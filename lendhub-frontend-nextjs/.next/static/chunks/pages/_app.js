/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/_app"],{

/***/ "(pages-dir-browser)/./node_modules/@adraffy/ens-normalize/dist/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@adraffy/ens-normalize/dist/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ens_beautify: () => (/* binding */ ens_beautify),\n/* harmony export */   ens_emoji: () => (/* binding */ ens_emoji),\n/* harmony export */   ens_normalize: () => (/* binding */ ens_normalize),\n/* harmony export */   ens_normalize_fragment: () => (/* binding */ ens_normalize_fragment),\n/* harmony export */   ens_split: () => (/* binding */ ens_split),\n/* harmony export */   ens_tokenize: () => (/* binding */ ens_tokenize),\n/* harmony export */   is_combining_mark: () => (/* binding */ is_combining_mark),\n/* harmony export */   nfc: () => (/* binding */ nfc),\n/* harmony export */   nfd: () => (/* binding */ nfd),\n/* harmony export */   safe_str_from_cps: () => (/* binding */ safe_str_from_cps),\n/* harmony export */   should_escape: () => (/* binding */ should_escape)\n/* harmony export */ });\n// created 2023-09-25T01:01:55.148Z\r\n// compressed base64-encoded blob for include-ens data\r\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\r\n// see: https://github.com/adraffy/ens-normalize.js#security\r\n// SHA-256: 0565ed049b9cf1614bb9e11ba7d8ac6a6fb96c893253d890f7e2b2884b9ded32\r\nvar COMPRESSED$1 = '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';\r\nconst FENCED = new Map([[8217,\"apostrophe\"],[8260,\"fraction slash\"],[12539,\"middle dot\"]]);\r\nconst NSM_MAX = 4;\r\n\r\nfunction decode_arithmetic(bytes) {\r\n\tlet pos = 0;\r\n\tfunction u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\r\n\t\r\n\t// decode the frequency table\r\n\tlet symbol_count = u16();\r\n\tlet total = 1;\r\n\tlet acc = [0, 1]; // first symbol has frequency 1\r\n\tfor (let i = 1; i < symbol_count; i++) {\r\n\t\tacc.push(total += u16());\r\n\t}\r\n\r\n\t// skip the sized-payload that the last 3 symbols index into\r\n\tlet skip = u16();\r\n\tlet pos_payload = pos;\r\n\tpos += skip;\r\n\r\n\tlet read_width = 0;\r\n\tlet read_buffer = 0; \r\n\tfunction read_bit() {\r\n\t\tif (read_width == 0) {\r\n\t\t\t// this will read beyond end of buffer\r\n\t\t\t// but (undefined|0) => zero pad\r\n\t\t\tread_buffer = (read_buffer << 8) | bytes[pos++];\r\n\t\t\tread_width = 8;\r\n\t\t}\r\n\t\treturn (read_buffer >> --read_width) & 1;\r\n\t}\r\n\r\n\tconst N = 31;\r\n\tconst FULL = 2**N;\r\n\tconst HALF = FULL >>> 1;\r\n\tconst QRTR = HALF >> 1;\r\n\tconst MASK = FULL - 1;\r\n\r\n\t// fill register\r\n\tlet register = 0;\r\n\tfor (let i = 0; i < N; i++) register = (register << 1) | read_bit();\r\n\r\n\tlet symbols = [];\r\n\tlet low = 0;\r\n\tlet range = FULL; // treat like a float\r\n\twhile (true) {\r\n\t\tlet value = Math.floor((((register - low + 1) * total) - 1) / range);\r\n\t\tlet start = 0;\r\n\t\tlet end = symbol_count;\r\n\t\twhile (end - start > 1) { // binary search\r\n\t\t\tlet mid = (start + end) >>> 1;\r\n\t\t\tif (value < acc[mid]) {\r\n\t\t\t\tend = mid;\r\n\t\t\t} else {\r\n\t\t\t\tstart = mid;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (start == 0) break; // first symbol is end mark\r\n\t\tsymbols.push(start);\r\n\t\tlet a = low + Math.floor(range * acc[start]   / total);\r\n\t\tlet b = low + Math.floor(range * acc[start+1] / total) - 1;\r\n\t\twhile (((a ^ b) & HALF) == 0) {\r\n\t\t\tregister = (register << 1) & MASK | read_bit();\r\n\t\t\ta = (a << 1) & MASK;\r\n\t\t\tb = (b << 1) & MASK | 1;\r\n\t\t}\r\n\t\twhile (a & ~b & QRTR) {\r\n\t\t\tregister = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\r\n\t\t\ta = (a << 1) ^ HALF;\r\n\t\t\tb = ((b ^ HALF) << 1) | HALF | 1;\r\n\t\t}\r\n\t\tlow = a;\r\n\t\trange = 1 + b - a;\r\n\t}\r\n\tlet offset = symbol_count - 4;\r\n\treturn symbols.map(x => { // index into payload\r\n\t\tswitch (x - offset) {\r\n\t\t\tcase 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 1: return offset + bytes[pos_payload++];\r\n\t\t\tdefault: return x - 1;\r\n\t\t}\r\n\t});\r\n}\t\r\n\r\n// returns an iterator which returns the next symbol\r\nfunction read_payload(v) {\r\n\tlet pos = 0;\r\n\treturn () => v[pos++];\r\n}\r\nfunction read_compressed_payload(s) {\r\n\treturn read_payload(decode_arithmetic(unsafe_atob(s)));\r\n}\r\n\r\n// unsafe in the sense:\r\n// expected well-formed Base64 w/o padding \r\n// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4\r\nfunction unsafe_atob(s) {\r\n\tlet lookup = [];\r\n\t[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);\r\n\tlet n = s.length;\r\n\tlet ret = new Uint8Array((6 * n) >> 3);\r\n\tfor (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\r\n\t\tcarry = (carry << 6) | lookup[s.charCodeAt(i)];\r\n\t\twidth += 6;\r\n\t\tif (width >= 8) {\r\n\t\t\tret[pos++] = (carry >> (width -= 8));\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\r\nfunction signed(i) { \r\n\treturn (i & 1) ? (~i >> 1) : (i >> 1);\r\n}\r\n\r\nfunction read_deltas(n, next) {\r\n\tlet v = Array(n);\r\n\tfor (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\r\n\treturn v;\r\n}\r\n\r\n// [123][5] => [0 3] [1 1] [0 0]\r\nfunction read_sorted(next, prev = 0) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet x = next();\r\n\t\tlet n = next();\r\n\t\tif (!n) break;\r\n\t\tprev += x;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tret.push(prev + i);\r\n\t\t}\r\n\t\tprev += n + 1;\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction read_sorted_arrays(next) {\r\n\treturn read_array_while(() => { \r\n\t\tlet v = read_sorted(next);\r\n\t\tif (v.length) return v;\r\n\t});\r\n}\r\n\r\n// returns map of x => ys\r\nfunction read_mapped(next) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet w = next();\r\n\t\tif (w == 0) break;\r\n\t\tret.push(read_linear_table(w, next));\r\n\t}\r\n\twhile (true) {\r\n\t\tlet w = next() - 1;\r\n\t\tif (w < 0) break;\r\n\t\tret.push(read_replacement_table(w, next));\r\n\t}\r\n\treturn ret.flat();\r\n}\r\n\r\n// read until next is falsy\r\n// return array of read values\r\nfunction read_array_while(next) {\r\n\tlet v = [];\r\n\twhile (true) {\r\n\t\tlet x = next(v.length);\r\n\t\tif (!x) break;\r\n\t\tv.push(x);\r\n\t}\r\n\treturn v;\r\n}\r\n\r\n// read w columns of length n\r\n// return as n rows of length w\r\nfunction read_transposed(n, w, next) {\r\n\tlet m = Array(n).fill().map(() => []);\r\n\tfor (let i = 0; i < w; i++) {\r\n\t\tread_deltas(n, next).forEach((x, j) => m[j].push(x));\r\n\t}\r\n\treturn m;\r\n}\r\n \r\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\r\n// where dx/dy = steps, n = run size, w = length of y\r\nfunction read_linear_table(w, next) {\r\n\tlet dx = 1 + next();\r\n\tlet dy = next();\r\n\tlet vN = read_array_while(next);\r\n\tlet m = read_transposed(vN.length, 1+w, next);\r\n\treturn m.flatMap((v, i) => {\r\n\t\tlet [x, ...ys] = v;\r\n\t\treturn Array(vN[i]).fill().map((_, j) => {\r\n\t\t\tlet j_dy = j * dy;\r\n\t\t\treturn [x + j * dx, ys.map(y => y + j_dy)];\r\n\t\t});\r\n\t});\r\n}\r\n\r\n// return [[x, ys...], ...]\r\n// where w = length of y\r\nfunction read_replacement_table(w, next) { \r\n\tlet n = 1 + next();\r\n\tlet m = read_transposed(n, 1+w, next);\r\n\treturn m.map(v => [v[0], v.slice(1)]);\r\n}\r\n\r\n\r\nfunction read_trie(next) {\r\n\tlet ret = [];\r\n\tlet sorted = read_sorted(next); \r\n\texpand(decode([]), []);\r\n\treturn ret; // not sorted\r\n\tfunction decode(Q) { // characters that lead into this node\r\n\t\tlet S = next(); // state: valid, save, check\r\n\t\tlet B = read_array_while(() => { // buckets leading to new nodes\r\n\t\t\tlet cps = read_sorted(next).map(i => sorted[i]);\r\n\t\t\tif (cps.length) return decode(cps);\r\n\t\t});\r\n\t\treturn {S, B, Q};\r\n\t}\r\n\tfunction expand({S, B}, cps, saved) {\r\n\t\tif (S & 4 && saved === cps[cps.length-1]) return;\r\n\t\tif (S & 2) saved = cps[cps.length-1];\r\n\t\tif (S & 1) ret.push(cps); \r\n\t\tfor (let br of B) {\r\n\t\t\tfor (let cp of br.Q) {\r\n\t\t\t\texpand(br, [...cps, cp], saved);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction hex_cp(cp) {\r\n\treturn cp.toString(16).toUpperCase().padStart(2, '0');\r\n}\r\n\r\nfunction quote_cp(cp) {\r\n\treturn `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\r\n}\r\n\r\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/\r\nfunction explode_cp(s) { // this is about 2x faster\r\n\tlet cps = [];\r\n\tfor (let pos = 0, len = s.length; pos < len; ) {\r\n\t\tlet cp = s.codePointAt(pos);\r\n\t\tpos += cp < 0x10000 ? 1 : 2;\r\n\t\tcps.push(cp);\r\n\t}\r\n\treturn cps;\r\n}\r\n\r\nfunction str_from_cps(cps) {\r\n\tconst chunk = 4096;\r\n\tlet len = cps.length;\r\n\tif (len < chunk) return String.fromCodePoint(...cps);\r\n\tlet buf = [];\r\n\tfor (let i = 0; i < len; ) {\r\n\t\tbuf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\r\n\t}\r\n\treturn buf.join('');\r\n}\r\n\r\nfunction compare_arrays(a, b) {\r\n\tlet n = a.length;\r\n\tlet c = n - b.length;\r\n\tfor (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];\r\n\treturn c;\r\n}\r\n\r\n// created 2023-09-25T01:01:55.148Z\r\n// compressed base64-encoded blob for include-nf data\r\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\r\n// see: https://github.com/adraffy/ens-normalize.js#security\r\n// SHA-256: a974b6f8541fc29d919bc85118af0a44015851fab5343f8679cb31be2bdb209e\r\nvar COMPRESSED = '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';\r\n\r\n// https://unicode.org/reports/tr15/\r\n// for reference implementation\r\n// see: /derive/nf.js\r\n\r\n\r\n// algorithmic hangul\r\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\r\nconst S0 = 0xAC00;\r\nconst L0 = 0x1100;\r\nconst V0 = 0x1161;\r\nconst T0 = 0x11A7;\r\nconst L_COUNT = 19;\r\nconst V_COUNT = 21;\r\nconst T_COUNT = 28;\r\nconst N_COUNT = V_COUNT * T_COUNT;\r\nconst S_COUNT = L_COUNT * N_COUNT;\r\nconst S1 = S0 + S_COUNT;\r\nconst L1 = L0 + L_COUNT;\r\nconst V1 = V0 + V_COUNT;\r\nconst T1 = T0 + T_COUNT;\r\n\r\nfunction unpack_cc(packed) {\r\n\treturn (packed >> 24) & 0xFF;\r\n}\r\nfunction unpack_cp(packed) {\r\n\treturn packed & 0xFFFFFF;\r\n}\r\n\r\nlet SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;\r\n\r\nfunction init$1() {\r\n\t//console.time('nf');\r\n\tlet r = read_compressed_payload(COMPRESSED);\r\n\tSHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map(x => [x, (i+1) << 24]))); // pre-shifted\r\n\tEXCLUSIONS = new Set(read_sorted(r));\r\n\tDECOMP = new Map();\r\n\tRECOMP = new Map();\r\n\tfor (let [cp, cps] of read_mapped(r)) {\r\n\t\tif (!EXCLUSIONS.has(cp) && cps.length == 2) {\r\n\t\t\tlet [a, b] = cps;\r\n\t\t\tlet bucket = RECOMP.get(a);\r\n\t\t\tif (!bucket) {\r\n\t\t\t\tbucket = new Map();\r\n\t\t\t\tRECOMP.set(a, bucket);\r\n\t\t\t}\r\n\t\t\tbucket.set(b, cp);\r\n\t\t}\r\n\t\tDECOMP.set(cp, cps.reverse()); // stored reversed\r\n\t}\r\n\t//console.timeEnd('nf');\r\n\t// 20230905: 11ms\r\n}\r\n\r\nfunction is_hangul(cp) {\r\n\treturn cp >= S0 && cp < S1;\r\n}\r\n\r\nfunction compose_pair(a, b) {\r\n\tif (a >= L0 && a < L1 && b >= V0 && b < V1) {\r\n\t\treturn S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\r\n\t} else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\r\n\t\treturn a + (b - T0);\r\n\t} else {\r\n\t\tlet recomp = RECOMP.get(a);\r\n\t\tif (recomp) {\r\n\t\t\trecomp = recomp.get(b);\r\n\t\t\tif (recomp) {\r\n\t\t\t\treturn recomp;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n}\r\n\r\nfunction decomposed(cps) {\r\n\tif (!SHIFTED_RANK) init$1();\r\n\tlet ret = [];\r\n\tlet buf = [];\r\n\tlet check_order = false;\r\n\tfunction add(cp) {\r\n\t\tlet cc = SHIFTED_RANK.get(cp);\r\n\t\tif (cc) {\r\n\t\t\tcheck_order = true;\r\n\t\t\tcp |= cc;\r\n\t\t}\r\n\t\tret.push(cp);\r\n\t}\r\n\tfor (let cp of cps) {\r\n\t\twhile (true) {\r\n\t\t\tif (cp < 0x80) {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t} else if (is_hangul(cp)) {\r\n\t\t\t\tlet s_index = cp - S0;\r\n\t\t\t\tlet l_index = s_index / N_COUNT | 0;\r\n\t\t\t\tlet v_index = (s_index % N_COUNT) / T_COUNT | 0;\r\n\t\t\t\tlet t_index = s_index % T_COUNT;\r\n\t\t\t\tadd(L0 + l_index);\r\n\t\t\t\tadd(V0 + v_index);\r\n\t\t\t\tif (t_index > 0) add(T0 + t_index);\r\n\t\t\t} else {\r\n\t\t\t\tlet mapped = DECOMP.get(cp);\r\n\t\t\t\tif (mapped) {\r\n\t\t\t\t\tbuf.push(...mapped);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tadd(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!buf.length) break;\r\n\t\t\tcp = buf.pop();\r\n\t\t}\r\n\t}\r\n\tif (check_order && ret.length > 1) {\r\n\t\tlet prev_cc = unpack_cc(ret[0]);\r\n\t\tfor (let i = 1; i < ret.length; i++) {\r\n\t\t\tlet cc = unpack_cc(ret[i]);\r\n\t\t\tif (cc == 0 || prev_cc <= cc) {\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlet j = i-1;\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet tmp = ret[j+1];\r\n\t\t\t\tret[j+1] = ret[j];\r\n\t\t\t\tret[j] = tmp;\r\n\t\t\t\tif (!j) break;\r\n\t\t\t\tprev_cc = unpack_cc(ret[--j]);\r\n\t\t\t\tif (prev_cc <= cc) break;\r\n\t\t\t}\r\n\t\t\tprev_cc = unpack_cc(ret[i]);\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction composed_from_decomposed(v) {\r\n\tlet ret = [];\r\n\tlet stack = [];\r\n\tlet prev_cp = -1;\r\n\tlet prev_cc = 0;\r\n\tfor (let packed of v) {\r\n\t\tlet cc = unpack_cc(packed);\r\n\t\tlet cp = unpack_cp(packed);\r\n\t\tif (prev_cp == -1) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t}\r\n\t\t} else if (prev_cc > 0 && prev_cc >= cc) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tret.push(prev_cp, ...stack);\r\n\t\t\t\tstack.length = 0;\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t}\r\n\t\t\tprev_cc = cc;\r\n\t\t} else {\r\n\t\t\tlet composed = compose_pair(prev_cp, cp);\r\n\t\t\tif (composed >= 0) {\r\n\t\t\t\tprev_cp = composed;\r\n\t\t\t} else if (prev_cc == 0 && cc == 0) {\r\n\t\t\t\tret.push(prev_cp);\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (prev_cp >= 0) {\r\n\t\tret.push(prev_cp, ...stack);\t\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// note: cps can be iterable\r\nfunction nfd(cps) {\r\n\treturn decomposed(cps).map(unpack_cp);\r\n}\r\nfunction nfc(cps) {\r\n\treturn composed_from_decomposed(decomposed(cps));\r\n}\r\n\r\nconst HYPHEN = 0x2D;\r\nconst STOP = 0x2E;\r\nconst STOP_CH = '.';\r\nconst FE0F = 0xFE0F;\r\nconst UNIQUE_PH = 1;\r\n\r\n// 20230913: replace [...v] with Array_from(v) to avoid large spreads\r\nconst Array_from = x => Array.from(x); // Array.from.bind(Array);\r\n\r\nfunction group_has_cp(g, cp) {\r\n\t// 20230913: keep primary and secondary distinct instead of creating valid union\r\n\treturn g.P.has(cp) || g.Q.has(cp);\r\n}\r\n\r\nclass Emoji extends Array {\r\n\tget is_emoji() { return true; } // free tagging system\r\n}\r\n\r\nlet MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;\r\n\r\nfunction init() {\r\n\tif (MAPPED) return;\r\n\t\r\n\tlet r = read_compressed_payload(COMPRESSED$1);\r\n\tconst read_sorted_array = () => read_sorted(r);\r\n\tconst read_sorted_set = () => new Set(read_sorted_array());\r\n\tconst set_add_many = (set, v) => v.forEach(x => set.add(x));\r\n\r\n\tMAPPED = new Map(read_mapped(r)); \r\n\tIGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints\r\n\r\n\t/*\r\n\t// direct include from payload is smaller than the decompression code\r\n\tconst FENCED = new Map(read_array_while(() => {\r\n\t\tlet cp = r();\r\n\t\tif (cp) return [cp, read_str(r())];\r\n\t}));\r\n\t*/\r\n\t// 20230217: we still need all CM for proper error formatting\r\n\t// but norm only needs NSM subset that are potentially-valid\r\n\tCM = read_sorted_array();\r\n\tNSM = new Set(read_sorted_array().map(i => CM[i]));\r\n\tCM = new Set(CM);\r\n\t\r\n\tESCAPE = read_sorted_set(); // characters that should not be printed\r\n\tNFC_CHECK = read_sorted_set(); // only needed to illustrate ens_tokenize() transformations\r\n\r\n\tlet chunks = read_sorted_arrays(r);\r\n\tlet unrestricted = r();\r\n\t//const read_chunked = () => new Set(read_sorted_array().flatMap(i => chunks[i]).concat(read_sorted_array()));\r\n\tconst read_chunked = () => {\r\n\t\t// 20230921: build set in parts, 2x faster\r\n\t\tlet set = new Set();\r\n\t\tread_sorted_array().forEach(i => set_add_many(set, chunks[i]));\r\n\t\tset_add_many(set, read_sorted_array());\r\n\t\treturn set; \r\n\t};\r\n\tGROUPS = read_array_while(i => {\r\n\t\t// minifier property mangling seems unsafe\r\n\t\t// so these are manually renamed to single chars\r\n\t\tlet N = read_array_while(r).map(x => x+0x60);\r\n\t\tif (N.length) {\r\n\t\t\tlet R = i >= unrestricted; // unrestricted then restricted\r\n\t\t\tN[0] -= 32; // capitalize\r\n\t\t\tN = str_from_cps(N);\r\n\t\t\tif (R) N=`Restricted[${N}]`;\r\n\t\t\tlet P = read_chunked(); // primary\r\n\t\t\tlet Q = read_chunked(); // secondary\r\n\t\t\tlet M = !r(); // not-whitelisted, check for NSM\r\n\t\t\t// *** this code currently isn't needed ***\r\n\t\t\t/*\r\n\t\t\tlet V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n\t\t\tlet M = r()-1; // number of combining mark\r\n\t\t\tif (M < 0) { // whitelisted\r\n\t\t\t\tM = new Map(read_array_while(() => {\r\n\t\t\t\t\tlet i = r();\r\n\t\t\t\t\tif (i) return [V[i-1], read_array_while(() => {\r\n\t\t\t\t\t\tlet v = read_array_while(r);\r\n\t\t\t\t\t\tif (v.length) return v.map(x => x-1);\r\n\t\t\t\t\t})];\r\n\t\t\t\t}));\r\n\t\t\t}*/\r\n\t\t\treturn {N, P, Q, M, R};\r\n\t\t}\r\n\t});\r\n\r\n\t// decode compressed wholes\r\n\tWHOLE_VALID = read_sorted_set();\r\n\tWHOLE_MAP = new Map();\r\n\tlet wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b) => a-b); // must be sorted\r\n\twholes.forEach((cp, i) => {\r\n\t\tlet d = r(); \r\n\t\tlet w = wholes[i] = d ? wholes[i-d] : {V: [], M: new Map()};\r\n\t\tw.V.push(cp); // add to member set\r\n\t\tif (!WHOLE_VALID.has(cp)) {\r\n\t\t\tWHOLE_MAP.set(cp, w);  // register with whole map\r\n\t\t}\r\n\t});\r\n\r\n\t// compute confusable-extent complements\r\n\t// usage: WHOLE_MAP.get(cp).M.get(cp) = complement set\r\n\tfor (let {V, M} of new Set(WHOLE_MAP.values())) {\r\n\t\t// connect all groups that have each whole character\r\n\t\tlet recs = [];\r\n\t\tfor (let cp of V) {\r\n\t\t\tlet gs = GROUPS.filter(g => group_has_cp(g, cp));\r\n\t\t\tlet rec = recs.find(({G}) => gs.some(g => G.has(g)));\r\n\t\t\tif (!rec) {\r\n\t\t\t\trec = {G: new Set(), V: []};\r\n\t\t\t\trecs.push(rec);\r\n\t\t\t}\r\n\t\t\trec.V.push(cp);\r\n\t\t\tset_add_many(rec.G, gs);\r\n\t\t}\r\n\t\t// per character cache groups which are not a member of the extent\r\n\t\tlet union = recs.flatMap(x => Array_from(x.G)); // all of the groups used by this whole\r\n\t\tfor (let {G, V} of recs) {\r\n\t\t\tlet complement = new Set(union.filter(g => !G.has(g))); // groups not covered by the extent\r\n\t\t\tfor (let cp of V) {\r\n\t\t\t\tM.set(cp, complement); // this is the same reference\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// compute valid set\r\n\t// 20230924: VALID was union but can be re-used\r\n\tVALID = new Set(); // exists in 1+ groups\r\n\tlet multi = new Set(); // exists in 2+ groups\r\n\tconst add_to_union = cp => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);\r\n\tfor (let g of GROUPS) {\r\n\t\tfor (let cp of g.P) add_to_union(cp);\r\n\t\tfor (let cp of g.Q) add_to_union(cp);\r\n\t}\r\n\t// dual purpose WHOLE_MAP: return placeholder if unique non-confusable\r\n\tfor (let cp of VALID) {\r\n\t\tif (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\r\n\t\t\tWHOLE_MAP.set(cp, UNIQUE_PH);\r\n\t\t}\r\n\t}\r\n\t// add all decomposed parts\r\n\t// see derive: \"Valid is Closed (via Brute-force)\"\r\n\tset_add_many(VALID, nfd(VALID));\r\n\t\r\n\t// decode emoji\r\n\t// 20230719: emoji are now fully-expanded to avoid quirk logic \r\n\tEMOJI_LIST = read_trie(r).map(v => Emoji.from(v)).sort(compare_arrays);\r\n\tEMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)\r\n\tfor (let cps of EMOJI_LIST) {\r\n\t\t// 20230719: change to *slightly* stricter algorithm which disallows \r\n\t\t// insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)\r\n\t\t// example: beautified [A B] (eg. flag emoji) \r\n\t\t//  before: allow: [A FE0F B], error: [A FE0F FE0F B] \r\n\t\t//   after: error: both\r\n\t\t// note: this code now matches ENSNormalize.{cs,java} logic\r\n\t\tlet prev = [EMOJI_ROOT];\r\n\t\tfor (let cp of cps) {\r\n\t\t\tlet next = prev.map(node => {\r\n\t\t\t\tlet child = node.get(cp);\r\n\t\t\t\tif (!child) {\r\n\t\t\t\t\t// should this be object? \r\n\t\t\t\t\t// (most have 1-2 items, few have many)\r\n\t\t\t\t\t// 20230719: no, v8 default map is 4?\r\n\t\t\t\t\tchild = new Map();\r\n\t\t\t\t\tnode.set(cp, child);\r\n\t\t\t\t}\r\n\t\t\t\treturn child;\r\n\t\t\t});\r\n\t\t\tif (cp === FE0F) {\r\n\t\t\t\tprev.push(...next); // less than 20 elements\r\n\t\t\t} else {\r\n\t\t\t\tprev = next;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (let x of prev) {\r\n\t\t\tx.V = cps;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// if escaped: {HEX}\r\n//       else: \"x\" {HEX}\r\nfunction quoted_cp(cp) {\r\n\treturn (should_escape(cp) ? '' : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);\r\n}\r\n\r\n// 20230211: some messages can be mixed-directional and result in spillover\r\n// use 200E after a quoted string to force the remainder of a string from \r\n// acquring the direction of the quote\r\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\r\nfunction bidi_qq(s) {\r\n\treturn `\"${s}\"\\u200E`; // strong LTR\r\n}\r\n\r\nfunction check_label_extension(cps) {\r\n\tif (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\r\n\t\tthrow new Error(`invalid label extension: \"${str_from_cps(cps.slice(0, 4))}\"`); // this can only be ascii so cant be bidi\r\n\t}\r\n}\r\nfunction check_leading_underscore(cps) {\r\n\tconst UNDERSCORE = 0x5F;\r\n\tfor (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {\r\n\t\tif (cps[--i] !== UNDERSCORE) {\r\n\t\t\tthrow new Error('underscore allowed only at start');\r\n\t\t}\r\n\t}\r\n}\r\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\r\nfunction check_fenced(cps) {\r\n\tlet cp = cps[0];\r\n\tlet prev = FENCED.get(cp);\r\n\tif (prev) throw error_placement(`leading ${prev}`);\r\n\tlet n = cps.length;\r\n\tlet last = -1; // prevents trailing from throwing\r\n\tfor (let i = 1; i < n; i++) {\r\n\t\tcp = cps[i];\r\n\t\tlet match = FENCED.get(cp);\r\n\t\tif (match) {\r\n\t\t\t// since cps[0] isn't fenced, cps[1] cannot throw\r\n\t\t\tif (last == i) throw error_placement(`${prev} + ${match}`);\r\n\t\t\tlast = i + 1;\r\n\t\t\tprev = match;\r\n\t\t}\r\n\t}\r\n\tif (last == n) throw error_placement(`trailing ${prev}`);\r\n}\r\n\r\n// create a safe to print string \r\n// invisibles are escaped\r\n// leading cm uses placeholder\r\n// if cps exceed max, middle truncate with ellipsis\r\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\r\n// note: in html, you'd call this function then replace [<>&] with entities\r\nfunction safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {\r\n\t//if (Number.isInteger(cps)) cps = [cps];\r\n\t//if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\r\n\tlet buf = [];\r\n\tif (is_combining_mark(cps[0])) buf.push('');\r\n\tif (cps.length > max) {\r\n\t\tmax >>= 1;\r\n\t\tcps = [...cps.slice(0, max), 0x2026, ...cps.slice(-max)];\r\n\t}\r\n\tlet prev = 0;\r\n\tlet n = cps.length;\r\n\tfor (let i = 0; i < n; i++) {\r\n\t\tlet cp = cps[i];\r\n\t\tif (should_escape(cp)) {\r\n\t\t\tbuf.push(str_from_cps(cps.slice(prev, i)));\r\n\t\t\tbuf.push(quoter(cp));\r\n\t\t\tprev = i + 1;\r\n\t\t}\r\n\t}\r\n\tbuf.push(str_from_cps(cps.slice(prev, n)));\r\n\treturn buf.join('');\r\n}\r\n\r\n// note: set(s) cannot be exposed because they can be modified\r\n// note: Object.freeze() doesn't work\r\nfunction is_combining_mark(cp) {\r\n\tinit();\r\n\treturn CM.has(cp);\r\n}\r\nfunction should_escape(cp) {\r\n\tinit();\r\n\treturn ESCAPE.has(cp);\r\n}\r\n\r\n// return all supported emoji as fully-qualified emoji \r\n// ordered by length then lexicographic \r\nfunction ens_emoji() {\r\n\tinit();\r\n\treturn EMOJI_LIST.map(x => x.slice()); // emoji are exposed so copy\r\n}\r\n\r\nfunction ens_normalize_fragment(frag, decompose) {\r\n\tinit();\r\n\tlet nf = decompose ? nfd : nfc;\r\n\treturn frag.split(STOP_CH).map(label => str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat())).join(STOP_CH);\r\n}\r\n\r\nfunction ens_normalize(name) {\r\n\treturn flatten(split(name, nfc, filter_fe0f));\r\n}\r\n\r\nfunction ens_beautify(name) {\r\n\tlet labels = split(name, nfc, x => x); // emoji not exposed\r\n\tfor (let {type, output, error} of labels) {\r\n\t\tif (error) break; // flatten will throw\r\n\r\n\t\t// replace leading/trailing hyphen\r\n\t\t// 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\r\n\t\t// not exactly the same in every font, but very similar: \"-\" vs \"\"\r\n\t\t/*\r\n\t\tconst UNICODE_HYPHEN = 0x2010;\r\n\t\t// maybe this should replace all for visual consistancy?\r\n\t\t// `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n\t\t//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n\t\tif (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n\t\tlet end = output.length-1;\r\n\t\tif (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n\t\t*/\r\n\t\t// 20230123: WHATWG URL uses \"CheckHyphens\" false\r\n\t\t// https://url.spec.whatwg.org/#idna\r\n\r\n\t\t// update ethereum symbol\r\n\t\t//  =>  if not greek\r\n\t\tif (type !== 'Greek') array_replace(output, 0x3BE, 0x39E);\r\n\r\n\t\t// 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\r\n\t\t// could be fixed with special case for: 2D (.) + 200E (LTR)\r\n\t\t// https://discuss.ens.domains/t/bidi-label-ordering-spoof/15824\r\n\t\t//output.splice(0, 0, 0x200E);\r\n\t}\r\n\treturn flatten(labels);\r\n}\r\n\r\nfunction array_replace(v, a, b) {\r\n\tlet prev = 0;\r\n\twhile (true) {\r\n\t\tlet next = v.indexOf(a, prev);\r\n\t\tif (next < 0) break;\r\n\t\tv[next] = b; \r\n\t\tprev = next + 1;\r\n\t}\r\n}\r\n\r\nfunction ens_split(name, preserve_emoji) {\r\n\treturn split(name, nfc, preserve_emoji ? x => x.slice() : filter_fe0f); // emoji are exposed so copy\r\n}\r\n\r\nfunction split(name, nf, ef) {\r\n\tif (!name) return []; // 20230719: empty name allowance\r\n\tinit();\r\n\tlet offset = 0;\r\n\t// https://unicode.org/reports/tr46/#Validity_Criteria\r\n\t// 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\r\n\treturn name.split(STOP_CH).map(label => {\r\n\t\tlet input = explode_cp(label);\r\n\t\tlet info = {\r\n\t\t\tinput,\r\n\t\t\toffset, // codepoint, not substring!\r\n\t\t};\r\n\t\toffset += input.length + 1; // + stop\r\n\t\ttry {\r\n\t\t\t// 1.) \"The label must be in Unicode Normalization Form NFC\"\r\n\t\t\tlet tokens = info.tokens = tokens_from_str(input, nf, ef);\r\n\t\t\tlet token_count = tokens.length;\r\n\t\t\tlet type;\r\n\t\t\tif (!token_count) { // the label was effectively empty (could of had ignored characters)\r\n\t\t\t\t//norm = [];\r\n\t\t\t\t//type = 'None'; // use this instead of next match, \"ASCII\"\r\n\t\t\t\t// 20230120: change to strict\r\n\t\t\t\t// https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\r\n\t\t\t\tthrow new Error(`empty label`);\r\n\t\t\t} \r\n\t\t\tlet norm = info.output = tokens.flat();\r\n\t\t\tcheck_leading_underscore(norm);\r\n\t\t\tlet emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);\r\n\t\t\tif (!emoji && norm.every(cp => cp < 0x80)) { // special case for ascii\r\n\t\t\t\t// 20230123: matches matches WHATWG, see note 3.3\r\n\t\t\t\tcheck_label_extension(norm); // only needed for ascii\r\n\t\t\t\t// cant have fenced\r\n\t\t\t\t// cant have cm\r\n\t\t\t\t// cant have wholes\r\n\t\t\t\t// see derive: \"Fastpath ASCII\"\r\n\t\t\t\ttype = 'ASCII';\r\n\t\t\t} else {\r\n\t\t\t\tlet chars = tokens.flatMap(x => x.is_emoji ? [] : x); // all of the nfc tokens concat together\r\n\t\t\t\tif (!chars.length) { // theres no text, just emoji\r\n\t\t\t\t\ttype = 'Emoji';\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// 5.) \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\r\n\t\t\t\t\tif (CM.has(norm[0])) throw error_placement('leading combining mark');\r\n\t\t\t\t\tfor (let i = 1; i < token_count; i++) { // we've already checked the first token\r\n\t\t\t\t\t\tlet cps = tokens[i];\r\n\t\t\t\t\t\tif (!cps.is_emoji && CM.has(cps[0])) { // every text token has emoji neighbors, eg. EtEEEtEt...\r\n\t\t\t\t\t\t\t// bidi_qq() not needed since emoji is LTR and cps is a CM\r\n\t\t\t\t\t\t\tthrow error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i-1])} + ${safe_str_from_cps([cps[0]])}\"`); \r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcheck_fenced(norm);\r\n\t\t\t\t\tlet unique = Array_from(new Set(chars));\r\n\t\t\t\t\tlet [g] = determine_group(unique); // take the first match\r\n\t\t\t\t\t// see derive: \"Matching Groups have Same CM Style\"\r\n\t\t\t\t\t// alternative: could form a hybrid type: Latin/Japanese/...\t\r\n\t\t\t\t\tcheck_group(g, chars); // need text in order\r\n\t\t\t\t\tcheck_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\r\n\t\t\t\t\ttype = g.N;\r\n\t\t\t\t\t// 20230121: consider exposing restricted flag\r\n\t\t\t\t\t// it's simpler to just check for 'Restricted'\r\n\t\t\t\t\t// or even better: type.endsWith(']')\r\n\t\t\t\t\t//if (g.R) info.restricted = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tinfo.type = type;\r\n\t\t} catch (err) {\r\n\t\t\tinfo.error = err; // use full error object\r\n\t\t}\r\n\t\treturn info;\r\n\t});\r\n}\r\n\r\nfunction check_whole(group, unique) {\r\n\tlet maker;\r\n\tlet shared = [];\r\n\tfor (let cp of unique) {\r\n\t\tlet whole = WHOLE_MAP.get(cp);\r\n\t\tif (whole === UNIQUE_PH) return; // unique, non-confusable\r\n\t\tif (whole) {\r\n\t\t\tlet set = whole.M.get(cp); // groups which have a character that look-like this character\r\n\t\t\tmaker = maker ? maker.filter(g => set.has(g)) : Array_from(set);\r\n\t\t\tif (!maker.length) return; // confusable intersection is empty\r\n\t\t} else {\r\n\t\t\tshared.push(cp); \r\n\t\t}\r\n\t}\r\n\tif (maker) {\r\n\t\t// we have 1+ confusable\r\n\t\t// check if any of the remaining groups\r\n\t\t// contain the shared characters too\r\n\t\tfor (let g of maker) {\r\n\t\t\tif (shared.every(cp => group_has_cp(g, cp))) {\r\n\t\t\t\tthrow new Error(`whole-script confusable: ${group.N}/${g.N}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// assumption: unique.size > 0\r\n// returns list of matching groups\r\nfunction determine_group(unique) {\r\n\tlet groups = GROUPS;\r\n\tfor (let cp of unique) {\r\n\t\t// note: we need to dodge CM that are whitelisted\r\n\t\t// but that code isn't currently necessary\r\n\t\tlet gs = groups.filter(g => group_has_cp(g, cp));\r\n\t\tif (!gs.length) {\r\n\t\t\tif (!GROUPS.some(g => group_has_cp(g, cp))) { \r\n\t\t\t\t// the character was composed of valid parts\r\n\t\t\t\t// but it's NFC form is invalid\r\n\t\t\t\t// 20230716: change to more exact statement, see: ENSNormalize.{cs,java}\r\n\t\t\t\t// note: this doesn't have to be a composition\r\n\t\t\t\t// 20230720: change to full check\r\n\t\t\t\tthrow error_disallowed(cp); // this should be rare\r\n\t\t\t} else {\r\n\t\t\t\t// there is no group that contains all these characters\r\n\t\t\t\t// throw using the highest priority group that matched\r\n\t\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\t\tthrow error_group_member(groups[0], cp);\r\n\t\t\t}\r\n\t\t}\r\n\t\tgroups = gs;\r\n\t\tif (gs.length == 1) break; // there is only one group left\r\n\t}\r\n\t// there are at least 1 group(s) with all of these characters\r\n\treturn groups;\r\n}\r\n\r\n// throw on first error\r\nfunction flatten(split) {\r\n\treturn split.map(({input, error, output}) => {\r\n\t\tif (error) {\r\n\t\t\t// don't print label again if just a single label\r\n\t\t\tlet msg = error.message;\r\n\t\t\t// bidi_qq() only necessary if msg is digits\r\n\t\t\tthrow new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`); \r\n\t\t}\r\n\t\treturn str_from_cps(output);\r\n\t}).join(STOP_CH);\r\n}\r\n\r\nfunction error_disallowed(cp) {\r\n\t// TODO: add cp to error?\r\n\treturn new Error(`disallowed character: ${quoted_cp(cp)}`); \r\n}\r\nfunction error_group_member(g, cp) {\r\n\tlet quoted = quoted_cp(cp);\r\n\tlet gg = GROUPS.find(g => g.P.has(cp)); // only check primary\r\n\tif (gg) {\r\n\t\tquoted = `${gg.N} ${quoted}`;\r\n\t}\r\n\treturn new Error(`illegal mixture: ${g.N} + ${quoted}`);\r\n}\r\nfunction error_placement(where) {\r\n\treturn new Error(`illegal placement: ${where}`);\r\n}\r\n\r\n// assumption: cps.length > 0\r\n// assumption: cps[0] isn't a CM\r\n// assumption: the previous character isn't an emoji\r\nfunction check_group(g, cps) {\r\n\tfor (let cp of cps) {\r\n\t\tif (!group_has_cp(g, cp)) {\r\n\t\t\t// for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\r\n\t\t\t// at the moment, it's unnecessary to introduce an extra error type\r\n\t\t\t// until there exists a whitelisted multi-character\r\n\t\t\t//   eg. if (M < 0 && is_combining_mark(cp)) { ... }\r\n\t\t\t// there are 3 cases:\r\n\t\t\t//   1. illegal cm for wrong group => mixture error\r\n\t\t\t//   2. illegal cm for same group => cm error\r\n\t\t\t//       requires set of whitelist cm per group: \r\n\t\t\t//        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))\r\n\t\t\t//   3. wrong group => mixture error\r\n\t\t\tthrow error_group_member(g, cp);\r\n\t\t}\r\n\t}\r\n\t//if (M >= 0) { // we have a known fixed cm count\r\n\tif (g.M) { // we need to check for NSM\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // see: assumption\r\n\t\t\t// 20230210: bugfix: using cps instead of decomposed h/t Carbon225\r\n\t\t\t/*\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t\t// 20230217: switch to NSM counting\r\n\t\t\t// https://www.unicode.org/reports/tr39/#Optional_Detection\r\n\t\t\tif (NSM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\tfor (let cp; j < e && NSM.has(cp = decomposed[j]); j++) {\r\n\t\t\t\t\t// a. Forbid sequences of the same nonspacing mark.\r\n\t\t\t\t\tfor (let k = i; k < j; k++) { // O(n^2) but n < 100\r\n\t\t\t\t\t\tif (decomposed[k] == cp) {\r\n\t\t\t\t\t\t\tthrow new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// parse to end so we have full nsm count\r\n\t\t\t\t// b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\r\n\t\t\t\tif (j - i > NSM_MAX) {\r\n\t\t\t\t\t// note: this slice starts with a base char or spacing-mark cm\r\n\t\t\t\t\tthrow new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${NSM_MAX})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// *** this code currently isn't needed ***\r\n\t/*\r\n\tlet cm_whitelist = M instanceof Map;\r\n\tfor (let i = 0, e = cps.length; i < e; ) {\r\n\t\tlet cp = cps[i++];\r\n\t\tlet seqs = cm_whitelist && M.get(cp);\r\n\t\tif (seqs) { \r\n\t\t\t// list of codepoints that can follow\r\n\t\t\t// if this exists, this will always be 1+\r\n\t\t\tlet j = i;\r\n\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\tlet cms = cps.slice(i, j);\r\n\t\t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n\t\t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n\t\t\ti = j;\r\n\t\t} else if (!V.has(cp)) {\r\n\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\tlet quoted = quoted_cp(cp);\r\n\t\t\tfor (let cp of cps) {\r\n\t\t\t\tlet u = UNIQUE.get(cp);\r\n\t\t\t\tif (u && u !== g) {\r\n\t\t\t\t\t// if both scripts are restricted this error is confusing\r\n\t\t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n\t\t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n\t\t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n\t\t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n\t\t}\r\n\t}\r\n\tif (!cm_whitelist) {\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n// given a list of codepoints\r\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\r\n// eg. explode_cp(\"abcd\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\r\n// 20230818: rename for 'process' name collision h/t Javarome\r\n// https://github.com/adraffy/ens-normalize.js/issues/23\r\nfunction tokens_from_str(input, nf, ef) {\r\n\tlet ret = [];\r\n\tlet chars = [];\r\n\tinput = input.slice().reverse(); // flip so we can pop\r\n\twhile (input.length) {\r\n\t\tlet emoji = consume_emoji_reversed(input);\r\n\t\tif (emoji) {\r\n\t\t\tif (chars.length) {\r\n\t\t\t\tret.push(nf(chars));\r\n\t\t\t\tchars = [];\r\n\t\t\t}\r\n\t\t\tret.push(ef(emoji));\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (VALID.has(cp)) {\r\n\t\t\t\tchars.push(cp);\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\tchars.push(...cps); // less than 10 elements\r\n\t\t\t\t} else if (!IGNORED.has(cp)) {\r\n\t\t\t\t\t// 20230912: unicode 15.1 changed the order of processing such that\r\n\t\t\t\t\t// disallowed parts are only rejected after NFC\r\n\t\t\t\t\t// https://unicode.org/reports/tr46/#Validity_Criteria\r\n\t\t\t\t\t// this doesn't impact normalization as of today\r\n\t\t\t\t\t// technically, this error can be removed as the group logic will apply similar logic\r\n\t\t\t\t\t// however the error type might be less clear\r\n\t\t\t\t\tthrow error_disallowed(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (chars.length) {\r\n\t\tret.push(nf(chars));\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction filter_fe0f(cps) {\r\n\treturn cps.filter(cp => cp != FE0F);\r\n}\r\n\r\n// given array of codepoints\r\n// returns the longest valid emoji sequence (or undefined if no match)\r\n// *MUTATES* the supplied array\r\n// disallows interleaved ignored characters\r\n// fills (optional) eaten array with matched codepoints\r\nfunction consume_emoji_reversed(cps, eaten) {\r\n\tlet node = EMOJI_ROOT;\r\n\tlet emoji;\r\n\tlet pos = cps.length;\r\n\twhile (pos) {\r\n\t\tnode = node.get(cps[--pos]);\r\n\t\tif (!node) break;\r\n\t\tlet {V} = node;\r\n\t\tif (V) { // this is a valid emoji (so far)\r\n\t\t\temoji = V;\r\n\t\t\tif (eaten) eaten.push(...cps.slice(pos).reverse()); // (optional) copy input, used for ens_tokenize()\r\n\t\t\tcps.length = pos; // truncate\r\n\t\t}\r\n\t}\r\n\treturn emoji;\r\n}\r\n\r\n// ************************************************************\r\n// tokenizer \r\n\r\nconst TY_VALID = 'valid';\r\nconst TY_MAPPED = 'mapped';\r\nconst TY_IGNORED = 'ignored';\r\nconst TY_DISALLOWED = 'disallowed';\r\nconst TY_EMOJI = 'emoji';\r\nconst TY_NFC = 'nfc';\r\nconst TY_STOP = 'stop';\r\n\r\nfunction ens_tokenize(name, {\r\n\tnf = true, // collapse unnormalized runs into a single token\r\n} = {}) {\r\n\tinit();\r\n\tlet input = explode_cp(name).reverse();\r\n\tlet eaten = [];\r\n\tlet tokens = [];\r\n\twhile (input.length) {\r\n\t\tlet emoji = consume_emoji_reversed(input, eaten);\r\n\t\tif (emoji) {\r\n\t\t\ttokens.push({\r\n\t\t\t\ttype: TY_EMOJI,\r\n\t\t\t\temoji: emoji.slice(), // copy emoji\r\n\t\t\t\tinput: eaten,\r\n\t\t\t\tcps: filter_fe0f(emoji)\r\n\t\t\t});\r\n\t\t\teaten = []; // reset buffer\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (cp == STOP) {\r\n\t\t\t\ttokens.push({type: TY_STOP, cp});\r\n\t\t\t} else if (VALID.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_VALID, cps: [cp]});\r\n\t\t\t} else if (IGNORED.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_IGNORED, cp});\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\ttokens.push({type: TY_MAPPED, cp, cps: cps.slice()});\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokens.push({type: TY_DISALLOWED, cp});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (nf) {\r\n\t\tfor (let i = 0, start = -1; i < tokens.length; i++) {\r\n\t\t\tlet token = tokens[i];\r\n\t\t\tif (is_valid_or_mapped(token.type)) {\r\n\t\t\t\tif (requires_check(token.cps)) { // normalization might be needed\r\n\t\t\t\t\tlet end = i + 1;\r\n\t\t\t\t\tfor (let pos = end; pos < tokens.length; pos++) { // find adjacent text\r\n\t\t\t\t\t\tlet {type, cps} = tokens[pos];\r\n\t\t\t\t\t\tif (is_valid_or_mapped(type)) {\r\n\t\t\t\t\t\t\tif (!requires_check(cps)) break;\r\n\t\t\t\t\t\t\tend = pos + 1;\r\n\t\t\t\t\t\t} else if (type !== TY_IGNORED) { // || type !== TY_DISALLOWED) { \r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (start < 0) start = i;\r\n\t\t\t\t\tlet slice = tokens.slice(start, end);\r\n\t\t\t\t\tlet cps0 = slice.flatMap(x => is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\r\n\t\t\t\t\tlet cps = nfc(cps0);\r\n\t\t\t\t\tif (compare_arrays(cps, cps0)) { // bundle into an nfc token\r\n\t\t\t\t\t\ttokens.splice(start, end - start, {\r\n\t\t\t\t\t\t\ttype: TY_NFC, \r\n\t\t\t\t\t\t\tinput: cps0, // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps\r\n\t\t\t\t\t\t\tcps, \r\n\t\t\t\t\t\t\ttokens0: collapse_valid_tokens(slice),\r\n\t\t\t\t\t\t\ttokens: ens_tokenize(str_from_cps(cps), {nf: false})\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\ti = start;\r\n\t\t\t\t\t} else { \r\n\t\t\t\t\t\ti = end - 1; // skip to end of slice\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstart = -1; // reset\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstart = i; // remember last\r\n\t\t\t\t}\r\n\t\t\t} else if (token.type !== TY_IGNORED) { // 20221024: is this correct?\r\n\t\t\t\tstart = -1; // reset\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn collapse_valid_tokens(tokens);\r\n}\r\n\r\nfunction is_valid_or_mapped(type) {\r\n\treturn type == TY_VALID || type == TY_MAPPED;\r\n}\r\n\r\nfunction requires_check(cps) {\r\n\treturn cps.some(cp => NFC_CHECK.has(cp));\r\n}\r\n\r\nfunction collapse_valid_tokens(tokens) {\r\n\tfor (let i = 0; i < tokens.length; i++) {\r\n\t\tif (tokens[i].type == TY_VALID) {\r\n\t\t\tlet j = i + 1;\r\n\t\t\twhile (j < tokens.length && tokens[j].type == TY_VALID) j++;\r\n\t\t\ttokens.splice(i, j - i, {type: TY_VALID, cps: tokens.slice(i, j).flatMap(x => x.cps)});\r\n\t\t}\r\n\t}\r\n\treturn tokens;\r\n}\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYWRyYWZmeS9lbnMtbm9ybWFsaXplL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEIsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsVUFBVTtBQUNWO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEVBQUUsWUFBWSxHQUFHLDhCQUE4QixFQUFFO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsbUNBQW1DLFdBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtB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UDtBQUNBLE9BQU87QUFDUCxtQkFBbUI7QUFDbkI7QUFDQSxpQkFBaUI7QUFDakIsTUFBTTtBQUNOLGdCQUFnQjtBQUNoQjtBQUNBLEtBQUssc0NBQXNDO0FBQzNDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0REFBNEQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrSyIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcQGFkcmFmZnlcXGVucy1ub3JtYWxpemVcXGRpc3RcXGluZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjcmVhdGVkIDIwMjMtMDktMjVUMDE6MDE6NTUuMTQ4WlxyXG4vLyBjb21wcmVzc2VkIGJhc2U2NC1lbmNvZGVkIGJsb2IgZm9yIGluY2x1ZGUtZW5zIGRhdGFcclxuLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzL2Jsb2IvbWFpbi9zcmMvbWFrZS5qc1xyXG4vLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMjc2VjdXJpdHlcclxuLy8gU0hBLTI1NjogMDU2NWVkMDQ5YjljZjE2MTRiYjllMTFiYTdkOGFjNmE2ZmI5NmM4OTMyNTNkODkwZjdlMmIyODg0YjlkZWQzMlxyXG52YXIgQ09NUFJFU1NFRCQxID0gJ0FFRVVkd21nRFM4QnhRS0tBUDRCT2dEakFUQUFuZ0RVQUlNQW9BQm9BT0FBYWdDT0FFUUFoQUJNQUhJQU93QTlBQ3NBTmdBbUFHSUFIZ0F1QUNnQUp3QVhBQzBBR2dBakFCOEFMd0FVQUNrQUVnQWVBQWtBR3dBUkFCa0FGZ0E1QUNnQUxRQXJBRGNBRlFBcEFCQUFIZ0FpQUJBQUdnQWVBQk1BR0FVaEJlOEJGeFJFTjhzRjJ3QzVBSzVIQVc4QXJRa0R6UUN1aHpjM056Y0JQNjhORWZNQUJRZEhCdXc1QlY4RllBQTlNemtJOXI0WkJnN1F5UUFXQTlDZU93TE5DamNDanFrQ2h1QS9sbStSQXNYVEFvUDZBU2ZuRVFEeXRRRkpBaldWQ2tlWEFPc0E2Z29kQUIvY3dkQVVFMFdsQkNOL0FRVUNRUmpGRC9NUkJqSHhEUVNKYncwakJ6VUFzd0J4bWUrdG5JY0FZd2FiQXlzRzhRQWpBRU1NbXhjRHFnUEtReURYQ01NeEE3a1VRd0QzTlhPckFLbUZJQUFmQkMwRDN4NEJKUURCR2RVRkFoRWdWRDhKbndtUUppTldZVXpyZzBvQUd3QVVBQjBBRm5OY0FDa0FGZ0JQOWgzZ1Bmc0RPV0RLbmVZMkNoZ2xYMVVEWUQzMEFCc0FGQUFkQUJaeklHUkFud0REOHdBakFFRU16UmJEcWdNQjJzQUZZd1hxQXRDbkFzUzRBd3BVSktSdEZIc2FkVXo5QU1NVmJ3THBBQk0xTkpFWDBaa0NnWU1CRXlNQXhSVnZBdWtBRXpVQlVGQXRtVXdTQXk0REJURVIzM0VmdFFIZlN3QjVNeEovQWprV0tRTHpMOEUvY3dCQjZRSDlMUURQRHRPOUFTTnJpUUM1RFFBTkF3Q0syMUVGSTkxekh3Q29MOWtCcVFjSEJ3Y0hLelVEb3dCdkFRb2hQdlUzZkFRZ0h3Q3lBYzhDS1FNQTV6TVNlenI3VUxnRm1EcC9MelZRQmdFR0FpOEZZUVZndDhBRmNUdGxRaHBDV0VtZmU1dG1aNklBRXhzRHpROHQrWDhyQkt0VEFsdGJBbjBqc3k4Qmw2dXRQV01EVFI4RWkya1JBTmtEQnJOSE55c0RCekVDUVdVQWN3RnBKM2tBaXlVaEFKMEJVYjhBTDNFZkFiZk5BejgxS1VzRld3RjNZUVp0QW0wQStWRWZBekVKRFFCUlNRQ3pBUUJsQUhzQU03MEdEL3YzSVpXSEJ3QVJLUUF4QUxzalR3SFpBZU1QRXptWGdJSHdBQklBR1FBOEFFVUFRRHQzZ2R2SUVHY1FaQWtHVFJGTWRFSVZFd0swRDY0TDdSRWRETmtxMDlQZ0FEU3hCL01EV3dmekExc0RXd2Z6Qi9NRFd3ZnpBMXNEV3dOYkExc2NFdkFpMjhnUVp3OVFCSFVGbGdXVEJONElpeVpSRVlrSE1BamFWQlYwSmh4UEEwMEJCQ010U1NRN216TVRKVXBNRkUwTENBUTJTbXl2ZlVBRFR6R3pWUDJRcWdQVE1sYzVkQWtHSG5rU3FBQXlEM3NrTmIxT2hucFBjYWdLVTArMnRZZEphazV2QXNZNnNFQUFDaWtKbTIvRGQxWUdSUkFmSjZrUSt3dzNBYmtCUHczeFM5d0U5UVkvQk0wZmdSa2REOUdWb0FpcExlRU04U2JuTHFXQVhpUDVLb2NGOFV2NFBPRUxVVkZzRDEwTGFRbm5PbWVCVWdNbEFSRWlqd3JoRFQwSWNSRDNDczF2RGVrUlNRYzlBOWxKbmdDcEJ3VUxGUjA1RmJrbUZHS3dDdzA1ZXdiL0d2b0xreWF6RXkxN0FBWFhHaVVHVVFFdEd3TUEweTdyaGJSYU5Wd2dUMk1HQndzcEk4c1VyRkFrRFNsQXUzaE1HaDhIR1NXdEFwVkRkRXFMVVRvZWx5SDZQRUVOYWk0WFVZQUgrVHdKR1ZNTGhUeWlScTlGRWhIV1BwRTlUQ0pOVERBRU9ZTXNNeWVQQ2RNUGlReTlmSFlCWFFrbENiVU1kUk0xRVJzM3lRZzlCeDB4bHlnbkdRZ2xScGxnbmdUN293UDNFOVVERHdWRENVVUhGd081SERFVE1oVXRCUkdCS05zQzl6YlpMcmNDazFhRUFSc0Z6dzhwSCtNUVZFZmtEdTBJbndKcEE0Y2w3d0F4RlNVQUd5S2ZDRWRuQUdPUDNGTUpMczhJeTJwd0kzZ0RheFRyWlJGM0I1VU9Xd2VySERjVnd4emxjTXhlRDRZTUtLZXpDVjhCZVFtZEFXTUU1d2dOTlYrTXBDQkZaMWVMWEJpZklHVkJRMTRBQWpVTWFSV2pSTUdIZkFLUEQyOFNId0U1QVhjSFBRMEZBbnNSOFJGdkVKa0k3NFlJTmJrei9Eb3BCRk1oaHlBVkNpc0RVMnpTQ3lzbS9RejhiUUduRW1ZREVEUkJkL0pucjJDNktCZ0JCeDB5eVVGa0lmVUxsay9SREtBYXhSaEdWRElaNkFmREEvY2E5eWZ1UVZzR0F3T25CeGM2VVRQeUJNRUxiUWlQQ1VNQVRRNm5Hd2ZiR0c0S2RZelVBVFdQQWJ1ZEExdVZod0p6a3dZN0J3OEFhdytMQlgzcEFDRUNxd2luQUFrQTB3TmJBRDBDc1FlaEFCMEFpVVVCUVFNck13RWw2UUtUQTVjSU5jOEJtVE1COXkwRUg4Y01HUUQ3TzI1T0FzTzFBb0J1WnFZRjRWd0NrZ0pOT1FGUktRUUpVa3RWQTdOMTVRRGZBRThHRitOTEFSbXZUczhlNTBjQjQzTXZBTXNBL3dBSk9RY0pSUUhSQWZkeEFMc0JZd3MxQ2FhM3VRRlI3UzBBaHdBWmJ3SGJBbzBBNFFBNUFJUDFBVmNBVVFWZC9RWFhBbE5OQVJVMUhDOWJaUUcvQXlNQk53RVJBSDBHejVHcHpRc2pCSEVIMXdJUUh4WGxBdTh5QjdrRkF5TGpFOUZDeVFLOTRsa0FNaG9LUEFxckNxcGdYMlEzQ2pWMlBWUUFFaCtzUHNzL1VnVlZPMWM3WER0WE8xdzdWenRjTzFjN1hEdFhPMXdEbThQbXcrWUtjRjlKWWU4TXFnM1lSTXc2VFJQZllGVmdOaFBNTGJzVXhSWFNKVm9aUVJyQUp3a2w2RlVORHdndDEyWTBDREEwZVJmQUFFTXBiSU5GWTRvZU5BcFBIT3RUbFZUOExSOEF0VXVtTTdNTnNCc1pSRVFGUzNYeFlpNFdFZ29tQW1TRkFtSkdYMUd6QVY4M0pBS2grd0pvbkFKbURRS2ZpRGdmRHdKbVB3Sm1LZ1J5QklNRGZ4Y0RmcFk1Q2psN0d6bUdPaWNuQW13aEFqSTZPQTRDYmNzQ2JiTHpqZ00zYTBrdkFXc0E0Z0RsQUU0SkI1d01rUUVDRDhZQUVia0Nkek1DZHFaREFubFBSd0o0dmlGZzMwV3lSdmNDZkVNQ2Vzd0NmUTBDZlBSSUJFaUJaeWdBTHhsSlhFcGZHUnRLMEFMUkJRTFEwRXNyQTRoVEE0ZnFSTW1STmdMeXBWMEhBd095UzlKTU1Ta0gwMDFRVGJNQ2kwTUNpdHpGSHdzaFIyc0p1d0tPT3dLT1lFU2JoUUtPM1FLT1lIeFJ1Rk01QVE1UzJGU0pBcFAvQXBNUUFPMEFJRlVpVmJOVjFBb3NIeW1aaWpMbGVHcEZQejBDbDZNQzc3WllKYXdBWFNrQ2xwTUNsb0NnQUsxWnNGb05oVkVBUHdLV3VRS1dVbHhJWE5VQ21jOENtV2hjemwwTEhRS2Nuem5HT3FFQ25Cb0NuNThDbnJ5T0FDRVROUzRUQXAzMUFwNldBTGxCWVRoaDh3S2Uxd0tnY2dHdEFwNmpJd0tlVXFsanpHUXJLUzhDSjdNQ0pvSUNvUDhDb0ZEYkFxWXpBcVhTQXFnREFJRUNwL1pvZ0dpMUFBZE5haUJxMVFLczV3S3NzZ0t0YXdLdEJnSlhJUUpWNEFLeDVkc0RIMUpzbXdLeXdSRUNzdXdiYk9SdFoyMU1Zd01sMFFLMllEOURicFFES1VrQ3VHSUN1VXNaQXJrdWUzQTZjT1VDdlIwRExiWURNaFVDdm94eUJnTXpkUUsrSG5NbWMxTUN3ODhDd3doemhuUlBPVWwwNUFNOHF3RURQSjREUGNNQ3hZQUN4a3NDeGhTTkFzaHRWUUxJU0FMSlV3TEpNZ0prb1FMZDFuaDlaWGl5ZVNsTDFBTVlwMmNHQW1INEdmZVZLSHNQWHBaZXZ4VUN6MjhDejNBelQxZlc5eGVqQU1xeEFzOTNBUzN1QTA0V2ZrOEpBdHdyQXR1T0F0SlRBMUpnQTFOakFRVURWWkNBalVNRXp4cnhaRWw1QTRMU2c1RUMyc3NDMmVLRUZJUk5wMEFEaHFrQU13TmtFb1oxWGYwQVdRTGZhUUxldkhkN0F1SXo3UmdCOHpRckFmU2ZBZkxXaXdMcjl3THBkSDBEQXVyOUF1cm9BUDFMQWIwQzdvMEM2NkNXcnBjSEF1NURBNFhrbUgxdzVIR2xBdk1IQUcwRGpocVpsd0wzRndPUmNnT1Npd0wzbkFMNTNRTDRhcG9nbXErL081c2lBNTJIQXY3K0FSOEFQWjhnQVorM0F3V1JBNlp1QTZiZEFOWEpBd1p1b1l5aUNRMERERTBCRXdFakIzRUdaYjFyQ1FDL0JHL0RGWThldHhFQUczazlBQ2NETnhKUkE0MkRBV2NySlFDTTh3QWxBT2FuQzZPVkNMc0dJNmZKQmdDdkJSbkRCdkVsUlVZRkZvQUZjRDlHU0ROQ0tVSzhYM2taWDhRQWxzMEZPZ0NRVkNHYndUc3VZRG9adXRjT054ak9HSkhKL2dWZkJXQUZYd1ZnQldzRllBVmZCV0FGWHdWZ0JWOEZZQVZmQldCT0hRamZqVzhLQ2dvS2JGN3hNd1RSQTdrR044UERBTU1FcjhNQTcwZ3hGcm9GVGo1eFBuaENSMEsrWDMwL1gvQUFXQmt6c3dDTkJzeHp6QVNtNzBhQ1JTNHJERE1lTHo0OWZuWGZjc0g1R2Nvc2NRRnoxM1k0SHdWbkJYTEp5Y25BQ05kUll3Z0lDQXFFWG9XVHhnQTdQNGtBQ3hiWkJ1MjFLdzBBak1zVEF3a1ZBT1Z0SlVVc0oxSkN1VUxFU1VBclh5OWdQaTlBS3duSlJRWUtURDlMUG9BK2lUNTRQbmtDa1VMRVVVcERYOU5XVjNKVkVqUUFjMXczQTNJQkUzWW5YK2c3UWlNSmI2TUthaXN6UkNVdVFyTkN4RFBNQ2N3RVg5RVdKellSRUJFRUJ3SUhLbjZsMzNKQ05WSWZ5YlBKdEFsdHlkUFVDbWhCWncvdEVLc1pBSk9WSlUxQ0xSdXhiVUhPUUFvN1AwcytlRUpISEE4U0pWUlBkR00wTlZycHZCb0toZlVsTTBKSEhHVVFVaEVXTzF4TFNqOE1PMHVjTkFxSkl6VkNSeHY5RUZzcUt5QTRPUWdOajJud1pncDVaTkZnRTJBMUszWUhTMkFoUVFvakptQzdEZ3B6R0cxV1lGVVpDUVlIWk85Z0hXQ2RZSVZndTJCVFlKbHdGaDhHdlJiY1hiRzhZZ3RESHJNQnd6UFZ5UW9uSFFna0N5WUJnUUowQWpjNG5WcUlBd0dTQ3NCUElnRHNLM1NXRXRJVkJhNU44Z0dqQW8ra1Z3Vklad0QvQUVVU0NEd2VYNElUclJRc0o4SzNUd0JYRkR3RUFCMFR2elZjQXRvVFMyMFJJd0RnVmdaOUJCSW1ZZ0E1QUw0Q29pOExGbmV6T2tDbklRRmpBWTRLQkFQaDlSY0dzZ1pTQnNFQUpjdGRzV0lSdTJrVGtRc3RSdzdEQWNNQktncFBCR0lHTURBd0tDWW5LVFFhTGc0QUtSU1ZBRndDZGwrWVVaMEpkaWNGRDNsUEFkdDFGOVpaS0NHeHVFM3lCeGtGVkdjQS93QkZFZ2lDQndBT0xIUVNqeE90UURnMXo3ZGVGUk1BWjhRVEFHdEtiMUFwSWlQSEFEa0F2Z0tpTHkxREZ0WUNtQmlEQWxERFdOQjBlbzdmcGFNTy9hRVZSUnYwQVRFUVpCSU9EeU1FQWM4SlFoQ2JEUmd6RkQ0VEFFTUF1OVlCQ2dDc0FPa0FtNUkzQUJ3QVl4dk9OblIrTWhYSkF4Z0tReXhMMitra0poTWJoUUtEQk1rU3N2RjBBRDlCTlE2dVFDN1dxU1FId3hFQUVFSXUxaGtoQUgyejRpUVB3eUpQSE5XcGR5WUJSU3BuSkFMem9CQUVWUFBzSDIwTXhBMENDRVFLUmdBRnlBdEZBbE1Od3dqRURVUUpSQXJFTHRhcE1nN0REWmdKSXcrVEd1a0VJd3ZERmtNQXFBdERFTU1NQmhpb2UrUUFPM01NUkFBQ3JnbkVCU1BZOVEwRkRuYlNCb01BQjhNU1l4a1N4QUVKQVBJSkFBQjhGV01PRnRNYy9IY1h3eGhEQUM3REF2T293d0Fld3dKZEtES0hBQUhEQUFMckZVUVZ3d0Fid3l2enBXTVd2OHdBL0FCcEF5KytiY1lEVUtQRDBLaERDd0ttSjFNQUFtTUE1K1Vad3hBYWd3aXBCUkwvZUFEZnc2ZkRHT01DR3NPamszbDZCd09wbzRzQUVzTU9HeE1BQTVzQWJjTU9BQXZEcDBNSkdrTUR3Z2lwbk5JUEF3ZklxVU1HQU9HREFBUHpBQlhEQUFjREFBbkRBR21UQUJyREFBN0RDaGpEam5FV0F3QUJZd0FPY3dBdVV5WUFCc01BRjhNSUtRQU5VZ0M2d3k0QUE4TUFEcU1xOHdDeVlnQWNJd0FCOHdxcEFBWE9DeDBWNHdBSG93QkN3d0VLQUduREFBdURBQjNEQUFqRENha0FCZElBYnFjWjNRQ1pDQ2tBQmRJQUFBRkRBQWZqQUIyakNDa0FCcUlBQ1lNQUd6TUFiU01BNXNPSUFBaGpBQWhEQUJUREJBa3BBQWJTQU9PVEFBbERDNmtPelB0bkFBZERBRzZrUUZBQVR3QUt3d3dBQTBNQUNiVURQd0FISXdBWmd3QUNFNmNEQUFvakFBcERBQW9EcC9NR3d3QUpJd0FERXdBUVF3Z0FGRU1BRVhNQUQ1TUFEZk1BRGNNQUdSTU9GaU1BRlVNQWJxTVd1d0hEQU1JQUUwTUxBR2t6RWdEaFV3QUNRd0FFV2dBWGd3VWpBQWJZQUJqREJTWUJnekJhQUVGTkFMY1FCeFVNZWdBd01uZ0JyQTBJWmdKMEt4UUhCUkVQZDFOMFp6S1JKd2FJSEFacU5UNERxUXE4QnduZ0FCNERBd3QyQVg1NlQxb2NLUU5YQWgxR0FUUUdDM3RPeFlOYWdrZ0FNUUE1Q1FBREFRRUFXeExqQUlPWU5BRXpBSDd0RlJrNlRnbFNBRjhOQUFsWUFRK1MxQUNBUXdRb3JRQmlBTjRkQUoxd1B5ZVRBTlZ6dVFEWDNBSWVFTXA5ZXlNZ1hpVUFFZGtCa0ppektsdGJWVkFhUk1xUkFBRUFoeVEvU0RFejZCbWZWd0I2QVRFc09DbEtJUmNET0YwRS84MzJBRk50NUFCeUFua0NSeEdDT3M5NE5qWGRBd0lOR0JvbkRCd1BBTFcyQXdJQ0FnQUFBQUFBQUFZREJRTURBUnJVQXdBdEFBQUFBZ0VHQmdZR0JnWUZCUVVGQlFVRUJRWUhDQWtFQlFVRkJRUUFBQUlDQUFBQUlnQ05BSkFBbFQwQTZnQzdBTndBcEVRQXdnQ3lBSzBBcUFEdUFLWUEyZ0NqQU9jQkNBRURBTWNBZ1FCaUFOSUExQUVEQU40QThnQ1FBS2tCTVFEcUFOOEEzQXNCQ1E4eU85cmEydHE4eHVMVDF0UkpPQjBCVWdGY05VMEJXZ0ZwQVdnQld3Rk1VVWxMYmhNQlV4c05FQXM2UGhNT0FDY1VLeTB2TWo1QVFFTkRRMFJGRkVZR0pGZFhWMWRaV1ZoWkwxcGJYVnhjSTJObloyWm9aeXBzYm5aMWVIaDRlSGg0ZW5wNmVucDZlbnA2ZW5wOGZIMThlMklBUlBJQVNRQ2FBSGdBTWdCbStBQ09BRmNBVndBM0FuYnZBSXNBQmZqNEFHUUFrL0lBbndCUEFHSUFaUC8vc0FDRkFJVUFhUUJXQUxFQUpBQzJBSU1DUUFKREFQd0E1d0QrQVA0QTZBRC9BT2tBNlFEb0FPWUFMd0o3QVZFQlFBRStBVlFCUGdFK0FUNEJPUUU0QVRnQk9BRWNBVmdYQURFUUNBRUFVeDhTSGdzZEhoWUFqZ0NXQUtZQVVRQnFJQUl4QUhZQWJ3Q1hBeFVESnpJRElVbEdUekVBa1FKUEFNY0NWd0trQU1BQ2xnS1dBcFlDbGdLV0FwWUNpd0tXQXBZQ2xnS1dBcFlDbGdLVkFwVUNtQUtnQXBjQ2xnS1dBcFFDbEFLVUFwUUNrZ0tWQW5VQjFBS1hBcDhDbGdLV0FwVWVBSUVUQlFEK0RRT2ZBbUVDT2g4QlZCZzlBdUlaRWpNYkFVNC9HMVdaQVh1c1JBRnBZUUVGQTBGUEFRWUFtVEVlSUpkeUFERm9BSEVBTmdDUkE1ek1rL0MyakdJTndqTVd5Z0laQ2FYZGZESUxCQ3M1ZEFFN1luUUJ1Z0RsaG9pSGhvaUdpWXFLaG91T2pJYU5rSTZJajRxUWlwR0drb2FUaHBTU2xZYVdocGVLbUlhWmhwcUdtNGFjaTUyUW5vcWZodUlDNFhUcEF0OTBBSXAwTEhTb0FJc0FkSFFFUXdSQUJFSUVSUVJEQkVrRVJnUkJCRWNFU1FSSUJFUUVSZ1JKQUo1dWRBQ3JBNDkwQUx4dUFRMTBBTkZaZEhRQTEzUUNGSFFBL21KMEFQNEJJUUQrQVB3QS9BRDlBUHdEaEdaMDNBU01LMjNIQVA0QS9BRDhBUDBBL0NSMGRBQ1JZblFBL2dDUkFTRUEvZ0NSQXZRQS9nQ1JBNFJtZE53RWpDdHR4eVIwQVA5aWRBRWhBUDRBL2dEOEFQd0EvUUQ4QVA4QS9BRDhBUDBBL0FPRVpuVGNCSXdyYmNja2RIUUFrV0owQVNFQS9nQ1JBUDRBa1FMMEFQNEFrUU9FWm5UY0JJd3JiY2NrZEFKTEFUNTBBbElCUVhRQ1U4bDBkQUpmZEhRRHBnTDBBNllEcGdPbkE2Y0Rwd09uQTRSbWROd0VqQ3R0eHlSMGRBQ1JZblFCSVFPbUFKRURwZ0NSQXZRRHBnQ1JBNFJtZE53RWpDdHR4eVIwQkRoMEFKRUVPUUNSRHBVNWRTZ0NBRFIwM2dWMkN3QXJkQUVGQU01aUNuUjBBRjFpQUFZY09ncDBkQUNSQ25RQVhBRUl3V1owQ25SbWRIUUFrV1owQ25SbWRFWGdBRkYwM2dwMGRFWTB0bFQydTNTT0FRVHdzY3doalpaS3JoWWNCU2ZGcDlYTmJLaVZET0QyYitjcGU0L1oxN21RbmJ0enpoYWVRdEUyR0dqMElETlRqUlVTeVR4eHcvUlBIVy8rdlM3ZDFOZlJ0OXo5UVBaZzRYN1FGZmhDbmt2Z05QSUl0T3NDMmVWNmhQYW5uWk5IbFo5eHJ3WlhJTU9sdTNqU29RU3E3OFdFandMancxRUxTbEYxYUJ2Znp3azVaWDdBVXZRempQUUtiRHVRK3NtNHdOT3A0QTZBZFZ1UlMwdDF5L0RacGc0UjZtN0ZOak05SGd2VzdCaTg4emFNak9vNmxNOHd0QkJkajhMUDR5bHYzekNYUGhlYk1LSmMwNjZvOXNGNzFvRlcvOEpYdTg2SEpid0RJRDVsenc1R1dMUi9MaFQwUXFucDJKUXhOWk5mY2JMSXpQeStZeXBxUm0vbEJtR21leCs4MitQaXN4VXVtU2VKa0FMSVQ2ckplenhNSCtDVEptUXR0NXV3VFZiTDNwdG1qRFVRemxTSXZXaThUbDduZzFOcHVSbjFOZzRuMTRRYyszSWlsN093a3ZOV29nTFNQa24zcGloSUZ5dHlJR21NaE9lM24xdFdzdU15OUJkS3lxRjRaM3YyU2dnZ1RMOUtWdk1YUG5DYlJlK29PdUZGUDNIZWpCRy93OWd2bWZOWXZnNkp1V2lhMmxjU1NOMXVJakJrdHpvSWF6T0hQSlo3a0tIUHo4bVJXVmRXM2xBOFdHRjlkUUY2Qm02NzNib292M0JVV0RVMkpOY2FoUjIzR3RmSEtMT3ovdmlaK3JZblpGYUl6blhPNjdDWUVKMWZYdVRScFpoWVprS2U1NHhlb2Fna05HTHMrTlRaSEUwclg0NS9YdlEyUkdBRFg2dmNBdmR4SVVCVjI3d3hHbTJ6alpvNFgzSUxnQWxyT0ZoZXVaNnd0c3ZhSWo0eUxZN3FxYXdsbGlhSWNyejJHK2MzdnNjQW5Da0N1TXpNbVp2TWZ1OWxMd1R2ZlgrM2NWU3lQZE45WndnRFpoZmpSZ05KY0xpSjY3Yjl4eDhKSHN3cHJiaUUzdjlVcGhvdEFQSWduWFZJTjVLbU1jMHBpWGhjNmNDaFBuTitNUmhHOWFkdGR0dFFUVHdTSXBsOEk0L2ovL2Qzc3oxMzI2cVRCVHBQUk0vSGdoM2t6cUVYczhaQWs0RXJRaE5POGh6clEwRExrV01BL04rOTF0bjJNZE9KbldDMkZDWmVoa1Fyd3p3YktPamh2WnNiTTk1UW9lTDlza1l5TWY0c3JWUFZKU2dnN3BPTFV0ci9uOWVUOTlvZTluTHRGUnBqQTlva1YyS2o4aDlrNUhhQzBvaXZSRDhWeVhrSjgxdGNkNGZITlhQQ2Zsb0lRYXN4c3VPMTgvNDZkUjJqZ3VsL1VJZXQyRzBrUnZueU9OTUtoSHM2SjI2RkVvcVNxZCtyZllqZUVHd0hXVkRwWDFmaDFqQkJjS0dNcVJlcGp1OVkwMG1EVkhDK1hkaWovajQ0cktmdmZqR2luTnMxak8vMEYzakI4M1hDRElOTi9IQjg0YXhsUCszRS9rbGt0Um8rdmwzVS9haXlNSmJJb2RFMVhTc0RuNlVBeklvTXRVT2JZMitrLzRnWS9sK0FrWko1U2oydlFya3lMbTNGb3hqaERYKzMxVVhCRmY5WHJBSDMxZkZxb0JtREVadmh2dnBuWjg3TitvWkV1N1U5Ty9ubmsrUVdqM3g4dXlvUmJFbmYrTzVVTXI5aTBuSFAzOElGNUF2enJCVzhZV0JVUjBtSUF6SXZuZFFxOU4zdi9KdG8zYVBqUFhVUGw4QVNkUFB5QXA3akVOZjhiazdWTU05b2w5WEdtbEJtZURNdUdxdCtXenVMNkNYQXhYakloQ1BNNXZBQ2NoZ01KLzhYQkdMTy9EMWlzVnZHaHd3SEhyMURMYUk1bW4ySnIvYjFwVUQ5MHVjaURhUzhjWE5EekNXdk5tVC9QaFFlNWU4blRubm5rdDhEcy9TSWppYmN1bS9mcURoS29weEFZOEFrU3JQbitJR0RFS09PK1UzWE9QNmRqRnMySDVOOStvcmhPYWhpUWs1S25FVVdhK0N6a1Z6aHA4Yk1IUmJnODFxaGpqWHVJS2JIalNMU0lCS1dxb2NrR3RLaW5ZK3o0L1JkQlVGNnBjYzNKbW5seFZjTmdySTRTRXpLVVpTd2NEMlFDeXh6S3ZlK2dBbWc2WnVTUmtwUEZhNm1mVGh1N0xKTnUzSDVLNDJ1Q3BOdlBBc29lZG9sS1YvTEhlL2VKK0JiYUc1TUcwTmFTR1ZQUlVtTkZNRkZTU3BYRWNYd2JWaDdVRVRPWlp0b1ZOUkdPSWJia2lnM01jRXRSNjhjRzBSWkFvSmV2V1lvN0RnL2xaMUNRemJsV2VVdlZIbXI4Zlk0TnFkOUpKaUgvekVYMjRtSnZpSDYwZkF5RnIwQTNjNGJDMWozeVpVNjBWZ0p4WG44SmdKWExVSXNpQm5tS21NWXorN3lCUUZCdnFiMmVZbnVXNTlqb1pCZjU2L3dYdldJUjRSOHdUbVY4MGkxbVp5K1M0K0JVRVMraHpqazB1WHBDLy8vei9JbHFIWjFtb256bFhwOGFDZmhHS010aTczRkkxS2JMMXE2SUtPNGZ1QnVaNTlnYWdqbjV4VTc5bXVNcEhYZzZTK2UrZ0RNL1U5QktMSGJsOWw2bzhjelFLbDRSVWtKSmlxZnRRRzJpM0JNZy9UUWxVWUZrSkRZQk9PdkF1Z1l1ellTRG5aYkREZC9hU2Q5eDBPZTZGK2JKY0hmbDkrZ3A2TDUvVGdBK0JkRkZvdmJmQ3JRNDBzNXZNUHc4ODY2cE5YOHp5RkdlRldkeElwUFZwOVJnMVVQT1ZGYkZacnZhRnEvWUF6SFFncU1XcGFoTVlmcUhwbXdYZkhMMS9rcFltR3VIRndUNTVtUXUwZHlsZk51cTJPcTBoVE1DUHdxZnhudUJJUExYZmNpNFkxQU55KzFDVWlwUXhsZC9pelZoMTZXeUcyUTBDUVE5TnF0QW54MUhDSHdEajdzWXhPU0Iwd29wWlNuT3p4UU9jRXhteHJWVEYyQmtPdGhWcEdmdWhhR0VDZkNKcEpLcGpuaWhZK3hPVDJRSnhONjErOUs2UVNxdHYyU2hyODJJM2pnSnJxQmcwd0VMRlpQanZIcHZ6VHRhSm5MSzZWYjk3WW45MzNrb08vc2FON2ZzandOS3pwNGwybEpWeDJvcmpDR3pDLzRaTDR6Q3ZlcjZhUVl0QzVzZG95Y2h1RkU2dWZPaW9nK1ZXaTVVRGtibXZtdGFoLzNhQXJFQklpMzlzNUlMVW5sRkxnaWxjR3V6OUNRc2hFWTdmdzJvdW9JTEFZUFZUL2d5QUlxM1RGQUl3VnNsK2t0a1J6L3FHZm5DREdybTVnc2wvbDlRZHZDV0dzalB6M2RVN1h1cUtmZFVyci82WElnanA0cmV5NkFKQm1DbVVKTWpJVEhWZEZiNW0xcCtkTE1DTDh0NTV6RDQyY21mdG1MRUpDMERhMDRZaVJDVlVCTExhOEQwNzEvTjVVQk5CWERoMExGc21oVi81QjVFeE9CNGozV1ZHL1MzbGZLNW8rVjZFTEh2eTZSUjluNGFjK1ZzSzRWRTR5cGhQdlYra0c5RmVnVEJINFpSWEwySHl0VUhDZHVKYXpCL0t5a2pmZXRZeE9YVEx3czI2N2FHT2QrSStKaEtQLy8rVm5YbVM5ME9EL2p2TGNWdTBhc3lxY3VZTjFtU2I2WFRsQ2txdjF2aWdaUElZd05GL3pwV2NUMUdSLzZhRUlSamtoMHloZzRMWEpmYUdvYllKVFk0Skk1OEtpQUtnbW1nQUtXZGw1bllDZUxxYXZSSkdRTnVZdVp0WkZHeCtJa0k0dzROUzJ4d2JldE5NdW5PakJ1L2htS0NJL3c3dGZpaXlVZC8vNHJiVGVXdDRpekJZOFl2R0lONnZ5S1ltUC84WDh3SEtDZU4rV1JjS003MCt0WEtOR3lldlU5SDJEZzVCc2xqblRmOFlic0oxVG1Nczc0Q2UyWGxIaXNsZWd1aHllZzQ0clFPSFp1dy82SFRraG5udXJLMmQ2MnE2eVM3MjEwU3NBSWFSK2pYTVFBK3N2a3JMcHNVWStGMzBVdzg5dU9kR0FSNnZvNEZJTUUwRWZWVmVIVHU2ZUtpY2ZoU3FPZVhKaGJmdGNkMDhzV0VuTlVMMUM5Zm5wclRnZDgzSU11dDhvblZVRjBodnF6WmZIZHVQamJqd0VYSWNvWW15K1A2dGNKWkhtZU92NlZydkVka0hESmVjakh1SGVXQU5lNzlWRzY2MnFUakEvSEN2dW1WdjNxTCtMck9jcHFHcHMyWkd3UWRGSjdQVTRpdXlSbEJyd2ZPK3huUHlyNDdzMmNYVmJXekF5em5EaUJHakNNM2tzeGpqcU02MkdFOUM4ZjVVMzhrQjNWanRhYktwL25SZHZNRVNQR0RHOTBiV1JMQXQxUWs1RHlMdWF6UlIxWXpkQzFjK2haWHZBV1Y4eEE3MlM0QThCNjd2alZoYmJhM01Nb3AyOTNGZUVYcGU3ekl0TVdySkcvTE9IOUJ5T1htWW5OSmZqbWZ1WDlLYnJwZ0xPYmE0blorZmw4R2Jkdi9paHYrNndGR0tIQ1lyVndtaEZDMEozVjJibjJ0SUIxd0NjMUNTVDNkM1gyT3l4aGd1WGNzNHNtNjc5VW5nem9mdVNlQmV3TUZKYm9JUUhiVWgvbTJKaFcyaEc5REl2RzJ0N3laSXpLQlR6OXdCdG5OQysycENSWWhTSXVRMWo4eHN6NVZ2cW55VUl0aHZ1b3l5dTdmTklyZy9LUVVWbUdRYXFrcVprL1Z4NWIzMy9nc0VzOHlYN1NDMUorTlY0aWN6NmJ2SUU3QzVHNk1jQmFJOHJWZzU2cTVRQkpXeG4vODdRMXNQSzQrc1FhOGZMVTVnWG80cGFhcTRjT2NRNHdSMFZCSFBHaktoK1VsUENiQTFuTFh5RVVYNDVxWjhKNy9MbjRGUEpFMlRkekQwWjhNTFNOUWl5a01NbVN5T0NpRmZ5ODRScTYwZW1ZQjJ2RDA5S2pZd3NvSXBlRGNCRFRFbEJiWHhORDcyeWhkOXBDLzFDTWlkLzVIVU12QUwyN090Y0lKRHpOS3BSUE5xUE9weXQyYVBHejlRV0lzOWhROUxpWDVzOG05aGpUVXUvZjdNeUlhdGpqZCt0U2ZRM3VmWnhQcG1KaFRhQnRadEtMVWNmT0NVcUFEdU8rUW9IOEI5djZVK1AwSFYxR0xRbXRvTkZUYjNzNzRpdlpnakVTMHFmSys4UmRHZ0JiY0NNU3k4ZUJ2aDk4K2V0MUtJRnFTZTFLUVB5WFVMQk1Uc0lZbnlzSXdpWkJKWWRJMjB2c2VWK3d1SmtjcUdlbWVoS2phQWI5TDU3eFptM2cyelgwYloyeGsvZlUrYkNvN1RsbmJXN0p1RjFZZFVSby8yR3c3VmNsREcxVzdMT3RhczJMWDR1cGlmWi8yM3J6cHNuWS9BTGZSZ3JjV1A1aFltVjlWeFZPUUExZlp2cDlGMlVOVSs3ZDd4UnlWbTV3aUxwMy8wZGxWN3ZkdzFQTWlacmJEQVl6SVZxRWpSWTJZVTAzc0poUG5sd0lQY1pVRzVsdEw2UzhYQ3hVMWVZUzVjanIzNHZlQm1YQXZ5N3lONFpqQXJJRzBkZkQvNVVwQk5sWDFaUG94Sk93eXFSaTN3UVd0T3pkNG9OS2gwTGtvVG04Y3dxZ0lmS2hxcUdPaHdvNzFJK3pYbk1lbVR2MkIyQVV6QUJXeUZ6dEdnR1VMakREeldZd0pVVkJUaktDbjVLMlFHTUsxQ1FUN1N6emlPam8rQmhBbXFCanp1YzN4WXltMmVlZEdlT0lSSlZ5VHdEdzM3aUNNZTRnNVZibnNiNVpCZHhPQW5NVDdIVTRESHB4V0d1UTdHZWlZMzBDcGJ2enNzNTUrNUttMVlzYkQ1ZWEzTkk5UU5ZSVhvbDVhcGdTdTlkWjhmOHhTNWR0SHBpZG81QmNsRHVMV1k0bGhpazB0YkphMDd5SmhIMEJPeUV1dC9HUmJZVFM2UmZpVFlXR01Da05wZlNIaTdIdmRpVGdsRVZIS1pYYVZoZXpINGtrWGlJdktvcFlBbFB1c2Z0cEU0YTVJWnd2dzF4L2VMdm9ESWgvenBvOUZpUUluc1RiMlNBa0tIVjQyWFlCanBKRGc0Mzc0WGlWYjN3czRxTTBzOWVTUTVIenNNVTRPWkpLdW9wRmpCTStkQVpFbDhSVU14NXVVMk40ODZLcjE0MXRWc0dRZkdqT1JZTUNKQU1zeEVMZU5UNFJtV2pSY3BkVEdCd2N4NlhOOWRyV3FQbUp6Y3JHckg0K0RSYzcrbjF3M2tQWnd1MEJrTnI2aFFycWdvN0pUQjlBNWtkSi9IN1A0Y1dCTXdzbXVpeEF6SkIzeXJRcG5HSXE5MGx4QVhMekRDZG4xTFBpYnNSdDdySE5qZ1FCa2xSZ1BaOHZUYmpYZGdYclRXUXNLNU1kclhYUVZQcDBSaW5xM2ZyelpLSjBxRDZRaGM0MFZ6QXJhVVhsb2IxZ3ZraEszdnBtSGdJNkZSbFFaTng2ZVJxa3Awenk0QVFsWDgxM2ZBUHRMM2pNUmFpdEdGRmpvMHptRXJsb0MraCtZWWRWUTZrNEYvZXB4QW9GMEJtcUVvS05UdDZqNHZRWk5RMkJvcUY5Vmo1M1RPSW9ObURpdTlYcDE1UmtJZ1FJR2NvTHBmb0liZW56cEdVQXRxRkpwNVcrTExueDM4akhlRUNUSi9uYXZLWTFOV2ZOMHNZMVQ4L3BCOGtJSDNEVTNEWCt1NlczWXdweXBCTVlPaGJTeEdqcTg0Ulo4NGZXSm93OHB5SHFuNFMvOUoxNUVjQ01zWHFyZnd5ZDltaGl1MytyRW85cFBwb0prZFpxSGpyYTROdnpGd3VUaE5LeTZoYW8vU2xMdzNaQURVY1VwM3czU1JWZlcycmhsODB6T2dUWW5LRTBIczJxcDFKNkgzeHFQcUlrdlVEUk1GRFl5UmJzRkkzTTlNRXlvdlBrOHJsdzcvMGE4MWNEVkxtQnNSMnplMnBCdUtiMjNmYmVaQzB1WG9JdkRwcGZUd0lEeGsxT3EyZEdlc0djK29KWFdKTEdrT2hhM0NYK0RVbnpnQXA5SEdIOVJzUFpONjNIbjRSTUE1ZVNWaFBITys5UmNSYi9JT2d0VzMxVjFRNUlQR3RveFBqQytNRUpiVmxJTVlBRGQ5YUhZV1VJUUtvcHVQT0htb3FTa3VibkFLbnpnS0hxZ0lPZlc1UmRBZ290TjZCTitPMlpZSGt1ZW1MbnZROFU5VEhWclMxUnRMbUtiY0M3UGVlRHNZem52cXplZzZWQ053bXIwWXl4MXduTGp5VDg0Qlp6M0VKeUNwdEQzeWV1ZUF5RFdJczBMMnFzL1ZRM0hVeXFmcmphMFYxTGREenFBaWtlV3VWNHNjN1JMSUI2OWpFSUJqQ2t5WmVkb1VIcUNyT3ZTaFZ6eWQ3M09kckpXMGhQT3VRdjJxT29IRGM5eFZiNll1NnVxM1hxcDJaYUg0NkE3bHpldmJ4UUVtZnJ6dkFZU0p1WjRXRGsxSHozUVgxTFZkaVVLMEV2bEFHQVlsRzNNZDMwcjdkY1BONjN5cUJDSWoyNXBycHZaUDBuSTQrRWdXb0ZHOTVWNTk2Q3VyWHBLUkJHUmpRbEhDdnk1SWIvaVc4blpKV3dyRVQzbWdkNm1FaGZQNEtDdWFMam9wV3M3aCtNZFhGZEl2OGRIUUpnZzF4aTFlWXFCMHVEWWp4d1ZtcmkwU3Y1WEt1dC9vbnFhcEMrRlFpQzJDMWx2WUo5TVZjbzZ5RFlzUzNBQU5VZk10dnRiWUkyaGZ3WmF0aVNzbm9VZU1aZDM0R1Zqa01NS0ErWG5qSnBYZ1JXMlNIVFpwbFZvd1BtSnN2WHk2dzNjZk8xQUsyZHZ0WkVLVGtDL1RZOUxGaUtIQ0cwRG5yTVFkR20ybHpsQkhNOWlFWXluSDJVY1ZNaFVFanNjMG9EQlRnbzJaU1ExZ3prQUhlV2VCWFlGallMdXVmOHl6VEN5Ny9SRlI4MVdEalhNYnEyQk9INWRVUm54bzZvaXZteEwzY0t6S0lubFprRDMxbnZwSEI5S2s3R2ZjZkUxdCsxVjY0YjlMdGdlSkdscFJGeFFDQXFXSjVEb1k3N3NraThnc09FT3IydXl3WmFvTy9OR2EwWDB5MXBOUUhCaTNiMlNVR05wY1p4RFQ3ckxiQmYxRlNuUThndXhHVzNXKzM2QlcwZ0JqZTRET3o2QmE2U1ZrMHhpS2d0K3EySk9GeXI0U1lmbnUrSWMxUVpZSXV3SEJyZ3pyNlV2T2NTQ3pQVE9vN0Q2SUM0SVNlUzd6a2w0aCsyVm9lSHBuRy91V1IzK3lzTmdQY09JWFFidjBuNG1yM0J3UWNkS0p4Z1BTZXl1UC96MUpqZzRlOW5Vdm9YZWdxUVZJRTMwRUh4NUdIditGQVZVTlRvd1lESmd5RmhmNUl2bFltRXFSaWY2K1dOMU1rRUptRGNRSVR4OUZYMjNhNG14eTFBUVJzT0hPLytlSW1YOWw4RU1KSTNvUFd6Vlh4U09lSFUxZFVXWXIydUFBN0FNYit2QUVaU2JVM3FvYjlpYkN5WGV5cEVNcFo2ODYzbzZRUHFscUdIWmt1V0FCU1RWTmQ0Y09oOWh2M3FFcFN4Mlp5L0RKTVA2Y0l0RW1pQko1UEZxUW5ERUl0M05yQTNDT2xPU2d6NDNEN2dwTkZOSjVNQmg0b0Z6aERQaWdsQzJ5cHNOVTRJU3l3WTJlcmt5YjFOQzNRaC9JZldqMGVEZ1pJNC9sbjhXUGZCc1QzbWVUanExVXF0MUU3WmwvcWZ0cWt4NmFNOUt1ZU1DZWtTbk1yY0hqMUNxVFdXekV6UHNaR2NEZTNVZTRXcytYRllWeE5iT0ZGOGV6a3ZRR1I2Wk90T0xVMmxRRW5NQlN0eDQ3dkU2UGI3QVlNQlJqMk9PZlpYZmlzakpucFRmU05qbzZzWjZxU3ZOeFpObURlUzdHazN5WXlDazFIdEtOMlVuaE1Jak9YVXpBcUR2OTBseDlPL3EvQVQxWk1uaXQ1WFFlOXdtUXhuRS9XU0gwQ3FaOS8ySHkrU2ZtcGVnOFJ3c0hJNVo4a0M4SDI5M20vTEhWVk0vQkE3SGFUSllnNUVuazdNL3hXcHEwMTkyQUNmQmFpMkxBL3FyQ2pDcjZEaDFCSU16TVhJTkJtWDk2TUo1SG4ybnhsbi9SWFBGaHdIeFVtU1YwRVYyVjBqbTg2L2R4eHVZU1UxVzdzVmtFYk45RXprRzBRRndQaHlIS3liM3QrRmo1V29VVVRFcmNhekUvTjZFVzZMdnAwZC8vU0RQajdFVjlVZEpOK0FtbmYzV3drM0EwU2xKOVowMHl2WFo3bjN6NzBHNDdIZnNvdzhXcTFKWGNmd25BK1l4YTVtRnNnVjQ2NEtLUDRUMzF3cUlnekZQZDNlQ2UzajVvcnk1ZkJGMmhnQ0Z5VkZyTHpJOWVldE5Ydk03b1FxeUZnRG80Q1RwL2hEVjlOTVg5SkRIUS9ueUhUTHZaTE5MRjZmdG4yT3hqR204K1BxT3doeG5QSFdpcGtFLzh3YnR5cmk4MFNyN3BNTmtRR01mbzRaWUs5T2NDQzRFU1ZGRmJMTUl2bHhTb1JxV2llMHd4cW5MZmNMU1hNU3BNTVFFSllEVk9iWXNYSVFOdjRUR053anExa3ZUMVVPa2ljVHJHM0lhQlozWGRTY1MzdThzZ2VaUFZwT0xrYmlGOTQwRmpiQ2VOUklOTnZEYmQwMUVQQnJUQ1BwbTEybTQzemUxYkJCNTlJYTZPdmhudXIvTnZ4M0l4d1NXb2wrM0gycWZDSlI4ZGY2YVFmNHY2V2lPTnhrSytJcVQ0cEtRclpLL0xwbGdESS9QSlpiT2VwOGR0YlY3b0NyNkNnZnBXYThOY3pPa1B4ODFpU0hic05oVlNKQk90ckxJTXJMMzFMSzlUcUhxQWJBSGUwUkxtbVY4MDZrUkxETE5FaFVFSmZtOXUwc3hwa0w5M1pnZDZydyt0cUJmVE1pNTl4cVhITFhTSHdTYlNCbDBFSzArbG9FQ09QdHJsKy9uc2FGZTE5N2RpNHlVZ29lNGpLb0FKRFhjNkRHRGpyUU9vRkRXWko5SFh3dDh4RHJRUCs3YVJ3V0tXSTFHRjhzOE80S3p4V0JCY3dubDN2bmwxT2V6M29oNkVhMXZqUjcvejdERFRyRnRxVTJXL0tBRXpBdVhETlo3TVk3M01GMjE2ZHpkU2JXbVVwNGxjbTdrZUpmV2FNSGd1dDl4NUM5bWo2NlowbEoreWhzalZ2eWlXcmZrMWx6UE9UZGhHMTVZN2dRbFh0YWN2STdxdi9YTlNzY0R3cWtnd0hUL2dVc0Q1eUI3TGRSUnZKeFFHWUlObjloVHBvZEtGVlNUUHJ0R3Z5UXcrSGxSRlhJa29kRXJBR3U5SXkxWXBmU1BjM2prRmg1Q1gzbFB4djdhcWpFL0pBZlRJcEVqR2IvSDdNTzBlMnZzVmlTVzFxYS9MbWk0L240REVJM2c3bFlyY2Fuc3BEZkVwS2tkVjFPalNMT3kwQkNVcVZvRUNhQjU1dnMwNnJYbDRqcW1Mc1BzRk0vN3ZZSjB2ckJoRENtLzAwQS9IODFsMXVla0ovNkxtbDNIYjkrTktpTHFBVEptRHB5emZZWkZIdW1FakM2NjJMMEJ3a3hpN0U5VTRjUUEwWE1WRHVNWUFJZUxNUGdRYU1WT2Q4Zm10NVNmbEZJZnVCb3N6ZUF3N293NWdYUEUyWS95QmMvN2pFeEFSVWYvQnhJSFFCRjVTbjNpNjF3NHo1eEpkQ3lPMUYxWDMrM2F4K0pTdk1lWjdTNlFTS3AxRnAvc2pZejZaK1ZnQ1p6aWJHZUVvdWpyeWZNdWxIN1JhaTVrQWZ0OWViY1c1MER5SnIydW8yejk3bVRXSXU0NVlzU25OU01yck5VdUcxWHNZQnREOVREWXpRZmZLQjg3dldia000RWJQQUZnb0JWNEdRUyt2dEZEVXFPRkFvaTFuVHRtSU92ZzM4TjRoVDJTbjhyOGNsbUJDWHNwQmxNQllUbnJxRkpHQlQzd1pPekF5SkRyZTlkSEg3K3g3cWFhS0RPQjRVUUFMRDVlY1MwREU0b2J1YlFFaXVKWjBFcEJWcEx1WWNjZThBYTRQWWQvVjRETERBSkJZS1FQQ1dUY3JFYVo1SFliSmkxMUdkNmhqR29tMWlpMThWSFluRzI4Tktwa3oyVUtWUHhsaFlTcDh1WnIzNjdpT21veTd6c3hlaFc5d3pjeTJ6RzBhODBQQk1DUlFNYjMyaG5hSGVPUjhmbk5EelpoYU5ZaGtPZERzQlVaM2xvRE1hMVlQMHVTMGNqVVAzYi82REJscW1aT2VOQUJEc0xsNUJJNVFKdXBzOHV4QXVXSmRrVUIvcE82WmF4NnRzZzdmTjVtampEZ01HbmdPK0RQY0txaUhJRGJGSUd1ZHh0UFRJeURpOVNGTUtCRGNmZEdRUnY0MXExQXFteGdrVmZKTW5QOHcvQmM3TjkvVFI2QzdtR09iRnFGa0lFb204c0tpMnhZcUpMVENISzdjeHphWnZxT0RvMjJjM3dpc0JDUDRIZUFnY1JiTlBBc0JrTlJoU21ENDhkSHVwZEJSdzRtSXZ0UzVvZUY2emVUMUtNQ3loTW5taHBrRkFHV25Hc2NvTmt3dlE4Wk01bEUvdmdUSEZZTDk5T3VOeGRGQnhURURkNXYycUxSOHk5V2tYc1dnRzZrWk5uZEZHK3BPL1VBa09DaXBxSWhMM2hxN2NSU2RyQ3E3WWhVc1RvY0VjbmFGYTZuVmtoblNlUllVQTFZTzB6NWl0RjlTbHkzVmx4WUR3MjM5VEpKSDZmM0VVZllPNWxiN2JjRmN6OEJwN09vOFFtbnNVSE96L2ZhZ1ZVQnRLRXcxaVQ4OGorYUtrdjhjc2NLTmtNeGpZcjgzNDREMWtGb1o3L3RkMVc2TENOWU41OTQzMDF0VUdSbUZqQXplUmc1dnlvTTFGNitiSlovUTU0ak4vazhTRmQzRHhQVFlhQVVzaXZzQmZnVG43TXg4SDJTcFB0NEdPZFlSbkVKT0g2akhNMnA2U2dCMGd6SVJxNmZIeEdNbVNtcWFQQ21sZnd4aXVsb2FWSWl0TEdOOHdpZTJDRFdoa3pMb0NKY09EaDdLSU9BcWJIRXZYZFV4YVM0VFRUczA3Q2x6ai82R21WczlraVpEZXJNeEVuaFVCNlFRUGxjZnFrRzk4ODJScUhvTGlIR0JvSGZRdVhJc0FHOEdUQXRhbzJLVndSbnZ2YW04am8xZTMxMkdRQUtXRWE0c1VWRUFNRzRHNmNrY09ORHdSY2cxZTJEMytvaFhnWTRVQVdGOHdIS1FNclNuekNnZkZwc3hoK2FIWE1HdFBRcm9RYXNSWTRVNlVkRzByejFWamJrYTBNZWtPR1JaUUV2cVFGbHhzZUZvcjh6V0ZnSGVrM3YyOStXcU42Z2FLNWdaT1RPTVp6cFFJQzEyMDFMa01DWGlsZDN2V1hTYzVVWDl4Y0ZZZmJSUHpHRmExRkRjUGZQQi9qVUVxL0ZlR3Q0MTlDSTNZbUJsVm9Ic2E0S2Rjd1FQNVpTd0hIaEZKNy9QaC9SYXAvNHZtRzkxZUR3UFAwbERmQ0RSQ0xzelRxZnpNNzF4cG1pS2kySHdTNFdscXZHTnd0dndGNURxcG42S1RxOGF4MDBVTVBreERjWnJFRUVzSXZIaVVYWEVwaGRiNEdCNEZ5bWxQd0J6NEdwZXJxcTVwVzdUUTYveU5SaFc4VlQ1Tmh1UDB1ZGx4bzRnSUxxNVp4QVprOFpHaDNnNENxeEpsUEtZN0FReHVwZlVjVnBXVDVWSXRwMSszMFVxb3lQNHdXc1JvM29sUlJna1daWjJaTjZWQzNPWkZlWEI4TmJuVXJTZGlrTnB0RDFRaUd1S2tyOEVtU1IvQUs5UncrRkYzczV1d3VQYnZIR2lQZUZPVmlsdE1LN0FVYU9zcTkreDljbmRrM2lKRUU1TEtaUmxXSmJLT1p3ZVJPem1QTlZQa2pFM0svVHlBNTdSczY4VGtaM01SOGFrS3BtN2NGam5qUGQvRGRrV2pnWW9LSFNyNVd1NXNzb0JZVTRhY1JzNWcyREh4VW1kcThWWE9YUmJ1bkQ4UU4wTGhna3NzZ2FoY2RvWXNOdnVYR1VLL0tYRC83b0ZiK1ZHZGhxSW4wMnZldU01Ykx1ZEpPYzJLeTBHTWFHNFcveFdCeElKY0w3eWxpSk9YT3B4MEFrQnFVZ3psRGN6bUxUNGlJTFhEeHh0UlIxb1phMkpXRmdpQWI0M29ickpuRy9UWkMyS1NLMndxT3pSWlRYYXZaWkZNYjFmM2JYdlZhTmFLODI4dzlUTzYxMGdrOEpOZjNnTWZFVHpYWHNiY3ZSR0NHOUpXUVo2K2NEUHFjNDQ2NllvMlJjS0grUElMZUtPcXRubGJJblIzTW1CZUdHM0ZIMTB5emt5YnVxRUMySFNRd3BBMEFuN2Q5KzczQmtEVVRtMzBiWm1vUC9SR2JnRk4rR3JDT2ZBRGdxcjBXYkkxYTFva3BGbXM4aUhZdzlobTB6VXZsRU1pdkJSeE1vZHJiSkorOS9wM2pVZFFROUJDdFFkeG5PR3JUNWR6UlVtdzA1OTMvbWJSU2RCZzBuUnZSWk01L0UxNm03WkhtREV0V2h3dmZkWkNaOEo4TTEyVzB5Uk1zelhhbVdmUVR3SVo0YXlZa3RybnNjUXVXcjhpZHAzUGpUMmVGL2ptdGRoSWZjcE1uYitJZlpZMkZlYlc2VVkvQUszalA0dTNUdTR6RTRxbG5RZ0xGYk0xOUVCSXNOZjdLaGpkYnFRL0Q2eWlEYitObEVpMlNLRCtpdlhWVUs4aWIwb0JvMzY2Z1hrUjhaeEdqcEpJRGNFZ1pQYTlUY1llMFRJYmlQbC9yUFVRRHUzWEJKOVgvR05xM0ZBVXNLc2xsNTdEemFHTXJqY1QrZ2N0cCs5TUxZWENxK3NxUDgxZVZRMHI5bHQrZ2NRZlpiQUNSYkVqdmxNc2t6dFpHOGdiQzhRbjl0dDI2UTd5N25EcmJacS9MRXo3a1I2SmM2cGczTjlyVlg4WTVNSnJHbE1MOXA5bFU0amJUa0txQ3ZlZVpVSmpIQjAzbTJLUktSMlR5dG9Ga1RYT0xnN2tlVTFzMWxyUE1RSnBvT0tMdUFBQyt5MUhsSnVjVTZ5c0I1aHNYaHZTUFBMcTVKN0p0bnFIS1o0dllqQzRWeTgxNTNRWSs2NzgweER1R0FSc0diT3MxV3F6SDBRUzc2NXJuU0tFYmJLbGtPOG9JL1ZEd1VkMGlzMTN0S3BxSUx1MW1ESkZOeS9pSkFXY3ZEZ2p4dnVzSVQrUEd6M1NUL0o5cjlNdGZkMGpwYUdlaUxZSXFYYzdEaUhTUzhUY2pGVmtzaTY2UEVreFcxejZ1amJMTFVHTk5ZbnpPV3BIOEJaR0s0YkNLN2lSK01iSXY4bmNEQXoxdTRTdE4zdlRUemV3cjlJUWprOXd4RnhuKzZOMWRkS3MwdmZmSmlTMDhOM2E0RzFTVnJsWjk3US9NKzhHOWZlNUFQNmQ5L1FxNFdSbk9SVmhvZlBJS0VkQ3IzbGxzcFVmRTBvS0lJWW9CeUJSUGgrYlgxSExTM0pXR0pSaEl2RTFhVzROVGQ4ZVBpNFora1hiK1o4c25ZZlNOY3FpamhBZ1ZzeDRSQ001NGNYVWlZa2plQm1tQzRhak9IckNob0VMc2NKSkM3Kzlqak1qdzVCYWdaS2xnUk1pU05ZejdoN3Z2WklvUXFidFFtc3BjMGNVazFHLzczaVh0U3BST2w1d3RMZ1FpMG1XMkV4OGkzV1VMaGNnZ3g2RTFMTVZIVXNkYzlHSEkxUEgzVTJLbzBQeUdkbjlLZFZPTG03RlBCdWkwaTlhMEhwQTYwTXNld1ZFNHo4Q0F0NWQ0MDFHdjZ6WGxJVDVZYml0MVZJQTBGQ3M3d3R2WXJlcnUxZlV5VzNvTEFaLythVG5ack9jWVJOVkE4c3BvUnRsUm9XZmxzUkNsRmNnemtxaUhPcmYwL1NWdytFcFZhRmxKMGc0S3hxMU1NT21pUWRwTU5wdGU4bE1NUXFtNmNJRlhsbkdiZkpsbHlzS0RpKzBKSk1vdGtxZ0l4T1NRZ1U5ZG4vbFdrZVZmOG5VbTNpd1gyTmwzV0R3OWk2QVVLM3ZCQWJaWnJjSnBEUS9ONjRBVndqVDA3SmVmMzBHU1NtdE51MldsVzdZb3lXMkZsV2ZaRlFVd2s4NjdFZExZS2s5Vkc2SmdFbkJpQnhrWTdMTW80WUxRSkpsQW85bC9vVHZKa1NBUkRGL1h0eUF6TThPMnQzZVQvaVhhNndETjNXZXdObVFIZFBmc3hDaFUvS3RMRzJNbjhpNFpxS2RTbElhQlphZHhKbVJ6VlMvbzR5QTY1UlRTVmlxNjBvYTM5NUxxdzBwelk0U2lwd0UwU1hYc0tWK0dacmFHU2tyL1JXMDh3UFJ2cXZTVWtZQk1BOWxQeDRtMjRheitJSG1DYlhBKzBmYXhUUkU5d3VHZU8wNkRJWGE2UWxLSjNwdUl5aXVBVmZQcjczNnZ6bzJwQmlyUytWeGVsM1RNbTNKS2h6OW8yWm9SdmFGVnBJa3lrYjBIY200b0hGQk1jTlNOajcvNEdKdDQzb2dvblkyVmc0bnNEUUlXeEFjb3JwWEFDemdCcVFQallzRS9WVXBYcHdOTWFuRXJ1NE53TUNGUGtYdk1vcXZvZUxOM3F5dS9OMWVXRUh0dE1ENjV2MTlsLzBrSDJtUjM1aXYvRkkreWpvSEo5Z1BNejY3YWYzTXEvQm9XWHF1M3JwaGlXTVhWa21uUFNFa3BHcFVJMmgxTVRoaWRlR0ZFT0s2WVpIUHdZek1CdnBOQzcrWkh4UGI3ZXBmZWZHeUlCNEp6TzlEVE5FWW5ETFZWSGRReXZPRVZlZnJrNlV2NWtUUVlWWVdXZHFyZGNJbDd5bGp3d0lXZGZRL3krMlFCM2VSL3F4WU9idVl5QjRnVGJvMmluNFB6YXJVMXNPOW5FVGttajkvQW94REErSk0zR01xUXRKUjRqdGR1SHRub0NMeGQxZ1FVc2NIUkIvTW9SWUlFc1AycERaOUt2SGd0bGsxaVRiV1diSGhvaHdGRVlYN3k1MWZVVjJudVVtbm9VY3FuV0lRQUFnbDlMVFZYK0JjMFFHTkVoQ2h4SFI0WWpmRTUxUFVkR2ZzU0ZFNmNrN0JMMy9oVGY5akxxNEcxSWFmSU54T0xLZUF0TzdxdXVsWXZINVlPQmMrelg3Q3JNZ1duVzQ3L2pmUnNXbkpqWVlvRTd4TWZXVjJITjJpeUlxTEknO1xyXG5jb25zdCBGRU5DRUQgPSBuZXcgTWFwKFtbODIxNyxcImFwb3N0cm9waGVcIl0sWzgyNjAsXCJmcmFjdGlvbiBzbGFzaFwiXSxbMTI1MzksXCJtaWRkbGUgZG90XCJdXSk7XHJcbmNvbnN0IE5TTV9NQVggPSA0O1xyXG5cclxuZnVuY3Rpb24gZGVjb2RlX2FyaXRobWV0aWMoYnl0ZXMpIHtcclxuXHRsZXQgcG9zID0gMDtcclxuXHRmdW5jdGlvbiB1MTYoKSB7IHJldHVybiAoYnl0ZXNbcG9zKytdIDw8IDgpIHwgYnl0ZXNbcG9zKytdOyB9XHJcblx0XHJcblx0Ly8gZGVjb2RlIHRoZSBmcmVxdWVuY3kgdGFibGVcclxuXHRsZXQgc3ltYm9sX2NvdW50ID0gdTE2KCk7XHJcblx0bGV0IHRvdGFsID0gMTtcclxuXHRsZXQgYWNjID0gWzAsIDFdOyAvLyBmaXJzdCBzeW1ib2wgaGFzIGZyZXF1ZW5jeSAxXHJcblx0Zm9yIChsZXQgaSA9IDE7IGkgPCBzeW1ib2xfY291bnQ7IGkrKykge1xyXG5cdFx0YWNjLnB1c2godG90YWwgKz0gdTE2KCkpO1xyXG5cdH1cclxuXHJcblx0Ly8gc2tpcCB0aGUgc2l6ZWQtcGF5bG9hZCB0aGF0IHRoZSBsYXN0IDMgc3ltYm9scyBpbmRleCBpbnRvXHJcblx0bGV0IHNraXAgPSB1MTYoKTtcclxuXHRsZXQgcG9zX3BheWxvYWQgPSBwb3M7XHJcblx0cG9zICs9IHNraXA7XHJcblxyXG5cdGxldCByZWFkX3dpZHRoID0gMDtcclxuXHRsZXQgcmVhZF9idWZmZXIgPSAwOyBcclxuXHRmdW5jdGlvbiByZWFkX2JpdCgpIHtcclxuXHRcdGlmIChyZWFkX3dpZHRoID09IDApIHtcclxuXHRcdFx0Ly8gdGhpcyB3aWxsIHJlYWQgYmV5b25kIGVuZCBvZiBidWZmZXJcclxuXHRcdFx0Ly8gYnV0ICh1bmRlZmluZWR8MCkgPT4gemVybyBwYWRcclxuXHRcdFx0cmVhZF9idWZmZXIgPSAocmVhZF9idWZmZXIgPDwgOCkgfCBieXRlc1twb3MrK107XHJcblx0XHRcdHJlYWRfd2lkdGggPSA4O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIChyZWFkX2J1ZmZlciA+PiAtLXJlYWRfd2lkdGgpICYgMTtcclxuXHR9XHJcblxyXG5cdGNvbnN0IE4gPSAzMTtcclxuXHRjb25zdCBGVUxMID0gMioqTjtcclxuXHRjb25zdCBIQUxGID0gRlVMTCA+Pj4gMTtcclxuXHRjb25zdCBRUlRSID0gSEFMRiA+PiAxO1xyXG5cdGNvbnN0IE1BU0sgPSBGVUxMIC0gMTtcclxuXHJcblx0Ly8gZmlsbCByZWdpc3RlclxyXG5cdGxldCByZWdpc3RlciA9IDA7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpKyspIHJlZ2lzdGVyID0gKHJlZ2lzdGVyIDw8IDEpIHwgcmVhZF9iaXQoKTtcclxuXHJcblx0bGV0IHN5bWJvbHMgPSBbXTtcclxuXHRsZXQgbG93ID0gMDtcclxuXHRsZXQgcmFuZ2UgPSBGVUxMOyAvLyB0cmVhdCBsaWtlIGEgZmxvYXRcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHZhbHVlID0gTWF0aC5mbG9vcigoKChyZWdpc3RlciAtIGxvdyArIDEpICogdG90YWwpIC0gMSkgLyByYW5nZSk7XHJcblx0XHRsZXQgc3RhcnQgPSAwO1xyXG5cdFx0bGV0IGVuZCA9IHN5bWJvbF9jb3VudDtcclxuXHRcdHdoaWxlIChlbmQgLSBzdGFydCA+IDEpIHsgLy8gYmluYXJ5IHNlYXJjaFxyXG5cdFx0XHRsZXQgbWlkID0gKHN0YXJ0ICsgZW5kKSA+Pj4gMTtcclxuXHRcdFx0aWYgKHZhbHVlIDwgYWNjW21pZF0pIHtcclxuXHRcdFx0XHRlbmQgPSBtaWQ7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3RhcnQgPSBtaWQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmIChzdGFydCA9PSAwKSBicmVhazsgLy8gZmlyc3Qgc3ltYm9sIGlzIGVuZCBtYXJrXHJcblx0XHRzeW1ib2xzLnB1c2goc3RhcnQpO1xyXG5cdFx0bGV0IGEgPSBsb3cgKyBNYXRoLmZsb29yKHJhbmdlICogYWNjW3N0YXJ0XSAgIC8gdG90YWwpO1xyXG5cdFx0bGV0IGIgPSBsb3cgKyBNYXRoLmZsb29yKHJhbmdlICogYWNjW3N0YXJ0KzFdIC8gdG90YWwpIC0gMTtcclxuXHRcdHdoaWxlICgoKGEgXiBiKSAmIEhBTEYpID09IDApIHtcclxuXHRcdFx0cmVnaXN0ZXIgPSAocmVnaXN0ZXIgPDwgMSkgJiBNQVNLIHwgcmVhZF9iaXQoKTtcclxuXHRcdFx0YSA9IChhIDw8IDEpICYgTUFTSztcclxuXHRcdFx0YiA9IChiIDw8IDEpICYgTUFTSyB8IDE7XHJcblx0XHR9XHJcblx0XHR3aGlsZSAoYSAmIH5iICYgUVJUUikge1xyXG5cdFx0XHRyZWdpc3RlciA9IChyZWdpc3RlciAmIEhBTEYpIHwgKChyZWdpc3RlciA8PCAxKSAmIChNQVNLID4+PiAxKSkgfCByZWFkX2JpdCgpO1xyXG5cdFx0XHRhID0gKGEgPDwgMSkgXiBIQUxGO1xyXG5cdFx0XHRiID0gKChiIF4gSEFMRikgPDwgMSkgfCBIQUxGIHwgMTtcclxuXHRcdH1cclxuXHRcdGxvdyA9IGE7XHJcblx0XHRyYW5nZSA9IDEgKyBiIC0gYTtcclxuXHR9XHJcblx0bGV0IG9mZnNldCA9IHN5bWJvbF9jb3VudCAtIDQ7XHJcblx0cmV0dXJuIHN5bWJvbHMubWFwKHggPT4geyAvLyBpbmRleCBpbnRvIHBheWxvYWRcclxuXHRcdHN3aXRjaCAoeCAtIG9mZnNldCkge1xyXG5cdFx0XHRjYXNlIDM6IHJldHVybiBvZmZzZXQgKyAweDEwMTAwICsgKChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCAxNikgfCAoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgOCkgfCBieXRlc1twb3NfcGF5bG9hZCsrXSk7XHJcblx0XHRcdGNhc2UgMjogcmV0dXJuIG9mZnNldCArIDB4MTAwICsgKChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCA4KSB8IGJ5dGVzW3Bvc19wYXlsb2FkKytdKTtcclxuXHRcdFx0Y2FzZSAxOiByZXR1cm4gb2Zmc2V0ICsgYnl0ZXNbcG9zX3BheWxvYWQrK107XHJcblx0XHRcdGRlZmF1bHQ6IHJldHVybiB4IC0gMTtcclxuXHRcdH1cclxuXHR9KTtcclxufVx0XHJcblxyXG4vLyByZXR1cm5zIGFuIGl0ZXJhdG9yIHdoaWNoIHJldHVybnMgdGhlIG5leHQgc3ltYm9sXHJcbmZ1bmN0aW9uIHJlYWRfcGF5bG9hZCh2KSB7XHJcblx0bGV0IHBvcyA9IDA7XHJcblx0cmV0dXJuICgpID0+IHZbcG9zKytdO1xyXG59XHJcbmZ1bmN0aW9uIHJlYWRfY29tcHJlc3NlZF9wYXlsb2FkKHMpIHtcclxuXHRyZXR1cm4gcmVhZF9wYXlsb2FkKGRlY29kZV9hcml0aG1ldGljKHVuc2FmZV9hdG9iKHMpKSk7XHJcbn1cclxuXHJcbi8vIHVuc2FmZSBpbiB0aGUgc2Vuc2U6XHJcbi8vIGV4cGVjdGVkIHdlbGwtZm9ybWVkIEJhc2U2NCB3L28gcGFkZGluZyBcclxuLy8gMjAyMjA5MjI6IGFkZGVkIGZvciBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzL2lzc3Vlcy80XHJcbmZ1bmN0aW9uIHVuc2FmZV9hdG9iKHMpIHtcclxuXHRsZXQgbG9va3VwID0gW107XHJcblx0Wy4uLidBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ10uZm9yRWFjaCgoYywgaSkgPT4gbG9va3VwW2MuY2hhckNvZGVBdCgwKV0gPSBpKTtcclxuXHRsZXQgbiA9IHMubGVuZ3RoO1xyXG5cdGxldCByZXQgPSBuZXcgVWludDhBcnJheSgoNiAqIG4pID4+IDMpO1xyXG5cdGZvciAobGV0IGkgPSAwLCBwb3MgPSAwLCB3aWR0aCA9IDAsIGNhcnJ5ID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0Y2FycnkgPSAoY2FycnkgPDwgNikgfCBsb29rdXBbcy5jaGFyQ29kZUF0KGkpXTtcclxuXHRcdHdpZHRoICs9IDY7XHJcblx0XHRpZiAod2lkdGggPj0gOCkge1xyXG5cdFx0XHRyZXRbcG9zKytdID0gKGNhcnJ5ID4+ICh3aWR0aCAtPSA4KSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8vIGVnLiBbMCwxLDIsMy4uLl0gPT4gWzAsLTEsMSwtMiwuLi5dXHJcbmZ1bmN0aW9uIHNpZ25lZChpKSB7IFxyXG5cdHJldHVybiAoaSAmIDEpID8gKH5pID4+IDEpIDogKGkgPj4gMSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRfZGVsdGFzKG4sIG5leHQpIHtcclxuXHRsZXQgdiA9IEFycmF5KG4pO1xyXG5cdGZvciAobGV0IGkgPSAwLCB4ID0gMDsgaSA8IG47IGkrKykgdltpXSA9IHggKz0gc2lnbmVkKG5leHQoKSk7XHJcblx0cmV0dXJuIHY7XHJcbn1cclxuXHJcbi8vIFsxMjNdWzVdID0+IFswIDNdIFsxIDFdIFswIDBdXHJcbmZ1bmN0aW9uIHJlYWRfc29ydGVkKG5leHQsIHByZXYgPSAwKSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgeCA9IG5leHQoKTtcclxuXHRcdGxldCBuID0gbmV4dCgpO1xyXG5cdFx0aWYgKCFuKSBicmVhaztcclxuXHRcdHByZXYgKz0geDtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRcdHJldC5wdXNoKHByZXYgKyBpKTtcclxuXHRcdH1cclxuXHRcdHByZXYgKz0gbiArIDE7XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRfc29ydGVkX2FycmF5cyhuZXh0KSB7XHJcblx0cmV0dXJuIHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4geyBcclxuXHRcdGxldCB2ID0gcmVhZF9zb3J0ZWQobmV4dCk7XHJcblx0XHRpZiAodi5sZW5ndGgpIHJldHVybiB2O1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyByZXR1cm5zIG1hcCBvZiB4ID0+IHlzXHJcbmZ1bmN0aW9uIHJlYWRfbWFwcGVkKG5leHQpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB3ID0gbmV4dCgpO1xyXG5cdFx0aWYgKHcgPT0gMCkgYnJlYWs7XHJcblx0XHRyZXQucHVzaChyZWFkX2xpbmVhcl90YWJsZSh3LCBuZXh0KSk7XHJcblx0fVxyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgdyA9IG5leHQoKSAtIDE7XHJcblx0XHRpZiAodyA8IDApIGJyZWFrO1xyXG5cdFx0cmV0LnB1c2gocmVhZF9yZXBsYWNlbWVudF90YWJsZSh3LCBuZXh0KSk7XHJcblx0fVxyXG5cdHJldHVybiByZXQuZmxhdCgpO1xyXG59XHJcblxyXG4vLyByZWFkIHVudGlsIG5leHQgaXMgZmFsc3lcclxuLy8gcmV0dXJuIGFycmF5IG9mIHJlYWQgdmFsdWVzXHJcbmZ1bmN0aW9uIHJlYWRfYXJyYXlfd2hpbGUobmV4dCkge1xyXG5cdGxldCB2ID0gW107XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB4ID0gbmV4dCh2Lmxlbmd0aCk7XHJcblx0XHRpZiAoIXgpIGJyZWFrO1xyXG5cdFx0di5wdXNoKHgpO1xyXG5cdH1cclxuXHRyZXR1cm4gdjtcclxufVxyXG5cclxuLy8gcmVhZCB3IGNvbHVtbnMgb2YgbGVuZ3RoIG5cclxuLy8gcmV0dXJuIGFzIG4gcm93cyBvZiBsZW5ndGggd1xyXG5mdW5jdGlvbiByZWFkX3RyYW5zcG9zZWQobiwgdywgbmV4dCkge1xyXG5cdGxldCBtID0gQXJyYXkobikuZmlsbCgpLm1hcCgoKSA9PiBbXSk7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCB3OyBpKyspIHtcclxuXHRcdHJlYWRfZGVsdGFzKG4sIG5leHQpLmZvckVhY2goKHgsIGopID0+IG1bal0ucHVzaCh4KSk7XHJcblx0fVxyXG5cdHJldHVybiBtO1xyXG59XHJcbiBcclxuLy8gcmV0dXJucyBbW3gsIHlzXSwgW3grZHgsIHlzK2R5XSwgW3grMipkeCwgeXMrMipkeV0sIC4uLl1cclxuLy8gd2hlcmUgZHgvZHkgPSBzdGVwcywgbiA9IHJ1biBzaXplLCB3ID0gbGVuZ3RoIG9mIHlcclxuZnVuY3Rpb24gcmVhZF9saW5lYXJfdGFibGUodywgbmV4dCkge1xyXG5cdGxldCBkeCA9IDEgKyBuZXh0KCk7XHJcblx0bGV0IGR5ID0gbmV4dCgpO1xyXG5cdGxldCB2TiA9IHJlYWRfYXJyYXlfd2hpbGUobmV4dCk7XHJcblx0bGV0IG0gPSByZWFkX3RyYW5zcG9zZWQodk4ubGVuZ3RoLCAxK3csIG5leHQpO1xyXG5cdHJldHVybiBtLmZsYXRNYXAoKHYsIGkpID0+IHtcclxuXHRcdGxldCBbeCwgLi4ueXNdID0gdjtcclxuXHRcdHJldHVybiBBcnJheSh2TltpXSkuZmlsbCgpLm1hcCgoXywgaikgPT4ge1xyXG5cdFx0XHRsZXQgal9keSA9IGogKiBkeTtcclxuXHRcdFx0cmV0dXJuIFt4ICsgaiAqIGR4LCB5cy5tYXAoeSA9PiB5ICsgal9keSldO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8vIHJldHVybiBbW3gsIHlzLi4uXSwgLi4uXVxyXG4vLyB3aGVyZSB3ID0gbGVuZ3RoIG9mIHlcclxuZnVuY3Rpb24gcmVhZF9yZXBsYWNlbWVudF90YWJsZSh3LCBuZXh0KSB7IFxyXG5cdGxldCBuID0gMSArIG5leHQoKTtcclxuXHRsZXQgbSA9IHJlYWRfdHJhbnNwb3NlZChuLCAxK3csIG5leHQpO1xyXG5cdHJldHVybiBtLm1hcCh2ID0+IFt2WzBdLCB2LnNsaWNlKDEpXSk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiByZWFkX3RyaWUobmV4dCkge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgc29ydGVkID0gcmVhZF9zb3J0ZWQobmV4dCk7IFxyXG5cdGV4cGFuZChkZWNvZGUoW10pLCBbXSk7XHJcblx0cmV0dXJuIHJldDsgLy8gbm90IHNvcnRlZFxyXG5cdGZ1bmN0aW9uIGRlY29kZShRKSB7IC8vIGNoYXJhY3RlcnMgdGhhdCBsZWFkIGludG8gdGhpcyBub2RlXHJcblx0XHRsZXQgUyA9IG5leHQoKTsgLy8gc3RhdGU6IHZhbGlkLCBzYXZlLCBjaGVja1xyXG5cdFx0bGV0IEIgPSByZWFkX2FycmF5X3doaWxlKCgpID0+IHsgLy8gYnVja2V0cyBsZWFkaW5nIHRvIG5ldyBub2Rlc1xyXG5cdFx0XHRsZXQgY3BzID0gcmVhZF9zb3J0ZWQobmV4dCkubWFwKGkgPT4gc29ydGVkW2ldKTtcclxuXHRcdFx0aWYgKGNwcy5sZW5ndGgpIHJldHVybiBkZWNvZGUoY3BzKTtcclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIHtTLCBCLCBRfTtcclxuXHR9XHJcblx0ZnVuY3Rpb24gZXhwYW5kKHtTLCBCfSwgY3BzLCBzYXZlZCkge1xyXG5cdFx0aWYgKFMgJiA0ICYmIHNhdmVkID09PSBjcHNbY3BzLmxlbmd0aC0xXSkgcmV0dXJuO1xyXG5cdFx0aWYgKFMgJiAyKSBzYXZlZCA9IGNwc1tjcHMubGVuZ3RoLTFdO1xyXG5cdFx0aWYgKFMgJiAxKSByZXQucHVzaChjcHMpOyBcclxuXHRcdGZvciAobGV0IGJyIG9mIEIpIHtcclxuXHRcdFx0Zm9yIChsZXQgY3Agb2YgYnIuUSkge1xyXG5cdFx0XHRcdGV4cGFuZChiciwgWy4uLmNwcywgY3BdLCBzYXZlZCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhleF9jcChjcCkge1xyXG5cdHJldHVybiBjcC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5wYWRTdGFydCgyLCAnMCcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBxdW90ZV9jcChjcCkge1xyXG5cdHJldHVybiBgeyR7aGV4X2NwKGNwKX19YDsgLy8gcmFmZnkgY29udmVudGlvbjogbGlrZSBcIlxcdXtYfVwiIHcvbyB0aGUgXCJcXHVcIlxyXG59XHJcblxyXG4vKlxyXG5leHBvcnQgZnVuY3Rpb24gZXhwbG9kZV9jcChzKSB7XHJcblx0cmV0dXJuIFsuLi5zXS5tYXAoYyA9PiBjLmNvZGVQb2ludEF0KDApKTtcclxufVxyXG4qL1xyXG5mdW5jdGlvbiBleHBsb2RlX2NwKHMpIHsgLy8gdGhpcyBpcyBhYm91dCAyeCBmYXN0ZXJcclxuXHRsZXQgY3BzID0gW107XHJcblx0Zm9yIChsZXQgcG9zID0gMCwgbGVuID0gcy5sZW5ndGg7IHBvcyA8IGxlbjsgKSB7XHJcblx0XHRsZXQgY3AgPSBzLmNvZGVQb2ludEF0KHBvcyk7XHJcblx0XHRwb3MgKz0gY3AgPCAweDEwMDAwID8gMSA6IDI7XHJcblx0XHRjcHMucHVzaChjcCk7XHJcblx0fVxyXG5cdHJldHVybiBjcHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cl9mcm9tX2NwcyhjcHMpIHtcclxuXHRjb25zdCBjaHVuayA9IDQwOTY7XHJcblx0bGV0IGxlbiA9IGNwcy5sZW5ndGg7XHJcblx0aWYgKGxlbiA8IGNodW5rKSByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY3BzKTtcclxuXHRsZXQgYnVmID0gW107XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICkge1xyXG5cdFx0YnVmLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY3BzLnNsaWNlKGksIGkgKz0gY2h1bmspKSk7XHJcblx0fVxyXG5cdHJldHVybiBidWYuam9pbignJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBhcmVfYXJyYXlzKGEsIGIpIHtcclxuXHRsZXQgbiA9IGEubGVuZ3RoO1xyXG5cdGxldCBjID0gbiAtIGIubGVuZ3RoO1xyXG5cdGZvciAobGV0IGkgPSAwOyBjID09IDAgJiYgaSA8IG47IGkrKykgYyA9IGFbaV0gLSBiW2ldO1xyXG5cdHJldHVybiBjO1xyXG59XHJcblxyXG4vLyBjcmVhdGVkIDIwMjMtMDktMjVUMDE6MDE6NTUuMTQ4WlxyXG4vLyBjb21wcmVzc2VkIGJhc2U2NC1lbmNvZGVkIGJsb2IgZm9yIGluY2x1ZGUtbmYgZGF0YVxyXG4vLyBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvYmxvYi9tYWluL3NyYy9tYWtlLmpzXHJcbi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcyNzZWN1cml0eVxyXG4vLyBTSEEtMjU2OiBhOTc0YjZmODU0MWZjMjlkOTE5YmM4NTExOGFmMGE0NDAxNTg1MWZhYjUzNDNmODY3OWNiMzFiZTJiZGIyMDllXHJcbnZhciBDT01QUkVTU0VEID0gJ0FFVURUQUhCQ0ZRQVRRRFJBREFBY2dBZ0FEUUFGQUFzQUJRQUh3QU9BQ1FBRFFBUkFBb0FGd0FIQUJJQUNBQVBBQVVBQ3dBRkFBd0FCQUFRQUFNQUJ3QUVBQW9BQlFBSUFBSUFDZ0FCQUFRQUZBQUxBQUlBQ3dBQkFBSUFBUUFIQUFNQUF3QUVBQXNBREFBTUFBd0FDZ0FOQUEwQUF3QUtBQWtBQkFBZEFBWUFad0RTQWRzREpnQzBDa01COHhoWkFxZm9DMTkwVUdjVGhnQnVyd2Y3UFQwOVBiMDlBamdKdW04T2pEbGx4SFlVS1hBUHh6cTZ0QUJBeGdLOHlzVXZXQWdNUFQwOVBUMDlQU3M2TFQySGNnV1hXd0ZMb1NNRUVFbDVSRlZNS3ZPMFhROEV4RGRKTW5JZ3NqMjZQVFF5eThGZkVROEFZOElQQUdjRWJ3UndCSEVFY2dSekJIUUVkUVIyQkhjRWVBUjZCSHNFZkFSK0JJQUVnZm5kQlFvQllnVUxBV0lGREFGaUJOY0UyQVRaQlJBRkVRVXZCZEFMRkFzVkRQY05CdzEzRFljT01BNHhEak1CNEJsbEhJMEIyZ3JiQU1EcEhMa1E3UUhWQVBSTlFRRm5HUlVFZzB5RUIydWFKRjhBSnBJQnBvYjVBRVJTTUFLTm9BWHFhUUxVQk1DekVpQUNud1JaRWtrVnNTN3RBTkFzQkcwUnVBUUxFUEFCdjlISUNUVUJYaWdQWndSQkFwTURPd0FhbWh0YUFCcUVBWThLdkt4M0xRNEFyQUI4VWh3RUJBVlNhZ0Q4QUVGWkFEa0JJYWRWajJVTVVneDVJbDRBTlFDOUF4SUIxQmxiRVBNQXMzMENHeGxYQWh3WktRSUVDQmM2RWJzQ294bmd6djdVelJRQThNMEJhd0w2WndrTjd3QUJBRDMzT1FSY3NnTEpDak1DanFVQ2h0dy9rbStOQXNYUEFvUDJCVDg0UHdVUkFLMFJBdnB0YjZjQXBRUy9PTU1leTVISlM4NFVkeHB4VFBrQ29nVkZJVGFUT3dFUkFLNXBBdmtOQk9WeUE3cTNCS2xPSlNBTEFnVUlCUmNFZEFTcEJYcXpBQlhGU1daT2F3TENPcXcvL0FvbENaZHZ2M2RTQmtFUUd5ZWxFUGNNTXdHMUFUc043VXZZQlBFR093VEpIMzBaR1EvTmxad0lwUzNkRE8wbTR5NmhnRm9qOVNxREJlMUw5RHpkQzAxUmFBOVpDMlVKNHpwamdVNERJUUVOSW9zSzNRMDVDRzBROHdySmF3M2xFVVVIT1FQVlNab0FwUWNCQ3hFZE5SVzFKaEJpckFzSk9YY0creHIyQzQ4bXJ4TXBldndGMHhvaEJrMEJLUnIvQU04dTU0V3dXakZjSEU5ZkJnTUxKU1BIRktoUUlBMGxRTGQ0U0JvYkJ4VWxxUUtSUTNCS2gxRTJIcE1oOWp3OURXWXVFMUY4Qi9VOEJSbFBDNEU4bmthclJRNFIwajZOUFVnaVNVd3NCRFYvTEM4bml3blBENFVNdVh4eUFWa0pJUW14REhFVE1SRVhOOFVJT1FjWkxaY2tKeFVJSVVhVllKb0U5NThEOHhQUkF3c0ZQd2xCQnhNRHRSd3RFeTRWS1FVTmdTVFhBdk0yMVM2ekFvOVdnQUVYQmNzUEpSL2ZFRkJINEE3cENKc0NaUU9ESmVzQUxSVWhBQmNpbXdoRFl3QmZqOWhUQlM3TENNZHFiQ04wQTJjVTUyRVJjd2VSRGxjSHB4d3pGYjhjNFhESVhndUdDQ2lqcndsYkFYVUptUUZmQk9NSUNUVmJqS0FnUVdkVGkxZ1lteUJoUVQ5ZC9BSXhER1VWbjBTOWgzZ0NpdzlyRWhzQk5RRnpCemtOQVFKM0VlMFJheENWQ091R0JEVzFNL2c2SlFSUElZTWdFUW9uQTA5c3pnc25KdmtNK0drQm94SmlBd3cwUFhmdVo2dGd0aVFYL1FjWk1zVkJZQ0h4QzVKUHpReWNHc0VZUWxRdUdlUUh2d1B6R3ZNbjZrRlhCZjhEb3dNVE9rMHo3Z1M5QzJrSWl3ay9BRWtPb3hjSDF4aHFDbkdNMEFFeGl3RzNtUU5Ya1lNQ2I0OEdOd2NMQUdjTGh3VjU1UUFkQXFjSW93QUZBTThEVndBNUFxMEhuUUFaQUlWQkFUMERKeThCSWVVQ2p3T1RDREhMQVpVdkFmTXBCQnZEREJVQTl6ZHVTZ0xEc1FLQWFtYWlCZDFZQW80Q1NUVUJUU1VFQlU1SFVRT3ZjZUVBMndCTEJoUGZSd0VWcTByTEd1TkRBZDl2S3dESEFQc0FCVFVIQlVFQnpRSHpiUUMzQVY4TE1RbWlzN1VCVGVrcEFJTUFGV3NCMXdLSkFOMEFOUUIvOFFGVEFFMEZXZmtGMHdKUFNRRVJNUmdyVjJFQnV3TWZBVE1CRFFCNUJzdU5wY2tISHdSdEI5TUNFQnNWNFFMdkxnZTFBUU1pM3hQTlFzVUN2ZDVWb1dBQ1pJRUNZa0piVGE5Yk55QUNvZmNDYUpnQ1pna0NuNFE0R3dzQ1pqc0NaaVlFYmdSL0EzOFRBMzZTT1FZNWR4YzVnam9qSXdKc0hRSXlOamdLQW0zSEFtMnU3NG96WjBVckFXY0EzZ0RoQUVvRkI1Z01qUUQrQzhJQURiVUNkeThDZHFJL0FubExRd0o0dWgxYzIwV3VSdGNDZkQ4Q2VzZ0NmUWtDZlBBRldRVWdTQUJJZldNa0FvRnRBb0FBQW9BRkFuK3VTVmhLV3hVWFNzd0MwUUVDME14TEp3T0lUd09INWtURmtUSUM4cUZkQXdNRHJrdk9UQzBsQTg5TlRFMnZBb3MvQW9yWXdSc0hIVU5uQmJjQ2pqY0NqbHhBbDRFQ2p0a0NqbHg0VWJSVE5RcFMxRlNGQXBQN0FwTU1BT2tBSEZVZVZhOVYwQVlzR3ltVmhqTGhlR1pGT3prQ2w1OEM3N0pZSWFnQVdTVUNsbzhDbG55Y0FLbFpyRm9KZ1UwQU93S1d0UUtXVGx4RVhORUNtY3NDbVdSY3lsMEhHUUtjbXpuQ09wMENuQllDbjVzQ25yaUtBQjBQTVNvUEFwM3hBcDZTQUxVOVlUUmg3d0tlMHdLZ2JnR3BBcDZmSHdLZVRxVmp5R1FuSlNzQ0o2OENKbjRDb1BzQ29Fd0NvdDBDb2NRQ3BpOENwYzRDcC84QWZRS244bWg4YUxFQUEwbHFIR3JSQXF6akFxeXVBcTFuQXEwQ0FsY2RBbFhjQXJIaDF3TWZUbXlYQXJLOURRS3k2QmRzNEcxamJVaGZBeVhOQXJaY096OXVrQU1wUlFLNFhnSzVSeFVDdVNwM2NEWnc0UUs5R1FLNzJuQ1dBeklSQXI2SWNnSURNM0VDdmhwekluTlBBc1BMQXNNRWM0SjBTelZGZE9BRFBLY0RQSm9EUGI4Q3hYd0N4a2NDeGhDSkFzaHBVUUxJUkFMSlR3TEpMZ0prblFMZDBuaDVZWGl1ZVNWTDBBTVlvMmNDQW1IMEdmT1ZKSHNMWHBKZXV4RUN6MnNDejJ3dlMxUFM4eE9mQU1hdEFzOXpBU25xQTA0U2Zrc0ZBdHduQXR1S0F0SlBBMUpjQTFOZkFRRURWWXlBaVQ4QXl4YnRZRVdDSElMVGdzNkRqUUxheHdMWjNvUVFoRW1uUEFPR3BRQXZBMlFPaG5GWitRQlZBdDlsQXQ2NGMzY0M0aS90RkFIek1DY0I5SnNCOHRLSEF1dnpBdWx3ZVFMcStRTHE1QUQ1UndHNUF1NkpBdXVjbHFxWEF3THVQd09GNEpoNWNPQnhvUUx6QXdCcEE0NFdtWk1DOXhNRGtXNERrb2NDOTVnQytka0MrR2FhSEpxcnV6ZWJIZ09kZ3dMKytnRWJBRG1mSEorekF3V05BNlpxQTZiWkFOSEZBd1pxb1lpaUJRa0RERWtDd0FBL0F3RGhRUmRUQVJIekEyc0hsMmNGQUpNdEs3ZXZ2ZHNCaVprVWZ4RUVPUUg3S1FVaERwMEpud0NTL1NsWHhRTDNBWjBBdHdXNUFHOExiVUV1RkNhTkxnRkRBWUQ4QWJVbUFIVUREZ1J0QUN3Q0ZneWhBQUFLQWowQ2FnUGRBMzRFa1FFZ1JRVWhmQW9BQlFCRUFCTUFOaElDZHdFQUJkVURhKzhLeFFJQTl3cWZKNyt4dCtVQmtTRkJRZ0hwRkg4Uk5NQ0pBQVFBR3dCYUFrVUNoSXNBQmpwVE9wU05iUUM0T284NjBBQ05PTUU2M0FDbEFPZ0F5d0U2Z1RvN09mdzUrVHQyaVRwYk81NkpPbTg1R0FGV0FUTUJiQVV2TlYwMW5qV3ROV1kxZFRXMk5jVTFnaldSTmRJMTRUV2VOYTAxN2pYOU5iSTF3VFlDTmhFMXhqWFZOaFkySnpYZU5lMDJMalk5Tmk0MUxTRTJPalk5Tmp3MnlUY0lCSkE4VnpZNE50MDNJRGNQTnNvZ040azNNQW9Fc0R4bk5pUTNHVGRzT28wM0lVTFVRd2RDNEVNTEhBOFBDWnNvYlNoUlZRWUE2WDhBNmJBQkZDblhBdWtCb3dDOUJiY0Fid056Qkw4TURBTU1BUWdEQUFrS0N3c0xDUW9HQkFWVkJJL0R2d0R6OWIyOWthVUNiMFF0c1JUTkx0NGVHQmNTSEFNWkZoWVpFaFlFQVJBRUJVRWNRUnhCSEVFY1FSeEJIRUVhUVJ4QkhFRkNTVHhCUEVsSVNVaEJOa00yUVRZYk5rbElTVm1CVklnQkZMV1pBdTBCaFFDakJjRUFieWtCdndHSkFhUWNFWjBlUENrbE1BQWhNdkFJTUFMNTRnQzdCbThFZXNjanpRTXBBUlFwS2dEVUFCYXZBajYyNnhRQUpQMEEzZXR6dWY0Tk5SQTdlZnkyWjlOUXJDbkMwT1N5QU56NUJCSWJKNUlGRFI2bWlJYXZZUzZ0cHJqam11S2VieG01Qzc0UTIyNVgxcGthWVlQYjZmMURLNGszeE1FQmI5UzJXTWpFaWJUTldoc1JKSUErdndOVkVpWFRFNWlYcy93ZXpWNjZvRkxmcDlOWkdZVytHazE5SjIrYkNUNlllMnc2TERZZGd6S01VYWJrNTk1ZUxCQ1hBTno5SFVwV2JBVHE5dnFYVng5WERnK1BjOVhwNCtic1MwMDVTVk0vQkpCTTQ2ODdXVXVmK1VqOWRFaThhRE5hUHh0cGJEeGNHMVRIVEltVU1acTRVQ2FhTllwc1ZxcmFOeUtMSlhEWXNGWi81amw3YkxSdE84OHQ3UDN4WmFBeGhiNU9kUE1YcXNTa3AxV0NpZUc4alhtMVU5OStibHZMbFh6UENTK005M1ZuSkNpSyswOUxmYVNhQkFWQm9teURnSnVhOGRmVXpSN2dhMzRJdlIyTnZqK0E5aGVKNmxzbDFLRzROa0kxMDMyQ25mZjFtMXdvZjJCOW9ISks0Ymk2SmtFZFNxZU5laXVvNlFvWlppbmNvYzczL1RIOVNYRjhzQ0U3WHl1WXlXOFdTZ2JHRkNqUFYwaWhMS2hkUHMwOFR4ODJmWUFrTExjNEkyd2RsNGFwWTdHVTVsSFJGelJXSmVwN1d3M3diZUEzcW1kNTkvODZQNHh1TmFxRHB5Z1h0Nk04NWdsU0JIT0NHZ0pEbnQrcE45Yks3SEFwTWd1WDYrMDZSWk5qelZtY1pKK3djVXJKOS8vYnBSTnhOdUtwTmw5dUZkcytTOXRkeDdMYU01WmtJclBqNm5JVTltbmJGdFZiczlzL3VMZ2w4TVZjekF3ZXQraU9FenpCbFlXN1JDTWdFNmd5TkxlcTYrMXRJeDRkcGdabmQwRGtzSlM1ZitKTkRwd3djUE5YYWFWc3BxMWZiUWFqT3JKZ0swb2ZLdEoxTmU5MEw2Vk80TU9sNVM4ODZwN3U2eG83T0xqRzhUR0wrSFUxSlhHSmdwcGc0bk5iTko1bmx6U3B1UFl5MjFKVUVjVUE5NFBvRmlaZmpadWUrUW55UTgwZWtPdVpWa3h4NGcrY3ZoSmZIZ05sNGh5MS9hNitSS2NLbGFyL0oyOXkvL0V6dGxiVlBIVlVlUTF6WDg2ZVFWQWpSL00zZEE5dzRXOExmYVhwNEVnTTg1d09XYXNsaTgzN1B6Vk1PbnNMelIrazNvNzUvbFJQQUpTRTF4QUtRekVpNXYxMGtlK1ZCdlJ0MWN3UVJNZCtVNW1MQ1RHVmQ2WGladGdCRzVjRGkwdzIyR0tjVk52SGl1NUxRYlpFRFZ0ejBvbm43azUraGV1S1hWc1p0U3ppbGtMUkFVbWpNWEVNQjNKOVlDNTBYQnhQaXo1M1NDK0VoblBsOVdzS0N2OTJTTS9PRkZJTUpaWWZsMFdXOHRJTzNVeFljd2RNQWo3RlNtZ3JzWjJhQVpPMDNCT2hQMWJOTlpJdHlYWVFGVHBDM1NHMVZ1UERxSDlHa2lDRG1FK0p3eHlJVlNPNXNpREVyQU9wRVhGZ2p5NlBRdE9WRGorczZlMXI4aGVXVnZtWm5UY2l1ZjRFaU5aekNBZDdTT01oWEVSSU9sc0hJTUczOTlpOWFMVHkzbTJoUkxaakpWRE5MUzUzaUdJSzExZFBxUXQwekJEeWc2cWM3WXFrRG0yTTVWZTZkQ1dDYUNiVFhYMnJUb2FJZ3o2K3poNGxZVWkvKzZucWNGTUFrUUpLSFlMSzB3WWs1TjlzelY2eGloRGJEREZyNDVsTjFLNGFDWEJxL0ZpdFBTdWQ5Z0x0NVpWbitacUdYN2N3bTJ6NUVHTWdmRnBJRnloR0d1RFBtc282VEl0VE13bnkrN3VQbkxDZjRXNmdvRlFGVjBvUVNzYzlWZk1tVkxjTHI2WmV0RFpiYVNGVExxblNPL2JJUGpBMy96QVVvcWdHRkFFUVM0SWh1TXpFcDJJM2pKemJ6a2svSUVteWF4K3JoWlR3ZDZmK0NHdHdQaXh1OEl2ekFDcXVQV1BSRXU5WnZHa1V6cFJ3dlJSdWFOTjZjcjBXMXdXaXRzOUlDZFlKN2x0YmdNaVNMM3NUUGV1ZmdOY1ZxTVZXRmtDUERINGpHMmpBMFhjVmdRajYyQ2IyOXY5Zi96LysyS2JZdkl2L3p6anBRQVBrbGlhVkR6TnJXNTdUWi9aT3laRDBubGZNbUFJQklBR0FJMEQzay9tZE40eHI5djg1WmJaYmJxZkgyakdkNWhVcU5aV3dsNVNQZm9HbWZFbG1helVJZU5MMWovbWtGN1ZOQXpUcTRqTnQ4Sm9RMTFOUU9jbWhwclhveFN4ZlJHSjlMREVPQVErZG14QVFIOTBpdGk5ZTJ1L01vZXVhR2NEVEhvQyt4c21FZVdteEVLZWZRdUl6SGJwdzVUYzVjRW9jYm9BRDA5b2lwV1FodFRPMXdpdmYvTytEUmUycnBsL0U5d2xyekJvcmpKc09lRzFCL1hQVzRFYUpFRmRObEVDRVpnYTVab0dSSFhnWW91R1J1VmttOHRERVNpRXlGTm8rM3M1TTVwdVNkVHlVTDJsbG5JTlZIRXQ5MVhVTlc0ZXdkTWdKNGJvSmZFeXQvaVk1V1hxYkErQTJGa3Q1WjBsdXRpV2hlOW5aSXlJVWp5WERDM1VzYUcxdCtlTng2ejRXL09Zb1RCN0E2eCtkTlNUT2k5QUluY3RiRVNxbTVndk9Md3c3T1dYUHJtSHdWWmFzcmw0ZUQxMTNwbStKdFQ3SlZPdm5DWHFkenpkVFJIZ0owUGlHVEZZVzVHdnQ5UjlMRDZMemZzMHYvVFpaSFNteVZOcTd2aUlIRTZEQks3UXAwN0l6NTVFTThTWXRRdlpmL29iQm5pVFdpNUMyL292SGZ3NFZuZGtFNVhZZGpPaENNUmpEZU9FZlhlTi9Dd2ZHZHVpVUlmc29GZVV4WGVRWGJhN2M3OTcyWE52OHcrZFRqalVNMFFlTkFSZVcrSjAxNGRLQUQvTWNRWVhUN2MwR1FQSWtuM0xsNlI3Z0dqdWlRb1pEMFRFZUVxUXBLb1oxNWcvME9QUUkxN1FpU3Y5QVVST2EvVi9UUU4zZHZMQXJlYzNScnNZbHZCbTFiOExXemx0ZHVnc0M1MGxOS1lMRXAyYStaWllxUGVqVUxSbE9KaDV6ai9MVk15VER2d0toTXh4d3VEa3hKMVFwb05JME9UV0xvbTRaNzFTTnpJOVRWMWlYSnJJdTlXY25kK01DYUF3OG8xalNYZDk0WVUvMWdua3JDOUJVRU90UXZFSVE3ZzBpNmgrS0wySktrOFlkbDdIcnV2Z1dNU0FtTmUrTHNoR2hWNHFuV0hoTzkvUklQUXpZMXRIUmoyVnFPeU5zRHBLMGN3dys1NkFkREM0Z3NXd1kwWHhvdWNJV0lxcy9HY3duV3FsYVQwS1ByOG1iSzVVOTQvMzAxaTFXTHQ0WUlOVFZ2Q0ZCckZaYkliWThleWNPZGVKMnRlRDVJZlBMQ1JnN2pqY0ZUd2xNRk5sOXpkaC9vM0UvaEhQd2o3QldnME1VMDlwUHJCTGJyQ2dtNTRBNkgrSTZ2Mjcrakw1Z2tqV2cvaVlka3M5amJmVlA1eS9uMGRsZ1dFTWxLYXNsN0p2RlpkNTZMZnliVzFlZWFWTzBneFRmWFp3RDhHNFNJMTE2eXg3VUtWUmd1aTZZYTFZcGl4cVhlTkxjOEl4dEF3Q1U1SWh3UWduK05xSG5SYUR2NjFDeEtoT3E0cE9YN002cGtBK1BtcGQ0ajF2bjZBQ1VBTG9MTGM0dnBYY2k4VmlkTHh6bTdxRkJlN3MrcXV1SnM2RVRZbW5wZ1MzTHdTWnhQSWx0Z0JEWHo4TTFrL1cyeVNOdjJmOS9OUGh4TEdLMkQyMWRrSGVTR21lblJUM1lxY2RsMG0vaDNPWXI4VitsWE5ZR2Y4YUNDcGQ0YldqRTRRSVBqN3ZVS040TnJmczdNTDZZMk95UzgzMEpDbm9mZy9rN2xwRnB0NFNxWmM1SEdnMUhDT3JIdk9kQzhiUDZGR0RiRS9WVjBtWDRJYWt6YmRTL29wK0t0M0cyNC84UWJCVjd5ODZzR1NRL3ZaelU4RlhzN3U2akl2d2Noc0VQMkJwSWhXM0c4dVdOd2EzSG1qZkgvWmpoaENXdmx1QWNGK25NZjE0Q2xLZzVoR2d0UExKOTh1ZU5Ba2M1SHMyV1psazJRSHZmcmVDSzFDQ0dPNm5NWlZTYjk5Vk0vYWpyOFdIVHRlOUpTbWtYcS9pL1U5NDNIRWJkelc2UmUvUzg4ZEtnZzhwR09MbEFlTmlxcmNMa1VSMy9hQ2xGcE1YY09VUDNybUVUY1dTZk1YWkUzVFVPaThpK2ZxUm5UWUxmbFZ4L1ZiLzZHSjdlSVJaVUE2azNSWVIzaUZTSzljNGlEZE53SnVaTDJGS3ovSUs1VmltY05XRXFkWGpTb3hTZ21GMFVQbERvVWxOclBjTTdmdG1BOFk5Z0tpcUtFSHVXTitBWlJJd3RWU3h5ZTJLZjhyTTNsaEo1WGNCWFU5bjR2ME95MVJVMk0rNHFNOEFRUFZ3c2U4RXJOU29iNW9GUFd4dXFablZ6bzFxQi9JQnhrTTNFVlVLRlVVbE8zZTUxMjU5R2dOY0piQ21sdnJkanRvVFc3ckNobTF3eUNLenBDVHdvelVVRU9JY1dMbmVSTGdNWGgrU2pHU0ZrQWxsemJHUzVISzdMbGZDTVJOUkRTdmJRUGpjWGFlbk5ZeEN2dTJReXpuejZTdHV4Vmo2NlNnSTBUOEI2L3NmSEFKWVphWjc4dGhqT1NJRnVtTldMUWJlWml4RENDQyt2MFlCdGt4aUJCM2plZkhxWi9kRkhVK2NyYmo2T3ZTMXgvSkREN3ZsbTd6T1ZQd3BVQzAxbmh4WnVZLzYzRTdnJztcclxuXHJcbi8vIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjE1L1xyXG4vLyBmb3IgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uXHJcbi8vIHNlZTogL2Rlcml2ZS9uZi5qc1xyXG5cclxuXHJcbi8vIGFsZ29yaXRobWljIGhhbmd1bFxyXG4vLyBodHRwczovL3d3dy51bmljb2RlLm9yZy92ZXJzaW9ucy9Vbmljb2RlMTUuMC4wL2NoMDMucGRmIChwYWdlIDE0NClcclxuY29uc3QgUzAgPSAweEFDMDA7XHJcbmNvbnN0IEwwID0gMHgxMTAwO1xyXG5jb25zdCBWMCA9IDB4MTE2MTtcclxuY29uc3QgVDAgPSAweDExQTc7XHJcbmNvbnN0IExfQ09VTlQgPSAxOTtcclxuY29uc3QgVl9DT1VOVCA9IDIxO1xyXG5jb25zdCBUX0NPVU5UID0gMjg7XHJcbmNvbnN0IE5fQ09VTlQgPSBWX0NPVU5UICogVF9DT1VOVDtcclxuY29uc3QgU19DT1VOVCA9IExfQ09VTlQgKiBOX0NPVU5UO1xyXG5jb25zdCBTMSA9IFMwICsgU19DT1VOVDtcclxuY29uc3QgTDEgPSBMMCArIExfQ09VTlQ7XHJcbmNvbnN0IFYxID0gVjAgKyBWX0NPVU5UO1xyXG5jb25zdCBUMSA9IFQwICsgVF9DT1VOVDtcclxuXHJcbmZ1bmN0aW9uIHVucGFja19jYyhwYWNrZWQpIHtcclxuXHRyZXR1cm4gKHBhY2tlZCA+PiAyNCkgJiAweEZGO1xyXG59XHJcbmZ1bmN0aW9uIHVucGFja19jcChwYWNrZWQpIHtcclxuXHRyZXR1cm4gcGFja2VkICYgMHhGRkZGRkY7XHJcbn1cclxuXHJcbmxldCBTSElGVEVEX1JBTkssIEVYQ0xVU0lPTlMsIERFQ09NUCwgUkVDT01QO1xyXG5cclxuZnVuY3Rpb24gaW5pdCQxKCkge1xyXG5cdC8vY29uc29sZS50aW1lKCduZicpO1xyXG5cdGxldCByID0gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoQ09NUFJFU1NFRCk7XHJcblx0U0hJRlRFRF9SQU5LID0gbmV3IE1hcChyZWFkX3NvcnRlZF9hcnJheXMocikuZmxhdE1hcCgodiwgaSkgPT4gdi5tYXAoeCA9PiBbeCwgKGkrMSkgPDwgMjRdKSkpOyAvLyBwcmUtc2hpZnRlZFxyXG5cdEVYQ0xVU0lPTlMgPSBuZXcgU2V0KHJlYWRfc29ydGVkKHIpKTtcclxuXHRERUNPTVAgPSBuZXcgTWFwKCk7XHJcblx0UkVDT01QID0gbmV3IE1hcCgpO1xyXG5cdGZvciAobGV0IFtjcCwgY3BzXSBvZiByZWFkX21hcHBlZChyKSkge1xyXG5cdFx0aWYgKCFFWENMVVNJT05TLmhhcyhjcCkgJiYgY3BzLmxlbmd0aCA9PSAyKSB7XHJcblx0XHRcdGxldCBbYSwgYl0gPSBjcHM7XHJcblx0XHRcdGxldCBidWNrZXQgPSBSRUNPTVAuZ2V0KGEpO1xyXG5cdFx0XHRpZiAoIWJ1Y2tldCkge1xyXG5cdFx0XHRcdGJ1Y2tldCA9IG5ldyBNYXAoKTtcclxuXHRcdFx0XHRSRUNPTVAuc2V0KGEsIGJ1Y2tldCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YnVja2V0LnNldChiLCBjcCk7XHJcblx0XHR9XHJcblx0XHRERUNPTVAuc2V0KGNwLCBjcHMucmV2ZXJzZSgpKTsgLy8gc3RvcmVkIHJldmVyc2VkXHJcblx0fVxyXG5cdC8vY29uc29sZS50aW1lRW5kKCduZicpO1xyXG5cdC8vIDIwMjMwOTA1OiAxMW1zXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzX2hhbmd1bChjcCkge1xyXG5cdHJldHVybiBjcCA+PSBTMCAmJiBjcCA8IFMxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wb3NlX3BhaXIoYSwgYikge1xyXG5cdGlmIChhID49IEwwICYmIGEgPCBMMSAmJiBiID49IFYwICYmIGIgPCBWMSkge1xyXG5cdFx0cmV0dXJuIFMwICsgKGEgLSBMMCkgKiBOX0NPVU5UICsgKGIgLSBWMCkgKiBUX0NPVU5UO1xyXG5cdH0gZWxzZSBpZiAoaXNfaGFuZ3VsKGEpICYmIGIgPiBUMCAmJiBiIDwgVDEgJiYgKGEgLSBTMCkgJSBUX0NPVU5UID09IDApIHtcclxuXHRcdHJldHVybiBhICsgKGIgLSBUMCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGxldCByZWNvbXAgPSBSRUNPTVAuZ2V0KGEpO1xyXG5cdFx0aWYgKHJlY29tcCkge1xyXG5cdFx0XHRyZWNvbXAgPSByZWNvbXAuZ2V0KGIpO1xyXG5cdFx0XHRpZiAocmVjb21wKSB7XHJcblx0XHRcdFx0cmV0dXJuIHJlY29tcDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVjb21wb3NlZChjcHMpIHtcclxuXHRpZiAoIVNISUZURURfUkFOSykgaW5pdCQxKCk7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRsZXQgY2hlY2tfb3JkZXIgPSBmYWxzZTtcclxuXHRmdW5jdGlvbiBhZGQoY3ApIHtcclxuXHRcdGxldCBjYyA9IFNISUZURURfUkFOSy5nZXQoY3ApO1xyXG5cdFx0aWYgKGNjKSB7XHJcblx0XHRcdGNoZWNrX29yZGVyID0gdHJ1ZTtcclxuXHRcdFx0Y3AgfD0gY2M7XHJcblx0XHR9XHJcblx0XHRyZXQucHVzaChjcCk7XHJcblx0fVxyXG5cdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0aWYgKGNwIDwgMHg4MCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKGNwKTtcclxuXHRcdFx0fSBlbHNlIGlmIChpc19oYW5ndWwoY3ApKSB7XHJcblx0XHRcdFx0bGV0IHNfaW5kZXggPSBjcCAtIFMwO1xyXG5cdFx0XHRcdGxldCBsX2luZGV4ID0gc19pbmRleCAvIE5fQ09VTlQgfCAwO1xyXG5cdFx0XHRcdGxldCB2X2luZGV4ID0gKHNfaW5kZXggJSBOX0NPVU5UKSAvIFRfQ09VTlQgfCAwO1xyXG5cdFx0XHRcdGxldCB0X2luZGV4ID0gc19pbmRleCAlIFRfQ09VTlQ7XHJcblx0XHRcdFx0YWRkKEwwICsgbF9pbmRleCk7XHJcblx0XHRcdFx0YWRkKFYwICsgdl9pbmRleCk7XHJcblx0XHRcdFx0aWYgKHRfaW5kZXggPiAwKSBhZGQoVDAgKyB0X2luZGV4KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgbWFwcGVkID0gREVDT01QLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKG1hcHBlZCkge1xyXG5cdFx0XHRcdFx0YnVmLnB1c2goLi4ubWFwcGVkKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YWRkKGNwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFidWYubGVuZ3RoKSBicmVhaztcclxuXHRcdFx0Y3AgPSBidWYucG9wKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChjaGVja19vcmRlciAmJiByZXQubGVuZ3RoID4gMSkge1xyXG5cdFx0bGV0IHByZXZfY2MgPSB1bnBhY2tfY2MocmV0WzBdKTtcclxuXHRcdGZvciAobGV0IGkgPSAxOyBpIDwgcmV0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBjYyA9IHVucGFja19jYyhyZXRbaV0pO1xyXG5cdFx0XHRpZiAoY2MgPT0gMCB8fCBwcmV2X2NjIDw9IGNjKSB7XHJcblx0XHRcdFx0cHJldl9jYyA9IGNjO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxldCBqID0gaS0xO1xyXG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRcdGxldCB0bXAgPSByZXRbaisxXTtcclxuXHRcdFx0XHRyZXRbaisxXSA9IHJldFtqXTtcclxuXHRcdFx0XHRyZXRbal0gPSB0bXA7XHJcblx0XHRcdFx0aWYgKCFqKSBicmVhaztcclxuXHRcdFx0XHRwcmV2X2NjID0gdW5wYWNrX2NjKHJldFstLWpdKTtcclxuXHRcdFx0XHRpZiAocHJldl9jYyA8PSBjYykgYnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0cHJldl9jYyA9IHVucGFja19jYyhyZXRbaV0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wb3NlZF9mcm9tX2RlY29tcG9zZWQodikge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgc3RhY2sgPSBbXTtcclxuXHRsZXQgcHJldl9jcCA9IC0xO1xyXG5cdGxldCBwcmV2X2NjID0gMDtcclxuXHRmb3IgKGxldCBwYWNrZWQgb2Ygdikge1xyXG5cdFx0bGV0IGNjID0gdW5wYWNrX2NjKHBhY2tlZCk7XHJcblx0XHRsZXQgY3AgPSB1bnBhY2tfY3AocGFja2VkKTtcclxuXHRcdGlmIChwcmV2X2NwID09IC0xKSB7XHJcblx0XHRcdGlmIChjYyA9PSAwKSB7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldC5wdXNoKGNwKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChwcmV2X2NjID4gMCAmJiBwcmV2X2NjID49IGNjKSB7XHJcblx0XHRcdGlmIChjYyA9PSAwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gocHJldl9jcCwgLi4uc3RhY2spO1xyXG5cdFx0XHRcdHN0YWNrLmxlbmd0aCA9IDA7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2goY3ApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjb21wb3NlZCA9IGNvbXBvc2VfcGFpcihwcmV2X2NwLCBjcCk7XHJcblx0XHRcdGlmIChjb21wb3NlZCA+PSAwKSB7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNvbXBvc2VkO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHByZXZfY2MgPT0gMCAmJiBjYyA9PSAwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gocHJldl9jcCk7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2goY3ApO1xyXG5cdFx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAocHJldl9jcCA+PSAwKSB7XHJcblx0XHRyZXQucHVzaChwcmV2X2NwLCAuLi5zdGFjayk7XHRcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuLy8gbm90ZTogY3BzIGNhbiBiZSBpdGVyYWJsZVxyXG5mdW5jdGlvbiBuZmQoY3BzKSB7XHJcblx0cmV0dXJuIGRlY29tcG9zZWQoY3BzKS5tYXAodW5wYWNrX2NwKTtcclxufVxyXG5mdW5jdGlvbiBuZmMoY3BzKSB7XHJcblx0cmV0dXJuIGNvbXBvc2VkX2Zyb21fZGVjb21wb3NlZChkZWNvbXBvc2VkKGNwcykpO1xyXG59XHJcblxyXG5jb25zdCBIWVBIRU4gPSAweDJEO1xyXG5jb25zdCBTVE9QID0gMHgyRTtcclxuY29uc3QgU1RPUF9DSCA9ICcuJztcclxuY29uc3QgRkUwRiA9IDB4RkUwRjtcclxuY29uc3QgVU5JUVVFX1BIID0gMTtcclxuXHJcbi8vIDIwMjMwOTEzOiByZXBsYWNlIFsuLi52XSB3aXRoIEFycmF5X2Zyb20odikgdG8gYXZvaWQgbGFyZ2Ugc3ByZWFkc1xyXG5jb25zdCBBcnJheV9mcm9tID0geCA9PiBBcnJheS5mcm9tKHgpOyAvLyBBcnJheS5mcm9tLmJpbmQoQXJyYXkpO1xyXG5cclxuZnVuY3Rpb24gZ3JvdXBfaGFzX2NwKGcsIGNwKSB7XHJcblx0Ly8gMjAyMzA5MTM6IGtlZXAgcHJpbWFyeSBhbmQgc2Vjb25kYXJ5IGRpc3RpbmN0IGluc3RlYWQgb2YgY3JlYXRpbmcgdmFsaWQgdW5pb25cclxuXHRyZXR1cm4gZy5QLmhhcyhjcCkgfHwgZy5RLmhhcyhjcCk7XHJcbn1cclxuXHJcbmNsYXNzIEVtb2ppIGV4dGVuZHMgQXJyYXkge1xyXG5cdGdldCBpc19lbW9qaSgpIHsgcmV0dXJuIHRydWU7IH0gLy8gZnJlZSB0YWdnaW5nIHN5c3RlbVxyXG59XHJcblxyXG5sZXQgTUFQUEVELCBJR05PUkVELCBDTSwgTlNNLCBFU0NBUEUsIE5GQ19DSEVDSywgR1JPVVBTLCBXSE9MRV9WQUxJRCwgV0hPTEVfTUFQLCBWQUxJRCwgRU1PSklfTElTVCwgRU1PSklfUk9PVDtcclxuXHJcbmZ1bmN0aW9uIGluaXQoKSB7XHJcblx0aWYgKE1BUFBFRCkgcmV0dXJuO1xyXG5cdFxyXG5cdGxldCByID0gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoQ09NUFJFU1NFRCQxKTtcclxuXHRjb25zdCByZWFkX3NvcnRlZF9hcnJheSA9ICgpID0+IHJlYWRfc29ydGVkKHIpO1xyXG5cdGNvbnN0IHJlYWRfc29ydGVkX3NldCA9ICgpID0+IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKSk7XHJcblx0Y29uc3Qgc2V0X2FkZF9tYW55ID0gKHNldCwgdikgPT4gdi5mb3JFYWNoKHggPT4gc2V0LmFkZCh4KSk7XHJcblxyXG5cdE1BUFBFRCA9IG5ldyBNYXAocmVhZF9tYXBwZWQocikpOyBcclxuXHRJR05PUkVEID0gcmVhZF9zb3J0ZWRfc2V0KCk7IC8vIGlnbm9yZWQgY2hhcmFjdGVycyBhcmUgbm90IHZhbGlkLCBzbyBqdXN0IHJlYWQgcmF3IGNvZGVwb2ludHNcclxuXHJcblx0LypcclxuXHQvLyBkaXJlY3QgaW5jbHVkZSBmcm9tIHBheWxvYWQgaXMgc21hbGxlciB0aGFuIHRoZSBkZWNvbXByZXNzaW9uIGNvZGVcclxuXHRjb25zdCBGRU5DRUQgPSBuZXcgTWFwKHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4ge1xyXG5cdFx0bGV0IGNwID0gcigpO1xyXG5cdFx0aWYgKGNwKSByZXR1cm4gW2NwLCByZWFkX3N0cihyKCkpXTtcclxuXHR9KSk7XHJcblx0Ki9cclxuXHQvLyAyMDIzMDIxNzogd2Ugc3RpbGwgbmVlZCBhbGwgQ00gZm9yIHByb3BlciBlcnJvciBmb3JtYXR0aW5nXHJcblx0Ly8gYnV0IG5vcm0gb25seSBuZWVkcyBOU00gc3Vic2V0IHRoYXQgYXJlIHBvdGVudGlhbGx5LXZhbGlkXHJcblx0Q00gPSByZWFkX3NvcnRlZF9hcnJheSgpO1xyXG5cdE5TTSA9IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKS5tYXAoaSA9PiBDTVtpXSkpO1xyXG5cdENNID0gbmV3IFNldChDTSk7XHJcblx0XHJcblx0RVNDQVBFID0gcmVhZF9zb3J0ZWRfc2V0KCk7IC8vIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgbm90IGJlIHByaW50ZWRcclxuXHRORkNfQ0hFQ0sgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gb25seSBuZWVkZWQgdG8gaWxsdXN0cmF0ZSBlbnNfdG9rZW5pemUoKSB0cmFuc2Zvcm1hdGlvbnNcclxuXHJcblx0bGV0IGNodW5rcyA9IHJlYWRfc29ydGVkX2FycmF5cyhyKTtcclxuXHRsZXQgdW5yZXN0cmljdGVkID0gcigpO1xyXG5cdC8vY29uc3QgcmVhZF9jaHVua2VkID0gKCkgPT4gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpLmZsYXRNYXAoaSA9PiBjaHVua3NbaV0pLmNvbmNhdChyZWFkX3NvcnRlZF9hcnJheSgpKSk7XHJcblx0Y29uc3QgcmVhZF9jaHVua2VkID0gKCkgPT4ge1xyXG5cdFx0Ly8gMjAyMzA5MjE6IGJ1aWxkIHNldCBpbiBwYXJ0cywgMnggZmFzdGVyXHJcblx0XHRsZXQgc2V0ID0gbmV3IFNldCgpO1xyXG5cdFx0cmVhZF9zb3J0ZWRfYXJyYXkoKS5mb3JFYWNoKGkgPT4gc2V0X2FkZF9tYW55KHNldCwgY2h1bmtzW2ldKSk7XHJcblx0XHRzZXRfYWRkX21hbnkoc2V0LCByZWFkX3NvcnRlZF9hcnJheSgpKTtcclxuXHRcdHJldHVybiBzZXQ7IFxyXG5cdH07XHJcblx0R1JPVVBTID0gcmVhZF9hcnJheV93aGlsZShpID0+IHtcclxuXHRcdC8vIG1pbmlmaWVyIHByb3BlcnR5IG1hbmdsaW5nIHNlZW1zIHVuc2FmZVxyXG5cdFx0Ly8gc28gdGhlc2UgYXJlIG1hbnVhbGx5IHJlbmFtZWQgdG8gc2luZ2xlIGNoYXJzXHJcblx0XHRsZXQgTiA9IHJlYWRfYXJyYXlfd2hpbGUocikubWFwKHggPT4geCsweDYwKTtcclxuXHRcdGlmIChOLmxlbmd0aCkge1xyXG5cdFx0XHRsZXQgUiA9IGkgPj0gdW5yZXN0cmljdGVkOyAvLyB1bnJlc3RyaWN0ZWQgdGhlbiByZXN0cmljdGVkXHJcblx0XHRcdE5bMF0gLT0gMzI7IC8vIGNhcGl0YWxpemVcclxuXHRcdFx0TiA9IHN0cl9mcm9tX2NwcyhOKTtcclxuXHRcdFx0aWYgKFIpIE49YFJlc3RyaWN0ZWRbJHtOfV1gO1xyXG5cdFx0XHRsZXQgUCA9IHJlYWRfY2h1bmtlZCgpOyAvLyBwcmltYXJ5XHJcblx0XHRcdGxldCBRID0gcmVhZF9jaHVua2VkKCk7IC8vIHNlY29uZGFyeVxyXG5cdFx0XHRsZXQgTSA9ICFyKCk7IC8vIG5vdC13aGl0ZWxpc3RlZCwgY2hlY2sgZm9yIE5TTVxyXG5cdFx0XHQvLyAqKiogdGhpcyBjb2RlIGN1cnJlbnRseSBpc24ndCBuZWVkZWQgKioqXHJcblx0XHRcdC8qXHJcblx0XHRcdGxldCBWID0gWy4uLlAsIC4uLlFdLnNvcnQoKGEsIGIpID0+IGEtYik7IC8vIGRlcml2ZTogc29ydGVkIHZhbGlkXHJcblx0XHRcdGxldCBNID0gcigpLTE7IC8vIG51bWJlciBvZiBjb21iaW5pbmcgbWFya1xyXG5cdFx0XHRpZiAoTSA8IDApIHsgLy8gd2hpdGVsaXN0ZWRcclxuXHRcdFx0XHRNID0gbmV3IE1hcChyZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdFx0XHRcdGxldCBpID0gcigpO1xyXG5cdFx0XHRcdFx0aWYgKGkpIHJldHVybiBbVltpLTFdLCByZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdFx0XHRcdFx0bGV0IHYgPSByZWFkX2FycmF5X3doaWxlKHIpO1xyXG5cdFx0XHRcdFx0XHRpZiAodi5sZW5ndGgpIHJldHVybiB2Lm1hcCh4ID0+IHgtMSk7XHJcblx0XHRcdFx0XHR9KV07XHJcblx0XHRcdFx0fSkpO1xyXG5cdFx0XHR9Ki9cclxuXHRcdFx0cmV0dXJuIHtOLCBQLCBRLCBNLCBSfTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0Ly8gZGVjb2RlIGNvbXByZXNzZWQgd2hvbGVzXHJcblx0V0hPTEVfVkFMSUQgPSByZWFkX3NvcnRlZF9zZXQoKTtcclxuXHRXSE9MRV9NQVAgPSBuZXcgTWFwKCk7XHJcblx0bGV0IHdob2xlcyA9IHJlYWRfc29ydGVkX2FycmF5KCkuY29uY2F0KEFycmF5X2Zyb20oV0hPTEVfVkFMSUQpKS5zb3J0KChhLCBiKSA9PiBhLWIpOyAvLyBtdXN0IGJlIHNvcnRlZFxyXG5cdHdob2xlcy5mb3JFYWNoKChjcCwgaSkgPT4ge1xyXG5cdFx0bGV0IGQgPSByKCk7IFxyXG5cdFx0bGV0IHcgPSB3aG9sZXNbaV0gPSBkID8gd2hvbGVzW2ktZF0gOiB7VjogW10sIE06IG5ldyBNYXAoKX07XHJcblx0XHR3LlYucHVzaChjcCk7IC8vIGFkZCB0byBtZW1iZXIgc2V0XHJcblx0XHRpZiAoIVdIT0xFX1ZBTElELmhhcyhjcCkpIHtcclxuXHRcdFx0V0hPTEVfTUFQLnNldChjcCwgdyk7ICAvLyByZWdpc3RlciB3aXRoIHdob2xlIG1hcFxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvLyBjb21wdXRlIGNvbmZ1c2FibGUtZXh0ZW50IGNvbXBsZW1lbnRzXHJcblx0Ly8gdXNhZ2U6IFdIT0xFX01BUC5nZXQoY3ApLk0uZ2V0KGNwKSA9IGNvbXBsZW1lbnQgc2V0XHJcblx0Zm9yIChsZXQge1YsIE19IG9mIG5ldyBTZXQoV0hPTEVfTUFQLnZhbHVlcygpKSkge1xyXG5cdFx0Ly8gY29ubmVjdCBhbGwgZ3JvdXBzIHRoYXQgaGF2ZSBlYWNoIHdob2xlIGNoYXJhY3RlclxyXG5cdFx0bGV0IHJlY3MgPSBbXTtcclxuXHRcdGZvciAobGV0IGNwIG9mIFYpIHtcclxuXHRcdFx0bGV0IGdzID0gR1JPVVBTLmZpbHRlcihnID0+IGdyb3VwX2hhc19jcChnLCBjcCkpO1xyXG5cdFx0XHRsZXQgcmVjID0gcmVjcy5maW5kKCh7R30pID0+IGdzLnNvbWUoZyA9PiBHLmhhcyhnKSkpO1xyXG5cdFx0XHRpZiAoIXJlYykge1xyXG5cdFx0XHRcdHJlYyA9IHtHOiBuZXcgU2V0KCksIFY6IFtdfTtcclxuXHRcdFx0XHRyZWNzLnB1c2gocmVjKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZWMuVi5wdXNoKGNwKTtcclxuXHRcdFx0c2V0X2FkZF9tYW55KHJlYy5HLCBncyk7XHJcblx0XHR9XHJcblx0XHQvLyBwZXIgY2hhcmFjdGVyIGNhY2hlIGdyb3VwcyB3aGljaCBhcmUgbm90IGEgbWVtYmVyIG9mIHRoZSBleHRlbnRcclxuXHRcdGxldCB1bmlvbiA9IHJlY3MuZmxhdE1hcCh4ID0+IEFycmF5X2Zyb20oeC5HKSk7IC8vIGFsbCBvZiB0aGUgZ3JvdXBzIHVzZWQgYnkgdGhpcyB3aG9sZVxyXG5cdFx0Zm9yIChsZXQge0csIFZ9IG9mIHJlY3MpIHtcclxuXHRcdFx0bGV0IGNvbXBsZW1lbnQgPSBuZXcgU2V0KHVuaW9uLmZpbHRlcihnID0+ICFHLmhhcyhnKSkpOyAvLyBncm91cHMgbm90IGNvdmVyZWQgYnkgdGhlIGV4dGVudFxyXG5cdFx0XHRmb3IgKGxldCBjcCBvZiBWKSB7XHJcblx0XHRcdFx0TS5zZXQoY3AsIGNvbXBsZW1lbnQpOyAvLyB0aGlzIGlzIHRoZSBzYW1lIHJlZmVyZW5jZVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBjb21wdXRlIHZhbGlkIHNldFxyXG5cdC8vIDIwMjMwOTI0OiBWQUxJRCB3YXMgdW5pb24gYnV0IGNhbiBiZSByZS11c2VkXHJcblx0VkFMSUQgPSBuZXcgU2V0KCk7IC8vIGV4aXN0cyBpbiAxKyBncm91cHNcclxuXHRsZXQgbXVsdGkgPSBuZXcgU2V0KCk7IC8vIGV4aXN0cyBpbiAyKyBncm91cHNcclxuXHRjb25zdCBhZGRfdG9fdW5pb24gPSBjcCA9PiBWQUxJRC5oYXMoY3ApID8gbXVsdGkuYWRkKGNwKSA6IFZBTElELmFkZChjcCk7XHJcblx0Zm9yIChsZXQgZyBvZiBHUk9VUFMpIHtcclxuXHRcdGZvciAobGV0IGNwIG9mIGcuUCkgYWRkX3RvX3VuaW9uKGNwKTtcclxuXHRcdGZvciAobGV0IGNwIG9mIGcuUSkgYWRkX3RvX3VuaW9uKGNwKTtcclxuXHR9XHJcblx0Ly8gZHVhbCBwdXJwb3NlIFdIT0xFX01BUDogcmV0dXJuIHBsYWNlaG9sZGVyIGlmIHVuaXF1ZSBub24tY29uZnVzYWJsZVxyXG5cdGZvciAobGV0IGNwIG9mIFZBTElEKSB7XHJcblx0XHRpZiAoIVdIT0xFX01BUC5oYXMoY3ApICYmICFtdWx0aS5oYXMoY3ApKSB7XHJcblx0XHRcdFdIT0xFX01BUC5zZXQoY3AsIFVOSVFVRV9QSCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vIGFkZCBhbGwgZGVjb21wb3NlZCBwYXJ0c1xyXG5cdC8vIHNlZSBkZXJpdmU6IFwiVmFsaWQgaXMgQ2xvc2VkICh2aWEgQnJ1dGUtZm9yY2UpXCJcclxuXHRzZXRfYWRkX21hbnkoVkFMSUQsIG5mZChWQUxJRCkpO1xyXG5cdFxyXG5cdC8vIGRlY29kZSBlbW9qaVxyXG5cdC8vIDIwMjMwNzE5OiBlbW9qaSBhcmUgbm93IGZ1bGx5LWV4cGFuZGVkIHRvIGF2b2lkIHF1aXJrIGxvZ2ljIFxyXG5cdEVNT0pJX0xJU1QgPSByZWFkX3RyaWUocikubWFwKHYgPT4gRW1vamkuZnJvbSh2KSkuc29ydChjb21wYXJlX2FycmF5cyk7XHJcblx0RU1PSklfUk9PVCA9IG5ldyBNYXAoKTsgLy8gdGhpcyBoYXMgYXBwcm94IDdLIG5vZGVzICgyKyBwZXIgZW1vamkpXHJcblx0Zm9yIChsZXQgY3BzIG9mIEVNT0pJX0xJU1QpIHtcclxuXHRcdC8vIDIwMjMwNzE5OiBjaGFuZ2UgdG8gKnNsaWdodGx5KiBzdHJpY3RlciBhbGdvcml0aG0gd2hpY2ggZGlzYWxsb3dzIFxyXG5cdFx0Ly8gaW5zZXJ0aW9uIG9mIG1pc3BsYWNlZCBGRTBGIGluIGVtb2ppIHNlcXVlbmNlcyAobWF0Y2hpbmcgRU5TSVAtMTUpXHJcblx0XHQvLyBleGFtcGxlOiBiZWF1dGlmaWVkIFtBIEJdIChlZy4gZmxhZyBlbW9qaSkgXHJcblx0XHQvLyAgYmVmb3JlOiBhbGxvdzogW0EgRkUwRiBCXSwgZXJyb3I6IFtBIEZFMEYgRkUwRiBCXSBcclxuXHRcdC8vICAgYWZ0ZXI6IGVycm9yOiBib3RoXHJcblx0XHQvLyBub3RlOiB0aGlzIGNvZGUgbm93IG1hdGNoZXMgRU5TTm9ybWFsaXplLntjcyxqYXZhfSBsb2dpY1xyXG5cdFx0bGV0IHByZXYgPSBbRU1PSklfUk9PVF07XHJcblx0XHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdFx0bGV0IG5leHQgPSBwcmV2Lm1hcChub2RlID0+IHtcclxuXHRcdFx0XHRsZXQgY2hpbGQgPSBub2RlLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKCFjaGlsZCkge1xyXG5cdFx0XHRcdFx0Ly8gc2hvdWxkIHRoaXMgYmUgb2JqZWN0PyBcclxuXHRcdFx0XHRcdC8vIChtb3N0IGhhdmUgMS0yIGl0ZW1zLCBmZXcgaGF2ZSBtYW55KVxyXG5cdFx0XHRcdFx0Ly8gMjAyMzA3MTk6IG5vLCB2OCBkZWZhdWx0IG1hcCBpcyA0P1xyXG5cdFx0XHRcdFx0Y2hpbGQgPSBuZXcgTWFwKCk7XHJcblx0XHRcdFx0XHRub2RlLnNldChjcCwgY2hpbGQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gY2hpbGQ7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpZiAoY3AgPT09IEZFMEYpIHtcclxuXHRcdFx0XHRwcmV2LnB1c2goLi4ubmV4dCk7IC8vIGxlc3MgdGhhbiAyMCBlbGVtZW50c1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHByZXYgPSBuZXh0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmb3IgKGxldCB4IG9mIHByZXYpIHtcclxuXHRcdFx0eC5WID0gY3BzO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gaWYgZXNjYXBlZDoge0hFWH1cclxuLy8gICAgICAgZWxzZTogXCJ4XCIge0hFWH1cclxuZnVuY3Rpb24gcXVvdGVkX2NwKGNwKSB7XHJcblx0cmV0dXJuIChzaG91bGRfZXNjYXBlKGNwKSA/ICcnIDogYCR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhbY3BdKSl9IGApICsgcXVvdGVfY3AoY3ApO1xyXG59XHJcblxyXG4vLyAyMDIzMDIxMTogc29tZSBtZXNzYWdlcyBjYW4gYmUgbWl4ZWQtZGlyZWN0aW9uYWwgYW5kIHJlc3VsdCBpbiBzcGlsbG92ZXJcclxuLy8gdXNlIDIwMEUgYWZ0ZXIgYSBxdW90ZWQgc3RyaW5nIHRvIGZvcmNlIHRoZSByZW1haW5kZXIgb2YgYSBzdHJpbmcgZnJvbSBcclxuLy8gYWNxdXJpbmcgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcXVvdGVcclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL0ludGVybmF0aW9uYWwvcXVlc3Rpb25zL3FhLWJpZGktdW5pY29kZS1jb250cm9scyNleGNlcHRpb25zXHJcbmZ1bmN0aW9uIGJpZGlfcXEocykge1xyXG5cdHJldHVybiBgXCIke3N9XCJcXHUyMDBFYDsgLy8gc3Ryb25nIExUUlxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja19sYWJlbF9leHRlbnNpb24oY3BzKSB7XHJcblx0aWYgKGNwcy5sZW5ndGggPj0gNCAmJiBjcHNbMl0gPT0gSFlQSEVOICYmIGNwc1szXSA9PSBIWVBIRU4pIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBsYWJlbCBleHRlbnNpb246IFwiJHtzdHJfZnJvbV9jcHMoY3BzLnNsaWNlKDAsIDQpKX1cImApOyAvLyB0aGlzIGNhbiBvbmx5IGJlIGFzY2lpIHNvIGNhbnQgYmUgYmlkaVxyXG5cdH1cclxufVxyXG5mdW5jdGlvbiBjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUoY3BzKSB7XHJcblx0Y29uc3QgVU5ERVJTQ09SRSA9IDB4NUY7XHJcblx0Zm9yIChsZXQgaSA9IGNwcy5sYXN0SW5kZXhPZihVTkRFUlNDT1JFKTsgaSA+IDA7ICkge1xyXG5cdFx0aWYgKGNwc1stLWldICE9PSBVTkRFUlNDT1JFKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcigndW5kZXJzY29yZSBhbGxvd2VkIG9ubHkgYXQgc3RhcnQnKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuLy8gY2hlY2sgdGhhdCBhIGZlbmNlZCBjcCBpcyBub3QgbGVhZGluZywgdHJhaWxpbmcsIG9yIHRvdWNoaW5nIGFub3RoZXIgZmVuY2VkIGNwXHJcbmZ1bmN0aW9uIGNoZWNrX2ZlbmNlZChjcHMpIHtcclxuXHRsZXQgY3AgPSBjcHNbMF07XHJcblx0bGV0IHByZXYgPSBGRU5DRUQuZ2V0KGNwKTtcclxuXHRpZiAocHJldikgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGBsZWFkaW5nICR7cHJldn1gKTtcclxuXHRsZXQgbiA9IGNwcy5sZW5ndGg7XHJcblx0bGV0IGxhc3QgPSAtMTsgLy8gcHJldmVudHMgdHJhaWxpbmcgZnJvbSB0aHJvd2luZ1xyXG5cdGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRjcCA9IGNwc1tpXTtcclxuXHRcdGxldCBtYXRjaCA9IEZFTkNFRC5nZXQoY3ApO1xyXG5cdFx0aWYgKG1hdGNoKSB7XHJcblx0XHRcdC8vIHNpbmNlIGNwc1swXSBpc24ndCBmZW5jZWQsIGNwc1sxXSBjYW5ub3QgdGhyb3dcclxuXHRcdFx0aWYgKGxhc3QgPT0gaSkgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGAke3ByZXZ9ICsgJHttYXRjaH1gKTtcclxuXHRcdFx0bGFzdCA9IGkgKyAxO1xyXG5cdFx0XHRwcmV2ID0gbWF0Y2g7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChsYXN0ID09IG4pIHRocm93IGVycm9yX3BsYWNlbWVudChgdHJhaWxpbmcgJHtwcmV2fWApO1xyXG59XHJcblxyXG4vLyBjcmVhdGUgYSBzYWZlIHRvIHByaW50IHN0cmluZyBcclxuLy8gaW52aXNpYmxlcyBhcmUgZXNjYXBlZFxyXG4vLyBsZWFkaW5nIGNtIHVzZXMgcGxhY2Vob2xkZXJcclxuLy8gaWYgY3BzIGV4Y2VlZCBtYXgsIG1pZGRsZSB0cnVuY2F0ZSB3aXRoIGVsbGlwc2lzXHJcbi8vIHF1b3RlcihjcCkgPT4gc3RyaW5nLCBlZy4gMzAwMCA9PiBcInszMDAwfVwiXHJcbi8vIG5vdGU6IGluIGh0bWwsIHlvdSdkIGNhbGwgdGhpcyBmdW5jdGlvbiB0aGVuIHJlcGxhY2UgWzw+Jl0gd2l0aCBlbnRpdGllc1xyXG5mdW5jdGlvbiBzYWZlX3N0cl9mcm9tX2NwcyhjcHMsIG1heCA9IEluZmluaXR5LCBxdW90ZXIgPSBxdW90ZV9jcCkge1xyXG5cdC8vaWYgKE51bWJlci5pc0ludGVnZXIoY3BzKSkgY3BzID0gW2Nwc107XHJcblx0Ly9pZiAoIUFycmF5LmlzQXJyYXkoY3BzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgY29kZXBvaW50c2ApO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRpZiAoaXNfY29tYmluaW5nX21hcmsoY3BzWzBdKSkgYnVmLnB1c2goJ+KXjCcpO1xyXG5cdGlmIChjcHMubGVuZ3RoID4gbWF4KSB7XHJcblx0XHRtYXggPj49IDE7XHJcblx0XHRjcHMgPSBbLi4uY3BzLnNsaWNlKDAsIG1heCksIDB4MjAyNiwgLi4uY3BzLnNsaWNlKC1tYXgpXTtcclxuXHR9XHJcblx0bGV0IHByZXYgPSAwO1xyXG5cdGxldCBuID0gY3BzLmxlbmd0aDtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0bGV0IGNwID0gY3BzW2ldO1xyXG5cdFx0aWYgKHNob3VsZF9lc2NhcGUoY3ApKSB7XHJcblx0XHRcdGJ1Zi5wdXNoKHN0cl9mcm9tX2NwcyhjcHMuc2xpY2UocHJldiwgaSkpKTtcclxuXHRcdFx0YnVmLnB1c2gocXVvdGVyKGNwKSk7XHJcblx0XHRcdHByZXYgPSBpICsgMTtcclxuXHRcdH1cclxuXHR9XHJcblx0YnVmLnB1c2goc3RyX2Zyb21fY3BzKGNwcy5zbGljZShwcmV2LCBuKSkpO1xyXG5cdHJldHVybiBidWYuam9pbignJyk7XHJcbn1cclxuXHJcbi8vIG5vdGU6IHNldChzKSBjYW5ub3QgYmUgZXhwb3NlZCBiZWNhdXNlIHRoZXkgY2FuIGJlIG1vZGlmaWVkXHJcbi8vIG5vdGU6IE9iamVjdC5mcmVlemUoKSBkb2Vzbid0IHdvcmtcclxuZnVuY3Rpb24gaXNfY29tYmluaW5nX21hcmsoY3ApIHtcclxuXHRpbml0KCk7XHJcblx0cmV0dXJuIENNLmhhcyhjcCk7XHJcbn1cclxuZnVuY3Rpb24gc2hvdWxkX2VzY2FwZShjcCkge1xyXG5cdGluaXQoKTtcclxuXHRyZXR1cm4gRVNDQVBFLmhhcyhjcCk7XHJcbn1cclxuXHJcbi8vIHJldHVybiBhbGwgc3VwcG9ydGVkIGVtb2ppIGFzIGZ1bGx5LXF1YWxpZmllZCBlbW9qaSBcclxuLy8gb3JkZXJlZCBieSBsZW5ndGggdGhlbiBsZXhpY29ncmFwaGljIFxyXG5mdW5jdGlvbiBlbnNfZW1vamkoKSB7XHJcblx0aW5pdCgpO1xyXG5cdHJldHVybiBFTU9KSV9MSVNULm1hcCh4ID0+IHguc2xpY2UoKSk7IC8vIGVtb2ppIGFyZSBleHBvc2VkIHNvIGNvcHlcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX25vcm1hbGl6ZV9mcmFnbWVudChmcmFnLCBkZWNvbXBvc2UpIHtcclxuXHRpbml0KCk7XHJcblx0bGV0IG5mID0gZGVjb21wb3NlID8gbmZkIDogbmZjO1xyXG5cdHJldHVybiBmcmFnLnNwbGl0KFNUT1BfQ0gpLm1hcChsYWJlbCA9PiBzdHJfZnJvbV9jcHModG9rZW5zX2Zyb21fc3RyKGV4cGxvZGVfY3AobGFiZWwpLCBuZiwgZmlsdGVyX2ZlMGYpLmZsYXQoKSkpLmpvaW4oU1RPUF9DSCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19ub3JtYWxpemUobmFtZSkge1xyXG5cdHJldHVybiBmbGF0dGVuKHNwbGl0KG5hbWUsIG5mYywgZmlsdGVyX2ZlMGYpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX2JlYXV0aWZ5KG5hbWUpIHtcclxuXHRsZXQgbGFiZWxzID0gc3BsaXQobmFtZSwgbmZjLCB4ID0+IHgpOyAvLyBlbW9qaSBub3QgZXhwb3NlZFxyXG5cdGZvciAobGV0IHt0eXBlLCBvdXRwdXQsIGVycm9yfSBvZiBsYWJlbHMpIHtcclxuXHRcdGlmIChlcnJvcikgYnJlYWs7IC8vIGZsYXR0ZW4gd2lsbCB0aHJvd1xyXG5cclxuXHRcdC8vIHJlcGxhY2UgbGVhZGluZy90cmFpbGluZyBoeXBoZW5cclxuXHRcdC8vIDIwMjMwMTIxOiBjb25zaWRlciBiZWF1dGlmaW5nIGFsbCBvciBsZWFkaW5nL3RyYWlsaW5nIGh5cGhlbiB0byB1bmljb2RlIHZhcmlhbnRcclxuXHRcdC8vIG5vdCBleGFjdGx5IHRoZSBzYW1lIGluIGV2ZXJ5IGZvbnQsIGJ1dCB2ZXJ5IHNpbWlsYXI6IFwiLVwiIHZzIFwi4oCQXCJcclxuXHRcdC8qXHJcblx0XHRjb25zdCBVTklDT0RFX0hZUEhFTiA9IDB4MjAxMDtcclxuXHRcdC8vIG1heWJlIHRoaXMgc2hvdWxkIHJlcGxhY2UgYWxsIGZvciB2aXN1YWwgY29uc2lzdGFuY3k/XHJcblx0XHQvLyBgbm9kZSB0b29scy9yZWctY291bnQuanMgcmVnZXggXi1cXHsyLFxcfWAgPT4gNTkyXHJcblx0XHQvL2ZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Lmxlbmd0aDsgaSsrKSBpZiAob3V0cHV0W2ldID09IDB4MkQpIG91dHB1dFtpXSA9IDB4MjAxMDtcclxuXHRcdGlmIChvdXRwdXRbMF0gPT0gSFlQSEVOKSBvdXRwdXRbMF0gPSBVTklDT0RFX0hZUEhFTjtcclxuXHRcdGxldCBlbmQgPSBvdXRwdXQubGVuZ3RoLTE7XHJcblx0XHRpZiAob3V0cHV0W2VuZF0gPT0gSFlQSEVOKSBvdXRwdXRbZW5kXSA9IFVOSUNPREVfSFlQSEVOO1xyXG5cdFx0Ki9cclxuXHRcdC8vIDIwMjMwMTIzOiBXSEFUV0cgVVJMIHVzZXMgXCJDaGVja0h5cGhlbnNcIiBmYWxzZVxyXG5cdFx0Ly8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNpZG5hXHJcblxyXG5cdFx0Ly8gdXBkYXRlIGV0aGVyZXVtIHN5bWJvbFxyXG5cdFx0Ly8gzr4gPT4gzp4gaWYgbm90IGdyZWVrXHJcblx0XHRpZiAodHlwZSAhPT0gJ0dyZWVrJykgYXJyYXlfcmVwbGFjZShvdXRwdXQsIDB4M0JFLCAweDM5RSk7XHJcblxyXG5cdFx0Ly8gMjAyMjEyMTM6IGZpeGVzIGJpZGkgc3ViZG9tYWluIGlzc3VlLCBidXQgYnJlYWtzIGludmFyaWFudCAoMjAwRSBpcyBkaXNhbGxvd2VkKVxyXG5cdFx0Ly8gY291bGQgYmUgZml4ZWQgd2l0aCBzcGVjaWFsIGNhc2UgZm9yOiAyRCAoLikgKyAyMDBFIChMVFIpXHJcblx0XHQvLyBodHRwczovL2Rpc2N1c3MuZW5zLmRvbWFpbnMvdC9iaWRpLWxhYmVsLW9yZGVyaW5nLXNwb29mLzE1ODI0XHJcblx0XHQvL291dHB1dC5zcGxpY2UoMCwgMCwgMHgyMDBFKTtcclxuXHR9XHJcblx0cmV0dXJuIGZsYXR0ZW4obGFiZWxzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXJyYXlfcmVwbGFjZSh2LCBhLCBiKSB7XHJcblx0bGV0IHByZXYgPSAwO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgbmV4dCA9IHYuaW5kZXhPZihhLCBwcmV2KTtcclxuXHRcdGlmIChuZXh0IDwgMCkgYnJlYWs7XHJcblx0XHR2W25leHRdID0gYjsgXHJcblx0XHRwcmV2ID0gbmV4dCArIDE7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfc3BsaXQobmFtZSwgcHJlc2VydmVfZW1vamkpIHtcclxuXHRyZXR1cm4gc3BsaXQobmFtZSwgbmZjLCBwcmVzZXJ2ZV9lbW9qaSA/IHggPT4geC5zbGljZSgpIDogZmlsdGVyX2ZlMGYpOyAvLyBlbW9qaSBhcmUgZXhwb3NlZCBzbyBjb3B5XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNwbGl0KG5hbWUsIG5mLCBlZikge1xyXG5cdGlmICghbmFtZSkgcmV0dXJuIFtdOyAvLyAyMDIzMDcxOTogZW1wdHkgbmFtZSBhbGxvd2FuY2VcclxuXHRpbml0KCk7XHJcblx0bGV0IG9mZnNldCA9IDA7XHJcblx0Ly8gaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyNDYvI1ZhbGlkaXR5X0NyaXRlcmlhXHJcblx0Ly8gNC4pIFwiVGhlIGxhYmVsIG11c3Qgbm90IGNvbnRhaW4gYSBVKzAwMkUgKCAuICkgRlVMTCBTVE9QLlwiXHJcblx0cmV0dXJuIG5hbWUuc3BsaXQoU1RPUF9DSCkubWFwKGxhYmVsID0+IHtcclxuXHRcdGxldCBpbnB1dCA9IGV4cGxvZGVfY3AobGFiZWwpO1xyXG5cdFx0bGV0IGluZm8gPSB7XHJcblx0XHRcdGlucHV0LFxyXG5cdFx0XHRvZmZzZXQsIC8vIGNvZGVwb2ludCwgbm90IHN1YnN0cmluZyFcclxuXHRcdH07XHJcblx0XHRvZmZzZXQgKz0gaW5wdXQubGVuZ3RoICsgMTsgLy8gKyBzdG9wXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyAxLikgXCJUaGUgbGFiZWwgbXVzdCBiZSBpbiBVbmljb2RlIE5vcm1hbGl6YXRpb24gRm9ybSBORkNcIlxyXG5cdFx0XHRsZXQgdG9rZW5zID0gaW5mby50b2tlbnMgPSB0b2tlbnNfZnJvbV9zdHIoaW5wdXQsIG5mLCBlZik7XHJcblx0XHRcdGxldCB0b2tlbl9jb3VudCA9IHRva2Vucy5sZW5ndGg7XHJcblx0XHRcdGxldCB0eXBlO1xyXG5cdFx0XHRpZiAoIXRva2VuX2NvdW50KSB7IC8vIHRoZSBsYWJlbCB3YXMgZWZmZWN0aXZlbHkgZW1wdHkgKGNvdWxkIG9mIGhhZCBpZ25vcmVkIGNoYXJhY3RlcnMpXHJcblx0XHRcdFx0Ly9ub3JtID0gW107XHJcblx0XHRcdFx0Ly90eXBlID0gJ05vbmUnOyAvLyB1c2UgdGhpcyBpbnN0ZWFkIG9mIG5leHQgbWF0Y2gsIFwiQVNDSUlcIlxyXG5cdFx0XHRcdC8vIDIwMjMwMTIwOiBjaGFuZ2UgdG8gc3RyaWN0XHJcblx0XHRcdFx0Ly8gaHR0cHM6Ly9kaXNjdXNzLmVucy5kb21haW5zL3QvZW5zLW5hbWUtbm9ybWFsaXphdGlvbi0ybmQvMTQ1NjQvNTlcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGVtcHR5IGxhYmVsYCk7XHJcblx0XHRcdH0gXHJcblx0XHRcdGxldCBub3JtID0gaW5mby5vdXRwdXQgPSB0b2tlbnMuZmxhdCgpO1xyXG5cdFx0XHRjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUobm9ybSk7XHJcblx0XHRcdGxldCBlbW9qaSA9IGluZm8uZW1vamkgPSB0b2tlbl9jb3VudCA+IDEgfHwgdG9rZW5zWzBdLmlzX2Vtb2ppOyAvLyBzYW1lIGFzOiB0b2tlbnMuc29tZSh4ID0+IHguaXNfZW1vamkpO1xyXG5cdFx0XHRpZiAoIWVtb2ppICYmIG5vcm0uZXZlcnkoY3AgPT4gY3AgPCAweDgwKSkgeyAvLyBzcGVjaWFsIGNhc2UgZm9yIGFzY2lpXHJcblx0XHRcdFx0Ly8gMjAyMzAxMjM6IG1hdGNoZXMgbWF0Y2hlcyBXSEFUV0csIHNlZSBub3RlIDMuM1xyXG5cdFx0XHRcdGNoZWNrX2xhYmVsX2V4dGVuc2lvbihub3JtKTsgLy8gb25seSBuZWVkZWQgZm9yIGFzY2lpXHJcblx0XHRcdFx0Ly8gY2FudCBoYXZlIGZlbmNlZFxyXG5cdFx0XHRcdC8vIGNhbnQgaGF2ZSBjbVxyXG5cdFx0XHRcdC8vIGNhbnQgaGF2ZSB3aG9sZXNcclxuXHRcdFx0XHQvLyBzZWUgZGVyaXZlOiBcIkZhc3RwYXRoIEFTQ0lJXCJcclxuXHRcdFx0XHR0eXBlID0gJ0FTQ0lJJztcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY2hhcnMgPSB0b2tlbnMuZmxhdE1hcCh4ID0+IHguaXNfZW1vamkgPyBbXSA6IHgpOyAvLyBhbGwgb2YgdGhlIG5mYyB0b2tlbnMgY29uY2F0IHRvZ2V0aGVyXHJcblx0XHRcdFx0aWYgKCFjaGFycy5sZW5ndGgpIHsgLy8gdGhlcmVzIG5vIHRleHQsIGp1c3QgZW1vamlcclxuXHRcdFx0XHRcdHR5cGUgPSAnRW1vamknO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyA1LikgXCJUaGUgbGFiZWwgbXVzdCBub3QgYmVnaW4gd2l0aCBhIGNvbWJpbmluZyBtYXJrLCB0aGF0IGlzOiBHZW5lcmFsX0NhdGVnb3J5PU1hcmsuXCJcclxuXHRcdFx0XHRcdGlmIChDTS5oYXMobm9ybVswXSkpIHRocm93IGVycm9yX3BsYWNlbWVudCgnbGVhZGluZyBjb21iaW5pbmcgbWFyaycpO1xyXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCB0b2tlbl9jb3VudDsgaSsrKSB7IC8vIHdlJ3ZlIGFscmVhZHkgY2hlY2tlZCB0aGUgZmlyc3QgdG9rZW5cclxuXHRcdFx0XHRcdFx0bGV0IGNwcyA9IHRva2Vuc1tpXTtcclxuXHRcdFx0XHRcdFx0aWYgKCFjcHMuaXNfZW1vamkgJiYgQ00uaGFzKGNwc1swXSkpIHsgLy8gZXZlcnkgdGV4dCB0b2tlbiBoYXMgZW1vamkgbmVpZ2hib3JzLCBlZy4gRXRFRUV0RXQuLi5cclxuXHRcdFx0XHRcdFx0XHQvLyBiaWRpX3FxKCkgbm90IG5lZWRlZCBzaW5jZSBlbW9qaSBpcyBMVFIgYW5kIGNwcyBpcyBhIENNXHJcblx0XHRcdFx0XHRcdFx0dGhyb3cgZXJyb3JfcGxhY2VtZW50KGBlbW9qaSArIGNvbWJpbmluZyBtYXJrOiBcIiR7c3RyX2Zyb21fY3BzKHRva2Vuc1tpLTFdKX0gKyAke3NhZmVfc3RyX2Zyb21fY3BzKFtjcHNbMF1dKX1cImApOyBcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y2hlY2tfZmVuY2VkKG5vcm0pO1xyXG5cdFx0XHRcdFx0bGV0IHVuaXF1ZSA9IEFycmF5X2Zyb20obmV3IFNldChjaGFycykpO1xyXG5cdFx0XHRcdFx0bGV0IFtnXSA9IGRldGVybWluZV9ncm91cCh1bmlxdWUpOyAvLyB0YWtlIHRoZSBmaXJzdCBtYXRjaFxyXG5cdFx0XHRcdFx0Ly8gc2VlIGRlcml2ZTogXCJNYXRjaGluZyBHcm91cHMgaGF2ZSBTYW1lIENNIFN0eWxlXCJcclxuXHRcdFx0XHRcdC8vIGFsdGVybmF0aXZlOiBjb3VsZCBmb3JtIGEgaHlicmlkIHR5cGU6IExhdGluL0phcGFuZXNlLy4uLlx0XHJcblx0XHRcdFx0XHRjaGVja19ncm91cChnLCBjaGFycyk7IC8vIG5lZWQgdGV4dCBpbiBvcmRlclxyXG5cdFx0XHRcdFx0Y2hlY2tfd2hvbGUoZywgdW5pcXVlKTsgLy8gb25seSBuZWVkIHVuaXF1ZSB0ZXh0IChvcmRlciB3b3VsZCBiZSByZXF1aXJlZCBmb3IgbXVsdGlwbGUtY2hhciBjb25mdXNhYmxlcylcclxuXHRcdFx0XHRcdHR5cGUgPSBnLk47XHJcblx0XHRcdFx0XHQvLyAyMDIzMDEyMTogY29uc2lkZXIgZXhwb3NpbmcgcmVzdHJpY3RlZCBmbGFnXHJcblx0XHRcdFx0XHQvLyBpdCdzIHNpbXBsZXIgdG8ganVzdCBjaGVjayBmb3IgJ1Jlc3RyaWN0ZWQnXHJcblx0XHRcdFx0XHQvLyBvciBldmVuIGJldHRlcjogdHlwZS5lbmRzV2l0aCgnXScpXHJcblx0XHRcdFx0XHQvL2lmIChnLlIpIGluZm8ucmVzdHJpY3RlZCA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGluZm8udHlwZSA9IHR5cGU7XHJcblx0XHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdFx0aW5mby5lcnJvciA9IGVycjsgLy8gdXNlIGZ1bGwgZXJyb3Igb2JqZWN0XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gaW5mbztcclxuXHR9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tfd2hvbGUoZ3JvdXAsIHVuaXF1ZSkge1xyXG5cdGxldCBtYWtlcjtcclxuXHRsZXQgc2hhcmVkID0gW107XHJcblx0Zm9yIChsZXQgY3Agb2YgdW5pcXVlKSB7XHJcblx0XHRsZXQgd2hvbGUgPSBXSE9MRV9NQVAuZ2V0KGNwKTtcclxuXHRcdGlmICh3aG9sZSA9PT0gVU5JUVVFX1BIKSByZXR1cm47IC8vIHVuaXF1ZSwgbm9uLWNvbmZ1c2FibGVcclxuXHRcdGlmICh3aG9sZSkge1xyXG5cdFx0XHRsZXQgc2V0ID0gd2hvbGUuTS5nZXQoY3ApOyAvLyBncm91cHMgd2hpY2ggaGF2ZSBhIGNoYXJhY3RlciB0aGF0IGxvb2stbGlrZSB0aGlzIGNoYXJhY3RlclxyXG5cdFx0XHRtYWtlciA9IG1ha2VyID8gbWFrZXIuZmlsdGVyKGcgPT4gc2V0LmhhcyhnKSkgOiBBcnJheV9mcm9tKHNldCk7XHJcblx0XHRcdGlmICghbWFrZXIubGVuZ3RoKSByZXR1cm47IC8vIGNvbmZ1c2FibGUgaW50ZXJzZWN0aW9uIGlzIGVtcHR5XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzaGFyZWQucHVzaChjcCk7IFxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAobWFrZXIpIHtcclxuXHRcdC8vIHdlIGhhdmUgMSsgY29uZnVzYWJsZVxyXG5cdFx0Ly8gY2hlY2sgaWYgYW55IG9mIHRoZSByZW1haW5pbmcgZ3JvdXBzXHJcblx0XHQvLyBjb250YWluIHRoZSBzaGFyZWQgY2hhcmFjdGVycyB0b29cclxuXHRcdGZvciAobGV0IGcgb2YgbWFrZXIpIHtcclxuXHRcdFx0aWYgKHNoYXJlZC5ldmVyeShjcCA9PiBncm91cF9oYXNfY3AoZywgY3ApKSkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgd2hvbGUtc2NyaXB0IGNvbmZ1c2FibGU6ICR7Z3JvdXAuTn0vJHtnLk59YCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbi8vIGFzc3VtcHRpb246IHVuaXF1ZS5zaXplID4gMFxyXG4vLyByZXR1cm5zIGxpc3Qgb2YgbWF0Y2hpbmcgZ3JvdXBzXHJcbmZ1bmN0aW9uIGRldGVybWluZV9ncm91cCh1bmlxdWUpIHtcclxuXHRsZXQgZ3JvdXBzID0gR1JPVVBTO1xyXG5cdGZvciAobGV0IGNwIG9mIHVuaXF1ZSkge1xyXG5cdFx0Ly8gbm90ZTogd2UgbmVlZCB0byBkb2RnZSBDTSB0aGF0IGFyZSB3aGl0ZWxpc3RlZFxyXG5cdFx0Ly8gYnV0IHRoYXQgY29kZSBpc24ndCBjdXJyZW50bHkgbmVjZXNzYXJ5XHJcblx0XHRsZXQgZ3MgPSBncm91cHMuZmlsdGVyKGcgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSk7XHJcblx0XHRpZiAoIWdzLmxlbmd0aCkge1xyXG5cdFx0XHRpZiAoIUdST1VQUy5zb21lKGcgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSkpIHsgXHJcblx0XHRcdFx0Ly8gdGhlIGNoYXJhY3RlciB3YXMgY29tcG9zZWQgb2YgdmFsaWQgcGFydHNcclxuXHRcdFx0XHQvLyBidXQgaXQncyBORkMgZm9ybSBpcyBpbnZhbGlkXHJcblx0XHRcdFx0Ly8gMjAyMzA3MTY6IGNoYW5nZSB0byBtb3JlIGV4YWN0IHN0YXRlbWVudCwgc2VlOiBFTlNOb3JtYWxpemUue2NzLGphdmF9XHJcblx0XHRcdFx0Ly8gbm90ZTogdGhpcyBkb2Vzbid0IGhhdmUgdG8gYmUgYSBjb21wb3NpdGlvblxyXG5cdFx0XHRcdC8vIDIwMjMwNzIwOiBjaGFuZ2UgdG8gZnVsbCBjaGVja1xyXG5cdFx0XHRcdHRocm93IGVycm9yX2Rpc2FsbG93ZWQoY3ApOyAvLyB0aGlzIHNob3VsZCBiZSByYXJlXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gdGhlcmUgaXMgbm8gZ3JvdXAgdGhhdCBjb250YWlucyBhbGwgdGhlc2UgY2hhcmFjdGVyc1xyXG5cdFx0XHRcdC8vIHRocm93IHVzaW5nIHRoZSBoaWdoZXN0IHByaW9yaXR5IGdyb3VwIHRoYXQgbWF0Y2hlZFxyXG5cdFx0XHRcdC8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzOS8jbWl4ZWRfc2NyaXB0X2NvbmZ1c2FibGVzXHJcblx0XHRcdFx0dGhyb3cgZXJyb3JfZ3JvdXBfbWVtYmVyKGdyb3Vwc1swXSwgY3ApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRncm91cHMgPSBncztcclxuXHRcdGlmIChncy5sZW5ndGggPT0gMSkgYnJlYWs7IC8vIHRoZXJlIGlzIG9ubHkgb25lIGdyb3VwIGxlZnRcclxuXHR9XHJcblx0Ly8gdGhlcmUgYXJlIGF0IGxlYXN0IDEgZ3JvdXAocykgd2l0aCBhbGwgb2YgdGhlc2UgY2hhcmFjdGVyc1xyXG5cdHJldHVybiBncm91cHM7XHJcbn1cclxuXHJcbi8vIHRocm93IG9uIGZpcnN0IGVycm9yXHJcbmZ1bmN0aW9uIGZsYXR0ZW4oc3BsaXQpIHtcclxuXHRyZXR1cm4gc3BsaXQubWFwKCh7aW5wdXQsIGVycm9yLCBvdXRwdXR9KSA9PiB7XHJcblx0XHRpZiAoZXJyb3IpIHtcclxuXHRcdFx0Ly8gZG9uJ3QgcHJpbnQgbGFiZWwgYWdhaW4gaWYganVzdCBhIHNpbmdsZSBsYWJlbFxyXG5cdFx0XHRsZXQgbXNnID0gZXJyb3IubWVzc2FnZTtcclxuXHRcdFx0Ly8gYmlkaV9xcSgpIG9ubHkgbmVjZXNzYXJ5IGlmIG1zZyBpcyBkaWdpdHNcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKHNwbGl0Lmxlbmd0aCA9PSAxID8gbXNnIDogYEludmFsaWQgbGFiZWwgJHtiaWRpX3FxKHNhZmVfc3RyX2Zyb21fY3BzKGlucHV0LCA2MykpfTogJHttc2d9YCk7IFxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN0cl9mcm9tX2NwcyhvdXRwdXQpO1xyXG5cdH0pLmpvaW4oU1RPUF9DSCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVycm9yX2Rpc2FsbG93ZWQoY3ApIHtcclxuXHQvLyBUT0RPOiBhZGQgY3AgdG8gZXJyb3I/XHJcblx0cmV0dXJuIG5ldyBFcnJvcihgZGlzYWxsb3dlZCBjaGFyYWN0ZXI6ICR7cXVvdGVkX2NwKGNwKX1gKTsgXHJcbn1cclxuZnVuY3Rpb24gZXJyb3JfZ3JvdXBfbWVtYmVyKGcsIGNwKSB7XHJcblx0bGV0IHF1b3RlZCA9IHF1b3RlZF9jcChjcCk7XHJcblx0bGV0IGdnID0gR1JPVVBTLmZpbmQoZyA9PiBnLlAuaGFzKGNwKSk7IC8vIG9ubHkgY2hlY2sgcHJpbWFyeVxyXG5cdGlmIChnZykge1xyXG5cdFx0cXVvdGVkID0gYCR7Z2cuTn0gJHtxdW90ZWR9YDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBFcnJvcihgaWxsZWdhbCBtaXh0dXJlOiAke2cuTn0gKyAke3F1b3RlZH1gKTtcclxufVxyXG5mdW5jdGlvbiBlcnJvcl9wbGFjZW1lbnQod2hlcmUpIHtcclxuXHRyZXR1cm4gbmV3IEVycm9yKGBpbGxlZ2FsIHBsYWNlbWVudDogJHt3aGVyZX1gKTtcclxufVxyXG5cclxuLy8gYXNzdW1wdGlvbjogY3BzLmxlbmd0aCA+IDBcclxuLy8gYXNzdW1wdGlvbjogY3BzWzBdIGlzbid0IGEgQ01cclxuLy8gYXNzdW1wdGlvbjogdGhlIHByZXZpb3VzIGNoYXJhY3RlciBpc24ndCBhbiBlbW9qaVxyXG5mdW5jdGlvbiBjaGVja19ncm91cChnLCBjcHMpIHtcclxuXHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdGlmICghZ3JvdXBfaGFzX2NwKGcsIGNwKSkge1xyXG5cdFx0XHQvLyBmb3Igd2hpdGVsaXN0ZWQgc2NyaXB0cywgdGhpcyB3aWxsIHRocm93IGlsbGVnYWwgbWl4dHVyZSBvbiBpbnZhbGlkIGNtLCBlZy4gXCJlezMwMH17MzAwfVwiXHJcblx0XHRcdC8vIGF0IHRoZSBtb21lbnQsIGl0J3MgdW5uZWNlc3NhcnkgdG8gaW50cm9kdWNlIGFuIGV4dHJhIGVycm9yIHR5cGVcclxuXHRcdFx0Ly8gdW50aWwgdGhlcmUgZXhpc3RzIGEgd2hpdGVsaXN0ZWQgbXVsdGktY2hhcmFjdGVyXHJcblx0XHRcdC8vICAgZWcuIGlmIChNIDwgMCAmJiBpc19jb21iaW5pbmdfbWFyayhjcCkpIHsgLi4uIH1cclxuXHRcdFx0Ly8gdGhlcmUgYXJlIDMgY2FzZXM6XHJcblx0XHRcdC8vICAgMS4gaWxsZWdhbCBjbSBmb3Igd3JvbmcgZ3JvdXAgPT4gbWl4dHVyZSBlcnJvclxyXG5cdFx0XHQvLyAgIDIuIGlsbGVnYWwgY20gZm9yIHNhbWUgZ3JvdXAgPT4gY20gZXJyb3JcclxuXHRcdFx0Ly8gICAgICAgcmVxdWlyZXMgc2V0IG9mIHdoaXRlbGlzdCBjbSBwZXIgZ3JvdXA6IFxyXG5cdFx0XHQvLyAgICAgICAgZWcuIG5ldyBTZXQoWy4uLmcuUCwgLi4uZy5RXS5mbGF0TWFwKG5mYykuZmlsdGVyKGNwID0+IENNLmhhcyhjcCkpKVxyXG5cdFx0XHQvLyAgIDMuIHdyb25nIGdyb3VwID0+IG1peHR1cmUgZXJyb3JcclxuXHRcdFx0dGhyb3cgZXJyb3JfZ3JvdXBfbWVtYmVyKGcsIGNwKTtcclxuXHRcdH1cclxuXHR9XHJcblx0Ly9pZiAoTSA+PSAwKSB7IC8vIHdlIGhhdmUgYSBrbm93biBmaXhlZCBjbSBjb3VudFxyXG5cdGlmIChnLk0pIHsgLy8gd2UgbmVlZCB0byBjaGVjayBmb3IgTlNNXHJcblx0XHRsZXQgZGVjb21wb3NlZCA9IG5mZChjcHMpO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDEsIGUgPSBkZWNvbXBvc2VkLmxlbmd0aDsgaSA8IGU7IGkrKykgeyAvLyBzZWU6IGFzc3VtcHRpb25cclxuXHRcdFx0Ly8gMjAyMzAyMTA6IGJ1Z2ZpeDogdXNpbmcgY3BzIGluc3RlYWQgb2YgZGVjb21wb3NlZCBoL3QgQ2FyYm9uMjI1XHJcblx0XHRcdC8qXHJcblx0XHRcdGlmIChDTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdHdoaWxlIChqIDwgZSAmJiBDTS5oYXMoZGVjb21wb3NlZFtqXSkpIGorKztcclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBNKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHRvbyBtYW55IGNvbWJpbmluZyBtYXJrczogJHtnLk59ICR7YmlkaV9xcShzdHJfZnJvbV9jcHMoZGVjb21wb3NlZC5zbGljZShpLTEsIGopKSl9ICgke2otaX0vJHtNfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdFx0Ki9cclxuXHRcdFx0Ly8gMjAyMzAyMTc6IHN3aXRjaCB0byBOU00gY291bnRpbmdcclxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM5LyNPcHRpb25hbF9EZXRlY3Rpb25cclxuXHRcdFx0aWYgKE5TTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdGZvciAobGV0IGNwOyBqIDwgZSAmJiBOU00uaGFzKGNwID0gZGVjb21wb3NlZFtqXSk7IGorKykge1xyXG5cdFx0XHRcdFx0Ly8gYS4gRm9yYmlkIHNlcXVlbmNlcyBvZiB0aGUgc2FtZSBub25zcGFjaW5nIG1hcmsuXHJcblx0XHRcdFx0XHRmb3IgKGxldCBrID0gaTsgayA8IGo7IGsrKykgeyAvLyBPKG5eMikgYnV0IG4gPCAxMDBcclxuXHRcdFx0XHRcdFx0aWYgKGRlY29tcG9zZWRba10gPT0gY3ApIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZSBub24tc3BhY2luZyBtYXJrczogJHtxdW90ZWRfY3AoY3ApfWApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIHBhcnNlIHRvIGVuZCBzbyB3ZSBoYXZlIGZ1bGwgbnNtIGNvdW50XHJcblx0XHRcdFx0Ly8gYi4gRm9yYmlkIHNlcXVlbmNlcyBvZiBtb3JlIHRoYW4gNCBub25zcGFjaW5nIG1hcmtzIChnYz1NbiBvciBnYz1NZSkuXHJcblx0XHRcdFx0aWYgKGogLSBpID4gTlNNX01BWCkge1xyXG5cdFx0XHRcdFx0Ly8gbm90ZTogdGhpcyBzbGljZSBzdGFydHMgd2l0aCBhIGJhc2UgY2hhciBvciBzcGFjaW5nLW1hcmsgY21cclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZXhjZXNzaXZlIG5vbi1zcGFjaW5nIG1hcmtzOiAke2JpZGlfcXEoc2FmZV9zdHJfZnJvbV9jcHMoZGVjb21wb3NlZC5zbGljZShpLTEsIGopKSl9ICgke2otaX0vJHtOU01fTUFYfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0Ly8gKioqIHRoaXMgY29kZSBjdXJyZW50bHkgaXNuJ3QgbmVlZGVkICoqKlxyXG5cdC8qXHJcblx0bGV0IGNtX3doaXRlbGlzdCA9IE0gaW5zdGFuY2VvZiBNYXA7XHJcblx0Zm9yIChsZXQgaSA9IDAsIGUgPSBjcHMubGVuZ3RoOyBpIDwgZTsgKSB7XHJcblx0XHRsZXQgY3AgPSBjcHNbaSsrXTtcclxuXHRcdGxldCBzZXFzID0gY21fd2hpdGVsaXN0ICYmIE0uZ2V0KGNwKTtcclxuXHRcdGlmIChzZXFzKSB7IFxyXG5cdFx0XHQvLyBsaXN0IG9mIGNvZGVwb2ludHMgdGhhdCBjYW4gZm9sbG93XHJcblx0XHRcdC8vIGlmIHRoaXMgZXhpc3RzLCB0aGlzIHdpbGwgYWx3YXlzIGJlIDErXHJcblx0XHRcdGxldCBqID0gaTtcclxuXHRcdFx0d2hpbGUgKGogPCBlICYmIENNLmhhcyhjcHNbal0pKSBqKys7XHJcblx0XHRcdGxldCBjbXMgPSBjcHMuc2xpY2UoaSwgaik7XHJcblx0XHRcdGxldCBtYXRjaCA9IHNlcXMuZmluZChzZXEgPT4gIWNvbXBhcmVfYXJyYXlzKHNlcSwgY21zKSk7XHJcblx0XHRcdGlmICghbWF0Y2gpIHRocm93IG5ldyBFcnJvcihgZGlzYWxsb3dlZCBjb21iaW5pbmcgbWFyayBzZXF1ZW5jZTogXCIke3NhZmVfc3RyX2Zyb21fY3BzKFtjcCwgLi4uY21zXSl9XCJgKTtcclxuXHRcdFx0aSA9IGo7XHJcblx0XHR9IGVsc2UgaWYgKCFWLmhhcyhjcCkpIHtcclxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM5LyNtaXhlZF9zY3JpcHRfY29uZnVzYWJsZXNcclxuXHRcdFx0bGV0IHF1b3RlZCA9IHF1b3RlZF9jcChjcCk7XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0XHRcdGxldCB1ID0gVU5JUVVFLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKHUgJiYgdSAhPT0gZykge1xyXG5cdFx0XHRcdFx0Ly8gaWYgYm90aCBzY3JpcHRzIGFyZSByZXN0cmljdGVkIHRoaXMgZXJyb3IgaXMgY29uZnVzaW5nXHJcblx0XHRcdFx0XHQvLyBiZWNhdXNlIHdlIGRvbid0IGRpZmZlcmVudGlhdGUgUmVzdHJpY3RlZEEgZnJvbSBSZXN0cmljdGVkQiBcclxuXHRcdFx0XHRcdGlmICghdS5SKSBxdW90ZWQgPSBgJHtxdW90ZWR9IGlzICR7dS5OfWA7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkICR7Zy5OfSBjaGFyYWN0ZXI6ICR7cXVvdGVkfWApO1xyXG5cdFx0XHQvL3Rocm93IG5ldyBFcnJvcihgZGlzYWxsb3dlZCBjaGFyYWN0ZXI6ICR7cXVvdGVkfSAoZXhwZWN0ZWQgJHtnLk59KWApO1xyXG5cdFx0XHQvL3Rocm93IG5ldyBFcnJvcihgJHtnLk59IGRvZXMgbm90IGFsbG93OiAke3F1b3RlZH1gKTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKCFjbV93aGl0ZWxpc3QpIHtcclxuXHRcdGxldCBkZWNvbXBvc2VkID0gbmZkKGNwcyk7XHJcblx0XHRmb3IgKGxldCBpID0gMSwgZSA9IGRlY29tcG9zZWQubGVuZ3RoOyBpIDwgZTsgaSsrKSB7IC8vIHdlIGtub3cgaXQgY2FuJ3QgYmUgY20gbGVhZGluZ1xyXG5cdFx0XHRpZiAoQ00uaGFzKGRlY29tcG9zZWRbaV0pKSB7XHJcblx0XHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0XHR3aGlsZSAoaiA8IGUgJiYgQ00uaGFzKGRlY29tcG9zZWRbal0pKSBqKys7XHJcblx0XHRcdFx0aWYgKGogLSBpID4gTSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB0b28gbWFueSBjb21iaW5pbmcgbWFya3M6IFwiJHtzdHJfZnJvbV9jcHMoZGVjb21wb3NlZC5zbGljZShpLTEsIGopKX1cIiAoJHtqLWl9LyR7TX0pYCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGkgPSBqO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdCovXHJcbn1cclxuXHJcbi8vIGdpdmVuIGEgbGlzdCBvZiBjb2RlcG9pbnRzXHJcbi8vIHJldHVybnMgYSBsaXN0IG9mIGxpc3RzLCB3aGVyZSBlbW9qaSBhcmUgYSBmdWxseS1xdWFsaWZpZWQgKGFzIEFycmF5IHN1YmNsYXNzKVxyXG4vLyBlZy4gZXhwbG9kZV9jcChcImFiY/CfkqlkXCIpID0+IFtbNjEsIDYyLCA2M10sIEVtb2ppWzFGNEE5LCBGRTBGXSwgWzY0XV1cclxuLy8gMjAyMzA4MTg6IHJlbmFtZSBmb3IgJ3Byb2Nlc3MnIG5hbWUgY29sbGlzaW9uIGgvdCBKYXZhcm9tZVxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzL2lzc3Vlcy8yM1xyXG5mdW5jdGlvbiB0b2tlbnNfZnJvbV9zdHIoaW5wdXQsIG5mLCBlZikge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgY2hhcnMgPSBbXTtcclxuXHRpbnB1dCA9IGlucHV0LnNsaWNlKCkucmV2ZXJzZSgpOyAvLyBmbGlwIHNvIHdlIGNhbiBwb3BcclxuXHR3aGlsZSAoaW5wdXQubGVuZ3RoKSB7XHJcblx0XHRsZXQgZW1vamkgPSBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGlucHV0KTtcclxuXHRcdGlmIChlbW9qaSkge1xyXG5cdFx0XHRpZiAoY2hhcnMubGVuZ3RoKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gobmYoY2hhcnMpKTtcclxuXHRcdFx0XHRjaGFycyA9IFtdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldC5wdXNoKGVmKGVtb2ppKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY3AgPSBpbnB1dC5wb3AoKTtcclxuXHRcdFx0aWYgKFZBTElELmhhcyhjcCkpIHtcclxuXHRcdFx0XHRjaGFycy5wdXNoKGNwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY3BzID0gTUFQUEVELmdldChjcCk7XHJcblx0XHRcdFx0aWYgKGNwcykge1xyXG5cdFx0XHRcdFx0Y2hhcnMucHVzaCguLi5jcHMpOyAvLyBsZXNzIHRoYW4gMTAgZWxlbWVudHNcclxuXHRcdFx0XHR9IGVsc2UgaWYgKCFJR05PUkVELmhhcyhjcCkpIHtcclxuXHRcdFx0XHRcdC8vIDIwMjMwOTEyOiB1bmljb2RlIDE1LjEgY2hhbmdlZCB0aGUgb3JkZXIgb2YgcHJvY2Vzc2luZyBzdWNoIHRoYXRcclxuXHRcdFx0XHRcdC8vIGRpc2FsbG93ZWQgcGFydHMgYXJlIG9ubHkgcmVqZWN0ZWQgYWZ0ZXIgTkZDXHJcblx0XHRcdFx0XHQvLyBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI0Ni8jVmFsaWRpdHlfQ3JpdGVyaWFcclxuXHRcdFx0XHRcdC8vIHRoaXMgZG9lc24ndCBpbXBhY3Qgbm9ybWFsaXphdGlvbiBhcyBvZiB0b2RheVxyXG5cdFx0XHRcdFx0Ly8gdGVjaG5pY2FsbHksIHRoaXMgZXJyb3IgY2FuIGJlIHJlbW92ZWQgYXMgdGhlIGdyb3VwIGxvZ2ljIHdpbGwgYXBwbHkgc2ltaWxhciBsb2dpY1xyXG5cdFx0XHRcdFx0Ly8gaG93ZXZlciB0aGUgZXJyb3IgdHlwZSBtaWdodCBiZSBsZXNzIGNsZWFyXHJcblx0XHRcdFx0XHR0aHJvdyBlcnJvcl9kaXNhbGxvd2VkKGNwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGNoYXJzLmxlbmd0aCkge1xyXG5cdFx0cmV0LnB1c2gobmYoY2hhcnMpKTtcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gZmlsdGVyX2ZlMGYoY3BzKSB7XHJcblx0cmV0dXJuIGNwcy5maWx0ZXIoY3AgPT4gY3AgIT0gRkUwRik7XHJcbn1cclxuXHJcbi8vIGdpdmVuIGFycmF5IG9mIGNvZGVwb2ludHNcclxuLy8gcmV0dXJucyB0aGUgbG9uZ2VzdCB2YWxpZCBlbW9qaSBzZXF1ZW5jZSAob3IgdW5kZWZpbmVkIGlmIG5vIG1hdGNoKVxyXG4vLyAqTVVUQVRFUyogdGhlIHN1cHBsaWVkIGFycmF5XHJcbi8vIGRpc2FsbG93cyBpbnRlcmxlYXZlZCBpZ25vcmVkIGNoYXJhY3RlcnNcclxuLy8gZmlsbHMgKG9wdGlvbmFsKSBlYXRlbiBhcnJheSB3aXRoIG1hdGNoZWQgY29kZXBvaW50c1xyXG5mdW5jdGlvbiBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGNwcywgZWF0ZW4pIHtcclxuXHRsZXQgbm9kZSA9IEVNT0pJX1JPT1Q7XHJcblx0bGV0IGVtb2ppO1xyXG5cdGxldCBwb3MgPSBjcHMubGVuZ3RoO1xyXG5cdHdoaWxlIChwb3MpIHtcclxuXHRcdG5vZGUgPSBub2RlLmdldChjcHNbLS1wb3NdKTtcclxuXHRcdGlmICghbm9kZSkgYnJlYWs7XHJcblx0XHRsZXQge1Z9ID0gbm9kZTtcclxuXHRcdGlmIChWKSB7IC8vIHRoaXMgaXMgYSB2YWxpZCBlbW9qaSAoc28gZmFyKVxyXG5cdFx0XHRlbW9qaSA9IFY7XHJcblx0XHRcdGlmIChlYXRlbikgZWF0ZW4ucHVzaCguLi5jcHMuc2xpY2UocG9zKS5yZXZlcnNlKCkpOyAvLyAob3B0aW9uYWwpIGNvcHkgaW5wdXQsIHVzZWQgZm9yIGVuc190b2tlbml6ZSgpXHJcblx0XHRcdGNwcy5sZW5ndGggPSBwb3M7IC8vIHRydW5jYXRlXHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBlbW9qaTtcclxufVxyXG5cclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vIHRva2VuaXplciBcclxuXHJcbmNvbnN0IFRZX1ZBTElEID0gJ3ZhbGlkJztcclxuY29uc3QgVFlfTUFQUEVEID0gJ21hcHBlZCc7XHJcbmNvbnN0IFRZX0lHTk9SRUQgPSAnaWdub3JlZCc7XHJcbmNvbnN0IFRZX0RJU0FMTE9XRUQgPSAnZGlzYWxsb3dlZCc7XHJcbmNvbnN0IFRZX0VNT0pJID0gJ2Vtb2ppJztcclxuY29uc3QgVFlfTkZDID0gJ25mYyc7XHJcbmNvbnN0IFRZX1NUT1AgPSAnc3RvcCc7XHJcblxyXG5mdW5jdGlvbiBlbnNfdG9rZW5pemUobmFtZSwge1xyXG5cdG5mID0gdHJ1ZSwgLy8gY29sbGFwc2UgdW5ub3JtYWxpemVkIHJ1bnMgaW50byBhIHNpbmdsZSB0b2tlblxyXG59ID0ge30pIHtcclxuXHRpbml0KCk7XHJcblx0bGV0IGlucHV0ID0gZXhwbG9kZV9jcChuYW1lKS5yZXZlcnNlKCk7XHJcblx0bGV0IGVhdGVuID0gW107XHJcblx0bGV0IHRva2VucyA9IFtdO1xyXG5cdHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcclxuXHRcdGxldCBlbW9qaSA9IGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoaW5wdXQsIGVhdGVuKTtcclxuXHRcdGlmIChlbW9qaSkge1xyXG5cdFx0XHR0b2tlbnMucHVzaCh7XHJcblx0XHRcdFx0dHlwZTogVFlfRU1PSkksXHJcblx0XHRcdFx0ZW1vamk6IGVtb2ppLnNsaWNlKCksIC8vIGNvcHkgZW1vamlcclxuXHRcdFx0XHRpbnB1dDogZWF0ZW4sXHJcblx0XHRcdFx0Y3BzOiBmaWx0ZXJfZmUwZihlbW9qaSlcclxuXHRcdFx0fSk7XHJcblx0XHRcdGVhdGVuID0gW107IC8vIHJlc2V0IGJ1ZmZlclxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGNwID0gaW5wdXQucG9wKCk7XHJcblx0XHRcdGlmIChjcCA9PSBTVE9QKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX1NUT1AsIGNwfSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoVkFMSUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9WQUxJRCwgY3BzOiBbY3BdfSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoSUdOT1JFRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX0lHTk9SRUQsIGNwfSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IGNwcyA9IE1BUFBFRC5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmIChjcHMpIHtcclxuXHRcdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9NQVBQRUQsIGNwLCBjcHM6IGNwcy5zbGljZSgpfSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9ESVNBTExPV0VELCBjcH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAobmYpIHtcclxuXHRcdGZvciAobGV0IGkgPSAwLCBzdGFydCA9IC0xOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCB0b2tlbiA9IHRva2Vuc1tpXTtcclxuXHRcdFx0aWYgKGlzX3ZhbGlkX29yX21hcHBlZCh0b2tlbi50eXBlKSkge1xyXG5cdFx0XHRcdGlmIChyZXF1aXJlc19jaGVjayh0b2tlbi5jcHMpKSB7IC8vIG5vcm1hbGl6YXRpb24gbWlnaHQgYmUgbmVlZGVkXHJcblx0XHRcdFx0XHRsZXQgZW5kID0gaSArIDE7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBwb3MgPSBlbmQ7IHBvcyA8IHRva2Vucy5sZW5ndGg7IHBvcysrKSB7IC8vIGZpbmQgYWRqYWNlbnQgdGV4dFxyXG5cdFx0XHRcdFx0XHRsZXQge3R5cGUsIGNwc30gPSB0b2tlbnNbcG9zXTtcclxuXHRcdFx0XHRcdFx0aWYgKGlzX3ZhbGlkX29yX21hcHBlZCh0eXBlKSkge1xyXG5cdFx0XHRcdFx0XHRcdGlmICghcmVxdWlyZXNfY2hlY2soY3BzKSkgYnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0ZW5kID0gcG9zICsgMTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlICE9PSBUWV9JR05PUkVEKSB7IC8vIHx8IHR5cGUgIT09IFRZX0RJU0FMTE9XRUQpIHsgXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChzdGFydCA8IDApIHN0YXJ0ID0gaTtcclxuXHRcdFx0XHRcdGxldCBzbGljZSA9IHRva2Vucy5zbGljZShzdGFydCwgZW5kKTtcclxuXHRcdFx0XHRcdGxldCBjcHMwID0gc2xpY2UuZmxhdE1hcCh4ID0+IGlzX3ZhbGlkX29yX21hcHBlZCh4LnR5cGUpID8geC5jcHMgOiBbXSk7IC8vIHN0cmlwIGp1bmsgdG9rZW5zXHJcblx0XHRcdFx0XHRsZXQgY3BzID0gbmZjKGNwczApO1xyXG5cdFx0XHRcdFx0aWYgKGNvbXBhcmVfYXJyYXlzKGNwcywgY3BzMCkpIHsgLy8gYnVuZGxlIGludG8gYW4gbmZjIHRva2VuXHJcblx0XHRcdFx0XHRcdHRva2Vucy5zcGxpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0LCB7XHJcblx0XHRcdFx0XHRcdFx0dHlwZTogVFlfTkZDLCBcclxuXHRcdFx0XHRcdFx0XHRpbnB1dDogY3BzMCwgLy8gdGhlcmUgYXJlIDMgc3RhdGVzOiB0b2tlbnMwID09KHByb2Nlc3MpPT4gaW5wdXQgPT0obmZjKT0+IHRva2Vucy9jcHNcclxuXHRcdFx0XHRcdFx0XHRjcHMsIFxyXG5cdFx0XHRcdFx0XHRcdHRva2VuczA6IGNvbGxhcHNlX3ZhbGlkX3Rva2VucyhzbGljZSksXHJcblx0XHRcdFx0XHRcdFx0dG9rZW5zOiBlbnNfdG9rZW5pemUoc3RyX2Zyb21fY3BzKGNwcyksIHtuZjogZmFsc2V9KVxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0aSA9IHN0YXJ0O1xyXG5cdFx0XHRcdFx0fSBlbHNlIHsgXHJcblx0XHRcdFx0XHRcdGkgPSBlbmQgLSAxOyAvLyBza2lwIHRvIGVuZCBvZiBzbGljZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0c3RhcnQgPSAtMTsgLy8gcmVzZXRcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c3RhcnQgPSBpOyAvLyByZW1lbWJlciBsYXN0XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKHRva2VuLnR5cGUgIT09IFRZX0lHTk9SRUQpIHsgLy8gMjAyMjEwMjQ6IGlzIHRoaXMgY29ycmVjdD9cclxuXHRcdFx0XHRzdGFydCA9IC0xOyAvLyByZXNldFxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBjb2xsYXBzZV92YWxpZF90b2tlbnModG9rZW5zKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNfdmFsaWRfb3JfbWFwcGVkKHR5cGUpIHtcclxuXHRyZXR1cm4gdHlwZSA9PSBUWV9WQUxJRCB8fCB0eXBlID09IFRZX01BUFBFRDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVxdWlyZXNfY2hlY2soY3BzKSB7XHJcblx0cmV0dXJuIGNwcy5zb21lKGNwID0+IE5GQ19DSEVDSy5oYXMoY3ApKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29sbGFwc2VfdmFsaWRfdG9rZW5zKHRva2Vucykge1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAodG9rZW5zW2ldLnR5cGUgPT0gVFlfVkFMSUQpIHtcclxuXHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0d2hpbGUgKGogPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tqXS50eXBlID09IFRZX1ZBTElEKSBqKys7XHJcblx0XHRcdHRva2Vucy5zcGxpY2UoaSwgaiAtIGksIHt0eXBlOiBUWV9WQUxJRCwgY3BzOiB0b2tlbnMuc2xpY2UoaSwgaikuZmxhdE1hcCh4ID0+IHguY3BzKX0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gdG9rZW5zO1xyXG59XHJcblxyXG5leHBvcnQgeyBlbnNfYmVhdXRpZnksIGVuc19lbW9qaSwgZW5zX25vcm1hbGl6ZSwgZW5zX25vcm1hbGl6ZV9mcmFnbWVudCwgZW5zX3NwbGl0LCBlbnNfdG9rZW5pemUsIGlzX2NvbWJpbmluZ19tYXJrLCBuZmMsIG5mZCwgc2FmZV9zdHJfZnJvbV9jcHMsIHNob3VsZF9lc2NhcGUgfTtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@adraffy/ens-normalize/dist/index.mjs\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\n\r\n\r\n\r\n// connects noble-curves to noble-hashes\r\nfunction getHash(hash) {\r\n    return {\r\n        hash,\r\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\r\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\r\n    };\r\n}\r\nfunction createCurve(curveDef, defHash) {\r\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\r\n    return Object.freeze({ ...create(defHash), create });\r\n}\r\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDMEM7QUFDcUI7QUFDUDtBQUN4RDtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdDQUFnQyx3REFBSSxZQUFZLGdFQUFXO0FBQzNELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ087QUFDUCw2QkFBNkIscUVBQVcsR0FBRywrQkFBK0I7QUFDMUUsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGN1cnZlc1xcZXNtXFxfc2hvcnR3X3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cclxuaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XHJcbmltcG9ydCB7IGNvbmNhdEJ5dGVzLCByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xyXG5pbXBvcnQgeyB3ZWllcnN0cmFzcyB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xyXG4vLyBjb25uZWN0cyBub2JsZS1jdXJ2ZXMgdG8gbm9ibGUtaGFzaGVzXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaGFzaCxcclxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiBobWFjKGhhc2gsIGtleSwgY29uY2F0Qnl0ZXMoLi4ubXNncykpLFxyXG4gICAgICAgIHJhbmRvbUJ5dGVzLFxyXG4gICAgfTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWYsIGRlZkhhc2gpIHtcclxuICAgIGNvbnN0IGNyZWF0ZSA9IChoYXNoKSA9PiB3ZWllcnN0cmFzcyh7IC4uLmN1cnZlRGVmLCAuLi5nZXRIYXNoKGhhc2gpIH0pO1xyXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hvcnR3X3V0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/curve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\n// Abelian group utilities\r\n\r\n\r\nconst _0n = BigInt(0);\r\nconst _1n = BigInt(1);\r\n// Elliptic curve multiplication of Point by scalar. Fragile.\r\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\r\n// Creates precomputation tables for fast multiplication:\r\n// - private scalar is split by fixed size windows of W bits\r\n// - every window point is collected from window's table & added to accumulator\r\n// - since windows are different, same point inside tables won't be accessed more than once per calc\r\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\r\n// - +1 window is neccessary for wNAF\r\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\r\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\r\n// windows to be in different memory locations\r\nfunction wNAF(c, bits) {\r\n    const constTimeNegate = (condition, item) => {\r\n        const neg = item.negate();\r\n        return condition ? neg : item;\r\n    };\r\n    const opts = (W) => {\r\n        const windows = Math.ceil(bits / W) + 1; // +1, because\r\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\r\n        return { windows, windowSize };\r\n    };\r\n    return {\r\n        constTimeNegate,\r\n        // non-const time multiplication ladder\r\n        unsafeLadder(elm, n) {\r\n            let p = c.ZERO;\r\n            let d = elm;\r\n            while (n > _0n) {\r\n                if (n & _1n)\r\n                    p = p.add(d);\r\n                d = d.double();\r\n                n >>= _1n;\r\n            }\r\n            return p;\r\n        },\r\n        /**\r\n         * Creates a wNAF precomputation window. Used for caching.\r\n         * Default window size is set by `utils.precompute()` and is equal to 8.\r\n         * Number of precomputed points depends on the curve size:\r\n         * 2^(1) * (Math.ceil( / ) + 1), where:\r\n         * -  is the window size\r\n         * -  is the bitlength of the curve order.\r\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\r\n         * @returns precomputed point tables flattened to a single array\r\n         */\r\n        precomputeWindow(elm, W) {\r\n            const { windows, windowSize } = opts(W);\r\n            const points = [];\r\n            let p = elm;\r\n            let base = p;\r\n            for (let window = 0; window < windows; window++) {\r\n                base = p;\r\n                points.push(base);\r\n                // =1, because we skip zero\r\n                for (let i = 1; i < windowSize; i++) {\r\n                    base = base.add(p);\r\n                    points.push(base);\r\n                }\r\n                p = base.double();\r\n            }\r\n            return points;\r\n        },\r\n        /**\r\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\r\n         * @param W window size\r\n         * @param precomputes precomputed tables\r\n         * @param n scalar (we don't check here, but should be less than curve order)\r\n         * @returns real and fake (for const-time) points\r\n         */\r\n        wNAF(W, precomputes, n) {\r\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\r\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\r\n            const { windows, windowSize } = opts(W);\r\n            let p = c.ZERO;\r\n            let f = c.BASE;\r\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\r\n            const maxNumber = 2 ** W;\r\n            const shiftBy = BigInt(W);\r\n            for (let window = 0; window < windows; window++) {\r\n                const offset = window * windowSize;\r\n                // Extract W bits.\r\n                let wbits = Number(n & mask);\r\n                // Shift number by W bits.\r\n                n >>= shiftBy;\r\n                // If the bits are bigger than max size, we'll split those.\r\n                // +224 => 256 - 32\r\n                if (wbits > windowSize) {\r\n                    wbits -= maxNumber;\r\n                    n += _1n;\r\n                }\r\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\r\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\r\n                // there is negate now: it is possible that negated element from low value\r\n                // would be the same as high element, which will create carry into next window.\r\n                // It's not obvious how this can fail, but still worth investigating later.\r\n                // Check if we're onto Zero point.\r\n                // Add random point inside current window to f.\r\n                const offset1 = offset;\r\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\r\n                const cond1 = window % 2 !== 0;\r\n                const cond2 = wbits < 0;\r\n                if (wbits === 0) {\r\n                    // The most important part for const-time getPublicKey\r\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\r\n                }\r\n                else {\r\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\r\n                }\r\n            }\r\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\r\n            // Even if the variable is still unused, there are some checks which will\r\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\r\n            // At this point there is a way to F be infinity-point even if p is not,\r\n            // which makes it less const-time: around 1 bigint multiply.\r\n            return { p, f };\r\n        },\r\n        wNAFCached(P, precomputesMap, n, transform) {\r\n            // @ts-ignore\r\n            const W = P._WINDOW_SIZE || 1;\r\n            // Calculate precomputes on a first run, reuse them after\r\n            let comp = precomputesMap.get(P);\r\n            if (!comp) {\r\n                comp = this.precomputeWindow(P, W);\r\n                if (W !== 1) {\r\n                    precomputesMap.set(P, transform(comp));\r\n                }\r\n            }\r\n            return this.wNAF(W, comp, n);\r\n        },\r\n    };\r\n}\r\nfunction validateBasic(curve) {\r\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\r\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\r\n        n: 'bigint',\r\n        h: 'bigint',\r\n        Gx: 'field',\r\n        Gy: 'field',\r\n    }, {\r\n        nBitLength: 'isSafeInteger',\r\n        nByteLength: 'isSafeInteger',\r\n    });\r\n    // Set defaults\r\n    return Object.freeze({\r\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\r\n        ...curve,\r\n        ...{ p: curve.Fp.ORDER },\r\n    });\r\n}\r\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNzRDtBQUNWO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELHlDQUF5QztBQUN6QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQLElBQUksMERBQWE7QUFDakIsSUFBSSx5REFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXLG9EQUFPO0FBQ2xCO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXEBub2JsZVxcY3VydmVzXFxlc21cXGFic3RyYWN0XFxjdXJ2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXHJcbi8vIEFiZWxpYW4gZ3JvdXAgdXRpbGl0aWVzXHJcbmltcG9ydCB7IHZhbGlkYXRlRmllbGQsIG5MZW5ndGggfSBmcm9tICcuL21vZHVsYXIuanMnO1xyXG5pbXBvcnQgeyB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xyXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XHJcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcclxuLy8gRWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gb2YgUG9pbnQgYnkgc2NhbGFyLiBGcmFnaWxlLlxyXG4vLyBTY2FsYXJzIHNob3VsZCBhbHdheXMgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyOiB0aGlzIHNob3VsZCBiZSBjaGVja2VkIGluc2lkZSBvZiBhIGN1cnZlIGl0c2VsZi5cclxuLy8gQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XHJcbi8vIC0gcHJpdmF0ZSBzY2FsYXIgaXMgc3BsaXQgYnkgZml4ZWQgc2l6ZSB3aW5kb3dzIG9mIFcgYml0c1xyXG4vLyAtIGV2ZXJ5IHdpbmRvdyBwb2ludCBpcyBjb2xsZWN0ZWQgZnJvbSB3aW5kb3cncyB0YWJsZSAmIGFkZGVkIHRvIGFjY3VtdWxhdG9yXHJcbi8vIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcclxuLy8gLSBlYWNoIG11bHRpcGxpY2F0aW9uIGlzICdNYXRoLmNlaWwoQ1VSVkVfT1JERVIgLyDwnZGKKSArIDEnIHBvaW50IGFkZGl0aW9ucyAoZml4ZWQgZm9yIGFueSBzY2FsYXIpXHJcbi8vIC0gKzEgd2luZG93IGlzIG5lY2Nlc3NhcnkgZm9yIHdOQUZcclxuLy8gLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cclxuLy8gVE9ETzogUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LiBUaGlzIHdvdWxkIGFsbG93XHJcbi8vIHdpbmRvd3MgdG8gYmUgaW4gZGlmZmVyZW50IG1lbW9yeSBsb2NhdGlvbnNcclxuZXhwb3J0IGZ1bmN0aW9uIHdOQUYoYywgYml0cykge1xyXG4gICAgY29uc3QgY29uc3RUaW1lTmVnYXRlID0gKGNvbmRpdGlvbiwgaXRlbSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgb3B0cyA9IChXKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgd2luZG93cyA9IE1hdGguY2VpbChiaXRzIC8gVykgKyAxOyAvLyArMSwgYmVjYXVzZVxyXG4gICAgICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXHJcbiAgICAgICAgcmV0dXJuIHsgd2luZG93cywgd2luZG93U2l6ZSB9O1xyXG4gICAgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY29uc3RUaW1lTmVnYXRlLFxyXG4gICAgICAgIC8vIG5vbi1jb25zdCB0aW1lIG11bHRpcGxpY2F0aW9uIGxhZGRlclxyXG4gICAgICAgIHVuc2FmZUxhZGRlcihlbG0sIG4pIHtcclxuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XHJcbiAgICAgICAgICAgIGxldCBkID0gZWxtO1xyXG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG4gJiBfMW4pXHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xyXG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XHJcbiAgICAgICAgICAgICAgICBuID4+PSBfMW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXHJcbiAgICAgICAgICogRGVmYXVsdCB3aW5kb3cgc2l6ZSBpcyBzZXQgYnkgYHV0aWxzLnByZWNvbXB1dGUoKWAgYW5kIGlzIGVxdWFsIHRvIDguXHJcbiAgICAgICAgICogTnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBkZXBlbmRzIG9uIHRoZSBjdXJ2ZSBzaXplOlxyXG4gICAgICAgICAqIDJeKPCdkYriiJIxKSAqIChNYXRoLmNlaWwo8J2RmyAvIPCdkYopICsgMSksIHdoZXJlOlxyXG4gICAgICAgICAqIC0g8J2RiiBpcyB0aGUgd2luZG93IHNpemVcclxuICAgICAgICAgKiAtIPCdkZsgaXMgdGhlIGJpdGxlbmd0aCBvZiB0aGUgY3VydmUgb3JkZXIuXHJcbiAgICAgICAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIHByZWNvbXB1dGVkIHBvaW50IHRhYmxlcyBmbGF0dGVuZWQgdG8gYSBzaW5nbGUgYXJyYXlcclxuICAgICAgICAgKi9cclxuICAgICAgICBwcmVjb21wdXRlV2luZG93KGVsbSwgVykge1xyXG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcclxuICAgICAgICAgICAgbGV0IGJhc2UgPSBwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xyXG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XHJcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcclxuICAgICAgICAgICAgICAgIC8vID0xLCBiZWNhdXNlIHdlIHNraXAgemVyb1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5hZGQocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwID0gYmFzZS5kb3VibGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxyXG4gICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXHJcbiAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xyXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXHJcbiAgICAgICAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogbWF5YmUgY2hlY2sgdGhhdCBzY2FsYXIgaXMgbGVzcyB0aGFuIGdyb3VwIG9yZGVyPyB3TkFGIGJlaGF2aW91cyBpcyB1bmRlZmluZWQgb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgIC8vIEJ1dCBuZWVkIHRvIGNhcmVmdWxseSByZW1vdmUgb3RoZXIgY2hlY2tzIGJlZm9yZSB3TkFGLiBPUkRFUiA9PSBiaXRzIGhlcmVcclxuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xyXG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcclxuICAgICAgICAgICAgbGV0IGYgPSBjLkJBU0U7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMiAqKiBXIC0gMSk7IC8vIENyZWF0ZSBtYXNrIHdpdGggVyBvbmVzOiAwYjExMTEgZm9yIFc9NCBldGMuXHJcbiAgICAgICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcclxuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpbmRvdyAqIHdpbmRvd1NpemU7XHJcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IFcgYml0cy5cclxuICAgICAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XHJcbiAgICAgICAgICAgICAgICAvLyBTaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxyXG4gICAgICAgICAgICAgICAgbiA+Pj0gc2hpZnRCeTtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBiaXRzIGFyZSBiaWdnZXIgdGhhbiBtYXggc2l6ZSwgd2UnbGwgc3BsaXQgdGhvc2UuXHJcbiAgICAgICAgICAgICAgICAvLyArMjI0ID0+IDI1NiAtIDMyXHJcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHdhcyBmaXJzdCB3cml0dGVuIHdpdGggYXNzdW1wdGlvbiB0aGF0ICdmJyBhbmQgJ3AnIHdpbGwgbmV2ZXIgYmUgaW5maW5pdHkgcG9pbnQ6XHJcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBuZWdhdGUgbm93OiBpdCBpcyBwb3NzaWJsZSB0aGF0IG5lZ2F0ZWQgZWxlbWVudCBmcm9tIGxvdyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgLy8gd291bGQgYmUgdGhlIHNhbWUgYXMgaGlnaCBlbGVtZW50LCB3aGljaCB3aWxsIGNyZWF0ZSBjYXJyeSBpbnRvIG5leHQgd2luZG93LlxyXG4gICAgICAgICAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBvbnRvIFplcm8gcG9pbnQuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgcmFuZG9tIHBvaW50IGluc2lkZSBjdXJyZW50IHdpbmRvdyB0byBmLlxyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSBvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDEgPSB3aW5kb3cgJSAyICE9PSAwO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBpbXBvcnRhbnQgcGFydCBmb3IgY29uc3QtdGltZSBnZXRQdWJsaWNLZXlcclxuICAgICAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBKSVQtY29tcGlsZXIgc2hvdWxkIG5vdCBlbGltaW5hdGUgZiBoZXJlLCBzaW5jZSBpdCB3aWxsIGxhdGVyIGJlIHVzZWQgaW4gbm9ybWFsaXplWigpXHJcbiAgICAgICAgICAgIC8vIEV2ZW4gaWYgdGhlIHZhcmlhYmxlIGlzIHN0aWxsIHVudXNlZCwgdGhlcmUgYXJlIHNvbWUgY2hlY2tzIHdoaWNoIHdpbGxcclxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uLCBzbyBjb21waWxlciBuZWVkcyB0byBwcm92ZSB0aGV5IHdvbid0IGhhcHBlbiwgd2hpY2ggaXMgaGFyZC5cclxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSBpcyBhIHdheSB0byBGIGJlIGluZmluaXR5LXBvaW50IGV2ZW4gaWYgcCBpcyBub3QsXHJcbiAgICAgICAgICAgIC8vIHdoaWNoIG1ha2VzIGl0IGxlc3MgY29uc3QtdGltZTogYXJvdW5kIDEgYmlnaW50IG11bHRpcGx5LlxyXG4gICAgICAgICAgICByZXR1cm4geyBwLCBmIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICB3TkFGQ2FjaGVkKFAsIHByZWNvbXB1dGVzTWFwLCBuLCB0cmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBjb25zdCBXID0gUC5fV0lORE9XX1NJWkUgfHwgMTtcclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXHJcbiAgICAgICAgICAgIGxldCBjb21wID0gcHJlY29tcHV0ZXNNYXAuZ2V0KFApO1xyXG4gICAgICAgICAgICBpZiAoIWNvbXApIHtcclxuICAgICAgICAgICAgICAgIGNvbXAgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3coUCwgVyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoVyAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZWNvbXB1dGVzTWFwLnNldChQLCB0cmFuc2Zvcm0oY29tcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUYoVywgY29tcCwgbik7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcclxuICAgIHZhbGlkYXRlRmllbGQoY3VydmUuRnApO1xyXG4gICAgdmFsaWRhdGVPYmplY3QoY3VydmUsIHtcclxuICAgICAgICBuOiAnYmlnaW50JyxcclxuICAgICAgICBoOiAnYmlnaW50JyxcclxuICAgICAgICBHeDogJ2ZpZWxkJyxcclxuICAgICAgICBHeTogJ2ZpZWxkJyxcclxuICAgIH0sIHtcclxuICAgICAgICBuQml0TGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXHJcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcclxuICAgIH0pO1xyXG4gICAgLy8gU2V0IGRlZmF1bHRzXHJcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICAgICAgLi4ubkxlbmd0aChjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcclxuICAgICAgICAuLi5jdXJ2ZSxcclxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n\r\n\r\nfunction validateDST(dst) {\r\n    if (dst instanceof Uint8Array)\r\n        return dst;\r\n    if (typeof dst === 'string')\r\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(dst);\r\n    throw new Error('DST must be Uint8Array or string');\r\n}\r\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\r\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\r\n// Integer to Octet Stream (numberToBytesBE)\r\nfunction i2osp(value, length) {\r\n    if (value < 0 || value >= 1 << (8 * length)) {\r\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\r\n    }\r\n    const res = Array.from({ length }).fill(0);\r\n    for (let i = length - 1; i >= 0; i--) {\r\n        res[i] = value & 0xff;\r\n        value >>>= 8;\r\n    }\r\n    return new Uint8Array(res);\r\n}\r\nfunction strxor(a, b) {\r\n    const arr = new Uint8Array(a.length);\r\n    for (let i = 0; i < a.length; i++) {\r\n        arr[i] = a[i] ^ b[i];\r\n    }\r\n    return arr;\r\n}\r\nfunction isBytes(item) {\r\n    if (!(item instanceof Uint8Array))\r\n        throw new Error('Uint8Array expected');\r\n}\r\nfunction isNum(item) {\r\n    if (!Number.isSafeInteger(item))\r\n        throw new Error('number expected');\r\n}\r\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\r\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\r\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\r\n    isBytes(msg);\r\n    isBytes(DST);\r\n    isNum(lenInBytes);\r\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\r\n    if (DST.length > 255)\r\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\r\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\r\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\r\n    if (ell > 255)\r\n        throw new Error('Invalid xmd length');\r\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\r\n    const Z_pad = i2osp(0, r_in_bytes);\r\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\r\n    const b = new Array(ell);\r\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\r\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\r\n    for (let i = 1; i <= ell; i++) {\r\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\r\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\r\n    }\r\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\r\n    return pseudo_random_bytes.slice(0, lenInBytes);\r\n}\r\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\r\n// 1. The collision resistance of H MUST be at least k bits.\r\n// 2. H MUST be an XOF that has been proved indifferentiable from\r\n//    a random oracle under a reasonable cryptographic assumption.\r\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\r\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\r\n    isBytes(msg);\r\n    isBytes(DST);\r\n    isNum(lenInBytes);\r\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\r\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\r\n    if (DST.length > 255) {\r\n        const dkLen = Math.ceil((2 * k) / 8);\r\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\r\n    }\r\n    if (lenInBytes > 65535 || DST.length > 255)\r\n        throw new Error('expand_message_xof: invalid lenInBytes');\r\n    return (H.create({ dkLen: lenInBytes })\r\n        .update(msg)\r\n        .update(i2osp(lenInBytes, 2))\r\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\r\n        .update(DST)\r\n        .update(i2osp(DST.length, 1))\r\n        .digest());\r\n}\r\n/**\r\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\r\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\r\n * @param msg a byte string containing the message to hash\r\n * @param count the number of elements of F to output\r\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\r\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\r\n */\r\nfunction hash_to_field(msg, count, options) {\r\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\r\n        DST: 'stringOrUint8Array',\r\n        p: 'bigint',\r\n        m: 'isSafeInteger',\r\n        k: 'isSafeInteger',\r\n        hash: 'hash',\r\n    });\r\n    const { p, k, m, hash, expand, DST: _DST } = options;\r\n    isBytes(msg);\r\n    isNum(count);\r\n    const DST = validateDST(_DST);\r\n    const log2p = p.toString(2).length;\r\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\r\n    const len_in_bytes = count * m * L;\r\n    let prb; // pseudo_random_bytes\r\n    if (expand === 'xmd') {\r\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\r\n    }\r\n    else if (expand === 'xof') {\r\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\r\n    }\r\n    else if (expand === '_internal_pass') {\r\n        // for internal tests only\r\n        prb = msg;\r\n    }\r\n    else {\r\n        throw new Error('expand must be \"xmd\" or \"xof\"');\r\n    }\r\n    const u = new Array(count);\r\n    for (let i = 0; i < count; i++) {\r\n        const e = new Array(m);\r\n        for (let j = 0; j < m; j++) {\r\n            const elm_offset = L * (j + i * m);\r\n            const tv = prb.subarray(elm_offset, elm_offset + L);\r\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\r\n        }\r\n        u[i] = e;\r\n    }\r\n    return u;\r\n}\r\nfunction isogenyMap(field, map) {\r\n    // Make same order as in spec\r\n    const COEFF = map.map((i) => Array.from(i).reverse());\r\n    return (x, y) => {\r\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\r\n        x = field.div(xNum, xDen); // xNum / xDen\r\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\r\n        return { x, y };\r\n    };\r\n}\r\nfunction createHasher(Point, mapToCurve, def) {\r\n    if (typeof mapToCurve !== 'function')\r\n        throw new Error('mapToCurve() must be defined');\r\n    return {\r\n        // Encodes byte string to elliptic curve.\r\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\r\n        hashToCurve(msg, options) {\r\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\r\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\r\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\r\n            const P = u0.add(u1).clearCofactor();\r\n            P.assertValidity();\r\n            return P;\r\n        },\r\n        // Encodes byte string to elliptic curve.\r\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\r\n        encodeToCurve(msg, options) {\r\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\r\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\r\n            P.assertValidity();\r\n            return P;\r\n        },\r\n    };\r\n}\r\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBbUM7QUFDb0Q7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNEQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0RBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU8sU0FBUyxPQUFPO0FBQ3hFO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckMsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFXLENBQUMsc0RBQVc7QUFDdkMsWUFBWSw4Q0FBOEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFXO0FBQ2pDO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0Esa0JBQWtCLHNEQUFXO0FBQzdCLGFBQWEsc0RBQVc7QUFDeEIsb0JBQW9CLFVBQVU7QUFDOUI7QUFDQSxpQkFBaUIsc0RBQVc7QUFDNUI7QUFDQSxnQ0FBZ0Msc0RBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU8sU0FBUyxzREFBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2RUFBNkU7QUFDakc7QUFDQTtBQUNPO0FBQ1AsSUFBSSx5REFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQUc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaURBQWlEO0FBQ2pELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0NBQWtDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHdDQUF3QztBQUN0RjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGN1cnZlc1xcZXNtXFxhYnN0cmFjdFxcaGFzaC10by1jdXJ2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtb2QgfSBmcm9tICcuL21vZHVsYXIuanMnO1xyXG5pbXBvcnQgeyBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCB1dGY4VG9CeXRlcywgdmFsaWRhdGVPYmplY3QgfSBmcm9tICcuL3V0aWxzLmpzJztcclxuZnVuY3Rpb24gdmFsaWRhdGVEU1QoZHN0KSB7XHJcbiAgICBpZiAoZHN0IGluc3RhbmNlb2YgVWludDhBcnJheSlcclxuICAgICAgICByZXR1cm4gZHN0O1xyXG4gICAgaWYgKHR5cGVvZiBkc3QgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhkc3QpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdEU1QgbXVzdCBiZSBVaW50OEFycmF5IG9yIHN0cmluZycpO1xyXG59XHJcbi8vIE9jdGV0IFN0cmVhbSB0byBJbnRlZ2VyLiBcInNwZWNcIiBpbXBsZW1lbnRhdGlvbiBvZiBvczJpcCBpcyAyLjV4IHNsb3dlciB2cyBieXRlc1RvTnVtYmVyQkUuXHJcbmNvbnN0IG9zMmlwID0gYnl0ZXNUb051bWJlckJFO1xyXG4vLyBJbnRlZ2VyIHRvIE9jdGV0IFN0cmVhbSAobnVtYmVyVG9CeXRlc0JFKVxyXG5mdW5jdGlvbiBpMm9zcCh2YWx1ZSwgbGVuZ3RoKSB7XHJcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDEgPDwgKDggKiBsZW5ndGgpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgSTJPU1AgY2FsbDogdmFsdWU9JHt2YWx1ZX0gbGVuZ3RoPSR7bGVuZ3RofWApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aCB9KS5maWxsKDApO1xyXG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgcmVzW2ldID0gdmFsdWUgJiAweGZmO1xyXG4gICAgICAgIHZhbHVlID4+Pj0gODtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXMpO1xyXG59XHJcbmZ1bmN0aW9uIHN0cnhvcihhLCBiKSB7XHJcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBhcnJbaV0gPSBhW2ldIF4gYltpXTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcnI7XHJcbn1cclxuZnVuY3Rpb24gaXNCeXRlcyhpdGVtKSB7XHJcbiAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgVWludDhBcnJheSkpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XHJcbn1cclxuZnVuY3Rpb24gaXNOdW0oaXRlbSkge1xyXG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpdGVtKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xyXG59XHJcbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhIGNyeXB0b2dyYXBoaWMgaGFzaCBmdW5jdGlvbiBIIHRoYXQgb3V0cHV0cyBiIGJpdHNcclxuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMVxyXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBIKSB7XHJcbiAgICBpc0J5dGVzKG1zZyk7XHJcbiAgICBpc0J5dGVzKERTVCk7XHJcbiAgICBpc051bShsZW5JbkJ5dGVzKTtcclxuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcclxuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxyXG4gICAgICAgIERTVCA9IEgoY29uY2F0Qnl0ZXModXRmOFRvQnl0ZXMoJ0gyQy1PVkVSU0laRS1EU1QtJyksIERTVCkpO1xyXG4gICAgY29uc3QgeyBvdXRwdXRMZW46IGJfaW5fYnl0ZXMsIGJsb2NrTGVuOiByX2luX2J5dGVzIH0gPSBIO1xyXG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcclxuICAgIGlmIChlbGwgPiAyNTUpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHhtZCBsZW5ndGgnKTtcclxuICAgIGNvbnN0IERTVF9wcmltZSA9IGNvbmNhdEJ5dGVzKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xyXG4gICAgY29uc3QgWl9wYWQgPSBpMm9zcCgwLCByX2luX2J5dGVzKTtcclxuICAgIGNvbnN0IGxfaV9iX3N0ciA9IGkyb3NwKGxlbkluQnl0ZXMsIDIpOyAvLyBsZW5faW5fYnl0ZXNfc3RyXHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XHJcbiAgICBjb25zdCBiXzAgPSBIKGNvbmNhdEJ5dGVzKFpfcGFkLCBtc2csIGxfaV9iX3N0ciwgaTJvc3AoMCwgMSksIERTVF9wcmltZSkpO1xyXG4gICAgYlswXSA9IEgoY29uY2F0Qnl0ZXMoYl8wLCBpMm9zcCgxLCAxKSwgRFNUX3ByaW1lKSk7XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbc3RyeG9yKGJfMCwgYltpIC0gMV0pLCBpMm9zcChpICsgMSwgMSksIERTVF9wcmltZV07XHJcbiAgICAgICAgYltpXSA9IEgoY29uY2F0Qnl0ZXMoLi4uYXJncykpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHNldWRvX3JhbmRvbV9ieXRlcyA9IGNvbmNhdEJ5dGVzKC4uLmIpO1xyXG4gICAgcmV0dXJuIHBzZXVkb19yYW5kb21fYnl0ZXMuc2xpY2UoMCwgbGVuSW5CeXRlcyk7XHJcbn1cclxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGFuIGV4dGVuZGFibGUtb3V0cHV0IGZ1bmN0aW9uIChYT0YpIEguXHJcbi8vIDEuIFRoZSBjb2xsaXNpb24gcmVzaXN0YW5jZSBvZiBIIE1VU1QgYmUgYXQgbGVhc3QgayBiaXRzLlxyXG4vLyAyLiBIIE1VU1QgYmUgYW4gWE9GIHRoYXQgaGFzIGJlZW4gcHJvdmVkIGluZGlmZmVyZW50aWFibGUgZnJvbVxyXG4vLyAgICBhIHJhbmRvbSBvcmFjbGUgdW5kZXIgYSByZWFzb25hYmxlIGNyeXB0b2dyYXBoaWMgYXNzdW1wdGlvbi5cclxuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMlxyXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XHJcbiAgICBpc0J5dGVzKG1zZyk7XHJcbiAgICBpc0J5dGVzKERTVCk7XHJcbiAgICBpc051bShsZW5JbkJ5dGVzKTtcclxuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcclxuICAgIC8vIERTVCA9IEgoJ0gyQy1PVkVSU0laRS1EU1QtJyB8fCBhX3ZlcnlfbG9uZ19EU1QsIE1hdGguY2VpbCgobGVuSW5CeXRlcyAqIGspIC8gOCkpO1xyXG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcclxuICAgICAgICBjb25zdCBka0xlbiA9IE1hdGguY2VpbCgoMiAqIGspIC8gOCk7XHJcbiAgICAgICAgRFNUID0gSC5jcmVhdGUoeyBka0xlbiB9KS51cGRhdGUodXRmOFRvQnl0ZXMoJ0gyQy1PVkVSU0laRS1EU1QtJykpLnVwZGF0ZShEU1QpLmRpZ2VzdCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBEU1QubGVuZ3RoID4gMjU1KVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kX21lc3NhZ2VfeG9mOiBpbnZhbGlkIGxlbkluQnl0ZXMnKTtcclxuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxyXG4gICAgICAgIC51cGRhdGUobXNnKVxyXG4gICAgICAgIC51cGRhdGUoaTJvc3AobGVuSW5CeXRlcywgMikpXHJcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxyXG4gICAgICAgIC51cGRhdGUoRFNUKVxyXG4gICAgICAgIC51cGRhdGUoaTJvc3AoRFNULmxlbmd0aCwgMSkpXHJcbiAgICAgICAgLmRpZ2VzdCgpKTtcclxufVxyXG4vKipcclxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGXHJcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4yXHJcbiAqIEBwYXJhbSBtc2cgYSBieXRlIHN0cmluZyBjb250YWluaW5nIHRoZSBtZXNzYWdlIHRvIGhhc2hcclxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcclxuICogQHBhcmFtIG9wdGlvbnMgYHtEU1Q6IHN0cmluZywgcDogYmlnaW50LCBtOiBudW1iZXIsIGs6IG51bWJlciwgZXhwYW5kOiAneG1kJyB8ICd4b2YnLCBoYXNoOiBIfWAsIHNlZSBhYm92ZVxyXG4gKiBAcmV0dXJucyBbdV8wLCAuLi4sIHVfKGNvdW50IC0gMSldLCBhIGxpc3Qgb2YgZmllbGQgZWxlbWVudHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaGFzaF90b19maWVsZChtc2csIGNvdW50LCBvcHRpb25zKSB7XHJcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRpb25zLCB7XHJcbiAgICAgICAgRFNUOiAnc3RyaW5nT3JVaW50OEFycmF5JyxcclxuICAgICAgICBwOiAnYmlnaW50JyxcclxuICAgICAgICBtOiAnaXNTYWZlSW50ZWdlcicsXHJcbiAgICAgICAgazogJ2lzU2FmZUludGVnZXInLFxyXG4gICAgICAgIGhhc2g6ICdoYXNoJyxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVDogX0RTVCB9ID0gb3B0aW9ucztcclxuICAgIGlzQnl0ZXMobXNnKTtcclxuICAgIGlzTnVtKGNvdW50KTtcclxuICAgIGNvbnN0IERTVCA9IHZhbGlkYXRlRFNUKF9EU1QpO1xyXG4gICAgY29uc3QgbG9nMnAgPSBwLnRvU3RyaW5nKDIpLmxlbmd0aDtcclxuICAgIGNvbnN0IEwgPSBNYXRoLmNlaWwoKGxvZzJwICsgaykgLyA4KTsgLy8gc2VjdGlvbiA1LjEgb2YgaWV0ZiBkcmFmdCBsaW5rIGFib3ZlXHJcbiAgICBjb25zdCBsZW5faW5fYnl0ZXMgPSBjb3VudCAqIG0gKiBMO1xyXG4gICAgbGV0IHByYjsgLy8gcHNldWRvX3JhbmRvbV9ieXRlc1xyXG4gICAgaWYgKGV4cGFuZCA9PT0gJ3htZCcpIHtcclxuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaGFzaCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICd4b2YnKSB7XHJcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGssIGhhc2gpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAnX2ludGVybmFsX3Bhc3MnKSB7XHJcbiAgICAgICAgLy8gZm9yIGludGVybmFsIHRlc3RzIG9ubHlcclxuICAgICAgICBwcmIgPSBtc2c7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZCBtdXN0IGJlIFwieG1kXCIgb3IgXCJ4b2ZcIicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdSA9IG5ldyBBcnJheShjb3VudCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICBjb25zdCBlID0gbmV3IEFycmF5KG0pO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsbV9vZmZzZXQgPSBMICogKGogKyBpICogbSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHR2ID0gcHJiLnN1YmFycmF5KGVsbV9vZmZzZXQsIGVsbV9vZmZzZXQgKyBMKTtcclxuICAgICAgICAgICAgZVtqXSA9IG1vZChvczJpcCh0diksIHApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1W2ldID0gZTtcclxuICAgIH1cclxuICAgIHJldHVybiB1O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpc29nZW55TWFwKGZpZWxkLCBtYXApIHtcclxuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXHJcbiAgICBjb25zdCBDT0VGRiA9IG1hcC5tYXAoKGkpID0+IEFycmF5LmZyb20oaSkucmV2ZXJzZSgpKTtcclxuICAgIHJldHVybiAoeCwgeSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IFt4TnVtLCB4RGVuLCB5TnVtLCB5RGVuXSA9IENPRUZGLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcclxuICAgICAgICB4ID0gZmllbGQuZGl2KHhOdW0sIHhEZW4pOyAvLyB4TnVtIC8geERlblxyXG4gICAgICAgIHkgPSBmaWVsZC5tdWwoeSwgZmllbGQuZGl2KHlOdW0sIHlEZW4pKTsgLy8geSAqICh5TnVtIC8geURldilcclxuICAgICAgICByZXR1cm4geyB4LCB5IH07XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIYXNoZXIoUG9pbnQsIG1hcFRvQ3VydmUsIGRlZikge1xyXG4gICAgaWYgKHR5cGVvZiBtYXBUb0N1cnZlICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZSgpIG11c3QgYmUgZGVmaW5lZCcpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxyXG4gICAgICAgIC8vIGhhc2hfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcclxuICAgICAgICBoYXNoVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCB7IC4uLmRlZiwgRFNUOiBkZWYuRFNULCAuLi5vcHRpb25zIH0pO1xyXG4gICAgICAgICAgICBjb25zdCB1MCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHUxID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMV0pKTtcclxuICAgICAgICAgICAgY29uc3QgUCA9IHUwLmFkZCh1MSkuY2xlYXJDb2ZhY3RvcigpO1xyXG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBQO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cclxuICAgICAgICAvLyBlbmNvZGVfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcclxuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDEsIHsgLi4uZGVmLCBEU1Q6IGRlZi5lbmNvZGVEU1QsIC4uLm9wdGlvbnMgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpLmNsZWFyQ29mYWN0b3IoKTtcclxuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gUDtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXRvLWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/modular.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/modular.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\n// Utilities for modular arithmetics and finite fields\r\n\r\n// prettier-ignore\r\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\r\n// prettier-ignore\r\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\r\n// prettier-ignore\r\nconst _9n = BigInt(9), _16n = BigInt(16);\r\n// Calculates a modulo b\r\nfunction mod(a, b) {\r\n    const result = a % b;\r\n    return result >= _0n ? result : b + result;\r\n}\r\n/**\r\n * Efficiently raise num to power and do modular division.\r\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\r\n * @example\r\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\r\n */\r\n// TODO: use field version && remove\r\nfunction pow(num, power, modulo) {\r\n    if (modulo <= _0n || power < _0n)\r\n        throw new Error('Expected power/modulo > 0');\r\n    if (modulo === _1n)\r\n        return _0n;\r\n    let res = _1n;\r\n    while (power > _0n) {\r\n        if (power & _1n)\r\n            res = (res * num) % modulo;\r\n        num = (num * num) % modulo;\r\n        power >>= _1n;\r\n    }\r\n    return res;\r\n}\r\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\r\nfunction pow2(x, power, modulo) {\r\n    let res = x;\r\n    while (power-- > _0n) {\r\n        res *= res;\r\n        res %= modulo;\r\n    }\r\n    return res;\r\n}\r\n// Inverses number over modulo\r\nfunction invert(number, modulo) {\r\n    if (number === _0n || modulo <= _0n) {\r\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\r\n    }\r\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\r\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\r\n    let a = mod(number, modulo);\r\n    let b = modulo;\r\n    // prettier-ignore\r\n    let x = _0n, y = _1n, u = _1n, v = _0n;\r\n    while (a !== _0n) {\r\n        // JIT applies optimization if those two lines follow each other\r\n        const q = b / a;\r\n        const r = b % a;\r\n        const m = x - u * q;\r\n        const n = y - v * q;\r\n        // prettier-ignore\r\n        b = a, a = r, x = u, y = v, u = m, v = n;\r\n    }\r\n    const gcd = b;\r\n    if (gcd !== _1n)\r\n        throw new Error('invert: does not exist');\r\n    return mod(x, modulo);\r\n}\r\n/**\r\n * Tonelli-Shanks square root search algorithm.\r\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\r\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\r\n * Will start an infinite loop if field order P is not prime.\r\n * @param P field order\r\n * @returns function that takes field Fp (created from P) and number n\r\n */\r\nfunction tonelliShanks(P) {\r\n    // Legendre constant: used to calculate Legendre symbol (a | p),\r\n    // which denotes the value of a^((p-1)/2) (mod p).\r\n    // (a | p)  1    if a is a square (mod p)\r\n    // (a | p)  -1   if a is not a square (mod p)\r\n    // (a | p)  0    if a  0 (mod p)\r\n    const legendreC = (P - _1n) / _2n;\r\n    let Q, S, Z;\r\n    // Step 1: By factoring out powers of 2 from p - 1,\r\n    // find q and s such that p - 1 = q*(2^s) with q odd\r\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\r\n        ;\r\n    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq\r\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\r\n        ;\r\n    // Fast-path\r\n    if (S === 1) {\r\n        const p1div4 = (P + _1n) / _4n;\r\n        return function tonelliFast(Fp, n) {\r\n            const root = Fp.pow(n, p1div4);\r\n            if (!Fp.eql(Fp.sqr(root), n))\r\n                throw new Error('Cannot find square root');\r\n            return root;\r\n        };\r\n    }\r\n    // Slow-path\r\n    const Q1div2 = (Q + _1n) / _2n;\r\n    return function tonelliSlow(Fp, n) {\r\n        // Step 0: Check that n is indeed a square: (n | p) should not be  -1\r\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\r\n            throw new Error('Cannot find square root');\r\n        let r = S;\r\n        // TODO: will fail at Fp2/etc\r\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\r\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\r\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\r\n        while (!Fp.eql(b, Fp.ONE)) {\r\n            if (Fp.eql(b, Fp.ZERO))\r\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\r\n            // Find m such b^(2^m)==1\r\n            let m = 1;\r\n            for (let t2 = Fp.sqr(b); m < r; m++) {\r\n                if (Fp.eql(t2, Fp.ONE))\r\n                    break;\r\n                t2 = Fp.sqr(t2); // t2 *= t2\r\n            }\r\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\r\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\r\n            g = Fp.sqr(ge); // g = ge * ge\r\n            x = Fp.mul(x, ge); // x *= ge\r\n            b = Fp.mul(b, g); // b *= g\r\n            r = m;\r\n        }\r\n        return x;\r\n    };\r\n}\r\nfunction FpSqrt(P) {\r\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\r\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\r\n    // P  3 (mod 4)\r\n    // n = n^((P+1)/4)\r\n    if (P % _4n === _3n) {\r\n        // Not all roots possible!\r\n        // const ORDER =\r\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\r\n        // const NUM = 72057594037927816n;\r\n        const p1div4 = (P + _1n) / _4n;\r\n        return function sqrt3mod4(Fp, n) {\r\n            const root = Fp.pow(n, p1div4);\r\n            // Throw if root**2 != n\r\n            if (!Fp.eql(Fp.sqr(root), n))\r\n                throw new Error('Cannot find square root');\r\n            return root;\r\n        };\r\n    }\r\n    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\r\n    if (P % _8n === _5n) {\r\n        const c1 = (P - _5n) / _8n;\r\n        return function sqrt5mod8(Fp, n) {\r\n            const n2 = Fp.mul(n, _2n);\r\n            const v = Fp.pow(n2, c1);\r\n            const nv = Fp.mul(n, v);\r\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\r\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\r\n            if (!Fp.eql(Fp.sqr(root), n))\r\n                throw new Error('Cannot find square root');\r\n            return root;\r\n        };\r\n    }\r\n    // P  9 (mod 16)\r\n    if (P % _16n === _9n) {\r\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\r\n        // Means we cannot use sqrt for constants at all!\r\n        //\r\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\r\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\r\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\r\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\r\n        // sqrt = (x) => {\r\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\r\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\r\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\r\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\r\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\r\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\r\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\r\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\r\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\r\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\r\n        // }\r\n    }\r\n    // Other cases: Tonelli-Shanks algorithm\r\n    return tonelliShanks(P);\r\n}\r\n// Little-endian check for first LE bit (last BE bit);\r\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\r\n// prettier-ignore\r\nconst FIELD_FIELDS = [\r\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\r\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\r\n    'addN', 'subN', 'mulN', 'sqrN'\r\n];\r\nfunction validateField(field) {\r\n    const initial = {\r\n        ORDER: 'bigint',\r\n        MASK: 'bigint',\r\n        BYTES: 'isSafeInteger',\r\n        BITS: 'isSafeInteger',\r\n    };\r\n    const opts = FIELD_FIELDS.reduce((map, val) => {\r\n        map[val] = 'function';\r\n        return map;\r\n    }, initial);\r\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\r\n}\r\n// Generic field functions\r\n/**\r\n * Same as `pow` but for Fp: non-constant-time.\r\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\r\n */\r\nfunction FpPow(f, num, power) {\r\n    // Should have same speed as pow for bigints\r\n    // TODO: benchmark!\r\n    if (power < _0n)\r\n        throw new Error('Expected power > 0');\r\n    if (power === _0n)\r\n        return f.ONE;\r\n    if (power === _1n)\r\n        return num;\r\n    let p = f.ONE;\r\n    let d = num;\r\n    while (power > _0n) {\r\n        if (power & _1n)\r\n            p = f.mul(p, d);\r\n        d = f.sqr(d);\r\n        power >>= _1n;\r\n    }\r\n    return p;\r\n}\r\n/**\r\n * Efficiently invert an array of Field elements.\r\n * `inv(0)` will return `undefined` here: make sure to throw an error.\r\n */\r\nfunction FpInvertBatch(f, nums) {\r\n    const tmp = new Array(nums.length);\r\n    // Walk from first to last, multiply them by each other MOD p\r\n    const lastMultiplied = nums.reduce((acc, num, i) => {\r\n        if (f.is0(num))\r\n            return acc;\r\n        tmp[i] = acc;\r\n        return f.mul(acc, num);\r\n    }, f.ONE);\r\n    // Invert last element\r\n    const inverted = f.inv(lastMultiplied);\r\n    // Walk from last to first, multiply them by inverted each other MOD p\r\n    nums.reduceRight((acc, num, i) => {\r\n        if (f.is0(num))\r\n            return acc;\r\n        tmp[i] = f.mul(acc, tmp[i]);\r\n        return f.mul(acc, num);\r\n    }, inverted);\r\n    return tmp;\r\n}\r\nfunction FpDiv(f, lhs, rhs) {\r\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\r\n}\r\n// This function returns True whenever the value x is a square in the field F.\r\nfunction FpIsSquare(f) {\r\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\r\n    return (x) => {\r\n        const p = f.pow(x, legendreConst);\r\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\r\n    };\r\n}\r\n// CURVE.n lengths\r\nfunction nLength(n, nBitLength) {\r\n    // Bit size, byte size of CURVE.n\r\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\r\n    const nByteLength = Math.ceil(_nBitLength / 8);\r\n    return { nBitLength: _nBitLength, nByteLength };\r\n}\r\n/**\r\n * Initializes a finite field over prime. **Non-primes are not supported.**\r\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\r\n * Major performance optimizations:\r\n * * a) denormalized operations like mulN instead of mul\r\n * * b) same object shape: never add or remove keys\r\n * * c) Object.freeze\r\n * @param ORDER prime positive bigint\r\n * @param bitLen how many bits the field consumes\r\n * @param isLE (def: false) if encoding / decoding should be in little-endian\r\n * @param redef optional faster redefinitions of sqrt and other methods\r\n */\r\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\r\n    if (ORDER <= _0n)\r\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\r\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\r\n    if (BYTES > 2048)\r\n        throw new Error('Field lengths over 2048 bytes are not supported');\r\n    const sqrtP = FpSqrt(ORDER);\r\n    const f = Object.freeze({\r\n        ORDER,\r\n        BITS,\r\n        BYTES,\r\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\r\n        ZERO: _0n,\r\n        ONE: _1n,\r\n        create: (num) => mod(num, ORDER),\r\n        isValid: (num) => {\r\n            if (typeof num !== 'bigint')\r\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\r\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\r\n        },\r\n        is0: (num) => num === _0n,\r\n        isOdd: (num) => (num & _1n) === _1n,\r\n        neg: (num) => mod(-num, ORDER),\r\n        eql: (lhs, rhs) => lhs === rhs,\r\n        sqr: (num) => mod(num * num, ORDER),\r\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\r\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\r\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\r\n        pow: (num, power) => FpPow(f, num, power),\r\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\r\n        // Same as above, but doesn't normalize\r\n        sqrN: (num) => num * num,\r\n        addN: (lhs, rhs) => lhs + rhs,\r\n        subN: (lhs, rhs) => lhs - rhs,\r\n        mulN: (lhs, rhs) => lhs * rhs,\r\n        inv: (num) => invert(num, ORDER),\r\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\r\n        invertBatch: (lst) => FpInvertBatch(f, lst),\r\n        // TODO: do we really need constant cmov?\r\n        // We don't have const-time bigints anyway, so probably will be not very useful\r\n        cmov: (a, b, c) => (c ? b : a),\r\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\r\n        fromBytes: (bytes) => {\r\n            if (bytes.length !== BYTES)\r\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\r\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\r\n        },\r\n    });\r\n    return Object.freeze(f);\r\n}\r\nfunction FpSqrtOdd(Fp, elm) {\r\n    if (!Fp.isOdd)\r\n        throw new Error(`Field doesn't have isOdd`);\r\n    const root = Fp.sqrt(elm);\r\n    return Fp.isOdd(root) ? root : Fp.neg(root);\r\n}\r\nfunction FpSqrtEven(Fp, elm) {\r\n    if (!Fp.isOdd)\r\n        throw new Error(`Field doesn't have isOdd`);\r\n    const root = Fp.sqrt(elm);\r\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\r\n}\r\n/**\r\n * \"Constant-time\" private key generation utility.\r\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\r\n * Which makes it slightly more biased, less secure.\r\n * @deprecated use mapKeyToField instead\r\n */\r\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\r\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\r\n    const hashLen = hash.length;\r\n    const minLen = nLength(groupOrder).nByteLength + 8;\r\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\r\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\r\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\r\n    return mod(num, groupOrder - _1n) + _1n;\r\n}\r\n/**\r\n * Returns total number of bytes consumed by the field element.\r\n * For example, 32 bytes for usual 256-bit weierstrass curve.\r\n * @param fieldOrder number of field elements, usually CURVE.n\r\n * @returns byte length of field\r\n */\r\nfunction getFieldBytesLength(fieldOrder) {\r\n    if (typeof fieldOrder !== 'bigint')\r\n        throw new Error('field order must be bigint');\r\n    const bitLength = fieldOrder.toString(2).length;\r\n    return Math.ceil(bitLength / 8);\r\n}\r\n/**\r\n * Returns minimal amount of bytes that can be safely reduced\r\n * by field order.\r\n * Should be 2^-128 for 128-bit curve such as P256.\r\n * @param fieldOrder number of field elements, usually CURVE.n\r\n * @returns byte length of target hash\r\n */\r\nfunction getMinHashLength(fieldOrder) {\r\n    const length = getFieldBytesLength(fieldOrder);\r\n    return length + Math.ceil(length / 2);\r\n}\r\n/**\r\n * \"Constant-time\" private key generation utility.\r\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\r\n * and convert them into private scalar, with the modulo bias being negligible.\r\n * Needs at least 48 bytes of input for 32-byte private key.\r\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\r\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\r\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\r\n * @param hash hash output from SHA3 or a similar function\r\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\r\n * @param isLE interpret hash bytes as LE num\r\n * @returns valid private scalar\r\n */\r\nfunction mapHashToField(key, fieldOrder, isLE = false) {\r\n    const len = key.length;\r\n    const fieldLen = getFieldBytesLength(fieldOrder);\r\n    const minLen = getMinHashLength(fieldOrder);\r\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\r\n    if (len < 16 || len < minLen || len > 1024)\r\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\r\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\r\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\r\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\r\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\r\n}\r\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDdUk7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHFFQUFxRSxRQUFRLE1BQU0sT0FBTztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBMkM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsbUNBQW1DO0FBQ25DLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsNEJBQTRCO0FBQzVCLCtC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QUFvQyxPQUFPLDRCQUE0QixJQUFJO0FBQzNFLHVCQUF1QiwwREFBZSxRQUFRLDBEQUFlO0FBQzdEO0FBQ0E7QUFDQSxrQkFBa0IsMERBQWUsc0JBQXNCLDBEQUFlO0FBQ3RFO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXEBub2JsZVxcY3VydmVzXFxlc21cXGFic3RyYWN0XFxtb2R1bGFyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cclxuLy8gVXRpbGl0aWVzIGZvciBtb2R1bGFyIGFyaXRobWV0aWNzIGFuZCBmaW5pdGUgZmllbGRzXHJcbmltcG9ydCB7IGJpdE1hc2ssIG51bWJlclRvQnl0ZXNCRSwgbnVtYmVyVG9CeXRlc0xFLCBieXRlc1RvTnVtYmVyQkUsIGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIHZhbGlkYXRlT2JqZWN0LCB9IGZyb20gJy4vdXRpbHMuanMnO1xyXG4vLyBwcmV0dGllci1pZ25vcmVcclxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpO1xyXG4vLyBwcmV0dGllci1pZ25vcmVcclxuY29uc3QgXzRuID0gQmlnSW50KDQpLCBfNW4gPSBCaWdJbnQoNSksIF84biA9IEJpZ0ludCg4KTtcclxuLy8gcHJldHRpZXItaWdub3JlXHJcbmNvbnN0IF85biA9IEJpZ0ludCg5KSwgXzE2biA9IEJpZ0ludCgxNik7XHJcbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxyXG5leHBvcnQgZnVuY3Rpb24gbW9kKGEsIGIpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xyXG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXHJcbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cclxuICogQGV4YW1wbGVcclxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cclxuICovXHJcbi8vIFRPRE86IHVzZSBmaWVsZCB2ZXJzaW9uICYmIHJlbW92ZVxyXG5leHBvcnQgZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xyXG4gICAgaWYgKG1vZHVsbyA8PSBfMG4gfHwgcG93ZXIgPCBfMG4pXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlci9tb2R1bG8gPiAwJyk7XHJcbiAgICBpZiAobW9kdWxvID09PSBfMW4pXHJcbiAgICAgICAgcmV0dXJuIF8wbjtcclxuICAgIGxldCByZXMgPSBfMW47XHJcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcclxuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXHJcbiAgICAgICAgICAgIHJlcyA9IChyZXMgKiBudW0pICUgbW9kdWxvO1xyXG4gICAgICAgIG51bSA9IChudW0gKiBudW0pICUgbW9kdWxvO1xyXG4gICAgICAgIHBvd2VyID4+PSBfMW47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbi8vIERvZXMgeCBeICgyIF4gcG93ZXIpIG1vZCBwLiBwb3cyKDMwLCA0KSA9PSAzMCBeICgyIF4gNClcclxuZXhwb3J0IGZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIsIG1vZHVsbykge1xyXG4gICAgbGV0IHJlcyA9IHg7XHJcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xyXG4gICAgICAgIHJlcyAqPSByZXM7XHJcbiAgICAgICAgcmVzICU9IG1vZHVsbztcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuLy8gSW52ZXJzZXMgbnVtYmVyIG92ZXIgbW9kdWxvXHJcbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcclxuICAgIGlmIChudW1iZXIgPT09IF8wbiB8fCBtb2R1bG8gPD0gXzBuKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJzLCBnb3Qgbj0ke251bWJlcn0gbW9kPSR7bW9kdWxvfWApO1xyXG4gICAgfVxyXG4gICAgLy8gRXVjbGlkZWFuIEdDRCBodHRwczovL2JyaWxsaWFudC5vcmcvd2lraS9leHRlbmRlZC1ldWNsaWRlYW4tYWxnb3JpdGhtL1xyXG4gICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXHJcbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XHJcbiAgICBsZXQgYiA9IG1vZHVsbztcclxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxyXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XHJcbiAgICB3aGlsZSAoYSAhPT0gXzBuKSB7XHJcbiAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcclxuICAgICAgICBjb25zdCByID0gYiAlIGE7XHJcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcclxuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xyXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxyXG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XHJcbiAgICB9XHJcbiAgICBjb25zdCBnY2QgPSBiO1xyXG4gICAgaWYgKGdjZCAhPT0gXzFuKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xyXG4gICAgcmV0dXJuIG1vZCh4LCBtb2R1bG8pO1xyXG59XHJcbi8qKlxyXG4gKiBUb25lbGxpLVNoYW5rcyBzcXVhcmUgcm9vdCBzZWFyY2ggYWxnb3JpdGhtLlxyXG4gKiAxLiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTIpXHJcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xyXG4gKiBXaWxsIHN0YXJ0IGFuIGluZmluaXRlIGxvb3AgaWYgZmllbGQgb3JkZXIgUCBpcyBub3QgcHJpbWUuXHJcbiAqIEBwYXJhbSBQIGZpZWxkIG9yZGVyXHJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b25lbGxpU2hhbmtzKFApIHtcclxuICAgIC8vIExlZ2VuZHJlIGNvbnN0YW50OiB1c2VkIHRvIGNhbGN1bGF0ZSBMZWdlbmRyZSBzeW1ib2wgKGEgfCBwKSxcclxuICAgIC8vIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXHJcbiAgICAvLyAoYSB8IHApIOKJoSAxICAgIGlmIGEgaXMgYSBzcXVhcmUgKG1vZCBwKVxyXG4gICAgLy8gKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApXHJcbiAgICAvLyAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxyXG4gICAgY29uc3QgbGVnZW5kcmVDID0gKFAgLSBfMW4pIC8gXzJuO1xyXG4gICAgbGV0IFEsIFMsIFo7XHJcbiAgICAvLyBTdGVwIDE6IEJ5IGZhY3RvcmluZyBvdXQgcG93ZXJzIG9mIDIgZnJvbSBwIC0gMSxcclxuICAgIC8vIGZpbmQgcSBhbmQgcyBzdWNoIHRoYXQgcCAtIDEgPSBxKigyXnMpIHdpdGggcSBvZGRcclxuICAgIGZvciAoUSA9IFAgLSBfMW4sIFMgPSAwOyBRICUgXzJuID09PSBfMG47IFEgLz0gXzJuLCBTKyspXHJcbiAgICAgICAgO1xyXG4gICAgLy8gU3RlcCAyOiBTZWxlY3QgYSBub24tc3F1YXJlIHogc3VjaCB0aGF0ICh6IHwgcCkg4omhIC0xIGFuZCBzZXQgYyDiiaEgenFcclxuICAgIGZvciAoWiA9IF8ybjsgWiA8IFAgJiYgcG93KFosIGxlZ2VuZHJlQywgUCkgIT09IFAgLSBfMW47IForKylcclxuICAgICAgICA7XHJcbiAgICAvLyBGYXN0LXBhdGhcclxuICAgIGlmIChTID09PSAxKSB7XHJcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpRmFzdChGcCwgbikge1xyXG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XHJcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XHJcbiAgICAgICAgICAgIHJldHVybiByb290O1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBTbG93LXBhdGhcclxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcclxuICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpU2xvdyhGcCwgbikge1xyXG4gICAgICAgIC8vIFN0ZXAgMDogQ2hlY2sgdGhhdCBuIGlzIGluZGVlZCBhIHNxdWFyZTogKG4gfCBwKSBzaG91bGQgbm90IGJlIOKJoSAtMVxyXG4gICAgICAgIGlmIChGcC5wb3cobiwgbGVnZW5kcmVDKSA9PT0gRnAubmVnKEZwLk9ORSkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcclxuICAgICAgICBsZXQgciA9IFM7XHJcbiAgICAgICAgLy8gVE9ETzogd2lsbCBmYWlsIGF0IEZwMi9ldGNcclxuICAgICAgICBsZXQgZyA9IEZwLnBvdyhGcC5tdWwoRnAuT05FLCBaKSwgUSk7IC8vIHdpbGwgdXBkYXRlIGJvdGggeCBhbmQgYlxyXG4gICAgICAgIGxldCB4ID0gRnAucG93KG4sIFExZGl2Mik7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBzcXVhcmUgcm9vdFxyXG4gICAgICAgIGxldCBiID0gRnAucG93KG4sIFEpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXHJcbiAgICAgICAgd2hpbGUgKCFGcC5lcWwoYiwgRnAuT05FKSkge1xyXG4gICAgICAgICAgICBpZiAoRnAuZXFsKGIsIEZwLlpFUk8pKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwLlpFUk87IC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvbmVsbGklRTIlODAlOTNTaGFua3NfYWxnb3JpdGhtICg0LiBJZiB0ID0gMCwgcmV0dXJuIHIgPSAwKVxyXG4gICAgICAgICAgICAvLyBGaW5kIG0gc3VjaCBiXigyXm0pPT0xXHJcbiAgICAgICAgICAgIGxldCBtID0gMTtcclxuICAgICAgICAgICAgZm9yIChsZXQgdDIgPSBGcC5zcXIoYik7IG0gPCByOyBtKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChGcC5lcWwodDIsIEZwLk9ORSkpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB0MiA9IEZwLnNxcih0Mik7IC8vIHQyICo9IHQyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTk9URTogci1tLTEgY2FuIGJlIGJpZ2dlciB0aGFuIDMyLCBuZWVkIHRvIGNvbnZlcnQgdG8gYmlnaW50IGJlZm9yZSBzaGlmdCwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmUgb3ZlcmZsb3dcclxuICAgICAgICAgICAgY29uc3QgZ2UgPSBGcC5wb3coZywgXzFuIDw8IEJpZ0ludChyIC0gbSAtIDEpKTsgLy8gZ2UgPSAyXihyLW0tMSlcclxuICAgICAgICAgICAgZyA9IEZwLnNxcihnZSk7IC8vIGcgPSBnZSAqIGdlXHJcbiAgICAgICAgICAgIHggPSBGcC5tdWwoeCwgZ2UpOyAvLyB4ICo9IGdlXHJcbiAgICAgICAgICAgIGIgPSBGcC5tdWwoYiwgZyk7IC8vIGIgKj0gZ1xyXG4gICAgICAgICAgICByID0gbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnQoUCkge1xyXG4gICAgLy8gTk9URTogZGlmZmVyZW50IGFsZ29yaXRobXMgY2FuIGdpdmUgZGlmZmVyZW50IHJvb3RzLCBpdCBpcyB1cCB0byB1c2VyIHRvIGRlY2lkZSB3aGljaCBvbmUgdGhleSB3YW50LlxyXG4gICAgLy8gRm9yIGV4YW1wbGUgdGhlcmUgaXMgRnBTcXJ0T2RkL0ZwU3FydEV2ZW4gdG8gY2hvaWNlIHJvb3QgYmFzZWQgb24gb2RkbmVzcyAodXNlZCBmb3IgaGFzaC10by1jdXJ2ZSkuXHJcbiAgICAvLyBQIOKJoSAzIChtb2QgNClcclxuICAgIC8vIOKImm4gPSBuXigoUCsxKS80KVxyXG4gICAgaWYgKFAgJSBfNG4gPT09IF8zbikge1xyXG4gICAgICAgIC8vIE5vdCBhbGwgcm9vdHMgcG9zc2libGUhXHJcbiAgICAgICAgLy8gY29uc3QgT1JERVIgPVxyXG4gICAgICAgIC8vICAgMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJuO1xyXG4gICAgICAgIC8vIGNvbnN0IE5VTSA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcclxuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQzbW9kNChGcCwgbikge1xyXG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XHJcbiAgICAgICAgICAgIC8vIFRocm93IGlmIHJvb3QqKjIgIT0gblxyXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xyXG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gQXRraW4gYWxnb3JpdGhtIGZvciBxIOKJoSA1IChtb2QgOCksIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMClcclxuICAgIGlmIChQICUgXzhuID09PSBfNW4pIHtcclxuICAgICAgICBjb25zdCBjMSA9IChQIC0gXzVuKSAvIF84bjtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDVtb2Q4KEZwLCBuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4yID0gRnAubXVsKG4sIF8ybik7XHJcbiAgICAgICAgICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIGMxKTtcclxuICAgICAgICAgICAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XHJcbiAgICAgICAgICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcclxuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xyXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xyXG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gUCDiiaEgOSAobW9kIDE2KVxyXG4gICAgaWYgKFAgJSBfMTZuID09PSBfOW4pIHtcclxuICAgICAgICAvLyBOT1RFOiB0b25lbGxpIGlzIHRvbyBzbG93IGZvciBibHMtRnAyIGNhbGN1bGF0aW9ucyBldmVuIG9uIHN0YXJ0XHJcbiAgICAgICAgLy8gTWVhbnMgd2UgY2Fubm90IHVzZSBzcXJ0IGZvciBjb25zdGFudHMgYXQgYWxsIVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gY29uc3QgYzEgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShGcC5PTkUpKTsgLy8gIDEuIGMxID0gc3FydCgtMSkgaW4gRiwgaS5lLiwgKGMxXjIpID09IC0xIGluIEZcclxuICAgICAgICAvLyBjb25zdCBjMiA9IEZwLnNxcnQoYzEpOyAgICAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxyXG4gICAgICAgIC8vIGNvbnN0IGMzID0gRnAuc3FydChGcC5uZWdhdGUoYzEpKTsgICAgIC8vICAzLiBjMyA9IHNxcnQoLWMxKSBpbiBGLCBpLmUuLCAoYzNeMikgPT0gLWMxIGluIEZcclxuICAgICAgICAvLyBjb25zdCBjNCA9IChQICsgXzduKSAvIF8xNm47ICAgICAgICAgICAvLyAgNC4gYzQgPSAocSArIDcpIC8gMTYgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXHJcbiAgICAgICAgLy8gc3FydCA9ICh4KSA9PiB7XHJcbiAgICAgICAgLy8gICBsZXQgdHYxID0gRnAucG93KHgsIGM0KTsgICAgICAgICAgICAgLy8gIDEuIHR2MSA9IHheYzRcclxuICAgICAgICAvLyAgIGxldCB0djIgPSBGcC5tdWwoYzEsIHR2MSk7ICAgICAgICAgICAvLyAgMi4gdHYyID0gYzEgKiB0djFcclxuICAgICAgICAvLyAgIGNvbnN0IHR2MyA9IEZwLm11bChjMiwgdHYxKTsgICAgICAgICAvLyAgMy4gdHYzID0gYzIgKiB0djFcclxuICAgICAgICAvLyAgIGxldCB0djQgPSBGcC5tdWwoYzMsIHR2MSk7ICAgICAgICAgICAvLyAgNC4gdHY0ID0gYzMgKiB0djFcclxuICAgICAgICAvLyAgIGNvbnN0IGUxID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDUuICBlMSA9ICh0djJeMikgPT0geFxyXG4gICAgICAgIC8vICAgY29uc3QgZTIgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MyksIHgpOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XHJcbiAgICAgICAgLy8gICB0djEgPSBGcC5jbW92KHR2MSwgdHYyLCBlMSk7IC8vICA3LiB0djEgPSBDTU9WKHR2MSwgdHYyLCBlMSkgICMgU2VsZWN0IHR2MiBpZiAodHYyXjIpID09IHhcclxuICAgICAgICAvLyAgIHR2MiA9IEZwLmNtb3YodHY0LCB0djMsIGUyKTsgLy8gIDguIHR2MiA9IENNT1YodHY0LCB0djMsIGUyKSAgIyBTZWxlY3QgdHYzIGlmICh0djNeMikgPT0geFxyXG4gICAgICAgIC8vICAgY29uc3QgZTMgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XHJcbiAgICAgICAgLy8gICByZXR1cm4gRnAuY21vdih0djEsIHR2MiwgZTMpOyAvLyAgMTAuICB6ID0gQ01PVih0djEsIHR2MiwgZTMpICAjIFNlbGVjdCB0aGUgc3FydCBmcm9tIHR2MSBhbmQgdHYyXHJcbiAgICAgICAgLy8gfVxyXG4gICAgfVxyXG4gICAgLy8gT3RoZXIgY2FzZXM6IFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxyXG4gICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XHJcbn1cclxuLy8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XHJcbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xyXG4vLyBwcmV0dGllci1pZ25vcmVcclxuY29uc3QgRklFTERfRklFTERTID0gW1xyXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcclxuICAgICdlcWwnLCAnYWRkJywgJ3N1YicsICdtdWwnLCAncG93JywgJ2RpdicsXHJcbiAgICAnYWRkTicsICdzdWJOJywgJ211bE4nLCAnc3FyTidcclxuXTtcclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcclxuICAgIGNvbnN0IGluaXRpYWwgPSB7XHJcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxyXG4gICAgICAgIE1BU0s6ICdiaWdpbnQnLFxyXG4gICAgICAgIEJZVEVTOiAnaXNTYWZlSW50ZWdlcicsXHJcbiAgICAgICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxyXG4gICAgfTtcclxuICAgIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xyXG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcclxuICAgICAgICByZXR1cm4gbWFwO1xyXG4gICAgfSwgaW5pdGlhbCk7XHJcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoZmllbGQsIG9wdHMpO1xyXG59XHJcbi8vIEdlbmVyaWMgZmllbGQgZnVuY3Rpb25zXHJcbi8qKlxyXG4gKiBTYW1lIGFzIGBwb3dgIGJ1dCBmb3IgRnA6IG5vbi1jb25zdGFudC10aW1lLlxyXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gRnBQb3coZiwgbnVtLCBwb3dlcikge1xyXG4gICAgLy8gU2hvdWxkIGhhdmUgc2FtZSBzcGVlZCBhcyBwb3cgZm9yIGJpZ2ludHNcclxuICAgIC8vIFRPRE86IGJlbmNobWFyayFcclxuICAgIGlmIChwb3dlciA8IF8wbilcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyID4gMCcpO1xyXG4gICAgaWYgKHBvd2VyID09PSBfMG4pXHJcbiAgICAgICAgcmV0dXJuIGYuT05FO1xyXG4gICAgaWYgKHBvd2VyID09PSBfMW4pXHJcbiAgICAgICAgcmV0dXJuIG51bTtcclxuICAgIGxldCBwID0gZi5PTkU7XHJcbiAgICBsZXQgZCA9IG51bTtcclxuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xyXG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcclxuICAgICAgICAgICAgcCA9IGYubXVsKHAsIGQpO1xyXG4gICAgICAgIGQgPSBmLnNxcihkKTtcclxuICAgICAgICBwb3dlciA+Pj0gXzFuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHA7XHJcbn1cclxuLyoqXHJcbiAqIEVmZmljaWVudGx5IGludmVydCBhbiBhcnJheSBvZiBGaWVsZCBlbGVtZW50cy5cclxuICogYGludigwKWAgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaGVyZTogbWFrZSBzdXJlIHRvIHRocm93IGFuIGVycm9yLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goZiwgbnVtcykge1xyXG4gICAgY29uc3QgdG1wID0gbmV3IEFycmF5KG51bXMubGVuZ3RoKTtcclxuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcclxuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XHJcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXHJcbiAgICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgdG1wW2ldID0gYWNjO1xyXG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XHJcbiAgICB9LCBmLk9ORSk7XHJcbiAgICAvLyBJbnZlcnQgbGFzdCBlbGVtZW50XHJcbiAgICBjb25zdCBpbnZlcnRlZCA9IGYuaW52KGxhc3RNdWx0aXBsaWVkKTtcclxuICAgIC8vIFdhbGsgZnJvbSBsYXN0IHRvIGZpcnN0LCBtdWx0aXBseSB0aGVtIGJ5IGludmVydGVkIGVhY2ggb3RoZXIgTU9EIHBcclxuICAgIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XHJcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXHJcbiAgICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgdG1wW2ldID0gZi5tdWwoYWNjLCB0bXBbaV0pO1xyXG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XHJcbiAgICB9LCBpbnZlcnRlZCk7XHJcbiAgICByZXR1cm4gdG1wO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBGcERpdihmLCBsaHMsIHJocykge1xyXG4gICAgcmV0dXJuIGYubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBmLk9SREVSKSA6IGYuaW52KHJocykpO1xyXG59XHJcbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBUcnVlIHdoZW5ldmVyIHRoZSB2YWx1ZSB4IGlzIGEgc3F1YXJlIGluIHRoZSBmaWVsZCBGLlxyXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZShmKSB7XHJcbiAgICBjb25zdCBsZWdlbmRyZUNvbnN0ID0gKGYuT1JERVIgLSBfMW4pIC8gXzJuOyAvLyBJbnRlZ2VyIGFyaXRobWV0aWNcclxuICAgIHJldHVybiAoeCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHAgPSBmLnBvdyh4LCBsZWdlbmRyZUNvbnN0KTtcclxuICAgICAgICByZXR1cm4gZi5lcWwocCwgZi5aRVJPKSB8fCBmLmVxbChwLCBmLk9ORSk7XHJcbiAgICB9O1xyXG59XHJcbi8vIENVUlZFLm4gbGVuZ3Roc1xyXG5leHBvcnQgZnVuY3Rpb24gbkxlbmd0aChuLCBuQml0TGVuZ3RoKSB7XHJcbiAgICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cclxuICAgIGNvbnN0IF9uQml0TGVuZ3RoID0gbkJpdExlbmd0aCAhPT0gdW5kZWZpbmVkID8gbkJpdExlbmd0aCA6IG4udG9TdHJpbmcoMikubGVuZ3RoO1xyXG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcclxuICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xyXG59XHJcbi8qKlxyXG4gKiBJbml0aWFsaXplcyBhIGZpbml0ZSBmaWVsZCBvdmVyIHByaW1lLiAqKk5vbi1wcmltZXMgYXJlIG5vdCBzdXBwb3J0ZWQuKipcclxuICogRG8gbm90IGluaXQgaW4gbG9vcDogc2xvdy4gVmVyeSBmcmFnaWxlOiBhbHdheXMgcnVuIGEgYmVuY2htYXJrIG9uIGEgY2hhbmdlLlxyXG4gKiBNYWpvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zOlxyXG4gKiAqIGEpIGRlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxyXG4gKiAqIGIpIHNhbWUgb2JqZWN0IHNoYXBlOiBuZXZlciBhZGQgb3IgcmVtb3ZlIGtleXNcclxuICogKiBjKSBPYmplY3QuZnJlZXplXHJcbiAqIEBwYXJhbSBPUkRFUiBwcmltZSBwb3NpdGl2ZSBiaWdpbnRcclxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xyXG4gKiBAcGFyYW0gaXNMRSAoZGVmOiBmYWxzZSkgaWYgZW5jb2RpbmcgLyBkZWNvZGluZyBzaG91bGQgYmUgaW4gbGl0dGxlLWVuZGlhblxyXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEZpZWxkKE9SREVSLCBiaXRMZW4sIGlzTEUgPSBmYWxzZSwgcmVkZWYgPSB7fSkge1xyXG4gICAgaWYgKE9SREVSIDw9IF8wbilcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIEZpZWxkIE9SREVSID4gMCwgZ290ICR7T1JERVJ9YCk7XHJcbiAgICBjb25zdCB7IG5CaXRMZW5ndGg6IEJJVFMsIG5CeXRlTGVuZ3RoOiBCWVRFUyB9ID0gbkxlbmd0aChPUkRFUiwgYml0TGVuKTtcclxuICAgIGlmIChCWVRFUyA+IDIwNDgpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZCBsZW5ndGhzIG92ZXIgMjA0OCBieXRlcyBhcmUgbm90IHN1cHBvcnRlZCcpO1xyXG4gICAgY29uc3Qgc3FydFAgPSBGcFNxcnQoT1JERVIpO1xyXG4gICAgY29uc3QgZiA9IE9iamVjdC5mcmVlemUoe1xyXG4gICAgICAgIE9SREVSLFxyXG4gICAgICAgIEJJVFMsXHJcbiAgICAgICAgQllURVMsXHJcbiAgICAgICAgTUFTSzogYml0TWFzayhCSVRTKSxcclxuICAgICAgICBaRVJPOiBfMG4sXHJcbiAgICAgICAgT05FOiBfMW4sXHJcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBtb2QobnVtLCBPUkRFUiksXHJcbiAgICAgICAgaXNWYWxpZDogKG51bSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmllbGQgZWxlbWVudDogZXhwZWN0ZWQgYmlnaW50LCBnb3QgJHt0eXBlb2YgbnVtfWApO1xyXG4gICAgICAgICAgICByZXR1cm4gXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXMwOiAobnVtKSA9PiBudW0gPT09IF8wbixcclxuICAgICAgICBpc09kZDogKG51bSkgPT4gKG51bSAmIF8xbikgPT09IF8xbixcclxuICAgICAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXHJcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxyXG4gICAgICAgIHNxcjogKG51bSkgPT4gbW9kKG51bSAqIG51bSwgT1JERVIpLFxyXG4gICAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXHJcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcclxuICAgICAgICBtdWw6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIHJocywgT1JERVIpLFxyXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IEZwUG93KGYsIG51bSwgcG93ZXIpLFxyXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXHJcbiAgICAgICAgLy8gU2FtZSBhcyBhYm92ZSwgYnV0IGRvZXNuJ3Qgbm9ybWFsaXplXHJcbiAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxyXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxyXG4gICAgICAgIHN1Yk46IChsaHMsIHJocykgPT4gbGhzIC0gcmhzLFxyXG4gICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxyXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxyXG4gICAgICAgIHNxcnQ6IHJlZGVmLnNxcnQgfHwgKChuKSA9PiBzcXJ0UChmLCBuKSksXHJcbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcclxuICAgICAgICAvLyBUT0RPOiBkbyB3ZSByZWFsbHkgbmVlZCBjb25zdGFudCBjbW92P1xyXG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgY29uc3QtdGltZSBiaWdpbnRzIGFueXdheSwgc28gcHJvYmFibHkgd2lsbCBiZSBub3QgdmVyeSB1c2VmdWxcclxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXHJcbiAgICAgICAgdG9CeXRlczogKG51bSkgPT4gKGlzTEUgPyBudW1iZXJUb0J5dGVzTEUobnVtLCBCWVRFUykgOiBudW1iZXJUb0J5dGVzQkUobnVtLCBCWVRFUykpLFxyXG4gICAgICAgIGZyb21CeXRlczogKGJ5dGVzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGcC5mcm9tQnl0ZXM6IGV4cGVjdGVkICR7QllURVN9LCBnb3QgJHtieXRlcy5sZW5ndGh9YCk7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0xFID8gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSA6IGJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoZik7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydE9kZChGcCwgZWxtKSB7XHJcbiAgICBpZiAoIUZwLmlzT2RkKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XHJcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xyXG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gcm9vdCA6IEZwLm5lZyhyb290KTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XHJcbiAgICBpZiAoIUZwLmlzT2RkKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XHJcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xyXG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcclxufVxyXG4vKipcclxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxyXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxyXG4gKiBXaGljaCBtYWtlcyBpdCBzbGlnaHRseSBtb3JlIGJpYXNlZCwgbGVzcyBzZWN1cmUuXHJcbiAqIEBkZXByZWNhdGVkIHVzZSBtYXBLZXlUb0ZpZWxkIGluc3RlYWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKGhhc2gsIGdyb3VwT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xyXG4gICAgaGFzaCA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlSGFzaCcsIGhhc2gpO1xyXG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xyXG4gICAgY29uc3QgbWluTGVuID0gbkxlbmd0aChncm91cE9yZGVyKS5uQnl0ZUxlbmd0aCArIDg7XHJcbiAgICBpZiAobWluTGVuIDwgMjQgfHwgaGFzaExlbiA8IG1pbkxlbiB8fCBoYXNoTGVuID4gMTAyNClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtoYXNoTGVufWApO1xyXG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShoYXNoKSA6IGJ5dGVzVG9OdW1iZXJCRShoYXNoKTtcclxuICAgIHJldHVybiBtb2QobnVtLCBncm91cE9yZGVyIC0gXzFuKSArIF8xbjtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgY29uc3VtZWQgYnkgdGhlIGZpZWxkIGVsZW1lbnQuXHJcbiAqIEZvciBleGFtcGxlLCAzMiBieXRlcyBmb3IgdXN1YWwgMjU2LWJpdCB3ZWllcnN0cmFzcyBjdXJ2ZS5cclxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cclxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgZmllbGRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpIHtcclxuICAgIGlmICh0eXBlb2YgZmllbGRPcmRlciAhPT0gJ2JpZ2ludCcpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludCcpO1xyXG4gICAgY29uc3QgYml0TGVuZ3RoID0gZmllbGRPcmRlci50b1N0cmluZygyKS5sZW5ndGg7XHJcbiAgICByZXR1cm4gTWF0aC5jZWlsKGJpdExlbmd0aCAvIDgpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIG1pbmltYWwgYW1vdW50IG9mIGJ5dGVzIHRoYXQgY2FuIGJlIHNhZmVseSByZWR1Y2VkXHJcbiAqIGJ5IGZpZWxkIG9yZGVyLlxyXG4gKiBTaG91bGQgYmUgMl4tMTI4IGZvciAxMjgtYml0IGN1cnZlIHN1Y2ggYXMgUDI1Ni5cclxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cclxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpIHtcclxuICAgIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XHJcbiAgICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xyXG59XHJcbi8qKlxyXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXHJcbiAqIENhbiB0YWtlIChuICsgbi8yKSBvciBtb3JlIGJ5dGVzIG9mIHVuaWZvcm0gaW5wdXQgZS5nLiBmcm9tIENTUFJORyBvciBLREZcclxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxyXG4gKiBOZWVkcyBhdCBsZWFzdCA0OCBieXRlcyBvZiBpbnB1dCBmb3IgMzItYnl0ZSBwcml2YXRlIGtleS5cclxuICogaHR0cHM6Ly9yZXNlYXJjaC5rdWRlbHNraXNlY3VyaXR5LmNvbS8yMDIwLzA3LzI4L3RoZS1kZWZpbml0aXZlLWd1aWRlLXRvLW1vZHVsby1iaWFzLWFuZC1ob3ctdG8tYXZvaWQtaXQvXHJcbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXHJcbiAqIFJGQyA5MzgwLCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTVcclxuICogQHBhcmFtIGhhc2ggaGFzaCBvdXRwdXQgZnJvbSBTSEEzIG9yIGEgc2ltaWxhciBmdW5jdGlvblxyXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXHJcbiAqIEBwYXJhbSBpc0xFIGludGVycHJldCBoYXNoIGJ5dGVzIGFzIExFIG51bVxyXG4gKiBAcmV0dXJucyB2YWxpZCBwcml2YXRlIHNjYWxhclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1hcEhhc2hUb0ZpZWxkKGtleSwgZmllbGRPcmRlciwgaXNMRSA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBsZW4gPSBrZXkubGVuZ3RoO1xyXG4gICAgY29uc3QgZmllbGRMZW4gPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xyXG4gICAgY29uc3QgbWluTGVuID0gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKTtcclxuICAgIC8vIE5vIHNtYWxsIG51bWJlcnM6IG5lZWQgdG8gdW5kZXJzdGFuZCBiaWFzIHN0b3J5LiBObyBodWdlIG51bWJlcnM6IGVhc2llciB0byBkZXRlY3QgSlMgdGltaW5ncy5cclxuICAgIGlmIChsZW4gPCAxNiB8fCBsZW4gPCBtaW5MZW4gfHwgbGVuID4gMTAyNClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtsZW59YCk7XHJcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckJFKGtleSkgOiBieXRlc1RvTnVtYmVyTEUoa2V5KTtcclxuICAgIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcclxuICAgIGNvbnN0IHJlZHVjZWQgPSBtb2QobnVtLCBmaWVsZE9yZGVyIC0gXzFuKSArIF8xbjtcclxuICAgIHJldHVybiBpc0xFID8gbnVtYmVyVG9CeXRlc0xFKHJlZHVjZWQsIGZpZWxkTGVuKSA6IG51bWJlclRvQnl0ZXNCRShyZWR1Y2VkLCBmaWVsZExlbik7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxhci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\r\n// This is OK: `abstract` directory does not use noble-hashes.\r\n// User may opt-in into using different hashing library. This way, noble-hashes\r\n// won't be included into their bundle.\r\nconst _0n = BigInt(0);\r\nconst _1n = BigInt(1);\r\nconst _2n = BigInt(2);\r\nconst u8a = (a) => a instanceof Uint8Array;\r\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\r\n/**\r\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\r\n */\r\nfunction bytesToHex(bytes) {\r\n    if (!u8a(bytes))\r\n        throw new Error('Uint8Array expected');\r\n    // pre-caching improves the speed 6x\r\n    let hex = '';\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        hex += hexes[bytes[i]];\r\n    }\r\n    return hex;\r\n}\r\nfunction numberToHexUnpadded(num) {\r\n    const hex = num.toString(16);\r\n    return hex.length & 1 ? `0${hex}` : hex;\r\n}\r\nfunction hexToNumber(hex) {\r\n    if (typeof hex !== 'string')\r\n        throw new Error('hex string expected, got ' + typeof hex);\r\n    // Big Endian\r\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\r\n}\r\n/**\r\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\r\n */\r\nfunction hexToBytes(hex) {\r\n    if (typeof hex !== 'string')\r\n        throw new Error('hex string expected, got ' + typeof hex);\r\n    const len = hex.length;\r\n    if (len % 2)\r\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\r\n    const array = new Uint8Array(len / 2);\r\n    for (let i = 0; i < array.length; i++) {\r\n        const j = i * 2;\r\n        const hexByte = hex.slice(j, j + 2);\r\n        const byte = Number.parseInt(hexByte, 16);\r\n        if (Number.isNaN(byte) || byte < 0)\r\n            throw new Error('Invalid byte sequence');\r\n        array[i] = byte;\r\n    }\r\n    return array;\r\n}\r\n// BE: Big Endian, LE: Little Endian\r\nfunction bytesToNumberBE(bytes) {\r\n    return hexToNumber(bytesToHex(bytes));\r\n}\r\nfunction bytesToNumberLE(bytes) {\r\n    if (!u8a(bytes))\r\n        throw new Error('Uint8Array expected');\r\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\r\n}\r\nfunction numberToBytesBE(n, len) {\r\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\r\n}\r\nfunction numberToBytesLE(n, len) {\r\n    return numberToBytesBE(n, len).reverse();\r\n}\r\n// Unpadded, rarely used\r\nfunction numberToVarBytesBE(n) {\r\n    return hexToBytes(numberToHexUnpadded(n));\r\n}\r\n/**\r\n * Takes hex string or Uint8Array, converts to Uint8Array.\r\n * Validates output length.\r\n * Will throw error for other types.\r\n * @param title descriptive title for an error e.g. 'private key'\r\n * @param hex hex string or Uint8Array\r\n * @param expectedLength optional, will compare to result array's length\r\n * @returns\r\n */\r\nfunction ensureBytes(title, hex, expectedLength) {\r\n    let res;\r\n    if (typeof hex === 'string') {\r\n        try {\r\n            res = hexToBytes(hex);\r\n        }\r\n        catch (e) {\r\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\r\n        }\r\n    }\r\n    else if (u8a(hex)) {\r\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\r\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\r\n        res = Uint8Array.from(hex);\r\n    }\r\n    else {\r\n        throw new Error(`${title} must be hex string or Uint8Array`);\r\n    }\r\n    const len = res.length;\r\n    if (typeof expectedLength === 'number' && len !== expectedLength)\r\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\r\n    return res;\r\n}\r\n/**\r\n * Copies several Uint8Arrays into one.\r\n */\r\nfunction concatBytes(...arrays) {\r\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\r\n    let pad = 0; // walk through each item, ensure they have proper type\r\n    arrays.forEach((a) => {\r\n        if (!u8a(a))\r\n            throw new Error('Uint8Array expected');\r\n        r.set(a, pad);\r\n        pad += a.length;\r\n    });\r\n    return r;\r\n}\r\nfunction equalBytes(b1, b2) {\r\n    // We don't care about timing attacks here\r\n    if (b1.length !== b2.length)\r\n        return false;\r\n    for (let i = 0; i < b1.length; i++)\r\n        if (b1[i] !== b2[i])\r\n            return false;\r\n    return true;\r\n}\r\n/**\r\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\r\n */\r\nfunction utf8ToBytes(str) {\r\n    if (typeof str !== 'string')\r\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\r\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\r\n}\r\n// Bit operations\r\n/**\r\n * Calculates amount of bits in a bigint.\r\n * Same as `n.toString(2).length`\r\n */\r\nfunction bitLen(n) {\r\n    let len;\r\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\r\n        ;\r\n    return len;\r\n}\r\n/**\r\n * Gets single bit at position.\r\n * NOTE: first bit position is 0 (same as arrays)\r\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\r\n */\r\nfunction bitGet(n, pos) {\r\n    return (n >> BigInt(pos)) & _1n;\r\n}\r\n/**\r\n * Sets single bit at position.\r\n */\r\nconst bitSet = (n, pos, value) => {\r\n    return n | ((value ? _1n : _0n) << BigInt(pos));\r\n};\r\n/**\r\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\r\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\r\n */\r\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\r\n// DRBG\r\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\r\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\r\n/**\r\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\r\n * @returns function that will call DRBG until 2nd arg returns something meaningful\r\n * @example\r\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\r\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\r\n */\r\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\r\n    if (typeof hashLen !== 'number' || hashLen < 2)\r\n        throw new Error('hashLen must be a number');\r\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\r\n        throw new Error('qByteLen must be a number');\r\n    if (typeof hmacFn !== 'function')\r\n        throw new Error('hmacFn must be a function');\r\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\r\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\r\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\r\n    let i = 0; // Iterations counter, will throw when over 1000\r\n    const reset = () => {\r\n        v.fill(1);\r\n        k.fill(0);\r\n        i = 0;\r\n    };\r\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\r\n    const reseed = (seed = u8n()) => {\r\n        // HMAC-DRBG reseed() function. Steps D-G\r\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\r\n        v = h(); // v = hmac(k || v)\r\n        if (seed.length === 0)\r\n            return;\r\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\r\n        v = h(); // v = hmac(k || v)\r\n    };\r\n    const gen = () => {\r\n        // HMAC-DRBG generate() function\r\n        if (i++ >= 1000)\r\n            throw new Error('drbg: tried 1000 values');\r\n        let len = 0;\r\n        const out = [];\r\n        while (len < qByteLen) {\r\n            v = h();\r\n            const sl = v.slice();\r\n            out.push(sl);\r\n            len += v.length;\r\n        }\r\n        return concatBytes(...out);\r\n    };\r\n    const genUntil = (seed, pred) => {\r\n        reset();\r\n        reseed(seed); // Steps D-G\r\n        let res = undefined; // Step H: grind until k is in [1..n-1]\r\n        while (!(res = pred(gen())))\r\n            reseed();\r\n        reset();\r\n        return res;\r\n    };\r\n    return genUntil;\r\n}\r\n// Validating curves and fields\r\nconst validatorFns = {\r\n    bigint: (val) => typeof val === 'bigint',\r\n    function: (val) => typeof val === 'function',\r\n    boolean: (val) => typeof val === 'boolean',\r\n    string: (val) => typeof val === 'string',\r\n    stringOrUint8Array: (val) => typeof val === 'string' || val instanceof Uint8Array,\r\n    isSafeInteger: (val) => Number.isSafeInteger(val),\r\n    array: (val) => Array.isArray(val),\r\n    field: (val, object) => object.Fp.isValid(val),\r\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\r\n};\r\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\r\nfunction validateObject(object, validators, optValidators = {}) {\r\n    const checkField = (fieldName, type, isOptional) => {\r\n        const checkVal = validatorFns[type];\r\n        if (typeof checkVal !== 'function')\r\n            throw new Error(`Invalid validator \"${type}\", expected function`);\r\n        const val = object[fieldName];\r\n        if (isOptional && val === undefined)\r\n            return;\r\n        if (!checkVal(val, object)) {\r\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\r\n        }\r\n    };\r\n    for (const [fieldName, type] of Object.entries(validators))\r\n        checkField(fieldName, type, false);\r\n    for (const [fieldName, type] of Object.entries(optValidators))\r\n        checkField(fieldName, type, true);\r\n    return object;\r\n}\r\n// validate type tests\r\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\r\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\r\n// // Should fail type-check\r\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\r\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\r\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\r\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\r\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZ0NBQWdDLElBQUk7QUFDcEM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxpQ0FBaUMsSUFBSSxZQUFZLEVBQUU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPLFdBQVcsZ0JBQWdCLGFBQWEsSUFBSTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ087QUFDUDtBQUNBLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQ25ELDhEQUE4RDtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsS0FBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0IsR0FBRyxLQUFLLEdBQUcsV0FBVyxjQUFjLEtBQUs7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXLFdBQVcsWUFBWSxJQUFJO0FBQ3BELGtDQUFrQyxvQkFBb0IsSUFBSSxhQUFhLEdBQUc7QUFDMUU7QUFDQSxrQ0FBa0MsVUFBVSxJQUFJLFNBQVM7QUFDekQsa0NBQWtDLG9CQUFvQixJQUFJLFNBQVM7QUFDbkUsa0NBQWtDLDJCQUEyQjtBQUM3RCxrQ0FBa0Msd0JBQXdCO0FBQzFEIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGN1cnZlc1xcZXNtXFxhYnN0cmFjdFxcdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xyXG4vLyAxMDAgbGluZXMgb2YgY29kZSBpbiB0aGUgZmlsZSBhcmUgZHVwbGljYXRlZCBmcm9tIG5vYmxlLWhhc2hlcyAodXRpbHMpLlxyXG4vLyBUaGlzIGlzIE9LOiBgYWJzdHJhY3RgIGRpcmVjdG9yeSBkb2VzIG5vdCB1c2Ugbm9ibGUtaGFzaGVzLlxyXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXHJcbi8vIHdvbid0IGJlIGluY2x1ZGVkIGludG8gdGhlaXIgYnVuZGxlLlxyXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XHJcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcclxuY29uc3QgXzJuID0gQmlnSW50KDIpO1xyXG5jb25zdCB1OGEgPSAoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XHJcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XHJcbi8qKlxyXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xyXG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xyXG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XHJcbiAgICBsZXQgaGV4ID0gJyc7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcclxuICAgIH1cclxuICAgIHJldHVybiBoZXg7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvSGV4VW5wYWRkZWQobnVtKSB7XHJcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xyXG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcclxuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XHJcbiAgICAvLyBCaWcgRW5kaWFuXHJcbiAgICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiBgMHgke2hleH1gKTtcclxufVxyXG4vKipcclxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XHJcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xyXG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcclxuICAgIGlmIChsZW4gJSAyKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBsZW4pO1xyXG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBqID0gaSAqIDI7XHJcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XHJcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XHJcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcclxuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyYXk7XHJcbn1cclxuLy8gQkU6IEJpZyBFbmRpYW4sIExFOiBMaXR0bGUgRW5kaWFuXHJcbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcclxuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KGJ5dGVzKSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xyXG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xyXG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikge1xyXG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNMRShuLCBsZW4pIHtcclxuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XHJcbn1cclxuLy8gVW5wYWRkZWQsIHJhcmVseSB1c2VkXHJcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xyXG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobnVtYmVyVG9IZXhVbnBhZGRlZChuKSk7XHJcbn1cclxuLyoqXHJcbiAqIFRha2VzIGhleCBzdHJpbmcgb3IgVWludDhBcnJheSwgY29udmVydHMgdG8gVWludDhBcnJheS5cclxuICogVmFsaWRhdGVzIG91dHB1dCBsZW5ndGguXHJcbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxyXG4gKiBAcGFyYW0gdGl0bGUgZGVzY3JpcHRpdmUgdGl0bGUgZm9yIGFuIGVycm9yIGUuZy4gJ3ByaXZhdGUga2V5J1xyXG4gKiBAcGFyYW0gaGV4IGhleCBzdHJpbmcgb3IgVWludDhBcnJheVxyXG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcclxuICogQHJldHVybnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xyXG4gICAgbGV0IHJlcztcclxuICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlcyA9IGhleFRvQnl0ZXMoaGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIHZhbGlkIGhleCBzdHJpbmcsIGdvdCBcIiR7aGV4fVwiLiBDYXVzZTogJHtlfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHU4YShoZXgpKSB7XHJcbiAgICAgICAgLy8gVWludDhBcnJheS5mcm9tKCkgaW5zdGVhZCBvZiBoYXNoLnNsaWNlKCkgYmVjYXVzZSBub2RlLmpzIEJ1ZmZlclxyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcclxuICAgICAgICByZXMgPSBVaW50OEFycmF5LmZyb20oaGV4KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlgKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XHJcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW4gIT09IGV4cGVjdGVkTGVuZ3RoKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gZXhwZWN0ZWQgJHtleHBlY3RlZExlbmd0aH0gYnl0ZXMsIGdvdCAke2xlbn1gKTtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuLyoqXHJcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xyXG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcclxuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXHJcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xyXG4gICAgICAgIGlmICghdThhKGEpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcclxuICAgICAgICByLnNldChhLCBwYWQpO1xyXG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsQnl0ZXMoYjEsIGIyKSB7XHJcbiAgICAvLyBXZSBkb24ndCBjYXJlIGFib3V0IHRpbWluZyBhdHRhY2tzIGhlcmVcclxuICAgIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGIxLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGlmIChiMVtpXSAhPT0gYjJbaV0pXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKlxyXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xyXG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xyXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxyXG59XHJcbi8vIEJpdCBvcGVyYXRpb25zXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGFtb3VudCBvZiBiaXRzIGluIGEgYmlnaW50LlxyXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBiaXRMZW4obikge1xyXG4gICAgbGV0IGxlbjtcclxuICAgIGZvciAobGVuID0gMDsgbiA+IF8wbjsgbiA+Pj0gXzFuLCBsZW4gKz0gMSlcclxuICAgICAgICA7XHJcbiAgICByZXR1cm4gbGVuO1xyXG59XHJcbi8qKlxyXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXHJcbiAqIE5PVEU6IGZpcnN0IGJpdCBwb3NpdGlvbiBpcyAwIChzYW1lIGFzIGFycmF5cylcclxuICogU2FtZSBhcyBgISErQXJyYXkuZnJvbShuLnRvU3RyaW5nKDIpKS5yZXZlcnNlKClbcG9zXWBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBiaXRHZXQobiwgcG9zKSB7XHJcbiAgICByZXR1cm4gKG4gPj4gQmlnSW50KHBvcykpICYgXzFuO1xyXG59XHJcbi8qKlxyXG4gKiBTZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgYml0U2V0ID0gKG4sIHBvcywgdmFsdWUpID0+IHtcclxuICAgIHJldHVybiBuIHwgKCh2YWx1ZSA/IF8xbiA6IF8wbikgPDwgQmlnSW50KHBvcykpO1xyXG59O1xyXG4vKipcclxuICogQ2FsY3VsYXRlIG1hc2sgZm9yIE4gYml0cy4gTm90IHVzaW5nICoqIG9wZXJhdG9yIHdpdGggYmlnaW50cyBiZWNhdXNlIG9mIG9sZCBlbmdpbmVzLlxyXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGJpdE1hc2sgPSAobikgPT4gKF8ybiA8PCBCaWdJbnQobiAtIDEpKSAtIF8xbjtcclxuLy8gRFJCR1xyXG5jb25zdCB1OG4gPSAoZGF0YSkgPT4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7IC8vIGNyZWF0ZXMgVWludDhBcnJheVxyXG5jb25zdCB1OGZyID0gKGFycikgPT4gVWludDhBcnJheS5mcm9tKGFycik7IC8vIGFub3RoZXIgc2hvcnRjdXRcclxuLyoqXHJcbiAqIE1pbmltYWwgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cclxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcclxuICogQGV4YW1wbGVcclxuICogICBjb25zdCBkcmJnID0gY3JlYXRlSG1hY0RSQkc8S2V5PigzMiwgMzIsIGhtYWMpO1xyXG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhtYWNEcmJnKGhhc2hMZW4sIHFCeXRlTGVuLCBobWFjRm4pIHtcclxuICAgIGlmICh0eXBlb2YgaGFzaExlbiAhPT0gJ251bWJlcicgfHwgaGFzaExlbiA8IDIpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcclxuICAgIGlmICh0eXBlb2YgcUJ5dGVMZW4gIT09ICdudW1iZXInIHx8IHFCeXRlTGVuIDwgMilcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3FCeXRlTGVuIG11c3QgYmUgYSBudW1iZXInKTtcclxuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaG1hY0ZuIG11c3QgYmUgYSBmdW5jdGlvbicpO1xyXG4gICAgLy8gU3RlcCBCLCBTdGVwIEM6IHNldCBoYXNoTGVuIHRvIDgqY2VpbChobGVuLzgpXHJcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXHJcbiAgICBsZXQgayA9IHU4bihoYXNoTGVuKTsgLy8gU3RlcHMgQiBhbmQgQyBvZiBSRkM2OTc5IDMuMjogc2V0IGhhc2hMZW4sIGluIG91ciBjYXNlIGFsd2F5cyBzYW1lXHJcbiAgICBsZXQgaSA9IDA7IC8vIEl0ZXJhdGlvbnMgY291bnRlciwgd2lsbCB0aHJvdyB3aGVuIG92ZXIgMTAwMFxyXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XHJcbiAgICAgICAgdi5maWxsKDEpO1xyXG4gICAgICAgIGsuZmlsbCgwKTtcclxuICAgICAgICBpID0gMDtcclxuICAgIH07XHJcbiAgICBjb25zdCBoID0gKC4uLmIpID0+IGhtYWNGbihrLCB2LCAuLi5iKTsgLy8gaG1hYyhrKSh2LCAuLi52YWx1ZXMpXHJcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XHJcbiAgICAgICAgLy8gSE1BQy1EUkJHIHJlc2VlZCgpIGZ1bmN0aW9uLiBTdGVwcyBELUdcclxuICAgICAgICBrID0gaCh1OGZyKFsweDAwXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMCB8fCBzZWVkKVxyXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcclxuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxyXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcclxuICAgIH07XHJcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgLy8gSE1BQy1EUkJHIGdlbmVyYXRlKCkgZnVuY3Rpb25cclxuICAgICAgICBpZiAoaSsrID49IDEwMDApXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcclxuICAgICAgICBsZXQgbGVuID0gMDtcclxuICAgICAgICBjb25zdCBvdXQgPSBbXTtcclxuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcclxuICAgICAgICAgICAgdiA9IGgoKTtcclxuICAgICAgICAgICAgY29uc3Qgc2wgPSB2LnNsaWNlKCk7XHJcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcclxuICAgICAgICAgICAgbGVuICs9IHYubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcclxuICAgIH07XHJcbiAgICBjb25zdCBnZW5VbnRpbCA9IChzZWVkLCBwcmVkKSA9PiB7XHJcbiAgICAgICAgcmVzZXQoKTtcclxuICAgICAgICByZXNlZWQoc2VlZCk7IC8vIFN0ZXBzIEQtR1xyXG4gICAgICAgIGxldCByZXMgPSB1bmRlZmluZWQ7IC8vIFN0ZXAgSDogZ3JpbmQgdW50aWwgayBpcyBpbiBbMS4ubi0xXVxyXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcclxuICAgICAgICAgICAgcmVzZWVkKCk7XHJcbiAgICAgICAgcmVzZXQoKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBnZW5VbnRpbDtcclxufVxyXG4vLyBWYWxpZGF0aW5nIGN1cnZlcyBhbmQgZmllbGRzXHJcbmNvbnN0IHZhbGlkYXRvckZucyA9IHtcclxuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXHJcbiAgICBmdW5jdGlvbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcclxuICAgIGJvb2xlYW46ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdib29sZWFuJyxcclxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXHJcbiAgICBzdHJpbmdPclVpbnQ4QXJyYXk6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHZhbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksXHJcbiAgICBpc1NhZmVJbnRlZ2VyOiAodmFsKSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwpLFxyXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcclxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXHJcbiAgICBoYXNoOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbC5vdXRwdXRMZW4pLFxyXG59O1xyXG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iamVjdCwgdmFsaWRhdG9ycywgb3B0VmFsaWRhdG9ycyA9IHt9KSB7XHJcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgXCIke3R5cGV9XCIsIGV4cGVjdGVkIGZ1bmN0aW9uYCk7XHJcbiAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XHJcbiAgICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgdmFsID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAoIWNoZWNrVmFsKHZhbCwgb2JqZWN0KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFyYW0gJHtTdHJpbmcoZmllbGROYW1lKX09JHt2YWx9ICgke3R5cGVvZiB2YWx9KSwgZXhwZWN0ZWQgJHt0eXBlfWApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbGlkYXRvcnMpKVxyXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XHJcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKVxyXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCB0cnVlKTtcclxuICAgIHJldHVybiBvYmplY3Q7XHJcbn1cclxuLy8gdmFsaWRhdGUgdHlwZSB0ZXN0c1xyXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xyXG4vLyBjb25zdCB6MCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ2JpZ2ludCcgfSk7IC8vIE9rIVxyXG4vLyAvLyBTaG91bGQgZmFpbCB0eXBlLWNoZWNrXHJcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XHJcbi8vIGNvbnN0IHoyID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnenonIH0pO1xyXG4vLyBjb25zdCB6MyA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgdGVzdDogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcclxuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\n// Short Weierstrass curve. The formula is: y = x + ax + b\r\n\r\n\r\n\r\n\r\nfunction validatePointOpts(curve) {\r\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\r\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\r\n        a: 'field',\r\n        b: 'field',\r\n    }, {\r\n        allowedPrivateKeyLengths: 'array',\r\n        wrapPrivateKey: 'boolean',\r\n        isTorsionFree: 'function',\r\n        clearCofactor: 'function',\r\n        allowInfinityPoint: 'boolean',\r\n        fromBytes: 'function',\r\n        toBytes: 'function',\r\n    });\r\n    const { endo, Fp, a } = opts;\r\n    if (endo) {\r\n        if (!Fp.eql(a, Fp.ZERO)) {\r\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\r\n        }\r\n        if (typeof endo !== 'object' ||\r\n            typeof endo.beta !== 'bigint' ||\r\n            typeof endo.splitScalar !== 'function') {\r\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\r\n        }\r\n    }\r\n    return Object.freeze({ ...opts });\r\n}\r\n// ASN.1 DER encoding utilities\r\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\r\nconst DER = {\r\n    // asn.1 DER encoding utils\r\n    Err: class DERErr extends Error {\r\n        constructor(m = '') {\r\n            super(m);\r\n        }\r\n    },\r\n    _parseInt(data) {\r\n        const { Err: E } = DER;\r\n        if (data.length < 2 || data[0] !== 0x02)\r\n            throw new E('Invalid signature integer tag');\r\n        const len = data[1];\r\n        const res = data.subarray(2, len + 2);\r\n        if (!len || res.length !== len)\r\n            throw new E('Invalid signature integer: wrong length');\r\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\r\n        // since we always use positive integers here. It must always be empty:\r\n        // - add zero byte if exists\r\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\r\n        if (res[0] & 0b10000000)\r\n            throw new E('Invalid signature integer: negative');\r\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\r\n            throw new E('Invalid signature integer: unnecessary leading zero');\r\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\r\n    },\r\n    toSig(hex) {\r\n        // parse DER signature\r\n        const { Err: E } = DER;\r\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\r\n        if (!(data instanceof Uint8Array))\r\n            throw new Error('ui8a expected');\r\n        let l = data.length;\r\n        if (l < 2 || data[0] != 0x30)\r\n            throw new E('Invalid signature tag');\r\n        if (data[1] !== l - 2)\r\n            throw new E('Invalid signature: incorrect length');\r\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\r\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\r\n        if (rBytesLeft.length)\r\n            throw new E('Invalid signature: left bytes after parsing');\r\n        return { r, s };\r\n    },\r\n    hexFromSig(sig) {\r\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\r\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\r\n        const h = (num) => {\r\n            const hex = num.toString(16);\r\n            return hex.length & 1 ? `0${hex}` : hex;\r\n        };\r\n        const s = slice(h(sig.s));\r\n        const r = slice(h(sig.r));\r\n        const shl = s.length / 2;\r\n        const rhl = r.length / 2;\r\n        const sl = h(shl);\r\n        const rl = h(rhl);\r\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\r\n    },\r\n};\r\n// Be friendly to bad ECMAScript parsers by not using bigint literals\r\n// prettier-ignore\r\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\r\nfunction weierstrassPoints(opts) {\r\n    const CURVE = validatePointOpts(opts);\r\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\r\n    const toBytes = CURVE.toBytes ||\r\n        ((_c, point, _isCompressed) => {\r\n            const a = point.toAffine();\r\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\r\n        });\r\n    const fromBytes = CURVE.fromBytes ||\r\n        ((bytes) => {\r\n            // const head = bytes[0];\r\n            const tail = bytes.subarray(1);\r\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\r\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\r\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\r\n            return { x, y };\r\n        });\r\n    /**\r\n     * y = x + ax + b: Short weierstrass curve formula\r\n     * @returns y\r\n     */\r\n    function weierstrassEquation(x) {\r\n        const { a, b } = CURVE;\r\n        const x2 = Fp.sqr(x); // x * x\r\n        const x3 = Fp.mul(x2, x); // x2 * x\r\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\r\n    }\r\n    // Validate whether the passed curve params are valid.\r\n    // We check if curve equation works for generator point.\r\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\r\n    // ProjectivePoint class has not been initialized yet.\r\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\r\n        throw new Error('bad generator point: equation left != right');\r\n    // Valid group elements reside in range 1..n-1\r\n    function isWithinCurveOrder(num) {\r\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\r\n    }\r\n    function assertGE(num) {\r\n        if (!isWithinCurveOrder(num))\r\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\r\n    }\r\n    // Validates if priv key is valid and converts it to bigint.\r\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\r\n    function normPrivateKeyToScalar(key) {\r\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\r\n        if (lengths && typeof key !== 'bigint') {\r\n            if (key instanceof Uint8Array)\r\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\r\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\r\n            if (typeof key !== 'string' || !lengths.includes(key.length))\r\n                throw new Error('Invalid key');\r\n            key = key.padStart(nByteLength * 2, '0');\r\n        }\r\n        let num;\r\n        try {\r\n            num =\r\n                typeof key === 'bigint'\r\n                    ? key\r\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, nByteLength));\r\n        }\r\n        catch (error) {\r\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\r\n        }\r\n        if (wrapPrivateKey)\r\n            num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\r\n        assertGE(num); // num in range [1..N-1]\r\n        return num;\r\n    }\r\n    const pointPrecomputes = new Map();\r\n    function assertPrjPoint(other) {\r\n        if (!(other instanceof Point))\r\n            throw new Error('ProjectivePoint expected');\r\n    }\r\n    /**\r\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)\r\n     * Default Point works in 2d / affine coordinates: (x, y)\r\n     * We're doing calculations in projective, because its operations don't require costly inversion.\r\n     */\r\n    class Point {\r\n        constructor(px, py, pz) {\r\n            this.px = px;\r\n            this.py = py;\r\n            this.pz = pz;\r\n            if (px == null || !Fp.isValid(px))\r\n                throw new Error('x required');\r\n            if (py == null || !Fp.isValid(py))\r\n                throw new Error('y required');\r\n            if (pz == null || !Fp.isValid(pz))\r\n                throw new Error('z required');\r\n        }\r\n        // Does not validate if the point is on-curve.\r\n        // Use fromHex instead, or call assertValidity() later.\r\n        static fromAffine(p) {\r\n            const { x, y } = p || {};\r\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\r\n                throw new Error('invalid affine point');\r\n            if (p instanceof Point)\r\n                throw new Error('projective point not allowed');\r\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\r\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\r\n            if (is0(x) && is0(y))\r\n                return Point.ZERO;\r\n            return new Point(x, y, Fp.ONE);\r\n        }\r\n        get x() {\r\n            return this.toAffine().x;\r\n        }\r\n        get y() {\r\n            return this.toAffine().y;\r\n        }\r\n        /**\r\n         * Takes a bunch of Projective Points but executes only one\r\n         * inversion on all of them. Inversion is very slow operation,\r\n         * so this improves performance massively.\r\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\r\n         */\r\n        static normalizeZ(points) {\r\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\r\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\r\n        }\r\n        /**\r\n         * Converts hash string or Uint8Array to Point.\r\n         * @param hex short/long ECDSA hex\r\n         */\r\n        static fromHex(hex) {\r\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex)));\r\n            P.assertValidity();\r\n            return P;\r\n        }\r\n        // Multiplies generator point by privateKey.\r\n        static fromPrivateKey(privateKey) {\r\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\r\n        }\r\n        // \"Private method\", don't use it directly\r\n        _setWindowSize(windowSize) {\r\n            this._WINDOW_SIZE = windowSize;\r\n            pointPrecomputes.delete(this);\r\n        }\r\n        // A point on curve is valid if it conforms to equation.\r\n        assertValidity() {\r\n            if (this.is0()) {\r\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\r\n                // In BLS, ZERO can be serialized, so we allow it.\r\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\r\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\r\n                    return;\r\n                throw new Error('bad point: ZERO');\r\n            }\r\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\r\n            const { x, y } = this.toAffine();\r\n            // Check if x, y are valid field elements\r\n            if (!Fp.isValid(x) || !Fp.isValid(y))\r\n                throw new Error('bad point: x or y not FE');\r\n            const left = Fp.sqr(y); // y\r\n            const right = weierstrassEquation(x); // x + ax + b\r\n            if (!Fp.eql(left, right))\r\n                throw new Error('bad point: equation left != right');\r\n            if (!this.isTorsionFree())\r\n                throw new Error('bad point: not in prime-order subgroup');\r\n        }\r\n        hasEvenY() {\r\n            const { y } = this.toAffine();\r\n            if (Fp.isOdd)\r\n                return !Fp.isOdd(y);\r\n            throw new Error(\"Field doesn't support isOdd\");\r\n        }\r\n        /**\r\n         * Compare one point to another.\r\n         */\r\n        equals(other) {\r\n            assertPrjPoint(other);\r\n            const { px: X1, py: Y1, pz: Z1 } = this;\r\n            const { px: X2, py: Y2, pz: Z2 } = other;\r\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\r\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\r\n            return U1 && U2;\r\n        }\r\n        /**\r\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\r\n         */\r\n        negate() {\r\n            return new Point(this.px, Fp.neg(this.py), this.pz);\r\n        }\r\n        // Renes-Costello-Batina exception-free doubling formula.\r\n        // There is 30% faster Jacobian formula, but it is not complete.\r\n        // https://eprint.iacr.org/2015/1060, algorithm 3\r\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\r\n        double() {\r\n            const { a, b } = CURVE;\r\n            const b3 = Fp.mul(b, _3n);\r\n            const { px: X1, py: Y1, pz: Z1 } = this;\r\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\r\n            let t0 = Fp.mul(X1, X1); // step 1\r\n            let t1 = Fp.mul(Y1, Y1);\r\n            let t2 = Fp.mul(Z1, Z1);\r\n            let t3 = Fp.mul(X1, Y1);\r\n            t3 = Fp.add(t3, t3); // step 5\r\n            Z3 = Fp.mul(X1, Z1);\r\n            Z3 = Fp.add(Z3, Z3);\r\n            X3 = Fp.mul(a, Z3);\r\n            Y3 = Fp.mul(b3, t2);\r\n            Y3 = Fp.add(X3, Y3); // step 10\r\n            X3 = Fp.sub(t1, Y3);\r\n            Y3 = Fp.add(t1, Y3);\r\n            Y3 = Fp.mul(X3, Y3);\r\n            X3 = Fp.mul(t3, X3);\r\n            Z3 = Fp.mul(b3, Z3); // step 15\r\n            t2 = Fp.mul(a, t2);\r\n            t3 = Fp.sub(t0, t2);\r\n            t3 = Fp.mul(a, t3);\r\n            t3 = Fp.add(t3, Z3);\r\n            Z3 = Fp.add(t0, t0); // step 20\r\n            t0 = Fp.add(Z3, t0);\r\n            t0 = Fp.add(t0, t2);\r\n            t0 = Fp.mul(t0, t3);\r\n            Y3 = Fp.add(Y3, t0);\r\n            t2 = Fp.mul(Y1, Z1); // step 25\r\n            t2 = Fp.add(t2, t2);\r\n            t0 = Fp.mul(t2, t3);\r\n            X3 = Fp.sub(X3, t0);\r\n            Z3 = Fp.mul(t2, t1);\r\n            Z3 = Fp.add(Z3, Z3); // step 30\r\n            Z3 = Fp.add(Z3, Z3);\r\n            return new Point(X3, Y3, Z3);\r\n        }\r\n        // Renes-Costello-Batina exception-free addition formula.\r\n        // There is 30% faster Jacobian formula, but it is not complete.\r\n        // https://eprint.iacr.org/2015/1060, algorithm 1\r\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\r\n        add(other) {\r\n            assertPrjPoint(other);\r\n            const { px: X1, py: Y1, pz: Z1 } = this;\r\n            const { px: X2, py: Y2, pz: Z2 } = other;\r\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\r\n            const a = CURVE.a;\r\n            const b3 = Fp.mul(CURVE.b, _3n);\r\n            let t0 = Fp.mul(X1, X2); // step 1\r\n            let t1 = Fp.mul(Y1, Y2);\r\n            let t2 = Fp.mul(Z1, Z2);\r\n            let t3 = Fp.add(X1, Y1);\r\n            let t4 = Fp.add(X2, Y2); // step 5\r\n            t3 = Fp.mul(t3, t4);\r\n            t4 = Fp.add(t0, t1);\r\n            t3 = Fp.sub(t3, t4);\r\n            t4 = Fp.add(X1, Z1);\r\n            let t5 = Fp.add(X2, Z2); // step 10\r\n            t4 = Fp.mul(t4, t5);\r\n            t5 = Fp.add(t0, t2);\r\n            t4 = Fp.sub(t4, t5);\r\n            t5 = Fp.add(Y1, Z1);\r\n            X3 = Fp.add(Y2, Z2); // step 15\r\n            t5 = Fp.mul(t5, X3);\r\n            X3 = Fp.add(t1, t2);\r\n            t5 = Fp.sub(t5, X3);\r\n            Z3 = Fp.mul(a, t4);\r\n            X3 = Fp.mul(b3, t2); // step 20\r\n            Z3 = Fp.add(X3, Z3);\r\n            X3 = Fp.sub(t1, Z3);\r\n            Z3 = Fp.add(t1, Z3);\r\n            Y3 = Fp.mul(X3, Z3);\r\n            t1 = Fp.add(t0, t0); // step 25\r\n            t1 = Fp.add(t1, t0);\r\n            t2 = Fp.mul(a, t2);\r\n            t4 = Fp.mul(b3, t4);\r\n            t1 = Fp.add(t1, t2);\r\n            t2 = Fp.sub(t0, t2); // step 30\r\n            t2 = Fp.mul(a, t2);\r\n            t4 = Fp.add(t4, t2);\r\n            t0 = Fp.mul(t1, t4);\r\n            Y3 = Fp.add(Y3, t0);\r\n            t0 = Fp.mul(t5, t4); // step 35\r\n            X3 = Fp.mul(t3, X3);\r\n            X3 = Fp.sub(X3, t0);\r\n            t0 = Fp.mul(t3, t1);\r\n            Z3 = Fp.mul(t5, Z3);\r\n            Z3 = Fp.add(Z3, t0); // step 40\r\n            return new Point(X3, Y3, Z3);\r\n        }\r\n        subtract(other) {\r\n            return this.add(other.negate());\r\n        }\r\n        is0() {\r\n            return this.equals(Point.ZERO);\r\n        }\r\n        wNAF(n) {\r\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\r\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\r\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\r\n            });\r\n        }\r\n        /**\r\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\r\n         * It's faster, but should only be used when you don't care about\r\n         * an exposed private key e.g. sig verification, which works over *public* keys.\r\n         */\r\n        multiplyUnsafe(n) {\r\n            const I = Point.ZERO;\r\n            if (n === _0n)\r\n                return I;\r\n            assertGE(n); // Will throw on 0\r\n            if (n === _1n)\r\n                return this;\r\n            const { endo } = CURVE;\r\n            if (!endo)\r\n                return wnaf.unsafeLadder(this, n);\r\n            // Apply endomorphism\r\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\r\n            let k1p = I;\r\n            let k2p = I;\r\n            let d = this;\r\n            while (k1 > _0n || k2 > _0n) {\r\n                if (k1 & _1n)\r\n                    k1p = k1p.add(d);\r\n                if (k2 & _1n)\r\n                    k2p = k2p.add(d);\r\n                d = d.double();\r\n                k1 >>= _1n;\r\n                k2 >>= _1n;\r\n            }\r\n            if (k1neg)\r\n                k1p = k1p.negate();\r\n            if (k2neg)\r\n                k2p = k2p.negate();\r\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\r\n            return k1p.add(k2p);\r\n        }\r\n        /**\r\n         * Constant time multiplication.\r\n         * Uses wNAF method. Windowed method may be 10% faster,\r\n         * but takes 2x longer to generate and consumes 2x memory.\r\n         * Uses precomputes when available.\r\n         * Uses endomorphism for Koblitz curves.\r\n         * @param scalar by which the point would be multiplied\r\n         * @returns New point\r\n         */\r\n        multiply(scalar) {\r\n            assertGE(scalar);\r\n            let n = scalar;\r\n            let point, fake; // Fake point is used to const-time mult\r\n            const { endo } = CURVE;\r\n            if (endo) {\r\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\r\n                let { p: k1p, f: f1p } = this.wNAF(k1);\r\n                let { p: k2p, f: f2p } = this.wNAF(k2);\r\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\r\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\r\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\r\n                point = k1p.add(k2p);\r\n                fake = f1p.add(f2p);\r\n            }\r\n            else {\r\n                const { p, f } = this.wNAF(n);\r\n                point = p;\r\n                fake = f;\r\n            }\r\n            // Normalize `z` for both points, but return only real one\r\n            return Point.normalizeZ([point, fake])[0];\r\n        }\r\n        /**\r\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\r\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\r\n         * The trick could be useful if both P and Q are not G (not in our case).\r\n         * @returns non-zero affine point\r\n         */\r\n        multiplyAndAddUnsafe(Q, a, b) {\r\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\r\n            const mul = (P, a // Select faster multiply() method\r\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\r\n            const sum = mul(this, a).add(mul(Q, b));\r\n            return sum.is0() ? undefined : sum;\r\n        }\r\n        // Converts Projective point to affine (x, y) coordinates.\r\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\r\n        // (x, y, z)  (x=x/z, y=y/z)\r\n        toAffine(iz) {\r\n            const { px: x, py: y, pz: z } = this;\r\n            const is0 = this.is0();\r\n            // If invZ was 0, we return zero point. However we still want to execute\r\n            // all operations, so we replace invZ with a random number, 1.\r\n            if (iz == null)\r\n                iz = is0 ? Fp.ONE : Fp.inv(z);\r\n            const ax = Fp.mul(x, iz);\r\n            const ay = Fp.mul(y, iz);\r\n            const zz = Fp.mul(z, iz);\r\n            if (is0)\r\n                return { x: Fp.ZERO, y: Fp.ZERO };\r\n            if (!Fp.eql(zz, Fp.ONE))\r\n                throw new Error('invZ was invalid');\r\n            return { x: ax, y: ay };\r\n        }\r\n        isTorsionFree() {\r\n            const { h: cofactor, isTorsionFree } = CURVE;\r\n            if (cofactor === _1n)\r\n                return true; // No subgroups, always torsion-free\r\n            if (isTorsionFree)\r\n                return isTorsionFree(Point, this);\r\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\r\n        }\r\n        clearCofactor() {\r\n            const { h: cofactor, clearCofactor } = CURVE;\r\n            if (cofactor === _1n)\r\n                return this; // Fast-path\r\n            if (clearCofactor)\r\n                return clearCofactor(Point, this);\r\n            return this.multiplyUnsafe(CURVE.h);\r\n        }\r\n        toRawBytes(isCompressed = true) {\r\n            this.assertValidity();\r\n            return toBytes(Point, this, isCompressed);\r\n        }\r\n        toHex(isCompressed = true) {\r\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\r\n        }\r\n    }\r\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\r\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\r\n    const _bits = CURVE.nBitLength;\r\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\r\n    // Validate if generator point is on curve\r\n    return {\r\n        CURVE,\r\n        ProjectivePoint: Point,\r\n        normPrivateKeyToScalar,\r\n        weierstrassEquation,\r\n        isWithinCurveOrder,\r\n    };\r\n}\r\nfunction validateOpts(curve) {\r\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\r\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\r\n        hash: 'hash',\r\n        hmac: 'function',\r\n        randomBytes: 'function',\r\n    }, {\r\n        bits2int: 'function',\r\n        bits2int_modN: 'function',\r\n        lowS: 'boolean',\r\n    });\r\n    return Object.freeze({ lowS: true, ...opts });\r\n}\r\nfunction weierstrass(curveDef) {\r\n    const CURVE = validateOpts(curveDef);\r\n    const { Fp, n: CURVE_ORDER } = CURVE;\r\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\r\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\r\n    function isValidFieldElement(num) {\r\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\r\n    }\r\n    function modN(a) {\r\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\r\n    }\r\n    function invN(a) {\r\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\r\n    }\r\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\r\n        ...CURVE,\r\n        toBytes(_c, point, isCompressed) {\r\n            const a = point.toAffine();\r\n            const x = Fp.toBytes(a.x);\r\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\r\n            if (isCompressed) {\r\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\r\n            }\r\n            else {\r\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\r\n            }\r\n        },\r\n        fromBytes(bytes) {\r\n            const len = bytes.length;\r\n            const head = bytes[0];\r\n            const tail = bytes.subarray(1);\r\n            // this.assertValidity() is done inside of fromHex\r\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\r\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\r\n                if (!isValidFieldElement(x))\r\n                    throw new Error('Point is not on curve');\r\n                const y2 = weierstrassEquation(x); // y = x + ax + b\r\n                let y = Fp.sqrt(y2); // y = y ^ (p+1)/4\r\n                const isYOdd = (y & _1n) === _1n;\r\n                // ECDSA\r\n                const isHeadOdd = (head & 1) === 1;\r\n                if (isHeadOdd !== isYOdd)\r\n                    y = Fp.neg(y);\r\n                return { x, y };\r\n            }\r\n            else if (len === uncompressedLen && head === 0x04) {\r\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\r\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\r\n                return { x, y };\r\n            }\r\n            else {\r\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\r\n            }\r\n        },\r\n    });\r\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\r\n    function isBiggerThanHalfOrder(number) {\r\n        const HALF = CURVE_ORDER >> _1n;\r\n        return number > HALF;\r\n    }\r\n    function normalizeS(s) {\r\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\r\n    }\r\n    // slice bytes num\r\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\r\n    /**\r\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\r\n     */\r\n    class Signature {\r\n        constructor(r, s, recovery) {\r\n            this.r = r;\r\n            this.s = s;\r\n            this.recovery = recovery;\r\n            this.assertValidity();\r\n        }\r\n        // pair (bytes of r, bytes of s)\r\n        static fromCompact(hex) {\r\n            const l = CURVE.nByteLength;\r\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('compactSignature', hex, l * 2);\r\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\r\n        }\r\n        // DER encoded ECDSA signature\r\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\r\n        static fromDER(hex) {\r\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('DER', hex));\r\n            return new Signature(r, s);\r\n        }\r\n        assertValidity() {\r\n            // can use assertGE here\r\n            if (!isWithinCurveOrder(this.r))\r\n                throw new Error('r must be 0 < r < CURVE.n');\r\n            if (!isWithinCurveOrder(this.s))\r\n                throw new Error('s must be 0 < s < CURVE.n');\r\n        }\r\n        addRecoveryBit(recovery) {\r\n            return new Signature(this.r, this.s, recovery);\r\n        }\r\n        recoverPublicKey(msgHash) {\r\n            const { r, s, recovery: rec } = this;\r\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash)); // Truncate hash\r\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\r\n                throw new Error('recovery id invalid');\r\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\r\n            if (radj >= Fp.ORDER)\r\n                throw new Error('recovery id 2 or 3 invalid');\r\n            const prefix = (rec & 1) === 0 ? '02' : '03';\r\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\r\n            const ir = invN(radj); // r^-1\r\n            const u1 = modN(-h * ir); // -hr^-1\r\n            const u2 = modN(s * ir); // sr^-1\r\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\r\n            if (!Q)\r\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\r\n            Q.assertValidity();\r\n            return Q;\r\n        }\r\n        // Signatures should be low-s, to prevent malleability.\r\n        hasHighS() {\r\n            return isBiggerThanHalfOrder(this.s);\r\n        }\r\n        normalizeS() {\r\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\r\n        }\r\n        // DER-encoded\r\n        toDERRawBytes() {\r\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\r\n        }\r\n        toDERHex() {\r\n            return DER.hexFromSig({ r: this.r, s: this.s });\r\n        }\r\n        // padded bytes of r, then padded bytes of s\r\n        toCompactRawBytes() {\r\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\r\n        }\r\n        toCompactHex() {\r\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\r\n        }\r\n    }\r\n    const utils = {\r\n        isValidPrivateKey(privateKey) {\r\n            try {\r\n                normPrivateKeyToScalar(privateKey);\r\n                return true;\r\n            }\r\n            catch (error) {\r\n                return false;\r\n            }\r\n        },\r\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\r\n        /**\r\n         * Produces cryptographically secure private key from random of size\r\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\r\n         */\r\n        randomPrivateKey: () => {\r\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\r\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\r\n        },\r\n        /**\r\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\r\n         * Allows to massively speed-up `point.multiply(scalar)`.\r\n         * @returns cached point\r\n         * @example\r\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\r\n         * fast.multiply(privKey); // much faster ECDH now\r\n         */\r\n        precompute(windowSize = 8, point = Point.BASE) {\r\n            point._setWindowSize(windowSize);\r\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\r\n            return point;\r\n        },\r\n    };\r\n    /**\r\n     * Computes public key for a private key. Checks for validity of the private key.\r\n     * @param privateKey private key\r\n     * @param isCompressed whether to return compact (default), or full key\r\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\r\n     */\r\n    function getPublicKey(privateKey, isCompressed = true) {\r\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\r\n    }\r\n    /**\r\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\r\n     */\r\n    function isProbPub(item) {\r\n        const arr = item instanceof Uint8Array;\r\n        const str = typeof item === 'string';\r\n        const len = (arr || str) && item.length;\r\n        if (arr)\r\n            return len === compressedLen || len === uncompressedLen;\r\n        if (str)\r\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\r\n        if (item instanceof Point)\r\n            return true;\r\n        return false;\r\n    }\r\n    /**\r\n     * ECDH (Elliptic Curve Diffie Hellman).\r\n     * Computes shared public key from private key and public key.\r\n     * Checks: 1) private key validity 2) shared key is on-curve.\r\n     * Does NOT hash the result.\r\n     * @param privateA private key\r\n     * @param publicB different public key\r\n     * @param isCompressed whether to return compact (default), or full key\r\n     * @returns shared public key\r\n     */\r\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\r\n        if (isProbPub(privateA))\r\n            throw new Error('first arg must be private key');\r\n        if (!isProbPub(publicB))\r\n            throw new Error('second arg must be public key');\r\n        const b = Point.fromHex(publicB); // check for being on-curve\r\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\r\n    }\r\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\r\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\r\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\r\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\r\n    const bits2int = CURVE.bits2int ||\r\n        function (bytes) {\r\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\r\n            // for some cases, since bytes.length * 8 is not actual bitLength.\r\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\r\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\r\n            return delta > 0 ? num >> BigInt(delta) : num;\r\n        };\r\n    const bits2int_modN = CURVE.bits2int_modN ||\r\n        function (bytes) {\r\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\r\n        };\r\n    // NOTE: pads output with zero as per spec\r\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\r\n    /**\r\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\r\n     */\r\n    function int2octets(num) {\r\n        if (typeof num !== 'bigint')\r\n            throw new Error('bigint expected');\r\n        if (!(_0n <= num && num < ORDER_MASK))\r\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\r\n        // works with order, can have different size than numToField!\r\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\r\n    }\r\n    // Steps A, D of RFC6979 3.2\r\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\r\n    // Used only in sign, not in verify.\r\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\r\n    // Also it can be bigger for P224 + SHA256\r\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\r\n        if (['recovered', 'canonical'].some((k) => k in opts))\r\n            throw new Error('sign() legacy options not supported');\r\n        const { hash, randomBytes } = CURVE;\r\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\r\n        if (lowS == null)\r\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\r\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\r\n        if (prehash)\r\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('prehashed msgHash', hash(msgHash));\r\n        // We can't later call bits2octets, since nested bits2int is broken for curves\r\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\r\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\r\n        const h1int = bits2int_modN(msgHash);\r\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\r\n        const seedArgs = [int2octets(d), int2octets(h1int)];\r\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\r\n        if (ent != null) {\r\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\r\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\r\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('extraEntropy', e)); // check for being bytes\r\n        }\r\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\r\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\r\n        // Converts signature params into point w r/s, checks result for validity.\r\n        function k2sig(kBytes) {\r\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\r\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\r\n            if (!isWithinCurveOrder(k))\r\n                return; // Important: all mod() calls here must be done over N\r\n            const ik = invN(k); // k^-1 mod n\r\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\r\n            const r = modN(q.x); // r = q.x mod n\r\n            if (r === _0n)\r\n                return;\r\n            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\r\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\r\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\r\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\r\n            if (s === _0n)\r\n                return;\r\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\r\n            let normS = s;\r\n            if (lowS && isBiggerThanHalfOrder(s)) {\r\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\r\n                recovery ^= 1; // // in the bottom half of N\r\n            }\r\n            return new Signature(r, normS, recovery); // use normS, not s\r\n        }\r\n        return { seed, k2sig };\r\n    }\r\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\r\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\r\n    /**\r\n     * Signs message hash with a private key.\r\n     * ```\r\n     * sign(m, d, k) where\r\n     *   (x, y) = G  k\r\n     *   r = x mod n\r\n     *   s = (m + dr)/k mod n\r\n     * ```\r\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\r\n     * @param privKey private key\r\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\r\n     * @returns signature with recovery param\r\n     */\r\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\r\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\r\n        const C = CURVE;\r\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\r\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\r\n    }\r\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\r\n    Point.BASE._setWindowSize(8);\r\n    // utils.precompute(8, ProjectivePoint.BASE)\r\n    /**\r\n     * Verifies a signature against message hash and public key.\r\n     * Rejects lowS signatures by default: to override,\r\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\r\n     *\r\n     * ```\r\n     * verify(r, s, h, P) where\r\n     *   U1 = hs^-1 mod n\r\n     *   U2 = rs^-1 mod n\r\n     *   R = U1G - U2P\r\n     *   mod(R.x, n) == r\r\n     * ```\r\n     */\r\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\r\n        const sg = signature;\r\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\r\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('publicKey', publicKey);\r\n        if ('strict' in opts)\r\n            throw new Error('options.strict was renamed to lowS');\r\n        const { lowS, prehash } = opts;\r\n        let _sig = undefined;\r\n        let P;\r\n        try {\r\n            if (typeof sg === 'string' || sg instanceof Uint8Array) {\r\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\r\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\r\n                try {\r\n                    _sig = Signature.fromDER(sg);\r\n                }\r\n                catch (derError) {\r\n                    if (!(derError instanceof DER.Err))\r\n                        throw derError;\r\n                    _sig = Signature.fromCompact(sg);\r\n                }\r\n            }\r\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\r\n                const { r, s } = sg;\r\n                _sig = new Signature(r, s);\r\n            }\r\n            else {\r\n                throw new Error('PARSE');\r\n            }\r\n            P = Point.fromHex(publicKey);\r\n        }\r\n        catch (error) {\r\n            if (error.message === 'PARSE')\r\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\r\n            return false;\r\n        }\r\n        if (lowS && _sig.hasHighS())\r\n            return false;\r\n        if (prehash)\r\n            msgHash = CURVE.hash(msgHash);\r\n        const { r, s } = _sig;\r\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\r\n        const is = invN(s); // s^-1\r\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\r\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\r\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\r\n        if (!R)\r\n            return false;\r\n        const v = modN(R.x);\r\n        return v === r;\r\n    }\r\n    return {\r\n        CURVE,\r\n        getPublicKey,\r\n        getSharedSecret,\r\n        sign,\r\n        verify,\r\n        ProjectivePoint: Point,\r\n        Signature,\r\n        utils,\r\n    };\r\n}\r\n/**\r\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\r\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\r\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\r\n * b = False and y = sqrt(Z * (u / v)) otherwise.\r\n * @param Fp\r\n * @param Z\r\n * @returns\r\n */\r\nfunction SWUFpSqrtRatio(Fp, Z) {\r\n    // Generic implementation\r\n    const q = Fp.ORDER;\r\n    let l = _0n;\r\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\r\n        l += _1n;\r\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\r\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\r\n    // 2n ** c1 == 2n << (c1-1)\r\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\r\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\r\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\r\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\r\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\r\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\r\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\r\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\r\n    let sqrtRatio = (u, v) => {\r\n        let tv1 = c6; // 1. tv1 = c6\r\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\r\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\r\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\r\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\r\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\r\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\r\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\r\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\r\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\r\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\r\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\r\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\r\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\r\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\r\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\r\n        // 17. for i in (c1, c1 - 1, ..., 2):\r\n        for (let i = c1; i > _1n; i--) {\r\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\r\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\r\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\r\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\r\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\r\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\r\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\r\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\r\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\r\n        }\r\n        return { isValid: isQR, value: tv3 };\r\n    };\r\n    if (Fp.ORDER % _4n === _3n) {\r\n        // sqrt_ratio_3mod4(u, v)\r\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\r\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\r\n        sqrtRatio = (u, v) => {\r\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\r\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\r\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\r\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\r\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\r\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\r\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\r\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\r\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\r\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\r\n        };\r\n    }\r\n    // No curves uses that\r\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\r\n    return sqrtRatio;\r\n}\r\n/**\r\n * Simplified Shallue-van de Woestijne-Ulas Method\r\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\r\n */\r\nfunction mapToCurveSimpleSWU(Fp, opts) {\r\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\r\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\r\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\r\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\r\n    if (!Fp.isOdd)\r\n        throw new Error('Fp.isOdd is not implemented!');\r\n    // Input: u, an element of F.\r\n    // Output: (x, y), a point on E.\r\n    return (u) => {\r\n        // prettier-ignore\r\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\r\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\r\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\r\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\r\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\r\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\r\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\r\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\r\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\r\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\r\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\r\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\r\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\r\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\r\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\r\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\r\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\r\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\r\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\r\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\r\n        y = Fp.mul(y, value); // 20.   y = y * y1\r\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\r\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\r\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\r\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\r\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\r\n        return { x, y };\r\n    };\r\n}\r\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDb0M7QUFDSDtBQUNRO0FBQ1E7QUFDakQ7QUFDQSxpQkFBaUIsd0RBQWE7QUFDOUIsSUFBSSxxREFBaUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0EsUUFBUSx3Q0FBd0MsRUFBRSxzQ0FBRTtBQUM3QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBDQUEwQztBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQixJQUFJLEdBQUcsRUFBRSxFQUFFLElBQUksR0FBRyxFQUFFLEVBQUU7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFlBQVksS0FBSyxTQUFTO0FBQzFCO0FBQ0E7QUFD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LW5leHRqc1xcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGN1cnZlc1xcZXNtXFxhYnN0cmFjdFxcd2VpZXJzdHJhc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xyXG4vLyBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZS4gVGhlIGZvcm11bGEgaXM6IHnCsiA9IHjCsyArIGF4ICsgYlxyXG5pbXBvcnQgKiBhcyBtb2QgZnJvbSAnLi9tb2R1bGFyLmpzJztcclxuaW1wb3J0ICogYXMgdXQgZnJvbSAnLi91dGlscy5qcyc7XHJcbmltcG9ydCB7IGVuc3VyZUJ5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XHJcbmltcG9ydCB7IHdOQUYsIHZhbGlkYXRlQmFzaWMgfSBmcm9tICcuL2N1cnZlLmpzJztcclxuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcclxuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcclxuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcclxuICAgICAgICBhOiAnZmllbGQnLFxyXG4gICAgICAgIGI6ICdmaWVsZCcsXHJcbiAgICB9LCB7XHJcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxyXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiAnYm9vbGVhbicsXHJcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcclxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxyXG4gICAgICAgIGFsbG93SW5maW5pdHlQb2ludDogJ2Jvb2xlYW4nLFxyXG4gICAgICAgIGZyb21CeXRlczogJ2Z1bmN0aW9uJyxcclxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCB7IGVuZG8sIEZwLCBhIH0gPSBvcHRzO1xyXG4gICAgaWYgKGVuZG8pIHtcclxuICAgICAgICBpZiAoIUZwLmVxbChhLCBGcC5aRVJPKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuZG9tb3JwaGlzbSBjYW4gb25seSBiZSBkZWZpbmVkIGZvciBLb2JsaXR6IGN1cnZlcyB0aGF0IGhhdmUgYT0wJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgZW5kbyAhPT0gJ29iamVjdCcgfHxcclxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHxcclxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBlbmRvbW9ycGhpc20gd2l0aCBiZXRhOiBiaWdpbnQgYW5kIHNwbGl0U2NhbGFyOiBmdW5jdGlvbicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcclxufVxyXG4vLyBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzXHJcbmNvbnN0IHsgYnl0ZXNUb051bWJlckJFOiBiMm4sIGhleFRvQnl0ZXM6IGgyYiB9ID0gdXQ7XHJcbmV4cG9ydCBjb25zdCBERVIgPSB7XHJcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcclxuICAgIEVycjogY2xhc3MgREVSRXJyIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xyXG4gICAgICAgICAgICBzdXBlcihtKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX3BhcnNlSW50KGRhdGEpIHtcclxuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xyXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVswXSAhPT0gMHgwMilcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnJyk7XHJcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YVsxXTtcclxuICAgICAgICBjb25zdCByZXMgPSBkYXRhLnN1YmFycmF5KDIsIGxlbiArIDIpO1xyXG4gICAgICAgIGlmICghbGVuIHx8IHJlcy5sZW5ndGggIT09IGxlbilcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHdyb25nIGxlbmd0aCcpO1xyXG4gICAgICAgIC8vIGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTc3MzQgTGVmdG1vc3QgYml0IG9mIGZpcnN0IGJ5dGUgaXMgJ25lZ2F0aXZlJyBmbGFnLFxyXG4gICAgICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XHJcbiAgICAgICAgLy8gLSBhZGQgemVybyBieXRlIGlmIGV4aXN0c1xyXG4gICAgICAgIC8vIC0gaWYgbmV4dCBieXRlIGRvZXNuJ3QgaGF2ZSBhIGZsYWcsIGxlYWRpbmcgemVybyBpcyBub3QgYWxsb3dlZCAobWluaW1hbCBlbmNvZGluZylcclxuICAgICAgICBpZiAocmVzWzBdICYgMGIxMDAwMDAwMClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IG5lZ2F0aXZlJyk7XHJcbiAgICAgICAgaWYgKHJlc1swXSA9PT0gMHgwMCAmJiAhKHJlc1sxXSAmIDBiMTAwMDAwMDApKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XHJcbiAgICAgICAgcmV0dXJuIHsgZDogYjJuKHJlcyksIGw6IGRhdGEuc3ViYXJyYXkobGVuICsgMikgfTsgLy8gZCBpcyBkYXRhLCBsIGlzIGxlZnRcclxuICAgIH0sXHJcbiAgICB0b1NpZyhoZXgpIHtcclxuICAgICAgICAvLyBwYXJzZSBERVIgc2lnbmF0dXJlXHJcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcclxuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgPyBoMmIoaGV4KSA6IGhleDtcclxuICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndWk4YSBleHBlY3RlZCcpO1xyXG4gICAgICAgIGxldCBsID0gZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGwgPCAyIHx8IGRhdGFbMF0gIT0gMHgzMClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIHRhZycpO1xyXG4gICAgICAgIGlmIChkYXRhWzFdICE9PSBsIC0gMilcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoJyk7XHJcbiAgICAgICAgY29uc3QgeyBkOiByLCBsOiBzQnl0ZXMgfSA9IERFUi5fcGFyc2VJbnQoZGF0YS5zdWJhcnJheSgyKSk7XHJcbiAgICAgICAgY29uc3QgeyBkOiBzLCBsOiByQnl0ZXNMZWZ0IH0gPSBERVIuX3BhcnNlSW50KHNCeXRlcyk7XHJcbiAgICAgICAgaWYgKHJCeXRlc0xlZnQubGVuZ3RoKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xyXG4gICAgICAgIHJldHVybiB7IHIsIHMgfTtcclxuICAgIH0sXHJcbiAgICBoZXhGcm9tU2lnKHNpZykge1xyXG4gICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm8gaWYgZmlyc3QgYnl0ZSBoYXMgbmVnYXRpdmUgYml0IGVuYWJsZWQuIE1vcmUgZGV0YWlscyBpbiAnX3BhcnNlSW50J1xyXG4gICAgICAgIGNvbnN0IHNsaWNlID0gKHMpID0+IChOdW1iZXIucGFyc2VJbnQoc1swXSwgMTYpICYgMGIxMDAwID8gJzAwJyArIHMgOiBzKTtcclxuICAgICAgICBjb25zdCBoID0gKG51bSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xyXG4gICAgICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBzID0gc2xpY2UoaChzaWcucykpO1xyXG4gICAgICAgIGNvbnN0IHIgPSBzbGljZShoKHNpZy5yKSk7XHJcbiAgICAgICAgY29uc3Qgc2hsID0gcy5sZW5ndGggLyAyO1xyXG4gICAgICAgIGNvbnN0IHJobCA9IHIubGVuZ3RoIC8gMjtcclxuICAgICAgICBjb25zdCBzbCA9IGgoc2hsKTtcclxuICAgICAgICBjb25zdCBybCA9IGgocmhsKTtcclxuICAgICAgICByZXR1cm4gYDMwJHtoKHJobCArIHNobCArIDQpfTAyJHtybH0ke3J9MDIke3NsfSR7c31gO1xyXG4gICAgfSxcclxufTtcclxuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXHJcbi8vIHByZXR0aWVyLWlnbm9yZVxyXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyksIF80biA9IEJpZ0ludCg0KTtcclxuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcclxuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XHJcbiAgICBjb25zdCB7IEZwIH0gPSBDVVJWRTsgLy8gQWxsIGN1cnZlcyBoYXMgc2FtZSBmaWVsZCAvIGdyb3VwIGxlbmd0aCBhcyBmb3Igbm93LCBidXQgdGhleSBjYW4gZGlmZmVyXHJcbiAgICBjb25zdCB0b0J5dGVzID0gQ1VSVkUudG9CeXRlcyB8fFxyXG4gICAgICAgICgoX2MsIHBvaW50LCBfaXNDb21wcmVzc2VkKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdXQuY29uY2F0Qnl0ZXMoVWludDhBcnJheS5mcm9tKFsweDA0XSksIEZwLnRvQnl0ZXMoYS54KSwgRnAudG9CeXRlcyhhLnkpKTtcclxuICAgICAgICB9KTtcclxuICAgIGNvbnN0IGZyb21CeXRlcyA9IENVUlZFLmZyb21CeXRlcyB8fFxyXG4gICAgICAgICgoYnl0ZXMpID0+IHtcclxuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xyXG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XHJcbiAgICAgICAgICAgIC8vIGlmIChoZWFkICE9PSAweDA0KSB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbm9uLWNvbXByZXNzZWQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xyXG4gICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xyXG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIHnCsiA9IHjCsyArIGF4ICsgYjogU2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgZm9ybXVsYVxyXG4gICAgICogQHJldHVybnMgecKyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xyXG4gICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XHJcbiAgICAgICAgY29uc3QgeDIgPSBGcC5zcXIoeCk7IC8vIHggKiB4XHJcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4MiAqIHhcclxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHgzICsgYSAqIHggKyBiXHJcbiAgICB9XHJcbiAgICAvLyBWYWxpZGF0ZSB3aGV0aGVyIHRoZSBwYXNzZWQgY3VydmUgcGFyYW1zIGFyZSB2YWxpZC5cclxuICAgIC8vIFdlIGNoZWNrIGlmIGN1cnZlIGVxdWF0aW9uIHdvcmtzIGZvciBnZW5lcmF0b3IgcG9pbnQuXHJcbiAgICAvLyBgYXNzZXJ0VmFsaWRpdHkoKWAgd29uJ3Qgd29yazogYGlzVG9yc2lvbkZyZWUoKWAgaXMgbm90IGF2YWlsYWJsZSBhdCB0aGlzIHBvaW50IGluIGJsczEyLTM4MS5cclxuICAgIC8vIFByb2plY3RpdmVQb2ludCBjbGFzcyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LlxyXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKENVUlZFLkd5KSwgd2VpZXJzdHJhc3NFcXVhdGlvbihDVVJWRS5HeCkpKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGdlbmVyYXRvciBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xyXG4gICAgLy8gVmFsaWQgZ3JvdXAgZWxlbWVudHMgcmVzaWRlIGluIHJhbmdlIDEuLm4tMVxyXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgbnVtID09PSAnYmlnaW50JyAmJiBfMG4gPCBudW0gJiYgbnVtIDwgQ1VSVkUubjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzc2VydEdFKG51bSkge1xyXG4gICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFsaWQgYmlnaW50OiAwIDwgYmlnaW50IDwgY3VydmUubicpO1xyXG4gICAgfVxyXG4gICAgLy8gVmFsaWRhdGVzIGlmIHByaXYga2V5IGlzIHZhbGlkIGFuZCBjb252ZXJ0cyBpdCB0byBiaWdpbnQuXHJcbiAgICAvLyBTdXBwb3J0cyBvcHRpb25zIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyBhbmQgd3JhcFByaXZhdGVLZXkuXHJcbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xyXG4gICAgICAgIGNvbnN0IHsgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiBsZW5ndGhzLCBuQnl0ZUxlbmd0aCwgd3JhcFByaXZhdGVLZXksIG4gfSA9IENVUlZFO1xyXG4gICAgICAgIGlmIChsZW5ndGhzICYmIHR5cGVvZiBrZXkgIT09ICdiaWdpbnQnKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxyXG4gICAgICAgICAgICAgICAga2V5ID0gdXQuYnl0ZXNUb0hleChrZXkpO1xyXG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gaGV4IHN0cmluZywgcGFkLiBFLmcuIFA1MjEgd291bGQgbm9ybSAxMzAtMTMyIGNoYXIgaGV4IHRvIDEzMi1jaGFyIGJ5dGVzXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCAhbGVuZ3Rocy5pbmNsdWRlcyhrZXkubGVuZ3RoKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXknKTtcclxuICAgICAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG51bTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBudW0gPVxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCdcclxuICAgICAgICAgICAgICAgICAgICA/IGtleVxyXG4gICAgICAgICAgICAgICAgICAgIDogdXQuYnl0ZXNUb051bWJlckJFKGVuc3VyZUJ5dGVzKCdwcml2YXRlIGtleScsIGtleSwgbkJ5dGVMZW5ndGgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJpdmF0ZSBrZXkgbXVzdCBiZSAke25CeXRlTGVuZ3RofSBieXRlcywgaGV4IG9yIGJpZ2ludCwgbm90ICR7dHlwZW9mIGtleX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxyXG4gICAgICAgICAgICBudW0gPSBtb2QubW9kKG51bSwgbik7IC8vIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGVuYWJsZWQgZm9yIEJMU1xyXG4gICAgICAgIGFzc2VydEdFKG51bSk7IC8vIG51bSBpbiByYW5nZSBbMS4uTi0xXVxyXG4gICAgICAgIHJldHVybiBudW07XHJcbiAgICB9XHJcbiAgICBjb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IE1hcCgpO1xyXG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcclxuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWQnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvamVjdGl2ZSBQb2ludCB3b3JrcyBpbiAzZCAvIHByb2plY3RpdmUgKGhvbW9nZW5lb3VzKSBjb29yZGluYXRlczogKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxyXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXHJcbiAgICAgKiBXZSdyZSBkb2luZyBjYWxjdWxhdGlvbnMgaW4gcHJvamVjdGl2ZSwgYmVjYXVzZSBpdHMgb3BlcmF0aW9ucyBkb24ndCByZXF1aXJlIGNvc3RseSBpbnZlcnNpb24uXHJcbiAgICAgKi9cclxuICAgIGNsYXNzIFBvaW50IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihweCwgcHksIHB6KSB7XHJcbiAgICAgICAgICAgIHRoaXMucHggPSBweDtcclxuICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xyXG4gICAgICAgICAgICB0aGlzLnB6ID0gcHo7XHJcbiAgICAgICAgICAgIGlmIChweCA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB4KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xyXG4gICAgICAgICAgICBpZiAocHkgPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweSkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcclxuICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6IHJlcXVpcmVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cclxuICAgICAgICAvLyBVc2UgZnJvbUhleCBpbnN0ZWFkLCBvciBjYWxsIGFzc2VydFZhbGlkaXR5KCkgbGF0ZXIuXHJcbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XHJcbiAgICAgICAgICAgIGlmICghcCB8fCAhRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcclxuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvamVjdGl2ZSBwb2ludCBub3QgYWxsb3dlZCcpO1xyXG4gICAgICAgICAgICBjb25zdCBpczAgPSAoaSkgPT4gRnAuZXFsKGksIEZwLlpFUk8pO1xyXG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXHJcbiAgICAgICAgICAgIGlmIChpczAoeCkgJiYgaXMwKHkpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0IHgoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0IHkoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcclxuICAgICAgICAgKiBpbnZlcnNpb24gb24gYWxsIG9mIHRoZW0uIEludmVyc2lvbiBpcyB2ZXJ5IHNsb3cgb3BlcmF0aW9uLFxyXG4gICAgICAgICAqIHNvIHRoaXMgaW1wcm92ZXMgcGVyZm9ybWFuY2UgbWFzc2l2ZWx5LlxyXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xyXG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGhhc2ggc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gUG9pbnQuXHJcbiAgICAgICAgICogQHBhcmFtIGhleCBzaG9ydC9sb25nIEVDRFNBIGhleFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xyXG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShmcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3BvaW50SGV4JywgaGV4KSkpO1xyXG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBQO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxyXG4gICAgICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBcIlByaXZhdGUgbWV0aG9kXCIsIGRvbid0IHVzZSBpdCBkaXJlY3RseVxyXG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB3aW5kb3dTaXplO1xyXG4gICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLmRlbGV0ZSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cclxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vICgwLCAxLCAwKSBha2EgWkVSTyBpcyBpbnZhbGlkIGluIG1vc3QgY29udGV4dHMuXHJcbiAgICAgICAgICAgICAgICAvLyBJbiBCTFMsIFpFUk8gY2FuIGJlIHNlcmlhbGl6ZWQsIHNvIHdlIGFsbG93IGl0LlxyXG4gICAgICAgICAgICAgICAgLy8gKDAsIDAsIDApIGlzIHdyb25nIHJlcHJlc2VudGF0aW9uIG9mIFpFUk8gYW5kIGlzIGFsd2F5cyBpbnZhbGlkLlxyXG4gICAgICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHRoaXMucHkpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU29tZSAzcmQtcGFydHkgdGVzdCB2ZWN0b3JzIHJlcXVpcmUgZGlmZmVyZW50IHdvcmRpbmcgYmV0d2VlbiBoZXJlICYgYGZyb21Db21wcmVzc2VkSGV4YFxyXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcclxuICAgICAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcclxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXHJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8geMKzICsgYXggKyBiXHJcbiAgICAgICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1RvcnNpb25GcmVlKCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhc0V2ZW5ZKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcclxuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICFGcC5pc09kZCh5KTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVxdWFscyhvdGhlcikge1xyXG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcclxuICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcclxuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcclxuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcclxuICAgICAgICAgICAgcmV0dXJuIFUxICYmIFUyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGbGlwcyBwb2ludCB0byBvbmUgY29ycmVzcG9uZGluZyB0byAoeCwgLXkpIGluIEFmZmluZSBjb29yZGluYXRlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBuZWdhdGUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5weCwgRnAubmVnKHRoaXMucHkpLCB0aGlzLnB6KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXHJcbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcclxuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxyXG4gICAgICAgIGRvdWJsZSgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcclxuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcclxuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXHJcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcclxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMSk7XHJcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjEpO1xyXG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcclxuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIHQzKTsgLy8gc3RlcCA1XHJcbiAgICAgICAgICAgIFozID0gRnAubXVsKFgxLCBaMSk7XHJcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XHJcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGEsIFozKTtcclxuICAgICAgICAgICAgWTMgPSBGcC5tdWwoYjMsIHQyKTtcclxuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxyXG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWTMpO1xyXG4gICAgICAgICAgICBZMyA9IEZwLmFkZCh0MSwgWTMpO1xyXG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xyXG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xyXG4gICAgICAgICAgICBaMyA9IEZwLm11bChiMywgWjMpOyAvLyBzdGVwIDE1XHJcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcclxuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDAsIHQyKTtcclxuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xyXG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xyXG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDIwXHJcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKFozLCB0MCk7XHJcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XHJcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQwLCB0Myk7XHJcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XHJcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcclxuICAgICAgICAgICAgdDIgPSBGcC5hZGQodDIsIHQyKTtcclxuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDIsIHQzKTtcclxuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcclxuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDIsIHQxKTtcclxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTsgLy8gc3RlcCAzMFxyXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cclxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxyXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxyXG4gICAgICAgIGFkZChvdGhlcikge1xyXG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcclxuICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcclxuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxyXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcclxuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoQ1VSVkUuYiwgXzNuKTtcclxuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxyXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcclxuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMik7XHJcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xyXG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XHJcbiAgICAgICAgICAgIHQzID0gRnAubXVsKHQzLCB0NCk7XHJcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XHJcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XHJcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKFgxLCBaMSk7XHJcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXHJcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XHJcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKHQwLCB0Mik7XHJcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XHJcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XHJcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKFkyLCBaMik7IC8vIHN0ZXAgMTVcclxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcclxuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcclxuICAgICAgICAgICAgdDUgPSBGcC5zdWIodDUsIFgzKTtcclxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xyXG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXHJcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFgzLCBaMyk7XHJcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XHJcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XHJcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBaMyk7XHJcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcclxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcclxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xyXG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xyXG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xyXG4gICAgICAgICAgICB0MiA9IEZwLnN1Yih0MCwgdDIpOyAvLyBzdGVwIDMwXHJcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcclxuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcclxuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDEsIHQ0KTtcclxuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcclxuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxyXG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xyXG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xyXG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xyXG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0NSwgWjMpO1xyXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlzMCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3TkFGKG4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBwb2ludFByZWNvbXB1dGVzLCBuLCAoY29tcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChjb21wLm1hcCgocCkgPT4gcC5weikpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxyXG4gICAgICAgICAqIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XHJcbiAgICAgICAgICogYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBtdWx0aXBseVVuc2FmZShuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IEkgPSBQb2ludC5aRVJPO1xyXG4gICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEk7XHJcbiAgICAgICAgICAgIGFzc2VydEdFKG4pOyAvLyBXaWxsIHRocm93IG9uIDBcclxuICAgICAgICAgICAgaWYgKG4gPT09IF8xbilcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xyXG4gICAgICAgICAgICBpZiAoIWVuZG8pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd25hZi51bnNhZmVMYWRkZXIodGhpcywgbik7XHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGVuZG9tb3JwaGlzbVxyXG4gICAgICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcclxuICAgICAgICAgICAgbGV0IGsxcCA9IEk7XHJcbiAgICAgICAgICAgIGxldCBrMnAgPSBJO1xyXG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxyXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoazIgJiBfMW4pXHJcbiAgICAgICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcclxuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xyXG4gICAgICAgICAgICAgICAgazEgPj49IF8xbjtcclxuICAgICAgICAgICAgICAgIGsyID4+PSBfMW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGsxbmVnKVxyXG4gICAgICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICBpZiAoazJuZWcpXHJcbiAgICAgICAgICAgICAgICBrMnAgPSBrMnAubmVnYXRlKCk7XHJcbiAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XHJcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXHJcbiAgICAgICAgICogVXNlcyB3TkFGIG1ldGhvZC4gV2luZG93ZWQgbWV0aG9kIG1heSBiZSAxMCUgZmFzdGVyLFxyXG4gICAgICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cclxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxyXG4gICAgICAgICAqIFVzZXMgZW5kb21vcnBoaXNtIGZvciBLb2JsaXR6IGN1cnZlcy5cclxuICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXHJcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XHJcbiAgICAgICAgICAgIGFzc2VydEdFKHNjYWxhcik7XHJcbiAgICAgICAgICAgIGxldCBuID0gc2NhbGFyO1xyXG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcclxuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcclxuICAgICAgICAgICAgaWYgKGVuZG8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcclxuICAgICAgICAgICAgICAgIGxldCB7IHA6IGsycCwgZjogZjJwIH0gPSB0aGlzLndOQUYoazIpO1xyXG4gICAgICAgICAgICAgICAgazFwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XHJcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcclxuICAgICAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XHJcbiAgICAgICAgICAgICAgICBwb2ludCA9IGsxcC5hZGQoazJwKTtcclxuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuKTtcclxuICAgICAgICAgICAgICAgIHBvaW50ID0gcDtcclxuICAgICAgICAgICAgICAgIGZha2UgPSBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBgemAgZm9yIGJvdGggcG9pbnRzLCBidXQgcmV0dXJuIG9ubHkgcmVhbCBvbmVcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50Lm5vcm1hbGl6ZVooW3BvaW50LCBmYWtlXSlbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVmZmljaWVudGx5IGNhbGN1bGF0ZSBgYVAgKyBiUWAuIFVuc2FmZSwgY2FuIGV4cG9zZSBwcml2YXRlIGtleSwgaWYgdXNlZCBpbmNvcnJlY3RseS5cclxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxyXG4gICAgICAgICAqIFRoZSB0cmljayBjb3VsZCBiZSB1c2VmdWwgaWYgYm90aCBQIGFuZCBRIGFyZSBub3QgRyAobm90IGluIG91ciBjYXNlKS5cclxuICAgICAgICAgKiBAcmV0dXJucyBub24temVybyBhZmZpbmUgcG9pbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IEcgPSBQb2ludC5CQVNFOyAvLyBObyBTdHJhdXNzLVNoYW1pciB0cmljazogd2UgaGF2ZSAxMCUgZmFzdGVyIEcgcHJlY29tcHV0ZXNcclxuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxyXG4gICAgICAgICAgICApID0+IChhID09PSBfMG4gfHwgYSA9PT0gXzFuIHx8ICFQLmVxdWFscyhHKSA/IFAubXVsdGlwbHlVbnNhZmUoYSkgOiBQLm11bHRpcGx5KGEpKTtcclxuICAgICAgICAgICAgY29uc3Qgc3VtID0gbXVsKHRoaXMsIGEpLmFkZChtdWwoUSwgYikpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXHJcbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXHJcbiAgICAgICAgLy8gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxyXG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IHgsIHB5OiB5LCBwejogeiB9ID0gdGhpcztcclxuICAgICAgICAgICAgY29uc3QgaXMwID0gdGhpcy5pczAoKTtcclxuICAgICAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXHJcbiAgICAgICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXHJcbiAgICAgICAgICAgIGlmIChpeiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XHJcbiAgICAgICAgICAgIGNvbnN0IGF4ID0gRnAubXVsKHgsIGl6KTtcclxuICAgICAgICAgICAgY29uc3QgYXkgPSBGcC5tdWwoeSwgaXopO1xyXG4gICAgICAgICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XHJcbiAgICAgICAgICAgIGlmIChpczApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBGcC5aRVJPLCB5OiBGcC5aRVJPIH07XHJcbiAgICAgICAgICAgIGlmICghRnAuZXFsKHp6LCBGcC5PTkUpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGF4LCB5OiBheSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBpc1RvcnNpb25GcmVlIH0gPSBDVVJWRTtcclxuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gc3ViZ3JvdXBzLCBhbHdheXMgdG9yc2lvbi1mcmVlXHJcbiAgICAgICAgICAgIGlmIChpc1RvcnNpb25GcmVlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBjbGVhckNvZmFjdG9yIH0gPSBDVVJWRTtcclxuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXHJcbiAgICAgICAgICAgIGlmIChjbGVhckNvZmFjdG9yKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyQ29mYWN0b3IoUG9pbnQsIHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xyXG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChGcC5aRVJPLCBGcC5PTkUsIEZwLlpFUk8pO1xyXG4gICAgY29uc3QgX2JpdHMgPSBDVVJWRS5uQml0TGVuZ3RoO1xyXG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQsIENVUlZFLmVuZG8gPyBNYXRoLmNlaWwoX2JpdHMgLyAyKSA6IF9iaXRzKTtcclxuICAgIC8vIFZhbGlkYXRlIGlmIGdlbmVyYXRvciBwb2ludCBpcyBvbiBjdXJ2ZVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBDVVJWRSxcclxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxyXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXHJcbiAgICAgICAgd2VpZXJzdHJhc3NFcXVhdGlvbixcclxuICAgICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xyXG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xyXG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xyXG4gICAgICAgIGhhc2g6ICdoYXNoJyxcclxuICAgICAgICBobWFjOiAnZnVuY3Rpb24nLFxyXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxyXG4gICAgfSwge1xyXG4gICAgICAgIGJpdHMyaW50OiAnZnVuY3Rpb24nLFxyXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXHJcbiAgICAgICAgbG93UzogJ2Jvb2xlYW4nLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzKGN1cnZlRGVmKSB7XHJcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XHJcbiAgICBjb25zdCB7IEZwLCBuOiBDVVJWRV9PUkRFUiB9ID0gQ1VSVkU7XHJcbiAgICBjb25zdCBjb21wcmVzc2VkTGVuID0gRnAuQllURVMgKyAxOyAvLyBlLmcuIDMzIGZvciAzMlxyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcclxuICAgIGZ1bmN0aW9uIGlzVmFsaWRGaWVsZEVsZW1lbnQobnVtKSB7XHJcbiAgICAgICAgcmV0dXJuIF8wbiA8IG51bSAmJiBudW0gPCBGcC5PUkRFUjsgLy8gMCBpcyBiYW5uZWQgc2luY2UgaXQncyBub3QgaW52ZXJ0aWJsZSBGRVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbW9kTihhKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vZC5tb2QoYSwgQ1VSVkVfT1JERVIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaW52TihhKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vZC5pbnZlcnQoYSwgQ1VSVkVfT1JERVIpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LCBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLCB3ZWllcnN0cmFzc0VxdWF0aW9uLCBpc1dpdGhpbkN1cnZlT3JkZXIsIH0gPSB3ZWllcnN0cmFzc1BvaW50cyh7XHJcbiAgICAgICAgLi4uQ1VSVkUsXHJcbiAgICAgICAgdG9CeXRlcyhfYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkge1xyXG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcclxuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMoYS54KTtcclxuICAgICAgICAgICAgY29uc3QgY2F0ID0gdXQuY29uY2F0Qnl0ZXM7XHJcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFtwb2ludC5oYXNFdmVuWSgpID8gMHgwMiA6IDB4MDNdKSwgeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCB4LCBGcC50b0J5dGVzKGEueSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmcm9tQnl0ZXMoYnl0ZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBoZWFkID0gYnl0ZXNbMF07XHJcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5hc3NlcnRWYWxpZGl0eSgpIGlzIGRvbmUgaW5zaWRlIG9mIGZyb21IZXhcclxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZCA9PT0gMHgwMiB8fCBoZWFkID09PSAweDAzKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHV0LmJ5dGVzVG9OdW1iZXJCRSh0YWlsKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEZpZWxkRWxlbWVudCh4KSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcclxuICAgICAgICAgICAgICAgIGxldCB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc1lPZGQgPSAoeSAmIF8xbikgPT09IF8xbjtcclxuICAgICAgICAgICAgICAgIC8vIEVDRFNBXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzSGVhZE9kZCAhPT0gaXNZT2RkKVxyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBGcC5uZWcoeSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobGVuID09PSB1bmNvbXByZXNzZWRMZW4gJiYgaGVhZCA9PT0gMHgwNCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2ludCBvZiBsZW5ndGggJHtsZW59IHdhcyBpbnZhbGlkLiBFeHBlY3RlZCAke2NvbXByZXNzZWRMZW59IGNvbXByZXNzZWQgYnl0ZXMgb3IgJHt1bmNvbXByZXNzZWRMZW59IHVuY29tcHJlc3NlZCBieXRlc2ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IHV0LmJ5dGVzVG9IZXgodXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpKTtcclxuICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcclxuICAgICAgICBjb25zdCBIQUxGID0gQ1VSVkVfT1JERVIgPj4gXzFuO1xyXG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUyhzKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcclxuICAgIH1cclxuICAgIC8vIHNsaWNlIGJ5dGVzIG51bVxyXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiB1dC5ieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFQ0RTQSBzaWduYXR1cmUgd2l0aCBpdHMgKHIsIHMpIHByb3BlcnRpZXMuIFN1cHBvcnRzIERFUiAmIGNvbXBhY3QgcmVwcmVzZW50YXRpb25zLlxyXG4gICAgICovXHJcbiAgICBjbGFzcyBTaWduYXR1cmUge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHIsIHMsIHJlY292ZXJ5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XHJcbiAgICAgICAgICAgIHRoaXMucyA9IHM7XHJcbiAgICAgICAgICAgIHRoaXMucmVjb3ZlcnkgPSByZWNvdmVyeTtcclxuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwYWlyIChieXRlcyBvZiByLCBieXRlcyBvZiBzKVxyXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcclxuICAgICAgICAgICAgY29uc3QgbCA9IENVUlZFLm5CeXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICBoZXggPSBlbnN1cmVCeXRlcygnY29tcGFjdFNpZ25hdHVyZScsIGhleCwgbCAqIDIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gREVSIGVuY29kZWQgRUNEU0Egc2lnbmF0dXJlXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxyXG4gICAgICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IERFUi50b1NpZyhlbnN1cmVCeXRlcygnREVSJywgaGV4KSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcclxuICAgICAgICAgICAgLy8gY2FuIHVzZSBhc3NlcnRHRSBoZXJlXHJcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucikpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3IgbXVzdCBiZSAwIDwgciA8IENVUlZFLm4nKTtcclxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5zKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncyBtdXN0IGJlIDAgPCBzIDwgQ1VSVkUubicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcclxuICAgICAgICAgICAgY29uc3QgeyByLCBzLCByZWNvdmVyeTogcmVjIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxyXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCBpbnZhbGlkJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xyXG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgMiBvciAzIGludmFsaWQnKTtcclxuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gKHJlYyAmIDEpID09PSAwID8gJzAyJyA6ICcwMyc7XHJcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xyXG4gICAgICAgICAgICBjb25zdCBpciA9IGludk4ocmFkaik7IC8vIHJeLTFcclxuICAgICAgICAgICAgY29uc3QgdTEgPSBtb2ROKC1oICogaXIpOyAvLyAtaHJeLTFcclxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXHJcbiAgICAgICAgICAgIGNvbnN0IFEgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFIsIHUxLCB1Mik7IC8vIChzcl4tMSlSLShocl4tMSlHID0gLShocl4tMSlHICsgKHNyXi0xKVxyXG4gICAgICAgICAgICBpZiAoIVEpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXHJcbiAgICAgICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcclxuICAgICAgICAgICAgcmV0dXJuIFE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNpZ25hdHVyZXMgc2hvdWxkIGJlIGxvdy1zLCB0byBwcmV2ZW50IG1hbGxlYWJpbGl0eS5cclxuICAgICAgICBoYXNIaWdoUygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBub3JtYWxpemVTKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gREVSLWVuY29kZWRcclxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvREVSSGV4KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b0RFUkhleCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIERFUi5oZXhGcm9tU2lnKHsgcjogdGhpcy5yLCBzOiB0aGlzLnMgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXHJcbiAgICAgICAgdG9Db21wYWN0UmF3Qnl0ZXMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9Db21wYWN0SGV4KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b0NvbXBhY3RIZXgoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1Ub05CeXRlU3RyKHRoaXMucikgKyBudW1Ub05CeXRlU3RyKHRoaXMucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgdXRpbHMgPSB7XHJcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb2R1Y2VzIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwcml2YXRlIGtleSBmcm9tIHJhbmRvbSBvZiBzaXplXHJcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1vZC5tYXBIYXNoVG9GaWVsZChDVVJWRS5yYW5kb21CeXRlcyhsZW5ndGgpLCBDVVJWRS5uKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgcHJlY29tcHV0ZSB0YWJsZSBmb3IgYW4gYXJiaXRyYXJ5IEVDIHBvaW50LiBNYWtlcyBwb2ludCBcImNhY2hlZFwiLlxyXG4gICAgICAgICAqIEFsbG93cyB0byBtYXNzaXZlbHkgc3BlZWQtdXAgYHBvaW50Lm11bHRpcGx5KHNjYWxhcilgLlxyXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogY29uc3QgZmFzdCA9IHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoc29tZW9uZXNQdWJLZXkpKTtcclxuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xyXG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcclxuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTsgLy8gMyBpcyBhcmJpdHJhcnksIGp1c3QgbmVlZCBhbnkgbnVtYmVyIGhlcmVcclxuICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cclxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IHByaXZhdGUga2V5XHJcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxyXG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1Byb2JQdWIoaXRlbSkge1xyXG4gICAgICAgIGNvbnN0IGFyciA9IGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5O1xyXG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcclxuICAgICAgICBjb25zdCBsZW4gPSAoYXJyIHx8IHN0cikgJiYgaXRlbS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGFycilcclxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcclxuICAgICAgICBpZiAoc3RyKVxyXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSAyICogY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IDIgKiB1bmNvbXByZXNzZWRMZW47XHJcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hbikuXHJcbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxyXG4gICAgICogQ2hlY2tzOiAxKSBwcml2YXRlIGtleSB2YWxpZGl0eSAyKSBzaGFyZWQga2V5IGlzIG9uLWN1cnZlLlxyXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxyXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XHJcbiAgICAgKiBAcGFyYW0gcHVibGljQiBkaWZmZXJlbnQgcHVibGljIGtleVxyXG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcclxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZyBtdXN0IGJlIHByaXZhdGUga2V5Jyk7XHJcbiAgICAgICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcclxuICAgICAgICBjb25zdCBiID0gUG9pbnQuZnJvbUhleChwdWJsaWNCKTsgLy8gY2hlY2sgZm9yIGJlaW5nIG9uLWN1cnZlXHJcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcclxuICAgIH1cclxuICAgIC8vIFJGQzY5Nzk6IGVuc3VyZSBFQ0RTQSBtc2cgaXMgWCBieXRlcyBhbmQgPCBOLiBSRkMgc3VnZ2VzdHMgb3B0aW9uYWwgdHJ1bmNhdGluZyB2aWEgYml0czJvY3RldHMuXHJcbiAgICAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2ggbWF0Y2hlcyBiaXRzMmludC5cclxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cclxuICAgIC8vIGludDJvY3RldHMgY2FuJ3QgYmUgdXNlZDsgcGFkcyBzbWFsbCBtc2dzIHdpdGggMDogdW5hY2NlcHRhdGJsZSBmb3IgdHJ1bmMgYXMgcGVyIFJGQyB2ZWN0b3JzXHJcbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBjdXJ2ZXMgd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMDogYml0czJvY3RldHMoYml0czJvY3RldHMobSkpICE9PSBiaXRzMm9jdGV0cyhtKVxyXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cclxuICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxyXG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGJ5dGVzLmxlbmd0aCAqIDggLSBDVVJWRS5uQml0TGVuZ3RoOyAvLyB0cnVuY2F0ZSB0byBuQml0TGVuZ3RoIGxlZnRtb3N0IGJpdHNcclxuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xyXG4gICAgICAgIH07XHJcbiAgICBjb25zdCBiaXRzMmludF9tb2ROID0gQ1VSVkUuYml0czJpbnRfbW9kTiB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcclxuICAgICAgICB9O1xyXG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXHJcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gdXQuYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaW50Mm9jdGV0cyhudW0pIHtcclxuICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmlnaW50IGV4cGVjdGVkJyk7XHJcbiAgICAgICAgaWYgKCEoXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUl9NQVNLKSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gKTtcclxuICAgICAgICAvLyB3b3JrcyB3aXRoIG9yZGVyLCBjYW4gaGF2ZSBkaWZmZXJlbnQgc2l6ZSB0aGFuIG51bVRvRmllbGQhXHJcbiAgICAgICAgcmV0dXJuIHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKTtcclxuICAgIH1cclxuICAgIC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjJcclxuICAgIC8vIENyZWF0ZXMgUkZDNjk3OSBzZWVkOyBjb252ZXJ0cyBtc2cvcHJpdktleSB0byBudW1iZXJzLlxyXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXHJcbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtc2dIYXNoIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlciwgdGhpcyB3aWxsIGJlIHdyb25nIGF0IGxlYXN0IGZvciBQNTIxLlxyXG4gICAgLy8gQWxzbyBpdCBjYW4gYmUgYmlnZ2VyIGZvciBQMjI0ICsgU0hBMjU2XHJcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xyXG4gICAgICAgIGlmIChbJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24oKSBsZWdhY3kgb3B0aW9ucyBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XHJcbiAgICAgICAgbGV0IHsgbG93UywgcHJlaGFzaCwgZXh0cmFFbnRyb3B5OiBlbnQgfSA9IG9wdHM7IC8vIGdlbmVyYXRlcyBsb3ctcyBzaWdzIGJ5IGRlZmF1bHRcclxuICAgICAgICBpZiAobG93UyA9PSBudWxsKVxyXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXHJcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XHJcbiAgICAgICAgaWYgKHByZWhhc2gpXHJcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygncHJlaGFzaGVkIG1zZ0hhc2gnLCBoYXNoKG1zZ0hhc2gpKTtcclxuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcclxuICAgICAgICAvLyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwLiBCZWNhdXNlIG9mIHRoYXQsIHdlIHVud3JhcCBpdCBoZXJlIGFzIGludDJvY3RldHMgY2FsbC5cclxuICAgICAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXHJcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xyXG4gICAgICAgIGNvbnN0IGQgPSBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpOyAvLyB2YWxpZGF0ZSBwcml2YXRlIGtleSwgY29udmVydCB0byBiaWdpbnRcclxuICAgICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XHJcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxyXG4gICAgICAgIGlmIChlbnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcclxuICAgICAgICAgICAgY29uc3QgZSA9IGVudCA9PT0gdHJ1ZSA/IHJhbmRvbUJ5dGVzKEZwLkJZVEVTKSA6IGVudDsgLy8gZ2VuZXJhdGUgcmFuZG9tIGJ5dGVzIE9SIHBhc3MgYXMtaXNcclxuICAgICAgICAgICAgc2VlZEFyZ3MucHVzaChlbnN1cmVCeXRlcygnZXh0cmFFbnRyb3B5JywgZSkpOyAvLyBjaGVjayBmb3IgYmVpbmcgYnl0ZXNcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2VlZCA9IHV0LmNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTsgLy8gU3RlcCBEIG9mIFJGQzY5NzkgMy4yXHJcbiAgICAgICAgY29uc3QgbSA9IGgxaW50OyAvLyBOT1RFOiBubyBuZWVkIHRvIGNhbGwgYml0czJpbnQgc2Vjb25kIHRpbWUgaGVyZSwgaXQgaXMgaW5zaWRlIHRydW5jYXRlSGFzaCFcclxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxyXG4gICAgICAgIGZ1bmN0aW9uIGsyc2lnKGtCeXRlcykge1xyXG4gICAgICAgICAgICAvLyBSRkMgNjk3OSBTZWN0aW9uIDMuMiwgc3RlcCAzOiBrID0gYml0czJpbnQoVClcclxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcclxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIoaykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEltcG9ydGFudDogYWxsIG1vZCgpIGNhbGxzIGhlcmUgbXVzdCBiZSBkb25lIG92ZXIgTlxyXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cclxuICAgICAgICAgICAgY29uc3QgcSA9IFBvaW50LkJBU0UubXVsdGlwbHkoaykudG9BZmZpbmUoKTsgLy8gcSA9IEdrXHJcbiAgICAgICAgICAgIGNvbnN0IHIgPSBtb2ROKHEueCk7IC8vIHIgPSBxLnggbW9kIG5cclxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgLy8gQ2FuIHVzZSBzY2FsYXIgYmxpbmRpbmcgYl4tMShibSArIGJkcikgd2hlcmUgYiDiiIggWzEsceKIkjFdIGFjY29yZGluZyB0b1xyXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XHJcbiAgICAgICAgICAgIC8vIGEpIGRlcGVuZGVuY3kgb24gQ1NQUk5HIGIpIDE1JSBzbG93ZG93biBjKSBkb2Vzbid0IHJlYWxseSBoZWxwIHNpbmNlIGJpZ2ludHMgYXJlIG5vdCBDVFxyXG4gICAgICAgICAgICBjb25zdCBzID0gbW9kTihpayAqIG1vZE4obSArIHIgKiBkKSk7IC8vIE5vdCB1c2luZyBibGluZGluZyBoZXJlXHJcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGxldCByZWNvdmVyeSA9IChxLnggPT09IHIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgXzFuKTsgLy8gcmVjb3ZlcnkgYml0ICgyIG9yIDMsIHdoZW4gcS54ID4gbilcclxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcclxuICAgICAgICAgICAgaWYgKGxvd1MgJiYgaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpKSB7XHJcbiAgICAgICAgICAgICAgICBub3JtUyA9IG5vcm1hbGl6ZVMocyk7IC8vIGlmIGxvd1Mgd2FzIHBhc3NlZCwgZW5zdXJlIHMgaXMgYWx3YXlzXHJcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCByZWNvdmVyeSk7IC8vIHVzZSBub3JtUywgbm90IHNcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xyXG4gICAgY29uc3QgZGVmYXVsdFZlck9wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XHJcbiAgICAvKipcclxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXHJcbiAgICAgKiBgYGBcclxuICAgICAqIHNpZ24obSwgZCwgaykgd2hlcmVcclxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXHJcbiAgICAgKiAgIHIgPSB4IG1vZCBuXHJcbiAgICAgKiAgIHMgPSAobSArIGRyKS9rIG1vZCBuXHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBtc2dIYXNoIE5PVCBtZXNzYWdlLiBtc2cgbmVlZHMgdG8gYmUgaGFzaGVkIHRvIGBtc2dIYXNoYCwgb3IgdXNlIGBwcmVoYXNoYC5cclxuICAgICAqIEBwYXJhbSBwcml2S2V5IHByaXZhdGUga2V5XHJcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXHJcbiAgICAgKiBAcmV0dXJucyBzaWduYXR1cmUgd2l0aCByZWNvdmVyeSBwYXJhbVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xyXG4gICAgICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobXNnSGFzaCwgcHJpdktleSwgb3B0cyk7IC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXHJcbiAgICAgICAgY29uc3QgQyA9IENVUlZFO1xyXG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xyXG4gICAgICAgIHJldHVybiBkcmJnKHNlZWQsIGsyc2lnKTsgLy8gU3RlcHMgQiwgQywgRCwgRSwgRiwgR1xyXG4gICAgfVxyXG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxyXG4gICAgUG9pbnQuQkFTRS5fc2V0V2luZG93U2l6ZSg4KTtcclxuICAgIC8vIHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LkJBU0UpXHJcbiAgICAvKipcclxuICAgICAqIFZlcmlmaWVzIGEgc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBoYXNoIGFuZCBwdWJsaWMga2V5LlxyXG4gICAgICogUmVqZWN0cyBsb3dTIHNpZ25hdHVyZXMgYnkgZGVmYXVsdDogdG8gb3ZlcnJpZGUsXHJcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxyXG4gICAgICpcclxuICAgICAqIGBgYFxyXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXHJcbiAgICAgKiAgIFUxID0gaHNeLTEgbW9kIG5cclxuICAgICAqICAgVTIgPSByc14tMSBtb2QgblxyXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXHJcbiAgICAgKiAgIG1vZChSLngsIG4pID09IHJcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnbmF0dXJlLCBtc2dIYXNoLCBwdWJsaWNLZXksIG9wdHMgPSBkZWZhdWx0VmVyT3B0cykge1xyXG4gICAgICAgIGNvbnN0IHNnID0gc2lnbmF0dXJlO1xyXG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xyXG4gICAgICAgIHB1YmxpY0tleSA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXkpO1xyXG4gICAgICAgIGlmICgnc3RyaWN0JyBpbiBvcHRzKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcclxuICAgICAgICBjb25zdCB7IGxvd1MsIHByZWhhc2ggfSA9IG9wdHM7XHJcbiAgICAgICAgbGV0IF9zaWcgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IFA7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZyA9PT0gJ3N0cmluZycgfHwgc2cgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXHJcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGRlckVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tQ29tcGFjdChzZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNnID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygc2cuciA9PT0gJ2JpZ2ludCcgJiYgdHlwZW9mIHNnLnMgPT09ICdiaWdpbnQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xyXG4gICAgICAgICAgICAgICAgX3NpZyA9IG5ldyBTaWduYXR1cmUociwgcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BBUlNFJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduYXR1cmUgbXVzdCBiZSBTaWduYXR1cmUgaW5zdGFuY2UsIFVpbnQ4QXJyYXkgb3IgaGV4IHN0cmluZ2ApO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsb3dTICYmIF9zaWcuaGFzSGlnaFMoKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChwcmVoYXNoKVxyXG4gICAgICAgICAgICBtc2dIYXNoID0gQ1VSVkUuaGFzaChtc2dIYXNoKTtcclxuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IF9zaWc7XHJcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcclxuICAgICAgICBjb25zdCBpcyA9IGludk4ocyk7IC8vIHNeLTFcclxuICAgICAgICBjb25zdCB1MSA9IG1vZE4oaCAqIGlzKTsgLy8gdTEgPSBoc14tMSBtb2QgblxyXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXHJcbiAgICAgICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdTEsIHUyKT8udG9BZmZpbmUoKTsgLy8gUiA9IHUx4ouFRyArIHUy4ouFUFxyXG4gICAgICAgIGlmICghUilcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IHYgPSBtb2ROKFIueCk7XHJcbiAgICAgICAgcmV0dXJuIHYgPT09IHI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIENVUlZFLFxyXG4gICAgICAgIGdldFB1YmxpY0tleSxcclxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQsXHJcbiAgICAgICAgc2lnbixcclxuICAgICAgICB2ZXJpZnksXHJcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcclxuICAgICAgICBTaWduYXR1cmUsXHJcbiAgICAgICAgdXRpbHMsXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2hhbGx1ZSBhbmQgdmFuIGRlIFdvZXN0aWpuZSBtZXRob2QgZm9yIGFueSB3ZWllcnN0cmFzcyBjdXJ2ZS5cclxuICogVE9ETzogY2hlY2sgaWYgdGhlcmUgaXMgYSB3YXkgdG8gbWVyZ2UgdGhpcyB3aXRoIHV2UmF0aW8gaW4gRWR3YXJkczsgbW92ZSB0byBtb2R1bGFyLlxyXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxyXG4gKiBiID0gRmFsc2UgYW5kIHkgPSBzcXJ0KFogKiAodSAvIHYpKSBvdGhlcndpc2UuXHJcbiAqIEBwYXJhbSBGcFxyXG4gKiBAcGFyYW0gWlxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XHJcbiAgICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXHJcbiAgICBjb25zdCBxID0gRnAuT1JERVI7XHJcbiAgICBsZXQgbCA9IF8wbjtcclxuICAgIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKVxyXG4gICAgICAgIGwgKz0gXzFuO1xyXG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxyXG4gICAgLy8gV2UgbmVlZCAybiAqKiBjMSBhbmQgMm4gKiogKGMxLTEpLiBXZSBjYW4ndCB1c2UgKio7IGJ1dCB3ZSBjYW4gdXNlIDw8LlxyXG4gICAgLy8gMm4gKiogYzEgPT0gMm4gPDwgKGMxLTEpXHJcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcclxuICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XHJcbiAgICBjb25zdCBjMiA9IChxIC0gXzFuKSAvIF8ybl9wb3dfYzE7IC8vIDIuIGMyID0gKHEgLSAxKSAvICgyXmMxKSAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcclxuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xyXG4gICAgY29uc3QgYzQgPSBfMm5fcG93X2MxIC0gXzFuOyAvLyA0LiBjNCA9IDJeYzEgLSAxICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXHJcbiAgICBjb25zdCBjNSA9IF8ybl9wb3dfYzFfMTsgLy8gNS4gYzUgPSAyXihjMSAtIDEpICAgICAgICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcclxuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXHJcbiAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW4pIC8gXzJuKTsgLy8gNy4gYzcgPSBaXigoYzIgKyAxKSAvIDIpXHJcbiAgICBsZXQgc3FydFJhdGlvID0gKHUsIHYpID0+IHtcclxuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XHJcbiAgICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcclxuICAgICAgICBsZXQgdHYzID0gRnAuc3FyKHR2Mik7IC8vIDMuIHR2MyA9IHR2Ml4yXHJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcclxuICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcclxuICAgICAgICB0djUgPSBGcC5wb3codHY1LCBjMyk7IC8vIDYuIHR2NSA9IHR2NV5jM1xyXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XHJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2NSwgdSk7IC8vIDkuIHR2MyA9IHR2NSAqIHVcclxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxyXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxyXG4gICAgICAgIGxldCBpc1FSID0gRnAuZXFsKHR2NSwgRnAuT05FKTsgLy8gMTIuIGlzUVIgPSB0djUgPT0gMVxyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XHJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxyXG4gICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGlzUVIpOyAvLyAxNS4gdHYzID0gQ01PVih0djIsIHR2MywgaXNRUilcclxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXHJcbiAgICAgICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxyXG4gICAgICAgIGZvciAobGV0IGkgPSBjMTsgaSA+IF8xbjsgaS0tKSB7XHJcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcclxuICAgICAgICAgICAgdHY1ID0gXzJuIDw8ICh0djUgLSBfMW4pOyAvLyAxOS4gICAgdHY1ID0gMl50djVcclxuICAgICAgICAgICAgbGV0IHR2djUgPSBGcC5wb3codHY0LCB0djUpOyAvLyAyMC4gICAgdHY1ID0gdHY0XnR2NVxyXG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxyXG4gICAgICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpOyAvLyAyMi4gICAgdHYyID0gdHYzICogdHYxXHJcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2MSk7IC8vIDIzLiAgICB0djEgPSB0djEgKiB0djFcclxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcclxuICAgICAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpOyAvLyAyNS4gICAgdHYzID0gQ01PVih0djIsIHR2MywgZTEpXHJcbiAgICAgICAgICAgIHR2NCA9IEZwLmNtb3YodHZ2NSwgdHY0LCBlMSk7IC8vIDI2LiAgICB0djQgPSBDTU9WKHR2NSwgdHY0LCBlMSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xyXG4gICAgfTtcclxuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XHJcbiAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxyXG4gICAgICAgIGNvbnN0IGMxID0gKEZwLk9SREVSIC0gXzNuKSAvIF80bjsgLy8gMS4gYzEgPSAocSAtIDMpIC8gNCAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcclxuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxyXG4gICAgICAgIHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB0djEgPSBGcC5zcXIodik7IC8vIDEuIHR2MSA9IHZeMlxyXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XHJcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxyXG4gICAgICAgICAgICBsZXQgeTEgPSBGcC5wb3codHYxLCBjMSk7IC8vIDQuIHkxID0gdHYxXmMxXHJcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXHJcbiAgICAgICAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxyXG4gICAgICAgICAgICBjb25zdCB0djMgPSBGcC5tdWwoRnAuc3FyKHkxKSwgdik7IC8vIDcuIHR2MyA9IHkxXjI7IDguIHR2MyA9IHR2MyAqIHZcclxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcclxuICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXHJcbiAgICAgICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB5IH07IC8vIDExLiByZXR1cm4gKGlzUVIsIHkpIGlzUVIgPyB5IDogeSpjMlxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBObyBjdXJ2ZXMgdXNlcyB0aGF0XHJcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxyXG4gICAgcmV0dXJuIHNxcnRSYXRpbztcclxufVxyXG4vKipcclxuICogU2ltcGxpZmllZCBTaGFsbHVlLXZhbiBkZSBXb2VzdGlqbmUtVWxhcyBNZXRob2RcclxuICogaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi02LjYuMlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIG9wdHMpIHtcclxuICAgIG1vZC52YWxpZGF0ZUZpZWxkKEZwKTtcclxuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xyXG4gICAgY29uc3Qgc3FydFJhdGlvID0gU1dVRnBTcXJ0UmF0aW8oRnAsIG9wdHMuWik7XHJcbiAgICBpZiAoIUZwLmlzT2RkKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnAuaXNPZGQgaXMgbm90IGltcGxlbWVudGVkIScpO1xyXG4gICAgLy8gSW5wdXQ6IHUsIGFuIGVsZW1lbnQgb2YgRi5cclxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXHJcbiAgICByZXR1cm4gKHUpID0+IHtcclxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcclxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcclxuICAgICAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcclxuICAgICAgICB0djEgPSBGcC5tdWwodHYxLCBvcHRzLlopOyAvLyAyLiAgdHYxID0gWiAqIHR2MVxyXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcclxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXHJcbiAgICAgICAgdHYzID0gRnAuYWRkKHR2MiwgRnAuT05FKTsgLy8gNS4gIHR2MyA9IHR2MiArIDFcclxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xyXG4gICAgICAgIHR2NCA9IEZwLmNtb3Yob3B0cy5aLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXHJcbiAgICAgICAgdHY0ID0gRnAubXVsKHR2NCwgb3B0cy5BKTsgLy8gOC4gIHR2NCA9IEEgKiB0djRcclxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXHJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxyXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQSk7IC8vIDExLiB0djUgPSBBICogdHY2XHJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcclxuICAgICAgICB0djYgPSBGcC5tdWwodHY2LCB0djQpOyAvLyAxNC4gdHY2ID0gdHY2ICogdHY0XHJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcclxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XHJcbiAgICAgICAgeCA9IEZwLm11bCh0djEsIHR2Myk7IC8vIDE3LiAgIHggPSB0djEgKiB0djNcclxuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXHJcbiAgICAgICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXHJcbiAgICAgICAgeSA9IEZwLm11bCh5LCB2YWx1ZSk7IC8vIDIwLiAgIHkgPSB5ICogeTFcclxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXHJcbiAgICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcclxuICAgICAgICBjb25zdCBlMSA9IEZwLmlzT2RkKHUpID09PSBGcC5pc09kZCh5KTsgLy8gMjMuICBlMSA9IHNnbjAodSkgPT0gc2duMCh5KVxyXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXHJcbiAgICAgICAgeCA9IEZwLmRpdih4LCB0djQpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxyXG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2VpZXJzdHJhc3MuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/curves/esm/secp256k1.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/esm/secp256k1.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\r\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\r\nconst _1n = BigInt(1);\r\nconst _2n = BigInt(2);\r\nconst divNearest = (a, b) => (a + b / _2n) / b;\r\n/**\r\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\r\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\r\n */\r\nfunction sqrtMod(y) {\r\n    const P = secp256k1P;\r\n    // prettier-ignore\r\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\r\n    // prettier-ignore\r\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\r\n    const b2 = (y * y * y) % P; // x^3, 11\r\n    const b3 = (b2 * b2 * y) % P; // x^7\r\n    const b6 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3) % P;\r\n    const b9 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3) % P;\r\n    const b11 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2) % P;\r\n    const b22 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11) % P;\r\n    const b44 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22) % P;\r\n    const b88 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44) % P;\r\n    const b176 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88) % P;\r\n    const b220 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44) % P;\r\n    const b223 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3) % P;\r\n    const t1 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22) % P;\r\n    const t2 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2) % P;\r\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\r\n    if (!Fp.eql(Fp.sqr(root), y))\r\n        throw new Error('Cannot find square root');\r\n    return root;\r\n}\r\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\r\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\r\n    a: BigInt(0),\r\n    b: BigInt(7),\r\n    Fp,\r\n    n: secp256k1N,\r\n    // Base point (x, y) aka generator point\r\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\r\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\r\n    h: BigInt(1),\r\n    lowS: true,\r\n    /**\r\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\r\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\r\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\r\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\r\n     */\r\n    endo: {\r\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\r\n        splitScalar: (k) => {\r\n            const n = secp256k1N;\r\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\r\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\r\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\r\n            const b2 = a1;\r\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\r\n            const c1 = divNearest(b2 * k, n);\r\n            const c2 = divNearest(-b1 * k, n);\r\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\r\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\r\n            const k1neg = k1 > POW_2_128;\r\n            const k2neg = k2 > POW_2_128;\r\n            if (k1neg)\r\n                k1 = n - k1;\r\n            if (k2neg)\r\n                k2 = n - k2;\r\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\r\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\r\n            }\r\n            return { k1neg, k1, k2neg, k2 };\r\n        },\r\n    },\r\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\r\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\r\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\r\nconst _0n = BigInt(0);\r\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\r\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\r\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\r\nconst TAGGED_HASH_PREFIXES = {};\r\nfunction taggedHash(tag, ...messages) {\r\n    let tagP = TAGGED_HASH_PREFIXES[tag];\r\n    if (tagP === undefined) {\r\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\r\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\r\n        TAGGED_HASH_PREFIXES[tag] = tagP;\r\n    }\r\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\r\n}\r\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\r\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\r\nconst numTo32b = (n) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\r\nconst modP = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\r\nconst modN = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\r\nconst Point = secp256k1.ProjectivePoint;\r\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\r\n// Calculate point, scalar and bytes\r\nfunction schnorrGetExtPubKey(priv) {\r\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\r\n    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\r\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\r\n    return { scalar: scalar, bytes: pointToBytes(p) };\r\n}\r\n/**\r\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\r\n * @returns valid point checked for being on-curve\r\n */\r\nfunction lift_x(x) {\r\n    if (!fe(x))\r\n        throw new Error('bad x: need 0 < x < p'); // Fail if x  p.\r\n    const xx = modP(x * x);\r\n    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.\r\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\r\n    if (y % _2n !== _0n)\r\n        y = modP(-y); // Return the unique point P such that x(P) = x and\r\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\r\n    p.assertValidity();\r\n    return p;\r\n}\r\n/**\r\n * Create tagged hash, convert it to bigint, reduce modulo-n.\r\n */\r\nfunction challenge(...args) {\r\n    return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\r\n}\r\n/**\r\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\r\n */\r\nfunction schnorrGetPublicKey(privateKey) {\r\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\r\n}\r\n/**\r\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\r\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\r\n */\r\nfunction schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\r\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\r\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\r\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\r\n    const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\r\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\r\n    const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\r\n    if (k_ === _0n)\r\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\r\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\r\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\r\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\r\n    sig.set(rx, 0);\r\n    sig.set(numTo32b(modN(k + e * d)), 32);\r\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\r\n    if (!schnorrVerify(sig, m, px))\r\n        throw new Error('sign: Invalid signature produced');\r\n    return sig;\r\n}\r\n/**\r\n * Verifies Schnorr signature.\r\n * Will swallow errors & return false except for initial type validation of arguments.\r\n */\r\nfunction schnorrVerify(signature, message, publicKey) {\r\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('signature', signature, 64);\r\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\r\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('publicKey', publicKey, 32);\r\n    try {\r\n        const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\r\n        const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\r\n        if (!fe(r))\r\n            return false;\r\n        const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\r\n        if (!ge(s))\r\n            return false;\r\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\r\n        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP\r\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\r\n            return false; // -eP == (n-e)P\r\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\r\n    }\r\n    catch (error) {\r\n        return false;\r\n    }\r\n}\r\nconst schnorr = /* @__PURE__ */ (() => ({\r\n    getPublicKey: schnorrGetPublicKey,\r\n    sign: schnorrSign,\r\n    verify: schnorrVerify,\r\n    utils: {\r\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\r\n        lift_x,\r\n        pointToBytes,\r\n        numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\r\n        bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\r\n        taggedHash,\r\n        mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod,\r\n    },\r\n}))();\r\nconst isoMap = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fp, [\r\n    // xNum\r\n    [\r\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\r\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\r\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\r\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\r\n    ],\r\n    // xDen\r\n    [\r\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\r\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\r\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\r\n    ],\r\n    // yNum\r\n    [\r\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\r\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\r\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\r\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\r\n    ],\r\n    // yDen\r\n    [\r\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\r\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\r\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\r\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\r\n    ],\r\n].map((i) => i.map((j) => BigInt(j)))))();\r\nconst mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fp, {\r\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\r\n    B: BigInt('1771'),\r\n    Z: Fp.create(BigInt('-11')),\r\n}))();\r\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars) => {\r\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\r\n    return isoMap(x, y);\r\n}, {\r\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\r\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\r\n    p: Fp.ORDER,\r\n    m: 1,\r\n    k: 128,\r\n    expand: 'xmd',\r\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256,\r\n}))();\r\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\r\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\r\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUM4QztBQUNJO0FBQ087QUFDTztBQUNpQztBQUMxQjtBQUN0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLGdCQUFnQiwwREFBSTtBQUNwQixnQkFBZ0IsMERBQUk7QUFDcEIsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGtCQUFrQiwwREFBSTtBQUN0QixrQkFBa0IsMERBQUk7QUFDdEIsa0JBQWtCLDBEQUFJO0FBQ3RCLGdCQUFnQiwwREFBSTtBQUNwQixnQkFBZ0IsMERBQUk7QUFDcEIsaUJBQWlCLDBEQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyREFBSyxxQ0FBcUMsZUFBZTtBQUM3RCxrQkFBa0IsNkRBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0EscUJBQXFCLHlEQUFHO0FBQ3hCLHFCQUFxQix5REFBRztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDLEVBQUUsd0RBQU07QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0REFBTTtBQUMzQixlQUFlLCtEQUFXO0FBQzFCO0FBQ0E7QUFDQSxXQUFXLDREQUFNLENBQUMsK0RBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1FQUFlO0FBQ3ZDLG9CQUFvQix5REFBRztBQUN2QixvQkFBb0IseURBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Qsc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSx3Q0FBd0M7QUFDeEMsd0JBQXdCO0FBQ3hCO0FBQ0Esc0JBQXNCO0FBQ3RCLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtRUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0VBQVc7QUFDL0QsY0FBYywrREFBVztBQUN6QixZQUFZLHVCQUF1QixtQ0FBbUM7QUFDdEUsY0FBYywrREFBVywwQkFBMEI7QUFDbkQsMkJBQTJCLG1FQUFlLGlDQUFpQztBQUMzRSx3REFBd0Q7QUFDeEQsb0JBQW9CLG1FQUFlLFNBQVM7QUFDNUM7QUFDQSxtREFBbUQ7QUFDbkQsWUFBWSx1QkFBdUIsMkJBQTJCO0FBQzlELG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFXO0FBQzNCLGNBQWMsK0RBQVc7QUFDekIsZ0JBQWdCLCtEQUFXO0FBQzNCO0FBQ0EseUJBQXlCLG1FQUFlLFFBQVEsd0JBQXdCO0FBQ3hFLGtCQUFrQixtRUFBZSx1QkFBdUIsMkJBQTJCO0FBQ25GO0FBQ0E7QUFDQSxrQkFBa0IsbUVBQWUsd0JBQXdCLDRCQUE0QjtBQUNyRjtBQUNBO0FBQ0EsOERBQThEO0FBQzlELDJDQUEyQztBQUMzQztBQUNBLDBCQUEwQjtBQUMxQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCO0FBQ0EsV0FBVztBQUNYLEtBQUs7QUFDTCxDQUFDO0FBQ0Qsc0NBQXNDLHNFQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZFQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLHdFQUFZO0FBQy9DLFlBQVksT0FBTztBQUNuQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdEQUFNO0FBQ2hCLENBQUM7QUFDTTtBQUNBO0FBQ1AiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXEBub2JsZVxcY3VydmVzXFxlc21cXHNlY3AyNTZrMS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXHJcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcclxuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcclxuaW1wb3J0IHsgRmllbGQsIG1vZCwgcG93MiB9IGZyb20gJy4vYWJzdHJhY3QvbW9kdWxhci5qcyc7XHJcbmltcG9ydCB7IG1hcFRvQ3VydmVTaW1wbGVTV1UgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcclxuaW1wb3J0IHsgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSB9IGZyb20gJy4vYWJzdHJhY3QvdXRpbHMuanMnO1xyXG5pbXBvcnQgeyBjcmVhdGVIYXNoZXIsIGlzb2dlbnlNYXAgfSBmcm9tICcuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMnO1xyXG5pbXBvcnQgeyBjcmVhdGVDdXJ2ZSB9IGZyb20gJy4vX3Nob3J0d191dGlscy5qcyc7XHJcbmNvbnN0IHNlY3AyNTZrMVAgPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpO1xyXG5jb25zdCBzZWNwMjU2azFOID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnKTtcclxuY29uc3QgXzFuID0gQmlnSW50KDEpO1xyXG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XHJcbmNvbnN0IGRpdk5lYXJlc3QgPSAoYSwgYikgPT4gKGEgKyBiIC8gXzJuKSAvIGI7XHJcbi8qKlxyXG4gKiDiiJpuID0gbl4oKHArMSkvNCkgZm9yIGZpZWxkcyBwID0gMyBtb2QgNC4gV2UgdW53cmFwIHRoZSBsb29wIGFuZCBtdWx0aXBseSBiaXQtYnktYml0LlxyXG4gKiAoUCsxbi80bikudG9TdHJpbmcoMikgd291bGQgcHJvZHVjZSBiaXRzIFsyMjN4IDEsIDAsIDIyeCAxLCA0eCAwLCAxMSwgMDBdXHJcbiAqL1xyXG5mdW5jdGlvbiBzcXJ0TW9kKHkpIHtcclxuICAgIGNvbnN0IFAgPSBzZWNwMjU2azFQO1xyXG4gICAgLy8gcHJldHRpZXItaWdub3JlXHJcbiAgICBjb25zdCBfM24gPSBCaWdJbnQoMyksIF82biA9IEJpZ0ludCg2KSwgXzExbiA9IEJpZ0ludCgxMSksIF8yMm4gPSBCaWdJbnQoMjIpO1xyXG4gICAgLy8gcHJldHRpZXItaWdub3JlXHJcbiAgICBjb25zdCBfMjNuID0gQmlnSW50KDIzKSwgXzQ0biA9IEJpZ0ludCg0NCksIF84OG4gPSBCaWdJbnQoODgpO1xyXG4gICAgY29uc3QgYjIgPSAoeSAqIHkgKiB5KSAlIFA7IC8vIHheMywgMTFcclxuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7IC8vIHheN1xyXG4gICAgY29uc3QgYjYgPSAocG93MihiMywgXzNuLCBQKSAqIGIzKSAlIFA7XHJcbiAgICBjb25zdCBiOSA9IChwb3cyKGI2LCBfM24sIFApICogYjMpICUgUDtcclxuICAgIGNvbnN0IGIxMSA9IChwb3cyKGI5LCBfMm4sIFApICogYjIpICUgUDtcclxuICAgIGNvbnN0IGIyMiA9IChwb3cyKGIxMSwgXzExbiwgUCkgKiBiMTEpICUgUDtcclxuICAgIGNvbnN0IGI0NCA9IChwb3cyKGIyMiwgXzIybiwgUCkgKiBiMjIpICUgUDtcclxuICAgIGNvbnN0IGI4OCA9IChwb3cyKGI0NCwgXzQ0biwgUCkgKiBiNDQpICUgUDtcclxuICAgIGNvbnN0IGIxNzYgPSAocG93MihiODgsIF84OG4sIFApICogYjg4KSAlIFA7XHJcbiAgICBjb25zdCBiMjIwID0gKHBvdzIoYjE3NiwgXzQ0biwgUCkgKiBiNDQpICUgUDtcclxuICAgIGNvbnN0IGIyMjMgPSAocG93MihiMjIwLCBfM24sIFApICogYjMpICUgUDtcclxuICAgIGNvbnN0IHQxID0gKHBvdzIoYjIyMywgXzIzbiwgUCkgKiBiMjIpICUgUDtcclxuICAgIGNvbnN0IHQyID0gKHBvdzIodDEsIF82biwgUCkgKiBiMikgJSBQO1xyXG4gICAgY29uc3Qgcm9vdCA9IHBvdzIodDIsIF8ybiwgUCk7XHJcbiAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIHkpKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcclxuICAgIHJldHVybiByb290O1xyXG59XHJcbmNvbnN0IEZwID0gRmllbGQoc2VjcDI1NmsxUCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgc3FydDogc3FydE1vZCB9KTtcclxuZXhwb3J0IGNvbnN0IHNlY3AyNTZrMSA9IGNyZWF0ZUN1cnZlKHtcclxuICAgIGE6IEJpZ0ludCgwKSxcclxuICAgIGI6IEJpZ0ludCg3KSxcclxuICAgIEZwLFxyXG4gICAgbjogc2VjcDI1NmsxTixcclxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcclxuICAgIEd4OiBCaWdJbnQoJzU1MDY2MjYzMDIyMjc3MzQzNjY5NTc4NzE4ODk1MTY4NTM0MzI2MjUwNjAzNDUzNzc3NTk0MTc1NTAwMTg3MzYwMzg5MTE2NzI5MjQwJyksXHJcbiAgICBHeTogQmlnSW50KCczMjY3MDUxMDAyMDc1ODgxNjk3ODA4MzA4NTEzMDUwNzA0MzE4NDQ3MTI3MzM4MDY1OTI0MzI3NTkzODkwNDMzNTc1NzMzNzQ4MjQyNCcpLFxyXG4gICAgaDogQmlnSW50KDEpLFxyXG4gICAgbG93UzogdHJ1ZSxcclxuICAgIC8qKlxyXG4gICAgICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cclxuICAgICAqIEVuZG9tb3JwaGlzbSB1c2VzIDJ4IGxlc3MgUkFNLCBzcGVlZHMgdXAgcHJlY29tcHV0YXRpb24gYnkgMnggYW5kIEVDREggLyBrZXkgcmVjb3ZlcnkgYnkgMjAlLlxyXG4gICAgICogRm9yIHByZWNvbXB1dGVkIHdOQUYgaXQgdHJhZGVzIG9mZiAxLzIgaW5pdCB0aW1lICYgMS8zIHJhbSBmb3IgMjAlIHBlcmYgaGl0LlxyXG4gICAgICogRXhwbGFuYXRpb246IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NlxyXG4gICAgICovXHJcbiAgICBlbmRvOiB7XHJcbiAgICAgICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcclxuICAgICAgICBzcGxpdFNjYWxhcjogKGspID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbiA9IHNlY3AyNTZrMU47XHJcbiAgICAgICAgICAgIGNvbnN0IGExID0gQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1Jyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xyXG4gICAgICAgICAgICBjb25zdCBhMiA9IEJpZ0ludCgnMHgxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDgnKTtcclxuICAgICAgICAgICAgY29uc3QgYjIgPSBhMTtcclxuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxyXG4gICAgICAgICAgICBjb25zdCBjMSA9IGRpdk5lYXJlc3QoYjIgKiBrLCBuKTtcclxuICAgICAgICAgICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xyXG4gICAgICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcclxuICAgICAgICAgICAgbGV0IGsyID0gbW9kKC1jMSAqIGIxIC0gYzIgKiBiMiwgbik7XHJcbiAgICAgICAgICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XHJcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XHJcbiAgICAgICAgICAgIGlmIChrMW5lZylcclxuICAgICAgICAgICAgICAgIGsxID0gbiAtIGsxO1xyXG4gICAgICAgICAgICBpZiAoazJuZWcpXHJcbiAgICAgICAgICAgICAgICBrMiA9IG4gLSBrMjtcclxuICAgICAgICAgICAgaWYgKGsxID4gUE9XXzJfMTI4IHx8IGsyID4gUE9XXzJfMTI4KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG59LCBzaGEyNTYpO1xyXG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQwLm1lZGlhd2lraVxyXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XHJcbmNvbnN0IGZlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFQO1xyXG5jb25zdCBnZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxTjtcclxuLyoqIEFuIG9iamVjdCBtYXBwaW5nIHRhZ3MgdG8gdGhlaXIgdGFnZ2VkIGhhc2ggcHJlZml4IG9mIFtTSEEyNTYodGFnKSB8IFNIQTI1Nih0YWcpXSAqL1xyXG5jb25zdCBUQUdHRURfSEFTSF9QUkVGSVhFUyA9IHt9O1xyXG5mdW5jdGlvbiB0YWdnZWRIYXNoKHRhZywgLi4ubWVzc2FnZXMpIHtcclxuICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcclxuICAgIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBjb25zdCB0YWdIID0gc2hhMjU2KFVpbnQ4QXJyYXkuZnJvbSh0YWcsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcclxuICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XHJcbiAgICAgICAgVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXSA9IHRhZ1A7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2hhMjU2KGNvbmNhdEJ5dGVzKHRhZ1AsIC4uLm1lc3NhZ2VzKSk7XHJcbn1cclxuLy8gRUNEU0EgY29tcGFjdCBwb2ludHMgYXJlIDMzLWJ5dGUuIFNjaG5vcnIgaXMgMzI6IHdlIHN0cmlwIGZpcnN0IGJ5dGUgMHgwMiBvciAweDAzXHJcbmNvbnN0IHBvaW50VG9CeXRlcyA9IChwb2ludCkgPT4gcG9pbnQudG9SYXdCeXRlcyh0cnVlKS5zbGljZSgxKTtcclxuY29uc3QgbnVtVG8zMmIgPSAobikgPT4gbnVtYmVyVG9CeXRlc0JFKG4sIDMyKTtcclxuY29uc3QgbW9kUCA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxUCk7XHJcbmNvbnN0IG1vZE4gPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMU4pO1xyXG5jb25zdCBQb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQ7XHJcbmNvbnN0IEdtdWxBZGQgPSAoUSwgYSwgYikgPT4gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKTtcclxuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXHJcbmZ1bmN0aW9uIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdikge1xyXG4gICAgbGV0IGRfID0gc2VjcDI1NmsxLnV0aWxzLm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdik7IC8vIHNhbWUgbWV0aG9kIGV4ZWN1dGVkIGluIGZyb21Qcml2YXRlS2V5XHJcbiAgICBsZXQgcCA9IFBvaW50LmZyb21Qcml2YXRlS2V5KGRfKTsgLy8gUCA9IGQn4ouFRzsgMCA8IGQnIDwgbiBjaGVjayBpcyBkb25lIGluc2lkZVxyXG4gICAgY29uc3Qgc2NhbGFyID0gcC5oYXNFdmVuWSgpID8gZF8gOiBtb2ROKC1kXyk7XHJcbiAgICByZXR1cm4geyBzY2FsYXI6IHNjYWxhciwgYnl0ZXM6IHBvaW50VG9CeXRlcyhwKSB9O1xyXG59XHJcbi8qKlxyXG4gKiBsaWZ0X3ggZnJvbSBCSVAzNDAuIENvbnZlcnQgMzItYnl0ZSB4IGNvb3JkaW5hdGUgdG8gZWxsaXB0aWMgY3VydmUgcG9pbnQuXHJcbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXHJcbiAqL1xyXG5mdW5jdGlvbiBsaWZ0X3goeCkge1xyXG4gICAgaWYgKCFmZSh4KSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCB4OiBuZWVkIDAgPCB4IDwgcCcpOyAvLyBGYWlsIGlmIHgg4omlIHAuXHJcbiAgICBjb25zdCB4eCA9IG1vZFAoeCAqIHgpO1xyXG4gICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxyXG4gICAgbGV0IHkgPSBzcXJ0TW9kKGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC5cclxuICAgIGlmICh5ICUgXzJuICE9PSBfMG4pXHJcbiAgICAgICAgeSA9IG1vZFAoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcclxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoeCwgeSwgXzFuKTsgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXHJcbiAgICBwLmFzc2VydFZhbGlkaXR5KCk7XHJcbiAgICByZXR1cm4gcDtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxyXG4gKi9cclxuZnVuY3Rpb24gY2hhbGxlbmdlKC4uLmFyZ3MpIHtcclxuICAgIHJldHVybiBtb2ROKGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XHJcbn1cclxuLyoqXHJcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXHJcbiAqL1xyXG5mdW5jdGlvbiBzY2hub3JyR2V0UHVibGljS2V5KHByaXZhdGVLZXkpIHtcclxuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxyXG4gKiBhdXhSYW5kIGlzIG9wdGlvbmFsIGFuZCBpcyBub3QgdGhlIHNvbGUgc291cmNlIG9mIGsgZ2VuZXJhdGlvbjogYmFkIENTUFJORyB3b24ndCBiZSBkYW5nZXJvdXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gcmFuZG9tQnl0ZXMoMzIpKSB7XHJcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcclxuICAgIGNvbnN0IHsgYnl0ZXM6IHB4LCBzY2FsYXI6IGQgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSk7IC8vIGNoZWNrcyBmb3IgaXNXaXRoaW5DdXJ2ZU9yZGVyXHJcbiAgICBjb25zdCBhID0gZW5zdXJlQnl0ZXMoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcclxuICAgIGNvbnN0IHQgPSBudW1UbzMyYihkIF4gYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYSkpKTsgLy8gTGV0IHQgYmUgdGhlIGJ5dGUtd2lzZSB4b3Igb2YgYnl0ZXMoZCkgYW5kIGhhc2gvYXV4KGEpXHJcbiAgICBjb25zdCByYW5kID0gdGFnZ2VkSGFzaCgnQklQMDM0MC9ub25jZScsIHQsIHB4LCBtKTsgLy8gTGV0IHJhbmQgPSBoYXNoL25vbmNlKHQgfHwgYnl0ZXMoUCkgfHwgbSlcclxuICAgIGNvbnN0IGtfID0gbW9kTihieXRlc1RvTnVtYmVyQkUocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cclxuICAgIGlmIChrXyA9PT0gXzBuKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbiBmYWlsZWQ6IGsgaXMgemVybycpOyAvLyBGYWlsIGlmIGsnID0gMC5cclxuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cclxuICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UocngsIHB4LCBtKTsgLy8gTGV0IGUgPSBpbnQoaGFzaC9jaGFsbGVuZ2UoYnl0ZXMoUikgfHwgYnl0ZXMoUCkgfHwgbSkpIG1vZCBuLlxyXG4gICAgY29uc3Qgc2lnID0gbmV3IFVpbnQ4QXJyYXkoNjQpOyAvLyBMZXQgc2lnID0gYnl0ZXMoUikgfHwgYnl0ZXMoKGsgKyBlZCkgbW9kIG4pLlxyXG4gICAgc2lnLnNldChyeCwgMCk7XHJcbiAgICBzaWcuc2V0KG51bVRvMzJiKG1vZE4oayArIGUgKiBkKSksIDMyKTtcclxuICAgIC8vIElmIFZlcmlmeShieXRlcyhQKSwgbSwgc2lnKSAoc2VlIGJlbG93KSByZXR1cm5zIGZhaWx1cmUsIGFib3J0XHJcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xyXG4gICAgcmV0dXJuIHNpZztcclxufVxyXG4vKipcclxuICogVmVyaWZpZXMgU2Nobm9yciBzaWduYXR1cmUuXHJcbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KSB7XHJcbiAgICBjb25zdCBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XHJcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcclxuICAgIGNvbnN0IHB1YiA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXksIDMyKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgUCA9IGxpZnRfeChieXRlc1RvTnVtYmVyQkUocHViKSk7IC8vIFAgPSBsaWZ0X3goaW50KHBrKSk7IGZhaWwgaWYgdGhhdCBmYWlsc1xyXG4gICAgICAgIGNvbnN0IHIgPSBieXRlc1RvTnVtYmVyQkUoc2lnLnN1YmFycmF5KDAsIDMyKSk7IC8vIExldCByID0gaW50KHNpZ1swOjMyXSk7IGZhaWwgaWYgciDiiaUgcC5cclxuICAgICAgICBpZiAoIWZlKHIpKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgcyA9IGJ5dGVzVG9OdW1iZXJCRShzaWcuc3ViYXJyYXkoMzIsIDY0KSk7IC8vIExldCBzID0gaW50KHNpZ1szMjo2NF0pOyBmYWlsIGlmIHMg4omlIG4uXHJcbiAgICAgICAgaWYgKCFnZShzKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UobnVtVG8zMmIociksIHBvaW50VG9CeXRlcyhQKSwgbSk7IC8vIGludChjaGFsbGVuZ2UoYnl0ZXMocil8fGJ5dGVzKFApfHxtKSklblxyXG4gICAgICAgIGNvbnN0IFIgPSBHbXVsQWRkKFAsIHMsIG1vZE4oLWUpKTsgLy8gUiA9IHPii4VHIC0gZeKLhVBcclxuICAgICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyAtZVAgPT0gKG4tZSlQXHJcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEZhaWwgaWYgaXNfaW5maW5pdGUoUikgLyBub3QgaGFzX2V2ZW5feShSKSAvIHgoUikg4omgIHIuXHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XHJcbiAgICBnZXRQdWJsaWNLZXk6IHNjaG5vcnJHZXRQdWJsaWNLZXksXHJcbiAgICBzaWduOiBzY2hub3JyU2lnbixcclxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcclxuICAgIHV0aWxzOiB7XHJcbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogc2VjcDI1NmsxLnV0aWxzLnJhbmRvbVByaXZhdGVLZXksXHJcbiAgICAgICAgbGlmdF94LFxyXG4gICAgICAgIHBvaW50VG9CeXRlcyxcclxuICAgICAgICBudW1iZXJUb0J5dGVzQkUsXHJcbiAgICAgICAgYnl0ZXNUb051bWJlckJFLFxyXG4gICAgICAgIHRhZ2dlZEhhc2gsXHJcbiAgICAgICAgbW9kLFxyXG4gICAgfSxcclxufSkpKCk7XHJcbmNvbnN0IGlzb01hcCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaXNvZ2VueU1hcChGcCwgW1xyXG4gICAgLy8geE51bVxyXG4gICAgW1xyXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4YzcnLFxyXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXHJcbiAgICAgICAgJzB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MicsXHJcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYTg4YycsXHJcbiAgICBdLFxyXG4gICAgLy8geERlblxyXG4gICAgW1xyXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxyXG4gICAgICAgICcweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTQnLFxyXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcclxuICAgIF0sXHJcbiAgICAvLyB5TnVtXHJcbiAgICBbXHJcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXHJcbiAgICAgICAgJzB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhMycsXHJcbiAgICAgICAgJzB4MjlhNjE5NDY5MWY5MWE3MzcxNTIwOWVmNjUxMmU1NzY3MjI4MzBhMjAxYmUyMDE4YTc2NWU4NWE5ZWNlZTkzMScsXHJcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXHJcbiAgICBdLFxyXG4gICAgLy8geURlblxyXG4gICAgW1xyXG4gICAgICAgICcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmY5M2InLFxyXG4gICAgICAgICcweDdhMDY1MzRiYjhiZGI0OWZkNWU5ZTY2MzI3MjJjMjk4OTQ2N2MxYmZjOGU4ZDk3OGRmYjQyNWQyNjg1YzI1NzMnLFxyXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxyXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcclxuICAgIF0sXHJcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xyXG5jb25zdCBtYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIHtcclxuICAgIEE6IEJpZ0ludCgnMHgzZjg3MzFhYmRkNjYxYWRjYTA4YTU1NThmMGY1ZDI3MmU5NTNkMzYzY2I2ZjBlNWQ0MDU0NDdjMDFhNDQ0NTMzJyksXHJcbiAgICBCOiBCaWdJbnQoJzE3NzEnKSxcclxuICAgIFo6IEZwLmNyZWF0ZShCaWdJbnQoJy0xMScpKSxcclxufSkpKCk7XHJcbmNvbnN0IGh0ZiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XHJcbiAgICBjb25zdCB7IHgsIHkgfSA9IG1hcFNXVShGcC5jcmVhdGUoc2NhbGFyc1swXSkpO1xyXG4gICAgcmV0dXJuIGlzb01hcCh4LCB5KTtcclxufSwge1xyXG4gICAgRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfUk9fJyxcclxuICAgIGVuY29kZURTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX05VXycsXHJcbiAgICBwOiBGcC5PUkRFUixcclxuICAgIG06IDEsXHJcbiAgICBrOiAxMjgsXHJcbiAgICBleHBhbmQ6ICd4bWQnLFxyXG4gICAgaGFzaDogc2hhMjU2LFxyXG59KSkoKTtcclxuZXhwb3J0IGNvbnN0IGhhc2hUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XHJcbmV4cG9ydCBjb25zdCBlbmNvZGVUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuZW5jb2RlVG9DdXJ2ZSkoKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/curves/esm/secp256k1.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/hashes/esm/_assert.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_assert.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\r\n    if (!Number.isSafeInteger(n) || n < 0)\r\n        throw new Error(`Wrong positive integer: ${n}`);\r\n}\r\nfunction bool(b) {\r\n    if (typeof b !== 'boolean')\r\n        throw new Error(`Expected boolean, not ${b}`);\r\n}\r\nfunction bytes(b, ...lengths) {\r\n    if (!(b instanceof Uint8Array))\r\n        throw new Error('Expected Uint8Array');\r\n    if (lengths.length > 0 && !lengths.includes(b.length))\r\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\r\n}\r\nfunction hash(hash) {\r\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\r\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\r\n    number(hash.outputLen);\r\n    number(hash.blockLen);\r\n}\r\nfunction exists(instance, checkFinished = true) {\r\n    if (instance.destroyed)\r\n        throw new Error('Hash instance has been destroyed');\r\n    if (checkFinished && instance.finished)\r\n        throw new Error('Hash#digest() has already been called');\r\n}\r\nfunction output(out, instance) {\r\n    bytes(out);\r\n    const min = instance.outputLen;\r\n    if (out.length < min) {\r\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\r\n    }\r\n}\r\n\r\nconst assert = { number, bool, bytes, hash, exists, output };\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\r\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EsbURBQW1ELEVBQUU7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRLGtCQUFrQixTQUFTO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsSUFBSTtBQUNyRjtBQUNBO0FBQ3FEO0FBQ3JELGlCQUFpQjtBQUNqQixpRUFBZSxNQUFNLEVBQUM7QUFDdEIiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxlc21cXF9hc3NlcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbnVtYmVyKG4pIHtcclxuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XHJcbn1cclxuZnVuY3Rpb24gYm9vbChiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4sIG5vdCAke2J9YCk7XHJcbn1cclxuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xyXG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xyXG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XHJcbn1cclxuZnVuY3Rpb24gaGFzaChoYXNoKSB7XHJcbiAgICBpZiAodHlwZW9mIGhhc2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGhhc2guY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcclxuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XHJcbiAgICBudW1iZXIoaGFzaC5ibG9ja0xlbik7XHJcbn1cclxuZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xyXG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XHJcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcclxufVxyXG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xyXG4gICAgYnl0ZXMob3V0KTtcclxuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcclxuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgeyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xyXG5jb25zdCBhc3NlcnQgPSB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XHJcbmV4cG9ydCBkZWZhdWx0IGFzc2VydDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Fzc2VydC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/hashes/esm/_sha2.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_sha2.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n\r\n\r\n// Polyfill for Safari 14\r\nfunction setBigUint64(view, byteOffset, value, isLE) {\r\n    if (typeof view.setBigUint64 === 'function')\r\n        return view.setBigUint64(byteOffset, value, isLE);\r\n    const _32n = BigInt(32);\r\n    const _u32_max = BigInt(0xffffffff);\r\n    const wh = Number((value >> _32n) & _u32_max);\r\n    const wl = Number(value & _u32_max);\r\n    const h = isLE ? 4 : 0;\r\n    const l = isLE ? 0 : 4;\r\n    view.setUint32(byteOffset + h, wh, isLE);\r\n    view.setUint32(byteOffset + l, wl, isLE);\r\n}\r\n// Base SHA2 class (RFC 6234)\r\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\r\n    constructor(blockLen, outputLen, padOffset, isLE) {\r\n        super();\r\n        this.blockLen = blockLen;\r\n        this.outputLen = outputLen;\r\n        this.padOffset = padOffset;\r\n        this.isLE = isLE;\r\n        this.finished = false;\r\n        this.length = 0;\r\n        this.pos = 0;\r\n        this.destroyed = false;\r\n        this.buffer = new Uint8Array(blockLen);\r\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\r\n    }\r\n    update(data) {\r\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\r\n        const { view, buffer, blockLen } = this;\r\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\r\n        const len = data.length;\r\n        for (let pos = 0; pos < len;) {\r\n            const take = Math.min(blockLen - this.pos, len - pos);\r\n            // Fast path: we have at least one block in input, cast it to view and process\r\n            if (take === blockLen) {\r\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\r\n                for (; blockLen <= len - pos; pos += blockLen)\r\n                    this.process(dataView, pos);\r\n                continue;\r\n            }\r\n            buffer.set(data.subarray(pos, pos + take), this.pos);\r\n            this.pos += take;\r\n            pos += take;\r\n            if (this.pos === blockLen) {\r\n                this.process(view, 0);\r\n                this.pos = 0;\r\n            }\r\n        }\r\n        this.length += data.length;\r\n        this.roundClean();\r\n        return this;\r\n    }\r\n    digestInto(out) {\r\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\r\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\r\n        this.finished = true;\r\n        // Padding\r\n        // We can avoid allocation of buffer for padding completely if it\r\n        // was previously not allocated here. But it won't change performance.\r\n        const { buffer, view, blockLen, isLE } = this;\r\n        let { pos } = this;\r\n        // append the bit '1' to the message\r\n        buffer[pos++] = 0b10000000;\r\n        this.buffer.subarray(pos).fill(0);\r\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\r\n        if (this.padOffset > blockLen - pos) {\r\n            this.process(view, 0);\r\n            pos = 0;\r\n        }\r\n        // Pad until full block byte with zeros\r\n        for (let i = pos; i < blockLen; i++)\r\n            buffer[i] = 0;\r\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\r\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\r\n        // So we just write lowest 64 bits of that value.\r\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\r\n        this.process(view, 0);\r\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\r\n        const len = this.outputLen;\r\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\r\n        if (len % 4)\r\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\r\n        const outLen = len / 4;\r\n        const state = this.get();\r\n        if (outLen > state.length)\r\n            throw new Error('_sha2: outputLen bigger than state');\r\n        for (let i = 0; i < outLen; i++)\r\n            oview.setUint32(4 * i, state[i], isLE);\r\n    }\r\n    digest() {\r\n        const { buffer, outputLen } = this;\r\n        this.digestInto(buffer);\r\n        const res = buffer.slice(0, outputLen);\r\n        this.destroy();\r\n        return res;\r\n    }\r\n    _cloneInto(to) {\r\n        to || (to = new this.constructor());\r\n        to.set(...this.get());\r\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\r\n        to.length = length;\r\n        to.pos = pos;\r\n        to.finished = finished;\r\n        to.destroyed = destroyed;\r\n        if (length % blockLen)\r\n            to.buffer.set(buffer);\r\n        return to;\r\n    }\r\n}\r\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fc2hhMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEM7QUFDUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUJBQW1CLDJDQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQVU7QUFDOUI7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxnQkFBZ0IseUJBQXlCO0FBQ3pDLGVBQWUsa0RBQU87QUFDdEI7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQVU7QUFDM0MsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxRQUFRLGtEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxlc21cXF9zaGEyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4aXN0cywgb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcclxuaW1wb3J0IHsgSGFzaCwgY3JlYXRlVmlldywgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xyXG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XHJcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xyXG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xyXG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XHJcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcclxuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcclxuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xyXG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcclxuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XHJcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xyXG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcclxufVxyXG4vLyBCYXNlIFNIQTIgY2xhc3MgKFJGQyA2MjM0KVxyXG5leHBvcnQgY2xhc3MgU0hBMiBleHRlbmRzIEhhc2gge1xyXG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XHJcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XHJcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XHJcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcclxuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMucG9zID0gMDtcclxuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xyXG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGRhdGEpIHtcclxuICAgICAgICBleGlzdHModGhpcyk7XHJcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xyXG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcclxuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XHJcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xyXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyhkYXRhKTtcclxuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xyXG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xyXG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZGlnZXN0SW50byhvdXQpIHtcclxuICAgICAgICBleGlzdHModGhpcyk7XHJcbiAgICAgICAgb3V0cHV0KG91dCwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XHJcbiAgICAgICAgLy8gUGFkZGluZ1xyXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XHJcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxyXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcclxuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XHJcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXHJcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XHJcbiAgICAgICAgdGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xyXG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cclxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XHJcbiAgICAgICAgICAgIHBvcyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxyXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xyXG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxyXG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxyXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cclxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xyXG4gICAgICAgIGNvbnN0IG92aWV3ID0gY3JlYXRlVmlldyhvdXQpO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xyXG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXHJcbiAgICAgICAgaWYgKGxlbiAlIDQpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xyXG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xyXG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXHJcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xyXG4gICAgfVxyXG4gICAgZGlnZXN0KCkge1xyXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XHJcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XHJcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIF9jbG9uZUludG8odG8pIHtcclxuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcclxuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XHJcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcclxuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XHJcbiAgICAgICAgdG8ucG9zID0gcG9zO1xyXG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XHJcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xyXG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcclxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xyXG4gICAgICAgIHJldHVybiB0bztcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/hashes/esm/_sha2.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/hashes/esm/_u64.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_u64.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\r\nconst _32n = /* @__PURE__ */ BigInt(32);\r\n// We are not using BigUint64Array, because they are extremely slow as per 2022\r\nfunction fromBig(n, le = false) {\r\n    if (le)\r\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\r\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\r\n}\r\nfunction split(lst, le = false) {\r\n    let Ah = new Uint32Array(lst.length);\r\n    let Al = new Uint32Array(lst.length);\r\n    for (let i = 0; i < lst.length; i++) {\r\n        const { h, l } = fromBig(lst[i], le);\r\n        [Ah[i], Al[i]] = [h, l];\r\n    }\r\n    return [Ah, Al];\r\n}\r\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\r\n// for Shift in [0, 32)\r\nconst shrSH = (h, _l, s) => h >>> s;\r\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\r\n// Right rotate for Shift in [1, 32)\r\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\r\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\r\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\r\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\r\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\r\n// Right rotate for shift===32 (just swaps l&h)\r\nconst rotr32H = (_h, l) => l;\r\nconst rotr32L = (h, _l) => h;\r\n// Left rotate for Shift in [1, 32)\r\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\r\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\r\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\r\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\r\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\r\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\r\n// simple take carry out of low bit sum by shift, we need to use division.\r\nfunction add(Ah, Al, Bh, Bl) {\r\n    const l = (Al >>> 0) + (Bl >>> 0);\r\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\r\n}\r\n// Addition with more than 2 elements\r\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\r\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\r\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\r\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\r\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\r\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\r\n// prettier-ignore\r\n\r\n// prettier-ignore\r\nconst u64 = {\r\n    fromBig, split, toBig,\r\n    shrSH, shrSL,\r\n    rotrSH, rotrSL, rotrBH, rotrBL,\r\n    rotr32H, rotr32L,\r\n    rotlSH, rotlSL, rotlBH, rotlBL,\r\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\r\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDaUw7QUFDakw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsR0FBRyxFQUFDO0FBQ25CIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGhhc2hlc1xcZXNtXFxfdTY0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFUzMl9NQVNLNjQgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIgKiogMzIgLSAxKTtcclxuY29uc3QgXzMybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMzIpO1xyXG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXHJcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xyXG4gICAgaWYgKGxlKVxyXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XHJcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XHJcbn1cclxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XHJcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XHJcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcclxuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcclxuICAgIH1cclxuICAgIHJldHVybiBbQWgsIEFsXTtcclxufVxyXG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xyXG4vLyBmb3IgU2hpZnQgaW4gWzAsIDMyKVxyXG5jb25zdCBzaHJTSCA9IChoLCBfbCwgcykgPT4gaCA+Pj4gcztcclxuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xyXG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcclxuY29uc3Qgcm90clNIID0gKGgsIGwsIHMpID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcclxuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcclxuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxyXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcclxuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XHJcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXHJcbmNvbnN0IHJvdHIzMkggPSAoX2gsIGwpID0+IGw7XHJcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XHJcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXHJcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XHJcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XHJcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxyXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcclxuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XHJcbi8vIEpTIHVzZXMgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zIHdoaWNoIG1lYW5zIHdlIGNhbm5vdFxyXG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxyXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcclxuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcclxuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xyXG59XHJcbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcclxuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xyXG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcclxuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XHJcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xyXG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xyXG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcclxuLy8gcHJldHRpZXItaWdub3JlXHJcbmV4cG9ydCB7IGZyb21CaWcsIHNwbGl0LCB0b0JpZywgc2hyU0gsIHNoclNMLCByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsIHJvdHIzMkgsIHJvdHIzMkwsIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCwgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLCB9O1xyXG4vLyBwcmV0dGllci1pZ25vcmVcclxuY29uc3QgdTY0ID0ge1xyXG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxyXG4gICAgc2hyU0gsIHNoclNMLFxyXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxyXG4gICAgcm90cjMySCwgcm90cjMyTCxcclxuICAgIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCxcclxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcclxufTtcclxuZXhwb3J0IGRlZmF1bHQgdTY0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/hashes/esm/_u64.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/hashes/esm/crypto.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/crypto.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\r\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG8uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxlc21cXGNyeXB0by5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgY3J5cHRvID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnICYmICdjcnlwdG8nIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHVuZGVmaW5lZDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/hashes/esm/hmac.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/hmac.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n\r\n\r\n// HMAC (RFC 2104)\r\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\r\n    constructor(hash, _key) {\r\n        super();\r\n        this.finished = false;\r\n        this.destroyed = false;\r\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\r\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\r\n        this.iHash = hash.create();\r\n        if (typeof this.iHash.update !== 'function')\r\n            throw new Error('Expected instance of class which extends utils.Hash');\r\n        this.blockLen = this.iHash.blockLen;\r\n        this.outputLen = this.iHash.outputLen;\r\n        const blockLen = this.blockLen;\r\n        const pad = new Uint8Array(blockLen);\r\n        // blockLen can be bigger than outputLen\r\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\r\n        for (let i = 0; i < pad.length; i++)\r\n            pad[i] ^= 0x36;\r\n        this.iHash.update(pad);\r\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\r\n        this.oHash = hash.create();\r\n        // Undo internal XOR && apply outer XOR\r\n        for (let i = 0; i < pad.length; i++)\r\n            pad[i] ^= 0x36 ^ 0x5c;\r\n        this.oHash.update(pad);\r\n        pad.fill(0);\r\n    }\r\n    update(buf) {\r\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\r\n        this.iHash.update(buf);\r\n        return this;\r\n    }\r\n    digestInto(out) {\r\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\r\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\r\n        this.finished = true;\r\n        this.iHash.digestInto(out);\r\n        this.oHash.update(out);\r\n        this.oHash.digestInto(out);\r\n        this.destroy();\r\n    }\r\n    digest() {\r\n        const out = new Uint8Array(this.oHash.outputLen);\r\n        this.digestInto(out);\r\n        return out;\r\n    }\r\n    _cloneInto(to) {\r\n        // Create new instance without calling constructor since key already in state and we don't know it.\r\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\r\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\r\n        to = to;\r\n        to.finished = finished;\r\n        to.destroyed = destroyed;\r\n        to.blockLen = blockLen;\r\n        to.outputLen = outputLen;\r\n        to.oHash = oHash._cloneInto(to.oHash);\r\n        to.iHash = iHash._cloneInto(to.iHash);\r\n        return to;\r\n    }\r\n    destroy() {\r\n        this.destroyed = true;\r\n        this.oHash.destroy();\r\n        this.iHash.destroy();\r\n    }\r\n}\r\n/**\r\n * HMAC: RFC2104 message authentication code.\r\n * @param hash - function that would be used e.g. sha256\r\n * @param key - message key\r\n * @param message - message data\r\n */\r\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\r\nhmac.create = (hash, key) => new HMAC(hash, key);\r\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0c7QUFDckQ7QUFDM0M7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFVO0FBQ2xCLG9CQUFvQixrREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBWTtBQUNwQixRQUFRLGlEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGhhc2hlc1xcZXNtXFxobWFjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhhc2ggYXMgYXNzZXJ0SGFzaCwgYnl0ZXMgYXMgYXNzZXJ0Qnl0ZXMsIGV4aXN0cyBhcyBhc3NlcnRFeGlzdHMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xyXG5pbXBvcnQgeyBIYXNoLCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XHJcbi8vIEhNQUMgKFJGQyAyMTA0KVxyXG5leHBvcnQgY2xhc3MgSE1BQyBleHRlbmRzIEhhc2gge1xyXG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XHJcbiAgICAgICAgYXNzZXJ0SGFzaChoYXNoKTtcclxuICAgICAgICBjb25zdCBrZXkgPSB0b0J5dGVzKF9rZXkpO1xyXG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XHJcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XHJcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcclxuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XHJcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xyXG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cclxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcclxuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xyXG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcclxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcclxuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xyXG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XHJcbiAgICAgICAgcGFkLmZpbGwoMCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoYnVmKSB7XHJcbiAgICAgICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBkaWdlc3RJbnRvKG91dCkge1xyXG4gICAgICAgIGFzc2VydEV4aXN0cyh0aGlzKTtcclxuICAgICAgICBhc3NlcnRCeXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuKTtcclxuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcclxuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xyXG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xyXG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gICAgZGlnZXN0KCkge1xyXG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcclxuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG4gICAgX2Nsb25lSW50byh0bykge1xyXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxyXG4gICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xyXG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xyXG4gICAgICAgIHRvID0gdG87XHJcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcclxuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XHJcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcclxuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XHJcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcclxuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xyXG4gICAgICAgIHJldHVybiB0bztcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cclxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcclxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XHJcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xyXG5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBITUFDKGhhc2gsIGtleSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/hashes/esm/pbkdf2.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/pbkdf2.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pbkdf2: () => (/* binding */ pbkdf2),\n/* harmony export */   pbkdf2Async: () => (/* binding */ pbkdf2Async)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hmac.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n\r\n\r\n\r\n// Common prologue and epilogue for sync/async functions\r\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\r\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.hash)(hash);\r\n    const opts = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);\r\n    const { c, dkLen, asyncTick } = opts;\r\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(c);\r\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(dkLen);\r\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(asyncTick);\r\n    if (c < 1)\r\n        throw new Error('PBKDF2: iterations (c) should be >= 1');\r\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_password);\r\n    const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_salt);\r\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\r\n    const DK = new Uint8Array(dkLen);\r\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\r\n    const PRF = _hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac.create(hash, password);\r\n    const PRFSalt = PRF._cloneInto().update(salt);\r\n    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\r\n}\r\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\r\n    PRF.destroy();\r\n    PRFSalt.destroy();\r\n    if (prfW)\r\n        prfW.destroy();\r\n    u.fill(0);\r\n    return DK;\r\n}\r\n/**\r\n * PBKDF2-HMAC: RFC 2898 key derivation function\r\n * @param hash - hash function that would be used e.g. sha256\r\n * @param password - password from which a derived key is generated\r\n * @param salt - cryptographic salt\r\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\r\n */\r\nfunction pbkdf2(hash, password, salt, opts) {\r\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\r\n    let prfW; // Working copy\r\n    const arr = new Uint8Array(4);\r\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(arr);\r\n    const u = new Uint8Array(PRF.outputLen);\r\n    // DK = T1 + T2 +  + Tdklen/hlen\r\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\r\n        // Ti = F(Password, Salt, c, i)\r\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\r\n        view.setInt32(0, ti, false);\r\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\r\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\r\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\r\n        Ti.set(u.subarray(0, Ti.length));\r\n        for (let ui = 1; ui < c; ui++) {\r\n            // Uc = PRF(Password, Uc1)\r\n            PRF._cloneInto(prfW).update(u).digestInto(u);\r\n            for (let i = 0; i < Ti.length; i++)\r\n                Ti[i] ^= u[i];\r\n        }\r\n    }\r\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\r\n}\r\nasync function pbkdf2Async(hash, password, salt, opts) {\r\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\r\n    let prfW; // Working copy\r\n    const arr = new Uint8Array(4);\r\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(arr);\r\n    const u = new Uint8Array(PRF.outputLen);\r\n    // DK = T1 + T2 +  + Tdklen/hlen\r\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\r\n        // Ti = F(Password, Salt, c, i)\r\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\r\n        view.setInt32(0, ti, false);\r\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\r\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\r\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\r\n        Ti.set(u.subarray(0, Ti.length));\r\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.asyncLoop)(c - 1, asyncTick, () => {\r\n            // Uc = PRF(Password, Uc1)\r\n            PRF._cloneInto(prfW).update(u).digestInto(u);\r\n            for (let i = 0; i < Ti.length; i++)\r\n                Ti[i] ^= u[i];\r\n        });\r\n    }\r\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\r\n}\r\n//# sourceMappingURL=pbkdf2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9wYmtkZjIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMEU7QUFDekM7QUFDc0M7QUFDdkU7QUFDQTtBQUNBLElBQUksZ0RBQVU7QUFDZCxpQkFBaUIsb0RBQVMsR0FBRywwQkFBMEI7QUFDdkQsWUFBWSxzQkFBc0I7QUFDbEMsSUFBSSxrREFBWTtBQUNoQixJQUFJLGtEQUFZO0FBQ2hCLElBQUksa0RBQVk7QUFDaEI7QUFDQTtBQUNBLHFCQUFxQixrREFBTztBQUM1QixpQkFBaUIsa0RBQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBDQUFJO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNPO0FBQ1AsWUFBWSw2QkFBNkI7QUFDekMsY0FBYztBQUNkO0FBQ0EsaUJBQWlCLHFEQUFVO0FBQzNCO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHdDQUF3QztBQUNwRCxjQUFjO0FBQ2Q7QUFDQSxpQkFBaUIscURBQVU7QUFDM0I7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvREFBUztBQUN2QjtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxlc21cXHBia2RmMi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXNoIGFzIGFzc2VydEhhc2gsIG51bWJlciBhcyBhc3NlcnROdW1iZXIgfSBmcm9tICcuL19hc3NlcnQuanMnO1xyXG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnLi9obWFjLmpzJztcclxuaW1wb3J0IHsgY3JlYXRlVmlldywgdG9CeXRlcywgY2hlY2tPcHRzLCBhc3luY0xvb3AgfSBmcm9tICcuL3V0aWxzLmpzJztcclxuLy8gQ29tbW9uIHByb2xvZ3VlIGFuZCBlcGlsb2d1ZSBmb3Igc3luYy9hc3luYyBmdW5jdGlvbnNcclxuZnVuY3Rpb24gcGJrZGYySW5pdChoYXNoLCBfcGFzc3dvcmQsIF9zYWx0LCBfb3B0cykge1xyXG4gICAgYXNzZXJ0SGFzaChoYXNoKTtcclxuICAgIGNvbnN0IG9wdHMgPSBjaGVja09wdHMoeyBka0xlbjogMzIsIGFzeW5jVGljazogMTAgfSwgX29wdHMpO1xyXG4gICAgY29uc3QgeyBjLCBka0xlbiwgYXN5bmNUaWNrIH0gPSBvcHRzO1xyXG4gICAgYXNzZXJ0TnVtYmVyKGMpO1xyXG4gICAgYXNzZXJ0TnVtYmVyKGRrTGVuKTtcclxuICAgIGFzc2VydE51bWJlcihhc3luY1RpY2spO1xyXG4gICAgaWYgKGMgPCAxKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUEJLREYyOiBpdGVyYXRpb25zIChjKSBzaG91bGQgYmUgPj0gMScpO1xyXG4gICAgY29uc3QgcGFzc3dvcmQgPSB0b0J5dGVzKF9wYXNzd29yZCk7XHJcbiAgICBjb25zdCBzYWx0ID0gdG9CeXRlcyhfc2FsdCk7XHJcbiAgICAvLyBESyA9IFBCS0RGMihQUkYsIFBhc3N3b3JkLCBTYWx0LCBjLCBka0xlbik7XHJcbiAgICBjb25zdCBESyA9IG5ldyBVaW50OEFycmF5KGRrTGVuKTtcclxuICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxyXG4gICAgY29uc3QgUFJGID0gaG1hYy5jcmVhdGUoaGFzaCwgcGFzc3dvcmQpO1xyXG4gICAgY29uc3QgUFJGU2FsdCA9IFBSRi5fY2xvbmVJbnRvKCkudXBkYXRlKHNhbHQpO1xyXG4gICAgcmV0dXJuIHsgYywgZGtMZW4sIGFzeW5jVGljaywgREssIFBSRiwgUFJGU2FsdCB9O1xyXG59XHJcbmZ1bmN0aW9uIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KSB7XHJcbiAgICBQUkYuZGVzdHJveSgpO1xyXG4gICAgUFJGU2FsdC5kZXN0cm95KCk7XHJcbiAgICBpZiAocHJmVylcclxuICAgICAgICBwcmZXLmRlc3Ryb3koKTtcclxuICAgIHUuZmlsbCgwKTtcclxuICAgIHJldHVybiBESztcclxufVxyXG4vKipcclxuICogUEJLREYyLUhNQUM6IFJGQyAyODk4IGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSBoYXNoIC0gaGFzaCBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcclxuICogQHBhcmFtIHBhc3N3b3JkIC0gcGFzc3dvcmQgZnJvbSB3aGljaCBhIGRlcml2ZWQga2V5IGlzIGdlbmVyYXRlZFxyXG4gKiBAcGFyYW0gc2FsdCAtIGNyeXB0b2dyYXBoaWMgc2FsdFxyXG4gKiBAcGFyYW0gb3B0cyAtIHtjLCBka0xlbn0gd2hlcmUgYyBpcyB3b3JrIGZhY3RvciBhbmQgZGtMZW4gaXMgb3V0cHV0IG1lc3NhZ2Ugc2l6ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBia2RmMihoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cykge1xyXG4gICAgY29uc3QgeyBjLCBka0xlbiwgREssIFBSRiwgUFJGU2FsdCB9ID0gcGJrZGYySW5pdChoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cyk7XHJcbiAgICBsZXQgcHJmVzsgLy8gV29ya2luZyBjb3B5XHJcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSg0KTtcclxuICAgIGNvbnN0IHZpZXcgPSBjcmVhdGVWaWV3KGFycik7XHJcbiAgICBjb25zdCB1ID0gbmV3IFVpbnQ4QXJyYXkoUFJGLm91dHB1dExlbik7XHJcbiAgICAvLyBESyA9IFQxICsgVDIgKyDii68gKyBUZGtsZW4vaGxlblxyXG4gICAgZm9yIChsZXQgdGkgPSAxLCBwb3MgPSAwOyBwb3MgPCBka0xlbjsgdGkrKywgcG9zICs9IFBSRi5vdXRwdXRMZW4pIHtcclxuICAgICAgICAvLyBUaSA9IEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpXHJcbiAgICAgICAgY29uc3QgVGkgPSBESy5zdWJhcnJheShwb3MsIHBvcyArIFBSRi5vdXRwdXRMZW4pO1xyXG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgdGksIGZhbHNlKTtcclxuICAgICAgICAvLyBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKSA9IFUxIF4gVTIgXiDii68gXiBVY1xyXG4gICAgICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxyXG4gICAgICAgIChwcmZXID0gUFJGU2FsdC5fY2xvbmVJbnRvKHByZlcpKS51cGRhdGUoYXJyKS5kaWdlc3RJbnRvKHUpO1xyXG4gICAgICAgIFRpLnNldCh1LnN1YmFycmF5KDAsIFRpLmxlbmd0aCkpO1xyXG4gICAgICAgIGZvciAobGV0IHVpID0gMTsgdWkgPCBjOyB1aSsrKSB7XHJcbiAgICAgICAgICAgIC8vIFVjID0gUFJGKFBhc3N3b3JkLCBVY+KIkjEpXHJcbiAgICAgICAgICAgIFBSRi5fY2xvbmVJbnRvKHByZlcpLnVwZGF0ZSh1KS5kaWdlc3RJbnRvKHUpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRpLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgVGlbaV0gXj0gdVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGJrZGYyT3V0cHV0KFBSRiwgUFJGU2FsdCwgREssIHByZlcsIHUpO1xyXG59XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYmtkZjJBc3luYyhoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cykge1xyXG4gICAgY29uc3QgeyBjLCBka0xlbiwgYXN5bmNUaWNrLCBESywgUFJGLCBQUkZTYWx0IH0gPSBwYmtkZjJJbml0KGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcclxuICAgIGxldCBwcmZXOyAvLyBXb3JraW5nIGNvcHlcclxuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDQpO1xyXG4gICAgY29uc3QgdmlldyA9IGNyZWF0ZVZpZXcoYXJyKTtcclxuICAgIGNvbnN0IHUgPSBuZXcgVWludDhBcnJheShQUkYub3V0cHV0TGVuKTtcclxuICAgIC8vIERLID0gVDEgKyBUMiArIOKLryArIFRka2xlbi9obGVuXHJcbiAgICBmb3IgKGxldCB0aSA9IDEsIHBvcyA9IDA7IHBvcyA8IGRrTGVuOyB0aSsrLCBwb3MgKz0gUFJGLm91dHB1dExlbikge1xyXG4gICAgICAgIC8vIFRpID0gRihQYXNzd29yZCwgU2FsdCwgYywgaSlcclxuICAgICAgICBjb25zdCBUaSA9IERLLnN1YmFycmF5KHBvcywgcG9zICsgUFJGLm91dHB1dExlbik7XHJcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0aSwgZmFsc2UpO1xyXG4gICAgICAgIC8vIEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpID0gVTEgXiBVMiBeIOKLryBeIFVjXHJcbiAgICAgICAgLy8gVTEgPSBQUkYoUGFzc3dvcmQsIFNhbHQgKyBJTlRfMzJfQkUoaSkpXHJcbiAgICAgICAgKHByZlcgPSBQUkZTYWx0Ll9jbG9uZUludG8ocHJmVykpLnVwZGF0ZShhcnIpLmRpZ2VzdEludG8odSk7XHJcbiAgICAgICAgVGkuc2V0KHUuc3ViYXJyYXkoMCwgVGkubGVuZ3RoKSk7XHJcbiAgICAgICAgYXdhaXQgYXN5bmNMb29wKGMgLSAxLCBhc3luY1RpY2ssICgpID0+IHtcclxuICAgICAgICAgICAgLy8gVWMgPSBQUkYoUGFzc3dvcmQsIFVj4oiSMSlcclxuICAgICAgICAgICAgUFJGLl9jbG9uZUludG8ocHJmVykudXBkYXRlKHUpLmRpZ2VzdEludG8odSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgVGkubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICBUaVtpXSBePSB1W2ldO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYmtkZjIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/hashes/esm/pbkdf2.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/hashes/esm/ripemd160.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/ripemd160.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RIPEMD160: () => (/* binding */ RIPEMD160),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n\r\n\r\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\r\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\r\nconst Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\r\nconst Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);\r\nconst Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);\r\nlet idxL = [Id];\r\nlet idxR = [Pi];\r\nfor (let i = 0; i < 4; i++)\r\n    for (let j of [idxL, idxR])\r\n        j.push(j[i].map((k) => Rho[k]));\r\nconst shifts = /* @__PURE__ */ [\r\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\r\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\r\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\r\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\r\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\r\n].map((i) => new Uint8Array(i));\r\nconst shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\r\nconst shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\r\nconst Kl = /* @__PURE__ */ new Uint32Array([\r\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\r\n]);\r\nconst Kr = /* @__PURE__ */ new Uint32Array([\r\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\r\n]);\r\n// The rotate left (circular left shift) operation for uint32\r\nconst rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));\r\n// It's called f() in spec.\r\nfunction f(group, x, y, z) {\r\n    if (group === 0)\r\n        return x ^ y ^ z;\r\n    else if (group === 1)\r\n        return (x & y) | (~x & z);\r\n    else if (group === 2)\r\n        return (x | ~y) ^ z;\r\n    else if (group === 3)\r\n        return (x & z) | (y & ~z);\r\n    else\r\n        return x ^ (y | ~z);\r\n}\r\n// Temporary buffer, not used to store anything between runs\r\nconst BUF = /* @__PURE__ */ new Uint32Array(16);\r\nclass RIPEMD160 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\r\n    constructor() {\r\n        super(64, 20, 8, true);\r\n        this.h0 = 0x67452301 | 0;\r\n        this.h1 = 0xefcdab89 | 0;\r\n        this.h2 = 0x98badcfe | 0;\r\n        this.h3 = 0x10325476 | 0;\r\n        this.h4 = 0xc3d2e1f0 | 0;\r\n    }\r\n    get() {\r\n        const { h0, h1, h2, h3, h4 } = this;\r\n        return [h0, h1, h2, h3, h4];\r\n    }\r\n    set(h0, h1, h2, h3, h4) {\r\n        this.h0 = h0 | 0;\r\n        this.h1 = h1 | 0;\r\n        this.h2 = h2 | 0;\r\n        this.h3 = h3 | 0;\r\n        this.h4 = h4 | 0;\r\n    }\r\n    process(view, offset) {\r\n        for (let i = 0; i < 16; i++, offset += 4)\r\n            BUF[i] = view.getUint32(offset, true);\r\n        // prettier-ignore\r\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\r\n        // Instead of iterating 0 to 80, we split it into 5 groups\r\n        // And use the groups in constants, functions, etc. Much simpler\r\n        for (let group = 0; group < 5; group++) {\r\n            const rGroup = 4 - group;\r\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\r\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\r\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\r\n            for (let i = 0; i < 16; i++) {\r\n                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;\r\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\r\n            }\r\n            // 2 loops are 10% faster\r\n            for (let i = 0; i < 16; i++) {\r\n                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;\r\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\r\n            }\r\n        }\r\n        // Add the compressed chunk to the current hash value\r\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\r\n    }\r\n    roundClean() {\r\n        BUF.fill(0);\r\n    }\r\n    destroy() {\r\n        this.destroyed = true;\r\n        this.buffer.fill(0);\r\n        this.set(0, 0, 0, 0, 0);\r\n    }\r\n}\r\n/**\r\n * RIPEMD-160 - a hash function from 1990s.\r\n * @param message - msg that would be hashed\r\n */\r\nconst ripemd160 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new RIPEMD160());\r\n//# sourceMappingURL=ripemd160.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9yaXBlbWQxNjAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrQztBQUNXO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0JBQXdCLDBDQUFJO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQSxvREFBb0Q7QUFDcEQsc0RBQXNEO0FBQ3RELDREQUE0RDtBQUM1RCw0QkFBNEIsUUFBUTtBQUNwQztBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sa0NBQWtDLDBEQUFlO0FBQ3hEIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGhhc2hlc1xcZXNtXFxyaXBlbWQxNjAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xyXG5pbXBvcnQgeyB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcclxuLy8gaHR0cHM6Ly9ob21lcy5lc2F0Lmt1bGV1dmVuLmJlL35ib3NzZWxhZS9yaXBlbWQxNjAuaHRtbFxyXG4vLyBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC9wZGYvQUItOTYwMS9BQi05NjAxLnBkZlxyXG5jb25zdCBSaG8gPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoWzcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDhdKTtcclxuY29uc3QgSWQgPSAvKiBAX19QVVJFX18gKi8gVWludDhBcnJheS5mcm9tKHsgbGVuZ3RoOiAxNiB9LCAoXywgaSkgPT4gaSk7XHJcbmNvbnN0IFBpID0gLyogQF9fUFVSRV9fICovIElkLm1hcCgoaSkgPT4gKDkgKiBpICsgNSkgJSAxNik7XHJcbmxldCBpZHhMID0gW0lkXTtcclxubGV0IGlkeFIgPSBbUGldO1xyXG5mb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKylcclxuICAgIGZvciAobGV0IGogb2YgW2lkeEwsIGlkeFJdKVxyXG4gICAgICAgIGoucHVzaChqW2ldLm1hcCgoaykgPT4gUmhvW2tdKSk7XHJcbmNvbnN0IHNoaWZ0cyA9IC8qIEBfX1BVUkVfXyAqLyBbXHJcbiAgICBbMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4XSxcclxuICAgIFsxMiwgMTMsIDExLCAxNSwgNiwgOSwgOSwgNywgMTIsIDE1LCAxMSwgMTMsIDcsIDgsIDcsIDddLFxyXG4gICAgWzEzLCAxNSwgMTQsIDExLCA3LCA3LCA2LCA4LCAxMywgMTQsIDEzLCAxMiwgNSwgNSwgNiwgOV0sXHJcbiAgICBbMTQsIDExLCAxMiwgMTQsIDgsIDYsIDUsIDUsIDE1LCAxMiwgMTUsIDE0LCA5LCA5LCA4LCA2XSxcclxuICAgIFsxNSwgMTIsIDEzLCAxMywgOSwgNSwgOCwgNiwgMTQsIDExLCAxMiwgMTEsIDgsIDYsIDUsIDVdLFxyXG5dLm1hcCgoaSkgPT4gbmV3IFVpbnQ4QXJyYXkoaSkpO1xyXG5jb25zdCBzaGlmdHNMID0gLyogQF9fUFVSRV9fICovIGlkeEwubWFwKChpZHgsIGkpID0+IGlkeC5tYXAoKGopID0+IHNoaWZ0c1tpXVtqXSkpO1xyXG5jb25zdCBzaGlmdHNSID0gLyogQF9fUFVSRV9fICovIGlkeFIubWFwKChpZHgsIGkpID0+IGlkeC5tYXAoKGopID0+IHNoaWZ0c1tpXVtqXSkpO1xyXG5jb25zdCBLbCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xyXG4gICAgMHgwMDAwMDAwMCwgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhhOTUzZmQ0ZSxcclxuXSk7XHJcbmNvbnN0IEtyID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXHJcbiAgICAweDUwYTI4YmU2LCAweDVjNGRkMTI0LCAweDZkNzAzZWYzLCAweDdhNmQ3NmU5LCAweDAwMDAwMDAwLFxyXG5dKTtcclxuLy8gVGhlIHJvdGF0ZSBsZWZ0IChjaXJjdWxhciBsZWZ0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxyXG5jb25zdCByb3RsID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCBzaGlmdCkgfCAod29yZCA+Pj4gKDMyIC0gc2hpZnQpKTtcclxuLy8gSXQncyBjYWxsZWQgZigpIGluIHNwZWMuXHJcbmZ1bmN0aW9uIGYoZ3JvdXAsIHgsIHksIHopIHtcclxuICAgIGlmIChncm91cCA9PT0gMClcclxuICAgICAgICByZXR1cm4geCBeIHkgXiB6O1xyXG4gICAgZWxzZSBpZiAoZ3JvdXAgPT09IDEpXHJcbiAgICAgICAgcmV0dXJuICh4ICYgeSkgfCAofnggJiB6KTtcclxuICAgIGVsc2UgaWYgKGdyb3VwID09PSAyKVxyXG4gICAgICAgIHJldHVybiAoeCB8IH55KSBeIHo7XHJcbiAgICBlbHNlIGlmIChncm91cCA9PT0gMylcclxuICAgICAgICByZXR1cm4gKHggJiB6KSB8ICh5ICYgfnopO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiB4IF4gKHkgfCB+eik7XHJcbn1cclxuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXHJcbmNvbnN0IEJVRiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoMTYpO1xyXG5leHBvcnQgY2xhc3MgUklQRU1EMTYwIGV4dGVuZHMgU0hBMiB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcig2NCwgMjAsIDgsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuaDAgPSAweDY3NDUyMzAxIHwgMDtcclxuICAgICAgICB0aGlzLmgxID0gMHhlZmNkYWI4OSB8IDA7XHJcbiAgICAgICAgdGhpcy5oMiA9IDB4OThiYWRjZmUgfCAwO1xyXG4gICAgICAgIHRoaXMuaDMgPSAweDEwMzI1NDc2IHwgMDtcclxuICAgICAgICB0aGlzLmg0ID0gMHhjM2QyZTFmMCB8IDA7XHJcbiAgICB9XHJcbiAgICBnZXQoKSB7XHJcbiAgICAgICAgY29uc3QgeyBoMCwgaDEsIGgyLCBoMywgaDQgfSA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIFtoMCwgaDEsIGgyLCBoMywgaDRdO1xyXG4gICAgfVxyXG4gICAgc2V0KGgwLCBoMSwgaDIsIGgzLCBoNCkge1xyXG4gICAgICAgIHRoaXMuaDAgPSBoMCB8IDA7XHJcbiAgICAgICAgdGhpcy5oMSA9IGgxIHwgMDtcclxuICAgICAgICB0aGlzLmgyID0gaDIgfCAwO1xyXG4gICAgICAgIHRoaXMuaDMgPSBoMyB8IDA7XHJcbiAgICAgICAgdGhpcy5oNCA9IGg0IHwgMDtcclxuICAgIH1cclxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcclxuICAgICAgICAgICAgQlVGW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCB0cnVlKTtcclxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcclxuICAgICAgICBsZXQgYWwgPSB0aGlzLmgwIHwgMCwgYXIgPSBhbCwgYmwgPSB0aGlzLmgxIHwgMCwgYnIgPSBibCwgY2wgPSB0aGlzLmgyIHwgMCwgY3IgPSBjbCwgZGwgPSB0aGlzLmgzIHwgMCwgZHIgPSBkbCwgZWwgPSB0aGlzLmg0IHwgMCwgZXIgPSBlbDtcclxuICAgICAgICAvLyBJbnN0ZWFkIG9mIGl0ZXJhdGluZyAwIHRvIDgwLCB3ZSBzcGxpdCBpdCBpbnRvIDUgZ3JvdXBzXHJcbiAgICAgICAgLy8gQW5kIHVzZSB0aGUgZ3JvdXBzIGluIGNvbnN0YW50cywgZnVuY3Rpb25zLCBldGMuIE11Y2ggc2ltcGxlclxyXG4gICAgICAgIGZvciAobGV0IGdyb3VwID0gMDsgZ3JvdXAgPCA1OyBncm91cCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJHcm91cCA9IDQgLSBncm91cDtcclxuICAgICAgICAgICAgY29uc3QgaGJsID0gS2xbZ3JvdXBdLCBoYnIgPSBLcltncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxyXG4gICAgICAgICAgICBjb25zdCBybCA9IGlkeExbZ3JvdXBdLCByciA9IGlkeFJbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcclxuICAgICAgICAgICAgY29uc3Qgc2wgPSBzaGlmdHNMW2dyb3VwXSwgc3IgPSBzaGlmdHNSW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGwgPSAocm90bChhbCArIGYoZ3JvdXAsIGJsLCBjbCwgZGwpICsgQlVGW3JsW2ldXSArIGhibCwgc2xbaV0pICsgZWwpIHwgMDtcclxuICAgICAgICAgICAgICAgIGFsID0gZWwsIGVsID0gZGwsIGRsID0gcm90bChjbCwgMTApIHwgMCwgY2wgPSBibCwgYmwgPSB0bDsgLy8gcHJldHRpZXItaWdub3JlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gMiBsb29wcyBhcmUgMTAlIGZhc3RlclxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gKHJvdGwoYXIgKyBmKHJHcm91cCwgYnIsIGNyLCBkcikgKyBCVUZbcnJbaV1dICsgaGJyLCBzcltpXSkgKyBlcikgfCAwO1xyXG4gICAgICAgICAgICAgICAgYXIgPSBlciwgZXIgPSBkciwgZHIgPSByb3RsKGNyLCAxMCkgfCAwLCBjciA9IGJyLCBiciA9IHRyOyAvLyBwcmV0dGllci1pZ25vcmVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxyXG4gICAgICAgIHRoaXMuc2V0KCh0aGlzLmgxICsgY2wgKyBkcikgfCAwLCAodGhpcy5oMiArIGRsICsgZXIpIHwgMCwgKHRoaXMuaDMgKyBlbCArIGFyKSB8IDAsICh0aGlzLmg0ICsgYWwgKyBicikgfCAwLCAodGhpcy5oMCArIGJsICsgY3IpIHwgMCk7XHJcbiAgICB9XHJcbiAgICByb3VuZENsZWFuKCkge1xyXG4gICAgICAgIEJVRi5maWxsKDApO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcclxuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUklQRU1ELTE2MCAtIGEgaGFzaCBmdW5jdGlvbiBmcm9tIDE5OTBzLlxyXG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1zZyB0aGF0IHdvdWxkIGJlIGhhc2hlZFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJpcGVtZDE2MCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFJJUEVNRDE2MCgpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmlwZW1kMTYwLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/hashes/esm/ripemd160.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/hashes/esm/scrypt.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/scrypt.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scrypt: () => (/* binding */ scrypt),\n/* harmony export */   scryptAsync: () => (/* binding */ scryptAsync)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _sha256_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sha256.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _pbkdf2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pbkdf2.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/pbkdf2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n\r\n\r\n\r\n\r\n// RFC 7914 Scrypt KDF\r\n// Left rotate for uint32\r\nconst rotl = (a, b) => (a << b) | (a >>> (32 - b));\r\n// The main Scrypt loop: uses Salsa extensively.\r\n// Six versions of the function were tried, this is the fastest one.\r\n// prettier-ignore\r\nfunction XorAndSalsa(prev, pi, input, ii, out, oi) {\r\n    // Based on https://cr.yp.to/salsa20.html\r\n    // Xor blocks\r\n    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];\r\n    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];\r\n    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];\r\n    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];\r\n    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];\r\n    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];\r\n    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];\r\n    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];\r\n    // Save state to temporary variables (salsa)\r\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\r\n    // Main loop (salsa)\r\n    for (let i = 0; i < 8; i += 2) {\r\n        x04 ^= rotl(x00 + x12 | 0, 7);\r\n        x08 ^= rotl(x04 + x00 | 0, 9);\r\n        x12 ^= rotl(x08 + x04 | 0, 13);\r\n        x00 ^= rotl(x12 + x08 | 0, 18);\r\n        x09 ^= rotl(x05 + x01 | 0, 7);\r\n        x13 ^= rotl(x09 + x05 | 0, 9);\r\n        x01 ^= rotl(x13 + x09 | 0, 13);\r\n        x05 ^= rotl(x01 + x13 | 0, 18);\r\n        x14 ^= rotl(x10 + x06 | 0, 7);\r\n        x02 ^= rotl(x14 + x10 | 0, 9);\r\n        x06 ^= rotl(x02 + x14 | 0, 13);\r\n        x10 ^= rotl(x06 + x02 | 0, 18);\r\n        x03 ^= rotl(x15 + x11 | 0, 7);\r\n        x07 ^= rotl(x03 + x15 | 0, 9);\r\n        x11 ^= rotl(x07 + x03 | 0, 13);\r\n        x15 ^= rotl(x11 + x07 | 0, 18);\r\n        x01 ^= rotl(x00 + x03 | 0, 7);\r\n        x02 ^= rotl(x01 + x00 | 0, 9);\r\n        x03 ^= rotl(x02 + x01 | 0, 13);\r\n        x00 ^= rotl(x03 + x02 | 0, 18);\r\n        x06 ^= rotl(x05 + x04 | 0, 7);\r\n        x07 ^= rotl(x06 + x05 | 0, 9);\r\n        x04 ^= rotl(x07 + x06 | 0, 13);\r\n        x05 ^= rotl(x04 + x07 | 0, 18);\r\n        x11 ^= rotl(x10 + x09 | 0, 7);\r\n        x08 ^= rotl(x11 + x10 | 0, 9);\r\n        x09 ^= rotl(x08 + x11 | 0, 13);\r\n        x10 ^= rotl(x09 + x08 | 0, 18);\r\n        x12 ^= rotl(x15 + x14 | 0, 7);\r\n        x13 ^= rotl(x12 + x15 | 0, 9);\r\n        x14 ^= rotl(x13 + x12 | 0, 13);\r\n        x15 ^= rotl(x14 + x13 | 0, 18);\r\n    }\r\n    // Write output (salsa)\r\n    out[oi++] = (y00 + x00) | 0;\r\n    out[oi++] = (y01 + x01) | 0;\r\n    out[oi++] = (y02 + x02) | 0;\r\n    out[oi++] = (y03 + x03) | 0;\r\n    out[oi++] = (y04 + x04) | 0;\r\n    out[oi++] = (y05 + x05) | 0;\r\n    out[oi++] = (y06 + x06) | 0;\r\n    out[oi++] = (y07 + x07) | 0;\r\n    out[oi++] = (y08 + x08) | 0;\r\n    out[oi++] = (y09 + x09) | 0;\r\n    out[oi++] = (y10 + x10) | 0;\r\n    out[oi++] = (y11 + x11) | 0;\r\n    out[oi++] = (y12 + x12) | 0;\r\n    out[oi++] = (y13 + x13) | 0;\r\n    out[oi++] = (y14 + x14) | 0;\r\n    out[oi++] = (y15 + x15) | 0;\r\n}\r\nfunction BlockMix(input, ii, out, oi, r) {\r\n    // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)\r\n    let head = oi + 0;\r\n    let tail = oi + 16 * r;\r\n    for (let i = 0; i < 16; i++)\r\n        out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X  B[2r1]\r\n    for (let i = 0; i < r; i++, head += 16, ii += 16) {\r\n        // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1\r\n        XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])\r\n        if (i > 0)\r\n            tail += 16; // First iteration overwrites tmp value in tail\r\n        XorAndSalsa(out, head, input, (ii += 16), out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])\r\n    }\r\n}\r\n// Common prologue and epilogue for sync/async functions\r\nfunction scryptInit(password, salt, _opts) {\r\n    // Maxmem - 1GB+1KB by default\r\n    const opts = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.checkOpts)({\r\n        dkLen: 32,\r\n        asyncTick: 10,\r\n        maxmem: 1024 ** 3 + 1024,\r\n    }, _opts);\r\n    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;\r\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.number)(N);\r\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.number)(r);\r\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.number)(p);\r\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.number)(dkLen);\r\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.number)(asyncTick);\r\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.number)(maxmem);\r\n    if (onProgress !== undefined && typeof onProgress !== 'function')\r\n        throw new Error('progressCb should be function');\r\n    const blockSize = 128 * r;\r\n    const blockSize32 = blockSize / 4;\r\n    if (N <= 1 || (N & (N - 1)) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {\r\n        // NOTE: we limit N to be less than 2**32 because of 32 bit variant of Integrify function\r\n        // There is no JS engines that allows alocate more than 4GB per single Uint8Array for now, but can change in future.\r\n        throw new Error('Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32');\r\n    }\r\n    if (p < 0 || p > ((2 ** 32 - 1) * 32) / blockSize) {\r\n        throw new Error('Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)');\r\n    }\r\n    if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {\r\n        throw new Error('Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32');\r\n    }\r\n    const memUsed = blockSize * (N + p);\r\n    if (memUsed > maxmem) {\r\n        throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);\r\n    }\r\n    // [B0...Bp1]  PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)\r\n    // Since it has only one iteration there is no reason to use async variant\r\n    const B = (0,_pbkdf2_js__WEBPACK_IMPORTED_MODULE_2__.pbkdf2)(_sha256_js__WEBPACK_IMPORTED_MODULE_3__.sha256, password, salt, { c: 1, dkLen: blockSize * p });\r\n    const B32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(B);\r\n    // Re-used between parallel iterations. Array(iterations) of B\r\n    const V = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(new Uint8Array(blockSize * N));\r\n    const tmp = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(new Uint8Array(blockSize));\r\n    let blockMixCb = () => { };\r\n    if (onProgress) {\r\n        const totalBlockMix = 2 * N * p;\r\n        // Invoke callback if progress changes from 10.01 to 10.02\r\n        // Allows to draw smooth progress bar on up to 8K screen\r\n        const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);\r\n        let blockMixCnt = 0;\r\n        blockMixCb = () => {\r\n            blockMixCnt++;\r\n            if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))\r\n                onProgress(blockMixCnt / totalBlockMix);\r\n        };\r\n    }\r\n    return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };\r\n}\r\nfunction scryptOutput(password, dkLen, B, V, tmp) {\r\n    const res = (0,_pbkdf2_js__WEBPACK_IMPORTED_MODULE_2__.pbkdf2)(_sha256_js__WEBPACK_IMPORTED_MODULE_3__.sha256, password, B, { c: 1, dkLen });\r\n    B.fill(0);\r\n    V.fill(0);\r\n    tmp.fill(0);\r\n    return res;\r\n}\r\n/**\r\n * Scrypt KDF from RFC 7914.\r\n * @param password - pass\r\n * @param salt - salt\r\n * @param opts - parameters\r\n * - `N` is cpu/mem work factor (power of 2 e.g. 2**18)\r\n * - `r` is block size (8 is common), fine-tunes sequential memory read size and performance\r\n * - `p` is parallelization factor (1 is common)\r\n * - `dkLen` is output key length in bytes e.g. 32.\r\n * - `asyncTick` - (default: 10) max time in ms for which async function can block execution\r\n * - `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt\r\n * - `onProgress` - callback function that would be executed for progress report\r\n * @returns Derived key\r\n */\r\nfunction scrypt(password, salt, opts) {\r\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);\r\n    for (let pi = 0; pi < p; pi++) {\r\n        const Pi = blockSize32 * pi;\r\n        for (let i = 0; i < blockSize32; i++)\r\n            V[i] = B32[Pi + i]; // V[0] = B[i]\r\n        for (let i = 0, pos = 0; i < N - 1; i++) {\r\n            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\r\n            blockMixCb();\r\n        }\r\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\r\n        blockMixCb();\r\n        for (let i = 0; i < N; i++) {\r\n            // First u32 of the last 64-byte block (u32 is LE)\r\n            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\r\n            for (let k = 0; k < blockSize32; k++)\r\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\r\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\r\n            blockMixCb();\r\n        }\r\n    }\r\n    return scryptOutput(password, dkLen, B, V, tmp);\r\n}\r\n/**\r\n * Scrypt KDF from RFC 7914.\r\n */\r\nasync function scryptAsync(password, salt, opts) {\r\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);\r\n    for (let pi = 0; pi < p; pi++) {\r\n        const Pi = blockSize32 * pi;\r\n        for (let i = 0; i < blockSize32; i++)\r\n            V[i] = B32[Pi + i]; // V[0] = B[i]\r\n        let pos = 0;\r\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.asyncLoop)(N - 1, asyncTick, () => {\r\n            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\r\n            blockMixCb();\r\n        });\r\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\r\n        blockMixCb();\r\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.asyncLoop)(N, asyncTick, () => {\r\n            // First u32 of the last 64-byte block (u32 is LE)\r\n            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\r\n            for (let k = 0; k < blockSize32; k++)\r\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\r\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\r\n            blockMixCb();\r\n        });\r\n    }\r\n    return scryptOutput(password, dkLen, B, V, tmp);\r\n}\r\n//# sourceMappingURL=scrypt.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zY3J5cHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXNEO0FBQ2pCO0FBQ0E7QUFDa0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUIsMERBQTBEO0FBQzFELG9CQUFvQixPQUFPO0FBQzNCO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0Esd0JBQXdCO0FBQ3hCLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9EQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLGdEQUFnRDtBQUM1RCxJQUFJLGtEQUFZO0FBQ2hCLElBQUksa0RBQVk7QUFDaEIsSUFBSSxrREFBWTtBQUNoQixJQUFJLGtEQUFZO0FBQ2hCLElBQUksa0RBQVk7QUFDaEIsSUFBSSxrREFBWTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFNBQVMsd0JBQXdCLFFBQVE7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrREFBTSxDQUFDLDhDQUFNLG9CQUFvQiw0QkFBNEI7QUFDM0UsZ0JBQWdCLDhDQUFHO0FBQ25CO0FBQ0EsY0FBYyw4Q0FBRztBQUNqQixnQkFBZ0IsOENBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQixrREFBTSxDQUFDLDhDQUFNLGlCQUFpQixhQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLDBEQUEwRDtBQUN0RSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekMsZ0NBQWdDO0FBQ2hDLGlDQUFpQyxXQUFXO0FBQzVDLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQSxzREFBc0Q7QUFDdEQsNEJBQTRCLGlCQUFpQjtBQUM3QywrREFBK0Q7QUFDL0QsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVkscUVBQXFFO0FBQ2pGLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QyxnQ0FBZ0M7QUFDaEM7QUFDQSxjQUFjLG9EQUFTO0FBQ3ZCLDBEQUEwRDtBQUMxRDtBQUNBLFNBQVM7QUFDVCx3REFBd0Q7QUFDeEQ7QUFDQSxjQUFjLG9EQUFTO0FBQ3ZCO0FBQ0Esc0RBQXNEO0FBQ3RELDRCQUE0QixpQkFBaUI7QUFDN0MsK0RBQStEO0FBQy9ELDBDQUEwQztBQUMxQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXGVzbVxcc2NyeXB0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG51bWJlciBhcyBhc3NlcnROdW1iZXIgfSBmcm9tICcuL19hc3NlcnQuanMnO1xyXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICcuL3NoYTI1Ni5qcyc7XHJcbmltcG9ydCB7IHBia2RmMiB9IGZyb20gJy4vcGJrZGYyLmpzJztcclxuaW1wb3J0IHsgYXN5bmNMb29wLCBjaGVja09wdHMsIHUzMiB9IGZyb20gJy4vdXRpbHMuanMnO1xyXG4vLyBSRkMgNzkxNCBTY3J5cHQgS0RGXHJcbi8vIExlZnQgcm90YXRlIGZvciB1aW50MzJcclxuY29uc3Qgcm90bCA9IChhLCBiKSA9PiAoYSA8PCBiKSB8IChhID4+PiAoMzIgLSBiKSk7XHJcbi8vIFRoZSBtYWluIFNjcnlwdCBsb29wOiB1c2VzIFNhbHNhIGV4dGVuc2l2ZWx5LlxyXG4vLyBTaXggdmVyc2lvbnMgb2YgdGhlIGZ1bmN0aW9uIHdlcmUgdHJpZWQsIHRoaXMgaXMgdGhlIGZhc3Rlc3Qgb25lLlxyXG4vLyBwcmV0dGllci1pZ25vcmVcclxuZnVuY3Rpb24gWG9yQW5kU2Fsc2EocHJldiwgcGksIGlucHV0LCBpaSwgb3V0LCBvaSkge1xyXG4gICAgLy8gQmFzZWQgb24gaHR0cHM6Ly9jci55cC50by9zYWxzYTIwLmh0bWxcclxuICAgIC8vIFhvciBibG9ja3NcclxuICAgIGxldCB5MDAgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwMSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcclxuICAgIGxldCB5MDIgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwMyA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcclxuICAgIGxldCB5MDQgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwNSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcclxuICAgIGxldCB5MDYgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwNyA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcclxuICAgIGxldCB5MDggPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwOSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcclxuICAgIGxldCB5MTAgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkxMSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcclxuICAgIGxldCB5MTIgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkxMyA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcclxuICAgIGxldCB5MTQgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkxNSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcclxuICAgIC8vIFNhdmUgc3RhdGUgdG8gdGVtcG9yYXJ5IHZhcmlhYmxlcyAoc2Fsc2EpXHJcbiAgICBsZXQgeDAwID0geTAwLCB4MDEgPSB5MDEsIHgwMiA9IHkwMiwgeDAzID0geTAzLCB4MDQgPSB5MDQsIHgwNSA9IHkwNSwgeDA2ID0geTA2LCB4MDcgPSB5MDcsIHgwOCA9IHkwOCwgeDA5ID0geTA5LCB4MTAgPSB5MTAsIHgxMSA9IHkxMSwgeDEyID0geTEyLCB4MTMgPSB5MTMsIHgxNCA9IHkxNCwgeDE1ID0geTE1O1xyXG4gICAgLy8gTWFpbiBsb29wIChzYWxzYSlcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSArPSAyKSB7XHJcbiAgICAgICAgeDA0IF49IHJvdGwoeDAwICsgeDEyIHwgMCwgNyk7XHJcbiAgICAgICAgeDA4IF49IHJvdGwoeDA0ICsgeDAwIHwgMCwgOSk7XHJcbiAgICAgICAgeDEyIF49IHJvdGwoeDA4ICsgeDA0IHwgMCwgMTMpO1xyXG4gICAgICAgIHgwMCBePSByb3RsKHgxMiArIHgwOCB8IDAsIDE4KTtcclxuICAgICAgICB4MDkgXj0gcm90bCh4MDUgKyB4MDEgfCAwLCA3KTtcclxuICAgICAgICB4MTMgXj0gcm90bCh4MDkgKyB4MDUgfCAwLCA5KTtcclxuICAgICAgICB4MDEgXj0gcm90bCh4MTMgKyB4MDkgfCAwLCAxMyk7XHJcbiAgICAgICAgeDA1IF49IHJvdGwoeDAxICsgeDEzIHwgMCwgMTgpO1xyXG4gICAgICAgIHgxNCBePSByb3RsKHgxMCArIHgwNiB8IDAsIDcpO1xyXG4gICAgICAgIHgwMiBePSByb3RsKHgxNCArIHgxMCB8IDAsIDkpO1xyXG4gICAgICAgIHgwNiBePSByb3RsKHgwMiArIHgxNCB8IDAsIDEzKTtcclxuICAgICAgICB4MTAgXj0gcm90bCh4MDYgKyB4MDIgfCAwLCAxOCk7XHJcbiAgICAgICAgeDAzIF49IHJvdGwoeDE1ICsgeDExIHwgMCwgNyk7XHJcbiAgICAgICAgeDA3IF49IHJvdGwoeDAzICsgeDE1IHwgMCwgOSk7XHJcbiAgICAgICAgeDExIF49IHJvdGwoeDA3ICsgeDAzIHwgMCwgMTMpO1xyXG4gICAgICAgIHgxNSBePSByb3RsKHgxMSArIHgwNyB8IDAsIDE4KTtcclxuICAgICAgICB4MDEgXj0gcm90bCh4MDAgKyB4MDMgfCAwLCA3KTtcclxuICAgICAgICB4MDIgXj0gcm90bCh4MDEgKyB4MDAgfCAwLCA5KTtcclxuICAgICAgICB4MDMgXj0gcm90bCh4MDIgKyB4MDEgfCAwLCAxMyk7XHJcbiAgICAgICAgeDAwIF49IHJvdGwoeDAzICsgeDAyIHwgMCwgMTgpO1xyXG4gICAgICAgIHgwNiBePSByb3RsKHgwNSArIHgwNCB8IDAsIDcpO1xyXG4gICAgICAgIHgwNyBePSByb3RsKHgwNiArIHgwNSB8IDAsIDkpO1xyXG4gICAgICAgIHgwNCBePSByb3RsKHgwNyArIHgwNiB8IDAsIDEzKTtcclxuICAgICAgICB4MDUgXj0gcm90bCh4MDQgKyB4MDcgfCAwLCAxOCk7XHJcbiAgICAgICAgeDExIF49IHJvdGwoeDEwICsgeDA5IHwgMCwgNyk7XHJcbiAgICAgICAgeDA4IF49IHJvdGwoeDExICsgeDEwIHwgMCwgOSk7XHJcbiAgICAgICAgeDA5IF49IHJvdGwoeDA4ICsgeDExIHwgMCwgMTMpO1xyXG4gICAgICAgIHgxMCBePSByb3RsKHgwOSArIHgwOCB8IDAsIDE4KTtcclxuICAgICAgICB4MTIgXj0gcm90bCh4MTUgKyB4MTQgfCAwLCA3KTtcclxuICAgICAgICB4MTMgXj0gcm90bCh4MTIgKyB4MTUgfCAwLCA5KTtcclxuICAgICAgICB4MTQgXj0gcm90bCh4MTMgKyB4MTIgfCAwLCAxMyk7XHJcbiAgICAgICAgeDE1IF49IHJvdGwoeDE0ICsgeDEzIHwgMCwgMTgpO1xyXG4gICAgfVxyXG4gICAgLy8gV3JpdGUgb3V0cHV0IChzYWxzYSlcclxuICAgIG91dFtvaSsrXSA9ICh5MDAgKyB4MDApIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MDEgKyB4MDEpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MDIgKyB4MDIpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MDMgKyB4MDMpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MDQgKyB4MDQpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MDUgKyB4MDUpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MDYgKyB4MDYpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MDcgKyB4MDcpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MDggKyB4MDgpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MDkgKyB4MDkpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MTAgKyB4MTApIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MTEgKyB4MTEpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MTIgKyB4MTIpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MTMgKyB4MTMpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MTQgKyB4MTQpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MTUgKyB4MTUpIHwgMDtcclxufVxyXG5mdW5jdGlvbiBCbG9ja01peChpbnB1dCwgaWksIG91dCwgb2ksIHIpIHtcclxuICAgIC8vIFRoZSBibG9jayBCIGlzIHIgMTI4LWJ5dGUgY2h1bmtzICh3aGljaCBpcyBlcXVpdmFsZW50IG9mIDJyIDY0LWJ5dGUgY2h1bmtzKVxyXG4gICAgbGV0IGhlYWQgPSBvaSArIDA7XHJcbiAgICBsZXQgdGFpbCA9IG9pICsgMTYgKiByO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKVxyXG4gICAgICAgIG91dFt0YWlsICsgaV0gPSBpbnB1dFtpaSArICgyICogciAtIDEpICogMTYgKyBpXTsgLy8gWCDihpAgQlsycuKIkjFdXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHI7IGkrKywgaGVhZCArPSAxNiwgaWkgKz0gMTYpIHtcclxuICAgICAgICAvLyBXZSB3cml0ZSBvZGQgJiBldmVuIFlpIGF0IHNhbWUgdGltZS4gRXZlbjogMGJYWFhYWDAgT2RkOiAgMGJYWFhYWDFcclxuICAgICAgICBYb3JBbmRTYWxzYShvdXQsIHRhaWwsIGlucHV0LCBpaSwgb3V0LCBoZWFkKTsgLy8gaGVhZFtpXSA9IFNhbHNhKGJsb2NrSW5bMippXSBeIHRhaWxbaS0xXSlcclxuICAgICAgICBpZiAoaSA+IDApXHJcbiAgICAgICAgICAgIHRhaWwgKz0gMTY7IC8vIEZpcnN0IGl0ZXJhdGlvbiBvdmVyd3JpdGVzIHRtcCB2YWx1ZSBpbiB0YWlsXHJcbiAgICAgICAgWG9yQW5kU2Fsc2Eob3V0LCBoZWFkLCBpbnB1dCwgKGlpICs9IDE2KSwgb3V0LCB0YWlsKTsgLy8gdGFpbFtpXSA9IFNhbHNhKGJsb2NrSW5bMippKzFdIF4gaGVhZFtpXSlcclxuICAgIH1cclxufVxyXG4vLyBDb21tb24gcHJvbG9ndWUgYW5kIGVwaWxvZ3VlIGZvciBzeW5jL2FzeW5jIGZ1bmN0aW9uc1xyXG5mdW5jdGlvbiBzY3J5cHRJbml0KHBhc3N3b3JkLCBzYWx0LCBfb3B0cykge1xyXG4gICAgLy8gTWF4bWVtIC0gMUdCKzFLQiBieSBkZWZhdWx0XHJcbiAgICBjb25zdCBvcHRzID0gY2hlY2tPcHRzKHtcclxuICAgICAgICBka0xlbjogMzIsXHJcbiAgICAgICAgYXN5bmNUaWNrOiAxMCxcclxuICAgICAgICBtYXhtZW06IDEwMjQgKiogMyArIDEwMjQsXHJcbiAgICB9LCBfb3B0cyk7XHJcbiAgICBjb25zdCB7IE4sIHIsIHAsIGRrTGVuLCBhc3luY1RpY2ssIG1heG1lbSwgb25Qcm9ncmVzcyB9ID0gb3B0cztcclxuICAgIGFzc2VydE51bWJlcihOKTtcclxuICAgIGFzc2VydE51bWJlcihyKTtcclxuICAgIGFzc2VydE51bWJlcihwKTtcclxuICAgIGFzc2VydE51bWJlcihka0xlbik7XHJcbiAgICBhc3NlcnROdW1iZXIoYXN5bmNUaWNrKTtcclxuICAgIGFzc2VydE51bWJlcihtYXhtZW0pO1xyXG4gICAgaWYgKG9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb25Qcm9ncmVzcyAhPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2dyZXNzQ2Igc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XHJcbiAgICBjb25zdCBibG9ja1NpemUgPSAxMjggKiByO1xyXG4gICAgY29uc3QgYmxvY2tTaXplMzIgPSBibG9ja1NpemUgLyA0O1xyXG4gICAgaWYgKE4gPD0gMSB8fCAoTiAmIChOIC0gMSkpICE9PSAwIHx8IE4gPj0gMiAqKiAoYmxvY2tTaXplIC8gOCkgfHwgTiA+IDIgKiogMzIpIHtcclxuICAgICAgICAvLyBOT1RFOiB3ZSBsaW1pdCBOIHRvIGJlIGxlc3MgdGhhbiAyKiozMiBiZWNhdXNlIG9mIDMyIGJpdCB2YXJpYW50IG9mIEludGVncmlmeSBmdW5jdGlvblxyXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIEpTIGVuZ2luZXMgdGhhdCBhbGxvd3MgYWxvY2F0ZSBtb3JlIHRoYW4gNEdCIHBlciBzaW5nbGUgVWludDhBcnJheSBmb3Igbm93LCBidXQgY2FuIGNoYW5nZSBpbiBmdXR1cmUuXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY3J5cHQ6IE4gbXVzdCBiZSBsYXJnZXIgdGhhbiAxLCBhIHBvd2VyIG9mIDIsIGxlc3MgdGhhbiAyXigxMjggKiByIC8gOCkgYW5kIGxlc3MgdGhhbiAyXjMyJyk7XHJcbiAgICB9XHJcbiAgICBpZiAocCA8IDAgfHwgcCA+ICgoMiAqKiAzMiAtIDEpICogMzIpIC8gYmxvY2tTaXplKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY3J5cHQ6IHAgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICgoMl4zMiAtIDEpICogMzIpIC8gKDEyOCAqIHIpJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGtMZW4gPCAwIHx8IGRrTGVuID4gKDIgKiogMzIgLSAxKSAqIDMyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY3J5cHQ6IGRrTGVuIHNob3VsZCBiZSBwb3NpdGl2ZSBpbnRlZ2VyIGxlc3MgdGhhbiBvciBlcXVhbCB0byAoMl4zMiAtIDEpICogMzInKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG1lbVVzZWQgPSBibG9ja1NpemUgKiAoTiArIHApO1xyXG4gICAgaWYgKG1lbVVzZWQgPiBtYXhtZW0pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNjcnlwdDogcGFyYW1ldGVycyB0b28gbGFyZ2UsICR7bWVtVXNlZH0gKDEyOCAqIHIgKiAoTiArIHApKSA+ICR7bWF4bWVtfSAobWF4bWVtKWApO1xyXG4gICAgfVxyXG4gICAgLy8gW0IwLi4uQnDiiJIxXSDihpAgUEJLREYySE1BQy1TSEEyNTYoUGFzc3BocmFzZSwgU2FsdCwgMSwgYmxvY2tTaXplKlBhcmFsbGVsaXphdGlvbkZhY3RvcilcclxuICAgIC8vIFNpbmNlIGl0IGhhcyBvbmx5IG9uZSBpdGVyYXRpb24gdGhlcmUgaXMgbm8gcmVhc29uIHRvIHVzZSBhc3luYyB2YXJpYW50XHJcbiAgICBjb25zdCBCID0gcGJrZGYyKHNoYTI1NiwgcGFzc3dvcmQsIHNhbHQsIHsgYzogMSwgZGtMZW46IGJsb2NrU2l6ZSAqIHAgfSk7XHJcbiAgICBjb25zdCBCMzIgPSB1MzIoQik7XHJcbiAgICAvLyBSZS11c2VkIGJldHdlZW4gcGFyYWxsZWwgaXRlcmF0aW9ucy4gQXJyYXkoaXRlcmF0aW9ucykgb2YgQlxyXG4gICAgY29uc3QgViA9IHUzMihuZXcgVWludDhBcnJheShibG9ja1NpemUgKiBOKSk7XHJcbiAgICBjb25zdCB0bXAgPSB1MzIobmV3IFVpbnQ4QXJyYXkoYmxvY2tTaXplKSk7XHJcbiAgICBsZXQgYmxvY2tNaXhDYiA9ICgpID0+IHsgfTtcclxuICAgIGlmIChvblByb2dyZXNzKSB7XHJcbiAgICAgICAgY29uc3QgdG90YWxCbG9ja01peCA9IDIgKiBOICogcDtcclxuICAgICAgICAvLyBJbnZva2UgY2FsbGJhY2sgaWYgcHJvZ3Jlc3MgY2hhbmdlcyBmcm9tIDEwLjAxIHRvIDEwLjAyXHJcbiAgICAgICAgLy8gQWxsb3dzIHRvIGRyYXcgc21vb3RoIHByb2dyZXNzIGJhciBvbiB1cCB0byA4SyBzY3JlZW5cclxuICAgICAgICBjb25zdCBjYWxsYmFja1BlciA9IE1hdGgubWF4KE1hdGguZmxvb3IodG90YWxCbG9ja01peCAvIDEwMDAwKSwgMSk7XHJcbiAgICAgICAgbGV0IGJsb2NrTWl4Q250ID0gMDtcclxuICAgICAgICBibG9ja01peENiID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBibG9ja01peENudCsrO1xyXG4gICAgICAgICAgICBpZiAob25Qcm9ncmVzcyAmJiAoIShibG9ja01peENudCAlIGNhbGxiYWNrUGVyKSB8fCBibG9ja01peENudCA9PT0gdG90YWxCbG9ja01peCkpXHJcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzKGJsb2NrTWl4Q250IC8gdG90YWxCbG9ja01peCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IE4sIHIsIHAsIGRrTGVuLCBibG9ja1NpemUzMiwgViwgQjMyLCBCLCB0bXAsIGJsb2NrTWl4Q2IsIGFzeW5jVGljayB9O1xyXG59XHJcbmZ1bmN0aW9uIHNjcnlwdE91dHB1dChwYXNzd29yZCwgZGtMZW4sIEIsIFYsIHRtcCkge1xyXG4gICAgY29uc3QgcmVzID0gcGJrZGYyKHNoYTI1NiwgcGFzc3dvcmQsIEIsIHsgYzogMSwgZGtMZW4gfSk7XHJcbiAgICBCLmZpbGwoMCk7XHJcbiAgICBWLmZpbGwoMCk7XHJcbiAgICB0bXAuZmlsbCgwKTtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuLyoqXHJcbiAqIFNjcnlwdCBLREYgZnJvbSBSRkMgNzkxNC5cclxuICogQHBhcmFtIHBhc3N3b3JkIC0gcGFzc1xyXG4gKiBAcGFyYW0gc2FsdCAtIHNhbHRcclxuICogQHBhcmFtIG9wdHMgLSBwYXJhbWV0ZXJzXHJcbiAqIC0gYE5gIGlzIGNwdS9tZW0gd29yayBmYWN0b3IgKHBvd2VyIG9mIDIgZS5nLiAyKioxOClcclxuICogLSBgcmAgaXMgYmxvY2sgc2l6ZSAoOCBpcyBjb21tb24pLCBmaW5lLXR1bmVzIHNlcXVlbnRpYWwgbWVtb3J5IHJlYWQgc2l6ZSBhbmQgcGVyZm9ybWFuY2VcclxuICogLSBgcGAgaXMgcGFyYWxsZWxpemF0aW9uIGZhY3RvciAoMSBpcyBjb21tb24pXHJcbiAqIC0gYGRrTGVuYCBpcyBvdXRwdXQga2V5IGxlbmd0aCBpbiBieXRlcyBlLmcuIDMyLlxyXG4gKiAtIGBhc3luY1RpY2tgIC0gKGRlZmF1bHQ6IDEwKSBtYXggdGltZSBpbiBtcyBmb3Igd2hpY2ggYXN5bmMgZnVuY3Rpb24gY2FuIGJsb2NrIGV4ZWN1dGlvblxyXG4gKiAtIGBtYXhtZW1gIC0gKGRlZmF1bHQ6IGAxMDI0ICoqIDMgKyAxMDI0YCBha2EgMUdCKzFLQikuIEEgbGltaXQgdGhhdCB0aGUgYXBwIGNvdWxkIHVzZSBmb3Igc2NyeXB0XHJcbiAqIC0gYG9uUHJvZ3Jlc3NgIC0gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSBleGVjdXRlZCBmb3IgcHJvZ3Jlc3MgcmVwb3J0XHJcbiAqIEByZXR1cm5zIERlcml2ZWQga2V5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2NyeXB0KHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XHJcbiAgICBjb25zdCB7IE4sIHIsIHAsIGRrTGVuLCBibG9ja1NpemUzMiwgViwgQjMyLCBCLCB0bXAsIGJsb2NrTWl4Q2IgfSA9IHNjcnlwdEluaXQocGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xyXG4gICAgZm9yIChsZXQgcGkgPSAwOyBwaSA8IHA7IHBpKyspIHtcclxuICAgICAgICBjb25zdCBQaSA9IGJsb2NrU2l6ZTMyICogcGk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja1NpemUzMjsgaSsrKVxyXG4gICAgICAgICAgICBWW2ldID0gQjMyW1BpICsgaV07IC8vIFZbMF0gPSBCW2ldXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCBOIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIEJsb2NrTWl4KFYsIHBvcywgViwgKHBvcyArPSBibG9ja1NpemUzMiksIHIpOyAvLyBWW2ldID0gQmxvY2tNaXgoVltpLTFdKTtcclxuICAgICAgICAgICAgYmxvY2tNaXhDYigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBCbG9ja01peChWLCAoTiAtIDEpICogYmxvY2tTaXplMzIsIEIzMiwgUGksIHIpOyAvLyBQcm9jZXNzIGxhc3QgZWxlbWVudFxyXG4gICAgICAgIGJsb2NrTWl4Q2IoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykge1xyXG4gICAgICAgICAgICAvLyBGaXJzdCB1MzIgb2YgdGhlIGxhc3QgNjQtYnl0ZSBibG9jayAodTMyIGlzIExFKVxyXG4gICAgICAgICAgICBjb25zdCBqID0gQjMyW1BpICsgYmxvY2tTaXplMzIgLSAxNl0gJSBOOyAvLyBqID0gSW50ZWdyaWZ5KFgpICUgaXRlcmF0aW9uc1xyXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGJsb2NrU2l6ZTMyOyBrKyspXHJcbiAgICAgICAgICAgICAgICB0bXBba10gPSBCMzJbUGkgKyBrXSBeIFZbaiAqIGJsb2NrU2l6ZTMyICsga107IC8vIHRtcCA9IEIgXiBWW2pdXHJcbiAgICAgICAgICAgIEJsb2NrTWl4KHRtcCwgMCwgQjMyLCBQaSwgcik7IC8vIEIgPSBCbG9ja01peChCIF4gVltqXSlcclxuICAgICAgICAgICAgYmxvY2tNaXhDYigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzY3J5cHRPdXRwdXQocGFzc3dvcmQsIGRrTGVuLCBCLCBWLCB0bXApO1xyXG59XHJcbi8qKlxyXG4gKiBTY3J5cHQgS0RGIGZyb20gUkZDIDc5MTQuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2NyeXB0QXN5bmMocGFzc3dvcmQsIHNhbHQsIG9wdHMpIHtcclxuICAgIGNvbnN0IHsgTiwgciwgcCwgZGtMZW4sIGJsb2NrU2l6ZTMyLCBWLCBCMzIsIEIsIHRtcCwgYmxvY2tNaXhDYiwgYXN5bmNUaWNrIH0gPSBzY3J5cHRJbml0KHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcclxuICAgIGZvciAobGV0IHBpID0gMDsgcGkgPCBwOyBwaSsrKSB7XHJcbiAgICAgICAgY29uc3QgUGkgPSBibG9ja1NpemUzMiAqIHBpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tTaXplMzI7IGkrKylcclxuICAgICAgICAgICAgVltpXSA9IEIzMltQaSArIGldOyAvLyBWWzBdID0gQltpXVxyXG4gICAgICAgIGxldCBwb3MgPSAwO1xyXG4gICAgICAgIGF3YWl0IGFzeW5jTG9vcChOIC0gMSwgYXN5bmNUaWNrLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIEJsb2NrTWl4KFYsIHBvcywgViwgKHBvcyArPSBibG9ja1NpemUzMiksIHIpOyAvLyBWW2ldID0gQmxvY2tNaXgoVltpLTFdKTtcclxuICAgICAgICAgICAgYmxvY2tNaXhDYigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIEJsb2NrTWl4KFYsIChOIC0gMSkgKiBibG9ja1NpemUzMiwgQjMyLCBQaSwgcik7IC8vIFByb2Nlc3MgbGFzdCBlbGVtZW50XHJcbiAgICAgICAgYmxvY2tNaXhDYigpO1xyXG4gICAgICAgIGF3YWl0IGFzeW5jTG9vcChOLCBhc3luY1RpY2ssICgpID0+IHtcclxuICAgICAgICAgICAgLy8gRmlyc3QgdTMyIG9mIHRoZSBsYXN0IDY0LWJ5dGUgYmxvY2sgKHUzMiBpcyBMRSlcclxuICAgICAgICAgICAgY29uc3QgaiA9IEIzMltQaSArIGJsb2NrU2l6ZTMyIC0gMTZdICUgTjsgLy8gaiA9IEludGVncmlmeShYKSAlIGl0ZXJhdGlvbnNcclxuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBibG9ja1NpemUzMjsgaysrKVxyXG4gICAgICAgICAgICAgICAgdG1wW2tdID0gQjMyW1BpICsga10gXiBWW2ogKiBibG9ja1NpemUzMiArIGtdOyAvLyB0bXAgPSBCIF4gVltqXVxyXG4gICAgICAgICAgICBCbG9ja01peCh0bXAsIDAsIEIzMiwgUGksIHIpOyAvLyBCID0gQmxvY2tNaXgoQiBeIFZbal0pXHJcbiAgICAgICAgICAgIGJsb2NrTWl4Q2IoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBzY3J5cHRPdXRwdXQocGFzc3dvcmQsIGRrTGVuLCBCLCBWLCB0bXApO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcnlwdC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/hashes/esm/scrypt.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/hashes/esm/sha256.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha256.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n\r\n\r\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\r\n// BTC network is doing 2^67 hashes/sec as per early 2023.\r\n// Choice: a ? b : c\r\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\r\n// Majority function, true if any two inpust is true\r\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\r\n// Round constants:\r\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\r\n// prettier-ignore\r\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\r\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\r\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\r\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\r\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\r\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\r\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\r\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\r\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\r\n]);\r\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\r\n// prettier-ignore\r\nconst IV = /* @__PURE__ */ new Uint32Array([\r\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\r\n]);\r\n// Temporary buffer, not used to store anything between runs\r\n// Named this way because it matches specification.\r\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\r\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\r\n    constructor() {\r\n        super(64, 32, 8, false);\r\n        // We cannot use array here since array allows indexing by variable\r\n        // which means optimizer/compiler cannot use registers.\r\n        this.A = IV[0] | 0;\r\n        this.B = IV[1] | 0;\r\n        this.C = IV[2] | 0;\r\n        this.D = IV[3] | 0;\r\n        this.E = IV[4] | 0;\r\n        this.F = IV[5] | 0;\r\n        this.G = IV[6] | 0;\r\n        this.H = IV[7] | 0;\r\n    }\r\n    get() {\r\n        const { A, B, C, D, E, F, G, H } = this;\r\n        return [A, B, C, D, E, F, G, H];\r\n    }\r\n    // prettier-ignore\r\n    set(A, B, C, D, E, F, G, H) {\r\n        this.A = A | 0;\r\n        this.B = B | 0;\r\n        this.C = C | 0;\r\n        this.D = D | 0;\r\n        this.E = E | 0;\r\n        this.F = F | 0;\r\n        this.G = G | 0;\r\n        this.H = H | 0;\r\n    }\r\n    process(view, offset) {\r\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\r\n        for (let i = 0; i < 16; i++, offset += 4)\r\n            SHA256_W[i] = view.getUint32(offset, false);\r\n        for (let i = 16; i < 64; i++) {\r\n            const W15 = SHA256_W[i - 15];\r\n            const W2 = SHA256_W[i - 2];\r\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\r\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\r\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\r\n        }\r\n        // Compression function main loop, 64 rounds\r\n        let { A, B, C, D, E, F, G, H } = this;\r\n        for (let i = 0; i < 64; i++) {\r\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\r\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\r\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\r\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\r\n            H = G;\r\n            G = F;\r\n            F = E;\r\n            E = (D + T1) | 0;\r\n            D = C;\r\n            C = B;\r\n            B = A;\r\n            A = (T1 + T2) | 0;\r\n        }\r\n        // Add the compressed chunk to the current hash value\r\n        A = (A + this.A) | 0;\r\n        B = (B + this.B) | 0;\r\n        C = (C + this.C) | 0;\r\n        D = (D + this.D) | 0;\r\n        E = (E + this.E) | 0;\r\n        F = (F + this.F) | 0;\r\n        G = (G + this.G) | 0;\r\n        H = (H + this.H) | 0;\r\n        this.set(A, B, C, D, E, F, G, H);\r\n    }\r\n    roundClean() {\r\n        SHA256_W.fill(0);\r\n    }\r\n    destroy() {\r\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\r\n        this.buffer.fill(0);\r\n    }\r\n}\r\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\r\nclass SHA224 extends SHA256 {\r\n    constructor() {\r\n        super();\r\n        this.A = 0xc1059ed8 | 0;\r\n        this.B = 0x367cd507 | 0;\r\n        this.C = 0x3070dd17 | 0;\r\n        this.D = 0xf70e5939 | 0;\r\n        this.E = 0xffc00b31 | 0;\r\n        this.F = 0x68581511 | 0;\r\n        this.G = 0x64f98fa7 | 0;\r\n        this.H = 0xbefa4fa4 | 0;\r\n        this.outputLen = 28;\r\n    }\r\n}\r\n/**\r\n * SHA2-256 hash function\r\n * @param message - data that would be hashed\r\n */\r\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\r\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\r\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrQztBQUNpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUMsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsd0JBQXdCLFFBQVE7QUFDaEMsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRDtBQUNBLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLDBEQUFlO0FBQzlDLCtCQUErQiwwREFBZTtBQUNyRCIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXGVzbVxcc2hhMjU2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNIQTIgfSBmcm9tICcuL19zaGEyLmpzJztcclxuaW1wb3J0IHsgcm90ciwgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XHJcbi8vIFNIQTItMjU2IG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcyB0byBleGVjdXRlIGJpcnRoZGF5IGF0dGFjay5cclxuLy8gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl42NyBoYXNoZXMvc2VjIGFzIHBlciBlYXJseSAyMDIzLlxyXG4vLyBDaG9pY2U6IGEgPyBiIDogY1xyXG5jb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xyXG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXHJcbmNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XHJcbi8vIFJvdW5kIGNvbnN0YW50czpcclxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcclxuLy8gcHJldHRpZXItaWdub3JlXHJcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXHJcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxyXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcclxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXHJcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxyXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcclxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXHJcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxyXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxyXG5dKTtcclxuLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XHJcbi8vIHByZXR0aWVyLWlnbm9yZVxyXG5jb25zdCBJViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xyXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxyXG5dKTtcclxuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXHJcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxyXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xyXG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBTSEEyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xyXG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcclxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXHJcbiAgICAgICAgdGhpcy5BID0gSVZbMF0gfCAwO1xyXG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcclxuICAgICAgICB0aGlzLkMgPSBJVlsyXSB8IDA7XHJcbiAgICAgICAgdGhpcy5EID0gSVZbM10gfCAwO1xyXG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcclxuICAgICAgICB0aGlzLkYgPSBJVls1XSB8IDA7XHJcbiAgICAgICAgdGhpcy5HID0gSVZbNl0gfCAwO1xyXG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcclxuICAgIH1cclxuICAgIGdldCgpIHtcclxuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcclxuICAgIH1cclxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxyXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcclxuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcclxuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcclxuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcclxuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcclxuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcclxuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcclxuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcclxuICAgICAgICB0aGlzLkggPSBIIHwgMDtcclxuICAgIH1cclxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XHJcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcclxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XHJcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xyXG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcclxuICAgICAgICAgICAgY29uc3QgczEgPSByb3RyKFcyLCAxNykgXiByb3RyKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcclxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcclxuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSByb3RyKEUsIDYpIF4gcm90cihFLCAxMSkgXiByb3RyKEUsIDI1KTtcclxuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcclxuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XHJcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xyXG4gICAgICAgICAgICBIID0gRztcclxuICAgICAgICAgICAgRyA9IEY7XHJcbiAgICAgICAgICAgIEYgPSBFO1xyXG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xyXG4gICAgICAgICAgICBEID0gQztcclxuICAgICAgICAgICAgQyA9IEI7XHJcbiAgICAgICAgICAgIEIgPSBBO1xyXG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcclxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcclxuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcclxuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcclxuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcclxuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcclxuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcclxuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcclxuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcclxuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcclxuICAgIH1cclxuICAgIHJvdW5kQ2xlYW4oKSB7XHJcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcclxuICAgIH1cclxufVxyXG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXHJcbmNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuQSA9IDB4YzEwNTllZDggfCAwO1xyXG4gICAgICAgIHRoaXMuQiA9IDB4MzY3Y2Q1MDcgfCAwO1xyXG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xyXG4gICAgICAgIHRoaXMuRCA9IDB4ZjcwZTU5MzkgfCAwO1xyXG4gICAgICAgIHRoaXMuRSA9IDB4ZmZjMDBiMzEgfCAwO1xyXG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xyXG4gICAgICAgIHRoaXMuRyA9IDB4NjRmOThmYTcgfCAwO1xyXG4gICAgICAgIHRoaXMuSCA9IDB4YmVmYTRmYTQgfCAwO1xyXG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cclxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjU2KCkpO1xyXG5leHBvcnQgY29uc3Qgc2hhMjI0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjI0KCkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/hashes/esm/sha3.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha3.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: () => (/* binding */ Keccak),\n/* harmony export */   keccakP: () => (/* binding */ keccakP),\n/* harmony export */   keccak_224: () => (/* binding */ keccak_224),\n/* harmony export */   keccak_256: () => (/* binding */ keccak_256),\n/* harmony export */   keccak_384: () => (/* binding */ keccak_384),\n/* harmony export */   keccak_512: () => (/* binding */ keccak_512),\n/* harmony export */   sha3_224: () => (/* binding */ sha3_224),\n/* harmony export */   sha3_256: () => (/* binding */ sha3_256),\n/* harmony export */   sha3_384: () => (/* binding */ sha3_384),\n/* harmony export */   sha3_512: () => (/* binding */ sha3_512),\n/* harmony export */   shake128: () => (/* binding */ shake128),\n/* harmony export */   shake256: () => (/* binding */ shake256)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_assert.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n\r\n\r\n\r\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\r\n// It's called a sponge function.\r\n// Various per round constants calculations\r\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];\r\nconst _0n = /* @__PURE__ */ BigInt(0);\r\nconst _1n = /* @__PURE__ */ BigInt(1);\r\nconst _2n = /* @__PURE__ */ BigInt(2);\r\nconst _7n = /* @__PURE__ */ BigInt(7);\r\nconst _256n = /* @__PURE__ */ BigInt(256);\r\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\r\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\r\n    // Pi\r\n    [x, y] = [y, (2 * x + 3 * y) % 5];\r\n    SHA3_PI.push(2 * (5 * y + x));\r\n    // Rotational\r\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\r\n    // Iota\r\n    let t = _0n;\r\n    for (let j = 0; j < 7; j++) {\r\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\r\n        if (R & _2n)\r\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\r\n    }\r\n    _SHA3_IOTA.push(t);\r\n}\r\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\r\n// Left rotation (without 0, 32, 64)\r\nconst rotlH = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s));\r\nconst rotlL = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s));\r\n// Same as keccakf1600, but allows to skip some rounds\r\nfunction keccakP(s, rounds = 24) {\r\n    const B = new Uint32Array(5 * 2);\r\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\r\n    for (let round = 24 - rounds; round < 24; round++) {\r\n        // Theta \r\n        for (let x = 0; x < 10; x++)\r\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\r\n        for (let x = 0; x < 10; x += 2) {\r\n            const idx1 = (x + 8) % 10;\r\n            const idx0 = (x + 2) % 10;\r\n            const B0 = B[idx0];\r\n            const B1 = B[idx0 + 1];\r\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\r\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\r\n            for (let y = 0; y < 50; y += 10) {\r\n                s[x + y] ^= Th;\r\n                s[x + y + 1] ^= Tl;\r\n            }\r\n        }\r\n        // Rho () and Pi ()\r\n        let curH = s[2];\r\n        let curL = s[3];\r\n        for (let t = 0; t < 24; t++) {\r\n            const shift = SHA3_ROTL[t];\r\n            const Th = rotlH(curH, curL, shift);\r\n            const Tl = rotlL(curH, curL, shift);\r\n            const PI = SHA3_PI[t];\r\n            curH = s[PI];\r\n            curL = s[PI + 1];\r\n            s[PI] = Th;\r\n            s[PI + 1] = Tl;\r\n        }\r\n        // Chi ()\r\n        for (let y = 0; y < 50; y += 10) {\r\n            for (let x = 0; x < 10; x++)\r\n                B[x] = s[y + x];\r\n            for (let x = 0; x < 10; x++)\r\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\r\n        }\r\n        // Iota ()\r\n        s[0] ^= SHA3_IOTA_H[round];\r\n        s[1] ^= SHA3_IOTA_L[round];\r\n    }\r\n    B.fill(0);\r\n}\r\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\r\n    // NOTE: we accept arguments in bytes instead of bits here.\r\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\r\n        super();\r\n        this.blockLen = blockLen;\r\n        this.suffix = suffix;\r\n        this.outputLen = outputLen;\r\n        this.enableXOF = enableXOF;\r\n        this.rounds = rounds;\r\n        this.pos = 0;\r\n        this.posOut = 0;\r\n        this.finished = false;\r\n        this.destroyed = false;\r\n        // Can be passed from user as dkLen\r\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(outputLen);\r\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\r\n        if (0 >= this.blockLen || this.blockLen >= 200)\r\n            throw new Error('Sha3 supports only keccak-f1600 function');\r\n        this.state = new Uint8Array(200);\r\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\r\n    }\r\n    keccak() {\r\n        keccakP(this.state32, this.rounds);\r\n        this.posOut = 0;\r\n        this.pos = 0;\r\n    }\r\n    update(data) {\r\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this);\r\n        const { blockLen, state } = this;\r\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\r\n        const len = data.length;\r\n        for (let pos = 0; pos < len;) {\r\n            const take = Math.min(blockLen - this.pos, len - pos);\r\n            for (let i = 0; i < take; i++)\r\n                state[this.pos++] ^= data[pos++];\r\n            if (this.pos === blockLen)\r\n                this.keccak();\r\n        }\r\n        return this;\r\n    }\r\n    finish() {\r\n        if (this.finished)\r\n            return;\r\n        this.finished = true;\r\n        const { state, suffix, pos, blockLen } = this;\r\n        // Do the padding\r\n        state[pos] ^= suffix;\r\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\r\n            this.keccak();\r\n        state[blockLen - 1] ^= 0x80;\r\n        this.keccak();\r\n    }\r\n    writeInto(out) {\r\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this, false);\r\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.bytes)(out);\r\n        this.finish();\r\n        const bufferOut = this.state;\r\n        const { blockLen } = this;\r\n        for (let pos = 0, len = out.length; pos < len;) {\r\n            if (this.posOut >= blockLen)\r\n                this.keccak();\r\n            const take = Math.min(blockLen - this.posOut, len - pos);\r\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\r\n            this.posOut += take;\r\n            pos += take;\r\n        }\r\n        return out;\r\n    }\r\n    xofInto(out) {\r\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\r\n        if (!this.enableXOF)\r\n            throw new Error('XOF is not possible for this instance');\r\n        return this.writeInto(out);\r\n    }\r\n    xof(bytes) {\r\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(bytes);\r\n        return this.xofInto(new Uint8Array(bytes));\r\n    }\r\n    digestInto(out) {\r\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.output)(out, this);\r\n        if (this.finished)\r\n            throw new Error('digest() was already called');\r\n        this.writeInto(out);\r\n        this.destroy();\r\n        return out;\r\n    }\r\n    digest() {\r\n        return this.digestInto(new Uint8Array(this.outputLen));\r\n    }\r\n    destroy() {\r\n        this.destroyed = true;\r\n        this.state.fill(0);\r\n    }\r\n    _cloneInto(to) {\r\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\r\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\r\n        to.state32.set(this.state32);\r\n        to.pos = this.pos;\r\n        to.posOut = this.posOut;\r\n        to.finished = this.finished;\r\n        to.rounds = rounds;\r\n        // Suffix can change in cSHAKE\r\n        to.suffix = suffix;\r\n        to.outputLen = outputLen;\r\n        to.enableXOF = enableXOF;\r\n        to.destroyed = this.destroyed;\r\n        return to;\r\n    }\r\n}\r\nconst gen = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));\r\nconst sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\r\n/**\r\n * SHA3-256 hash function\r\n * @param message - that would be hashed\r\n */\r\nconst sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\r\nconst sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\r\nconst sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\r\nconst keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\r\n/**\r\n * keccak-256 hash function. Different from SHA3-256.\r\n * @param message - that would be hashed\r\n */\r\nconst keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\r\nconst keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\r\nconst keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\r\nconst genShake = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\r\nconst shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\r\nconst shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\r\n//# sourceMappingURL=sha3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2RDtBQUNLO0FBQzRCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsOENBQUs7QUFDeEQ7QUFDQSxxQ0FBcUMsK0NBQU0sWUFBWSwrQ0FBTTtBQUM3RCxxQ0FBcUMsK0NBQU0sWUFBWSwrQ0FBTTtBQUM3RDtBQUNPO0FBQ1A7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEMsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUJBQXFCLDJDQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFHO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLGdCQUFnQixrQkFBa0I7QUFDbEMsZUFBZSxrREFBTztBQUN0QjtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2QsUUFBUSxpREFBSztBQUNiO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQiw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpREFBaUQ7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywwREFBZTtBQUNyRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNQLGtEQUFrRCxxRUFBMEIsV0FBVztBQUNoRjtBQUNBO0FBQ1AiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxlc21cXHNoYTMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYnl0ZXMsIGV4aXN0cywgbnVtYmVyLCBvdXRwdXQgfSBmcm9tICcuL19hc3NlcnQuanMnO1xyXG5pbXBvcnQgeyByb3RsQkgsIHJvdGxCTCwgcm90bFNILCByb3RsU0wsIHNwbGl0IH0gZnJvbSAnLi9fdTY0LmpzJztcclxuaW1wb3J0IHsgSGFzaCwgdTMyLCB0b0J5dGVzLCB3cmFwQ29uc3RydWN0b3IsIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzLCB9IGZyb20gJy4vdXRpbHMuanMnO1xyXG4vLyBTSEEzIChrZWNjYWspIGlzIGJhc2VkIG9uIGEgbmV3IGRlc2lnbjogYmFzaWNhbGx5LCB0aGUgaW50ZXJuYWwgc3RhdGUgaXMgYmlnZ2VyIHRoYW4gb3V0cHV0IHNpemUuXHJcbi8vIEl0J3MgY2FsbGVkIGEgc3BvbmdlIGZ1bmN0aW9uLlxyXG4vLyBWYXJpb3VzIHBlciByb3VuZCBjb25zdGFudHMgY2FsY3VsYXRpb25zXHJcbmNvbnN0IFtTSEEzX1BJLCBTSEEzX1JPVEwsIF9TSEEzX0lPVEFdID0gW1tdLCBbXSwgW11dO1xyXG5jb25zdCBfMG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDApO1xyXG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xyXG5jb25zdCBfMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIpO1xyXG5jb25zdCBfN24gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDcpO1xyXG5jb25zdCBfMjU2biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMjU2KTtcclxuY29uc3QgXzB4NzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgweDcxKTtcclxuZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuLCB4ID0gMSwgeSA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcclxuICAgIC8vIFBpXHJcbiAgICBbeCwgeV0gPSBbeSwgKDIgKiB4ICsgMyAqIHkpICUgNV07XHJcbiAgICBTSEEzX1BJLnB1c2goMiAqICg1ICogeSArIHgpKTtcclxuICAgIC8vIFJvdGF0aW9uYWxcclxuICAgIFNIQTNfUk9UTC5wdXNoKCgoKHJvdW5kICsgMSkgKiAocm91bmQgKyAyKSkgLyAyKSAlIDY0KTtcclxuICAgIC8vIElvdGFcclxuICAgIGxldCB0ID0gXzBuO1xyXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcclxuICAgICAgICBSID0gKChSIDw8IF8xbikgXiAoKFIgPj4gXzduKSAqIF8weDcxbikpICUgXzI1Nm47XHJcbiAgICAgICAgaWYgKFIgJiBfMm4pXHJcbiAgICAgICAgICAgIHQgXj0gXzFuIDw8ICgoXzFuIDw8IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoaikpIC0gXzFuKTtcclxuICAgIH1cclxuICAgIF9TSEEzX0lPVEEucHVzaCh0KTtcclxufVxyXG5jb25zdCBbU0hBM19JT1RBX0gsIFNIQTNfSU9UQV9MXSA9IC8qIEBfX1BVUkVfXyAqLyBzcGxpdChfU0hBM19JT1RBLCB0cnVlKTtcclxuLy8gTGVmdCByb3RhdGlvbiAod2l0aG91dCAwLCAzMiwgNjQpXHJcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkgoaCwgbCwgcykgOiByb3RsU0goaCwgbCwgcykpO1xyXG5jb25zdCByb3RsTCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gcm90bEJMKGgsIGwsIHMpIDogcm90bFNMKGgsIGwsIHMpKTtcclxuLy8gU2FtZSBhcyBrZWNjYWtmMTYwMCwgYnV0IGFsbG93cyB0byBza2lwIHNvbWUgcm91bmRzXHJcbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWtQKHMsIHJvdW5kcyA9IDI0KSB7XHJcbiAgICBjb25zdCBCID0gbmV3IFVpbnQzMkFycmF5KDUgKiAyKTtcclxuICAgIC8vIE5PVEU6IGFsbCBpbmRpY2VzIGFyZSB4MiBzaW5jZSB3ZSBzdG9yZSBzdGF0ZSBhcyB1MzIgaW5zdGVhZCBvZiB1NjQgKGJpZ2ludHMgdG8gc2xvdyBpbiBqcylcclxuICAgIGZvciAobGV0IHJvdW5kID0gMjQgLSByb3VuZHM7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcclxuICAgICAgICAvLyBUaGV0YSDOuFxyXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcclxuICAgICAgICAgICAgQlt4XSA9IHNbeF0gXiBzW3ggKyAxMF0gXiBzW3ggKyAyMF0gXiBzW3ggKyAzMF0gXiBzW3ggKyA0MF07XHJcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCArPSAyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkeDAgPSAoeCArIDIpICUgMTA7XHJcbiAgICAgICAgICAgIGNvbnN0IEIwID0gQltpZHgwXTtcclxuICAgICAgICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcclxuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChCMCwgQjEsIDEpIF4gQltpZHgxXTtcclxuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChCMCwgQjEsIDEpIF4gQltpZHgxICsgMV07XHJcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcclxuICAgICAgICAgICAgICAgIHNbeCArIHldIF49IFRoO1xyXG4gICAgICAgICAgICAgICAgc1t4ICsgeSArIDFdIF49IFRsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJobyAoz4EpIGFuZCBQaSAoz4ApXHJcbiAgICAgICAgbGV0IGN1ckggPSBzWzJdO1xyXG4gICAgICAgIGxldCBjdXJMID0gc1szXTtcclxuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDI0OyB0KyspIHtcclxuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVExbdF07XHJcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoY3VySCwgY3VyTCwgc2hpZnQpO1xyXG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKGN1ckgsIGN1ckwsIHNoaWZ0KTtcclxuICAgICAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJW3RdO1xyXG4gICAgICAgICAgICBjdXJIID0gc1tQSV07XHJcbiAgICAgICAgICAgIGN1ckwgPSBzW1BJICsgMV07XHJcbiAgICAgICAgICAgIHNbUEldID0gVGg7XHJcbiAgICAgICAgICAgIHNbUEkgKyAxXSA9IFRsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGkgKM+HKVxyXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxyXG4gICAgICAgICAgICAgICAgQlt4XSA9IHNbeSArIHhdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXHJcbiAgICAgICAgICAgICAgICBzW3kgKyB4XSBePSB+QlsoeCArIDIpICUgMTBdICYgQlsoeCArIDQpICUgMTBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJb3RhICjOuSlcclxuICAgICAgICBzWzBdIF49IFNIQTNfSU9UQV9IW3JvdW5kXTtcclxuICAgICAgICBzWzFdIF49IFNIQTNfSU9UQV9MW3JvdW5kXTtcclxuICAgIH1cclxuICAgIEIuZmlsbCgwKTtcclxufVxyXG5leHBvcnQgY2xhc3MgS2VjY2FrIGV4dGVuZHMgSGFzaCB7XHJcbiAgICAvLyBOT1RFOiB3ZSBhY2NlcHQgYXJndW1lbnRzIGluIGJ5dGVzIGluc3RlYWQgb2YgYml0cyBoZXJlLlxyXG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YgPSBmYWxzZSwgcm91bmRzID0gMjQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcclxuICAgICAgICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeDtcclxuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcclxuICAgICAgICB0aGlzLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcclxuICAgICAgICB0aGlzLnJvdW5kcyA9IHJvdW5kcztcclxuICAgICAgICB0aGlzLnBvcyA9IDA7XHJcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xyXG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIENhbiBiZSBwYXNzZWQgZnJvbSB1c2VyIGFzIGRrTGVuXHJcbiAgICAgICAgbnVtYmVyKG91dHB1dExlbik7XHJcbiAgICAgICAgLy8gMTYwMCA9IDV4NSBtYXRyaXggb2YgNjRiaXQuICAxNjAwIGJpdHMgPT09IDIwMCBieXRlc1xyXG4gICAgICAgIGlmICgwID49IHRoaXMuYmxvY2tMZW4gfHwgdGhpcy5ibG9ja0xlbiA+PSAyMDApXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhMyBzdXBwb3J0cyBvbmx5IGtlY2Nhay1mMTYwMCBmdW5jdGlvbicpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgVWludDhBcnJheSgyMDApO1xyXG4gICAgICAgIHRoaXMuc3RhdGUzMiA9IHUzMih0aGlzLnN0YXRlKTtcclxuICAgIH1cclxuICAgIGtlY2NhaygpIHtcclxuICAgICAgICBrZWNjYWtQKHRoaXMuc3RhdGUzMiwgdGhpcy5yb3VuZHMpO1xyXG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcclxuICAgICAgICB0aGlzLnBvcyA9IDA7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoZGF0YSkge1xyXG4gICAgICAgIGV4aXN0cyh0aGlzKTtcclxuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdGF0ZSB9ID0gdGhpcztcclxuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcclxuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2U7IGkrKylcclxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBmaW5pc2goKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCB7IHN0YXRlLCBzdWZmaXgsIHBvcywgYmxvY2tMZW4gfSA9IHRoaXM7XHJcbiAgICAgICAgLy8gRG8gdGhlIHBhZGRpbmdcclxuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcclxuICAgICAgICBpZiAoKHN1ZmZpeCAmIDB4ODApICE9PSAwICYmIHBvcyA9PT0gYmxvY2tMZW4gLSAxKVxyXG4gICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xyXG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcclxuICAgICAgICB0aGlzLmtlY2NhaygpO1xyXG4gICAgfVxyXG4gICAgd3JpdGVJbnRvKG91dCkge1xyXG4gICAgICAgIGV4aXN0cyh0aGlzLCBmYWxzZSk7XHJcbiAgICAgICAgYnl0ZXMob3V0KTtcclxuICAgICAgICB0aGlzLmZpbmlzaCgpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlck91dCA9IHRoaXMuc3RhdGU7XHJcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcclxuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBsZW4gPSBvdXQubGVuZ3RoOyBwb3MgPCBsZW47KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc091dCA+PSBibG9ja0xlbilcclxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zT3V0LCBsZW4gLSBwb3MpO1xyXG4gICAgICAgICAgICBvdXQuc2V0KGJ1ZmZlck91dC5zdWJhcnJheSh0aGlzLnBvc091dCwgdGhpcy5wb3NPdXQgKyB0YWtlKSwgcG9zKTtcclxuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcclxuICAgICAgICAgICAgcG9zICs9IHRha2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcbiAgICB4b2ZJbnRvKG91dCkge1xyXG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcclxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlWE9GKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1hPRiBpcyBub3QgcG9zc2libGUgZm9yIHRoaXMgaW5zdGFuY2UnKTtcclxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcclxuICAgIH1cclxuICAgIHhvZihieXRlcykge1xyXG4gICAgICAgIG51bWJlcihieXRlcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xyXG4gICAgfVxyXG4gICAgZGlnZXN0SW50byhvdXQpIHtcclxuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcclxuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcclxuICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xyXG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcbiAgICBkaWdlc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5maWxsKDApO1xyXG4gICAgfVxyXG4gICAgX2Nsb25lSW50byh0bykge1xyXG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcclxuICAgICAgICB0byB8fCAodG8gPSBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GLCByb3VuZHMpKTtcclxuICAgICAgICB0by5zdGF0ZTMyLnNldCh0aGlzLnN0YXRlMzIpO1xyXG4gICAgICAgIHRvLnBvcyA9IHRoaXMucG9zO1xyXG4gICAgICAgIHRvLnBvc091dCA9IHRoaXMucG9zT3V0O1xyXG4gICAgICAgIHRvLmZpbmlzaGVkID0gdGhpcy5maW5pc2hlZDtcclxuICAgICAgICB0by5yb3VuZHMgPSByb3VuZHM7XHJcbiAgICAgICAgLy8gU3VmZml4IGNhbiBjaGFuZ2UgaW4gY1NIQUtFXHJcbiAgICAgICAgdG8uc3VmZml4ID0gc3VmZml4O1xyXG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcclxuICAgICAgICB0by5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XHJcbiAgICAgICAgdG8uZGVzdHJveWVkID0gdGhpcy5kZXN0cm95ZWQ7XHJcbiAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGdlbiA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpO1xyXG5leHBvcnQgY29uc3Qgc2hhM18yMjQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDE0NCwgMjI0IC8gOCk7XHJcbi8qKlxyXG4gKiBTSEEzLTI1NiBoYXNoIGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSBtZXNzYWdlIC0gdGhhdCB3b3VsZCBiZSBoYXNoZWRcclxuICovXHJcbmV4cG9ydCBjb25zdCBzaGEzXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgMTM2LCAyNTYgLyA4KTtcclxuZXhwb3J0IGNvbnN0IHNoYTNfMzg0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCAxMDQsIDM4NCAvIDgpO1xyXG5leHBvcnQgY29uc3Qgc2hhM181MTIgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDcyLCA1MTIgLyA4KTtcclxuZXhwb3J0IGNvbnN0IGtlY2Nha18yMjQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDE0NCwgMjI0IC8gOCk7XHJcbi8qKlxyXG4gKiBrZWNjYWstMjU2IGhhc2ggZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIFNIQTMtMjU2LlxyXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qga2VjY2FrXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KTtcclxuZXhwb3J0IGNvbnN0IGtlY2Nha18zODQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCk7XHJcbmV4cG9ydCBjb25zdCBrZWNjYWtfNTEyID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCA3MiwgNTEyIC8gOCk7XHJcbmNvbnN0IGdlblNoYWtlID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoKG9wdHMgPSB7fSkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyBvdXRwdXRMZW4gOiBvcHRzLmRrTGVuLCB0cnVlKSk7XHJcbmV4cG9ydCBjb25zdCBzaGFrZTEyOCA9IC8qIEBfX1BVUkVfXyAqLyBnZW5TaGFrZSgweDFmLCAxNjgsIDEyOCAvIDgpO1xyXG5leHBvcnQgY29uc3Qgc2hha2UyNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuU2hha2UoMHgxZiwgMTM2LCAyNTYgLyA4KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/hashes/esm/sha3.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/hashes/esm/sha512.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha512.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_sha2.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n\r\n\r\n\r\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\r\n// prettier-ignore\r\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].split([\r\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\r\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\r\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\r\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\r\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\r\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\r\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\r\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\r\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\r\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\r\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\r\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\r\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\r\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\r\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\r\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\r\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\r\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\r\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\r\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\r\n].map(n => BigInt(n))))();\r\n// Temporary buffer, not used to store anything between runs\r\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\r\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\r\nclass SHA512 extends _sha2_js__WEBPACK_IMPORTED_MODULE_1__.SHA2 {\r\n    constructor() {\r\n        super(128, 64, 16, false);\r\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\r\n        // Also looks cleaner and easier to verify with spec.\r\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\r\n        // h -- high 32 bits, l -- low 32 bits\r\n        this.Ah = 0x6a09e667 | 0;\r\n        this.Al = 0xf3bcc908 | 0;\r\n        this.Bh = 0xbb67ae85 | 0;\r\n        this.Bl = 0x84caa73b | 0;\r\n        this.Ch = 0x3c6ef372 | 0;\r\n        this.Cl = 0xfe94f82b | 0;\r\n        this.Dh = 0xa54ff53a | 0;\r\n        this.Dl = 0x5f1d36f1 | 0;\r\n        this.Eh = 0x510e527f | 0;\r\n        this.El = 0xade682d1 | 0;\r\n        this.Fh = 0x9b05688c | 0;\r\n        this.Fl = 0x2b3e6c1f | 0;\r\n        this.Gh = 0x1f83d9ab | 0;\r\n        this.Gl = 0xfb41bd6b | 0;\r\n        this.Hh = 0x5be0cd19 | 0;\r\n        this.Hl = 0x137e2179 | 0;\r\n    }\r\n    // prettier-ignore\r\n    get() {\r\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\r\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\r\n    }\r\n    // prettier-ignore\r\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\r\n        this.Ah = Ah | 0;\r\n        this.Al = Al | 0;\r\n        this.Bh = Bh | 0;\r\n        this.Bl = Bl | 0;\r\n        this.Ch = Ch | 0;\r\n        this.Cl = Cl | 0;\r\n        this.Dh = Dh | 0;\r\n        this.Dl = Dl | 0;\r\n        this.Eh = Eh | 0;\r\n        this.El = El | 0;\r\n        this.Fh = Fh | 0;\r\n        this.Fl = Fl | 0;\r\n        this.Gh = Gh | 0;\r\n        this.Gl = Gl | 0;\r\n        this.Hh = Hh | 0;\r\n        this.Hl = Hl | 0;\r\n    }\r\n    process(view, offset) {\r\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\r\n        for (let i = 0; i < 16; i++, offset += 4) {\r\n            SHA512_W_H[i] = view.getUint32(offset);\r\n            SHA512_W_L[i] = view.getUint32((offset += 4));\r\n        }\r\n        for (let i = 16; i < 80; i++) {\r\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\r\n            const W15h = SHA512_W_H[i - 15] | 0;\r\n            const W15l = SHA512_W_L[i - 15] | 0;\r\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W15h, W15l, 7);\r\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W15h, W15l, 7);\r\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\r\n            const W2h = SHA512_W_H[i - 2] | 0;\r\n            const W2l = SHA512_W_L[i - 2] | 0;\r\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W2h, W2l, 6);\r\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W2h, W2l, 6);\r\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\r\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\r\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\r\n            SHA512_W_H[i] = SUMh | 0;\r\n            SHA512_W_L[i] = SUMl | 0;\r\n        }\r\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\r\n        // Compression function main loop, 80 rounds\r\n        for (let i = 0; i < 80; i++) {\r\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\r\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Eh, El, 41);\r\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Eh, El, 41);\r\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\r\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\r\n            const CHIl = (El & Fl) ^ (~El & Gl);\r\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\r\n            // prettier-ignore\r\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\r\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\r\n            const T1l = T1ll | 0;\r\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\r\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 39);\r\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 39);\r\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\r\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\r\n            Hh = Gh | 0;\r\n            Hl = Gl | 0;\r\n            Gh = Fh | 0;\r\n            Gl = Fl | 0;\r\n            Fh = Eh | 0;\r\n            Fl = El | 0;\r\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\r\n            Dh = Ch | 0;\r\n            Dl = Cl | 0;\r\n            Ch = Bh | 0;\r\n            Cl = Bl | 0;\r\n            Bh = Ah | 0;\r\n            Bl = Al | 0;\r\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3L(T1l, sigma0l, MAJl);\r\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3H(All, T1h, sigma0h, MAJh);\r\n            Al = All | 0;\r\n        }\r\n        // Add the compressed chunk to the current hash value\r\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\r\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\r\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\r\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\r\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\r\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\r\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\r\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\r\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\r\n    }\r\n    roundClean() {\r\n        SHA512_W_H.fill(0);\r\n        SHA512_W_L.fill(0);\r\n    }\r\n    destroy() {\r\n        this.buffer.fill(0);\r\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\r\n    }\r\n}\r\nclass SHA512_224 extends SHA512 {\r\n    constructor() {\r\n        super();\r\n        // h -- high 32 bits, l -- low 32 bits\r\n        this.Ah = 0x8c3d37c8 | 0;\r\n        this.Al = 0x19544da2 | 0;\r\n        this.Bh = 0x73e19966 | 0;\r\n        this.Bl = 0x89dcd4d6 | 0;\r\n        this.Ch = 0x1dfab7ae | 0;\r\n        this.Cl = 0x32ff9c82 | 0;\r\n        this.Dh = 0x679dd514 | 0;\r\n        this.Dl = 0x582f9fcf | 0;\r\n        this.Eh = 0x0f6d2b69 | 0;\r\n        this.El = 0x7bd44da8 | 0;\r\n        this.Fh = 0x77e36f73 | 0;\r\n        this.Fl = 0x04c48942 | 0;\r\n        this.Gh = 0x3f9d85a8 | 0;\r\n        this.Gl = 0x6a1d36c8 | 0;\r\n        this.Hh = 0x1112e6ad | 0;\r\n        this.Hl = 0x91d692a1 | 0;\r\n        this.outputLen = 28;\r\n    }\r\n}\r\nclass SHA512_256 extends SHA512 {\r\n    constructor() {\r\n        super();\r\n        // h -- high 32 bits, l -- low 32 bits\r\n        this.Ah = 0x22312194 | 0;\r\n        this.Al = 0xfc2bf72c | 0;\r\n        this.Bh = 0x9f555fa3 | 0;\r\n        this.Bl = 0xc84c64c2 | 0;\r\n        this.Ch = 0x2393b86b | 0;\r\n        this.Cl = 0x6f53b151 | 0;\r\n        this.Dh = 0x96387719 | 0;\r\n        this.Dl = 0x5940eabd | 0;\r\n        this.Eh = 0x96283ee2 | 0;\r\n        this.El = 0xa88effe3 | 0;\r\n        this.Fh = 0xbe5e1e25 | 0;\r\n        this.Fl = 0x53863992 | 0;\r\n        this.Gh = 0x2b0199fc | 0;\r\n        this.Gl = 0x2c85b8aa | 0;\r\n        this.Hh = 0x0eb72ddc | 0;\r\n        this.Hl = 0x81c52ca2 | 0;\r\n        this.outputLen = 32;\r\n    }\r\n}\r\nclass SHA384 extends SHA512 {\r\n    constructor() {\r\n        super();\r\n        // h -- high 32 bits, l -- low 32 bits\r\n        this.Ah = 0xcbbb9d5d | 0;\r\n        this.Al = 0xc1059ed8 | 0;\r\n        this.Bh = 0x629a292a | 0;\r\n        this.Bl = 0x367cd507 | 0;\r\n        this.Ch = 0x9159015a | 0;\r\n        this.Cl = 0x3070dd17 | 0;\r\n        this.Dh = 0x152fecd8 | 0;\r\n        this.Dl = 0xf70e5939 | 0;\r\n        this.Eh = 0x67332667 | 0;\r\n        this.El = 0xffc00b31 | 0;\r\n        this.Fh = 0x8eb44a87 | 0;\r\n        this.Fl = 0x68581511 | 0;\r\n        this.Gh = 0xdb0c2e0d | 0;\r\n        this.Gl = 0x64f98fa7 | 0;\r\n        this.Hh = 0x47b5481d | 0;\r\n        this.Hl = 0xbefa4fa4 | 0;\r\n        this.outputLen = 48;\r\n    }\r\n}\r\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512());\r\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_224());\r\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_256());\r\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA384());\r\n//# sourceMappingURL=sha512.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGE1MTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBa0M7QUFDTjtBQUNpQjtBQUM3QztBQUNBO0FBQ0Esc0RBQXNELHFEQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQiwwQ0FBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpRUFBaUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVSxrQkFBa0Isc0RBQVUsa0JBQWtCLHFEQUFTO0FBQ3pGLHdCQUF3QixzREFBVSxrQkFBa0Isc0RBQVUsa0JBQWtCLHFEQUFTO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVSxpQkFBaUIsc0RBQVUsaUJBQWlCLHFEQUFTO0FBQ3ZGLHdCQUF3QixzREFBVSxpQkFBaUIsc0RBQVUsaUJBQWlCLHFEQUFTO0FBQ3ZGO0FBQ0EseUJBQXlCLHFEQUFTO0FBQ2xDLHlCQUF5QixxREFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQSxjQUFjLGlFQUFpRTtBQUMvRTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EsNEJBQTRCLHNEQUFVLGVBQWUsc0RBQVUsZUFBZSxzREFBVTtBQUN4Riw0QkFBNEIsc0RBQVUsZUFBZSxzREFBVSxlQUFlLHNEQUFVO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscURBQVM7QUFDbEMsd0JBQXdCLHFEQUFTO0FBQ2pDO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQVUsZUFBZSxzREFBVSxlQUFlLHNEQUFVO0FBQ3hGLDRCQUE0QixzREFBVSxlQUFlLHNEQUFVLGVBQWUsc0RBQVU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZSxFQUFFLG1EQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxREFBUztBQUNqQyxpQkFBaUIscURBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQiwwREFBZTtBQUM5QyxtQ0FBbUMsMERBQWU7QUFDbEQsbUNBQW1DLDBEQUFlO0FBQ2xELCtCQUErQiwwREFBZTtBQUNyRCIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXGVzbVxcc2hhNTEyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNIQTIgfSBmcm9tICcuL19zaGEyLmpzJztcclxuaW1wb3J0IHU2NCBmcm9tICcuL191NjQuanMnO1xyXG5pbXBvcnQgeyB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcclxuLy8gUm91bmQgY29udGFudHMgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDgwIHByaW1lcyAyLi40MDkpOlxyXG4vLyBwcmV0dGllci1pZ25vcmVcclxuY29uc3QgW1NIQTUxMl9LaCwgU0hBNTEyX0tsXSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdTY0LnNwbGl0KFtcclxuICAgICcweDQyOGEyZjk4ZDcyOGFlMjInLCAnMHg3MTM3NDQ5MTIzZWY2NWNkJywgJzB4YjVjMGZiY2ZlYzRkM2IyZicsICcweGU5YjVkYmE1ODE4OWRiYmMnLFxyXG4gICAgJzB4Mzk1NmMyNWJmMzQ4YjUzOCcsICcweDU5ZjExMWYxYjYwNWQwMTknLCAnMHg5MjNmODJhNGFmMTk0ZjliJywgJzB4YWIxYzVlZDVkYTZkODExOCcsXHJcbiAgICAnMHhkODA3YWE5OGEzMDMwMjQyJywgJzB4MTI4MzViMDE0NTcwNmZiZScsICcweDI0MzE4NWJlNGVlNGIyOGMnLCAnMHg1NTBjN2RjM2Q1ZmZiNGUyJyxcclxuICAgICcweDcyYmU1ZDc0ZjI3Yjg5NmYnLCAnMHg4MGRlYjFmZTNiMTY5NmIxJywgJzB4OWJkYzA2YTcyNWM3MTIzNScsICcweGMxOWJmMTc0Y2Y2OTI2OTQnLFxyXG4gICAgJzB4ZTQ5YjY5YzE5ZWYxNGFkMicsICcweGVmYmU0Nzg2Mzg0ZjI1ZTMnLCAnMHgwZmMxOWRjNjhiOGNkNWI1JywgJzB4MjQwY2ExY2M3N2FjOWM2NScsXHJcbiAgICAnMHgyZGU5MmM2ZjU5MmIwMjc1JywgJzB4NGE3NDg0YWE2ZWE2ZTQ4MycsICcweDVjYjBhOWRjYmQ0MWZiZDQnLCAnMHg3NmY5ODhkYTgzMTE1M2I1JyxcclxuICAgICcweDk4M2U1MTUyZWU2NmRmYWInLCAnMHhhODMxYzY2ZDJkYjQzMjEwJywgJzB4YjAwMzI3Yzg5OGZiMjEzZicsICcweGJmNTk3ZmM3YmVlZjBlZTQnLFxyXG4gICAgJzB4YzZlMDBiZjMzZGE4OGZjMicsICcweGQ1YTc5MTQ3OTMwYWE3MjUnLCAnMHgwNmNhNjM1MWUwMDM4MjZmJywgJzB4MTQyOTI5NjcwYTBlNmU3MCcsXHJcbiAgICAnMHgyN2I3MGE4NTQ2ZDIyZmZjJywgJzB4MmUxYjIxMzg1YzI2YzkyNicsICcweDRkMmM2ZGZjNWFjNDJhZWQnLCAnMHg1MzM4MGQxMzlkOTViM2RmJyxcclxuICAgICcweDY1MGE3MzU0OGJhZjYzZGUnLCAnMHg3NjZhMGFiYjNjNzdiMmE4JywgJzB4ODFjMmM5MmU0N2VkYWVlNicsICcweDkyNzIyYzg1MTQ4MjM1M2InLFxyXG4gICAgJzB4YTJiZmU4YTE0Y2YxMDM2NCcsICcweGE4MWE2NjRiYmM0MjMwMDEnLCAnMHhjMjRiOGI3MGQwZjg5NzkxJywgJzB4Yzc2YzUxYTMwNjU0YmUzMCcsXHJcbiAgICAnMHhkMTkyZTgxOWQ2ZWY1MjE4JywgJzB4ZDY5OTA2MjQ1NTY1YTkxMCcsICcweGY0MGUzNTg1NTc3MTIwMmEnLCAnMHgxMDZhYTA3MDMyYmJkMWI4JyxcclxuICAgICcweDE5YTRjMTE2YjhkMmQwYzgnLCAnMHgxZTM3NmMwODUxNDFhYjUzJywgJzB4Mjc0ODc3NGNkZjhlZWI5OScsICcweDM0YjBiY2I1ZTE5YjQ4YTgnLFxyXG4gICAgJzB4MzkxYzBjYjNjNWM5NWE2MycsICcweDRlZDhhYTRhZTM0MThhY2InLCAnMHg1YjljY2E0Zjc3NjNlMzczJywgJzB4NjgyZTZmZjNkNmIyYjhhMycsXHJcbiAgICAnMHg3NDhmODJlZTVkZWZiMmZjJywgJzB4NzhhNTYzNmY0MzE3MmY2MCcsICcweDg0Yzg3ODE0YTFmMGFiNzInLCAnMHg4Y2M3MDIwODFhNjQzOWVjJyxcclxuICAgICcweDkwYmVmZmZhMjM2MzFlMjgnLCAnMHhhNDUwNmNlYmRlODJiZGU5JywgJzB4YmVmOWEzZjdiMmM2NzkxNScsICcweGM2NzE3OGYyZTM3MjUzMmInLFxyXG4gICAgJzB4Y2EyNzNlY2VlYTI2NjE5YycsICcweGQxODZiOGM3MjFjMGMyMDcnLCAnMHhlYWRhN2RkNmNkZTBlYjFlJywgJzB4ZjU3ZDRmN2ZlZTZlZDE3OCcsXHJcbiAgICAnMHgwNmYwNjdhYTcyMTc2ZmJhJywgJzB4MGE2MzdkYzVhMmM4OThhNicsICcweDExM2Y5ODA0YmVmOTBkYWUnLCAnMHgxYjcxMGIzNTEzMWM0NzFiJyxcclxuICAgICcweDI4ZGI3N2Y1MjMwNDdkODQnLCAnMHgzMmNhYWI3YjQwYzcyNDkzJywgJzB4M2M5ZWJlMGExNWM5YmViYycsICcweDQzMWQ2N2M0OWMxMDBkNGMnLFxyXG4gICAgJzB4NGNjNWQ0YmVjYjNlNDJiNicsICcweDU5N2YyOTljZmM2NTdlMmEnLCAnMHg1ZmNiNmZhYjNhZDZmYWVjJywgJzB4NmM0NDE5OGM0YTQ3NTgxNydcclxuXS5tYXAobiA9PiBCaWdJbnQobikpKSkoKTtcclxuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXHJcbmNvbnN0IFNIQTUxMl9XX0ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcclxuY29uc3QgU0hBNTEyX1dfTCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xyXG5leHBvcnQgY2xhc3MgU0hBNTEyIGV4dGVuZHMgU0hBMiB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigxMjgsIDY0LCAxNiwgZmFsc2UpO1xyXG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGUgd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxyXG4gICAgICAgIC8vIEFsc28gbG9va3MgY2xlYW5lciBhbmQgZWFzaWVyIHRvIHZlcmlmeSB3aXRoIHNwZWMuXHJcbiAgICAgICAgLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XHJcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcclxuICAgICAgICB0aGlzLkFoID0gMHg2YTA5ZTY2NyB8IDA7XHJcbiAgICAgICAgdGhpcy5BbCA9IDB4ZjNiY2M5MDggfCAwO1xyXG4gICAgICAgIHRoaXMuQmggPSAweGJiNjdhZTg1IHwgMDtcclxuICAgICAgICB0aGlzLkJsID0gMHg4NGNhYTczYiB8IDA7XHJcbiAgICAgICAgdGhpcy5DaCA9IDB4M2M2ZWYzNzIgfCAwO1xyXG4gICAgICAgIHRoaXMuQ2wgPSAweGZlOTRmODJiIHwgMDtcclxuICAgICAgICB0aGlzLkRoID0gMHhhNTRmZjUzYSB8IDA7XHJcbiAgICAgICAgdGhpcy5EbCA9IDB4NWYxZDM2ZjEgfCAwO1xyXG4gICAgICAgIHRoaXMuRWggPSAweDUxMGU1MjdmIHwgMDtcclxuICAgICAgICB0aGlzLkVsID0gMHhhZGU2ODJkMSB8IDA7XHJcbiAgICAgICAgdGhpcy5GaCA9IDB4OWIwNTY4OGMgfCAwO1xyXG4gICAgICAgIHRoaXMuRmwgPSAweDJiM2U2YzFmIHwgMDtcclxuICAgICAgICB0aGlzLkdoID0gMHgxZjgzZDlhYiB8IDA7XHJcbiAgICAgICAgdGhpcy5HbCA9IDB4ZmI0MWJkNmIgfCAwO1xyXG4gICAgICAgIHRoaXMuSGggPSAweDViZTBjZDE5IHwgMDtcclxuICAgICAgICB0aGlzLkhsID0gMHgxMzdlMjE3OSB8IDA7XHJcbiAgICB9XHJcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcclxuICAgIGdldCgpIHtcclxuICAgICAgICBjb25zdCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBbQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGxdO1xyXG4gICAgfVxyXG4gICAgLy8gcHJldHRpZXItaWdub3JlXHJcbiAgICBzZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpIHtcclxuICAgICAgICB0aGlzLkFoID0gQWggfCAwO1xyXG4gICAgICAgIHRoaXMuQWwgPSBBbCB8IDA7XHJcbiAgICAgICAgdGhpcy5CaCA9IEJoIHwgMDtcclxuICAgICAgICB0aGlzLkJsID0gQmwgfCAwO1xyXG4gICAgICAgIHRoaXMuQ2ggPSBDaCB8IDA7XHJcbiAgICAgICAgdGhpcy5DbCA9IENsIHwgMDtcclxuICAgICAgICB0aGlzLkRoID0gRGggfCAwO1xyXG4gICAgICAgIHRoaXMuRGwgPSBEbCB8IDA7XHJcbiAgICAgICAgdGhpcy5FaCA9IEVoIHwgMDtcclxuICAgICAgICB0aGlzLkVsID0gRWwgfCAwO1xyXG4gICAgICAgIHRoaXMuRmggPSBGaCB8IDA7XHJcbiAgICAgICAgdGhpcy5GbCA9IEZsIHwgMDtcclxuICAgICAgICB0aGlzLkdoID0gR2ggfCAwO1xyXG4gICAgICAgIHRoaXMuR2wgPSBHbCB8IDA7XHJcbiAgICAgICAgdGhpcy5IaCA9IEhoIHwgMDtcclxuICAgICAgICB0aGlzLkhsID0gSGwgfCAwO1xyXG4gICAgfVxyXG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcclxuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA2NCB3b3JkcyB3WzE2Li43OV0gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KSB7XHJcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xyXG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gdmlldy5nZXRVaW50MzIoKG9mZnNldCArPSA0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gczAgOj0gKHdbaS0xNV0gcmlnaHRyb3RhdGUgMSkgeG9yICh3W2ktMTVdIHJpZ2h0cm90YXRlIDgpIHhvciAod1tpLTE1XSByaWdodHNoaWZ0IDcpXHJcbiAgICAgICAgICAgIGNvbnN0IFcxNWggPSBTSEE1MTJfV19IW2kgLSAxNV0gfCAwO1xyXG4gICAgICAgICAgICBjb25zdCBXMTVsID0gU0hBNTEyX1dfTFtpIC0gMTVdIHwgMDtcclxuICAgICAgICAgICAgY29uc3QgczBoID0gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0goVzE1aCwgVzE1bCwgNyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHMwbCA9IHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNMKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNMKFcxNWgsIFcxNWwsIDcpO1xyXG4gICAgICAgICAgICAvLyBzMSA6PSAod1tpLTJdIHJpZ2h0cm90YXRlIDE5KSB4b3IgKHdbaS0yXSByaWdodHJvdGF0ZSA2MSkgeG9yICh3W2ktMl0gcmlnaHRzaGlmdCA2KVxyXG4gICAgICAgICAgICBjb25zdCBXMmggPSBTSEE1MTJfV19IW2kgLSAyXSB8IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IFcybCA9IFNIQTUxMl9XX0xbaSAtIDJdIHwgMDtcclxuICAgICAgICAgICAgY29uc3QgczFoID0gdTY0LnJvdHJTSChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCSChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNIKFcyaCwgVzJsLCA2KTtcclxuICAgICAgICAgICAgY29uc3QgczFsID0gdTY0LnJvdHJTTChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCTChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNMKFcyaCwgVzJsLCA2KTtcclxuICAgICAgICAgICAgLy8gU0hBMjU2X1dbaV0gPSBzMCArIHMxICsgU0hBMjU2X1dbaSAtIDddICsgU0hBMjU2X1dbaSAtIDE2XTtcclxuICAgICAgICAgICAgY29uc3QgU1VNbCA9IHU2NC5hZGQ0TChzMGwsIHMxbCwgU0hBNTEyX1dfTFtpIC0gN10sIFNIQTUxMl9XX0xbaSAtIDE2XSk7XHJcbiAgICAgICAgICAgIGNvbnN0IFNVTWggPSB1NjQuYWRkNEgoU1VNbCwgczBoLCBzMWgsIFNIQTUxMl9XX0hbaSAtIDddLCBTSEE1MTJfV19IW2kgLSAxNl0pO1xyXG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gU1VNaCB8IDA7XHJcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSBTVU1sIHwgMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XHJcbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA4MCByb3VuZHNcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gUzEgOj0gKGUgcmlnaHRyb3RhdGUgMTQpIHhvciAoZSByaWdodHJvdGF0ZSAxOCkgeG9yIChlIHJpZ2h0cm90YXRlIDQxKVxyXG4gICAgICAgICAgICBjb25zdCBzaWdtYTFoID0gdTY0LnJvdHJTSChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0goRWgsIEVsLCAxOCkgXiB1NjQucm90ckJIKEVoLCBFbCwgNDEpO1xyXG4gICAgICAgICAgICBjb25zdCBzaWdtYTFsID0gdTY0LnJvdHJTTChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0woRWgsIEVsLCAxOCkgXiB1NjQucm90ckJMKEVoLCBFbCwgNDEpO1xyXG4gICAgICAgICAgICAvL2NvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IENISWggPSAoRWggJiBGaCkgXiAofkVoICYgR2gpO1xyXG4gICAgICAgICAgICBjb25zdCBDSElsID0gKEVsICYgRmwpIF4gKH5FbCAmIEdsKTtcclxuICAgICAgICAgICAgLy8gVDEgPSBIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBNTEyX0tbaV0gKyBTSEE1MTJfV1tpXVxyXG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcclxuICAgICAgICAgICAgY29uc3QgVDFsbCA9IHU2NC5hZGQ1TChIbCwgc2lnbWExbCwgQ0hJbCwgU0hBNTEyX0tsW2ldLCBTSEE1MTJfV19MW2ldKTtcclxuICAgICAgICAgICAgY29uc3QgVDFoID0gdTY0LmFkZDVIKFQxbGwsIEhoLCBzaWdtYTFoLCBDSEloLCBTSEE1MTJfS2hbaV0sIFNIQTUxMl9XX0hbaV0pO1xyXG4gICAgICAgICAgICBjb25zdCBUMWwgPSBUMWxsIHwgMDtcclxuICAgICAgICAgICAgLy8gUzAgOj0gKGEgcmlnaHRyb3RhdGUgMjgpIHhvciAoYSByaWdodHJvdGF0ZSAzNCkgeG9yIChhIHJpZ2h0cm90YXRlIDM5KVxyXG4gICAgICAgICAgICBjb25zdCBzaWdtYTBoID0gdTY0LnJvdHJTSChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzkpO1xyXG4gICAgICAgICAgICBjb25zdCBzaWdtYTBsID0gdTY0LnJvdHJTTChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzkpO1xyXG4gICAgICAgICAgICBjb25zdCBNQUpoID0gKEFoICYgQmgpIF4gKEFoICYgQ2gpIF4gKEJoICYgQ2gpO1xyXG4gICAgICAgICAgICBjb25zdCBNQUpsID0gKEFsICYgQmwpIF4gKEFsICYgQ2wpIF4gKEJsICYgQ2wpO1xyXG4gICAgICAgICAgICBIaCA9IEdoIHwgMDtcclxuICAgICAgICAgICAgSGwgPSBHbCB8IDA7XHJcbiAgICAgICAgICAgIEdoID0gRmggfCAwO1xyXG4gICAgICAgICAgICBHbCA9IEZsIHwgMDtcclxuICAgICAgICAgICAgRmggPSBFaCB8IDA7XHJcbiAgICAgICAgICAgIEZsID0gRWwgfCAwO1xyXG4gICAgICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQoRGggfCAwLCBEbCB8IDAsIFQxaCB8IDAsIFQxbCB8IDApKTtcclxuICAgICAgICAgICAgRGggPSBDaCB8IDA7XHJcbiAgICAgICAgICAgIERsID0gQ2wgfCAwO1xyXG4gICAgICAgICAgICBDaCA9IEJoIHwgMDtcclxuICAgICAgICAgICAgQ2wgPSBCbCB8IDA7XHJcbiAgICAgICAgICAgIEJoID0gQWggfCAwO1xyXG4gICAgICAgICAgICBCbCA9IEFsIHwgMDtcclxuICAgICAgICAgICAgY29uc3QgQWxsID0gdTY0LmFkZDNMKFQxbCwgc2lnbWEwbCwgTUFKbCk7XHJcbiAgICAgICAgICAgIEFoID0gdTY0LmFkZDNIKEFsbCwgVDFoLCBzaWdtYTBoLCBNQUpoKTtcclxuICAgICAgICAgICAgQWwgPSBBbGwgfCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxyXG4gICAgICAgICh7IGg6IEFoLCBsOiBBbCB9ID0gdTY0LmFkZCh0aGlzLkFoIHwgMCwgdGhpcy5BbCB8IDAsIEFoIHwgMCwgQWwgfCAwKSk7XHJcbiAgICAgICAgKHsgaDogQmgsIGw6IEJsIH0gPSB1NjQuYWRkKHRoaXMuQmggfCAwLCB0aGlzLkJsIHwgMCwgQmggfCAwLCBCbCB8IDApKTtcclxuICAgICAgICAoeyBoOiBDaCwgbDogQ2wgfSA9IHU2NC5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBDaCB8IDAsIENsIHwgMCkpO1xyXG4gICAgICAgICh7IGg6IERoLCBsOiBEbCB9ID0gdTY0LmFkZCh0aGlzLkRoIHwgMCwgdGhpcy5EbCB8IDAsIERoIHwgMCwgRGwgfCAwKSk7XHJcbiAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKHRoaXMuRWggfCAwLCB0aGlzLkVsIHwgMCwgRWggfCAwLCBFbCB8IDApKTtcclxuICAgICAgICAoeyBoOiBGaCwgbDogRmwgfSA9IHU2NC5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBGaCB8IDAsIEZsIHwgMCkpO1xyXG4gICAgICAgICh7IGg6IEdoLCBsOiBHbCB9ID0gdTY0LmFkZCh0aGlzLkdoIHwgMCwgdGhpcy5HbCB8IDAsIEdoIHwgMCwgR2wgfCAwKSk7XHJcbiAgICAgICAgKHsgaDogSGgsIGw6IEhsIH0gPSB1NjQuYWRkKHRoaXMuSGggfCAwLCB0aGlzLkhsIHwgMCwgSGggfCAwLCBIbCB8IDApKTtcclxuICAgICAgICB0aGlzLnNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCk7XHJcbiAgICB9XHJcbiAgICByb3VuZENsZWFuKCkge1xyXG4gICAgICAgIFNIQTUxMl9XX0guZmlsbCgwKTtcclxuICAgICAgICBTSEE1MTJfV19MLmZpbGwoMCk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XHJcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgU0hBNTEyXzIyNCBleHRlbmRzIFNIQTUxMiB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXHJcbiAgICAgICAgdGhpcy5BaCA9IDB4OGMzZDM3YzggfCAwO1xyXG4gICAgICAgIHRoaXMuQWwgPSAweDE5NTQ0ZGEyIHwgMDtcclxuICAgICAgICB0aGlzLkJoID0gMHg3M2UxOTk2NiB8IDA7XHJcbiAgICAgICAgdGhpcy5CbCA9IDB4ODlkY2Q0ZDYgfCAwO1xyXG4gICAgICAgIHRoaXMuQ2ggPSAweDFkZmFiN2FlIHwgMDtcclxuICAgICAgICB0aGlzLkNsID0gMHgzMmZmOWM4MiB8IDA7XHJcbiAgICAgICAgdGhpcy5EaCA9IDB4Njc5ZGQ1MTQgfCAwO1xyXG4gICAgICAgIHRoaXMuRGwgPSAweDU4MmY5ZmNmIHwgMDtcclxuICAgICAgICB0aGlzLkVoID0gMHgwZjZkMmI2OSB8IDA7XHJcbiAgICAgICAgdGhpcy5FbCA9IDB4N2JkNDRkYTggfCAwO1xyXG4gICAgICAgIHRoaXMuRmggPSAweDc3ZTM2ZjczIHwgMDtcclxuICAgICAgICB0aGlzLkZsID0gMHgwNGM0ODk0MiB8IDA7XHJcbiAgICAgICAgdGhpcy5HaCA9IDB4M2Y5ZDg1YTggfCAwO1xyXG4gICAgICAgIHRoaXMuR2wgPSAweDZhMWQzNmM4IHwgMDtcclxuICAgICAgICB0aGlzLkhoID0gMHgxMTEyZTZhZCB8IDA7XHJcbiAgICAgICAgdGhpcy5IbCA9IDB4OTFkNjkyYTEgfCAwO1xyXG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgU0hBNTEyXzI1NiBleHRlbmRzIFNIQTUxMiB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXHJcbiAgICAgICAgdGhpcy5BaCA9IDB4MjIzMTIxOTQgfCAwO1xyXG4gICAgICAgIHRoaXMuQWwgPSAweGZjMmJmNzJjIHwgMDtcclxuICAgICAgICB0aGlzLkJoID0gMHg5ZjU1NWZhMyB8IDA7XHJcbiAgICAgICAgdGhpcy5CbCA9IDB4Yzg0YzY0YzIgfCAwO1xyXG4gICAgICAgIHRoaXMuQ2ggPSAweDIzOTNiODZiIHwgMDtcclxuICAgICAgICB0aGlzLkNsID0gMHg2ZjUzYjE1MSB8IDA7XHJcbiAgICAgICAgdGhpcy5EaCA9IDB4OTYzODc3MTkgfCAwO1xyXG4gICAgICAgIHRoaXMuRGwgPSAweDU5NDBlYWJkIHwgMDtcclxuICAgICAgICB0aGlzLkVoID0gMHg5NjI4M2VlMiB8IDA7XHJcbiAgICAgICAgdGhpcy5FbCA9IDB4YTg4ZWZmZTMgfCAwO1xyXG4gICAgICAgIHRoaXMuRmggPSAweGJlNWUxZTI1IHwgMDtcclxuICAgICAgICB0aGlzLkZsID0gMHg1Mzg2Mzk5MiB8IDA7XHJcbiAgICAgICAgdGhpcy5HaCA9IDB4MmIwMTk5ZmMgfCAwO1xyXG4gICAgICAgIHRoaXMuR2wgPSAweDJjODViOGFhIHwgMDtcclxuICAgICAgICB0aGlzLkhoID0gMHgwZWI3MmRkYyB8IDA7XHJcbiAgICAgICAgdGhpcy5IbCA9IDB4ODFjNTJjYTIgfCAwO1xyXG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMzI7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgU0hBMzg0IGV4dGVuZHMgU0hBNTEyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcclxuICAgICAgICB0aGlzLkFoID0gMHhjYmJiOWQ1ZCB8IDA7XHJcbiAgICAgICAgdGhpcy5BbCA9IDB4YzEwNTllZDggfCAwO1xyXG4gICAgICAgIHRoaXMuQmggPSAweDYyOWEyOTJhIHwgMDtcclxuICAgICAgICB0aGlzLkJsID0gMHgzNjdjZDUwNyB8IDA7XHJcbiAgICAgICAgdGhpcy5DaCA9IDB4OTE1OTAxNWEgfCAwO1xyXG4gICAgICAgIHRoaXMuQ2wgPSAweDMwNzBkZDE3IHwgMDtcclxuICAgICAgICB0aGlzLkRoID0gMHgxNTJmZWNkOCB8IDA7XHJcbiAgICAgICAgdGhpcy5EbCA9IDB4ZjcwZTU5MzkgfCAwO1xyXG4gICAgICAgIHRoaXMuRWggPSAweDY3MzMyNjY3IHwgMDtcclxuICAgICAgICB0aGlzLkVsID0gMHhmZmMwMGIzMSB8IDA7XHJcbiAgICAgICAgdGhpcy5GaCA9IDB4OGViNDRhODcgfCAwO1xyXG4gICAgICAgIHRoaXMuRmwgPSAweDY4NTgxNTExIHwgMDtcclxuICAgICAgICB0aGlzLkdoID0gMHhkYjBjMmUwZCB8IDA7XHJcbiAgICAgICAgdGhpcy5HbCA9IDB4NjRmOThmYTcgfCAwO1xyXG4gICAgICAgIHRoaXMuSGggPSAweDQ3YjU0ODFkIHwgMDtcclxuICAgICAgICB0aGlzLkhsID0gMHhiZWZhNGZhNCB8IDA7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSA0ODtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY29uc3Qgc2hhNTEyID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyKCkpO1xyXG5leHBvcnQgY29uc3Qgc2hhNTEyXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMl8yMjQoKSk7XHJcbmV4cG9ydCBjb25zdCBzaGE1MTJfMjU2ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyXzI1NigpKTtcclxuZXhwb3J0IGNvbnN0IHNoYTM4NCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTM4NCgpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhNTEyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/hashes/esm/sha512.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/crypto.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\r\n// node.js versions earlier than v19 don't declare it in global scope.\r\n// For node.js, package.json#exports field mapping rewrites import\r\n// from `crypto` to `cryptoNode`, which imports native module.\r\n// Makes the utils un-importable in browsers without a bundler.\r\n// Once node.js 18 is deprecated, we can just drop the import.\r\n\r\nconst u8a = (a) => a instanceof Uint8Array;\r\n// Cast array to different type\r\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\r\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\r\n// Cast array to view\r\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\r\n// The rotate right (circular right shift) operation for uint32\r\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\r\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\r\n// early-throw an error because we don't support BE yet.\r\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\r\nif (!isLE)\r\n    throw new Error('Non little-endian hardware is not supported');\r\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\r\n/**\r\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\r\n */\r\nfunction bytesToHex(bytes) {\r\n    if (!u8a(bytes))\r\n        throw new Error('Uint8Array expected');\r\n    // pre-caching improves the speed 6x\r\n    let hex = '';\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        hex += hexes[bytes[i]];\r\n    }\r\n    return hex;\r\n}\r\n/**\r\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\r\n */\r\nfunction hexToBytes(hex) {\r\n    if (typeof hex !== 'string')\r\n        throw new Error('hex string expected, got ' + typeof hex);\r\n    const len = hex.length;\r\n    if (len % 2)\r\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\r\n    const array = new Uint8Array(len / 2);\r\n    for (let i = 0; i < array.length; i++) {\r\n        const j = i * 2;\r\n        const hexByte = hex.slice(j, j + 2);\r\n        const byte = Number.parseInt(hexByte, 16);\r\n        if (Number.isNaN(byte) || byte < 0)\r\n            throw new Error('Invalid byte sequence');\r\n        array[i] = byte;\r\n    }\r\n    return array;\r\n}\r\n// There is no setImmediate in browser and setTimeout is slow.\r\n// call of async fn will return Promise, which will be fullfiled only on\r\n// next scheduler queue processing step and this is exactly what we need.\r\nconst nextTick = async () => { };\r\n// Returns control to thread each 'tick' ms to avoid blocking\r\nasync function asyncLoop(iters, tick, cb) {\r\n    let ts = Date.now();\r\n    for (let i = 0; i < iters; i++) {\r\n        cb(i);\r\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\r\n        const diff = Date.now() - ts;\r\n        if (diff >= 0 && diff < tick)\r\n            continue;\r\n        await nextTick();\r\n        ts += diff;\r\n    }\r\n}\r\n/**\r\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\r\n */\r\nfunction utf8ToBytes(str) {\r\n    if (typeof str !== 'string')\r\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\r\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\r\n}\r\n/**\r\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\r\n * Warning: when Uint8Array is passed, it would NOT get copied.\r\n * Keep in mind for future mutable operations.\r\n */\r\nfunction toBytes(data) {\r\n    if (typeof data === 'string')\r\n        data = utf8ToBytes(data);\r\n    if (!u8a(data))\r\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\r\n    return data;\r\n}\r\n/**\r\n * Copies several Uint8Arrays into one.\r\n */\r\nfunction concatBytes(...arrays) {\r\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\r\n    let pad = 0; // walk through each item, ensure they have proper type\r\n    arrays.forEach((a) => {\r\n        if (!u8a(a))\r\n            throw new Error('Uint8Array expected');\r\n        r.set(a, pad);\r\n        pad += a.length;\r\n    });\r\n    return r;\r\n}\r\n// For runtime check if class implements interface\r\nclass Hash {\r\n    // Safe version that clones internal state\r\n    clone() {\r\n        return this._cloneInto();\r\n    }\r\n}\r\nconst toStr = {}.toString;\r\nfunction checkOpts(defaults, opts) {\r\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\r\n        throw new Error('Options should be object or undefined');\r\n    const merged = Object.assign(defaults, opts);\r\n    return merged;\r\n}\r\nfunction wrapConstructor(hashCons) {\r\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\r\n    const tmp = hashCons();\r\n    hashC.outputLen = tmp.outputLen;\r\n    hashC.blockLen = tmp.blockLen;\r\n    hashC.create = () => hashCons();\r\n    return hashC;\r\n}\r\nfunction wrapConstructorWithOpts(hashCons) {\r\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\r\n    const tmp = hashCons({});\r\n    hashC.outputLen = tmp.outputLen;\r\n    hashC.blockLen = tmp.blockLen;\r\n    hashC.create = (opts) => hashCons(opts);\r\n    return hashC;\r\n}\r\nfunction wrapXOFConstructorWithOpts(hashCons) {\r\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\r\n    const tmp = hashCons({});\r\n    hashC.outputLen = tmp.outputLen;\r\n    hashC.blockLen = tmp.blockLen;\r\n    hashC.create = (opts) => hashCons(opts);\r\n    return hashC;\r\n}\r\n/**\r\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\r\n */\r\nfunction randomBytes(bytesLength = 32) {\r\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\r\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\r\n    }\r\n    throw new Error('crypto.getRandomValues must be defined');\r\n}\r\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEM7QUFDOUM7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw0REFBNEQsV0FBVztBQUN2RSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNUO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsd0RBQU0sV0FBVyx3REFBTTtBQUMvQixlQUFlLHdEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGhhc2hlc1xcZXNtXFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXHJcbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxyXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXHJcbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxyXG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxyXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cclxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQsIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cclxuaW1wb3J0IHsgY3J5cHRvIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9jcnlwdG8nO1xyXG5jb25zdCB1OGEgPSAoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XHJcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcclxuZXhwb3J0IGNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcclxuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcclxuLy8gQ2FzdCBhcnJheSB0byB2aWV3XHJcbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XHJcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxyXG5leHBvcnQgY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XHJcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxyXG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxyXG5leHBvcnQgY29uc3QgaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XHJcbmlmICghaXNMRSlcclxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xyXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xyXG4vKipcclxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcclxuICAgIGlmICghdThhKGJ5dGVzKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcclxuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxyXG4gICAgbGV0IGhleCA9ICcnO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGV4O1xyXG59XHJcbi8qKlxyXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcclxuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XHJcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xyXG4gICAgaWYgKGxlbiAlIDIpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XHJcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcclxuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcclxuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcclxuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xyXG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcnJheTtcclxufVxyXG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxyXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cclxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxyXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XHJcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcclxuICAgIGxldCB0cyA9IERhdGUubm93KCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcclxuICAgICAgICBjYihpKTtcclxuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xyXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XHJcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcclxuICAgICAgICB0cyArPSBkaWZmO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xyXG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xyXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxyXG59XHJcbi8qKlxyXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxyXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cclxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xyXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcclxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XHJcbiAgICBpZiAoIXU4YShkYXRhKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn1cclxuLyoqXHJcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xyXG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcclxuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXHJcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xyXG4gICAgICAgIGlmICghdThhKGEpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcclxuICAgICAgICByLnNldChhLCBwYWQpO1xyXG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcclxuZXhwb3J0IGNsYXNzIEhhc2gge1xyXG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcclxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xyXG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiB0b1N0ci5jYWxsKG9wdHMpICE9PSAnW29iamVjdCBPYmplY3RdJylcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcclxuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xyXG4gICAgcmV0dXJuIG1lcmdlZDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zKSB7XHJcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XHJcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xyXG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcclxuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xyXG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcclxuICAgIHJldHVybiBoYXNoQztcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcclxuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XHJcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XHJcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xyXG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XHJcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XHJcbiAgICByZXR1cm4gaGFzaEM7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XHJcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xyXG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xyXG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcclxuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xyXG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xyXG4gICAgcmV0dXJuIGhhc2hDO1xyXG59XHJcbi8qKlxyXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XHJcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/aes-js/lib.esm/aes.js":
/*!********************************************!*\
  !*** ./node_modules/aes-js/lib.esm/aes.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AES: () => (/* binding */ AES)\n/* harmony export */ });\n/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */\r\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n};\r\nvar _AES_key, _AES_Kd, _AES_Ke;\r\n// Number of rounds by keysize\r\nconst numberOfRounds = { 16: 10, 24: 12, 32: 14 };\r\n// Round constant words\r\nconst rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];\r\n// S-box and Inverse S-box (S is for Substitution)\r\nconst S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];\r\nconst Si = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];\r\n// Transformations for encryption\r\nconst T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];\r\nconst T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];\r\nconst T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];\r\nconst T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];\r\n// Transformations for decryption\r\nconst T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];\r\nconst T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];\r\nconst T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];\r\nconst T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];\r\n// Transformations for decryption key expansion\r\nconst U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];\r\nconst U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];\r\nconst U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];\r\nconst U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];\r\nfunction convertToInt32(bytes) {\r\n    const result = [];\r\n    for (let i = 0; i < bytes.length; i += 4) {\r\n        result.push((bytes[i] << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | bytes[i + 3]);\r\n    }\r\n    return result;\r\n}\r\nclass AES {\r\n    get key() { return __classPrivateFieldGet(this, _AES_key, \"f\").slice(); }\r\n    constructor(key) {\r\n        _AES_key.set(this, void 0);\r\n        _AES_Kd.set(this, void 0);\r\n        _AES_Ke.set(this, void 0);\r\n        if (!(this instanceof AES)) {\r\n            throw Error('AES must be instanitated with `new`');\r\n        }\r\n        __classPrivateFieldSet(this, _AES_key, new Uint8Array(key), \"f\");\r\n        const rounds = numberOfRounds[this.key.length];\r\n        if (rounds == null) {\r\n            throw new TypeError('invalid key size (must be 16, 24 or 32 bytes)');\r\n        }\r\n        // encryption round keys\r\n        __classPrivateFieldSet(this, _AES_Ke, [], \"f\");\r\n        // decryption round keys\r\n        __classPrivateFieldSet(this, _AES_Kd, [], \"f\");\r\n        for (let i = 0; i <= rounds; i++) {\r\n            __classPrivateFieldGet(this, _AES_Ke, \"f\").push([0, 0, 0, 0]);\r\n            __classPrivateFieldGet(this, _AES_Kd, \"f\").push([0, 0, 0, 0]);\r\n        }\r\n        const roundKeyCount = (rounds + 1) * 4;\r\n        const KC = this.key.length / 4;\r\n        // convert the key into ints\r\n        const tk = convertToInt32(this.key);\r\n        // copy values into round key arrays\r\n        let index;\r\n        for (let i = 0; i < KC; i++) {\r\n            index = i >> 2;\r\n            __classPrivateFieldGet(this, _AES_Ke, \"f\")[index][i % 4] = tk[i];\r\n            __classPrivateFieldGet(this, _AES_Kd, \"f\")[rounds - index][i % 4] = tk[i];\r\n        }\r\n        // key expansion (fips-197 section 5.2)\r\n        let rconpointer = 0;\r\n        let t = KC, tt;\r\n        while (t < roundKeyCount) {\r\n            tt = tk[KC - 1];\r\n            tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^\r\n                (S[(tt >> 8) & 0xFF] << 16) ^\r\n                (S[tt & 0xFF] << 8) ^\r\n                S[(tt >> 24) & 0xFF] ^\r\n                (rcon[rconpointer] << 24));\r\n            rconpointer += 1;\r\n            // key expansion (for non-256 bit)\r\n            if (KC != 8) {\r\n                for (let i = 1; i < KC; i++) {\r\n                    tk[i] ^= tk[i - 1];\r\n                }\r\n                // key expansion for 256-bit keys is \"slightly different\" (fips-197)\r\n            }\r\n            else {\r\n                for (let i = 1; i < (KC / 2); i++) {\r\n                    tk[i] ^= tk[i - 1];\r\n                }\r\n                tt = tk[(KC / 2) - 1];\r\n                tk[KC / 2] ^= (S[tt & 0xFF] ^\r\n                    (S[(tt >> 8) & 0xFF] << 8) ^\r\n                    (S[(tt >> 16) & 0xFF] << 16) ^\r\n                    (S[(tt >> 24) & 0xFF] << 24));\r\n                for (let i = (KC / 2) + 1; i < KC; i++) {\r\n                    tk[i] ^= tk[i - 1];\r\n                }\r\n            }\r\n            // copy values into round key arrays\r\n            let i = 0, r, c;\r\n            while (i < KC && t < roundKeyCount) {\r\n                r = t >> 2;\r\n                c = t % 4;\r\n                __classPrivateFieldGet(this, _AES_Ke, \"f\")[r][c] = tk[i];\r\n                __classPrivateFieldGet(this, _AES_Kd, \"f\")[rounds - r][c] = tk[i++];\r\n                t++;\r\n            }\r\n        }\r\n        // inverse-cipher-ify the decryption round key (fips-197 section 5.3)\r\n        for (let r = 1; r < rounds; r++) {\r\n            for (let c = 0; c < 4; c++) {\r\n                tt = __classPrivateFieldGet(this, _AES_Kd, \"f\")[r][c];\r\n                __classPrivateFieldGet(this, _AES_Kd, \"f\")[r][c] = (U1[(tt >> 24) & 0xFF] ^\r\n                    U2[(tt >> 16) & 0xFF] ^\r\n                    U3[(tt >> 8) & 0xFF] ^\r\n                    U4[tt & 0xFF]);\r\n            }\r\n        }\r\n    }\r\n    encrypt(plaintext) {\r\n        if (plaintext.length != 16) {\r\n            throw new TypeError('invalid plaintext size (must be 16 bytes)');\r\n        }\r\n        const rounds = __classPrivateFieldGet(this, _AES_Ke, \"f\").length - 1;\r\n        const a = [0, 0, 0, 0];\r\n        // convert plaintext to (ints ^ key)\r\n        let t = convertToInt32(plaintext);\r\n        for (let i = 0; i < 4; i++) {\r\n            t[i] ^= __classPrivateFieldGet(this, _AES_Ke, \"f\")[0][i];\r\n        }\r\n        // apply round transforms\r\n        for (let r = 1; r < rounds; r++) {\r\n            for (let i = 0; i < 4; i++) {\r\n                a[i] = (T1[(t[i] >> 24) & 0xff] ^\r\n                    T2[(t[(i + 1) % 4] >> 16) & 0xff] ^\r\n                    T3[(t[(i + 2) % 4] >> 8) & 0xff] ^\r\n                    T4[t[(i + 3) % 4] & 0xff] ^\r\n                    __classPrivateFieldGet(this, _AES_Ke, \"f\")[r][i]);\r\n            }\r\n            t = a.slice();\r\n        }\r\n        // the last round is special\r\n        const result = new Uint8Array(16);\r\n        let tt = 0;\r\n        for (let i = 0; i < 4; i++) {\r\n            tt = __classPrivateFieldGet(this, _AES_Ke, \"f\")[rounds][i];\r\n            result[4 * i] = (S[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;\r\n            result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;\r\n            result[4 * i + 2] = (S[(t[(i + 2) % 4] >> 8) & 0xff] ^ (tt >> 8)) & 0xff;\r\n            result[4 * i + 3] = (S[t[(i + 3) % 4] & 0xff] ^ tt) & 0xff;\r\n        }\r\n        return result;\r\n    }\r\n    decrypt(ciphertext) {\r\n        if (ciphertext.length != 16) {\r\n            throw new TypeError('invalid ciphertext size (must be 16 bytes)');\r\n        }\r\n        const rounds = __classPrivateFieldGet(this, _AES_Kd, \"f\").length - 1;\r\n        const a = [0, 0, 0, 0];\r\n        // convert plaintext to (ints ^ key)\r\n        let t = convertToInt32(ciphertext);\r\n        for (let i = 0; i < 4; i++) {\r\n            t[i] ^= __classPrivateFieldGet(this, _AES_Kd, \"f\")[0][i];\r\n        }\r\n        // apply round transforms\r\n        for (let r = 1; r < rounds; r++) {\r\n            for (let i = 0; i < 4; i++) {\r\n                a[i] = (T5[(t[i] >> 24) & 0xff] ^\r\n                    T6[(t[(i + 3) % 4] >> 16) & 0xff] ^\r\n                    T7[(t[(i + 2) % 4] >> 8) & 0xff] ^\r\n                    T8[t[(i + 1) % 4] & 0xff] ^\r\n                    __classPrivateFieldGet(this, _AES_Kd, \"f\")[r][i]);\r\n            }\r\n            t = a.slice();\r\n        }\r\n        // the last round is special\r\n        const result = new Uint8Array(16);\r\n        let tt = 0;\r\n        for (let i = 0; i < 4; i++) {\r\n            tt = __classPrivateFieldGet(this, _AES_Kd, \"f\")[rounds][i];\r\n            result[4 * i] = (Si[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;\r\n            result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;\r\n            result[4 * i + 2] = (Si[(t[(i + 2) % 4] >> 8) & 0xff] ^ (tt >> 8)) & 0xff;\r\n            result[4 * i + 3] = (Si[t[(i + 1) % 4] & 0xff] ^ tt) & 0xff;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n_AES_key = new WeakMap(), _AES_Kd = new WeakMap(), _AES_Ke = new WeakMap();\r\n//# sourceMappingURL=aes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9hZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0EsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQyw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxhZXMtanNcXGxpYi5lc21cXGFlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgTUlUIExpY2Vuc2UuIENvcHlyaWdodCAyMDE1LTIwMjIgUmljaGFyZCBNb29yZSA8bWVAcmljbW9vLmNvbT4uIFNlZSBMSUNFTlNFLnR4dC4gKi9cclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufTtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn07XHJcbnZhciBfQUVTX2tleSwgX0FFU19LZCwgX0FFU19LZTtcclxuLy8gTnVtYmVyIG9mIHJvdW5kcyBieSBrZXlzaXplXHJcbmNvbnN0IG51bWJlck9mUm91bmRzID0geyAxNjogMTAsIDI0OiAxMiwgMzI6IDE0IH07XHJcbi8vIFJvdW5kIGNvbnN0YW50IHdvcmRzXHJcbmNvbnN0IHJjb24gPSBbMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNiwgMHg2YywgMHhkOCwgMHhhYiwgMHg0ZCwgMHg5YSwgMHgyZiwgMHg1ZSwgMHhiYywgMHg2MywgMHhjNiwgMHg5NywgMHgzNSwgMHg2YSwgMHhkNCwgMHhiMywgMHg3ZCwgMHhmYSwgMHhlZiwgMHhjNSwgMHg5MV07XHJcbi8vIFMtYm94IGFuZCBJbnZlcnNlIFMtYm94IChTIGlzIGZvciBTdWJzdGl0dXRpb24pXHJcbmNvbnN0IFMgPSBbMHg2MywgMHg3YywgMHg3NywgMHg3YiwgMHhmMiwgMHg2YiwgMHg2ZiwgMHhjNSwgMHgzMCwgMHgwMSwgMHg2NywgMHgyYiwgMHhmZSwgMHhkNywgMHhhYiwgMHg3NiwgMHhjYSwgMHg4MiwgMHhjOSwgMHg3ZCwgMHhmYSwgMHg1OSwgMHg0NywgMHhmMCwgMHhhZCwgMHhkNCwgMHhhMiwgMHhhZiwgMHg5YywgMHhhNCwgMHg3MiwgMHhjMCwgMHhiNywgMHhmZCwgMHg5MywgMHgyNiwgMHgzNiwgMHgzZiwgMHhmNywgMHhjYywgMHgzNCwgMHhhNSwgMHhlNSwgMHhmMSwgMHg3MSwgMHhkOCwgMHgzMSwgMHgxNSwgMHgwNCwgMHhjNywgMHgyMywgMHhjMywgMHgxOCwgMHg5NiwgMHgwNSwgMHg5YSwgMHgwNywgMHgxMiwgMHg4MCwgMHhlMiwgMHhlYiwgMHgyNywgMHhiMiwgMHg3NSwgMHgwOSwgMHg4MywgMHgyYywgMHgxYSwgMHgxYiwgMHg2ZSwgMHg1YSwgMHhhMCwgMHg1MiwgMHgzYiwgMHhkNiwgMHhiMywgMHgyOSwgMHhlMywgMHgyZiwgMHg4NCwgMHg1MywgMHhkMSwgMHgwMCwgMHhlZCwgMHgyMCwgMHhmYywgMHhiMSwgMHg1YiwgMHg2YSwgMHhjYiwgMHhiZSwgMHgzOSwgMHg0YSwgMHg0YywgMHg1OCwgMHhjZiwgMHhkMCwgMHhlZiwgMHhhYSwgMHhmYiwgMHg0MywgMHg0ZCwgMHgzMywgMHg4NSwgMHg0NSwgMHhmOSwgMHgwMiwgMHg3ZiwgMHg1MCwgMHgzYywgMHg5ZiwgMHhhOCwgMHg1MSwgMHhhMywgMHg0MCwgMHg4ZiwgMHg5MiwgMHg5ZCwgMHgzOCwgMHhmNSwgMHhiYywgMHhiNiwgMHhkYSwgMHgyMSwgMHgxMCwgMHhmZiwgMHhmMywgMHhkMiwgMHhjZCwgMHgwYywgMHgxMywgMHhlYywgMHg1ZiwgMHg5NywgMHg0NCwgMHgxNywgMHhjNCwgMHhhNywgMHg3ZSwgMHgzZCwgMHg2NCwgMHg1ZCwgMHgxOSwgMHg3MywgMHg2MCwgMHg4MSwgMHg0ZiwgMHhkYywgMHgyMiwgMHgyYSwgMHg5MCwgMHg4OCwgMHg0NiwgMHhlZSwgMHhiOCwgMHgxNCwgMHhkZSwgMHg1ZSwgMHgwYiwgMHhkYiwgMHhlMCwgMHgzMiwgMHgzYSwgMHgwYSwgMHg0OSwgMHgwNiwgMHgyNCwgMHg1YywgMHhjMiwgMHhkMywgMHhhYywgMHg2MiwgMHg5MSwgMHg5NSwgMHhlNCwgMHg3OSwgMHhlNywgMHhjOCwgMHgzNywgMHg2ZCwgMHg4ZCwgMHhkNSwgMHg0ZSwgMHhhOSwgMHg2YywgMHg1NiwgMHhmNCwgMHhlYSwgMHg2NSwgMHg3YSwgMHhhZSwgMHgwOCwgMHhiYSwgMHg3OCwgMHgyNSwgMHgyZSwgMHgxYywgMHhhNiwgMHhiNCwgMHhjNiwgMHhlOCwgMHhkZCwgMHg3NCwgMHgxZiwgMHg0YiwgMHhiZCwgMHg4YiwgMHg4YSwgMHg3MCwgMHgzZSwgMHhiNSwgMHg2NiwgMHg0OCwgMHgwMywgMHhmNiwgMHgwZSwgMHg2MSwgMHgzNSwgMHg1NywgMHhiOSwgMHg4NiwgMHhjMSwgMHgxZCwgMHg5ZSwgMHhlMSwgMHhmOCwgMHg5OCwgMHgxMSwgMHg2OSwgMHhkOSwgMHg4ZSwgMHg5NCwgMHg5YiwgMHgxZSwgMHg4NywgMHhlOSwgMHhjZSwgMHg1NSwgMHgyOCwgMHhkZiwgMHg4YywgMHhhMSwgMHg4OSwgMHgwZCwgMHhiZiwgMHhlNiwgMHg0MiwgMHg2OCwgMHg0MSwgMHg5OSwgMHgyZCwgMHgwZiwgMHhiMCwgMHg1NCwgMHhiYiwgMHgxNl07XHJcbmNvbnN0IFNpID0gWzB4NTIsIDB4MDksIDB4NmEsIDB4ZDUsIDB4MzAsIDB4MzYsIDB4YTUsIDB4MzgsIDB4YmYsIDB4NDAsIDB4YTMsIDB4OWUsIDB4ODEsIDB4ZjMsIDB4ZDcsIDB4ZmIsIDB4N2MsIDB4ZTMsIDB4MzksIDB4ODIsIDB4OWIsIDB4MmYsIDB4ZmYsIDB4ODcsIDB4MzQsIDB4OGUsIDB4NDMsIDB4NDQsIDB4YzQsIDB4ZGUsIDB4ZTksIDB4Y2IsIDB4NTQsIDB4N2IsIDB4OTQsIDB4MzIsIDB4YTYsIDB4YzIsIDB4MjMsIDB4M2QsIDB4ZWUsIDB4NGMsIDB4OTUsIDB4MGIsIDB4NDIsIDB4ZmEsIDB4YzMsIDB4NGUsIDB4MDgsIDB4MmUsIDB4YTEsIDB4NjYsIDB4MjgsIDB4ZDksIDB4MjQsIDB4YjIsIDB4NzYsIDB4NWIsIDB4YTIsIDB4NDksIDB4NmQsIDB4OGIsIDB4ZDEsIDB4MjUsIDB4NzIsIDB4ZjgsIDB4ZjYsIDB4NjQsIDB4ODYsIDB4NjgsIDB4OTgsIDB4MTYsIDB4ZDQsIDB4YTQsIDB4NWMsIDB4Y2MsIDB4NWQsIDB4NjUsIDB4YjYsIDB4OTIsIDB4NmMsIDB4NzAsIDB4NDgsIDB4NTAsIDB4ZmQsIDB4ZWQsIDB4YjksIDB4ZGEsIDB4NWUsIDB4MTUsIDB4NDYsIDB4NTcsIDB4YTcsIDB4OGQsIDB4OWQsIDB4ODQsIDB4OTAsIDB4ZDgsIDB4YWIsIDB4MDAsIDB4OGMsIDB4YmMsIDB4ZDMsIDB4MGEsIDB4ZjcsIDB4ZTQsIDB4NTgsIDB4MDUsIDB4YjgsIDB4YjMsIDB4NDUsIDB4MDYsIDB4ZDAsIDB4MmMsIDB4MWUsIDB4OGYsIDB4Y2EsIDB4M2YsIDB4MGYsIDB4MDIsIDB4YzEsIDB4YWYsIDB4YmQsIDB4MDMsIDB4MDEsIDB4MTMsIDB4OGEsIDB4NmIsIDB4M2EsIDB4OTEsIDB4MTEsIDB4NDEsIDB4NGYsIDB4NjcsIDB4ZGMsIDB4ZWEsIDB4OTcsIDB4ZjIsIDB4Y2YsIDB4Y2UsIDB4ZjAsIDB4YjQsIDB4ZTYsIDB4NzMsIDB4OTYsIDB4YWMsIDB4NzQsIDB4MjIsIDB4ZTcsIDB4YWQsIDB4MzUsIDB4ODUsIDB4ZTIsIDB4ZjksIDB4MzcsIDB4ZTgsIDB4MWMsIDB4NzUsIDB4ZGYsIDB4NmUsIDB4NDcsIDB4ZjEsIDB4MWEsIDB4NzEsIDB4MWQsIDB4MjksIDB4YzUsIDB4ODksIDB4NmYsIDB4YjcsIDB4NjIsIDB4MGUsIDB4YWEsIDB4MTgsIDB4YmUsIDB4MWIsIDB4ZmMsIDB4NTYsIDB4M2UsIDB4NGIsIDB4YzYsIDB4ZDIsIDB4NzksIDB4MjAsIDB4OWEsIDB4ZGIsIDB4YzAsIDB4ZmUsIDB4NzgsIDB4Y2QsIDB4NWEsIDB4ZjQsIDB4MWYsIDB4ZGQsIDB4YTgsIDB4MzMsIDB4ODgsIDB4MDcsIDB4YzcsIDB4MzEsIDB4YjEsIDB4MTIsIDB4MTAsIDB4NTksIDB4MjcsIDB4ODAsIDB4ZWMsIDB4NWYsIDB4NjAsIDB4NTEsIDB4N2YsIDB4YTksIDB4MTksIDB4YjUsIDB4NGEsIDB4MGQsIDB4MmQsIDB4ZTUsIDB4N2EsIDB4OWYsIDB4OTMsIDB4YzksIDB4OWMsIDB4ZWYsIDB4YTAsIDB4ZTAsIDB4M2IsIDB4NGQsIDB4YWUsIDB4MmEsIDB4ZjUsIDB4YjAsIDB4YzgsIDB4ZWIsIDB4YmIsIDB4M2MsIDB4ODMsIDB4NTMsIDB4OTksIDB4NjEsIDB4MTcsIDB4MmIsIDB4MDQsIDB4N2UsIDB4YmEsIDB4NzcsIDB4ZDYsIDB4MjYsIDB4ZTEsIDB4NjksIDB4MTQsIDB4NjMsIDB4NTUsIDB4MjEsIDB4MGMsIDB4N2RdO1xyXG4vLyBUcmFuc2Zvcm1hdGlvbnMgZm9yIGVuY3J5cHRpb25cclxuY29uc3QgVDEgPSBbMHhjNjYzNjNhNSwgMHhmODdjN2M4NCwgMHhlZTc3Nzc5OSwgMHhmNjdiN2I4ZCwgMHhmZmYyZjIwZCwgMHhkNjZiNmJiZCwgMHhkZTZmNmZiMSwgMHg5MWM1YzU1NCwgMHg2MDMwMzA1MCwgMHgwMjAxMDEwMywgMHhjZTY3NjdhOSwgMHg1NjJiMmI3ZCwgMHhlN2ZlZmUxOSwgMHhiNWQ3ZDc2MiwgMHg0ZGFiYWJlNiwgMHhlYzc2NzY5YSwgMHg4ZmNhY2E0NSwgMHgxZjgyODI5ZCwgMHg4OWM5Yzk0MCwgMHhmYTdkN2Q4NywgMHhlZmZhZmExNSwgMHhiMjU5NTllYiwgMHg4ZTQ3NDdjOSwgMHhmYmYwZjAwYiwgMHg0MWFkYWRlYywgMHhiM2Q0ZDQ2NywgMHg1ZmEyYTJmZCwgMHg0NWFmYWZlYSwgMHgyMzljOWNiZiwgMHg1M2E0YTRmNywgMHhlNDcyNzI5NiwgMHg5YmMwYzA1YiwgMHg3NWI3YjdjMiwgMHhlMWZkZmQxYywgMHgzZDkzOTNhZSwgMHg0YzI2MjY2YSwgMHg2YzM2MzY1YSwgMHg3ZTNmM2Y0MSwgMHhmNWY3ZjcwMiwgMHg4M2NjY2M0ZiwgMHg2ODM0MzQ1YywgMHg1MWE1YTVmNCwgMHhkMWU1ZTUzNCwgMHhmOWYxZjEwOCwgMHhlMjcxNzE5MywgMHhhYmQ4ZDg3MywgMHg2MjMxMzE1MywgMHgyYTE1MTUzZiwgMHgwODA0MDQwYywgMHg5NWM3Yzc1MiwgMHg0NjIzMjM2NSwgMHg5ZGMzYzM1ZSwgMHgzMDE4MTgyOCwgMHgzNzk2OTZhMSwgMHgwYTA1MDUwZiwgMHgyZjlhOWFiNSwgMHgwZTA3MDcwOSwgMHgyNDEyMTIzNiwgMHgxYjgwODA5YiwgMHhkZmUyZTIzZCwgMHhjZGViZWIyNiwgMHg0ZTI3Mjc2OSwgMHg3ZmIyYjJjZCwgMHhlYTc1NzU5ZiwgMHgxMjA5MDkxYiwgMHgxZDgzODM5ZSwgMHg1ODJjMmM3NCwgMHgzNDFhMWEyZSwgMHgzNjFiMWIyZCwgMHhkYzZlNmViMiwgMHhiNDVhNWFlZSwgMHg1YmEwYTBmYiwgMHhhNDUyNTJmNiwgMHg3NjNiM2I0ZCwgMHhiN2Q2ZDY2MSwgMHg3ZGIzYjNjZSwgMHg1MjI5Mjk3YiwgMHhkZGUzZTMzZSwgMHg1ZTJmMmY3MSwgMHgxMzg0ODQ5NywgMHhhNjUzNTNmNSwgMHhiOWQxZDE2OCwgMHgwMDAwMDAwMCwgMHhjMWVkZWQyYywgMHg0MDIwMjA2MCwgMHhlM2ZjZmMxZiwgMHg3OWIxYjFjOCwgMHhiNjViNWJlZCwgMHhkNDZhNmFiZSwgMHg4ZGNiY2I0NiwgMHg2N2JlYmVkOSwgMHg3MjM5Mzk0YiwgMHg5NDRhNGFkZSwgMHg5ODRjNGNkNCwgMHhiMDU4NThlOCwgMHg4NWNmY2Y0YSwgMHhiYmQwZDA2YiwgMHhjNWVmZWYyYSwgMHg0ZmFhYWFlNSwgMHhlZGZiZmIxNiwgMHg4NjQzNDNjNSwgMHg5YTRkNGRkNywgMHg2NjMzMzM1NSwgMHgxMTg1ODU5NCwgMHg4YTQ1NDVjZiwgMHhlOWY5ZjkxMCwgMHgwNDAyMDIwNiwgMHhmZTdmN2Y4MSwgMHhhMDUwNTBmMCwgMHg3ODNjM2M0NCwgMHgyNTlmOWZiYSwgMHg0YmE4YThlMywgMHhhMjUxNTFmMywgMHg1ZGEzYTNmZSwgMHg4MDQwNDBjMCwgMHgwNThmOGY4YSwgMHgzZjkyOTJhZCwgMHgyMTlkOWRiYywgMHg3MDM4Mzg0OCwgMHhmMWY1ZjUwNCwgMHg2M2JjYmNkZiwgMHg3N2I2YjZjMSwgMHhhZmRhZGE3NSwgMHg0MjIxMjE2MywgMHgyMDEwMTAzMCwgMHhlNWZmZmYxYSwgMHhmZGYzZjMwZSwgMHhiZmQyZDI2ZCwgMHg4MWNkY2Q0YywgMHgxODBjMGMxNCwgMHgyNjEzMTMzNSwgMHhjM2VjZWMyZiwgMHhiZTVmNWZlMSwgMHgzNTk3OTdhMiwgMHg4ODQ0NDRjYywgMHgyZTE3MTczOSwgMHg5M2M0YzQ1NywgMHg1NWE3YTdmMiwgMHhmYzdlN2U4MiwgMHg3YTNkM2Q0NywgMHhjODY0NjRhYywgMHhiYTVkNWRlNywgMHgzMjE5MTkyYiwgMHhlNjczNzM5NSwgMHhjMDYwNjBhMCwgMHgxOTgxODE5OCwgMHg5ZTRmNGZkMSwgMHhhM2RjZGM3ZiwgMHg0NDIyMjI2NiwgMHg1NDJhMmE3ZSwgMHgzYjkwOTBhYiwgMHgwYjg4ODg4MywgMHg4YzQ2NDZjYSwgMHhjN2VlZWUyOSwgMHg2YmI4YjhkMywgMHgyODE0MTQzYywgMHhhN2RlZGU3OSwgMHhiYzVlNWVlMiwgMHgxNjBiMGIxZCwgMHhhZGRiZGI3NiwgMHhkYmUwZTAzYiwgMHg2NDMyMzI1NiwgMHg3NDNhM2E0ZSwgMHgxNDBhMGExZSwgMHg5MjQ5NDlkYiwgMHgwYzA2MDYwYSwgMHg0ODI0MjQ2YywgMHhiODVjNWNlNCwgMHg5ZmMyYzI1ZCwgMHhiZGQzZDM2ZSwgMHg0M2FjYWNlZiwgMHhjNDYyNjJhNiwgMHgzOTkxOTFhOCwgMHgzMTk1OTVhNCwgMHhkM2U0ZTQzNywgMHhmMjc5Nzk4YiwgMHhkNWU3ZTczMiwgMHg4YmM4Yzg0MywgMHg2ZTM3Mzc1OSwgMHhkYTZkNmRiNywgMHgwMThkOGQ4YywgMHhiMWQ1ZDU2NCwgMHg5YzRlNGVkMiwgMHg0OWE5YTllMCwgMHhkODZjNmNiNCwgMHhhYzU2NTZmYSwgMHhmM2Y0ZjQwNywgMHhjZmVhZWEyNSwgMHhjYTY1NjVhZiwgMHhmNDdhN2E4ZSwgMHg0N2FlYWVlOSwgMHgxMDA4MDgxOCwgMHg2ZmJhYmFkNSwgMHhmMDc4Nzg4OCwgMHg0YTI1MjU2ZiwgMHg1YzJlMmU3MiwgMHgzODFjMWMyNCwgMHg1N2E2YTZmMSwgMHg3M2I0YjRjNywgMHg5N2M2YzY1MSwgMHhjYmU4ZTgyMywgMHhhMWRkZGQ3YywgMHhlODc0NzQ5YywgMHgzZTFmMWYyMSwgMHg5NjRiNGJkZCwgMHg2MWJkYmRkYywgMHgwZDhiOGI4NiwgMHgwZjhhOGE4NSwgMHhlMDcwNzA5MCwgMHg3YzNlM2U0MiwgMHg3MWI1YjVjNCwgMHhjYzY2NjZhYSwgMHg5MDQ4NDhkOCwgMHgwNjAzMDMwNSwgMHhmN2Y2ZjYwMSwgMHgxYzBlMGUxMiwgMHhjMjYxNjFhMywgMHg2YTM1MzU1ZiwgMHhhZTU3NTdmOSwgMHg2OWI5YjlkMCwgMHgxNzg2ODY5MSwgMHg5OWMxYzE1OCwgMHgzYTFkMWQyNywgMHgyNzllOWViOSwgMHhkOWUxZTEzOCwgMHhlYmY4ZjgxMywgMHgyYjk4OThiMywgMHgyMjExMTEzMywgMHhkMjY5NjliYiwgMHhhOWQ5ZDk3MCwgMHgwNzhlOGU4OSwgMHgzMzk0OTRhNywgMHgyZDliOWJiNiwgMHgzYzFlMWUyMiwgMHgxNTg3ODc5MiwgMHhjOWU5ZTkyMCwgMHg4N2NlY2U0OSwgMHhhYTU1NTVmZiwgMHg1MDI4Mjg3OCwgMHhhNWRmZGY3YSwgMHgwMzhjOGM4ZiwgMHg1OWExYTFmOCwgMHgwOTg5ODk4MCwgMHgxYTBkMGQxNywgMHg2NWJmYmZkYSwgMHhkN2U2ZTYzMSwgMHg4NDQyNDJjNiwgMHhkMDY4NjhiOCwgMHg4MjQxNDFjMywgMHgyOTk5OTliMCwgMHg1YTJkMmQ3NywgMHgxZTBmMGYxMSwgMHg3YmIwYjBjYiwgMHhhODU0NTRmYywgMHg2ZGJiYmJkNiwgMHgyYzE2MTYzYV07XHJcbmNvbnN0IFQyID0gWzB4YTVjNjYzNjMsIDB4ODRmODdjN2MsIDB4OTllZTc3NzcsIDB4OGRmNjdiN2IsIDB4MGRmZmYyZjIsIDB4YmRkNjZiNmIsIDB4YjFkZTZmNmYsIDB4NTQ5MWM1YzUsIDB4NTA2MDMwMzAsIDB4MDMwMjAxMDEsIDB4YTljZTY3NjcsIDB4N2Q1NjJiMmIsIDB4MTllN2ZlZmUsIDB4NjJiNWQ3ZDcsIDB4ZTY0ZGFiYWIsIDB4OWFlYzc2NzYsIDB4NDU4ZmNhY2EsIDB4OWQxZjgyODIsIDB4NDA4OWM5YzksIDB4ODdmYTdkN2QsIDB4MTVlZmZhZmEsIDB4ZWJiMjU5NTksIDB4Yzk4ZTQ3NDcsIDB4MGJmYmYwZjAsIDB4ZWM0MWFkYWQsIDB4NjdiM2Q0ZDQsIDB4ZmQ1ZmEyYTIsIDB4ZWE0NWFmYWYsIDB4YmYyMzljOWMsIDB4Zjc1M2E0YTQsIDB4OTZlNDcyNzIsIDB4NWI5YmMwYzAsIDB4YzI3NWI3YjcsIDB4MWNlMWZkZmQsIDB4YWUzZDkzOTMsIDB4NmE0YzI2MjYsIDB4NWE2YzM2MzYsIDB4NDE3ZTNmM2YsIDB4MDJmNWY3ZjcsIDB4NGY4M2NjY2MsIDB4NWM2ODM0MzQsIDB4ZjQ1MWE1YTUsIDB4MzRkMWU1ZTUsIDB4MDhmOWYxZjEsIDB4OTNlMjcxNzEsIDB4NzNhYmQ4ZDgsIDB4NTM2MjMxMzEsIDB4M2YyYTE1MTUsIDB4MGMwODA0MDQsIDB4NTI5NWM3YzcsIDB4NjU0NjIzMjMsIDB4NWU5ZGMzYzMsIDB4MjgzMDE4MTgsIDB4YTEzNzk2OTYsIDB4MGYwYTA1MDUsIDB4YjUyZjlhOWEsIDB4MDkwZTA3MDcsIDB4MzYyNDEyMTIsIDB4OWIxYjgwODAsIDB4M2RkZmUyZTIsIDB4MjZjZGViZWIsIDB4Njk0ZTI3MjcsIDB4Y2Q3ZmIyYjIsIDB4OWZlYTc1NzUsIDB4MWIxMjA5MDksIDB4OWUxZDgzODMsIDB4NzQ1ODJjMmMsIDB4MmUzNDFhMWEsIDB4MmQzNjFiMWIsIDB4YjJkYzZlNmUsIDB4ZWViNDVhNWEsIDB4ZmI1YmEwYTAsIDB4ZjZhNDUyNTIsIDB4NGQ3NjNiM2IsIDB4NjFiN2Q2ZDYsIDB4Y2U3ZGIzYjMsIDB4N2I1MjI5MjksIDB4M2VkZGUzZTMsIDB4NzE1ZTJmMmYsIDB4OTcxMzg0ODQsIDB4ZjVhNjUzNTMsIDB4NjhiOWQxZDEsIDB4MDAwMDAwMDAsIDB4MmNjMWVkZWQsIDB4NjA0MDIwMjAsIDB4MWZlM2ZjZmMsIDB4Yzg3OWIxYjEsIDB4ZWRiNjViNWIsIDB4YmVkNDZhNmEsIDB4NDY4ZGNiY2IsIDB4ZDk2N2JlYmUsIDB4NGI3MjM5MzksIDB4ZGU5NDRhNGEsIDB4ZDQ5ODRjNGMsIDB4ZThiMDU4NTgsIDB4NGE4NWNmY2YsIDB4NmJiYmQwZDAsIDB4MmFjNWVmZWYsIDB4ZTU0ZmFhYWEsIDB4MTZlZGZiZmIsIDB4YzU4NjQzNDMsIDB4ZDc5YTRkNGQsIDB4NTU2NjMzMzMsIDB4OTQxMTg1ODUsIDB4Y2Y4YTQ1NDUsIDB4MTBlOWY5ZjksIDB4MDYwNDAyMDIsIDB4ODFmZTdmN2YsIDB4ZjBhMDUwNTAsIDB4NDQ3ODNjM2MsIDB4YmEyNTlmOWYsIDB4ZTM0YmE4YTgsIDB4ZjNhMjUxNTEsIDB4ZmU1ZGEzYTMsIDB4YzA4MDQwNDAsIDB4OGEwNThmOGYsIDB4YWQzZjkyOTIsIDB4YmMyMTlkOWQsIDB4NDg3MDM4MzgsIDB4MDRmMWY1ZjUsIDB4ZGY2M2JjYmMsIDB4YzE3N2I2YjYsIDB4NzVhZmRhZGEsIDB4NjM0MjIxMjEsIDB4MzAyMDEwMTAsIDB4MWFlNWZmZmYsIDB4MGVmZGYzZjMsIDB4NmRiZmQyZDIsIDB4NGM4MWNkY2QsIDB4MTQxODBjMGMsIDB4MzUyNjEzMTMsIDB4MmZjM2VjZWMsIDB4ZTFiZTVmNWYsIDB4YTIzNTk3OTcsIDB4Y2M4ODQ0NDQsIDB4MzkyZTE3MTcsIDB4NTc5M2M0YzQsIDB4ZjI1NWE3YTcsIDB4ODJmYzdlN2UsIDB4NDc3YTNkM2QsIDB4YWNjODY0NjQsIDB4ZTdiYTVkNWQsIDB4MmIzMjE5MTksIDB4OTVlNjczNzMsIDB4YTBjMDYwNjAsIDB4OTgxOTgxODEsIDB4ZDE5ZTRmNGYsIDB4N2ZhM2RjZGMsIDB4NjY0NDIyMjIsIDB4N2U1NDJhMmEsIDB4YWIzYjkwOTAsIDB4ODMwYjg4ODgsIDB4Y2E4YzQ2NDYsIDB4MjljN2VlZWUsIDB4ZDM2YmI4YjgsIDB4M2MyODE0MTQsIDB4NzlhN2RlZGUsIDB4ZTJiYzVlNWUsIDB4MWQxNjBiMGIsIDB4NzZhZGRiZGIsIDB4M2JkYmUwZTAsIDB4NTY2NDMyMzIsIDB4NGU3NDNhM2EsIDB4MWUxNDBhMGEsIDB4ZGI5MjQ5NDksIDB4MGEwYzA2MDYsIDB4NmM0ODI0MjQsIDB4ZTRiODVjNWMsIDB4NWQ5ZmMyYzIsIDB4NmViZGQzZDMsIDB4ZWY0M2FjYWMsIDB4YTZjNDYyNjIsIDB4YTgzOTkxOTEsIDB4YTQzMTk1OTUsIDB4MzdkM2U0ZTQsIDB4OGJmMjc5NzksIDB4MzJkNWU3ZTcsIDB4NDM4YmM4YzgsIDB4NTk2ZTM3MzcsIDB4YjdkYTZkNmQsIDB4OGMwMThkOGQsIDB4NjRiMWQ1ZDUsIDB4ZDI5YzRlNGUsIDB4ZTA0OWE5YTksIDB4YjRkODZjNmMsIDB4ZmFhYzU2NTYsIDB4MDdmM2Y0ZjQsIDB4MjVjZmVhZWEsIDB4YWZjYTY1NjUsIDB4OGVmNDdhN2EsIDB4ZTk0N2FlYWUsIDB4MTgxMDA4MDgsIDB4ZDU2ZmJhYmEsIDB4ODhmMDc4NzgsIDB4NmY0YTI1MjUsIDB4NzI1YzJlMmUsIDB4MjQzODFjMWMsIDB4ZjE1N2E2YTYsIDB4Yzc3M2I0YjQsIDB4NTE5N2M2YzYsIDB4MjNjYmU4ZTgsIDB4N2NhMWRkZGQsIDB4OWNlODc0NzQsIDB4MjEzZTFmMWYsIDB4ZGQ5NjRiNGIsIDB4ZGM2MWJkYmQsIDB4ODYwZDhiOGIsIDB4ODUwZjhhOGEsIDB4OTBlMDcwNzAsIDB4NDI3YzNlM2UsIDB4YzQ3MWI1YjUsIDB4YWFjYzY2NjYsIDB4ZDg5MDQ4NDgsIDB4MDUwNjAzMDMsIDB4MDFmN2Y2ZjYsIDB4MTIxYzBlMGUsIDB4YTNjMjYxNjEsIDB4NWY2YTM1MzUsIDB4ZjlhZTU3NTcsIDB4ZDA2OWI5YjksIDB4OTExNzg2ODYsIDB4NTg5OWMxYzEsIDB4MjczYTFkMWQsIDB4YjkyNzllOWUsIDB4MzhkOWUxZTEsIDB4MTNlYmY4ZjgsIDB4YjMyYjk4OTgsIDB4MzMyMjExMTEsIDB4YmJkMjY5NjksIDB4NzBhOWQ5ZDksIDB4ODkwNzhlOGUsIDB4YTczMzk0OTQsIDB4YjYyZDliOWIsIDB4MjIzYzFlMWUsIDB4OTIxNTg3ODcsIDB4MjBjOWU5ZTksIDB4NDk4N2NlY2UsIDB4ZmZhYTU1NTUsIDB4Nzg1MDI4MjgsIDB4N2FhNWRmZGYsIDB4OGYwMzhjOGMsIDB4Zjg1OWExYTEsIDB4ODAwOTg5ODksIDB4MTcxYTBkMGQsIDB4ZGE2NWJmYmYsIDB4MzFkN2U2ZTYsIDB4YzY4NDQyNDIsIDB4YjhkMDY4NjgsIDB4YzM4MjQxNDEsIDB4YjAyOTk5OTksIDB4Nzc1YTJkMmQsIDB4MTExZTBmMGYsIDB4Y2I3YmIwYjAsIDB4ZmNhODU0NTQsIDB4ZDY2ZGJiYmIsIDB4M2EyYzE2MTZdO1xyXG5jb25zdCBUMyA9IFsweDYzYTVjNjYzLCAweDdjODRmODdjLCAweDc3OTllZTc3LCAweDdiOGRmNjdiLCAweGYyMGRmZmYyLCAweDZiYmRkNjZiLCAweDZmYjFkZTZmLCAweGM1NTQ5MWM1LCAweDMwNTA2MDMwLCAweDAxMDMwMjAxLCAweDY3YTljZTY3LCAweDJiN2Q1NjJiLCAweGZlMTllN2ZlLCAweGQ3NjJiNWQ3LCAweGFiZTY0ZGFiLCAweDc2OWFlYzc2LCAweGNhNDU4ZmNhLCAweDgyOWQxZjgyLCAweGM5NDA4OWM5LCAweDdkODdmYTdkLCAweGZhMTVlZmZhLCAweDU5ZWJiMjU5LCAweDQ3Yzk4ZTQ3LCAweGYwMGJmYmYwLCAweGFkZWM0MWFkLCAweGQ0NjdiM2Q0LCAweGEyZmQ1ZmEyLCAweGFmZWE0NWFmLCAweDljYmYyMzljLCAweGE0Zjc1M2E0LCAweDcyOTZlNDcyLCAweGMwNWI5YmMwLCAweGI3YzI3NWI3LCAweGZkMWNlMWZkLCAweDkzYWUzZDkzLCAweDI2NmE0YzI2LCAweDM2NWE2YzM2LCAweDNmNDE3ZTNmLCAweGY3MDJmNWY3LCAweGNjNGY4M2NjLCAweDM0NWM2ODM0LCAweGE1ZjQ1MWE1LCAweGU1MzRkMWU1LCAweGYxMDhmOWYxLCAweDcxOTNlMjcxLCAweGQ4NzNhYmQ4LCAweDMxNTM2MjMxLCAweDE1M2YyYTE1LCAweDA0MGMwODA0LCAweGM3NTI5NWM3LCAweDIzNjU0NjIzLCAweGMzNWU5ZGMzLCAweDE4MjgzMDE4LCAweDk2YTEzNzk2LCAweDA1MGYwYTA1LCAweDlhYjUyZjlhLCAweDA3MDkwZTA3LCAweDEyMzYyNDEyLCAweDgwOWIxYjgwLCAweGUyM2RkZmUyLCAweGViMjZjZGViLCAweDI3Njk0ZTI3LCAweGIyY2Q3ZmIyLCAweDc1OWZlYTc1LCAweDA5MWIxMjA5LCAweDgzOWUxZDgzLCAweDJjNzQ1ODJjLCAweDFhMmUzNDFhLCAweDFiMmQzNjFiLCAweDZlYjJkYzZlLCAweDVhZWViNDVhLCAweGEwZmI1YmEwLCAweDUyZjZhNDUyLCAweDNiNGQ3NjNiLCAweGQ2NjFiN2Q2LCAweGIzY2U3ZGIzLCAweDI5N2I1MjI5LCAweGUzM2VkZGUzLCAweDJmNzE1ZTJmLCAweDg0OTcxMzg0LCAweDUzZjVhNjUzLCAweGQxNjhiOWQxLCAweDAwMDAwMDAwLCAweGVkMmNjMWVkLCAweDIwNjA0MDIwLCAweGZjMWZlM2ZjLCAweGIxYzg3OWIxLCAweDViZWRiNjViLCAweDZhYmVkNDZhLCAweGNiNDY4ZGNiLCAweGJlZDk2N2JlLCAweDM5NGI3MjM5LCAweDRhZGU5NDRhLCAweDRjZDQ5ODRjLCAweDU4ZThiMDU4LCAweGNmNGE4NWNmLCAweGQwNmJiYmQwLCAweGVmMmFjNWVmLCAweGFhZTU0ZmFhLCAweGZiMTZlZGZiLCAweDQzYzU4NjQzLCAweDRkZDc5YTRkLCAweDMzNTU2NjMzLCAweDg1OTQxMTg1LCAweDQ1Y2Y4YTQ1LCAweGY5MTBlOWY5LCAweDAyMDYwNDAyLCAweDdmODFmZTdmLCAweDUwZjBhMDUwLCAweDNjNDQ3ODNjLCAweDlmYmEyNTlmLCAweGE4ZTM0YmE4LCAweDUxZjNhMjUxLCAweGEzZmU1ZGEzLCAweDQwYzA4MDQwLCAweDhmOGEwNThmLCAweDkyYWQzZjkyLCAweDlkYmMyMTlkLCAweDM4NDg3MDM4LCAweGY1MDRmMWY1LCAweGJjZGY2M2JjLCAweGI2YzE3N2I2LCAweGRhNzVhZmRhLCAweDIxNjM0MjIxLCAweDEwMzAyMDEwLCAweGZmMWFlNWZmLCAweGYzMGVmZGYzLCAweGQyNmRiZmQyLCAweGNkNGM4MWNkLCAweDBjMTQxODBjLCAweDEzMzUyNjEzLCAweGVjMmZjM2VjLCAweDVmZTFiZTVmLCAweDk3YTIzNTk3LCAweDQ0Y2M4ODQ0LCAweDE3MzkyZTE3LCAweGM0NTc5M2M0LCAweGE3ZjI1NWE3LCAweDdlODJmYzdlLCAweDNkNDc3YTNkLCAweDY0YWNjODY0LCAweDVkZTdiYTVkLCAweDE5MmIzMjE5LCAweDczOTVlNjczLCAweDYwYTBjMDYwLCAweDgxOTgxOTgxLCAweDRmZDE5ZTRmLCAweGRjN2ZhM2RjLCAweDIyNjY0NDIyLCAweDJhN2U1NDJhLCAweDkwYWIzYjkwLCAweDg4ODMwYjg4LCAweDQ2Y2E4YzQ2LCAweGVlMjljN2VlLCAweGI4ZDM2YmI4LCAweDE0M2MyODE0LCAweGRlNzlhN2RlLCAweDVlZTJiYzVlLCAweDBiMWQxNjBiLCAweGRiNzZhZGRiLCAweGUwM2JkYmUwLCAweDMyNTY2NDMyLCAweDNhNGU3NDNhLCAweDBhMWUxNDBhLCAweDQ5ZGI5MjQ5LCAweDA2MGEwYzA2LCAweDI0NmM0ODI0LCAweDVjZTRiODVjLCAweGMyNWQ5ZmMyLCAweGQzNmViZGQzLCAweGFjZWY0M2FjLCAweDYyYTZjNDYyLCAweDkxYTgzOTkxLCAweDk1YTQzMTk1LCAweGU0MzdkM2U0LCAweDc5OGJmMjc5LCAweGU3MzJkNWU3LCAweGM4NDM4YmM4LCAweDM3NTk2ZTM3LCAweDZkYjdkYTZkLCAweDhkOGMwMThkLCAweGQ1NjRiMWQ1LCAweDRlZDI5YzRlLCAweGE5ZTA0OWE5LCAweDZjYjRkODZjLCAweDU2ZmFhYzU2LCAweGY0MDdmM2Y0LCAweGVhMjVjZmVhLCAweDY1YWZjYTY1LCAweDdhOGVmNDdhLCAweGFlZTk0N2FlLCAweDA4MTgxMDA4LCAweGJhZDU2ZmJhLCAweDc4ODhmMDc4LCAweDI1NmY0YTI1LCAweDJlNzI1YzJlLCAweDFjMjQzODFjLCAweGE2ZjE1N2E2LCAweGI0Yzc3M2I0LCAweGM2NTE5N2M2LCAweGU4MjNjYmU4LCAweGRkN2NhMWRkLCAweDc0OWNlODc0LCAweDFmMjEzZTFmLCAweDRiZGQ5NjRiLCAweGJkZGM2MWJkLCAweDhiODYwZDhiLCAweDhhODUwZjhhLCAweDcwOTBlMDcwLCAweDNlNDI3YzNlLCAweGI1YzQ3MWI1LCAweDY2YWFjYzY2LCAweDQ4ZDg5MDQ4LCAweDAzMDUwNjAzLCAweGY2MDFmN2Y2LCAweDBlMTIxYzBlLCAweDYxYTNjMjYxLCAweDM1NWY2YTM1LCAweDU3ZjlhZTU3LCAweGI5ZDA2OWI5LCAweDg2OTExNzg2LCAweGMxNTg5OWMxLCAweDFkMjczYTFkLCAweDllYjkyNzllLCAweGUxMzhkOWUxLCAweGY4MTNlYmY4LCAweDk4YjMyYjk4LCAweDExMzMyMjExLCAweDY5YmJkMjY5LCAweGQ5NzBhOWQ5LCAweDhlODkwNzhlLCAweDk0YTczMzk0LCAweDliYjYyZDliLCAweDFlMjIzYzFlLCAweDg3OTIxNTg3LCAweGU5MjBjOWU5LCAweGNlNDk4N2NlLCAweDU1ZmZhYTU1LCAweDI4Nzg1MDI4LCAweGRmN2FhNWRmLCAweDhjOGYwMzhjLCAweGExZjg1OWExLCAweDg5ODAwOTg5LCAweDBkMTcxYTBkLCAweGJmZGE2NWJmLCAweGU2MzFkN2U2LCAweDQyYzY4NDQyLCAweDY4YjhkMDY4LCAweDQxYzM4MjQxLCAweDk5YjAyOTk5LCAweDJkNzc1YTJkLCAweDBmMTExZTBmLCAweGIwY2I3YmIwLCAweDU0ZmNhODU0LCAweGJiZDY2ZGJiLCAweDE2M2EyYzE2XTtcclxuY29uc3QgVDQgPSBbMHg2MzYzYTVjNiwgMHg3YzdjODRmOCwgMHg3Nzc3OTllZSwgMHg3YjdiOGRmNiwgMHhmMmYyMGRmZiwgMHg2YjZiYmRkNiwgMHg2ZjZmYjFkZSwgMHhjNWM1NTQ5MSwgMHgzMDMwNTA2MCwgMHgwMTAxMDMwMiwgMHg2NzY3YTljZSwgMHgyYjJiN2Q1NiwgMHhmZWZlMTllNywgMHhkN2Q3NjJiNSwgMHhhYmFiZTY0ZCwgMHg3Njc2OWFlYywgMHhjYWNhNDU4ZiwgMHg4MjgyOWQxZiwgMHhjOWM5NDA4OSwgMHg3ZDdkODdmYSwgMHhmYWZhMTVlZiwgMHg1OTU5ZWJiMiwgMHg0NzQ3Yzk4ZSwgMHhmMGYwMGJmYiwgMHhhZGFkZWM0MSwgMHhkNGQ0NjdiMywgMHhhMmEyZmQ1ZiwgMHhhZmFmZWE0NSwgMHg5YzljYmYyMywgMHhhNGE0Zjc1MywgMHg3MjcyOTZlNCwgMHhjMGMwNWI5YiwgMHhiN2I3YzI3NSwgMHhmZGZkMWNlMSwgMHg5MzkzYWUzZCwgMHgyNjI2NmE0YywgMHgzNjM2NWE2YywgMHgzZjNmNDE3ZSwgMHhmN2Y3MDJmNSwgMHhjY2NjNGY4MywgMHgzNDM0NWM2OCwgMHhhNWE1ZjQ1MSwgMHhlNWU1MzRkMSwgMHhmMWYxMDhmOSwgMHg3MTcxOTNlMiwgMHhkOGQ4NzNhYiwgMHgzMTMxNTM2MiwgMHgxNTE1M2YyYSwgMHgwNDA0MGMwOCwgMHhjN2M3NTI5NSwgMHgyMzIzNjU0NiwgMHhjM2MzNWU5ZCwgMHgxODE4MjgzMCwgMHg5Njk2YTEzNywgMHgwNTA1MGYwYSwgMHg5YTlhYjUyZiwgMHgwNzA3MDkwZSwgMHgxMjEyMzYyNCwgMHg4MDgwOWIxYiwgMHhlMmUyM2RkZiwgMHhlYmViMjZjZCwgMHgyNzI3Njk0ZSwgMHhiMmIyY2Q3ZiwgMHg3NTc1OWZlYSwgMHgwOTA5MWIxMiwgMHg4MzgzOWUxZCwgMHgyYzJjNzQ1OCwgMHgxYTFhMmUzNCwgMHgxYjFiMmQzNiwgMHg2ZTZlYjJkYywgMHg1YTVhZWViNCwgMHhhMGEwZmI1YiwgMHg1MjUyZjZhNCwgMHgzYjNiNGQ3NiwgMHhkNmQ2NjFiNywgMHhiM2IzY2U3ZCwgMHgyOTI5N2I1MiwgMHhlM2UzM2VkZCwgMHgyZjJmNzE1ZSwgMHg4NDg0OTcxMywgMHg1MzUzZjVhNiwgMHhkMWQxNjhiOSwgMHgwMDAwMDAwMCwgMHhlZGVkMmNjMSwgMHgyMDIwNjA0MCwgMHhmY2ZjMWZlMywgMHhiMWIxYzg3OSwgMHg1YjViZWRiNiwgMHg2YTZhYmVkNCwgMHhjYmNiNDY4ZCwgMHhiZWJlZDk2NywgMHgzOTM5NGI3MiwgMHg0YTRhZGU5NCwgMHg0YzRjZDQ5OCwgMHg1ODU4ZThiMCwgMHhjZmNmNGE4NSwgMHhkMGQwNmJiYiwgMHhlZmVmMmFjNSwgMHhhYWFhZTU0ZiwgMHhmYmZiMTZlZCwgMHg0MzQzYzU4NiwgMHg0ZDRkZDc5YSwgMHgzMzMzNTU2NiwgMHg4NTg1OTQxMSwgMHg0NTQ1Y2Y4YSwgMHhmOWY5MTBlOSwgMHgwMjAyMDYwNCwgMHg3ZjdmODFmZSwgMHg1MDUwZjBhMCwgMHgzYzNjNDQ3OCwgMHg5ZjlmYmEyNSwgMHhhOGE4ZTM0YiwgMHg1MTUxZjNhMiwgMHhhM2EzZmU1ZCwgMHg0MDQwYzA4MCwgMHg4ZjhmOGEwNSwgMHg5MjkyYWQzZiwgMHg5ZDlkYmMyMSwgMHgzODM4NDg3MCwgMHhmNWY1MDRmMSwgMHhiY2JjZGY2MywgMHhiNmI2YzE3NywgMHhkYWRhNzVhZiwgMHgyMTIxNjM0MiwgMHgxMDEwMzAyMCwgMHhmZmZmMWFlNSwgMHhmM2YzMGVmZCwgMHhkMmQyNmRiZiwgMHhjZGNkNGM4MSwgMHgwYzBjMTQxOCwgMHgxMzEzMzUyNiwgMHhlY2VjMmZjMywgMHg1ZjVmZTFiZSwgMHg5Nzk3YTIzNSwgMHg0NDQ0Y2M4OCwgMHgxNzE3MzkyZSwgMHhjNGM0NTc5MywgMHhhN2E3ZjI1NSwgMHg3ZTdlODJmYywgMHgzZDNkNDc3YSwgMHg2NDY0YWNjOCwgMHg1ZDVkZTdiYSwgMHgxOTE5MmIzMiwgMHg3MzczOTVlNiwgMHg2MDYwYTBjMCwgMHg4MTgxOTgxOSwgMHg0ZjRmZDE5ZSwgMHhkY2RjN2ZhMywgMHgyMjIyNjY0NCwgMHgyYTJhN2U1NCwgMHg5MDkwYWIzYiwgMHg4ODg4ODMwYiwgMHg0NjQ2Y2E4YywgMHhlZWVlMjljNywgMHhiOGI4ZDM2YiwgMHgxNDE0M2MyOCwgMHhkZWRlNzlhNywgMHg1ZTVlZTJiYywgMHgwYjBiMWQxNiwgMHhkYmRiNzZhZCwgMHhlMGUwM2JkYiwgMHgzMjMyNTY2NCwgMHgzYTNhNGU3NCwgMHgwYTBhMWUxNCwgMHg0OTQ5ZGI5MiwgMHgwNjA2MGEwYywgMHgyNDI0NmM0OCwgMHg1YzVjZTRiOCwgMHhjMmMyNWQ5ZiwgMHhkM2QzNmViZCwgMHhhY2FjZWY0MywgMHg2MjYyYTZjNCwgMHg5MTkxYTgzOSwgMHg5NTk1YTQzMSwgMHhlNGU0MzdkMywgMHg3OTc5OGJmMiwgMHhlN2U3MzJkNSwgMHhjOGM4NDM4YiwgMHgzNzM3NTk2ZSwgMHg2ZDZkYjdkYSwgMHg4ZDhkOGMwMSwgMHhkNWQ1NjRiMSwgMHg0ZTRlZDI5YywgMHhhOWE5ZTA0OSwgMHg2YzZjYjRkOCwgMHg1NjU2ZmFhYywgMHhmNGY0MDdmMywgMHhlYWVhMjVjZiwgMHg2NTY1YWZjYSwgMHg3YTdhOGVmNCwgMHhhZWFlZTk0NywgMHgwODA4MTgxMCwgMHhiYWJhZDU2ZiwgMHg3ODc4ODhmMCwgMHgyNTI1NmY0YSwgMHgyZTJlNzI1YywgMHgxYzFjMjQzOCwgMHhhNmE2ZjE1NywgMHhiNGI0Yzc3MywgMHhjNmM2NTE5NywgMHhlOGU4MjNjYiwgMHhkZGRkN2NhMSwgMHg3NDc0OWNlOCwgMHgxZjFmMjEzZSwgMHg0YjRiZGQ5NiwgMHhiZGJkZGM2MSwgMHg4YjhiODYwZCwgMHg4YThhODUwZiwgMHg3MDcwOTBlMCwgMHgzZTNlNDI3YywgMHhiNWI1YzQ3MSwgMHg2NjY2YWFjYywgMHg0ODQ4ZDg5MCwgMHgwMzAzMDUwNiwgMHhmNmY2MDFmNywgMHgwZTBlMTIxYywgMHg2MTYxYTNjMiwgMHgzNTM1NWY2YSwgMHg1NzU3ZjlhZSwgMHhiOWI5ZDA2OSwgMHg4Njg2OTExNywgMHhjMWMxNTg5OSwgMHgxZDFkMjczYSwgMHg5ZTllYjkyNywgMHhlMWUxMzhkOSwgMHhmOGY4MTNlYiwgMHg5ODk4YjMyYiwgMHgxMTExMzMyMiwgMHg2OTY5YmJkMiwgMHhkOWQ5NzBhOSwgMHg4ZThlODkwNywgMHg5NDk0YTczMywgMHg5YjliYjYyZCwgMHgxZTFlMjIzYywgMHg4Nzg3OTIxNSwgMHhlOWU5MjBjOSwgMHhjZWNlNDk4NywgMHg1NTU1ZmZhYSwgMHgyODI4Nzg1MCwgMHhkZmRmN2FhNSwgMHg4YzhjOGYwMywgMHhhMWExZjg1OSwgMHg4OTg5ODAwOSwgMHgwZDBkMTcxYSwgMHhiZmJmZGE2NSwgMHhlNmU2MzFkNywgMHg0MjQyYzY4NCwgMHg2ODY4YjhkMCwgMHg0MTQxYzM4MiwgMHg5OTk5YjAyOSwgMHgyZDJkNzc1YSwgMHgwZjBmMTExZSwgMHhiMGIwY2I3YiwgMHg1NDU0ZmNhOCwgMHhiYmJiZDY2ZCwgMHgxNjE2M2EyY107XHJcbi8vIFRyYW5zZm9ybWF0aW9ucyBmb3IgZGVjcnlwdGlvblxyXG5jb25zdCBUNSA9IFsweDUxZjRhNzUwLCAweDdlNDE2NTUzLCAweDFhMTdhNGMzLCAweDNhMjc1ZTk2LCAweDNiYWI2YmNiLCAweDFmOWQ0NWYxLCAweGFjZmE1OGFiLCAweDRiZTMwMzkzLCAweDIwMzBmYTU1LCAweGFkNzY2ZGY2LCAweDg4Y2M3NjkxLCAweGY1MDI0YzI1LCAweDRmZTVkN2ZjLCAweGM1MmFjYmQ3LCAweDI2MzU0NDgwLCAweGI1NjJhMzhmLCAweGRlYjE1YTQ5LCAweDI1YmExYjY3LCAweDQ1ZWEwZTk4LCAweDVkZmVjMGUxLCAweGMzMmY3NTAyLCAweDgxNGNmMDEyLCAweDhkNDY5N2EzLCAweDZiZDNmOWM2LCAweDAzOGY1ZmU3LCAweDE1OTI5Yzk1LCAweGJmNmQ3YWViLCAweDk1NTI1OWRhLCAweGQ0YmU4MzJkLCAweDU4NzQyMWQzLCAweDQ5ZTA2OTI5LCAweDhlYzljODQ0LCAweDc1YzI4OTZhLCAweGY0OGU3OTc4LCAweDk5NTgzZTZiLCAweDI3Yjk3MWRkLCAweGJlZTE0ZmI2LCAweGYwODhhZDE3LCAweGM5MjBhYzY2LCAweDdkY2UzYWI0LCAweDYzZGY0YTE4LCAweGU1MWEzMTgyLCAweDk3NTEzMzYwLCAweDYyNTM3ZjQ1LCAweGIxNjQ3N2UwLCAweGJiNmJhZTg0LCAweGZlODFhMDFjLCAweGY5MDgyYjk0LCAweDcwNDg2ODU4LCAweDhmNDVmZDE5LCAweDk0ZGU2Yzg3LCAweDUyN2JmOGI3LCAweGFiNzNkMzIzLCAweDcyNGIwMmUyLCAweGUzMWY4ZjU3LCAweDY2NTVhYjJhLCAweGIyZWIyODA3LCAweDJmYjVjMjAzLCAweDg2YzU3YjlhLCAweGQzMzcwOGE1LCAweDMwMjg4N2YyLCAweDIzYmZhNWIyLCAweDAyMDM2YWJhLCAweGVkMTY4MjVjLCAweDhhY2YxYzJiLCAweGE3NzliNDkyLCAweGYzMDdmMmYwLCAweDRlNjllMmExLCAweDY1ZGFmNGNkLCAweDA2MDViZWQ1LCAweGQxMzQ2MjFmLCAweGM0YTZmZThhLCAweDM0MmU1MzlkLCAweGEyZjM1NWEwLCAweDA1OGFlMTMyLCAweGE0ZjZlYjc1LCAweDBiODNlYzM5LCAweDQwNjBlZmFhLCAweDVlNzE5ZjA2LCAweGJkNmUxMDUxLCAweDNlMjE4YWY5LCAweDk2ZGQwNjNkLCAweGRkM2UwNWFlLCAweDRkZTZiZDQ2LCAweDkxNTQ4ZGI1LCAweDcxYzQ1ZDA1LCAweDA0MDZkNDZmLCAweDYwNTAxNWZmLCAweDE5OThmYjI0LCAweGQ2YmRlOTk3LCAweDg5NDA0M2NjLCAweDY3ZDk5ZTc3LCAweGIwZTg0MmJkLCAweDA3ODk4Yjg4LCAweGU3MTk1YjM4LCAweDc5YzhlZWRiLCAweGExN2MwYTQ3LCAweDdjNDIwZmU5LCAweGY4ODQxZWM5LCAweDAwMDAwMDAwLCAweDA5ODA4NjgzLCAweDMyMmJlZDQ4LCAweDFlMTE3MGFjLCAweDZjNWE3MjRlLCAweGZkMGVmZmZiLCAweDBmODUzODU2LCAweDNkYWVkNTFlLCAweDM2MmQzOTI3LCAweDBhMGZkOTY0LCAweDY4NWNhNjIxLCAweDliNWI1NGQxLCAweDI0MzYyZTNhLCAweDBjMGE2N2IxLCAweDkzNTdlNzBmLCAweGI0ZWU5NmQyLCAweDFiOWI5MTllLCAweDgwYzBjNTRmLCAweDYxZGMyMGEyLCAweDVhNzc0YjY5LCAweDFjMTIxYTE2LCAweGUyOTNiYTBhLCAweGMwYTAyYWU1LCAweDNjMjJlMDQzLCAweDEyMWIxNzFkLCAweDBlMDkwZDBiLCAweGYyOGJjN2FkLCAweDJkYjZhOGI5LCAweDE0MWVhOWM4LCAweDU3ZjExOTg1LCAweGFmNzUwNzRjLCAweGVlOTlkZGJiLCAweGEzN2Y2MGZkLCAweGY3MDEyNjlmLCAweDVjNzJmNWJjLCAweDQ0NjYzYmM1LCAweDViZmI3ZTM0LCAweDhiNDMyOTc2LCAweGNiMjNjNmRjLCAweGI2ZWRmYzY4LCAweGI4ZTRmMTYzLCAweGQ3MzFkY2NhLCAweDQyNjM4NTEwLCAweDEzOTcyMjQwLCAweDg0YzYxMTIwLCAweDg1NGEyNDdkLCAweGQyYmIzZGY4LCAweGFlZjkzMjExLCAweGM3MjlhMTZkLCAweDFkOWUyZjRiLCAweGRjYjIzMGYzLCAweDBkODY1MmVjLCAweDc3YzFlM2QwLCAweDJiYjMxNjZjLCAweGE5NzBiOTk5LCAweDExOTQ0OGZhLCAweDQ3ZTk2NDIyLCAweGE4ZmM4Y2M0LCAweGEwZjAzZjFhLCAweDU2N2QyY2Q4LCAweDIyMzM5MGVmLCAweDg3NDk0ZWM3LCAweGQ5MzhkMWMxLCAweDhjY2FhMmZlLCAweDk4ZDQwYjM2LCAweGE2ZjU4MWNmLCAweGE1N2FkZTI4LCAweGRhYjc4ZTI2LCAweDNmYWRiZmE0LCAweDJjM2E5ZGU0LCAweDUwNzg5MjBkLCAweDZhNWZjYzliLCAweDU0N2U0NjYyLCAweGY2OGQxM2MyLCAweDkwZDhiOGU4LCAweDJlMzlmNzVlLCAweDgyYzNhZmY1LCAweDlmNWQ4MGJlLCAweDY5ZDA5MzdjLCAweDZmZDUyZGE5LCAweGNmMjUxMmIzLCAweGM4YWM5OTNiLCAweDEwMTg3ZGE3LCAweGU4OWM2MzZlLCAweGRiM2JiYjdiLCAweGNkMjY3ODA5LCAweDZlNTkxOGY0LCAweGVjOWFiNzAxLCAweDgzNGY5YWE4LCAweGU2OTU2ZTY1LCAweGFhZmZlNjdlLCAweDIxYmNjZjA4LCAweGVmMTVlOGU2LCAweGJhZTc5YmQ5LCAweDRhNmYzNmNlLCAweGVhOWYwOWQ0LCAweDI5YjA3Y2Q2LCAweDMxYTRiMmFmLCAweDJhM2YyMzMxLCAweGM2YTU5NDMwLCAweDM1YTI2NmMwLCAweDc0NGViYzM3LCAweGZjODJjYWE2LCAweGUwOTBkMGIwLCAweDMzYTdkODE1LCAweGYxMDQ5ODRhLCAweDQxZWNkYWY3LCAweDdmY2Q1MDBlLCAweDE3OTFmNjJmLCAweDc2NGRkNjhkLCAweDQzZWZiMDRkLCAweGNjYWE0ZDU0LCAweGU0OTYwNGRmLCAweDllZDFiNWUzLCAweDRjNmE4ODFiLCAweGMxMmMxZmI4LCAweDQ2NjU1MTdmLCAweDlkNWVlYTA0LCAweDAxOGMzNTVkLCAweGZhODc3NDczLCAweGZiMGI0MTJlLCAweGIzNjcxZDVhLCAweDkyZGJkMjUyLCAweGU5MTA1NjMzLCAweDZkZDY0NzEzLCAweDlhZDc2MThjLCAweDM3YTEwYzdhLCAweDU5ZjgxNDhlLCAweGViMTMzYzg5LCAweGNlYTkyN2VlLCAweGI3NjFjOTM1LCAweGUxMWNlNWVkLCAweDdhNDdiMTNjLCAweDljZDJkZjU5LCAweDU1ZjI3MzNmLCAweDE4MTRjZTc5LCAweDczYzczN2JmLCAweDUzZjdjZGVhLCAweDVmZmRhYTViLCAweGRmM2Q2ZjE0LCAweDc4NDRkYjg2LCAweGNhYWZmMzgxLCAweGI5NjhjNDNlLCAweDM4MjQzNDJjLCAweGMyYTM0MDVmLCAweDE2MWRjMzcyLCAweGJjZTIyNTBjLCAweDI4M2M0OThiLCAweGZmMGQ5NTQxLCAweDM5YTgwMTcxLCAweDA4MGNiM2RlLCAweGQ4YjRlNDljLCAweDY0NTZjMTkwLCAweDdiY2I4NDYxLCAweGQ1MzJiNjcwLCAweDQ4NmM1Yzc0LCAweGQwYjg1NzQyXTtcclxuY29uc3QgVDYgPSBbMHg1MDUxZjRhNywgMHg1MzdlNDE2NSwgMHhjMzFhMTdhNCwgMHg5NjNhMjc1ZSwgMHhjYjNiYWI2YiwgMHhmMTFmOWQ0NSwgMHhhYmFjZmE1OCwgMHg5MzRiZTMwMywgMHg1NTIwMzBmYSwgMHhmNmFkNzY2ZCwgMHg5MTg4Y2M3NiwgMHgyNWY1MDI0YywgMHhmYzRmZTVkNywgMHhkN2M1MmFjYiwgMHg4MDI2MzU0NCwgMHg4ZmI1NjJhMywgMHg0OWRlYjE1YSwgMHg2NzI1YmExYiwgMHg5ODQ1ZWEwZSwgMHhlMTVkZmVjMCwgMHgwMmMzMmY3NSwgMHgxMjgxNGNmMCwgMHhhMzhkNDY5NywgMHhjNjZiZDNmOSwgMHhlNzAzOGY1ZiwgMHg5NTE1OTI5YywgMHhlYmJmNmQ3YSwgMHhkYTk1NTI1OSwgMHgyZGQ0YmU4MywgMHhkMzU4NzQyMSwgMHgyOTQ5ZTA2OSwgMHg0NDhlYzljOCwgMHg2YTc1YzI4OSwgMHg3OGY0OGU3OSwgMHg2Yjk5NTgzZSwgMHhkZDI3Yjk3MSwgMHhiNmJlZTE0ZiwgMHgxN2YwODhhZCwgMHg2NmM5MjBhYywgMHhiNDdkY2UzYSwgMHgxODYzZGY0YSwgMHg4MmU1MWEzMSwgMHg2MDk3NTEzMywgMHg0NTYyNTM3ZiwgMHhlMGIxNjQ3NywgMHg4NGJiNmJhZSwgMHgxY2ZlODFhMCwgMHg5NGY5MDgyYiwgMHg1ODcwNDg2OCwgMHgxOThmNDVmZCwgMHg4Nzk0ZGU2YywgMHhiNzUyN2JmOCwgMHgyM2FiNzNkMywgMHhlMjcyNGIwMiwgMHg1N2UzMWY4ZiwgMHgyYTY2NTVhYiwgMHgwN2IyZWIyOCwgMHgwMzJmYjVjMiwgMHg5YTg2YzU3YiwgMHhhNWQzMzcwOCwgMHhmMjMwMjg4NywgMHhiMjIzYmZhNSwgMHhiYTAyMDM2YSwgMHg1Y2VkMTY4MiwgMHgyYjhhY2YxYywgMHg5MmE3NzliNCwgMHhmMGYzMDdmMiwgMHhhMTRlNjllMiwgMHhjZDY1ZGFmNCwgMHhkNTA2MDViZSwgMHgxZmQxMzQ2MiwgMHg4YWM0YTZmZSwgMHg5ZDM0MmU1MywgMHhhMGEyZjM1NSwgMHgzMjA1OGFlMSwgMHg3NWE0ZjZlYiwgMHgzOTBiODNlYywgMHhhYTQwNjBlZiwgMHgwNjVlNzE5ZiwgMHg1MWJkNmUxMCwgMHhmOTNlMjE4YSwgMHgzZDk2ZGQwNiwgMHhhZWRkM2UwNSwgMHg0NjRkZTZiZCwgMHhiNTkxNTQ4ZCwgMHgwNTcxYzQ1ZCwgMHg2ZjA0MDZkNCwgMHhmZjYwNTAxNSwgMHgyNDE5OThmYiwgMHg5N2Q2YmRlOSwgMHhjYzg5NDA0MywgMHg3NzY3ZDk5ZSwgMHhiZGIwZTg0MiwgMHg4ODA3ODk4YiwgMHgzOGU3MTk1YiwgMHhkYjc5YzhlZSwgMHg0N2ExN2MwYSwgMHhlOTdjNDIwZiwgMHhjOWY4ODQxZSwgMHgwMDAwMDAwMCwgMHg4MzA5ODA4NiwgMHg0ODMyMmJlZCwgMHhhYzFlMTE3MCwgMHg0ZTZjNWE3MiwgMHhmYmZkMGVmZiwgMHg1NjBmODUzOCwgMHgxZTNkYWVkNSwgMHgyNzM2MmQzOSwgMHg2NDBhMGZkOSwgMHgyMTY4NWNhNiwgMHhkMTliNWI1NCwgMHgzYTI0MzYyZSwgMHhiMTBjMGE2NywgMHgwZjkzNTdlNywgMHhkMmI0ZWU5NiwgMHg5ZTFiOWI5MSwgMHg0ZjgwYzBjNSwgMHhhMjYxZGMyMCwgMHg2OTVhNzc0YiwgMHgxNjFjMTIxYSwgMHgwYWUyOTNiYSwgMHhlNWMwYTAyYSwgMHg0MzNjMjJlMCwgMHgxZDEyMWIxNywgMHgwYjBlMDkwZCwgMHhhZGYyOGJjNywgMHhiOTJkYjZhOCwgMHhjODE0MWVhOSwgMHg4NTU3ZjExOSwgMHg0Y2FmNzUwNywgMHhiYmVlOTlkZCwgMHhmZGEzN2Y2MCwgMHg5ZmY3MDEyNiwgMHhiYzVjNzJmNSwgMHhjNTQ0NjYzYiwgMHgzNDViZmI3ZSwgMHg3NjhiNDMyOSwgMHhkY2NiMjNjNiwgMHg2OGI2ZWRmYywgMHg2M2I4ZTRmMSwgMHhjYWQ3MzFkYywgMHgxMDQyNjM4NSwgMHg0MDEzOTcyMiwgMHgyMDg0YzYxMSwgMHg3ZDg1NGEyNCwgMHhmOGQyYmIzZCwgMHgxMWFlZjkzMiwgMHg2ZGM3MjlhMSwgMHg0YjFkOWUyZiwgMHhmM2RjYjIzMCwgMHhlYzBkODY1MiwgMHhkMDc3YzFlMywgMHg2YzJiYjMxNiwgMHg5OWE5NzBiOSwgMHhmYTExOTQ0OCwgMHgyMjQ3ZTk2NCwgMHhjNGE4ZmM4YywgMHgxYWEwZjAzZiwgMHhkODU2N2QyYywgMHhlZjIyMzM5MCwgMHhjNzg3NDk0ZSwgMHhjMWQ5MzhkMSwgMHhmZThjY2FhMiwgMHgzNjk4ZDQwYiwgMHhjZmE2ZjU4MSwgMHgyOGE1N2FkZSwgMHgyNmRhYjc4ZSwgMHhhNDNmYWRiZiwgMHhlNDJjM2E5ZCwgMHgwZDUwNzg5MiwgMHg5YjZhNWZjYywgMHg2MjU0N2U0NiwgMHhjMmY2OGQxMywgMHhlODkwZDhiOCwgMHg1ZTJlMzlmNywgMHhmNTgyYzNhZiwgMHhiZTlmNWQ4MCwgMHg3YzY5ZDA5MywgMHhhOTZmZDUyZCwgMHhiM2NmMjUxMiwgMHgzYmM4YWM5OSwgMHhhNzEwMTg3ZCwgMHg2ZWU4OWM2MywgMHg3YmRiM2JiYiwgMHgwOWNkMjY3OCwgMHhmNDZlNTkxOCwgMHgwMWVjOWFiNywgMHhhODgzNGY5YSwgMHg2NWU2OTU2ZSwgMHg3ZWFhZmZlNiwgMHgwODIxYmNjZiwgMHhlNmVmMTVlOCwgMHhkOWJhZTc5YiwgMHhjZTRhNmYzNiwgMHhkNGVhOWYwOSwgMHhkNjI5YjA3YywgMHhhZjMxYTRiMiwgMHgzMTJhM2YyMywgMHgzMGM2YTU5NCwgMHhjMDM1YTI2NiwgMHgzNzc0NGViYywgMHhhNmZjODJjYSwgMHhiMGUwOTBkMCwgMHgxNTMzYTdkOCwgMHg0YWYxMDQ5OCwgMHhmNzQxZWNkYSwgMHgwZTdmY2Q1MCwgMHgyZjE3OTFmNiwgMHg4ZDc2NGRkNiwgMHg0ZDQzZWZiMCwgMHg1NGNjYWE0ZCwgMHhkZmU0OTYwNCwgMHhlMzllZDFiNSwgMHgxYjRjNmE4OCwgMHhiOGMxMmMxZiwgMHg3ZjQ2NjU1MSwgMHgwNDlkNWVlYSwgMHg1ZDAxOGMzNSwgMHg3M2ZhODc3NCwgMHgyZWZiMGI0MSwgMHg1YWIzNjcxZCwgMHg1MjkyZGJkMiwgMHgzM2U5MTA1NiwgMHgxMzZkZDY0NywgMHg4YzlhZDc2MSwgMHg3YTM3YTEwYywgMHg4ZTU5ZjgxNCwgMHg4OWViMTMzYywgMHhlZWNlYTkyNywgMHgzNWI3NjFjOSwgMHhlZGUxMWNlNSwgMHgzYzdhNDdiMSwgMHg1OTljZDJkZiwgMHgzZjU1ZjI3MywgMHg3OTE4MTRjZSwgMHhiZjczYzczNywgMHhlYTUzZjdjZCwgMHg1YjVmZmRhYSwgMHgxNGRmM2Q2ZiwgMHg4Njc4NDRkYiwgMHg4MWNhYWZmMywgMHgzZWI5NjhjNCwgMHgyYzM4MjQzNCwgMHg1ZmMyYTM0MCwgMHg3MjE2MWRjMywgMHgwY2JjZTIyNSwgMHg4YjI4M2M0OSwgMHg0MWZmMGQ5NSwgMHg3MTM5YTgwMSwgMHhkZTA4MGNiMywgMHg5Y2Q4YjRlNCwgMHg5MDY0NTZjMSwgMHg2MTdiY2I4NCwgMHg3MGQ1MzJiNiwgMHg3NDQ4NmM1YywgMHg0MmQwYjg1N107XHJcbmNvbnN0IFQ3ID0gWzB4YTc1MDUxZjQsIDB4NjU1MzdlNDEsIDB4YTRjMzFhMTcsIDB4NWU5NjNhMjcsIDB4NmJjYjNiYWIsIDB4NDVmMTFmOWQsIDB4NThhYmFjZmEsIDB4MDM5MzRiZTMsIDB4ZmE1NTIwMzAsIDB4NmRmNmFkNzYsIDB4NzY5MTg4Y2MsIDB4NGMyNWY1MDIsIDB4ZDdmYzRmZTUsIDB4Y2JkN2M1MmEsIDB4NDQ4MDI2MzUsIDB4YTM4ZmI1NjIsIDB4NWE0OWRlYjEsIDB4MWI2NzI1YmEsIDB4MGU5ODQ1ZWEsIDB4YzBlMTVkZmUsIDB4NzUwMmMzMmYsIDB4ZjAxMjgxNGMsIDB4OTdhMzhkNDYsIDB4ZjljNjZiZDMsIDB4NWZlNzAzOGYsIDB4OWM5NTE1OTIsIDB4N2FlYmJmNmQsIDB4NTlkYTk1NTIsIDB4ODMyZGQ0YmUsIDB4MjFkMzU4NzQsIDB4NjkyOTQ5ZTAsIDB4Yzg0NDhlYzksIDB4ODk2YTc1YzIsIDB4Nzk3OGY0OGUsIDB4M2U2Yjk5NTgsIDB4NzFkZDI3YjksIDB4NGZiNmJlZTEsIDB4YWQxN2YwODgsIDB4YWM2NmM5MjAsIDB4M2FiNDdkY2UsIDB4NGExODYzZGYsIDB4MzE4MmU1MWEsIDB4MzM2MDk3NTEsIDB4N2Y0NTYyNTMsIDB4NzdlMGIxNjQsIDB4YWU4NGJiNmIsIDB4YTAxY2ZlODEsIDB4MmI5NGY5MDgsIDB4Njg1ODcwNDgsIDB4ZmQxOThmNDUsIDB4NmM4Nzk0ZGUsIDB4ZjhiNzUyN2IsIDB4ZDMyM2FiNzMsIDB4MDJlMjcyNGIsIDB4OGY1N2UzMWYsIDB4YWIyYTY2NTUsIDB4MjgwN2IyZWIsIDB4YzIwMzJmYjUsIDB4N2I5YTg2YzUsIDB4MDhhNWQzMzcsIDB4ODdmMjMwMjgsIDB4YTViMjIzYmYsIDB4NmFiYTAyMDMsIDB4ODI1Y2VkMTYsIDB4MWMyYjhhY2YsIDB4YjQ5MmE3NzksIDB4ZjJmMGYzMDcsIDB4ZTJhMTRlNjksIDB4ZjRjZDY1ZGEsIDB4YmVkNTA2MDUsIDB4NjIxZmQxMzQsIDB4ZmU4YWM0YTYsIDB4NTM5ZDM0MmUsIDB4NTVhMGEyZjMsIDB4ZTEzMjA1OGEsIDB4ZWI3NWE0ZjYsIDB4ZWMzOTBiODMsIDB4ZWZhYTQwNjAsIDB4OWYwNjVlNzEsIDB4MTA1MWJkNmUsIDB4OGFmOTNlMjEsIDB4MDYzZDk2ZGQsIDB4MDVhZWRkM2UsIDB4YmQ0NjRkZTYsIDB4OGRiNTkxNTQsIDB4NWQwNTcxYzQsIDB4ZDQ2ZjA0MDYsIDB4MTVmZjYwNTAsIDB4ZmIyNDE5OTgsIDB4ZTk5N2Q2YmQsIDB4NDNjYzg5NDAsIDB4OWU3NzY3ZDksIDB4NDJiZGIwZTgsIDB4OGI4ODA3ODksIDB4NWIzOGU3MTksIDB4ZWVkYjc5YzgsIDB4MGE0N2ExN2MsIDB4MGZlOTdjNDIsIDB4MWVjOWY4ODQsIDB4MDAwMDAwMDAsIDB4ODY4MzA5ODAsIDB4ZWQ0ODMyMmIsIDB4NzBhYzFlMTEsIDB4NzI0ZTZjNWEsIDB4ZmZmYmZkMGUsIDB4Mzg1NjBmODUsIDB4ZDUxZTNkYWUsIDB4MzkyNzM2MmQsIDB4ZDk2NDBhMGYsIDB4YTYyMTY4NWMsIDB4NTRkMTliNWIsIDB4MmUzYTI0MzYsIDB4NjdiMTBjMGEsIDB4ZTcwZjkzNTcsIDB4OTZkMmI0ZWUsIDB4OTE5ZTFiOWIsIDB4YzU0ZjgwYzAsIDB4MjBhMjYxZGMsIDB4NGI2OTVhNzcsIDB4MWExNjFjMTIsIDB4YmEwYWUyOTMsIDB4MmFlNWMwYTAsIDB4ZTA0MzNjMjIsIDB4MTcxZDEyMWIsIDB4MGQwYjBlMDksIDB4YzdhZGYyOGIsIDB4YThiOTJkYjYsIDB4YTljODE0MWUsIDB4MTk4NTU3ZjEsIDB4MDc0Y2FmNzUsIDB4ZGRiYmVlOTksIDB4NjBmZGEzN2YsIDB4MjY5ZmY3MDEsIDB4ZjViYzVjNzIsIDB4M2JjNTQ0NjYsIDB4N2UzNDViZmIsIDB4Mjk3NjhiNDMsIDB4YzZkY2NiMjMsIDB4ZmM2OGI2ZWQsIDB4ZjE2M2I4ZTQsIDB4ZGNjYWQ3MzEsIDB4ODUxMDQyNjMsIDB4MjI0MDEzOTcsIDB4MTEyMDg0YzYsIDB4MjQ3ZDg1NGEsIDB4M2RmOGQyYmIsIDB4MzIxMWFlZjksIDB4YTE2ZGM3MjksIDB4MmY0YjFkOWUsIDB4MzBmM2RjYjIsIDB4NTJlYzBkODYsIDB4ZTNkMDc3YzEsIDB4MTY2YzJiYjMsIDB4Yjk5OWE5NzAsIDB4NDhmYTExOTQsIDB4NjQyMjQ3ZTksIDB4OGNjNGE4ZmMsIDB4M2YxYWEwZjAsIDB4MmNkODU2N2QsIDB4OTBlZjIyMzMsIDB4NGVjNzg3NDksIDB4ZDFjMWQ5MzgsIDB4YTJmZThjY2EsIDB4MGIzNjk4ZDQsIDB4ODFjZmE2ZjUsIDB4ZGUyOGE1N2EsIDB4OGUyNmRhYjcsIDB4YmZhNDNmYWQsIDB4OWRlNDJjM2EsIDB4OTIwZDUwNzgsIDB4Y2M5YjZhNWYsIDB4NDY2MjU0N2UsIDB4MTNjMmY2OGQsIDB4YjhlODkwZDgsIDB4Zjc1ZTJlMzksIDB4YWZmNTgyYzMsIDB4ODBiZTlmNWQsIDB4OTM3YzY5ZDAsIDB4MmRhOTZmZDUsIDB4MTJiM2NmMjUsIDB4OTkzYmM4YWMsIDB4N2RhNzEwMTgsIDB4NjM2ZWU4OWMsIDB4YmI3YmRiM2IsIDB4NzgwOWNkMjYsIDB4MThmNDZlNTksIDB4YjcwMWVjOWEsIDB4OWFhODgzNGYsIDB4NmU2NWU2OTUsIDB4ZTY3ZWFhZmYsIDB4Y2YwODIxYmMsIDB4ZThlNmVmMTUsIDB4OWJkOWJhZTcsIDB4MzZjZTRhNmYsIDB4MDlkNGVhOWYsIDB4N2NkNjI5YjAsIDB4YjJhZjMxYTQsIDB4MjMzMTJhM2YsIDB4OTQzMGM2YTUsIDB4NjZjMDM1YTIsIDB4YmMzNzc0NGUsIDB4Y2FhNmZjODIsIDB4ZDBiMGUwOTAsIDB4ZDgxNTMzYTcsIDB4OTg0YWYxMDQsIDB4ZGFmNzQxZWMsIDB4NTAwZTdmY2QsIDB4ZjYyZjE3OTEsIDB4ZDY4ZDc2NGQsIDB4YjA0ZDQzZWYsIDB4NGQ1NGNjYWEsIDB4MDRkZmU0OTYsIDB4YjVlMzllZDEsIDB4ODgxYjRjNmEsIDB4MWZiOGMxMmMsIDB4NTE3ZjQ2NjUsIDB4ZWEwNDlkNWUsIDB4MzU1ZDAxOGMsIDB4NzQ3M2ZhODcsIDB4NDEyZWZiMGIsIDB4MWQ1YWIzNjcsIDB4ZDI1MjkyZGIsIDB4NTYzM2U5MTAsIDB4NDcxMzZkZDYsIDB4NjE4YzlhZDcsIDB4MGM3YTM3YTEsIDB4MTQ4ZTU5ZjgsIDB4M2M4OWViMTMsIDB4MjdlZWNlYTksIDB4YzkzNWI3NjEsIDB4ZTVlZGUxMWMsIDB4YjEzYzdhNDcsIDB4ZGY1OTljZDIsIDB4NzMzZjU1ZjIsIDB4Y2U3OTE4MTQsIDB4MzdiZjczYzcsIDB4Y2RlYTUzZjcsIDB4YWE1YjVmZmQsIDB4NmYxNGRmM2QsIDB4ZGI4Njc4NDQsIDB4ZjM4MWNhYWYsIDB4YzQzZWI5NjgsIDB4MzQyYzM4MjQsIDB4NDA1ZmMyYTMsIDB4YzM3MjE2MWQsIDB4MjUwY2JjZTIsIDB4NDk4YjI4M2MsIDB4OTU0MWZmMGQsIDB4MDE3MTM5YTgsIDB4YjNkZTA4MGMsIDB4ZTQ5Y2Q4YjQsIDB4YzE5MDY0NTYsIDB4ODQ2MTdiY2IsIDB4YjY3MGQ1MzIsIDB4NWM3NDQ4NmMsIDB4NTc0MmQwYjhdO1xyXG5jb25zdCBUOCA9IFsweGY0YTc1MDUxLCAweDQxNjU1MzdlLCAweDE3YTRjMzFhLCAweDI3NWU5NjNhLCAweGFiNmJjYjNiLCAweDlkNDVmMTFmLCAweGZhNThhYmFjLCAweGUzMDM5MzRiLCAweDMwZmE1NTIwLCAweDc2NmRmNmFkLCAweGNjNzY5MTg4LCAweDAyNGMyNWY1LCAweGU1ZDdmYzRmLCAweDJhY2JkN2M1LCAweDM1NDQ4MDI2LCAweDYyYTM4ZmI1LCAweGIxNWE0OWRlLCAweGJhMWI2NzI1LCAweGVhMGU5ODQ1LCAweGZlYzBlMTVkLCAweDJmNzUwMmMzLCAweDRjZjAxMjgxLCAweDQ2OTdhMzhkLCAweGQzZjljNjZiLCAweDhmNWZlNzAzLCAweDkyOWM5NTE1LCAweDZkN2FlYmJmLCAweDUyNTlkYTk1LCAweGJlODMyZGQ0LCAweDc0MjFkMzU4LCAweGUwNjkyOTQ5LCAweGM5Yzg0NDhlLCAweGMyODk2YTc1LCAweDhlNzk3OGY0LCAweDU4M2U2Yjk5LCAweGI5NzFkZDI3LCAweGUxNGZiNmJlLCAweDg4YWQxN2YwLCAweDIwYWM2NmM5LCAweGNlM2FiNDdkLCAweGRmNGExODYzLCAweDFhMzE4MmU1LCAweDUxMzM2MDk3LCAweDUzN2Y0NTYyLCAweDY0NzdlMGIxLCAweDZiYWU4NGJiLCAweDgxYTAxY2ZlLCAweDA4MmI5NGY5LCAweDQ4Njg1ODcwLCAweDQ1ZmQxOThmLCAweGRlNmM4Nzk0LCAweDdiZjhiNzUyLCAweDczZDMyM2FiLCAweDRiMDJlMjcyLCAweDFmOGY1N2UzLCAweDU1YWIyYTY2LCAweGViMjgwN2IyLCAweGI1YzIwMzJmLCAweGM1N2I5YTg2LCAweDM3MDhhNWQzLCAweDI4ODdmMjMwLCAweGJmYTViMjIzLCAweDAzNmFiYTAyLCAweDE2ODI1Y2VkLCAweGNmMWMyYjhhLCAweDc5YjQ5MmE3LCAweDA3ZjJmMGYzLCAweDY5ZTJhMTRlLCAweGRhZjRjZDY1LCAweDA1YmVkNTA2LCAweDM0NjIxZmQxLCAweGE2ZmU4YWM0LCAweDJlNTM5ZDM0LCAweGYzNTVhMGEyLCAweDhhZTEzMjA1LCAweGY2ZWI3NWE0LCAweDgzZWMzOTBiLCAweDYwZWZhYTQwLCAweDcxOWYwNjVlLCAweDZlMTA1MWJkLCAweDIxOGFmOTNlLCAweGRkMDYzZDk2LCAweDNlMDVhZWRkLCAweGU2YmQ0NjRkLCAweDU0OGRiNTkxLCAweGM0NWQwNTcxLCAweDA2ZDQ2ZjA0LCAweDUwMTVmZjYwLCAweDk4ZmIyNDE5LCAweGJkZTk5N2Q2LCAweDQwNDNjYzg5LCAweGQ5OWU3NzY3LCAweGU4NDJiZGIwLCAweDg5OGI4ODA3LCAweDE5NWIzOGU3LCAweGM4ZWVkYjc5LCAweDdjMGE0N2ExLCAweDQyMGZlOTdjLCAweDg0MWVjOWY4LCAweDAwMDAwMDAwLCAweDgwODY4MzA5LCAweDJiZWQ0ODMyLCAweDExNzBhYzFlLCAweDVhNzI0ZTZjLCAweDBlZmZmYmZkLCAweDg1Mzg1NjBmLCAweGFlZDUxZTNkLCAweDJkMzkyNzM2LCAweDBmZDk2NDBhLCAweDVjYTYyMTY4LCAweDViNTRkMTliLCAweDM2MmUzYTI0LCAweDBhNjdiMTBjLCAweDU3ZTcwZjkzLCAweGVlOTZkMmI0LCAweDliOTE5ZTFiLCAweGMwYzU0ZjgwLCAweGRjMjBhMjYxLCAweDc3NGI2OTVhLCAweDEyMWExNjFjLCAweDkzYmEwYWUyLCAweGEwMmFlNWMwLCAweDIyZTA0MzNjLCAweDFiMTcxZDEyLCAweDA5MGQwYjBlLCAweDhiYzdhZGYyLCAweGI2YThiOTJkLCAweDFlYTljODE0LCAweGYxMTk4NTU3LCAweDc1MDc0Y2FmLCAweDk5ZGRiYmVlLCAweDdmNjBmZGEzLCAweDAxMjY5ZmY3LCAweDcyZjViYzVjLCAweDY2M2JjNTQ0LCAweGZiN2UzNDViLCAweDQzMjk3NjhiLCAweDIzYzZkY2NiLCAweGVkZmM2OGI2LCAweGU0ZjE2M2I4LCAweDMxZGNjYWQ3LCAweDYzODUxMDQyLCAweDk3MjI0MDEzLCAweGM2MTEyMDg0LCAweDRhMjQ3ZDg1LCAweGJiM2RmOGQyLCAweGY5MzIxMWFlLCAweDI5YTE2ZGM3LCAweDllMmY0YjFkLCAweGIyMzBmM2RjLCAweDg2NTJlYzBkLCAweGMxZTNkMDc3LCAweGIzMTY2YzJiLCAweDcwYjk5OWE5LCAweDk0NDhmYTExLCAweGU5NjQyMjQ3LCAweGZjOGNjNGE4LCAweGYwM2YxYWEwLCAweDdkMmNkODU2LCAweDMzOTBlZjIyLCAweDQ5NGVjNzg3LCAweDM4ZDFjMWQ5LCAweGNhYTJmZThjLCAweGQ0MGIzNjk4LCAweGY1ODFjZmE2LCAweDdhZGUyOGE1LCAweGI3OGUyNmRhLCAweGFkYmZhNDNmLCAweDNhOWRlNDJjLCAweDc4OTIwZDUwLCAweDVmY2M5YjZhLCAweDdlNDY2MjU0LCAweDhkMTNjMmY2LCAweGQ4YjhlODkwLCAweDM5Zjc1ZTJlLCAweGMzYWZmNTgyLCAweDVkODBiZTlmLCAweGQwOTM3YzY5LCAweGQ1MmRhOTZmLCAweDI1MTJiM2NmLCAweGFjOTkzYmM4LCAweDE4N2RhNzEwLCAweDljNjM2ZWU4LCAweDNiYmI3YmRiLCAweDI2NzgwOWNkLCAweDU5MThmNDZlLCAweDlhYjcwMWVjLCAweDRmOWFhODgzLCAweDk1NmU2NWU2LCAweGZmZTY3ZWFhLCAweGJjY2YwODIxLCAweDE1ZThlNmVmLCAweGU3OWJkOWJhLCAweDZmMzZjZTRhLCAweDlmMDlkNGVhLCAweGIwN2NkNjI5LCAweGE0YjJhZjMxLCAweDNmMjMzMTJhLCAweGE1OTQzMGM2LCAweGEyNjZjMDM1LCAweDRlYmMzNzc0LCAweDgyY2FhNmZjLCAweDkwZDBiMGUwLCAweGE3ZDgxNTMzLCAweDA0OTg0YWYxLCAweGVjZGFmNzQxLCAweGNkNTAwZTdmLCAweDkxZjYyZjE3LCAweDRkZDY4ZDc2LCAweGVmYjA0ZDQzLCAweGFhNGQ1NGNjLCAweDk2MDRkZmU0LCAweGQxYjVlMzllLCAweDZhODgxYjRjLCAweDJjMWZiOGMxLCAweDY1NTE3ZjQ2LCAweDVlZWEwNDlkLCAweDhjMzU1ZDAxLCAweDg3NzQ3M2ZhLCAweDBiNDEyZWZiLCAweDY3MWQ1YWIzLCAweGRiZDI1MjkyLCAweDEwNTYzM2U5LCAweGQ2NDcxMzZkLCAweGQ3NjE4YzlhLCAweGExMGM3YTM3LCAweGY4MTQ4ZTU5LCAweDEzM2M4OWViLCAweGE5MjdlZWNlLCAweDYxYzkzNWI3LCAweDFjZTVlZGUxLCAweDQ3YjEzYzdhLCAweGQyZGY1OTljLCAweGYyNzMzZjU1LCAweDE0Y2U3OTE4LCAweGM3MzdiZjczLCAweGY3Y2RlYTUzLCAweGZkYWE1YjVmLCAweDNkNmYxNGRmLCAweDQ0ZGI4Njc4LCAweGFmZjM4MWNhLCAweDY4YzQzZWI5LCAweDI0MzQyYzM4LCAweGEzNDA1ZmMyLCAweDFkYzM3MjE2LCAweGUyMjUwY2JjLCAweDNjNDk4YjI4LCAweDBkOTU0MWZmLCAweGE4MDE3MTM5LCAweDBjYjNkZTA4LCAweGI0ZTQ5Y2Q4LCAweDU2YzE5MDY0LCAweGNiODQ2MTdiLCAweDMyYjY3MGQ1LCAweDZjNWM3NDQ4LCAweGI4NTc0MmQwXTtcclxuLy8gVHJhbnNmb3JtYXRpb25zIGZvciBkZWNyeXB0aW9uIGtleSBleHBhbnNpb25cclxuY29uc3QgVTEgPSBbMHgwMDAwMDAwMCwgMHgwZTA5MGQwYiwgMHgxYzEyMWExNiwgMHgxMjFiMTcxZCwgMHgzODI0MzQyYywgMHgzNjJkMzkyNywgMHgyNDM2MmUzYSwgMHgyYTNmMjMzMSwgMHg3MDQ4Njg1OCwgMHg3ZTQxNjU1MywgMHg2YzVhNzI0ZSwgMHg2MjUzN2Y0NSwgMHg0ODZjNWM3NCwgMHg0NjY1NTE3ZiwgMHg1NDdlNDY2MiwgMHg1YTc3NGI2OSwgMHhlMDkwZDBiMCwgMHhlZTk5ZGRiYiwgMHhmYzgyY2FhNiwgMHhmMjhiYzdhZCwgMHhkOGI0ZTQ5YywgMHhkNmJkZTk5NywgMHhjNGE2ZmU4YSwgMHhjYWFmZjM4MSwgMHg5MGQ4YjhlOCwgMHg5ZWQxYjVlMywgMHg4Y2NhYTJmZSwgMHg4MmMzYWZmNSwgMHhhOGZjOGNjNCwgMHhhNmY1ODFjZiwgMHhiNGVlOTZkMiwgMHhiYWU3OWJkOSwgMHhkYjNiYmI3YiwgMHhkNTMyYjY3MCwgMHhjNzI5YTE2ZCwgMHhjOTIwYWM2NiwgMHhlMzFmOGY1NywgMHhlZDE2ODI1YywgMHhmZjBkOTU0MSwgMHhmMTA0OTg0YSwgMHhhYjczZDMyMywgMHhhNTdhZGUyOCwgMHhiNzYxYzkzNSwgMHhiOTY4YzQzZSwgMHg5MzU3ZTcwZiwgMHg5ZDVlZWEwNCwgMHg4ZjQ1ZmQxOSwgMHg4MTRjZjAxMiwgMHgzYmFiNmJjYiwgMHgzNWEyNjZjMCwgMHgyN2I5NzFkZCwgMHgyOWIwN2NkNiwgMHgwMzhmNWZlNywgMHgwZDg2NTJlYywgMHgxZjlkNDVmMSwgMHgxMTk0NDhmYSwgMHg0YmUzMDM5MywgMHg0NWVhMGU5OCwgMHg1N2YxMTk4NSwgMHg1OWY4MTQ4ZSwgMHg3M2M3MzdiZiwgMHg3ZGNlM2FiNCwgMHg2ZmQ1MmRhOSwgMHg2MWRjMjBhMiwgMHhhZDc2NmRmNiwgMHhhMzdmNjBmZCwgMHhiMTY0NzdlMCwgMHhiZjZkN2FlYiwgMHg5NTUyNTlkYSwgMHg5YjViNTRkMSwgMHg4OTQwNDNjYywgMHg4NzQ5NGVjNywgMHhkZDNlMDVhZSwgMHhkMzM3MDhhNSwgMHhjMTJjMWZiOCwgMHhjZjI1MTJiMywgMHhlNTFhMzE4MiwgMHhlYjEzM2M4OSwgMHhmOTA4MmI5NCwgMHhmNzAxMjY5ZiwgMHg0ZGU2YmQ0NiwgMHg0M2VmYjA0ZCwgMHg1MWY0YTc1MCwgMHg1ZmZkYWE1YiwgMHg3NWMyODk2YSwgMHg3YmNiODQ2MSwgMHg2OWQwOTM3YywgMHg2N2Q5OWU3NywgMHgzZGFlZDUxZSwgMHgzM2E3ZDgxNSwgMHgyMWJjY2YwOCwgMHgyZmI1YzIwMywgMHgwNThhZTEzMiwgMHgwYjgzZWMzOSwgMHgxOTk4ZmIyNCwgMHgxNzkxZjYyZiwgMHg3NjRkZDY4ZCwgMHg3ODQ0ZGI4NiwgMHg2YTVmY2M5YiwgMHg2NDU2YzE5MCwgMHg0ZTY5ZTJhMSwgMHg0MDYwZWZhYSwgMHg1MjdiZjhiNywgMHg1YzcyZjViYywgMHgwNjA1YmVkNSwgMHgwODBjYjNkZSwgMHgxYTE3YTRjMywgMHgxNDFlYTljOCwgMHgzZTIxOGFmOSwgMHgzMDI4ODdmMiwgMHgyMjMzOTBlZiwgMHgyYzNhOWRlNCwgMHg5NmRkMDYzZCwgMHg5OGQ0MGIzNiwgMHg4YWNmMWMyYiwgMHg4NGM2MTEyMCwgMHhhZWY5MzIxMSwgMHhhMGYwM2YxYSwgMHhiMmViMjgwNywgMHhiY2UyMjUwYywgMHhlNjk1NmU2NSwgMHhlODljNjM2ZSwgMHhmYTg3NzQ3MywgMHhmNDhlNzk3OCwgMHhkZWIxNWE0OSwgMHhkMGI4NTc0MiwgMHhjMmEzNDA1ZiwgMHhjY2FhNGQ1NCwgMHg0MWVjZGFmNywgMHg0ZmU1ZDdmYywgMHg1ZGZlYzBlMSwgMHg1M2Y3Y2RlYSwgMHg3OWM4ZWVkYiwgMHg3N2MxZTNkMCwgMHg2NWRhZjRjZCwgMHg2YmQzZjljNiwgMHgzMWE0YjJhZiwgMHgzZmFkYmZhNCwgMHgyZGI2YThiOSwgMHgyM2JmYTViMiwgMHgwOTgwODY4MywgMHgwNzg5OGI4OCwgMHgxNTkyOWM5NSwgMHgxYjliOTE5ZSwgMHhhMTdjMGE0NywgMHhhZjc1MDc0YywgMHhiZDZlMTA1MSwgMHhiMzY3MWQ1YSwgMHg5OTU4M2U2YiwgMHg5NzUxMzM2MCwgMHg4NTRhMjQ3ZCwgMHg4YjQzMjk3NiwgMHhkMTM0NjIxZiwgMHhkZjNkNmYxNCwgMHhjZDI2NzgwOSwgMHhjMzJmNzUwMiwgMHhlOTEwNTYzMywgMHhlNzE5NWIzOCwgMHhmNTAyNGMyNSwgMHhmYjBiNDEyZSwgMHg5YWQ3NjE4YywgMHg5NGRlNmM4NywgMHg4NmM1N2I5YSwgMHg4OGNjNzY5MSwgMHhhMmYzNTVhMCwgMHhhY2ZhNThhYiwgMHhiZWUxNGZiNiwgMHhiMGU4NDJiZCwgMHhlYTlmMDlkNCwgMHhlNDk2MDRkZiwgMHhmNjhkMTNjMiwgMHhmODg0MWVjOSwgMHhkMmJiM2RmOCwgMHhkY2IyMzBmMywgMHhjZWE5MjdlZSwgMHhjMGEwMmFlNSwgMHg3YTQ3YjEzYywgMHg3NDRlYmMzNywgMHg2NjU1YWIyYSwgMHg2ODVjYTYyMSwgMHg0MjYzODUxMCwgMHg0YzZhODgxYiwgMHg1ZTcxOWYwNiwgMHg1MDc4OTIwZCwgMHgwYTBmZDk2NCwgMHgwNDA2ZDQ2ZiwgMHgxNjFkYzM3MiwgMHgxODE0Y2U3OSwgMHgzMjJiZWQ0OCwgMHgzYzIyZTA0MywgMHgyZTM5Zjc1ZSwgMHgyMDMwZmE1NSwgMHhlYzlhYjcwMSwgMHhlMjkzYmEwYSwgMHhmMDg4YWQxNywgMHhmZTgxYTAxYywgMHhkNGJlODMyZCwgMHhkYWI3OGUyNiwgMHhjOGFjOTkzYiwgMHhjNmE1OTQzMCwgMHg5Y2QyZGY1OSwgMHg5MmRiZDI1MiwgMHg4MGMwYzU0ZiwgMHg4ZWM5Yzg0NCwgMHhhNGY2ZWI3NSwgMHhhYWZmZTY3ZSwgMHhiOGU0ZjE2MywgMHhiNmVkZmM2OCwgMHgwYzBhNjdiMSwgMHgwMjAzNmFiYSwgMHgxMDE4N2RhNywgMHgxZTExNzBhYywgMHgzNDJlNTM5ZCwgMHgzYTI3NWU5NiwgMHgyODNjNDk4YiwgMHgyNjM1NDQ4MCwgMHg3YzQyMGZlOSwgMHg3MjRiMDJlMiwgMHg2MDUwMTVmZiwgMHg2ZTU5MThmNCwgMHg0NDY2M2JjNSwgMHg0YTZmMzZjZSwgMHg1ODc0MjFkMywgMHg1NjdkMmNkOCwgMHgzN2ExMGM3YSwgMHgzOWE4MDE3MSwgMHgyYmIzMTY2YywgMHgyNWJhMWI2NywgMHgwZjg1Mzg1NiwgMHgwMThjMzU1ZCwgMHgxMzk3MjI0MCwgMHgxZDllMmY0YiwgMHg0N2U5NjQyMiwgMHg0OWUwNjkyOSwgMHg1YmZiN2UzNCwgMHg1NWYyNzMzZiwgMHg3ZmNkNTAwZSwgMHg3MWM0NWQwNSwgMHg2M2RmNGExOCwgMHg2ZGQ2NDcxMywgMHhkNzMxZGNjYSwgMHhkOTM4ZDFjMSwgMHhjYjIzYzZkYywgMHhjNTJhY2JkNywgMHhlZjE1ZThlNiwgMHhlMTFjZTVlZCwgMHhmMzA3ZjJmMCwgMHhmZDBlZmZmYiwgMHhhNzc5YjQ5MiwgMHhhOTcwYjk5OSwgMHhiYjZiYWU4NCwgMHhiNTYyYTM4ZiwgMHg5ZjVkODBiZSwgMHg5MTU0OGRiNSwgMHg4MzRmOWFhOCwgMHg4ZDQ2OTdhM107XHJcbmNvbnN0IFUyID0gWzB4MDAwMDAwMDAsIDB4MGIwZTA5MGQsIDB4MTYxYzEyMWEsIDB4MWQxMjFiMTcsIDB4MmMzODI0MzQsIDB4MjczNjJkMzksIDB4M2EyNDM2MmUsIDB4MzEyYTNmMjMsIDB4NTg3MDQ4NjgsIDB4NTM3ZTQxNjUsIDB4NGU2YzVhNzIsIDB4NDU2MjUzN2YsIDB4NzQ0ODZjNWMsIDB4N2Y0NjY1NTEsIDB4NjI1NDdlNDYsIDB4Njk1YTc3NGIsIDB4YjBlMDkwZDAsIDB4YmJlZTk5ZGQsIDB4YTZmYzgyY2EsIDB4YWRmMjhiYzcsIDB4OWNkOGI0ZTQsIDB4OTdkNmJkZTksIDB4OGFjNGE2ZmUsIDB4ODFjYWFmZjMsIDB4ZTg5MGQ4YjgsIDB4ZTM5ZWQxYjUsIDB4ZmU4Y2NhYTIsIDB4ZjU4MmMzYWYsIDB4YzRhOGZjOGMsIDB4Y2ZhNmY1ODEsIDB4ZDJiNGVlOTYsIDB4ZDliYWU3OWIsIDB4N2JkYjNiYmIsIDB4NzBkNTMyYjYsIDB4NmRjNzI5YTEsIDB4NjZjOTIwYWMsIDB4NTdlMzFmOGYsIDB4NWNlZDE2ODIsIDB4NDFmZjBkOTUsIDB4NGFmMTA0OTgsIDB4MjNhYjczZDMsIDB4MjhhNTdhZGUsIDB4MzViNzYxYzksIDB4M2ViOTY4YzQsIDB4MGY5MzU3ZTcsIDB4MDQ5ZDVlZWEsIDB4MTk4ZjQ1ZmQsIDB4MTI4MTRjZjAsIDB4Y2IzYmFiNmIsIDB4YzAzNWEyNjYsIDB4ZGQyN2I5NzEsIDB4ZDYyOWIwN2MsIDB4ZTcwMzhmNWYsIDB4ZWMwZDg2NTIsIDB4ZjExZjlkNDUsIDB4ZmExMTk0NDgsIDB4OTM0YmUzMDMsIDB4OTg0NWVhMGUsIDB4ODU1N2YxMTksIDB4OGU1OWY4MTQsIDB4YmY3M2M3MzcsIDB4YjQ3ZGNlM2EsIDB4YTk2ZmQ1MmQsIDB4YTI2MWRjMjAsIDB4ZjZhZDc2NmQsIDB4ZmRhMzdmNjAsIDB4ZTBiMTY0NzcsIDB4ZWJiZjZkN2EsIDB4ZGE5NTUyNTksIDB4ZDE5YjViNTQsIDB4Y2M4OTQwNDMsIDB4Yzc4NzQ5NGUsIDB4YWVkZDNlMDUsIDB4YTVkMzM3MDgsIDB4YjhjMTJjMWYsIDB4YjNjZjI1MTIsIDB4ODJlNTFhMzEsIDB4ODllYjEzM2MsIDB4OTRmOTA4MmIsIDB4OWZmNzAxMjYsIDB4NDY0ZGU2YmQsIDB4NGQ0M2VmYjAsIDB4NTA1MWY0YTcsIDB4NWI1ZmZkYWEsIDB4NmE3NWMyODksIDB4NjE3YmNiODQsIDB4N2M2OWQwOTMsIDB4Nzc2N2Q5OWUsIDB4MWUzZGFlZDUsIDB4MTUzM2E3ZDgsIDB4MDgyMWJjY2YsIDB4MDMyZmI1YzIsIDB4MzIwNThhZTEsIDB4MzkwYjgzZWMsIDB4MjQxOTk4ZmIsIDB4MmYxNzkxZjYsIDB4OGQ3NjRkZDYsIDB4ODY3ODQ0ZGIsIDB4OWI2YTVmY2MsIDB4OTA2NDU2YzEsIDB4YTE0ZTY5ZTIsIDB4YWE0MDYwZWYsIDB4Yjc1MjdiZjgsIDB4YmM1YzcyZjUsIDB4ZDUwNjA1YmUsIDB4ZGUwODBjYjMsIDB4YzMxYTE3YTQsIDB4YzgxNDFlYTksIDB4ZjkzZTIxOGEsIDB4ZjIzMDI4ODcsIDB4ZWYyMjMzOTAsIDB4ZTQyYzNhOWQsIDB4M2Q5NmRkMDYsIDB4MzY5OGQ0MGIsIDB4MmI4YWNmMWMsIDB4MjA4NGM2MTEsIDB4MTFhZWY5MzIsIDB4MWFhMGYwM2YsIDB4MDdiMmViMjgsIDB4MGNiY2UyMjUsIDB4NjVlNjk1NmUsIDB4NmVlODljNjMsIDB4NzNmYTg3NzQsIDB4NzhmNDhlNzksIDB4NDlkZWIxNWEsIDB4NDJkMGI4NTcsIDB4NWZjMmEzNDAsIDB4NTRjY2FhNGQsIDB4Zjc0MWVjZGEsIDB4ZmM0ZmU1ZDcsIDB4ZTE1ZGZlYzAsIDB4ZWE1M2Y3Y2QsIDB4ZGI3OWM4ZWUsIDB4ZDA3N2MxZTMsIDB4Y2Q2NWRhZjQsIDB4YzY2YmQzZjksIDB4YWYzMWE0YjIsIDB4YTQzZmFkYmYsIDB4YjkyZGI2YTgsIDB4YjIyM2JmYTUsIDB4ODMwOTgwODYsIDB4ODgwNzg5OGIsIDB4OTUxNTkyOWMsIDB4OWUxYjliOTEsIDB4NDdhMTdjMGEsIDB4NGNhZjc1MDcsIDB4NTFiZDZlMTAsIDB4NWFiMzY3MWQsIDB4NmI5OTU4M2UsIDB4NjA5NzUxMzMsIDB4N2Q4NTRhMjQsIDB4NzY4YjQzMjksIDB4MWZkMTM0NjIsIDB4MTRkZjNkNmYsIDB4MDljZDI2NzgsIDB4MDJjMzJmNzUsIDB4MzNlOTEwNTYsIDB4MzhlNzE5NWIsIDB4MjVmNTAyNGMsIDB4MmVmYjBiNDEsIDB4OGM5YWQ3NjEsIDB4ODc5NGRlNmMsIDB4OWE4NmM1N2IsIDB4OTE4OGNjNzYsIDB4YTBhMmYzNTUsIDB4YWJhY2ZhNTgsIDB4YjZiZWUxNGYsIDB4YmRiMGU4NDIsIDB4ZDRlYTlmMDksIDB4ZGZlNDk2MDQsIDB4YzJmNjhkMTMsIDB4YzlmODg0MWUsIDB4ZjhkMmJiM2QsIDB4ZjNkY2IyMzAsIDB4ZWVjZWE5MjcsIDB4ZTVjMGEwMmEsIDB4M2M3YTQ3YjEsIDB4Mzc3NDRlYmMsIDB4MmE2NjU1YWIsIDB4MjE2ODVjYTYsIDB4MTA0MjYzODUsIDB4MWI0YzZhODgsIDB4MDY1ZTcxOWYsIDB4MGQ1MDc4OTIsIDB4NjQwYTBmZDksIDB4NmYwNDA2ZDQsIDB4NzIxNjFkYzMsIDB4NzkxODE0Y2UsIDB4NDgzMjJiZWQsIDB4NDMzYzIyZTAsIDB4NWUyZTM5ZjcsIDB4NTUyMDMwZmEsIDB4MDFlYzlhYjcsIDB4MGFlMjkzYmEsIDB4MTdmMDg4YWQsIDB4MWNmZTgxYTAsIDB4MmRkNGJlODMsIDB4MjZkYWI3OGUsIDB4M2JjOGFjOTksIDB4MzBjNmE1OTQsIDB4NTk5Y2QyZGYsIDB4NTI5MmRiZDIsIDB4NGY4MGMwYzUsIDB4NDQ4ZWM5YzgsIDB4NzVhNGY2ZWIsIDB4N2VhYWZmZTYsIDB4NjNiOGU0ZjEsIDB4NjhiNmVkZmMsIDB4YjEwYzBhNjcsIDB4YmEwMjAzNmEsIDB4YTcxMDE4N2QsIDB4YWMxZTExNzAsIDB4OWQzNDJlNTMsIDB4OTYzYTI3NWUsIDB4OGIyODNjNDksIDB4ODAyNjM1NDQsIDB4ZTk3YzQyMGYsIDB4ZTI3MjRiMDIsIDB4ZmY2MDUwMTUsIDB4ZjQ2ZTU5MTgsIDB4YzU0NDY2M2IsIDB4Y2U0YTZmMzYsIDB4ZDM1ODc0MjEsIDB4ZDg1NjdkMmMsIDB4N2EzN2ExMGMsIDB4NzEzOWE4MDEsIDB4NmMyYmIzMTYsIDB4NjcyNWJhMWIsIDB4NTYwZjg1MzgsIDB4NWQwMThjMzUsIDB4NDAxMzk3MjIsIDB4NGIxZDllMmYsIDB4MjI0N2U5NjQsIDB4Mjk0OWUwNjksIDB4MzQ1YmZiN2UsIDB4M2Y1NWYyNzMsIDB4MGU3ZmNkNTAsIDB4MDU3MWM0NWQsIDB4MTg2M2RmNGEsIDB4MTM2ZGQ2NDcsIDB4Y2FkNzMxZGMsIDB4YzFkOTM4ZDEsIDB4ZGNjYjIzYzYsIDB4ZDdjNTJhY2IsIDB4ZTZlZjE1ZTgsIDB4ZWRlMTFjZTUsIDB4ZjBmMzA3ZjIsIDB4ZmJmZDBlZmYsIDB4OTJhNzc5YjQsIDB4OTlhOTcwYjksIDB4ODRiYjZiYWUsIDB4OGZiNTYyYTMsIDB4YmU5ZjVkODAsIDB4YjU5MTU0OGQsIDB4YTg4MzRmOWEsIDB4YTM4ZDQ2OTddO1xyXG5jb25zdCBVMyA9IFsweDAwMDAwMDAwLCAweDBkMGIwZTA5LCAweDFhMTYxYzEyLCAweDE3MWQxMjFiLCAweDM0MmMzODI0LCAweDM5MjczNjJkLCAweDJlM2EyNDM2LCAweDIzMzEyYTNmLCAweDY4NTg3MDQ4LCAweDY1NTM3ZTQxLCAweDcyNGU2YzVhLCAweDdmNDU2MjUzLCAweDVjNzQ0ODZjLCAweDUxN2Y0NjY1LCAweDQ2NjI1NDdlLCAweDRiNjk1YTc3LCAweGQwYjBlMDkwLCAweGRkYmJlZTk5LCAweGNhYTZmYzgyLCAweGM3YWRmMjhiLCAweGU0OWNkOGI0LCAweGU5OTdkNmJkLCAweGZlOGFjNGE2LCAweGYzODFjYWFmLCAweGI4ZTg5MGQ4LCAweGI1ZTM5ZWQxLCAweGEyZmU4Y2NhLCAweGFmZjU4MmMzLCAweDhjYzRhOGZjLCAweDgxY2ZhNmY1LCAweDk2ZDJiNGVlLCAweDliZDliYWU3LCAweGJiN2JkYjNiLCAweGI2NzBkNTMyLCAweGExNmRjNzI5LCAweGFjNjZjOTIwLCAweDhmNTdlMzFmLCAweDgyNWNlZDE2LCAweDk1NDFmZjBkLCAweDk4NGFmMTA0LCAweGQzMjNhYjczLCAweGRlMjhhNTdhLCAweGM5MzViNzYxLCAweGM0M2ViOTY4LCAweGU3MGY5MzU3LCAweGVhMDQ5ZDVlLCAweGZkMTk4ZjQ1LCAweGYwMTI4MTRjLCAweDZiY2IzYmFiLCAweDY2YzAzNWEyLCAweDcxZGQyN2I5LCAweDdjZDYyOWIwLCAweDVmZTcwMzhmLCAweDUyZWMwZDg2LCAweDQ1ZjExZjlkLCAweDQ4ZmExMTk0LCAweDAzOTM0YmUzLCAweDBlOTg0NWVhLCAweDE5ODU1N2YxLCAweDE0OGU1OWY4LCAweDM3YmY3M2M3LCAweDNhYjQ3ZGNlLCAweDJkYTk2ZmQ1LCAweDIwYTI2MWRjLCAweDZkZjZhZDc2LCAweDYwZmRhMzdmLCAweDc3ZTBiMTY0LCAweDdhZWJiZjZkLCAweDU5ZGE5NTUyLCAweDU0ZDE5YjViLCAweDQzY2M4OTQwLCAweDRlYzc4NzQ5LCAweDA1YWVkZDNlLCAweDA4YTVkMzM3LCAweDFmYjhjMTJjLCAweDEyYjNjZjI1LCAweDMxODJlNTFhLCAweDNjODllYjEzLCAweDJiOTRmOTA4LCAweDI2OWZmNzAxLCAweGJkNDY0ZGU2LCAweGIwNGQ0M2VmLCAweGE3NTA1MWY0LCAweGFhNWI1ZmZkLCAweDg5NmE3NWMyLCAweDg0NjE3YmNiLCAweDkzN2M2OWQwLCAweDllNzc2N2Q5LCAweGQ1MWUzZGFlLCAweGQ4MTUzM2E3LCAweGNmMDgyMWJjLCAweGMyMDMyZmI1LCAweGUxMzIwNThhLCAweGVjMzkwYjgzLCAweGZiMjQxOTk4LCAweGY2MmYxNzkxLCAweGQ2OGQ3NjRkLCAweGRiODY3ODQ0LCAweGNjOWI2YTVmLCAweGMxOTA2NDU2LCAweGUyYTE0ZTY5LCAweGVmYWE0MDYwLCAweGY4Yjc1MjdiLCAweGY1YmM1YzcyLCAweGJlZDUwNjA1LCAweGIzZGUwODBjLCAweGE0YzMxYTE3LCAweGE5YzgxNDFlLCAweDhhZjkzZTIxLCAweDg3ZjIzMDI4LCAweDkwZWYyMjMzLCAweDlkZTQyYzNhLCAweDA2M2Q5NmRkLCAweDBiMzY5OGQ0LCAweDFjMmI4YWNmLCAweDExMjA4NGM2LCAweDMyMTFhZWY5LCAweDNmMWFhMGYwLCAweDI4MDdiMmViLCAweDI1MGNiY2UyLCAweDZlNjVlNjk1LCAweDYzNmVlODljLCAweDc0NzNmYTg3LCAweDc5NzhmNDhlLCAweDVhNDlkZWIxLCAweDU3NDJkMGI4LCAweDQwNWZjMmEzLCAweDRkNTRjY2FhLCAweGRhZjc0MWVjLCAweGQ3ZmM0ZmU1LCAweGMwZTE1ZGZlLCAweGNkZWE1M2Y3LCAweGVlZGI3OWM4LCAweGUzZDA3N2MxLCAweGY0Y2Q2NWRhLCAweGY5YzY2YmQzLCAweGIyYWYzMWE0LCAweGJmYTQzZmFkLCAweGE4YjkyZGI2LCAweGE1YjIyM2JmLCAweDg2ODMwOTgwLCAweDhiODgwNzg5LCAweDljOTUxNTkyLCAweDkxOWUxYjliLCAweDBhNDdhMTdjLCAweDA3NGNhZjc1LCAweDEwNTFiZDZlLCAweDFkNWFiMzY3LCAweDNlNmI5OTU4LCAweDMzNjA5NzUxLCAweDI0N2Q4NTRhLCAweDI5NzY4YjQzLCAweDYyMWZkMTM0LCAweDZmMTRkZjNkLCAweDc4MDljZDI2LCAweDc1MDJjMzJmLCAweDU2MzNlOTEwLCAweDViMzhlNzE5LCAweDRjMjVmNTAyLCAweDQxMmVmYjBiLCAweDYxOGM5YWQ3LCAweDZjODc5NGRlLCAweDdiOWE4NmM1LCAweDc2OTE4OGNjLCAweDU1YTBhMmYzLCAweDU4YWJhY2ZhLCAweDRmYjZiZWUxLCAweDQyYmRiMGU4LCAweDA5ZDRlYTlmLCAweDA0ZGZlNDk2LCAweDEzYzJmNjhkLCAweDFlYzlmODg0LCAweDNkZjhkMmJiLCAweDMwZjNkY2IyLCAweDI3ZWVjZWE5LCAweDJhZTVjMGEwLCAweGIxM2M3YTQ3LCAweGJjMzc3NDRlLCAweGFiMmE2NjU1LCAweGE2MjE2ODVjLCAweDg1MTA0MjYzLCAweDg4MWI0YzZhLCAweDlmMDY1ZTcxLCAweDkyMGQ1MDc4LCAweGQ5NjQwYTBmLCAweGQ0NmYwNDA2LCAweGMzNzIxNjFkLCAweGNlNzkxODE0LCAweGVkNDgzMjJiLCAweGUwNDMzYzIyLCAweGY3NWUyZTM5LCAweGZhNTUyMDMwLCAweGI3MDFlYzlhLCAweGJhMGFlMjkzLCAweGFkMTdmMDg4LCAweGEwMWNmZTgxLCAweDgzMmRkNGJlLCAweDhlMjZkYWI3LCAweDk5M2JjOGFjLCAweDk0MzBjNmE1LCAweGRmNTk5Y2QyLCAweGQyNTI5MmRiLCAweGM1NGY4MGMwLCAweGM4NDQ4ZWM5LCAweGViNzVhNGY2LCAweGU2N2VhYWZmLCAweGYxNjNiOGU0LCAweGZjNjhiNmVkLCAweDY3YjEwYzBhLCAweDZhYmEwMjAzLCAweDdkYTcxMDE4LCAweDcwYWMxZTExLCAweDUzOWQzNDJlLCAweDVlOTYzYTI3LCAweDQ5OGIyODNjLCAweDQ0ODAyNjM1LCAweDBmZTk3YzQyLCAweDAyZTI3MjRiLCAweDE1ZmY2MDUwLCAweDE4ZjQ2ZTU5LCAweDNiYzU0NDY2LCAweDM2Y2U0YTZmLCAweDIxZDM1ODc0LCAweDJjZDg1NjdkLCAweDBjN2EzN2ExLCAweDAxNzEzOWE4LCAweDE2NmMyYmIzLCAweDFiNjcyNWJhLCAweDM4NTYwZjg1LCAweDM1NWQwMThjLCAweDIyNDAxMzk3LCAweDJmNGIxZDllLCAweDY0MjI0N2U5LCAweDY5Mjk0OWUwLCAweDdlMzQ1YmZiLCAweDczM2Y1NWYyLCAweDUwMGU3ZmNkLCAweDVkMDU3MWM0LCAweDRhMTg2M2RmLCAweDQ3MTM2ZGQ2LCAweGRjY2FkNzMxLCAweGQxYzFkOTM4LCAweGM2ZGNjYjIzLCAweGNiZDdjNTJhLCAweGU4ZTZlZjE1LCAweGU1ZWRlMTFjLCAweGYyZjBmMzA3LCAweGZmZmJmZDBlLCAweGI0OTJhNzc5LCAweGI5OTlhOTcwLCAweGFlODRiYjZiLCAweGEzOGZiNTYyLCAweDgwYmU5ZjVkLCAweDhkYjU5MTU0LCAweDlhYTg4MzRmLCAweDk3YTM4ZDQ2XTtcclxuY29uc3QgVTQgPSBbMHgwMDAwMDAwMCwgMHgwOTBkMGIwZSwgMHgxMjFhMTYxYywgMHgxYjE3MWQxMiwgMHgyNDM0MmMzOCwgMHgyZDM5MjczNiwgMHgzNjJlM2EyNCwgMHgzZjIzMzEyYSwgMHg0ODY4NTg3MCwgMHg0MTY1NTM3ZSwgMHg1YTcyNGU2YywgMHg1MzdmNDU2MiwgMHg2YzVjNzQ0OCwgMHg2NTUxN2Y0NiwgMHg3ZTQ2NjI1NCwgMHg3NzRiNjk1YSwgMHg5MGQwYjBlMCwgMHg5OWRkYmJlZSwgMHg4MmNhYTZmYywgMHg4YmM3YWRmMiwgMHhiNGU0OWNkOCwgMHhiZGU5OTdkNiwgMHhhNmZlOGFjNCwgMHhhZmYzODFjYSwgMHhkOGI4ZTg5MCwgMHhkMWI1ZTM5ZSwgMHhjYWEyZmU4YywgMHhjM2FmZjU4MiwgMHhmYzhjYzRhOCwgMHhmNTgxY2ZhNiwgMHhlZTk2ZDJiNCwgMHhlNzliZDliYSwgMHgzYmJiN2JkYiwgMHgzMmI2NzBkNSwgMHgyOWExNmRjNywgMHgyMGFjNjZjOSwgMHgxZjhmNTdlMywgMHgxNjgyNWNlZCwgMHgwZDk1NDFmZiwgMHgwNDk4NGFmMSwgMHg3M2QzMjNhYiwgMHg3YWRlMjhhNSwgMHg2MWM5MzViNywgMHg2OGM0M2ViOSwgMHg1N2U3MGY5MywgMHg1ZWVhMDQ5ZCwgMHg0NWZkMTk4ZiwgMHg0Y2YwMTI4MSwgMHhhYjZiY2IzYiwgMHhhMjY2YzAzNSwgMHhiOTcxZGQyNywgMHhiMDdjZDYyOSwgMHg4ZjVmZTcwMywgMHg4NjUyZWMwZCwgMHg5ZDQ1ZjExZiwgMHg5NDQ4ZmExMSwgMHhlMzAzOTM0YiwgMHhlYTBlOTg0NSwgMHhmMTE5ODU1NywgMHhmODE0OGU1OSwgMHhjNzM3YmY3MywgMHhjZTNhYjQ3ZCwgMHhkNTJkYTk2ZiwgMHhkYzIwYTI2MSwgMHg3NjZkZjZhZCwgMHg3ZjYwZmRhMywgMHg2NDc3ZTBiMSwgMHg2ZDdhZWJiZiwgMHg1MjU5ZGE5NSwgMHg1YjU0ZDE5YiwgMHg0MDQzY2M4OSwgMHg0OTRlYzc4NywgMHgzZTA1YWVkZCwgMHgzNzA4YTVkMywgMHgyYzFmYjhjMSwgMHgyNTEyYjNjZiwgMHgxYTMxODJlNSwgMHgxMzNjODllYiwgMHgwODJiOTRmOSwgMHgwMTI2OWZmNywgMHhlNmJkNDY0ZCwgMHhlZmIwNGQ0MywgMHhmNGE3NTA1MSwgMHhmZGFhNWI1ZiwgMHhjMjg5NmE3NSwgMHhjYjg0NjE3YiwgMHhkMDkzN2M2OSwgMHhkOTllNzc2NywgMHhhZWQ1MWUzZCwgMHhhN2Q4MTUzMywgMHhiY2NmMDgyMSwgMHhiNWMyMDMyZiwgMHg4YWUxMzIwNSwgMHg4M2VjMzkwYiwgMHg5OGZiMjQxOSwgMHg5MWY2MmYxNywgMHg0ZGQ2OGQ3NiwgMHg0NGRiODY3OCwgMHg1ZmNjOWI2YSwgMHg1NmMxOTA2NCwgMHg2OWUyYTE0ZSwgMHg2MGVmYWE0MCwgMHg3YmY4Yjc1MiwgMHg3MmY1YmM1YywgMHgwNWJlZDUwNiwgMHgwY2IzZGUwOCwgMHgxN2E0YzMxYSwgMHgxZWE5YzgxNCwgMHgyMThhZjkzZSwgMHgyODg3ZjIzMCwgMHgzMzkwZWYyMiwgMHgzYTlkZTQyYywgMHhkZDA2M2Q5NiwgMHhkNDBiMzY5OCwgMHhjZjFjMmI4YSwgMHhjNjExMjA4NCwgMHhmOTMyMTFhZSwgMHhmMDNmMWFhMCwgMHhlYjI4MDdiMiwgMHhlMjI1MGNiYywgMHg5NTZlNjVlNiwgMHg5YzYzNmVlOCwgMHg4Nzc0NzNmYSwgMHg4ZTc5NzhmNCwgMHhiMTVhNDlkZSwgMHhiODU3NDJkMCwgMHhhMzQwNWZjMiwgMHhhYTRkNTRjYywgMHhlY2RhZjc0MSwgMHhlNWQ3ZmM0ZiwgMHhmZWMwZTE1ZCwgMHhmN2NkZWE1MywgMHhjOGVlZGI3OSwgMHhjMWUzZDA3NywgMHhkYWY0Y2Q2NSwgMHhkM2Y5YzY2YiwgMHhhNGIyYWYzMSwgMHhhZGJmYTQzZiwgMHhiNmE4YjkyZCwgMHhiZmE1YjIyMywgMHg4MDg2ODMwOSwgMHg4OThiODgwNywgMHg5MjljOTUxNSwgMHg5YjkxOWUxYiwgMHg3YzBhNDdhMSwgMHg3NTA3NGNhZiwgMHg2ZTEwNTFiZCwgMHg2NzFkNWFiMywgMHg1ODNlNmI5OSwgMHg1MTMzNjA5NywgMHg0YTI0N2Q4NSwgMHg0MzI5NzY4YiwgMHgzNDYyMWZkMSwgMHgzZDZmMTRkZiwgMHgyNjc4MDljZCwgMHgyZjc1MDJjMywgMHgxMDU2MzNlOSwgMHgxOTViMzhlNywgMHgwMjRjMjVmNSwgMHgwYjQxMmVmYiwgMHhkNzYxOGM5YSwgMHhkZTZjODc5NCwgMHhjNTdiOWE4NiwgMHhjYzc2OTE4OCwgMHhmMzU1YTBhMiwgMHhmYTU4YWJhYywgMHhlMTRmYjZiZSwgMHhlODQyYmRiMCwgMHg5ZjA5ZDRlYSwgMHg5NjA0ZGZlNCwgMHg4ZDEzYzJmNiwgMHg4NDFlYzlmOCwgMHhiYjNkZjhkMiwgMHhiMjMwZjNkYywgMHhhOTI3ZWVjZSwgMHhhMDJhZTVjMCwgMHg0N2IxM2M3YSwgMHg0ZWJjMzc3NCwgMHg1NWFiMmE2NiwgMHg1Y2E2MjE2OCwgMHg2Mzg1MTA0MiwgMHg2YTg4MWI0YywgMHg3MTlmMDY1ZSwgMHg3ODkyMGQ1MCwgMHgwZmQ5NjQwYSwgMHgwNmQ0NmYwNCwgMHgxZGMzNzIxNiwgMHgxNGNlNzkxOCwgMHgyYmVkNDgzMiwgMHgyMmUwNDMzYywgMHgzOWY3NWUyZSwgMHgzMGZhNTUyMCwgMHg5YWI3MDFlYywgMHg5M2JhMGFlMiwgMHg4OGFkMTdmMCwgMHg4MWEwMWNmZSwgMHhiZTgzMmRkNCwgMHhiNzhlMjZkYSwgMHhhYzk5M2JjOCwgMHhhNTk0MzBjNiwgMHhkMmRmNTk5YywgMHhkYmQyNTI5MiwgMHhjMGM1NGY4MCwgMHhjOWM4NDQ4ZSwgMHhmNmViNzVhNCwgMHhmZmU2N2VhYSwgMHhlNGYxNjNiOCwgMHhlZGZjNjhiNiwgMHgwYTY3YjEwYywgMHgwMzZhYmEwMiwgMHgxODdkYTcxMCwgMHgxMTcwYWMxZSwgMHgyZTUzOWQzNCwgMHgyNzVlOTYzYSwgMHgzYzQ5OGIyOCwgMHgzNTQ0ODAyNiwgMHg0MjBmZTk3YywgMHg0YjAyZTI3MiwgMHg1MDE1ZmY2MCwgMHg1OTE4ZjQ2ZSwgMHg2NjNiYzU0NCwgMHg2ZjM2Y2U0YSwgMHg3NDIxZDM1OCwgMHg3ZDJjZDg1NiwgMHhhMTBjN2EzNywgMHhhODAxNzEzOSwgMHhiMzE2NmMyYiwgMHhiYTFiNjcyNSwgMHg4NTM4NTYwZiwgMHg4YzM1NWQwMSwgMHg5NzIyNDAxMywgMHg5ZTJmNGIxZCwgMHhlOTY0MjI0NywgMHhlMDY5Mjk0OSwgMHhmYjdlMzQ1YiwgMHhmMjczM2Y1NSwgMHhjZDUwMGU3ZiwgMHhjNDVkMDU3MSwgMHhkZjRhMTg2MywgMHhkNjQ3MTM2ZCwgMHgzMWRjY2FkNywgMHgzOGQxYzFkOSwgMHgyM2M2ZGNjYiwgMHgyYWNiZDdjNSwgMHgxNWU4ZTZlZiwgMHgxY2U1ZWRlMSwgMHgwN2YyZjBmMywgMHgwZWZmZmJmZCwgMHg3OWI0OTJhNywgMHg3MGI5OTlhOSwgMHg2YmFlODRiYiwgMHg2MmEzOGZiNSwgMHg1ZDgwYmU5ZiwgMHg1NDhkYjU5MSwgMHg0ZjlhYTg4MywgMHg0Njk3YTM4ZF07XHJcbmZ1bmN0aW9uIGNvbnZlcnRUb0ludDMyKGJ5dGVzKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDQpIHtcclxuICAgICAgICByZXN1bHQucHVzaCgoYnl0ZXNbaV0gPDwgMjQpIHwgKGJ5dGVzW2kgKyAxXSA8PCAxNikgfCAoYnl0ZXNbaSArIDJdIDw8IDgpIHwgYnl0ZXNbaSArIDNdKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZXhwb3J0IGNsYXNzIEFFUyB7XHJcbiAgICBnZXQga2V5KCkgeyByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX2tleSwgXCJmXCIpLnNsaWNlKCk7IH1cclxuICAgIGNvbnN0cnVjdG9yKGtleSkge1xyXG4gICAgICAgIF9BRVNfa2V5LnNldCh0aGlzLCB2b2lkIDApO1xyXG4gICAgICAgIF9BRVNfS2Quc2V0KHRoaXMsIHZvaWQgMCk7XHJcbiAgICAgICAgX0FFU19LZS5zZXQodGhpcywgdm9pZCAwKTtcclxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQUVTKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQUVTX2tleSwgbmV3IFVpbnQ4QXJyYXkoa2V5KSwgXCJmXCIpO1xyXG4gICAgICAgIGNvbnN0IHJvdW5kcyA9IG51bWJlck9mUm91bmRzW3RoaXMua2V5Lmxlbmd0aF07XHJcbiAgICAgICAgaWYgKHJvdW5kcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQga2V5IHNpemUgKG11c3QgYmUgMTYsIDI0IG9yIDMyIGJ5dGVzKScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBlbmNyeXB0aW9uIHJvdW5kIGtleXNcclxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9BRVNfS2UsIFtdLCBcImZcIik7XHJcbiAgICAgICAgLy8gZGVjcnlwdGlvbiByb3VuZCBrZXlzXHJcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQUVTX0tkLCBbXSwgXCJmXCIpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHJvdW5kczsgaSsrKSB7XHJcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZSwgXCJmXCIpLnB1c2goWzAsIDAsIDAsIDBdKTtcclxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIikucHVzaChbMCwgMCwgMCwgMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByb3VuZEtleUNvdW50ID0gKHJvdW5kcyArIDEpICogNDtcclxuICAgICAgICBjb25zdCBLQyA9IHRoaXMua2V5Lmxlbmd0aCAvIDQ7XHJcbiAgICAgICAgLy8gY29udmVydCB0aGUga2V5IGludG8gaW50c1xyXG4gICAgICAgIGNvbnN0IHRrID0gY29udmVydFRvSW50MzIodGhpcy5rZXkpO1xyXG4gICAgICAgIC8vIGNvcHkgdmFsdWVzIGludG8gcm91bmQga2V5IGFycmF5c1xyXG4gICAgICAgIGxldCBpbmRleDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEtDOyBpKyspIHtcclxuICAgICAgICAgICAgaW5kZXggPSBpID4+IDI7XHJcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZSwgXCJmXCIpW2luZGV4XVtpICUgNF0gPSB0a1tpXTtcclxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcm91bmRzIC0gaW5kZXhdW2kgJSA0XSA9IHRrW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIChmaXBzLTE5NyBzZWN0aW9uIDUuMilcclxuICAgICAgICBsZXQgcmNvbnBvaW50ZXIgPSAwO1xyXG4gICAgICAgIGxldCB0ID0gS0MsIHR0O1xyXG4gICAgICAgIHdoaWxlICh0IDwgcm91bmRLZXlDb3VudCkge1xyXG4gICAgICAgICAgICB0dCA9IHRrW0tDIC0gMV07XHJcbiAgICAgICAgICAgIHRrWzBdIF49ICgoU1sodHQgPj4gMTYpICYgMHhGRl0gPDwgMjQpIF5cclxuICAgICAgICAgICAgICAgIChTWyh0dCA+PiA4KSAmIDB4RkZdIDw8IDE2KSBeXHJcbiAgICAgICAgICAgICAgICAoU1t0dCAmIDB4RkZdIDw8IDgpIF5cclxuICAgICAgICAgICAgICAgIFNbKHR0ID4+IDI0KSAmIDB4RkZdIF5cclxuICAgICAgICAgICAgICAgIChyY29uW3Jjb25wb2ludGVyXSA8PCAyNCkpO1xyXG4gICAgICAgICAgICByY29ucG9pbnRlciArPSAxO1xyXG4gICAgICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIChmb3Igbm9uLTI1NiBiaXQpXHJcbiAgICAgICAgICAgIGlmIChLQyAhPSA4KSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IEtDOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0a1tpXSBePSB0a1tpIC0gMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIGZvciAyNTYtYml0IGtleXMgaXMgXCJzbGlnaHRseSBkaWZmZXJlbnRcIiAoZmlwcy0xOTcpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IChLQyAvIDIpOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0a1tpXSBePSB0a1tpIC0gMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0dCA9IHRrWyhLQyAvIDIpIC0gMV07XHJcbiAgICAgICAgICAgICAgICB0a1tLQyAvIDJdIF49IChTW3R0ICYgMHhGRl0gXlxyXG4gICAgICAgICAgICAgICAgICAgIChTWyh0dCA+PiA4KSAmIDB4RkZdIDw8IDgpIF5cclxuICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gMTYpICYgMHhGRl0gPDwgMTYpIF5cclxuICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gMjQpICYgMHhGRl0gPDwgMjQpKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAoS0MgLyAyKSArIDE7IGkgPCBLQzsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNvcHkgdmFsdWVzIGludG8gcm91bmQga2V5IGFycmF5c1xyXG4gICAgICAgICAgICBsZXQgaSA9IDAsIHIsIGM7XHJcbiAgICAgICAgICAgIHdoaWxlIChpIDwgS0MgJiYgdCA8IHJvdW5kS2V5Q291bnQpIHtcclxuICAgICAgICAgICAgICAgIHIgPSB0ID4+IDI7XHJcbiAgICAgICAgICAgICAgICBjID0gdCAlIDQ7XHJcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKVtyXVtjXSA9IHRrW2ldO1xyXG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcm91bmRzIC0gcl1bY10gPSB0a1tpKytdO1xyXG4gICAgICAgICAgICAgICAgdCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGludmVyc2UtY2lwaGVyLWlmeSB0aGUgZGVjcnlwdGlvbiByb3VuZCBrZXkgKGZpcHMtMTk3IHNlY3Rpb24gNS4zKVxyXG4gICAgICAgIGZvciAobGV0IHIgPSAxOyByIDwgcm91bmRzOyByKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCA0OyBjKyspIHtcclxuICAgICAgICAgICAgICAgIHR0ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcl1bY107XHJcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2QsIFwiZlwiKVtyXVtjXSA9IChVMVsodHQgPj4gMjQpICYgMHhGRl0gXlxyXG4gICAgICAgICAgICAgICAgICAgIFUyWyh0dCA+PiAxNikgJiAweEZGXSBeXHJcbiAgICAgICAgICAgICAgICAgICAgVTNbKHR0ID4+IDgpICYgMHhGRl0gXlxyXG4gICAgICAgICAgICAgICAgICAgIFU0W3R0ICYgMHhGRl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZW5jcnlwdChwbGFpbnRleHQpIHtcclxuICAgICAgICBpZiAocGxhaW50ZXh0Lmxlbmd0aCAhPSAxNikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBsYWludGV4dCBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByb3VuZHMgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKS5sZW5ndGggLSAxO1xyXG4gICAgICAgIGNvbnN0IGEgPSBbMCwgMCwgMCwgMF07XHJcbiAgICAgICAgLy8gY29udmVydCBwbGFpbnRleHQgdG8gKGludHMgXiBrZXkpXHJcbiAgICAgICAgbGV0IHQgPSBjb252ZXJ0VG9JbnQzMihwbGFpbnRleHQpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRbaV0gXj0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIilbMF1baV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFwcGx5IHJvdW5kIHRyYW5zZm9ybXNcclxuICAgICAgICBmb3IgKGxldCByID0gMTsgciA8IHJvdW5kczsgcisrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhW2ldID0gKFQxWyh0W2ldID4+IDI0KSAmIDB4ZmZdIF5cclxuICAgICAgICAgICAgICAgICAgICBUMlsodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXlxyXG4gICAgICAgICAgICAgICAgICAgIFQzWyh0WyhpICsgMikgJSA0XSA+PiA4KSAmIDB4ZmZdIF5cclxuICAgICAgICAgICAgICAgICAgICBUNFt0WyhpICsgMykgJSA0XSAmIDB4ZmZdIF5cclxuICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKVtyXVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdCA9IGEuc2xpY2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGhlIGxhc3Qgcm91bmQgaXMgc3BlY2lhbFxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KDE2KTtcclxuICAgICAgICBsZXQgdHQgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHR0ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIilbcm91bmRzXVtpXTtcclxuICAgICAgICAgICAgcmVzdWx0WzQgKiBpXSA9IChTWyh0W2ldID4+IDI0KSAmIDB4ZmZdIF4gKHR0ID4+IDI0KSkgJiAweGZmO1xyXG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAxXSA9IChTWyh0WyhpICsgMSkgJSA0XSA+PiAxNikgJiAweGZmXSBeICh0dCA+PiAxNikpICYgMHhmZjtcclxuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMl0gPSAoU1sodFsoaSArIDIpICUgNF0gPj4gOCkgJiAweGZmXSBeICh0dCA+PiA4KSkgJiAweGZmO1xyXG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAzXSA9IChTW3RbKGkgKyAzKSAlIDRdICYgMHhmZl0gXiB0dCkgJiAweGZmO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XHJcbiAgICAgICAgaWYgKGNpcGhlcnRleHQubGVuZ3RoICE9IDE2KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByb3VuZHMgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2QsIFwiZlwiKS5sZW5ndGggLSAxO1xyXG4gICAgICAgIGNvbnN0IGEgPSBbMCwgMCwgMCwgMF07XHJcbiAgICAgICAgLy8gY29udmVydCBwbGFpbnRleHQgdG8gKGludHMgXiBrZXkpXHJcbiAgICAgICAgbGV0IHQgPSBjb252ZXJ0VG9JbnQzMihjaXBoZXJ0ZXh0KTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICAgICAgICB0W2ldIF49IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpWzBdW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhcHBseSByb3VuZCB0cmFuc2Zvcm1zXHJcbiAgICAgICAgZm9yIChsZXQgciA9IDE7IHIgPCByb3VuZHM7IHIrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYVtpXSA9IChUNVsodFtpXSA+PiAyNCkgJiAweGZmXSBeXHJcbiAgICAgICAgICAgICAgICAgICAgVDZbKHRbKGkgKyAzKSAlIDRdID4+IDE2KSAmIDB4ZmZdIF5cclxuICAgICAgICAgICAgICAgICAgICBUN1sodFsoaSArIDIpICUgNF0gPj4gOCkgJiAweGZmXSBeXHJcbiAgICAgICAgICAgICAgICAgICAgVDhbdFsoaSArIDEpICUgNF0gJiAweGZmXSBeXHJcbiAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcl1baV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHQgPSBhLnNsaWNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRoZSBsYXN0IHJvdW5kIGlzIHNwZWNpYWxcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgxNik7XHJcbiAgICAgICAgbGV0IHR0ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICAgICAgICB0dCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JvdW5kc11baV07XHJcbiAgICAgICAgICAgIHJlc3VsdFs0ICogaV0gPSAoU2lbKHRbaV0gPj4gMjQpICYgMHhmZl0gXiAodHQgPj4gMjQpKSAmIDB4ZmY7XHJcbiAgICAgICAgICAgIHJlc3VsdFs0ICogaSArIDFdID0gKFNpWyh0WyhpICsgMykgJSA0XSA+PiAxNikgJiAweGZmXSBeICh0dCA+PiAxNikpICYgMHhmZjtcclxuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMl0gPSAoU2lbKHRbKGkgKyAyKSAlIDRdID4+IDgpICYgMHhmZl0gXiAodHQgPj4gOCkpICYgMHhmZjtcclxuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgM10gPSAoU2lbdFsoaSArIDEpICUgNF0gJiAweGZmXSBeIHR0KSAmIDB4ZmY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuX0FFU19rZXkgPSBuZXcgV2Vha01hcCgpLCBfQUVTX0tkID0gbmV3IFdlYWtNYXAoKSwgX0FFU19LZSA9IG5ldyBXZWFrTWFwKCk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/aes-js/lib.esm/aes.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/aes-js/lib.esm/index.js":
/*!**********************************************!*\
  !*** ./node_modules/aes-js/lib.esm/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AES: () => (/* reexport safe */ _aes_js__WEBPACK_IMPORTED_MODULE_0__.AES),\n/* harmony export */   CBC: () => (/* reexport safe */ _mode_cbc_js__WEBPACK_IMPORTED_MODULE_2__.CBC),\n/* harmony export */   CFB: () => (/* reexport safe */ _mode_cfb_js__WEBPACK_IMPORTED_MODULE_3__.CFB),\n/* harmony export */   CTR: () => (/* reexport safe */ _mode_ctr_js__WEBPACK_IMPORTED_MODULE_4__.CTR),\n/* harmony export */   ECB: () => (/* reexport safe */ _mode_ecb_js__WEBPACK_IMPORTED_MODULE_5__.ECB),\n/* harmony export */   ModeOfOperation: () => (/* reexport safe */ _mode_js__WEBPACK_IMPORTED_MODULE_1__.ModeOfOperation),\n/* harmony export */   OFB: () => (/* reexport safe */ _mode_ofb_js__WEBPACK_IMPORTED_MODULE_6__.OFB),\n/* harmony export */   pkcs7Pad: () => (/* reexport safe */ _padding_js__WEBPACK_IMPORTED_MODULE_7__.pkcs7Pad),\n/* harmony export */   pkcs7Strip: () => (/* reexport safe */ _padding_js__WEBPACK_IMPORTED_MODULE_7__.pkcs7Strip)\n/* harmony export */ });\n/* harmony import */ var _aes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./aes.js */ \"(pages-dir-browser)/./node_modules/aes-js/lib.esm/aes.js\");\n/* harmony import */ var _mode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mode.js */ \"(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode.js\");\n/* harmony import */ var _mode_cbc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mode-cbc.js */ \"(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode-cbc.js\");\n/* harmony import */ var _mode_cfb_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mode-cfb.js */ \"(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode-cfb.js\");\n/* harmony import */ var _mode_ctr_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mode-ctr.js */ \"(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode-ctr.js\");\n/* harmony import */ var _mode_ecb_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mode-ecb.js */ \"(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode-ecb.js\");\n/* harmony import */ var _mode_ofb_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mode-ofb.js */ \"(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode-ofb.js\");\n/* harmony import */ var _padding_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./padding.js */ \"(pages-dir-browser)/./node_modules/aes-js/lib.esm/padding.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNhO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnQjtBQUNwRCIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcYWVzLWpzXFxsaWIuZXNtXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBBRVMgfSBmcm9tIFwiLi9hZXMuanNcIjtcclxuZXhwb3J0IHsgTW9kZU9mT3BlcmF0aW9uIH0gZnJvbSBcIi4vbW9kZS5qc1wiO1xyXG5leHBvcnQgeyBDQkMgfSBmcm9tIFwiLi9tb2RlLWNiYy5qc1wiO1xyXG5leHBvcnQgeyBDRkIgfSBmcm9tIFwiLi9tb2RlLWNmYi5qc1wiO1xyXG5leHBvcnQgeyBDVFIgfSBmcm9tIFwiLi9tb2RlLWN0ci5qc1wiO1xyXG5leHBvcnQgeyBFQ0IgfSBmcm9tIFwiLi9tb2RlLWVjYi5qc1wiO1xyXG5leHBvcnQgeyBPRkIgfSBmcm9tIFwiLi9tb2RlLW9mYi5qc1wiO1xyXG5leHBvcnQgeyBwa2NzN1BhZCwgcGtjczdTdHJpcCB9IGZyb20gXCIuL3BhZGRpbmcuanNcIjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/aes-js/lib.esm/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode-cbc.js":
/*!*************************************************!*\
  !*** ./node_modules/aes-js/lib.esm/mode-cbc.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CBC: () => (/* binding */ CBC)\n/* harmony export */ });\n/* harmony import */ var _mode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mode.js */ \"(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode.js\");\n// Cipher Block Chaining\r\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n};\r\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar _CBC_iv, _CBC_lastBlock;\r\n\r\nclass CBC extends _mode_js__WEBPACK_IMPORTED_MODULE_0__.ModeOfOperation {\r\n    constructor(key, iv) {\r\n        super(\"ECC\", key, CBC);\r\n        _CBC_iv.set(this, void 0);\r\n        _CBC_lastBlock.set(this, void 0);\r\n        if (iv) {\r\n            if (iv.length % 16) {\r\n                throw new TypeError(\"invalid iv size (must be 16 bytes)\");\r\n            }\r\n            __classPrivateFieldSet(this, _CBC_iv, new Uint8Array(iv), \"f\");\r\n        }\r\n        else {\r\n            __classPrivateFieldSet(this, _CBC_iv, new Uint8Array(16), \"f\");\r\n        }\r\n        __classPrivateFieldSet(this, _CBC_lastBlock, this.iv, \"f\");\r\n    }\r\n    get iv() { return new Uint8Array(__classPrivateFieldGet(this, _CBC_iv, \"f\")); }\r\n    encrypt(plaintext) {\r\n        if (plaintext.length % 16) {\r\n            throw new TypeError(\"invalid plaintext size (must be multiple of 16 bytes)\");\r\n        }\r\n        const ciphertext = new Uint8Array(plaintext.length);\r\n        for (let i = 0; i < plaintext.length; i += 16) {\r\n            for (let j = 0; j < 16; j++) {\r\n                __classPrivateFieldGet(this, _CBC_lastBlock, \"f\")[j] ^= plaintext[i + j];\r\n            }\r\n            __classPrivateFieldSet(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet(this, _CBC_lastBlock, \"f\")), \"f\");\r\n            ciphertext.set(__classPrivateFieldGet(this, _CBC_lastBlock, \"f\"), i);\r\n        }\r\n        return ciphertext;\r\n    }\r\n    decrypt(ciphertext) {\r\n        if (ciphertext.length % 16) {\r\n            throw new TypeError(\"invalid ciphertext size (must be multiple of 16 bytes)\");\r\n        }\r\n        const plaintext = new Uint8Array(ciphertext.length);\r\n        for (let i = 0; i < ciphertext.length; i += 16) {\r\n            const block = this.aes.decrypt(ciphertext.subarray(i, i + 16));\r\n            for (let j = 0; j < 16; j++) {\r\n                plaintext[i + j] = block[j] ^ __classPrivateFieldGet(this, _CBC_lastBlock, \"f\")[j];\r\n                __classPrivateFieldGet(this, _CBC_lastBlock, \"f\")[j] = ciphertext[i + j];\r\n            }\r\n        }\r\n        return plaintext;\r\n    }\r\n}\r\n_CBC_iv = new WeakMap(), _CBC_lastBlock = new WeakMap();\r\n//# sourceMappingURL=mode-cbc.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9tb2RlLWNiYy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0QztBQUNyQyxrQkFBa0IscURBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGFlcy1qc1xcbGliLmVzbVxcbW9kZS1jYmMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2lwaGVyIEJsb2NrIENoYWluaW5nXHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59O1xyXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59O1xyXG52YXIgX0NCQ19pdiwgX0NCQ19sYXN0QmxvY2s7XHJcbmltcG9ydCB7IE1vZGVPZk9wZXJhdGlvbiB9IGZyb20gXCIuL21vZGUuanNcIjtcclxuZXhwb3J0IGNsYXNzIENCQyBleHRlbmRzIE1vZGVPZk9wZXJhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIGl2KSB7XHJcbiAgICAgICAgc3VwZXIoXCJFQ0NcIiwga2V5LCBDQkMpO1xyXG4gICAgICAgIF9DQkNfaXYuc2V0KHRoaXMsIHZvaWQgMCk7XHJcbiAgICAgICAgX0NCQ19sYXN0QmxvY2suc2V0KHRoaXMsIHZvaWQgMCk7XHJcbiAgICAgICAgaWYgKGl2KSB7XHJcbiAgICAgICAgICAgIGlmIChpdi5sZW5ndGggJSAxNikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgaXYgc2l6ZSAobXVzdCBiZSAxNiBieXRlcylcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ0JDX2l2LCBuZXcgVWludDhBcnJheShpdiksIFwiZlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NCQ19pdiwgbmV3IFVpbnQ4QXJyYXkoMTYpLCBcImZcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIHRoaXMuaXYsIFwiZlwiKTtcclxuICAgIH1cclxuICAgIGdldCBpdigpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NCQ19pdiwgXCJmXCIpKTsgfVxyXG4gICAgZW5jcnlwdChwbGFpbnRleHQpIHtcclxuICAgICAgICBpZiAocGxhaW50ZXh0Lmxlbmd0aCAlIDE2KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHBsYWludGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IG5ldyBVaW50OEFycmF5KHBsYWludGV4dC5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxhaW50ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyBqKyspIHtcclxuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIFwiZlwiKVtqXSBePSBwbGFpbnRleHRbaSArIGpdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIHRoaXMuYWVzLmVuY3J5cHQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgXCJmXCIpKSwgXCJmXCIpO1xyXG4gICAgICAgICAgICBjaXBoZXJ0ZXh0LnNldChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DQkNfbGFzdEJsb2NrLCBcImZcIiksIGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcclxuICAgIH1cclxuICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xyXG4gICAgICAgIGlmIChjaXBoZXJ0ZXh0Lmxlbmd0aCAlIDE2KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBsYWludGV4dCA9IG5ldyBVaW50OEFycmF5KGNpcGhlcnRleHQubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNpcGhlcnRleHQubGVuZ3RoOyBpICs9IDE2KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5hZXMuZGVjcnlwdChjaXBoZXJ0ZXh0LnN1YmFycmF5KGksIGkgKyAxNikpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHBsYWludGV4dFtpICsgal0gPSBibG9ja1tqXSBeIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIFwiZlwiKVtqXTtcclxuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIFwiZlwiKVtqXSA9IGNpcGhlcnRleHRbaSArIGpdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwbGFpbnRleHQ7XHJcbiAgICB9XHJcbn1cclxuX0NCQ19pdiA9IG5ldyBXZWFrTWFwKCksIF9DQkNfbGFzdEJsb2NrID0gbmV3IFdlYWtNYXAoKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZS1jYmMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode-cbc.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode-cfb.js":
/*!*************************************************!*\
  !*** ./node_modules/aes-js/lib.esm/mode-cfb.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CFB: () => (/* binding */ CFB)\n/* harmony export */ });\n/* harmony import */ var _mode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mode.js */ \"(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode.js\");\n// Cipher Feedback\r\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n};\r\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar _CFB_instances, _CFB_iv, _CFB_shiftRegister, _CFB_shift;\r\n\r\nclass CFB extends _mode_js__WEBPACK_IMPORTED_MODULE_0__.ModeOfOperation {\r\n    constructor(key, iv, segmentSize = 8) {\r\n        super(\"CFB\", key, CFB);\r\n        _CFB_instances.add(this);\r\n        _CFB_iv.set(this, void 0);\r\n        _CFB_shiftRegister.set(this, void 0);\r\n        // This library currently only handles byte-aligned segmentSize\r\n        if (!Number.isInteger(segmentSize) || (segmentSize % 8)) {\r\n            throw new TypeError(\"invalid segmentSize\");\r\n        }\r\n        Object.defineProperties(this, {\r\n            segmentSize: { enumerable: true, value: segmentSize }\r\n        });\r\n        if (iv) {\r\n            if (iv.length % 16) {\r\n                throw new TypeError(\"invalid iv size (must be 16 bytes)\");\r\n            }\r\n            __classPrivateFieldSet(this, _CFB_iv, new Uint8Array(iv), \"f\");\r\n        }\r\n        else {\r\n            __classPrivateFieldSet(this, _CFB_iv, new Uint8Array(16), \"f\");\r\n        }\r\n        __classPrivateFieldSet(this, _CFB_shiftRegister, this.iv, \"f\");\r\n    }\r\n    get iv() { return new Uint8Array(__classPrivateFieldGet(this, _CFB_iv, \"f\")); }\r\n    encrypt(plaintext) {\r\n        if (8 * plaintext.length % this.segmentSize) {\r\n            throw new TypeError(\"invalid plaintext size (must be multiple of segmentSize bytes)\");\r\n        }\r\n        const segmentSize = this.segmentSize / 8;\r\n        const ciphertext = new Uint8Array(plaintext);\r\n        for (let i = 0; i < ciphertext.length; i += segmentSize) {\r\n            const xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\"));\r\n            for (let j = 0; j < segmentSize; j++) {\r\n                ciphertext[i + j] ^= xorSegment[j];\r\n            }\r\n            __classPrivateFieldGet(this, _CFB_instances, \"m\", _CFB_shift).call(this, ciphertext.subarray(i));\r\n        }\r\n        return ciphertext;\r\n    }\r\n    decrypt(ciphertext) {\r\n        if (8 * ciphertext.length % this.segmentSize) {\r\n            throw new TypeError(\"invalid ciphertext size (must be multiple of segmentSize bytes)\");\r\n        }\r\n        const segmentSize = this.segmentSize / 8;\r\n        const plaintext = new Uint8Array(ciphertext);\r\n        for (let i = 0; i < plaintext.length; i += segmentSize) {\r\n            const xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\"));\r\n            for (let j = 0; j < segmentSize; j++) {\r\n                plaintext[i + j] ^= xorSegment[j];\r\n            }\r\n            __classPrivateFieldGet(this, _CFB_instances, \"m\", _CFB_shift).call(this, ciphertext.subarray(i));\r\n        }\r\n        return plaintext;\r\n    }\r\n}\r\n_CFB_iv = new WeakMap(), _CFB_shiftRegister = new WeakMap(), _CFB_instances = new WeakSet(), _CFB_shift = function _CFB_shift(data) {\r\n    const segmentSize = this.segmentSize / 8;\r\n    // Shift the register\r\n    __classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").set(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").subarray(segmentSize));\r\n    __classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").set(data.subarray(0, segmentSize), 16 - segmentSize);\r\n};\r\n//# sourceMappingURL=mode-cfb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9tb2RlLWNmYi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0QztBQUNyQyxrQkFBa0IscURBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcYWVzLWpzXFxsaWIuZXNtXFxtb2RlLWNmYi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDaXBoZXIgRmVlZGJhY2tcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn07XHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn07XHJcbnZhciBfQ0ZCX2luc3RhbmNlcywgX0NGQl9pdiwgX0NGQl9zaGlmdFJlZ2lzdGVyLCBfQ0ZCX3NoaWZ0O1xyXG5pbXBvcnQgeyBNb2RlT2ZPcGVyYXRpb24gfSBmcm9tIFwiLi9tb2RlLmpzXCI7XHJcbmV4cG9ydCBjbGFzcyBDRkIgZXh0ZW5kcyBNb2RlT2ZPcGVyYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3Ioa2V5LCBpdiwgc2VnbWVudFNpemUgPSA4KSB7XHJcbiAgICAgICAgc3VwZXIoXCJDRkJcIiwga2V5LCBDRkIpO1xyXG4gICAgICAgIF9DRkJfaW5zdGFuY2VzLmFkZCh0aGlzKTtcclxuICAgICAgICBfQ0ZCX2l2LnNldCh0aGlzLCB2b2lkIDApO1xyXG4gICAgICAgIF9DRkJfc2hpZnRSZWdpc3Rlci5zZXQodGhpcywgdm9pZCAwKTtcclxuICAgICAgICAvLyBUaGlzIGxpYnJhcnkgY3VycmVudGx5IG9ubHkgaGFuZGxlcyBieXRlLWFsaWduZWQgc2VnbWVudFNpemVcclxuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoc2VnbWVudFNpemUpIHx8IChzZWdtZW50U2l6ZSAlIDgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHNlZ21lbnRTaXplXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XHJcbiAgICAgICAgICAgIHNlZ21lbnRTaXplOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiBzZWdtZW50U2l6ZSB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGl2KSB7XHJcbiAgICAgICAgICAgIGlmIChpdi5sZW5ndGggJSAxNikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgaXYgc2l6ZSAobXVzdCBiZSAxNiBieXRlcylcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ0ZCX2l2LCBuZXcgVWludDhBcnJheShpdiksIFwiZlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NGQl9pdiwgbmV3IFVpbnQ4QXJyYXkoMTYpLCBcImZcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NGQl9zaGlmdFJlZ2lzdGVyLCB0aGlzLml2LCBcImZcIik7XHJcbiAgICB9XHJcbiAgICBnZXQgaXYoKSB7IHJldHVybiBuZXcgVWludDhBcnJheShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DRkJfaXYsIFwiZlwiKSk7IH1cclxuICAgIGVuY3J5cHQocGxhaW50ZXh0KSB7XHJcbiAgICAgICAgaWYgKDggKiBwbGFpbnRleHQubGVuZ3RoICUgdGhpcy5zZWdtZW50U2l6ZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiBzZWdtZW50U2l6ZSBieXRlcylcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlZ21lbnRTaXplID0gdGhpcy5zZWdtZW50U2l6ZSAvIDg7XHJcbiAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IG5ldyBVaW50OEFycmF5KHBsYWludGV4dCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaXBoZXJ0ZXh0Lmxlbmd0aDsgaSArPSBzZWdtZW50U2l6ZSkge1xyXG4gICAgICAgICAgICBjb25zdCB4b3JTZWdtZW50ID0gdGhpcy5hZXMuZW5jcnlwdChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DRkJfc2hpZnRSZWdpc3RlciwgXCJmXCIpKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZWdtZW50U2l6ZTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0W2kgKyBqXSBePSB4b3JTZWdtZW50W2pdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NGQl9pbnN0YW5jZXMsIFwibVwiLCBfQ0ZCX3NoaWZ0KS5jYWxsKHRoaXMsIGNpcGhlcnRleHQuc3ViYXJyYXkoaSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcclxuICAgIH1cclxuICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xyXG4gICAgICAgIGlmICg4ICogY2lwaGVydGV4dC5sZW5ndGggJSB0aGlzLnNlZ21lbnRTaXplKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiBzZWdtZW50U2l6ZSBieXRlcylcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlZ21lbnRTaXplID0gdGhpcy5zZWdtZW50U2l6ZSAvIDg7XHJcbiAgICAgICAgY29uc3QgcGxhaW50ZXh0ID0gbmV3IFVpbnQ4QXJyYXkoY2lwaGVydGV4dCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGFpbnRleHQubGVuZ3RoOyBpICs9IHNlZ21lbnRTaXplKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHhvclNlZ21lbnQgPSB0aGlzLmFlcy5lbmNyeXB0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NGQl9zaGlmdFJlZ2lzdGVyLCBcImZcIikpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNlZ21lbnRTaXplOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHBsYWludGV4dFtpICsgal0gXj0geG9yU2VnbWVudFtqXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DRkJfaW5zdGFuY2VzLCBcIm1cIiwgX0NGQl9zaGlmdCkuY2FsbCh0aGlzLCBjaXBoZXJ0ZXh0LnN1YmFycmF5KGkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcclxuICAgIH1cclxufVxyXG5fQ0ZCX2l2ID0gbmV3IFdlYWtNYXAoKSwgX0NGQl9zaGlmdFJlZ2lzdGVyID0gbmV3IFdlYWtNYXAoKSwgX0NGQl9pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpLCBfQ0ZCX3NoaWZ0ID0gZnVuY3Rpb24gX0NGQl9zaGlmdChkYXRhKSB7XHJcbiAgICBjb25zdCBzZWdtZW50U2l6ZSA9IHRoaXMuc2VnbWVudFNpemUgLyA4O1xyXG4gICAgLy8gU2hpZnQgdGhlIHJlZ2lzdGVyXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DRkJfc2hpZnRSZWdpc3RlciwgXCJmXCIpLnNldChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DRkJfc2hpZnRSZWdpc3RlciwgXCJmXCIpLnN1YmFycmF5KHNlZ21lbnRTaXplKSk7XHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DRkJfc2hpZnRSZWdpc3RlciwgXCJmXCIpLnNldChkYXRhLnN1YmFycmF5KDAsIHNlZ21lbnRTaXplKSwgMTYgLSBzZWdtZW50U2l6ZSk7XHJcbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGUtY2ZiLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode-cfb.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode-ctr.js":
/*!*************************************************!*\
  !*** ./node_modules/aes-js/lib.esm/mode-ctr.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CTR: () => (/* binding */ CTR)\n/* harmony export */ });\n/* harmony import */ var _mode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mode.js */ \"(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode.js\");\n// Counter Mode\r\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n};\r\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar _CTR_remaining, _CTR_remainingIndex, _CTR_counter;\r\n\r\nclass CTR extends _mode_js__WEBPACK_IMPORTED_MODULE_0__.ModeOfOperation {\r\n    constructor(key, initialValue) {\r\n        super(\"CTR\", key, CTR);\r\n        // Remaining bytes for the one-time pad\r\n        _CTR_remaining.set(this, void 0);\r\n        _CTR_remainingIndex.set(this, void 0);\r\n        // The current counter\r\n        _CTR_counter.set(this, void 0);\r\n        __classPrivateFieldSet(this, _CTR_counter, new Uint8Array(16), \"f\");\r\n        __classPrivateFieldGet(this, _CTR_counter, \"f\").fill(0);\r\n        __classPrivateFieldSet(this, _CTR_remaining, __classPrivateFieldGet(this, _CTR_counter, \"f\"), \"f\"); // This will be discarded immediately\r\n        __classPrivateFieldSet(this, _CTR_remainingIndex, 16, \"f\");\r\n        if (initialValue == null) {\r\n            initialValue = 1;\r\n        }\r\n        if (typeof (initialValue) === \"number\") {\r\n            this.setCounterValue(initialValue);\r\n        }\r\n        else {\r\n            this.setCounterBytes(initialValue);\r\n        }\r\n    }\r\n    get counter() { return new Uint8Array(__classPrivateFieldGet(this, _CTR_counter, \"f\")); }\r\n    setCounterValue(value) {\r\n        if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {\r\n            throw new TypeError(\"invalid counter initial integer value\");\r\n        }\r\n        for (let index = 15; index >= 0; --index) {\r\n            __classPrivateFieldGet(this, _CTR_counter, \"f\")[index] = value % 256;\r\n            value = Math.floor(value / 256);\r\n        }\r\n    }\r\n    setCounterBytes(value) {\r\n        if (value.length !== 16) {\r\n            throw new TypeError(\"invalid counter initial Uint8Array value length\");\r\n        }\r\n        __classPrivateFieldGet(this, _CTR_counter, \"f\").set(value);\r\n    }\r\n    increment() {\r\n        for (let i = 15; i >= 0; i--) {\r\n            if (__classPrivateFieldGet(this, _CTR_counter, \"f\")[i] === 255) {\r\n                __classPrivateFieldGet(this, _CTR_counter, \"f\")[i] = 0;\r\n            }\r\n            else {\r\n                __classPrivateFieldGet(this, _CTR_counter, \"f\")[i]++;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    encrypt(plaintext) {\r\n        var _a, _b;\r\n        const crypttext = new Uint8Array(plaintext);\r\n        for (let i = 0; i < crypttext.length; i++) {\r\n            if (__classPrivateFieldGet(this, _CTR_remainingIndex, \"f\") === 16) {\r\n                __classPrivateFieldSet(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet(this, _CTR_counter, \"f\")), \"f\");\r\n                __classPrivateFieldSet(this, _CTR_remainingIndex, 0, \"f\");\r\n                this.increment();\r\n            }\r\n            crypttext[i] ^= __classPrivateFieldGet(this, _CTR_remaining, \"f\")[__classPrivateFieldSet(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet(this, _CTR_remainingIndex, \"f\"), _a = _b++, _b), \"f\"), _a];\r\n        }\r\n        return crypttext;\r\n    }\r\n    decrypt(ciphertext) {\r\n        return this.encrypt(ciphertext);\r\n    }\r\n}\r\n_CTR_remaining = new WeakMap(), _CTR_remainingIndex = new WeakMap(), _CTR_counter = new WeakMap();\r\n//# sourceMappingURL=mode-ctr.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9tb2RlLWN0ci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0QztBQUNyQyxrQkFBa0IscURBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGFlcy1qc1xcbGliLmVzbVxcbW9kZS1jdHIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ291bnRlciBNb2RlXHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59O1xyXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59O1xyXG52YXIgX0NUUl9yZW1haW5pbmcsIF9DVFJfcmVtYWluaW5nSW5kZXgsIF9DVFJfY291bnRlcjtcclxuaW1wb3J0IHsgTW9kZU9mT3BlcmF0aW9uIH0gZnJvbSBcIi4vbW9kZS5qc1wiO1xyXG5leHBvcnQgY2xhc3MgQ1RSIGV4dGVuZHMgTW9kZU9mT3BlcmF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGtleSwgaW5pdGlhbFZhbHVlKSB7XHJcbiAgICAgICAgc3VwZXIoXCJDVFJcIiwga2V5LCBDVFIpO1xyXG4gICAgICAgIC8vIFJlbWFpbmluZyBieXRlcyBmb3IgdGhlIG9uZS10aW1lIHBhZFxyXG4gICAgICAgIF9DVFJfcmVtYWluaW5nLnNldCh0aGlzLCB2b2lkIDApO1xyXG4gICAgICAgIF9DVFJfcmVtYWluaW5nSW5kZXguc2V0KHRoaXMsIHZvaWQgMCk7XHJcbiAgICAgICAgLy8gVGhlIGN1cnJlbnQgY291bnRlclxyXG4gICAgICAgIF9DVFJfY291bnRlci5zZXQodGhpcywgdm9pZCAwKTtcclxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DVFJfY291bnRlciwgbmV3IFVpbnQ4QXJyYXkoMTYpLCBcImZcIik7XHJcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKS5maWxsKDApO1xyXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NUUl9yZW1haW5pbmcsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIiksIFwiZlwiKTsgLy8gVGhpcyB3aWxsIGJlIGRpc2NhcmRlZCBpbW1lZGlhdGVseVxyXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NUUl9yZW1haW5pbmdJbmRleCwgMTYsIFwiZlwiKTtcclxuICAgICAgICBpZiAoaW5pdGlhbFZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgaW5pdGlhbFZhbHVlID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoaW5pdGlhbFZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICB0aGlzLnNldENvdW50ZXJWYWx1ZShpbml0aWFsVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRDb3VudGVyQnl0ZXMoaW5pdGlhbFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgY291bnRlcigpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIikpOyB9XHJcbiAgICBzZXRDb3VudGVyVmFsdWUodmFsdWUpIHtcclxuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGNvdW50ZXIgaW5pdGlhbCBpbnRlZ2VyIHZhbHVlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE1OyBpbmRleCA+PSAwOyAtLWluZGV4KSB7XHJcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIilbaW5kZXhdID0gdmFsdWUgJSAyNTY7XHJcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvIDI1Nik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0Q291bnRlckJ5dGVzKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gMTYpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgY291bnRlciBpbml0aWFsIFVpbnQ4QXJyYXkgdmFsdWUgbGVuZ3RoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpLnNldCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBpbmNyZW1lbnQoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE1OyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKVtpXSA9PT0gMjU1KSB7XHJcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpW2ldID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIilbaV0rKztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZW5jcnlwdChwbGFpbnRleHQpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IGNyeXB0dGV4dCA9IG5ldyBVaW50OEFycmF5KHBsYWludGV4dCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjcnlwdHRleHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9yZW1haW5pbmdJbmRleCwgXCJmXCIpID09PSAxNikge1xyXG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ1RSX3JlbWFpbmluZywgdGhpcy5hZXMuZW5jcnlwdChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpKSwgXCJmXCIpO1xyXG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ1RSX3JlbWFpbmluZ0luZGV4LCAwLCBcImZcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluY3JlbWVudCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNyeXB0dGV4dFtpXSBePSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nLCBcImZcIilbX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ1RSX3JlbWFpbmluZ0luZGV4LCAoX2IgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nSW5kZXgsIFwiZlwiKSwgX2EgPSBfYisrLCBfYiksIFwiZlwiKSwgX2FdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3J5cHR0ZXh0O1xyXG4gICAgfVxyXG4gICAgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdChjaXBoZXJ0ZXh0KTtcclxuICAgIH1cclxufVxyXG5fQ1RSX3JlbWFpbmluZyA9IG5ldyBXZWFrTWFwKCksIF9DVFJfcmVtYWluaW5nSW5kZXggPSBuZXcgV2Vha01hcCgpLCBfQ1RSX2NvdW50ZXIgPSBuZXcgV2Vha01hcCgpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlLWN0ci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode-ctr.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode-ecb.js":
/*!*************************************************!*\
  !*** ./node_modules/aes-js/lib.esm/mode-ecb.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ECB: () => (/* binding */ ECB)\n/* harmony export */ });\n/* harmony import */ var _mode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mode.js */ \"(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode.js\");\n// Electronic Code Book\r\n\r\nclass ECB extends _mode_js__WEBPACK_IMPORTED_MODULE_0__.ModeOfOperation {\r\n    constructor(key) {\r\n        super(\"ECB\", key, ECB);\r\n    }\r\n    encrypt(plaintext) {\r\n        if (plaintext.length % 16) {\r\n            throw new TypeError(\"invalid plaintext size (must be multiple of 16 bytes)\");\r\n        }\r\n        const crypttext = new Uint8Array(plaintext.length);\r\n        for (let i = 0; i < plaintext.length; i += 16) {\r\n            crypttext.set(this.aes.encrypt(plaintext.subarray(i, i + 16)), i);\r\n        }\r\n        return crypttext;\r\n    }\r\n    decrypt(crypttext) {\r\n        if (crypttext.length % 16) {\r\n            throw new TypeError(\"invalid ciphertext size (must be multiple of 16 bytes)\");\r\n        }\r\n        const plaintext = new Uint8Array(crypttext.length);\r\n        for (let i = 0; i < crypttext.length; i += 16) {\r\n            plaintext.set(this.aes.decrypt(crypttext.subarray(i, i + 16)), i);\r\n        }\r\n        return plaintext;\r\n    }\r\n}\r\n//# sourceMappingURL=mode-ecb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9tb2RlLWVjYi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQzRDO0FBQ3JDLGtCQUFrQixxREFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcYWVzLWpzXFxsaWIuZXNtXFxtb2RlLWVjYi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbGVjdHJvbmljIENvZGUgQm9va1xyXG5pbXBvcnQgeyBNb2RlT2ZPcGVyYXRpb24gfSBmcm9tIFwiLi9tb2RlLmpzXCI7XHJcbmV4cG9ydCBjbGFzcyBFQ0IgZXh0ZW5kcyBNb2RlT2ZPcGVyYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3Ioa2V5KSB7XHJcbiAgICAgICAgc3VwZXIoXCJFQ0JcIiwga2V5LCBFQ0IpO1xyXG4gICAgfVxyXG4gICAgZW5jcnlwdChwbGFpbnRleHQpIHtcclxuICAgICAgICBpZiAocGxhaW50ZXh0Lmxlbmd0aCAlIDE2KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHBsYWludGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY3J5cHR0ZXh0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0Lmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGFpbnRleHQubGVuZ3RoOyBpICs9IDE2KSB7XHJcbiAgICAgICAgICAgIGNyeXB0dGV4dC5zZXQodGhpcy5hZXMuZW5jcnlwdChwbGFpbnRleHQuc3ViYXJyYXkoaSwgaSArIDE2KSksIGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3J5cHR0ZXh0O1xyXG4gICAgfVxyXG4gICAgZGVjcnlwdChjcnlwdHRleHQpIHtcclxuICAgICAgICBpZiAoY3J5cHR0ZXh0Lmxlbmd0aCAlIDE2KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBsYWludGV4dCA9IG5ldyBVaW50OEFycmF5KGNyeXB0dGV4dC5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3J5cHR0ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xyXG4gICAgICAgICAgICBwbGFpbnRleHQuc2V0KHRoaXMuYWVzLmRlY3J5cHQoY3J5cHR0ZXh0LnN1YmFycmF5KGksIGkgKyAxNikpLCBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlLWVjYi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode-ecb.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode-ofb.js":
/*!*************************************************!*\
  !*** ./node_modules/aes-js/lib.esm/mode-ofb.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OFB: () => (/* binding */ OFB)\n/* harmony export */ });\n/* harmony import */ var _mode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mode.js */ \"(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode.js\");\n// Output Feedback\r\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n};\r\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar _OFB_iv, _OFB_lastPrecipher, _OFB_lastPrecipherIndex;\r\n\r\nclass OFB extends _mode_js__WEBPACK_IMPORTED_MODULE_0__.ModeOfOperation {\r\n    constructor(key, iv) {\r\n        super(\"OFB\", key, OFB);\r\n        _OFB_iv.set(this, void 0);\r\n        _OFB_lastPrecipher.set(this, void 0);\r\n        _OFB_lastPrecipherIndex.set(this, void 0);\r\n        if (iv) {\r\n            if (iv.length % 16) {\r\n                throw new TypeError(\"invalid iv size (must be 16 bytes)\");\r\n            }\r\n            __classPrivateFieldSet(this, _OFB_iv, new Uint8Array(iv), \"f\");\r\n        }\r\n        else {\r\n            __classPrivateFieldSet(this, _OFB_iv, new Uint8Array(16), \"f\");\r\n        }\r\n        __classPrivateFieldSet(this, _OFB_lastPrecipher, this.iv, \"f\");\r\n        __classPrivateFieldSet(this, _OFB_lastPrecipherIndex, 16, \"f\");\r\n    }\r\n    get iv() { return new Uint8Array(__classPrivateFieldGet(this, _OFB_iv, \"f\")); }\r\n    encrypt(plaintext) {\r\n        var _a, _b;\r\n        if (plaintext.length % 16) {\r\n            throw new TypeError(\"invalid plaintext size (must be multiple of 16 bytes)\");\r\n        }\r\n        const ciphertext = new Uint8Array(plaintext);\r\n        for (let i = 0; i < ciphertext.length; i++) {\r\n            if (__classPrivateFieldGet(this, _OFB_lastPrecipherIndex, \"f\") === 16) {\r\n                __classPrivateFieldSet(this, _OFB_lastPrecipher, this.aes.encrypt(__classPrivateFieldGet(this, _OFB_lastPrecipher, \"f\")), \"f\");\r\n                __classPrivateFieldSet(this, _OFB_lastPrecipherIndex, 0, \"f\");\r\n            }\r\n            ciphertext[i] ^= __classPrivateFieldGet(this, _OFB_lastPrecipher, \"f\")[__classPrivateFieldSet(this, _OFB_lastPrecipherIndex, (_b = __classPrivateFieldGet(this, _OFB_lastPrecipherIndex, \"f\"), _a = _b++, _b), \"f\"), _a];\r\n        }\r\n        return ciphertext;\r\n    }\r\n    decrypt(ciphertext) {\r\n        if (ciphertext.length % 16) {\r\n            throw new TypeError(\"invalid ciphertext size (must be multiple of 16 bytes)\");\r\n        }\r\n        return this.encrypt(ciphertext);\r\n    }\r\n}\r\n_OFB_iv = new WeakMap(), _OFB_lastPrecipher = new WeakMap(), _OFB_lastPrecipherIndex = new WeakMap();\r\n//# sourceMappingURL=mode-ofb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9tb2RlLW9mYi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0QztBQUNyQyxrQkFBa0IscURBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGFlcy1qc1xcbGliLmVzbVxcbW9kZS1vZmIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gT3V0cHV0IEZlZWRiYWNrXHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59O1xyXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59O1xyXG52YXIgX09GQl9pdiwgX09GQl9sYXN0UHJlY2lwaGVyLCBfT0ZCX2xhc3RQcmVjaXBoZXJJbmRleDtcclxuaW1wb3J0IHsgTW9kZU9mT3BlcmF0aW9uIH0gZnJvbSBcIi4vbW9kZS5qc1wiO1xyXG5leHBvcnQgY2xhc3MgT0ZCIGV4dGVuZHMgTW9kZU9mT3BlcmF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGtleSwgaXYpIHtcclxuICAgICAgICBzdXBlcihcIk9GQlwiLCBrZXksIE9GQik7XHJcbiAgICAgICAgX09GQl9pdi5zZXQodGhpcywgdm9pZCAwKTtcclxuICAgICAgICBfT0ZCX2xhc3RQcmVjaXBoZXIuc2V0KHRoaXMsIHZvaWQgMCk7XHJcbiAgICAgICAgX09GQl9sYXN0UHJlY2lwaGVySW5kZXguc2V0KHRoaXMsIHZvaWQgMCk7XHJcbiAgICAgICAgaWYgKGl2KSB7XHJcbiAgICAgICAgICAgIGlmIChpdi5sZW5ndGggJSAxNikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgaXYgc2l6ZSAobXVzdCBiZSAxNiBieXRlcylcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfT0ZCX2l2LCBuZXcgVWludDhBcnJheShpdiksIFwiZlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX09GQl9pdiwgbmV3IFVpbnQ4QXJyYXkoMTYpLCBcImZcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX09GQl9sYXN0UHJlY2lwaGVyLCB0aGlzLml2LCBcImZcIik7XHJcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfT0ZCX2xhc3RQcmVjaXBoZXJJbmRleCwgMTYsIFwiZlwiKTtcclxuICAgIH1cclxuICAgIGdldCBpdigpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX09GQl9pdiwgXCJmXCIpKTsgfVxyXG4gICAgZW5jcnlwdChwbGFpbnRleHQpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmIChwbGFpbnRleHQubGVuZ3RoICUgMTYpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0KTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNpcGhlcnRleHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX09GQl9sYXN0UHJlY2lwaGVySW5kZXgsIFwiZlwiKSA9PT0gMTYpIHtcclxuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX09GQl9sYXN0UHJlY2lwaGVyLCB0aGlzLmFlcy5lbmNyeXB0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX09GQl9sYXN0UHJlY2lwaGVyLCBcImZcIikpLCBcImZcIik7XHJcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlckluZGV4LCAwLCBcImZcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2lwaGVydGV4dFtpXSBePSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlciwgXCJmXCIpW19fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX09GQl9sYXN0UHJlY2lwaGVySW5kZXgsIChfYiA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX09GQl9sYXN0UHJlY2lwaGVySW5kZXgsIFwiZlwiKSwgX2EgPSBfYisrLCBfYiksIFwiZlwiKSwgX2FdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcclxuICAgIH1cclxuICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xyXG4gICAgICAgIGlmIChjaXBoZXJ0ZXh0Lmxlbmd0aCAlIDE2KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHQoY2lwaGVydGV4dCk7XHJcbiAgICB9XHJcbn1cclxuX09GQl9pdiA9IG5ldyBXZWFrTWFwKCksIF9PRkJfbGFzdFByZWNpcGhlciA9IG5ldyBXZWFrTWFwKCksIF9PRkJfbGFzdFByZWNpcGhlckluZGV4ID0gbmV3IFdlYWtNYXAoKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZS1vZmIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode-ofb.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode.js":
/*!*********************************************!*\
  !*** ./node_modules/aes-js/lib.esm/mode.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ModeOfOperation: () => (/* binding */ ModeOfOperation)\n/* harmony export */ });\n/* harmony import */ var _aes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./aes.js */ \"(pages-dir-browser)/./node_modules/aes-js/lib.esm/aes.js\");\n\r\nclass ModeOfOperation {\r\n    constructor(name, key, cls) {\r\n        if (cls && !(this instanceof cls)) {\r\n            throw new Error(`${name} must be instantiated with \"new\"`);\r\n        }\r\n        Object.defineProperties(this, {\r\n            aes: { enumerable: true, value: new _aes_js__WEBPACK_IMPORTED_MODULE_0__.AES(key) },\r\n            name: { enumerable: true, value: name }\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=mode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9tb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStCO0FBQ3hCO0FBQ1A7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCLHdDQUFHLE9BQU87QUFDMUQsb0JBQW9CO0FBQ3BCLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGFlcy1qc1xcbGliLmVzbVxcbW9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBRVMgfSBmcm9tIFwiLi9hZXMuanNcIjtcclxuZXhwb3J0IGNsYXNzIE1vZGVPZk9wZXJhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBrZXksIGNscykge1xyXG4gICAgICAgIGlmIChjbHMgJiYgISh0aGlzIGluc3RhbmNlb2YgY2xzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX0gbXVzdCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBcIm5ld1wiYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgICAgICAgICAgYWVzOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiBuZXcgQUVTKGtleSkgfSxcclxuICAgICAgICAgICAgbmFtZTogeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogbmFtZSB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/aes-js/lib.esm/mode.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/aes-js/lib.esm/padding.js":
/*!************************************************!*\
  !*** ./node_modules/aes-js/lib.esm/padding.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pkcs7Pad: () => (/* binding */ pkcs7Pad),\n/* harmony export */   pkcs7Strip: () => (/* binding */ pkcs7Strip)\n/* harmony export */ });\nfunction pkcs7Pad(data) {\r\n    const padder = 16 - (data.length % 16);\r\n    const result = new Uint8Array(data.length + padder);\r\n    result.set(data);\r\n    for (let i = data.length; i < result.length; i++) {\r\n        result[i] = padder;\r\n    }\r\n    return result;\r\n}\r\nfunction pkcs7Strip(data) {\r\n    if (data.length < 16) {\r\n        throw new TypeError('PKCS#7 invalid length');\r\n    }\r\n    const padder = data[data.length - 1];\r\n    if (padder > 16) {\r\n        throw new TypeError('PKCS#7 padding byte out of range');\r\n    }\r\n    const length = data.length - padder;\r\n    for (let i = 0; i < padder; i++) {\r\n        if (data[length + i] !== padder) {\r\n            throw new TypeError('PKCS#7 invalid padding byte');\r\n        }\r\n    }\r\n    return new Uint8Array(data.subarray(0, length));\r\n}\r\n//# sourceMappingURL=padding.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9wYWRkaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUJBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGFlcy1qc1xcbGliLmVzbVxccGFkZGluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gcGtjczdQYWQoZGF0YSkge1xyXG4gICAgY29uc3QgcGFkZGVyID0gMTYgLSAoZGF0YS5sZW5ndGggJSAxNik7XHJcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCArIHBhZGRlcik7XHJcbiAgICByZXN1bHQuc2V0KGRhdGEpO1xyXG4gICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcmVzdWx0W2ldID0gcGFkZGVyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcGtjczdTdHJpcChkYXRhKSB7XHJcbiAgICBpZiAoZGF0YS5sZW5ndGggPCAxNikge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BLQ1MjNyBpbnZhbGlkIGxlbmd0aCcpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGFkZGVyID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdO1xyXG4gICAgaWYgKHBhZGRlciA+IDE2KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUEtDUyM3IHBhZGRpbmcgYnl0ZSBvdXQgb2YgcmFuZ2UnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoIC0gcGFkZGVyO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWRkZXI7IGkrKykge1xyXG4gICAgICAgIGlmIChkYXRhW2xlbmd0aCArIGldICE9PSBwYWRkZXIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUEtDUyM3IGludmFsaWQgcGFkZGluZyBieXRlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEuc3ViYXJyYXkoMCwgbGVuZ3RoKSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFkZGluZy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/aes-js/lib.esm/padding.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/_version.js":
/*!*************************************************!*\
  !*** ./node_modules/ethers/lib.esm/_version.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */\r\n/**\r\n *  The current version of Ethers.\r\n */\r\nconst version = \"6.15.0\";\r\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcX3ZlcnNpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogRG8gTk9UIG1vZGlmeSB0aGlzIGZpbGU7IHNlZSAvc3JjLnRzL19hZG1pbi91cGRhdGUtdmVyc2lvbi50cyAqL1xyXG4vKipcclxuICogIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgRXRoZXJzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcIjYuMTUuMFwiO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/_version.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/abi-coder.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/abi-coder.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbiCoder: () => (/* binding */ AbiCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./coders/abstract-coder.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _coders_address_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./coders/address.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/address.js\");\n/* harmony import */ var _coders_array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./coders/array.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/array.js\");\n/* harmony import */ var _coders_boolean_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./coders/boolean.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/boolean.js\");\n/* harmony import */ var _coders_bytes_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coders/bytes.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/bytes.js\");\n/* harmony import */ var _coders_fixed_bytes_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./coders/fixed-bytes.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js\");\n/* harmony import */ var _coders_null_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./coders/null.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/null.js\");\n/* harmony import */ var _coders_number_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./coders/number.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/number.js\");\n/* harmony import */ var _coders_string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./coders/string.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/string.js\");\n/* harmony import */ var _coders_tuple_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./coders/tuple.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/tuple.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./fragments.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/fragments.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\");\n/**\r\n *  When sending values to or receiving values from a [[Contract]], the\r\n *  data is generally encoded using the [ABI standard](link-solc-abi).\r\n *\r\n *  The AbiCoder provides a utility to encode values to ABI data and\r\n *  decode values from ABI data.\r\n *\r\n *  Most of the time, developers should favour the [[Contract]] class,\r\n *  which further abstracts a lot of the finer details of ABI data.\r\n *\r\n *  @_section api/abi/abi-coder:ABI Encoding\r\n */\r\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// https://docs.soliditylang.org/en/v0.8.17/control-structures.html\r\nconst PanicReasons = new Map();\r\nPanicReasons.set(0x00, \"GENERIC_PANIC\");\r\nPanicReasons.set(0x01, \"ASSERT_FALSE\");\r\nPanicReasons.set(0x11, \"OVERFLOW\");\r\nPanicReasons.set(0x12, \"DIVIDE_BY_ZERO\");\r\nPanicReasons.set(0x21, \"ENUM_RANGE_ERROR\");\r\nPanicReasons.set(0x22, \"BAD_STORAGE_DATA\");\r\nPanicReasons.set(0x31, \"STACK_UNDERFLOW\");\r\nPanicReasons.set(0x32, \"ARRAY_RANGE_ERROR\");\r\nPanicReasons.set(0x41, \"OUT_OF_MEMORY\");\r\nPanicReasons.set(0x51, \"UNINITIALIZED_FUNCTION_CALL\");\r\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\r\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\r\nlet defaultCoder = null;\r\nlet defaultMaxInflation = 1024;\r\nfunction getBuiltinCallException(action, tx, data, abiCoder) {\r\n    let message = \"missing revert data\";\r\n    let reason = null;\r\n    const invocation = null;\r\n    let revert = null;\r\n    if (data) {\r\n        message = \"execution reverted\";\r\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data);\r\n        data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data);\r\n        if (bytes.length === 0) {\r\n            message += \" (no data present; likely require(false) occurred\";\r\n            reason = \"require(false)\";\r\n        }\r\n        else if (bytes.length % 32 !== 4) {\r\n            message += \" (could not decode reason; invalid data length)\";\r\n        }\r\n        else if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4)) === \"0x08c379a0\") {\r\n            // Error(string)\r\n            try {\r\n                reason = abiCoder.decode([\"string\"], bytes.slice(4))[0];\r\n                revert = {\r\n                    signature: \"Error(string)\",\r\n                    name: \"Error\",\r\n                    args: [reason]\r\n                };\r\n                message += `: ${JSON.stringify(reason)}`;\r\n            }\r\n            catch (error) {\r\n                message += \" (could not decode reason; invalid string data)\";\r\n            }\r\n        }\r\n        else if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4)) === \"0x4e487b71\") {\r\n            // Panic(uint256)\r\n            try {\r\n                const code = Number(abiCoder.decode([\"uint256\"], bytes.slice(4))[0]);\r\n                revert = {\r\n                    signature: \"Panic(uint256)\",\r\n                    name: \"Panic\",\r\n                    args: [code]\r\n                };\r\n                reason = `Panic due to ${PanicReasons.get(code) || \"UNKNOWN\"}(${code})`;\r\n                message += `: ${reason}`;\r\n            }\r\n            catch (error) {\r\n                message += \" (could not decode panic code)\";\r\n            }\r\n        }\r\n        else {\r\n            message += \" (unknown custom error)\";\r\n        }\r\n    }\r\n    const transaction = {\r\n        to: (tx.to ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(tx.to) : null),\r\n        data: (tx.data || \"0x\")\r\n    };\r\n    if (tx.from) {\r\n        transaction.from = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(tx.from);\r\n    }\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(message, \"CALL_EXCEPTION\", {\r\n        action, data, reason, transaction, invocation, revert\r\n    });\r\n}\r\n/**\r\n *  The **AbiCoder** is a low-level class responsible for encoding JavaScript\r\n *  values into binary data and decoding binary data into JavaScript values.\r\n */\r\nclass AbiCoder {\r\n    #getCoder(param) {\r\n        if (param.isArray()) {\r\n            return new _coders_array_js__WEBPACK_IMPORTED_MODULE_2__.ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);\r\n        }\r\n        if (param.isTuple()) {\r\n            return new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_3__.TupleCoder(param.components.map((c) => this.#getCoder(c)), param.name);\r\n        }\r\n        switch (param.baseType) {\r\n            case \"address\":\r\n                return new _coders_address_js__WEBPACK_IMPORTED_MODULE_4__.AddressCoder(param.name);\r\n            case \"bool\":\r\n                return new _coders_boolean_js__WEBPACK_IMPORTED_MODULE_5__.BooleanCoder(param.name);\r\n            case \"string\":\r\n                return new _coders_string_js__WEBPACK_IMPORTED_MODULE_6__.StringCoder(param.name);\r\n            case \"bytes\":\r\n                return new _coders_bytes_js__WEBPACK_IMPORTED_MODULE_7__.BytesCoder(param.name);\r\n            case \"\":\r\n                return new _coders_null_js__WEBPACK_IMPORTED_MODULE_8__.NullCoder(param.name);\r\n        }\r\n        // u?int[0-9]*\r\n        let match = param.type.match(paramTypeNumber);\r\n        if (match) {\r\n            let size = parseInt(match[2] || \"256\");\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(size !== 0 && size <= 256 && (size % 8) === 0, \"invalid \" + match[1] + \" bit length\", \"param\", param);\r\n            return new _coders_number_js__WEBPACK_IMPORTED_MODULE_9__.NumberCoder(size / 8, (match[1] === \"int\"), param.name);\r\n        }\r\n        // bytes[0-9]+\r\n        match = param.type.match(paramTypeBytes);\r\n        if (match) {\r\n            let size = parseInt(match[1]);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(size !== 0 && size <= 32, \"invalid bytes length\", \"param\", param);\r\n            return new _coders_fixed_bytes_js__WEBPACK_IMPORTED_MODULE_10__.FixedBytesCoder(size, param.name);\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid type\", \"type\", param.type);\r\n    }\r\n    /**\r\n     *  Get the default values for the given %%types%%.\r\n     *\r\n     *  For example, a ``uint`` is by default ``0`` and ``bool``\r\n     *  is by default ``false``.\r\n     */\r\n    getDefaultValue(types) {\r\n        const coders = types.map((type) => this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_11__.ParamType.from(type)));\r\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_3__.TupleCoder(coders, \"_\");\r\n        return coder.defaultValue();\r\n    }\r\n    /**\r\n     *  Encode the %%values%% as the %%types%% into ABI data.\r\n     *\r\n     *  @returns DataHexstring\r\n     */\r\n    encode(types, values) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgumentCount)(values.length, types.length, \"types/values length mismatch\");\r\n        const coders = types.map((type) => this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_11__.ParamType.from(type)));\r\n        const coder = (new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_3__.TupleCoder(coders, \"_\"));\r\n        const writer = new _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_12__.Writer();\r\n        coder.encode(writer, values);\r\n        return writer.data;\r\n    }\r\n    /**\r\n     *  Decode the ABI %%data%% as the %%types%% into values.\r\n     *\r\n     *  If %%loose%% decoding is enabled, then strict padding is\r\n     *  not enforced. Some older versions of Solidity incorrectly\r\n     *  padded event data emitted from ``external`` functions.\r\n     */\r\n    decode(types, data, loose) {\r\n        const coders = types.map((type) => this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_11__.ParamType.from(type)));\r\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_3__.TupleCoder(coders, \"_\");\r\n        return coder.decode(new _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_12__.Reader(data, loose, defaultMaxInflation));\r\n    }\r\n    static _setDefaultMaxInflation(value) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (value) === \"number\" && Number.isInteger(value), \"invalid defaultMaxInflation factor\", \"value\", value);\r\n        defaultMaxInflation = value;\r\n    }\r\n    /**\r\n     *  Returns the shared singleton instance of a default [[AbiCoder]].\r\n     *\r\n     *  On the first call, the instance is created internally.\r\n     */\r\n    static defaultAbiCoder() {\r\n        if (defaultCoder == null) {\r\n            defaultCoder = new AbiCoder();\r\n        }\r\n        return defaultCoder;\r\n    }\r\n    /**\r\n     *  Returns an ethers-compatible [[CallExceptionError]] Error for the given\r\n     *  result %%data%% for the [[CallExceptionAction]] %%action%% against\r\n     *  the Transaction %%tx%%.\r\n     */\r\n    static getBuiltinCallException(action, tx, data) {\r\n        return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());\r\n    }\r\n}\r\n//# sourceMappingURL=abi-coder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvYWJpLWNvZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDd0U7QUFDWjtBQUNUO0FBQ0o7QUFDSTtBQUNKO0FBQ1c7QUFDYjtBQUNJO0FBQ0E7QUFDRjtBQUNKO0FBQ007QUFDZ0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5REFBUTtBQUM5QixlQUFlLHdEQUFPO0FBQ3RCO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLGlCQUFpQix3REFBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvQ0FBb0MsR0FBRyxLQUFLO0FBQ3JGLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZEQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2REFBVTtBQUNyQztBQUNBLFdBQVcsMERBQVM7QUFDcEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHVCQUF1Qix3REFBVTtBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLHdEQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0REFBWTtBQUN2QztBQUNBLDJCQUEyQiw0REFBWTtBQUN2QztBQUNBLDJCQUEyQiwwREFBVztBQUN0QztBQUNBLDJCQUEyQix3REFBVTtBQUNyQztBQUNBLDJCQUEyQixzREFBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBYztBQUMxQix1QkFBdUIsMERBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQWM7QUFDMUIsdUJBQXVCLG9FQUFlO0FBQ3RDO0FBQ0EsUUFBUSwrREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHFEQUFTO0FBQ25FLDBCQUEwQix3REFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvRUFBbUI7QUFDM0IsMERBQTBELHFEQUFTO0FBQ25FLDJCQUEyQix3REFBVTtBQUNyQywyQkFBMkIsOERBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxxREFBUztBQUNuRSwwQkFBMEIsd0RBQVU7QUFDcEMsZ0NBQWdDLDhEQUFNO0FBQ3RDO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcYWJpXFxhYmktY29kZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqICBXaGVuIHNlbmRpbmcgdmFsdWVzIHRvIG9yIHJlY2VpdmluZyB2YWx1ZXMgZnJvbSBhIFtbQ29udHJhY3RdXSwgdGhlXHJcbiAqICBkYXRhIGlzIGdlbmVyYWxseSBlbmNvZGVkIHVzaW5nIHRoZSBbQUJJIHN0YW5kYXJkXShsaW5rLXNvbGMtYWJpKS5cclxuICpcclxuICogIFRoZSBBYmlDb2RlciBwcm92aWRlcyBhIHV0aWxpdHkgdG8gZW5jb2RlIHZhbHVlcyB0byBBQkkgZGF0YSBhbmRcclxuICogIGRlY29kZSB2YWx1ZXMgZnJvbSBBQkkgZGF0YS5cclxuICpcclxuICogIE1vc3Qgb2YgdGhlIHRpbWUsIGRldmVsb3BlcnMgc2hvdWxkIGZhdm91ciB0aGUgW1tDb250cmFjdF1dIGNsYXNzLFxyXG4gKiAgd2hpY2ggZnVydGhlciBhYnN0cmFjdHMgYSBsb3Qgb2YgdGhlIGZpbmVyIGRldGFpbHMgb2YgQUJJIGRhdGEuXHJcbiAqXHJcbiAqICBAX3NlY3Rpb24gYXBpL2FiaS9hYmktY29kZXI6QUJJIEVuY29kaW5nXHJcbiAqL1xyXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvRXRoZXJldW0tQ29udHJhY3QtQUJJXHJcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50Q291bnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IFJlYWRlciwgV3JpdGVyIH0gZnJvbSBcIi4vY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzXCI7XHJcbmltcG9ydCB7IEFkZHJlc3NDb2RlciB9IGZyb20gXCIuL2NvZGVycy9hZGRyZXNzLmpzXCI7XHJcbmltcG9ydCB7IEFycmF5Q29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYXJyYXkuanNcIjtcclxuaW1wb3J0IHsgQm9vbGVhbkNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2Jvb2xlYW4uanNcIjtcclxuaW1wb3J0IHsgQnl0ZXNDb2RlciB9IGZyb20gXCIuL2NvZGVycy9ieXRlcy5qc1wiO1xyXG5pbXBvcnQgeyBGaXhlZEJ5dGVzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvZml4ZWQtYnl0ZXMuanNcIjtcclxuaW1wb3J0IHsgTnVsbENvZGVyIH0gZnJvbSBcIi4vY29kZXJzL251bGwuanNcIjtcclxuaW1wb3J0IHsgTnVtYmVyQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvbnVtYmVyLmpzXCI7XHJcbmltcG9ydCB7IFN0cmluZ0NvZGVyIH0gZnJvbSBcIi4vY29kZXJzL3N0cmluZy5qc1wiO1xyXG5pbXBvcnQgeyBUdXBsZUNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL3R1cGxlLmpzXCI7XHJcbmltcG9ydCB7IFBhcmFtVHlwZSB9IGZyb20gXCIuL2ZyYWdtZW50cy5qc1wiO1xyXG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnksIG1ha2VFcnJvciB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG4vLyBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi92MC44LjE3L2NvbnRyb2wtc3RydWN0dXJlcy5odG1sXHJcbmNvbnN0IFBhbmljUmVhc29ucyA9IG5ldyBNYXAoKTtcclxuUGFuaWNSZWFzb25zLnNldCgweDAwLCBcIkdFTkVSSUNfUEFOSUNcIik7XHJcblBhbmljUmVhc29ucy5zZXQoMHgwMSwgXCJBU1NFUlRfRkFMU0VcIik7XHJcblBhbmljUmVhc29ucy5zZXQoMHgxMSwgXCJPVkVSRkxPV1wiKTtcclxuUGFuaWNSZWFzb25zLnNldCgweDEyLCBcIkRJVklERV9CWV9aRVJPXCIpO1xyXG5QYW5pY1JlYXNvbnMuc2V0KDB4MjEsIFwiRU5VTV9SQU5HRV9FUlJPUlwiKTtcclxuUGFuaWNSZWFzb25zLnNldCgweDIyLCBcIkJBRF9TVE9SQUdFX0RBVEFcIik7XHJcblBhbmljUmVhc29ucy5zZXQoMHgzMSwgXCJTVEFDS19VTkRFUkZMT1dcIik7XHJcblBhbmljUmVhc29ucy5zZXQoMHgzMiwgXCJBUlJBWV9SQU5HRV9FUlJPUlwiKTtcclxuUGFuaWNSZWFzb25zLnNldCgweDQxLCBcIk9VVF9PRl9NRU1PUllcIik7XHJcblBhbmljUmVhc29ucy5zZXQoMHg1MSwgXCJVTklOSVRJQUxJWkVEX0ZVTkNUSU9OX0NBTExcIik7XHJcbmNvbnN0IHBhcmFtVHlwZUJ5dGVzID0gbmV3IFJlZ0V4cCgvXmJ5dGVzKFswLTldKikkLyk7XHJcbmNvbnN0IHBhcmFtVHlwZU51bWJlciA9IG5ldyBSZWdFeHAoL14odT9pbnQpKFswLTldKikkLyk7XHJcbmxldCBkZWZhdWx0Q29kZXIgPSBudWxsO1xyXG5sZXQgZGVmYXVsdE1heEluZmxhdGlvbiA9IDEwMjQ7XHJcbmZ1bmN0aW9uIGdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKGFjdGlvbiwgdHgsIGRhdGEsIGFiaUNvZGVyKSB7XHJcbiAgICBsZXQgbWVzc2FnZSA9IFwibWlzc2luZyByZXZlcnQgZGF0YVwiO1xyXG4gICAgbGV0IHJlYXNvbiA9IG51bGw7XHJcbiAgICBjb25zdCBpbnZvY2F0aW9uID0gbnVsbDtcclxuICAgIGxldCByZXZlcnQgPSBudWxsO1xyXG4gICAgaWYgKGRhdGEpIHtcclxuICAgICAgICBtZXNzYWdlID0gXCJleGVjdXRpb24gcmV2ZXJ0ZWRcIjtcclxuICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xyXG4gICAgICAgIGRhdGEgPSBoZXhsaWZ5KGRhdGEpO1xyXG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAobm8gZGF0YSBwcmVzZW50OyBsaWtlbHkgcmVxdWlyZShmYWxzZSkgb2NjdXJyZWRcIjtcclxuICAgICAgICAgICAgcmVhc29uID0gXCJyZXF1aXJlKGZhbHNlKVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggJSAzMiAhPT0gNCkge1xyXG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChjb3VsZCBub3QgZGVjb2RlIHJlYXNvbjsgaW52YWxpZCBkYXRhIGxlbmd0aClcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgPT09IFwiMHgwOGMzNzlhMFwiKSB7XHJcbiAgICAgICAgICAgIC8vIEVycm9yKHN0cmluZylcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJlYXNvbiA9IGFiaUNvZGVyLmRlY29kZShbXCJzdHJpbmdcIl0sIGJ5dGVzLnNsaWNlKDQpKVswXTtcclxuICAgICAgICAgICAgICAgIHJldmVydCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiRXJyb3Ioc3RyaW5nKVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiRXJyb3JcIixcclxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVhc29uXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYDogJHtKU09OLnN0cmluZ2lmeShyZWFzb24pfWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIChjb3VsZCBub3QgZGVjb2RlIHJlYXNvbjsgaW52YWxpZCBzdHJpbmcgZGF0YSlcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDQpKSA9PT0gXCIweDRlNDg3YjcxXCIpIHtcclxuICAgICAgICAgICAgLy8gUGFuaWModWludDI1NilcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBOdW1iZXIoYWJpQ29kZXIuZGVjb2RlKFtcInVpbnQyNTZcIl0sIGJ5dGVzLnNsaWNlKDQpKVswXSk7XHJcbiAgICAgICAgICAgICAgICByZXZlcnQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIlBhbmljKHVpbnQyNTYpXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJQYW5pY1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtjb2RlXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJlYXNvbiA9IGBQYW5pYyBkdWUgdG8gJHtQYW5pY1JlYXNvbnMuZ2V0KGNvZGUpIHx8IFwiVU5LTk9XTlwifSgke2NvZGV9KWA7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGA6ICR7cmVhc29ufWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIChjb3VsZCBub3QgZGVjb2RlIHBhbmljIGNvZGUpXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKHVua25vd24gY3VzdG9tIGVycm9yKVwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0ge1xyXG4gICAgICAgIHRvOiAodHgudG8gPyBnZXRBZGRyZXNzKHR4LnRvKSA6IG51bGwpLFxyXG4gICAgICAgIGRhdGE6ICh0eC5kYXRhIHx8IFwiMHhcIilcclxuICAgIH07XHJcbiAgICBpZiAodHguZnJvbSkge1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLmZyb20gPSBnZXRBZGRyZXNzKHR4LmZyb20pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1ha2VFcnJvcihtZXNzYWdlLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcclxuICAgICAgICBhY3Rpb24sIGRhdGEsIHJlYXNvbiwgdHJhbnNhY3Rpb24sIGludm9jYXRpb24sIHJldmVydFxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqICBUaGUgKipBYmlDb2RlcioqIGlzIGEgbG93LWxldmVsIGNsYXNzIHJlc3BvbnNpYmxlIGZvciBlbmNvZGluZyBKYXZhU2NyaXB0XHJcbiAqICB2YWx1ZXMgaW50byBiaW5hcnkgZGF0YSBhbmQgZGVjb2RpbmcgYmluYXJ5IGRhdGEgaW50byBKYXZhU2NyaXB0IHZhbHVlcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBBYmlDb2RlciB7XHJcbiAgICAjZ2V0Q29kZXIocGFyYW0pIHtcclxuICAgICAgICBpZiAocGFyYW0uaXNBcnJheSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlDb2Rlcih0aGlzLiNnZXRDb2RlcihwYXJhbS5hcnJheUNoaWxkcmVuKSwgcGFyYW0uYXJyYXlMZW5ndGgsIHBhcmFtLm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFyYW0uaXNUdXBsZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHVwbGVDb2RlcihwYXJhbS5jb21wb25lbnRzLm1hcCgoYykgPT4gdGhpcy4jZ2V0Q29kZXIoYykpLCBwYXJhbS5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoIChwYXJhbS5iYXNlVHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzQ29kZXIocGFyYW0ubmFtZSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJib29sXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5Db2RlcihwYXJhbS5uYW1lKTtcclxuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdDb2RlcihwYXJhbS5uYW1lKTtcclxuICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVzQ29kZXIocGFyYW0ubmFtZSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTnVsbENvZGVyKHBhcmFtLm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB1P2ludFswLTldKlxyXG4gICAgICAgIGxldCBtYXRjaCA9IHBhcmFtLnR5cGUubWF0Y2gocGFyYW1UeXBlTnVtYmVyKTtcclxuICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsyXSB8fCBcIjI1NlwiKTtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2l6ZSAhPT0gMCAmJiBzaXplIDw9IDI1NiAmJiAoc2l6ZSAlIDgpID09PSAwLCBcImludmFsaWQgXCIgKyBtYXRjaFsxXSArIFwiIGJpdCBsZW5ndGhcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29kZXIoc2l6ZSAvIDgsIChtYXRjaFsxXSA9PT0gXCJpbnRcIiksIHBhcmFtLm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBieXRlc1swLTldK1xyXG4gICAgICAgIG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVCeXRlcyk7XHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzaXplICE9PSAwICYmIHNpemUgPD0gMzIsIFwiaW52YWxpZCBieXRlcyBsZW5ndGhcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRml4ZWRCeXRlc0NvZGVyKHNpemUsIHBhcmFtLm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHR5cGVcIiwgXCJ0eXBlXCIsIHBhcmFtLnR5cGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgR2V0IHRoZSBkZWZhdWx0IHZhbHVlcyBmb3IgdGhlIGdpdmVuICUldHlwZXMlJS5cclxuICAgICAqXHJcbiAgICAgKiAgRm9yIGV4YW1wbGUsIGEgYGB1aW50YGAgaXMgYnkgZGVmYXVsdCBgYDBgYCBhbmQgYGBib29sYGBcclxuICAgICAqICBpcyBieSBkZWZhdWx0IGBgZmFsc2VgYC5cclxuICAgICAqL1xyXG4gICAgZ2V0RGVmYXVsdFZhbHVlKHR5cGVzKSB7XHJcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLiNnZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xyXG4gICAgICAgIGNvbnN0IGNvZGVyID0gbmV3IFR1cGxlQ29kZXIoY29kZXJzLCBcIl9cIik7XHJcbiAgICAgICAgcmV0dXJuIGNvZGVyLmRlZmF1bHRWYWx1ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgRW5jb2RlIHRoZSAlJXZhbHVlcyUlIGFzIHRoZSAlJXR5cGVzJSUgaW50byBBQkkgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xyXG4gICAgICovXHJcbiAgICBlbmNvZGUodHlwZXMsIHZhbHVlcykge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50Q291bnQodmFsdWVzLmxlbmd0aCwgdHlwZXMubGVuZ3RoLCBcInR5cGVzL3ZhbHVlcyBsZW5ndGggbWlzbWF0Y2hcIik7XHJcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLiNnZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xyXG4gICAgICAgIGNvbnN0IGNvZGVyID0gKG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpKTtcclxuICAgICAgICBjb25zdCB3cml0ZXIgPSBuZXcgV3JpdGVyKCk7XHJcbiAgICAgICAgY29kZXIuZW5jb2RlKHdyaXRlciwgdmFsdWVzKTtcclxuICAgICAgICByZXR1cm4gd3JpdGVyLmRhdGE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBEZWNvZGUgdGhlIEFCSSAlJWRhdGElJSBhcyB0aGUgJSV0eXBlcyUlIGludG8gdmFsdWVzLlxyXG4gICAgICpcclxuICAgICAqICBJZiAlJWxvb3NlJSUgZGVjb2RpbmcgaXMgZW5hYmxlZCwgdGhlbiBzdHJpY3QgcGFkZGluZyBpc1xyXG4gICAgICogIG5vdCBlbmZvcmNlZC4gU29tZSBvbGRlciB2ZXJzaW9ucyBvZiBTb2xpZGl0eSBpbmNvcnJlY3RseVxyXG4gICAgICogIHBhZGRlZCBldmVudCBkYXRhIGVtaXR0ZWQgZnJvbSBgYGV4dGVybmFsYGAgZnVuY3Rpb25zLlxyXG4gICAgICovXHJcbiAgICBkZWNvZGUodHlwZXMsIGRhdGEsIGxvb3NlKSB7XHJcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLiNnZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xyXG4gICAgICAgIGNvbnN0IGNvZGVyID0gbmV3IFR1cGxlQ29kZXIoY29kZXJzLCBcIl9cIik7XHJcbiAgICAgICAgcmV0dXJuIGNvZGVyLmRlY29kZShuZXcgUmVhZGVyKGRhdGEsIGxvb3NlLCBkZWZhdWx0TWF4SW5mbGF0aW9uKSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX3NldERlZmF1bHRNYXhJbmZsYXRpb24odmFsdWUpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiAmJiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSwgXCJpbnZhbGlkIGRlZmF1bHRNYXhJbmZsYXRpb24gZmFjdG9yXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgICAgIGRlZmF1bHRNYXhJbmZsYXRpb24gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIHNoYXJlZCBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgYSBkZWZhdWx0IFtbQWJpQ29kZXJdXS5cclxuICAgICAqXHJcbiAgICAgKiAgT24gdGhlIGZpcnN0IGNhbGwsIHRoZSBpbnN0YW5jZSBpcyBjcmVhdGVkIGludGVybmFsbHkuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkZWZhdWx0QWJpQ29kZXIoKSB7XHJcbiAgICAgICAgaWYgKGRlZmF1bHRDb2RlciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRlZmF1bHRDb2RlciA9IG5ldyBBYmlDb2RlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmYXVsdENvZGVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhbiBldGhlcnMtY29tcGF0aWJsZSBbW0NhbGxFeGNlcHRpb25FcnJvcl1dIEVycm9yIGZvciB0aGUgZ2l2ZW5cclxuICAgICAqICByZXN1bHQgJSVkYXRhJSUgZm9yIHRoZSBbW0NhbGxFeGNlcHRpb25BY3Rpb25dXSAlJWFjdGlvbiUlIGFnYWluc3RcclxuICAgICAqICB0aGUgVHJhbnNhY3Rpb24gJSV0eCUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oYWN0aW9uLCB0eCwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihhY3Rpb24sIHR4LCBkYXRhLCBBYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXIoKSk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJpLWNvZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/abi-coder.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/bytes32.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/bytes32.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBytes32String: () => (/* binding */ decodeBytes32String),\n/* harmony export */   encodeBytes32String: () => (/* binding */ encodeBytes32String)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/**\r\n *  About bytes32 strings...\r\n *\r\n *  @_docloc: api/utils:Bytes32 Strings\r\n */\r\n\r\n/**\r\n *  Encodes %%text%% as a Bytes32 string.\r\n */\r\nfunction encodeBytes32String(text) {\r\n    // Get the bytes\r\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(text);\r\n    // Check we have room for null-termination\r\n    if (bytes.length > 31) {\r\n        throw new Error(\"bytes32 string must be less than 32 bytes\");\r\n    }\r\n    // Zero-pad (implicitly null-terminates)\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadBytes)(bytes, 32);\r\n}\r\n/**\r\n *  Encodes the Bytes32-encoded %%bytes%% into a string.\r\n */\r\nfunction decodeBytes32String(_bytes) {\r\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(_bytes, \"bytes\");\r\n    // Must be 32 bytes with a null-termination\r\n    if (data.length !== 32) {\r\n        throw new Error(\"invalid bytes32 - not 32 bytes long\");\r\n    }\r\n    if (data[31] !== 0) {\r\n        throw new Error(\"invalid bytes32 string - no null terminator\");\r\n    }\r\n    // Find the null termination\r\n    let length = 31;\r\n    while (data[length - 1] === 0) {\r\n        length--;\r\n    }\r\n    // Determine the string value\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8String)(data.slice(0, length));\r\n}\r\n//# sourceMappingURL=bytes32.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvYnl0ZXMzMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrQkFBa0IsNERBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQix5REFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQVk7QUFDdkI7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxhYmlcXGJ5dGVzMzIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqICBBYm91dCBieXRlczMyIHN0cmluZ3MuLi5cclxuICpcclxuICogIEBfZG9jbG9jOiBhcGkvdXRpbHM6Qnl0ZXMzMiBTdHJpbmdzXHJcbiAqL1xyXG5pbXBvcnQgeyBnZXRCeXRlcywgdG9VdGY4Qnl0ZXMsIHRvVXRmOFN0cmluZywgemVyb1BhZEJ5dGVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbi8qKlxyXG4gKiAgRW5jb2RlcyAlJXRleHQlJSBhcyBhIEJ5dGVzMzIgc3RyaW5nLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJ5dGVzMzJTdHJpbmcodGV4dCkge1xyXG4gICAgLy8gR2V0IHRoZSBieXRlc1xyXG4gICAgY29uc3QgYnl0ZXMgPSB0b1V0ZjhCeXRlcyh0ZXh0KTtcclxuICAgIC8vIENoZWNrIHdlIGhhdmUgcm9vbSBmb3IgbnVsbC10ZXJtaW5hdGlvblxyXG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA+IDMxKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnl0ZXMzMiBzdHJpbmcgbXVzdCBiZSBsZXNzIHRoYW4gMzIgYnl0ZXNcIik7XHJcbiAgICB9XHJcbiAgICAvLyBaZXJvLXBhZCAoaW1wbGljaXRseSBudWxsLXRlcm1pbmF0ZXMpXHJcbiAgICByZXR1cm4gemVyb1BhZEJ5dGVzKGJ5dGVzLCAzMik7XHJcbn1cclxuLyoqXHJcbiAqICBFbmNvZGVzIHRoZSBCeXRlczMyLWVuY29kZWQgJSVieXRlcyUlIGludG8gYSBzdHJpbmcuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQnl0ZXMzMlN0cmluZyhfYnl0ZXMpIHtcclxuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfYnl0ZXMsIFwiYnl0ZXNcIik7XHJcbiAgICAvLyBNdXN0IGJlIDMyIGJ5dGVzIHdpdGggYSBudWxsLXRlcm1pbmF0aW9uXHJcbiAgICBpZiAoZGF0YS5sZW5ndGggIT09IDMyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBieXRlczMyIC0gbm90IDMyIGJ5dGVzIGxvbmdcIik7XHJcbiAgICB9XHJcbiAgICBpZiAoZGF0YVszMV0gIT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ5dGVzMzIgc3RyaW5nIC0gbm8gbnVsbCB0ZXJtaW5hdG9yXCIpO1xyXG4gICAgfVxyXG4gICAgLy8gRmluZCB0aGUgbnVsbCB0ZXJtaW5hdGlvblxyXG4gICAgbGV0IGxlbmd0aCA9IDMxO1xyXG4gICAgd2hpbGUgKGRhdGFbbGVuZ3RoIC0gMV0gPT09IDApIHtcclxuICAgICAgICBsZW5ndGgtLTtcclxuICAgIH1cclxuICAgIC8vIERldGVybWluZSB0aGUgc3RyaW5nIHZhbHVlXHJcbiAgICByZXR1cm4gdG9VdGY4U3RyaW5nKGRhdGEuc2xpY2UoMCwgbGVuZ3RoKSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMzMi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/bytes32.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Coder: () => (/* binding */ Coder),\n/* harmony export */   Reader: () => (/* binding */ Reader),\n/* harmony export */   Result: () => (/* binding */ Result),\n/* harmony export */   WordSize: () => (/* binding */ WordSize),\n/* harmony export */   Writer: () => (/* binding */ Writer),\n/* harmony export */   checkResultErrors: () => (/* binding */ checkResultErrors)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n\r\n/**\r\n * @_ignore:\r\n */\r\nconst WordSize = 32;\r\nconst Padding = new Uint8Array(WordSize);\r\n// Properties used to immediate pass through to the underlying object\r\n// - `then` is used to detect if an object is a Promise for await\r\nconst passProperties = [\"then\"];\r\nconst _guard = {};\r\nconst resultNames = new WeakMap();\r\nfunction getNames(result) {\r\n    return resultNames.get(result);\r\n}\r\nfunction setNames(result, names) {\r\n    resultNames.set(result, names);\r\n}\r\nfunction throwError(name, error) {\r\n    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);\r\n    wrapped.error = error;\r\n    throw wrapped;\r\n}\r\nfunction toObject(names, items, deep) {\r\n    if (names.indexOf(null) >= 0) {\r\n        return items.map((item, index) => {\r\n            if (item instanceof Result) {\r\n                return toObject(getNames(item), item, deep);\r\n            }\r\n            return item;\r\n        });\r\n    }\r\n    return names.reduce((accum, name, index) => {\r\n        let item = items.getValue(name);\r\n        if (!(name in accum)) {\r\n            if (deep && item instanceof Result) {\r\n                item = toObject(getNames(item), item, deep);\r\n            }\r\n            accum[name] = item;\r\n        }\r\n        return accum;\r\n    }, {});\r\n}\r\n/**\r\n *  A [[Result]] is a sub-class of Array, which allows accessing any\r\n *  of its values either positionally by its index or, if keys are\r\n *  provided by its name.\r\n *\r\n *  @_docloc: api/abi\r\n */\r\nclass Result extends Array {\r\n    // No longer used; but cannot be removed as it will remove the\r\n    // #private field from the .d.ts which may break backwards\r\n    // compatibility\r\n    #names;\r\n    /**\r\n     *  @private\r\n     */\r\n    constructor(...args) {\r\n        // To properly sub-class Array so the other built-in\r\n        // functions work, the constructor has to behave fairly\r\n        // well. So, in the event we are created via fromItems()\r\n        // we build the read-only Result object we want, but on\r\n        // any other input, we use the default constructor\r\n        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\r\n        const guard = args[0];\r\n        let items = args[1];\r\n        let names = (args[2] || []).slice();\r\n        let wrap = true;\r\n        if (guard !== _guard) {\r\n            items = args;\r\n            names = [];\r\n            wrap = false;\r\n        }\r\n        // Can't just pass in ...items since an array of length 1\r\n        // is a special case in the super.\r\n        super(items.length);\r\n        items.forEach((item, index) => { this[index] = item; });\r\n        // Find all unique keys\r\n        const nameCounts = names.reduce((accum, name) => {\r\n            if (typeof (name) === \"string\") {\r\n                accum.set(name, (accum.get(name) || 0) + 1);\r\n            }\r\n            return accum;\r\n        }, (new Map()));\r\n        // Remove any key thats not unique\r\n        setNames(this, Object.freeze(items.map((item, index) => {\r\n            const name = names[index];\r\n            if (name != null && nameCounts.get(name) === 1) {\r\n                return name;\r\n            }\r\n            return null;\r\n        })));\r\n        // Dummy operations to prevent TypeScript from complaining\r\n        this.#names = [];\r\n        if (this.#names == null) {\r\n            void (this.#names);\r\n        }\r\n        if (!wrap) {\r\n            return;\r\n        }\r\n        // A wrapped Result is immutable\r\n        Object.freeze(this);\r\n        // Proxy indices and names so we can trap deferred errors\r\n        const proxy = new Proxy(this, {\r\n            get: (target, prop, receiver) => {\r\n                if (typeof (prop) === \"string\") {\r\n                    // Index accessor\r\n                    if (prop.match(/^[0-9]+$/)) {\r\n                        const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(prop, \"%index\");\r\n                        if (index < 0 || index >= this.length) {\r\n                            throw new RangeError(\"out of result range\");\r\n                        }\r\n                        const item = target[index];\r\n                        if (item instanceof Error) {\r\n                            throwError(`index ${index}`, item);\r\n                        }\r\n                        return item;\r\n                    }\r\n                    // Pass important checks (like `then` for Promise) through\r\n                    if (passProperties.indexOf(prop) >= 0) {\r\n                        return Reflect.get(target, prop, receiver);\r\n                    }\r\n                    const value = target[prop];\r\n                    if (value instanceof Function) {\r\n                        // Make sure functions work with private variables\r\n                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\r\n                        return function (...args) {\r\n                            return value.apply((this === receiver) ? target : this, args);\r\n                        };\r\n                    }\r\n                    else if (!(prop in target)) {\r\n                        // Possible name accessor\r\n                        return target.getValue.apply((this === receiver) ? target : this, [prop]);\r\n                    }\r\n                }\r\n                return Reflect.get(target, prop, receiver);\r\n            }\r\n        });\r\n        setNames(proxy, getNames(this));\r\n        return proxy;\r\n    }\r\n    /**\r\n     *  Returns the Result as a normal Array. If %%deep%%, any children\r\n     *  which are Result objects are also converted to a normal Array.\r\n     *\r\n     *  This will throw if there are any outstanding deferred\r\n     *  errors.\r\n     */\r\n    toArray(deep) {\r\n        const result = [];\r\n        this.forEach((item, index) => {\r\n            if (item instanceof Error) {\r\n                throwError(`index ${index}`, item);\r\n            }\r\n            if (deep && item instanceof Result) {\r\n                item = item.toArray(deep);\r\n            }\r\n            result.push(item);\r\n        });\r\n        return result;\r\n    }\r\n    /**\r\n     *  Returns the Result as an Object with each name-value pair. If\r\n     *  %%deep%%, any children which are Result objects are also\r\n     *  converted to an Object.\r\n     *\r\n     *  This will throw if any value is unnamed, or if there are\r\n     *  any outstanding deferred errors.\r\n     */\r\n    toObject(deep) {\r\n        const names = getNames(this);\r\n        return names.reduce((accum, name, index) => {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(name != null, `value at index ${index} unnamed`, \"UNSUPPORTED_OPERATION\", {\r\n                operation: \"toObject()\"\r\n            });\r\n            return toObject(names, this, deep);\r\n        }, {});\r\n    }\r\n    /**\r\n     *  @_ignore\r\n     */\r\n    slice(start, end) {\r\n        if (start == null) {\r\n            start = 0;\r\n        }\r\n        if (start < 0) {\r\n            start += this.length;\r\n            if (start < 0) {\r\n                start = 0;\r\n            }\r\n        }\r\n        if (end == null) {\r\n            end = this.length;\r\n        }\r\n        if (end < 0) {\r\n            end += this.length;\r\n            if (end < 0) {\r\n                end = 0;\r\n            }\r\n        }\r\n        if (end > this.length) {\r\n            end = this.length;\r\n        }\r\n        const _names = getNames(this);\r\n        const result = [], names = [];\r\n        for (let i = start; i < end; i++) {\r\n            result.push(this[i]);\r\n            names.push(_names[i]);\r\n        }\r\n        return new Result(_guard, result, names);\r\n    }\r\n    /**\r\n     *  @_ignore\r\n     */\r\n    filter(callback, thisArg) {\r\n        const _names = getNames(this);\r\n        const result = [], names = [];\r\n        for (let i = 0; i < this.length; i++) {\r\n            const item = this[i];\r\n            if (item instanceof Error) {\r\n                throwError(`index ${i}`, item);\r\n            }\r\n            if (callback.call(thisArg, item, i, this)) {\r\n                result.push(item);\r\n                names.push(_names[i]);\r\n            }\r\n        }\r\n        return new Result(_guard, result, names);\r\n    }\r\n    /**\r\n     *  @_ignore\r\n     */\r\n    map(callback, thisArg) {\r\n        const result = [];\r\n        for (let i = 0; i < this.length; i++) {\r\n            const item = this[i];\r\n            if (item instanceof Error) {\r\n                throwError(`index ${i}`, item);\r\n            }\r\n            result.push(callback.call(thisArg, item, i, this));\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     *  Returns the value for %%name%%.\r\n     *\r\n     *  Since it is possible to have a key whose name conflicts with\r\n     *  a method on a [[Result]] or its superclass Array, or any\r\n     *  JavaScript keyword, this ensures all named values are still\r\n     *  accessible by name.\r\n     */\r\n    getValue(name) {\r\n        const index = getNames(this).indexOf(name);\r\n        if (index === -1) {\r\n            return undefined;\r\n        }\r\n        const value = this[index];\r\n        if (value instanceof Error) {\r\n            throwError(`property ${JSON.stringify(name)}`, value.error);\r\n        }\r\n        return value;\r\n    }\r\n    /**\r\n     *  Creates a new [[Result]] for %%items%% with each entry\r\n     *  also accessible by its corresponding name in %%keys%%.\r\n     */\r\n    static fromItems(items, keys) {\r\n        return new Result(_guard, items, keys);\r\n    }\r\n}\r\n/**\r\n *  Returns all errors found in a [[Result]].\r\n *\r\n *  Since certain errors encountered when creating a [[Result]] do\r\n *  not impact the ability to continue parsing data, they are\r\n *  deferred until they are actually accessed. Hence a faulty string\r\n *  in an Event that is never used does not impact the program flow.\r\n *\r\n *  However, sometimes it may be useful to access, identify or\r\n *  validate correctness of a [[Result]].\r\n *\r\n *  @_docloc api/abi\r\n */\r\nfunction checkResultErrors(result) {\r\n    // Find the first error (if any)\r\n    const errors = [];\r\n    const checkErrors = function (path, object) {\r\n        if (!Array.isArray(object)) {\r\n            return;\r\n        }\r\n        for (let key in object) {\r\n            const childPath = path.slice();\r\n            childPath.push(key);\r\n            try {\r\n                checkErrors(childPath, object[key]);\r\n            }\r\n            catch (error) {\r\n                errors.push({ path: childPath, error: error });\r\n            }\r\n        }\r\n    };\r\n    checkErrors([], result);\r\n    return errors;\r\n}\r\nfunction getValue(value) {\r\n    let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(value);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(bytes.length <= WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", { buffer: bytes, length: WordSize, offset: bytes.length });\r\n    if (bytes.length !== WordSize) {\r\n        bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([Padding.slice(bytes.length % WordSize), bytes]));\r\n    }\r\n    return bytes;\r\n}\r\n/**\r\n *  @_ignore\r\n */\r\nclass Coder {\r\n    // The coder name:\r\n    //   - address, uint256, tuple, array, etc.\r\n    name;\r\n    // The fully expanded type, including composite types:\r\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\r\n    type;\r\n    // The localName bound in the signature, in this example it is \"baz\":\r\n    //   - tuple(address foo, uint bar) baz\r\n    localName;\r\n    // Whether this type is dynamic:\r\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\r\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\r\n    dynamic;\r\n    constructor(name, type, localName, dynamic) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { name, type, localName, dynamic }, {\r\n            name: \"string\", type: \"string\", localName: \"string\", dynamic: \"boolean\"\r\n        });\r\n    }\r\n    _throwError(message, value) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, message, this.localName, value);\r\n    }\r\n}\r\n/**\r\n *  @_ignore\r\n */\r\nclass Writer {\r\n    // An array of WordSize lengthed objects to concatenation\r\n    #data;\r\n    #dataLength;\r\n    constructor() {\r\n        this.#data = [];\r\n        this.#dataLength = 0;\r\n    }\r\n    get data() {\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(this.#data);\r\n    }\r\n    get length() { return this.#dataLength; }\r\n    #writeData(data) {\r\n        this.#data.push(data);\r\n        this.#dataLength += data.length;\r\n        return data.length;\r\n    }\r\n    appendWriter(writer) {\r\n        return this.#writeData((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(writer.data));\r\n    }\r\n    // Arrayish item; pad on the right to *nearest* WordSize\r\n    writeBytes(value) {\r\n        let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(value);\r\n        const paddingOffset = bytes.length % WordSize;\r\n        if (paddingOffset) {\r\n            bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([bytes, Padding.slice(paddingOffset)]));\r\n        }\r\n        return this.#writeData(bytes);\r\n    }\r\n    // Numeric item; pad on the left *to* WordSize\r\n    writeValue(value) {\r\n        return this.#writeData(getValue(value));\r\n    }\r\n    // Inserts a numeric place-holder, returning a callback that can\r\n    // be used to asjust the value later\r\n    writeUpdatableValue() {\r\n        const offset = this.#data.length;\r\n        this.#data.push(Padding);\r\n        this.#dataLength += WordSize;\r\n        return (value) => {\r\n            this.#data[offset] = getValue(value);\r\n        };\r\n    }\r\n}\r\n/**\r\n *  @_ignore\r\n */\r\nclass Reader {\r\n    // Allows incomplete unpadded data to be read; otherwise an error\r\n    // is raised if attempting to overrun the buffer. This is required\r\n    // to deal with an old Solidity bug, in which event data for\r\n    // external (not public thoguh) was tightly packed.\r\n    allowLoose;\r\n    #data;\r\n    #offset;\r\n    #bytesRead;\r\n    #parent;\r\n    #maxInflation;\r\n    constructor(data, allowLoose, maxInflation) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { allowLoose: !!allowLoose });\r\n        this.#data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(data);\r\n        this.#bytesRead = 0;\r\n        this.#parent = null;\r\n        this.#maxInflation = (maxInflation != null) ? maxInflation : 1024;\r\n        this.#offset = 0;\r\n    }\r\n    get data() { return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(this.#data); }\r\n    get dataLength() { return this.#data.length; }\r\n    get consumed() { return this.#offset; }\r\n    get bytes() { return new Uint8Array(this.#data); }\r\n    #incrementBytesRead(count) {\r\n        if (this.#parent) {\r\n            return this.#parent.#incrementBytesRead(count);\r\n        }\r\n        this.#bytesRead += count;\r\n        // Check for excessive inflation (see: #4537)\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https:/\\/github.com/ethers-io/ethers.js/issues/4537 )`, \"BUFFER_OVERRUN\", {\r\n            buffer: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(this.#data), offset: this.#offset,\r\n            length: count, info: {\r\n                bytesRead: this.#bytesRead,\r\n                dataLength: this.dataLength\r\n            }\r\n        });\r\n    }\r\n    #peekBytes(offset, length, loose) {\r\n        let alignedLength = Math.ceil(length / WordSize) * WordSize;\r\n        if (this.#offset + alignedLength > this.#data.length) {\r\n            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\r\n                alignedLength = length;\r\n            }\r\n            else {\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\r\n                    buffer: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(this.#data),\r\n                    length: this.#data.length,\r\n                    offset: this.#offset + alignedLength\r\n                });\r\n            }\r\n        }\r\n        return this.#data.slice(this.#offset, this.#offset + alignedLength);\r\n    }\r\n    // Create a sub-reader with the same underlying data, but offset\r\n    subReader(offset) {\r\n        const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);\r\n        reader.#parent = this;\r\n        return reader;\r\n    }\r\n    // Read bytes\r\n    readBytes(length, loose) {\r\n        let bytes = this.#peekBytes(0, length, !!loose);\r\n        this.#incrementBytesRead(length);\r\n        this.#offset += bytes.length;\r\n        // @TODO: Make sure the length..end bytes are all 0?\r\n        return bytes.slice(0, length);\r\n    }\r\n    // Read a numeric values\r\n    readValue() {\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBigInt)(this.readBytes(WordSize));\r\n    }\r\n    readIndex() {\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toNumber)(this.readBytes(WordSize));\r\n    }\r\n}\r\n//# sourceMappingURL=abstract-coder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFFK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixLQUFLO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHFCQUFxQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMERBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxNQUFNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFNLHNJQUFzSSxvQkFBb0I7QUFDeEssb0JBQW9CLDZEQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQU07QUFDdEIsNEJBQTRCLDZEQUFZO0FBQ3hDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQVE7QUFDdkI7QUFDQTtBQUNBLGVBQWUseURBQVE7QUFDdkI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXGFiaVxcY29kZXJzXFxhYnN0cmFjdC1jb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBjb25jYXQsIGdldEJ5dGVzQ29weSwgZ2V0TnVtYmVyLCBoZXhsaWZ5LCB0b0JlQXJyYXksIHRvQmlnSW50LCB0b051bWJlciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudFxyXG4vKiwgaXNFcnJvciovXHJcbiB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xyXG4vKipcclxuICogQF9pZ25vcmU6XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgV29yZFNpemUgPSAzMjtcclxuY29uc3QgUGFkZGluZyA9IG5ldyBVaW50OEFycmF5KFdvcmRTaXplKTtcclxuLy8gUHJvcGVydGllcyB1c2VkIHRvIGltbWVkaWF0ZSBwYXNzIHRocm91Z2ggdG8gdGhlIHVuZGVybHlpbmcgb2JqZWN0XHJcbi8vIC0gYHRoZW5gIGlzIHVzZWQgdG8gZGV0ZWN0IGlmIGFuIG9iamVjdCBpcyBhIFByb21pc2UgZm9yIGF3YWl0XHJcbmNvbnN0IHBhc3NQcm9wZXJ0aWVzID0gW1widGhlblwiXTtcclxuY29uc3QgX2d1YXJkID0ge307XHJcbmNvbnN0IHJlc3VsdE5hbWVzID0gbmV3IFdlYWtNYXAoKTtcclxuZnVuY3Rpb24gZ2V0TmFtZXMocmVzdWx0KSB7XHJcbiAgICByZXR1cm4gcmVzdWx0TmFtZXMuZ2V0KHJlc3VsdCk7XHJcbn1cclxuZnVuY3Rpb24gc2V0TmFtZXMocmVzdWx0LCBuYW1lcykge1xyXG4gICAgcmVzdWx0TmFtZXMuc2V0KHJlc3VsdCwgbmFtZXMpO1xyXG59XHJcbmZ1bmN0aW9uIHRocm93RXJyb3IobmFtZSwgZXJyb3IpIHtcclxuICAgIGNvbnN0IHdyYXBwZWQgPSBuZXcgRXJyb3IoYGRlZmVycmVkIGVycm9yIGR1cmluZyBBQkkgZGVjb2RpbmcgdHJpZ2dlcmVkIGFjY2Vzc2luZyAke25hbWV9YCk7XHJcbiAgICB3cmFwcGVkLmVycm9yID0gZXJyb3I7XHJcbiAgICB0aHJvdyB3cmFwcGVkO1xyXG59XHJcbmZ1bmN0aW9uIHRvT2JqZWN0KG5hbWVzLCBpdGVtcywgZGVlcCkge1xyXG4gICAgaWYgKG5hbWVzLmluZGV4T2YobnVsbCkgPj0gMCkge1xyXG4gICAgICAgIHJldHVybiBpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9PYmplY3QoZ2V0TmFtZXMoaXRlbSksIGl0ZW0sIGRlZXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5hbWVzLnJlZHVjZSgoYWNjdW0sIG5hbWUsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgbGV0IGl0ZW0gPSBpdGVtcy5nZXRWYWx1ZShuYW1lKTtcclxuICAgICAgICBpZiAoIShuYW1lIGluIGFjY3VtKSkge1xyXG4gICAgICAgICAgICBpZiAoZGVlcCAmJiBpdGVtIGluc3RhbmNlb2YgUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtID0gdG9PYmplY3QoZ2V0TmFtZXMoaXRlbSksIGl0ZW0sIGRlZXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjY3VtW25hbWVdID0gaXRlbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFjY3VtO1xyXG4gICAgfSwge30pO1xyXG59XHJcbi8qKlxyXG4gKiAgQSBbW1Jlc3VsdF1dIGlzIGEgc3ViLWNsYXNzIG9mIEFycmF5LCB3aGljaCBhbGxvd3MgYWNjZXNzaW5nIGFueVxyXG4gKiAgb2YgaXRzIHZhbHVlcyBlaXRoZXIgcG9zaXRpb25hbGx5IGJ5IGl0cyBpbmRleCBvciwgaWYga2V5cyBhcmVcclxuICogIHByb3ZpZGVkIGJ5IGl0cyBuYW1lLlxyXG4gKlxyXG4gKiAgQF9kb2Nsb2M6IGFwaS9hYmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBSZXN1bHQgZXh0ZW5kcyBBcnJheSB7XHJcbiAgICAvLyBObyBsb25nZXIgdXNlZDsgYnV0IGNhbm5vdCBiZSByZW1vdmVkIGFzIGl0IHdpbGwgcmVtb3ZlIHRoZVxyXG4gICAgLy8gI3ByaXZhdGUgZmllbGQgZnJvbSB0aGUgLmQudHMgd2hpY2ggbWF5IGJyZWFrIGJhY2t3YXJkc1xyXG4gICAgLy8gY29tcGF0aWJpbGl0eVxyXG4gICAgI25hbWVzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xyXG4gICAgICAgIC8vIFRvIHByb3Blcmx5IHN1Yi1jbGFzcyBBcnJheSBzbyB0aGUgb3RoZXIgYnVpbHQtaW5cclxuICAgICAgICAvLyBmdW5jdGlvbnMgd29yaywgdGhlIGNvbnN0cnVjdG9yIGhhcyB0byBiZWhhdmUgZmFpcmx5XHJcbiAgICAgICAgLy8gd2VsbC4gU28sIGluIHRoZSBldmVudCB3ZSBhcmUgY3JlYXRlZCB2aWEgZnJvbUl0ZW1zKClcclxuICAgICAgICAvLyB3ZSBidWlsZCB0aGUgcmVhZC1vbmx5IFJlc3VsdCBvYmplY3Qgd2Ugd2FudCwgYnV0IG9uXHJcbiAgICAgICAgLy8gYW55IG90aGVyIGlucHV0LCB3ZSB1c2UgdGhlIGRlZmF1bHQgY29uc3RydWN0b3JcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvcihndWFyZDogYW55LCBpdGVtczogQXJyYXk8YW55Piwga2V5cz86IEFycmF5PG51bGwgfCBzdHJpbmc+KTtcclxuICAgICAgICBjb25zdCBndWFyZCA9IGFyZ3NbMF07XHJcbiAgICAgICAgbGV0IGl0ZW1zID0gYXJnc1sxXTtcclxuICAgICAgICBsZXQgbmFtZXMgPSAoYXJnc1syXSB8fCBbXSkuc2xpY2UoKTtcclxuICAgICAgICBsZXQgd3JhcCA9IHRydWU7XHJcbiAgICAgICAgaWYgKGd1YXJkICE9PSBfZ3VhcmQpIHtcclxuICAgICAgICAgICAgaXRlbXMgPSBhcmdzO1xyXG4gICAgICAgICAgICBuYW1lcyA9IFtdO1xyXG4gICAgICAgICAgICB3cmFwID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbid0IGp1c3QgcGFzcyBpbiAuLi5pdGVtcyBzaW5jZSBhbiBhcnJheSBvZiBsZW5ndGggMVxyXG4gICAgICAgIC8vIGlzIGEgc3BlY2lhbCBjYXNlIGluIHRoZSBzdXBlci5cclxuICAgICAgICBzdXBlcihpdGVtcy5sZW5ndGgpO1xyXG4gICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7IHRoaXNbaW5kZXhdID0gaXRlbTsgfSk7XHJcbiAgICAgICAgLy8gRmluZCBhbGwgdW5pcXVlIGtleXNcclxuICAgICAgICBjb25zdCBuYW1lQ291bnRzID0gbmFtZXMucmVkdWNlKChhY2N1bSwgbmFtZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgYWNjdW0uc2V0KG5hbWUsIChhY2N1bS5nZXQobmFtZSkgfHwgMCkgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XHJcbiAgICAgICAgfSwgKG5ldyBNYXAoKSkpO1xyXG4gICAgICAgIC8vIFJlbW92ZSBhbnkga2V5IHRoYXRzIG5vdCB1bmlxdWVcclxuICAgICAgICBzZXROYW1lcyh0aGlzLCBPYmplY3QuZnJlZXplKGl0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2luZGV4XTtcclxuICAgICAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiBuYW1lQ291bnRzLmdldChuYW1lKSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSkpKTtcclxuICAgICAgICAvLyBEdW1teSBvcGVyYXRpb25zIHRvIHByZXZlbnQgVHlwZVNjcmlwdCBmcm9tIGNvbXBsYWluaW5nXHJcbiAgICAgICAgdGhpcy4jbmFtZXMgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy4jbmFtZXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2b2lkICh0aGlzLiNuYW1lcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghd3JhcCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEEgd3JhcHBlZCBSZXN1bHQgaXMgaW1tdXRhYmxlXHJcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcclxuICAgICAgICAvLyBQcm94eSBpbmRpY2VzIGFuZCBuYW1lcyBzbyB3ZSBjYW4gdHJhcCBkZWZlcnJlZCBlcnJvcnNcclxuICAgICAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0aGlzLCB7XHJcbiAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5kZXggYWNjZXNzb3JcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5tYXRjaCgvXlswLTldKyQvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldE51bWJlcihwcm9wLCBcIiVpbmRleFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmVzdWx0IHJhbmdlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0YXJnZXRbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2luZGV4fWAsIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIGltcG9ydGFudCBjaGVja3MgKGxpa2UgYHRoZW5gIGZvciBQcm9taXNlKSB0aHJvdWdoXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0W3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBmdW5jdGlvbnMgd29yayB3aXRoIHByaXZhdGUgdmFyaWFibGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJveHkjbm9fcHJpdmF0ZV9wcm9wZXJ0eV9mb3J3YXJkaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KCh0aGlzID09PSByZWNlaXZlcikgPyB0YXJnZXQgOiB0aGlzLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIShwcm9wIGluIHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9zc2libGUgbmFtZSBhY2Nlc3NvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmdldFZhbHVlLmFwcGx5KCh0aGlzID09PSByZWNlaXZlcikgPyB0YXJnZXQgOiB0aGlzLCBbcHJvcF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNldE5hbWVzKHByb3h5LCBnZXROYW1lcyh0aGlzKSk7XHJcbiAgICAgICAgcmV0dXJuIHByb3h5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgUmVzdWx0IGFzIGEgbm9ybWFsIEFycmF5LiBJZiAlJWRlZXAlJSwgYW55IGNoaWxkcmVuXHJcbiAgICAgKiAgd2hpY2ggYXJlIFJlc3VsdCBvYmplY3RzIGFyZSBhbHNvIGNvbnZlcnRlZCB0byBhIG5vcm1hbCBBcnJheS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIHRoZXJlIGFyZSBhbnkgb3V0c3RhbmRpbmcgZGVmZXJyZWRcclxuICAgICAqICBlcnJvcnMuXHJcbiAgICAgKi9cclxuICAgIHRvQXJyYXkoZGVlcCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpbmRleH1gLCBpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGVlcCAmJiBpdGVtIGluc3RhbmNlb2YgUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtID0gaXRlbS50b0FycmF5KGRlZXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRoZSBSZXN1bHQgYXMgYW4gT2JqZWN0IHdpdGggZWFjaCBuYW1lLXZhbHVlIHBhaXIuIElmXHJcbiAgICAgKiAgJSVkZWVwJSUsIGFueSBjaGlsZHJlbiB3aGljaCBhcmUgUmVzdWx0IG9iamVjdHMgYXJlIGFsc29cclxuICAgICAqICBjb252ZXJ0ZWQgdG8gYW4gT2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgaWYgYW55IHZhbHVlIGlzIHVubmFtZWQsIG9yIGlmIHRoZXJlIGFyZVxyXG4gICAgICogIGFueSBvdXRzdGFuZGluZyBkZWZlcnJlZCBlcnJvcnMuXHJcbiAgICAgKi9cclxuICAgIHRvT2JqZWN0KGRlZXApIHtcclxuICAgICAgICBjb25zdCBuYW1lcyA9IGdldE5hbWVzKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBuYW1lcy5yZWR1Y2UoKGFjY3VtLCBuYW1lLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBhc3NlcnQobmFtZSAhPSBudWxsLCBgdmFsdWUgYXQgaW5kZXggJHtpbmRleH0gdW5uYW1lZGAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b09iamVjdCgpXCJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0b09iamVjdChuYW1lcywgdGhpcywgZGVlcCk7XHJcbiAgICAgICAgfSwge30pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmVcclxuICAgICAqL1xyXG4gICAgc2xpY2Uoc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIGlmIChzdGFydCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xyXG4gICAgICAgICAgICBzdGFydCArPSB0aGlzLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuZCA8IDApIHtcclxuICAgICAgICAgICAgZW5kICs9IHRoaXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoZW5kIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IF9uYW1lcyA9IGdldE5hbWVzKHRoaXMpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdLCBuYW1lcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXNbaV0pO1xyXG4gICAgICAgICAgICBuYW1lcy5wdXNoKF9uYW1lc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KF9ndWFyZCwgcmVzdWx0LCBuYW1lcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBAX2lnbm9yZVxyXG4gICAgICovXHJcbiAgICBmaWx0ZXIoY2FsbGJhY2ssIHRoaXNBcmcpIHtcclxuICAgICAgICBjb25zdCBfbmFtZXMgPSBnZXROYW1lcyh0aGlzKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXSwgbmFtZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXNbaV07XHJcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aX1gLCBpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBpdGVtLCBpLCB0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKF9uYW1lc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoX2d1YXJkLCByZXN1bHQsIG5hbWVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEBfaWdub3JlXHJcbiAgICAgKi9cclxuICAgIG1hcChjYWxsYmFjaywgdGhpc0FyZykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpc1tpXTtcclxuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpfWAsIGl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNhbGxiYWNrLmNhbGwodGhpc0FyZywgaXRlbSwgaSwgdGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgdmFsdWUgZm9yICUlbmFtZSUlLlxyXG4gICAgICpcclxuICAgICAqICBTaW5jZSBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIGEga2V5IHdob3NlIG5hbWUgY29uZmxpY3RzIHdpdGhcclxuICAgICAqICBhIG1ldGhvZCBvbiBhIFtbUmVzdWx0XV0gb3IgaXRzIHN1cGVyY2xhc3MgQXJyYXksIG9yIGFueVxyXG4gICAgICogIEphdmFTY3JpcHQga2V5d29yZCwgdGhpcyBlbnN1cmVzIGFsbCBuYW1lZCB2YWx1ZXMgYXJlIHN0aWxsXHJcbiAgICAgKiAgYWNjZXNzaWJsZSBieSBuYW1lLlxyXG4gICAgICovXHJcbiAgICBnZXRWYWx1ZShuYW1lKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXROYW1lcyh0aGlzKS5pbmRleE9mKG5hbWUpO1xyXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2luZGV4XTtcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIHZhbHVlLmVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW1Jlc3VsdF1dIGZvciAlJWl0ZW1zJSUgd2l0aCBlYWNoIGVudHJ5XHJcbiAgICAgKiAgYWxzbyBhY2Nlc3NpYmxlIGJ5IGl0cyBjb3JyZXNwb25kaW5nIG5hbWUgaW4gJSVrZXlzJSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tSXRlbXMoaXRlbXMsIGtleXMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChfZ3VhcmQsIGl0ZW1zLCBrZXlzKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIFJldHVybnMgYWxsIGVycm9ycyBmb3VuZCBpbiBhIFtbUmVzdWx0XV0uXHJcbiAqXHJcbiAqICBTaW5jZSBjZXJ0YWluIGVycm9ycyBlbmNvdW50ZXJlZCB3aGVuIGNyZWF0aW5nIGEgW1tSZXN1bHRdXSBkb1xyXG4gKiAgbm90IGltcGFjdCB0aGUgYWJpbGl0eSB0byBjb250aW51ZSBwYXJzaW5nIGRhdGEsIHRoZXkgYXJlXHJcbiAqICBkZWZlcnJlZCB1bnRpbCB0aGV5IGFyZSBhY3R1YWxseSBhY2Nlc3NlZC4gSGVuY2UgYSBmYXVsdHkgc3RyaW5nXHJcbiAqICBpbiBhbiBFdmVudCB0aGF0IGlzIG5ldmVyIHVzZWQgZG9lcyBub3QgaW1wYWN0IHRoZSBwcm9ncmFtIGZsb3cuXHJcbiAqXHJcbiAqICBIb3dldmVyLCBzb21ldGltZXMgaXQgbWF5IGJlIHVzZWZ1bCB0byBhY2Nlc3MsIGlkZW50aWZ5IG9yXHJcbiAqICB2YWxpZGF0ZSBjb3JyZWN0bmVzcyBvZiBhIFtbUmVzdWx0XV0uXHJcbiAqXHJcbiAqICBAX2RvY2xvYyBhcGkvYWJpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZXN1bHRFcnJvcnMocmVzdWx0KSB7XHJcbiAgICAvLyBGaW5kIHRoZSBmaXJzdCBlcnJvciAoaWYgYW55KVxyXG4gICAgY29uc3QgZXJyb3JzID0gW107XHJcbiAgICBjb25zdCBjaGVja0Vycm9ycyA9IGZ1bmN0aW9uIChwYXRoLCBvYmplY3QpIHtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aC5zbGljZSgpO1xyXG4gICAgICAgICAgICBjaGlsZFBhdGgucHVzaChrZXkpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tFcnJvcnMoY2hpbGRQYXRoLCBvYmplY3Rba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7IHBhdGg6IGNoaWxkUGF0aCwgZXJyb3I6IGVycm9yIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNoZWNrRXJyb3JzKFtdLCByZXN1bHQpO1xyXG4gICAgcmV0dXJuIGVycm9ycztcclxufVxyXG5mdW5jdGlvbiBnZXRWYWx1ZSh2YWx1ZSkge1xyXG4gICAgbGV0IGJ5dGVzID0gdG9CZUFycmF5KHZhbHVlKTtcclxuICAgIGFzc2VydChieXRlcy5sZW5ndGggPD0gV29yZFNpemUsIFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHsgYnVmZmVyOiBieXRlcywgbGVuZ3RoOiBXb3JkU2l6ZSwgb2Zmc2V0OiBieXRlcy5sZW5ndGggfSk7XHJcbiAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBXb3JkU2l6ZSkge1xyXG4gICAgICAgIGJ5dGVzID0gZ2V0Qnl0ZXNDb3B5KGNvbmNhdChbUGFkZGluZy5zbGljZShieXRlcy5sZW5ndGggJSBXb3JkU2l6ZSksIGJ5dGVzXSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJ5dGVzO1xyXG59XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb2RlciB7XHJcbiAgICAvLyBUaGUgY29kZXIgbmFtZTpcclxuICAgIC8vICAgLSBhZGRyZXNzLCB1aW50MjU2LCB0dXBsZSwgYXJyYXksIGV0Yy5cclxuICAgIG5hbWU7XHJcbiAgICAvLyBUaGUgZnVsbHkgZXhwYW5kZWQgdHlwZSwgaW5jbHVkaW5nIGNvbXBvc2l0ZSB0eXBlczpcclxuICAgIC8vICAgLSBhZGRyZXNzLCB1aW50MjU2LCB0dXBsZShhZGRyZXNzLGJ5dGVzKSwgdWludDI1NlszXVs0XVtdLCAgZXRjLlxyXG4gICAgdHlwZTtcclxuICAgIC8vIFRoZSBsb2NhbE5hbWUgYm91bmQgaW4gdGhlIHNpZ25hdHVyZSwgaW4gdGhpcyBleGFtcGxlIGl0IGlzIFwiYmF6XCI6XHJcbiAgICAvLyAgIC0gdHVwbGUoYWRkcmVzcyBmb28sIHVpbnQgYmFyKSBiYXpcclxuICAgIGxvY2FsTmFtZTtcclxuICAgIC8vIFdoZXRoZXIgdGhpcyB0eXBlIGlzIGR5bmFtaWM6XHJcbiAgICAvLyAgLSBEeW5hbWljOiBieXRlcywgc3RyaW5nLCBhZGRyZXNzW10sIHR1cGxlKGJvb2xlYW5bXSksIGV0Yy5cclxuICAgIC8vICAtIE5vdCBEeW5hbWljOiBhZGRyZXNzLCB1aW50MjU2LCBib29sZWFuWzNdLCB0dXBsZShhZGRyZXNzLCB1aW50OClcclxuICAgIGR5bmFtaWM7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMpIHtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljIH0sIHtcclxuICAgICAgICAgICAgbmFtZTogXCJzdHJpbmdcIiwgdHlwZTogXCJzdHJpbmdcIiwgbG9jYWxOYW1lOiBcInN0cmluZ1wiLCBkeW5hbWljOiBcImJvb2xlYW5cIlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX3Rocm93RXJyb3IobWVzc2FnZSwgdmFsdWUpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgbWVzc2FnZSwgdGhpcy5sb2NhbE5hbWUsIHZhbHVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEBfaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgV3JpdGVyIHtcclxuICAgIC8vIEFuIGFycmF5IG9mIFdvcmRTaXplIGxlbmd0aGVkIG9iamVjdHMgdG8gY29uY2F0ZW5hdGlvblxyXG4gICAgI2RhdGE7XHJcbiAgICAjZGF0YUxlbmd0aDtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuI2RhdGEgPSBbXTtcclxuICAgICAgICB0aGlzLiNkYXRhTGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIGdldCBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiBjb25jYXQodGhpcy4jZGF0YSk7XHJcbiAgICB9XHJcbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jZGF0YUxlbmd0aDsgfVxyXG4gICAgI3dyaXRlRGF0YShkYXRhKSB7XHJcbiAgICAgICAgdGhpcy4jZGF0YS5wdXNoKGRhdGEpO1xyXG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggKz0gZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgYXBwZW5kV3JpdGVyKHdyaXRlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiN3cml0ZURhdGEoZ2V0Qnl0ZXNDb3B5KHdyaXRlci5kYXRhKSk7XHJcbiAgICB9XHJcbiAgICAvLyBBcnJheWlzaCBpdGVtOyBwYWQgb24gdGhlIHJpZ2h0IHRvICpuZWFyZXN0KiBXb3JkU2l6ZVxyXG4gICAgd3JpdGVCeXRlcyh2YWx1ZSkge1xyXG4gICAgICAgIGxldCBieXRlcyA9IGdldEJ5dGVzQ29weSh2YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgcGFkZGluZ09mZnNldCA9IGJ5dGVzLmxlbmd0aCAlIFdvcmRTaXplO1xyXG4gICAgICAgIGlmIChwYWRkaW5nT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIGJ5dGVzID0gZ2V0Qnl0ZXNDb3B5KGNvbmNhdChbYnl0ZXMsIFBhZGRpbmcuc2xpY2UocGFkZGluZ09mZnNldCldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLiN3cml0ZURhdGEoYnl0ZXMpO1xyXG4gICAgfVxyXG4gICAgLy8gTnVtZXJpYyBpdGVtOyBwYWQgb24gdGhlIGxlZnQgKnRvKiBXb3JkU2l6ZVxyXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiN3cml0ZURhdGEoZ2V0VmFsdWUodmFsdWUpKTtcclxuICAgIH1cclxuICAgIC8vIEluc2VydHMgYSBudW1lcmljIHBsYWNlLWhvbGRlciwgcmV0dXJuaW5nIGEgY2FsbGJhY2sgdGhhdCBjYW5cclxuICAgIC8vIGJlIHVzZWQgdG8gYXNqdXN0IHRoZSB2YWx1ZSBsYXRlclxyXG4gICAgd3JpdGVVcGRhdGFibGVWYWx1ZSgpIHtcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLiNkYXRhLmxlbmd0aDtcclxuICAgICAgICB0aGlzLiNkYXRhLnB1c2goUGFkZGluZyk7XHJcbiAgICAgICAgdGhpcy4jZGF0YUxlbmd0aCArPSBXb3JkU2l6ZTtcclxuICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuI2RhdGFbb2Zmc2V0XSA9IGdldFZhbHVlKHZhbHVlKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBSZWFkZXIge1xyXG4gICAgLy8gQWxsb3dzIGluY29tcGxldGUgdW5wYWRkZWQgZGF0YSB0byBiZSByZWFkOyBvdGhlcndpc2UgYW4gZXJyb3JcclxuICAgIC8vIGlzIHJhaXNlZCBpZiBhdHRlbXB0aW5nIHRvIG92ZXJydW4gdGhlIGJ1ZmZlci4gVGhpcyBpcyByZXF1aXJlZFxyXG4gICAgLy8gdG8gZGVhbCB3aXRoIGFuIG9sZCBTb2xpZGl0eSBidWcsIGluIHdoaWNoIGV2ZW50IGRhdGEgZm9yXHJcbiAgICAvLyBleHRlcm5hbCAobm90IHB1YmxpYyB0aG9ndWgpIHdhcyB0aWdodGx5IHBhY2tlZC5cclxuICAgIGFsbG93TG9vc2U7XHJcbiAgICAjZGF0YTtcclxuICAgICNvZmZzZXQ7XHJcbiAgICAjYnl0ZXNSZWFkO1xyXG4gICAgI3BhcmVudDtcclxuICAgICNtYXhJbmZsYXRpb247XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBhbGxvd0xvb3NlLCBtYXhJbmZsYXRpb24pIHtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYWxsb3dMb29zZTogISFhbGxvd0xvb3NlIH0pO1xyXG4gICAgICAgIHRoaXMuI2RhdGEgPSBnZXRCeXRlc0NvcHkoZGF0YSk7XHJcbiAgICAgICAgdGhpcy4jYnl0ZXNSZWFkID0gMDtcclxuICAgICAgICB0aGlzLiNwYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuI21heEluZmxhdGlvbiA9IChtYXhJbmZsYXRpb24gIT0gbnVsbCkgPyBtYXhJbmZsYXRpb24gOiAxMDI0O1xyXG4gICAgICAgIHRoaXMuI29mZnNldCA9IDA7XHJcbiAgICB9XHJcbiAgICBnZXQgZGF0YSgpIHsgcmV0dXJuIGhleGxpZnkodGhpcy4jZGF0YSk7IH1cclxuICAgIGdldCBkYXRhTGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jZGF0YS5sZW5ndGg7IH1cclxuICAgIGdldCBjb25zdW1lZCgpIHsgcmV0dXJuIHRoaXMuI29mZnNldDsgfVxyXG4gICAgZ2V0IGJ5dGVzKCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy4jZGF0YSk7IH1cclxuICAgICNpbmNyZW1lbnRCeXRlc1JlYWQoY291bnQpIHtcclxuICAgICAgICBpZiAodGhpcy4jcGFyZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwYXJlbnQuI2luY3JlbWVudEJ5dGVzUmVhZChjb3VudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuI2J5dGVzUmVhZCArPSBjb3VudDtcclxuICAgICAgICAvLyBDaGVjayBmb3IgZXhjZXNzaXZlIGluZmxhdGlvbiAoc2VlOiAjNDUzNylcclxuICAgICAgICBhc3NlcnQodGhpcy4jbWF4SW5mbGF0aW9uIDwgMSB8fCB0aGlzLiNieXRlc1JlYWQgPD0gdGhpcy4jbWF4SW5mbGF0aW9uICogdGhpcy5kYXRhTGVuZ3RoLCBgY29tcHJlc3NlZCBBQkkgZGF0YSBleGNlZWRzIGluZmxhdGlvbiByYXRpbyBvZiAke3RoaXMuI21heEluZmxhdGlvbn0gKCBzZWU6IGh0dHBzOi9cXC9naXRodWIuY29tL2V0aGVycy1pby9ldGhlcnMuanMvaXNzdWVzLzQ1MzcgKWAsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xyXG4gICAgICAgICAgICBidWZmZXI6IGdldEJ5dGVzQ29weSh0aGlzLiNkYXRhKSwgb2Zmc2V0OiB0aGlzLiNvZmZzZXQsXHJcbiAgICAgICAgICAgIGxlbmd0aDogY291bnQsIGluZm86IHtcclxuICAgICAgICAgICAgICAgIGJ5dGVzUmVhZDogdGhpcy4jYnl0ZXNSZWFkLFxyXG4gICAgICAgICAgICAgICAgZGF0YUxlbmd0aDogdGhpcy5kYXRhTGVuZ3RoXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgICNwZWVrQnl0ZXMob2Zmc2V0LCBsZW5ndGgsIGxvb3NlKSB7XHJcbiAgICAgICAgbGV0IGFsaWduZWRMZW5ndGggPSBNYXRoLmNlaWwobGVuZ3RoIC8gV29yZFNpemUpICogV29yZFNpemU7XHJcbiAgICAgICAgaWYgKHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGggPiB0aGlzLiNkYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hbGxvd0xvb3NlICYmIGxvb3NlICYmIHRoaXMuI29mZnNldCArIGxlbmd0aCA8PSB0aGlzLiNkYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgYWxpZ25lZExlbmd0aCA9IGxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJkYXRhIG91dC1vZi1ib3VuZHNcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBnZXRCeXRlc0NvcHkodGhpcy4jZGF0YSksXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLiNkYXRhLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGhcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLiNkYXRhLnNsaWNlKHRoaXMuI29mZnNldCwgdGhpcy4jb2Zmc2V0ICsgYWxpZ25lZExlbmd0aCk7XHJcbiAgICB9XHJcbiAgICAvLyBDcmVhdGUgYSBzdWItcmVhZGVyIHdpdGggdGhlIHNhbWUgdW5kZXJseWluZyBkYXRhLCBidXQgb2Zmc2V0XHJcbiAgICBzdWJSZWFkZXIob2Zmc2V0KSB7XHJcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IFJlYWRlcih0aGlzLiNkYXRhLnNsaWNlKHRoaXMuI29mZnNldCArIG9mZnNldCksIHRoaXMuYWxsb3dMb29zZSwgdGhpcy4jbWF4SW5mbGF0aW9uKTtcclxuICAgICAgICByZWFkZXIuI3BhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHJlYWRlcjtcclxuICAgIH1cclxuICAgIC8vIFJlYWQgYnl0ZXNcclxuICAgIHJlYWRCeXRlcyhsZW5ndGgsIGxvb3NlKSB7XHJcbiAgICAgICAgbGV0IGJ5dGVzID0gdGhpcy4jcGVla0J5dGVzKDAsIGxlbmd0aCwgISFsb29zZSk7XHJcbiAgICAgICAgdGhpcy4jaW5jcmVtZW50Qnl0ZXNSZWFkKGxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy4jb2Zmc2V0ICs9IGJ5dGVzLmxlbmd0aDtcclxuICAgICAgICAvLyBAVE9ETzogTWFrZSBzdXJlIHRoZSBsZW5ndGguLmVuZCBieXRlcyBhcmUgYWxsIDA/XHJcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICAvLyBSZWFkIGEgbnVtZXJpYyB2YWx1ZXNcclxuICAgIHJlYWRWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdG9CaWdJbnQodGhpcy5yZWFkQnl0ZXMoV29yZFNpemUpKTtcclxuICAgIH1cclxuICAgIHJlYWRJbmRleCgpIHtcclxuICAgICAgICByZXR1cm4gdG9OdW1iZXIodGhpcy5yZWFkQnl0ZXMoV29yZFNpemUpKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1jb2Rlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/address.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/address.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressCoder: () => (/* binding */ AddressCoder)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../address/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/maths.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typed.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\r\n\r\n\r\n\r\n/**\r\n *  @_ignore\r\n */\r\nclass AddressCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\r\n    constructor(localName) {\r\n        super(\"address\", \"address\", localName, false);\r\n    }\r\n    defaultValue() {\r\n        return \"0x0000000000000000000000000000000000000000\";\r\n    }\r\n    encode(writer, _value) {\r\n        let value = _typed_js__WEBPACK_IMPORTED_MODULE_1__.Typed.dereference(_value, \"string\");\r\n        try {\r\n            value = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)(value);\r\n        }\r\n        catch (error) {\r\n            return this._throwError(error.message, _value);\r\n        }\r\n        return writer.writeValue(value);\r\n    }\r\n    decode(reader) {\r\n        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_3__.toBeHex)(reader.readValue(), 20));\r\n    }\r\n}\r\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBb0Q7QUFDTDtBQUNYO0FBQ1E7QUFDNUM7QUFDQTtBQUNBO0FBQ08sMkJBQTJCLHFEQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRDQUFLO0FBQ3pCO0FBQ0Esb0JBQW9CLDZEQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2REFBVSxDQUFDLHdEQUFPO0FBQ2pDO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxhYmlcXGNvZGVyc1xcYWRkcmVzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uLy4uL2FkZHJlc3MvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgdG9CZUhleCB9IGZyb20gXCIuLi8uLi91dGlscy9tYXRocy5qc1wiO1xyXG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xyXG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBBZGRyZXNzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcclxuICAgICAgICBzdXBlcihcImFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgZGVmYXVsdFZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xyXG4gICAgfVxyXG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInN0cmluZ1wiKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGdldEFkZHJlc3ModmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rocm93RXJyb3IoZXJyb3IubWVzc2FnZSwgX3ZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlKTtcclxuICAgIH1cclxuICAgIGRlY29kZShyZWFkZXIpIHtcclxuICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyh0b0JlSGV4KHJlYWRlci5yZWFkVmFsdWUoKSwgMjApKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/address.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/anonymous.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/anonymous.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnonymousCoder: () => (/* binding */ AnonymousCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\r\n/**\r\n *  Clones the functionality of an existing Coder, but without a localName\r\n *\r\n *  @_ignore\r\n */\r\nclass AnonymousCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\r\n    coder;\r\n    constructor(coder) {\r\n        super(coder.name, coder.type, \"_\", coder.dynamic);\r\n        this.coder = coder;\r\n    }\r\n    defaultValue() {\r\n        return this.coder.defaultValue();\r\n    }\r\n    encode(writer, value) {\r\n        return this.coder.encode(writer, value);\r\n    }\r\n    decode(reader) {\r\n        return this.coder.decode(reader);\r\n    }\r\n}\r\n//# sourceMappingURL=anonymous.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2Fub255bW91cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNkJBQTZCLHFEQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXGFiaVxcY29kZXJzXFxhbm9ueW1vdXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xyXG4vKipcclxuICogIENsb25lcyB0aGUgZnVuY3Rpb25hbGl0eSBvZiBhbiBleGlzdGluZyBDb2RlciwgYnV0IHdpdGhvdXQgYSBsb2NhbE5hbWVcclxuICpcclxuICogIEBfaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQW5vbnltb3VzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XHJcbiAgICBjb2RlcjtcclxuICAgIGNvbnN0cnVjdG9yKGNvZGVyKSB7XHJcbiAgICAgICAgc3VwZXIoY29kZXIubmFtZSwgY29kZXIudHlwZSwgXCJfXCIsIGNvZGVyLmR5bmFtaWMpO1xyXG4gICAgICAgIHRoaXMuY29kZXIgPSBjb2RlcjtcclxuICAgIH1cclxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtcclxuICAgIH1cclxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZW5jb2RlKHdyaXRlciwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZGVjb2RlKHJlYWRlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmRlY29kZShyZWFkZXIpO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFub255bW91cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/anonymous.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/array.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/array.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayCoder: () => (/* binding */ ArrayCoder),\n/* harmony export */   pack: () => (/* binding */ pack),\n/* harmony export */   unpack: () => (/* binding */ unpack)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract-coder.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _anonymous_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./anonymous.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/anonymous.js\");\n\r\n\r\n\r\n\r\n/**\r\n *  @_ignore\r\n */\r\nfunction pack(writer, coders, values) {\r\n    let arrayValues = [];\r\n    if (Array.isArray(values)) {\r\n        arrayValues = values;\r\n    }\r\n    else if (values && typeof (values) === \"object\") {\r\n        let unique = {};\r\n        arrayValues = coders.map((coder) => {\r\n            const name = coder.localName;\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(name, \"cannot encode object for signature with missing names\", \"INVALID_ARGUMENT\", { argument: \"values\", info: { coder }, value: values });\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!unique[name], \"cannot encode object for signature with duplicate names\", \"INVALID_ARGUMENT\", { argument: \"values\", info: { coder }, value: values });\r\n            unique[name] = true;\r\n            return values[name];\r\n        });\r\n    }\r\n    else {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid tuple value\", \"tuple\", values);\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(coders.length === arrayValues.length, \"types/value length mismatch\", \"tuple\", values);\r\n    let staticWriter = new _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\r\n    let dynamicWriter = new _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\r\n    let updateFuncs = [];\r\n    coders.forEach((coder, index) => {\r\n        let value = arrayValues[index];\r\n        if (coder.dynamic) {\r\n            // Get current dynamic offset (for the future pointer)\r\n            let dynamicOffset = dynamicWriter.length;\r\n            // Encode the dynamic value into the dynamicWriter\r\n            coder.encode(dynamicWriter, value);\r\n            // Prepare to populate the correct offset once we are done\r\n            let updateFunc = staticWriter.writeUpdatableValue();\r\n            updateFuncs.push((baseOffset) => {\r\n                updateFunc(baseOffset + dynamicOffset);\r\n            });\r\n        }\r\n        else {\r\n            coder.encode(staticWriter, value);\r\n        }\r\n    });\r\n    // Backfill all the dynamic offsets, now that we know the static length\r\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\r\n    let length = writer.appendWriter(staticWriter);\r\n    length += writer.appendWriter(dynamicWriter);\r\n    return length;\r\n}\r\n/**\r\n *  @_ignore\r\n */\r\nfunction unpack(reader, coders) {\r\n    let values = [];\r\n    let keys = [];\r\n    // A reader anchored to this base\r\n    let baseReader = reader.subReader(0);\r\n    coders.forEach((coder) => {\r\n        let value = null;\r\n        if (coder.dynamic) {\r\n            let offset = reader.readIndex();\r\n            let offsetReader = baseReader.subReader(offset);\r\n            try {\r\n                value = coder.decode(offsetReader);\r\n            }\r\n            catch (error) {\r\n                // Cannot recover from this\r\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"BUFFER_OVERRUN\")) {\r\n                    throw error;\r\n                }\r\n                value = error;\r\n                value.baseType = coder.name;\r\n                value.name = coder.localName;\r\n                value.type = coder.type;\r\n            }\r\n        }\r\n        else {\r\n            try {\r\n                value = coder.decode(reader);\r\n            }\r\n            catch (error) {\r\n                // Cannot recover from this\r\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"BUFFER_OVERRUN\")) {\r\n                    throw error;\r\n                }\r\n                value = error;\r\n                value.baseType = coder.name;\r\n                value.name = coder.localName;\r\n                value.type = coder.type;\r\n            }\r\n        }\r\n        if (value == undefined) {\r\n            throw new Error(\"investigate\");\r\n        }\r\n        values.push(value);\r\n        keys.push(coder.localName || null);\r\n    });\r\n    return _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Result.fromItems(values, keys);\r\n}\r\n/**\r\n *  @_ignore\r\n */\r\nclass ArrayCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Coder {\r\n    coder;\r\n    length;\r\n    constructor(coder, length, localName) {\r\n        const type = (coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\");\r\n        const dynamic = (length === -1 || coder.dynamic);\r\n        super(\"array\", type, localName, dynamic);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { coder, length });\r\n    }\r\n    defaultValue() {\r\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\r\n        const defaultChild = this.coder.defaultValue();\r\n        const result = [];\r\n        for (let i = 0; i < this.length; i++) {\r\n            result.push(defaultChild);\r\n        }\r\n        return result;\r\n    }\r\n    encode(writer, _value) {\r\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, \"array\");\r\n        if (!Array.isArray(value)) {\r\n            this._throwError(\"expected array value\", value);\r\n        }\r\n        let count = this.length;\r\n        if (count === -1) {\r\n            count = value.length;\r\n            writer.writeValue(value.length);\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgumentCount)(value.length, count, \"coder array\" + (this.localName ? (\" \" + this.localName) : \"\"));\r\n        let coders = [];\r\n        for (let i = 0; i < value.length; i++) {\r\n            coders.push(this.coder);\r\n        }\r\n        return pack(writer, coders, value);\r\n    }\r\n    decode(reader) {\r\n        let count = this.length;\r\n        if (count === -1) {\r\n            count = reader.readIndex();\r\n            // Check that there is *roughly* enough data to ensure\r\n            // stray random data is not being read as a length. Each\r\n            // slot requires at least 32 bytes for their value (or 32\r\n            // bytes as a link to the data). This could use a much\r\n            // tighter bound, but we are erroring on the side of safety.\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(count * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.WordSize <= reader.dataLength, \"insufficient data length\", \"BUFFER_OVERRUN\", { buffer: reader.bytes, offset: count * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.WordSize, length: reader.dataLength });\r\n        }\r\n        let coders = [];\r\n        for (let i = 0; i < count; i++) {\r\n            coders.push(new _anonymous_js__WEBPACK_IMPORTED_MODULE_3__.AnonymousCoder(this.coder));\r\n        }\r\n        return unpack(reader, coders);\r\n    }\r\n}\r\n//# sourceMappingURL=array.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2FycmF5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBOEc7QUFDMUU7QUFDa0M7QUFDdEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1REFBTSxzRkFBc0YsNEJBQTRCLE9BQU8saUJBQWlCO0FBQzVKLFlBQVksdURBQU0saUdBQWlHLDRCQUE0QixPQUFPLGlCQUFpQjtBQUN2SztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0EsSUFBSSwrREFBYztBQUNsQiwyQkFBMkIsc0RBQU07QUFDakMsNEJBQTRCLHNEQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0RBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLHNEQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ08seUJBQXlCLHFEQUFLO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRDQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9FQUFtQjtBQUMzQjtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVEQUFNLFNBQVMsd0RBQVEsdUVBQXVFLHNDQUFzQyx3REFBUSw2QkFBNkI7QUFDckw7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DLDRCQUE0Qix5REFBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXGFiaVxcY29kZXJzXFxhcnJheS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBpc0Vycm9yLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRBcmd1bWVudENvdW50IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XHJcbmltcG9ydCB7IENvZGVyLCBSZXN1bHQsIFdvcmRTaXplLCBXcml0ZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xyXG5pbXBvcnQgeyBBbm9ueW1vdXNDb2RlciB9IGZyb20gXCIuL2Fub255bW91cy5qc1wiO1xyXG4vKipcclxuICogIEBfaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWVzKSB7XHJcbiAgICBsZXQgYXJyYXlWYWx1ZXMgPSBbXTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcclxuICAgICAgICBhcnJheVZhbHVlcyA9IHZhbHVlcztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlcyAmJiB0eXBlb2YgKHZhbHVlcykgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICBsZXQgdW5pcXVlID0ge307XHJcbiAgICAgICAgYXJyYXlWYWx1ZXMgPSBjb2RlcnMubWFwKChjb2RlcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xyXG4gICAgICAgICAgICBhc3NlcnQobmFtZSwgXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggbWlzc2luZyBuYW1lc1wiLCBcIklOVkFMSURfQVJHVU1FTlRcIiwgeyBhcmd1bWVudDogXCJ2YWx1ZXNcIiwgaW5mbzogeyBjb2RlciB9LCB2YWx1ZTogdmFsdWVzIH0pO1xyXG4gICAgICAgICAgICBhc3NlcnQoIXVuaXF1ZVtuYW1lXSwgXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggZHVwbGljYXRlIG5hbWVzXCIsIFwiSU5WQUxJRF9BUkdVTUVOVFwiLCB7IGFyZ3VtZW50OiBcInZhbHVlc1wiLCBpbmZvOiB7IGNvZGVyIH0sIHZhbHVlOiB2YWx1ZXMgfSk7XHJcbiAgICAgICAgICAgIHVuaXF1ZVtuYW1lXSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbbmFtZV07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIsIFwidHVwbGVcIiwgdmFsdWVzKTtcclxuICAgIH1cclxuICAgIGFzc2VydEFyZ3VtZW50KGNvZGVycy5sZW5ndGggPT09IGFycmF5VmFsdWVzLmxlbmd0aCwgXCJ0eXBlcy92YWx1ZSBsZW5ndGggbWlzbWF0Y2hcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xyXG4gICAgbGV0IHN0YXRpY1dyaXRlciA9IG5ldyBXcml0ZXIoKTtcclxuICAgIGxldCBkeW5hbWljV3JpdGVyID0gbmV3IFdyaXRlcigpO1xyXG4gICAgbGV0IHVwZGF0ZUZ1bmNzID0gW107XHJcbiAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gYXJyYXlWYWx1ZXNbaW5kZXhdO1xyXG4gICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IGR5bmFtaWMgb2Zmc2V0IChmb3IgdGhlIGZ1dHVyZSBwb2ludGVyKVxyXG4gICAgICAgICAgICBsZXQgZHluYW1pY09mZnNldCA9IGR5bmFtaWNXcml0ZXIubGVuZ3RoO1xyXG4gICAgICAgICAgICAvLyBFbmNvZGUgdGhlIGR5bmFtaWMgdmFsdWUgaW50byB0aGUgZHluYW1pY1dyaXRlclxyXG4gICAgICAgICAgICBjb2Rlci5lbmNvZGUoZHluYW1pY1dyaXRlciwgdmFsdWUpO1xyXG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRvIHBvcHVsYXRlIHRoZSBjb3JyZWN0IG9mZnNldCBvbmNlIHdlIGFyZSBkb25lXHJcbiAgICAgICAgICAgIGxldCB1cGRhdGVGdW5jID0gc3RhdGljV3JpdGVyLndyaXRlVXBkYXRhYmxlVmFsdWUoKTtcclxuICAgICAgICAgICAgdXBkYXRlRnVuY3MucHVzaCgoYmFzZU9mZnNldCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlRnVuYyhiYXNlT2Zmc2V0ICsgZHluYW1pY09mZnNldCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29kZXIuZW5jb2RlKHN0YXRpY1dyaXRlciwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgLy8gQmFja2ZpbGwgYWxsIHRoZSBkeW5hbWljIG9mZnNldHMsIG5vdyB0aGF0IHdlIGtub3cgdGhlIHN0YXRpYyBsZW5ndGhcclxuICAgIHVwZGF0ZUZ1bmNzLmZvckVhY2goKGZ1bmMpID0+IHsgZnVuYyhzdGF0aWNXcml0ZXIubGVuZ3RoKTsgfSk7XHJcbiAgICBsZXQgbGVuZ3RoID0gd3JpdGVyLmFwcGVuZFdyaXRlcihzdGF0aWNXcml0ZXIpO1xyXG4gICAgbGVuZ3RoICs9IHdyaXRlci5hcHBlbmRXcml0ZXIoZHluYW1pY1dyaXRlcik7XHJcbiAgICByZXR1cm4gbGVuZ3RoO1xyXG59XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1bnBhY2socmVhZGVyLCBjb2RlcnMpIHtcclxuICAgIGxldCB2YWx1ZXMgPSBbXTtcclxuICAgIGxldCBrZXlzID0gW107XHJcbiAgICAvLyBBIHJlYWRlciBhbmNob3JlZCB0byB0aGlzIGJhc2VcclxuICAgIGxldCBiYXNlUmVhZGVyID0gcmVhZGVyLnN1YlJlYWRlcigwKTtcclxuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcclxuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHJlYWRlci5yZWFkSW5kZXgoKTtcclxuICAgICAgICAgICAgbGV0IG9mZnNldFJlYWRlciA9IGJhc2VSZWFkZXIuc3ViUmVhZGVyKG9mZnNldCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvZGVyLmRlY29kZShvZmZzZXRSZWFkZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2Fubm90IHJlY292ZXIgZnJvbSB0aGlzXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJCVUZGRVJfT1ZFUlJVTlwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcclxuICAgICAgICAgICAgICAgIHZhbHVlLmJhc2VUeXBlID0gY29kZXIubmFtZTtcclxuICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKHJlYWRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcclxuICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkJVRkZFUl9PVkVSUlVOXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUuYmFzZVR5cGUgPSBjb2Rlci5uYW1lO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcclxuICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgPSBjb2Rlci50eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZSA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52ZXN0aWdhdGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcclxuICAgICAgICBrZXlzLnB1c2goY29kZXIubG9jYWxOYW1lIHx8IG51bGwpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gUmVzdWx0LmZyb21JdGVtcyh2YWx1ZXMsIGtleXMpO1xyXG59XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBBcnJheUNvZGVyIGV4dGVuZHMgQ29kZXIge1xyXG4gICAgY29kZXI7XHJcbiAgICBsZW5ndGg7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb2RlciwgbGVuZ3RoLCBsb2NhbE5hbWUpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gKGNvZGVyLnR5cGUgKyBcIltcIiArIChsZW5ndGggPj0gMCA/IGxlbmd0aCA6IFwiXCIpICsgXCJdXCIpO1xyXG4gICAgICAgIGNvbnN0IGR5bmFtaWMgPSAobGVuZ3RoID09PSAtMSB8fCBjb2Rlci5keW5hbWljKTtcclxuICAgICAgICBzdXBlcihcImFycmF5XCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGNvZGVyLCBsZW5ndGggfSk7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0VmFsdWUoKSB7XHJcbiAgICAgICAgLy8gVmVyaWZpZXMgdGhlIGNoaWxkIGNvZGVyIGlzIHZhbGlkIChldmVuIGlmIHRoZSBhcnJheSBpcyBkeW5hbWljIG9yIDAtbGVuZ3RoKVxyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRDaGlsZCA9IHRoaXMuY29kZXIuZGVmYXVsdFZhbHVlKCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlZmF1bHRDaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJhcnJheVwiKTtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJleHBlY3RlZCBhcnJheSB2YWx1ZVwiLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgY291bnQgPSB2YWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50Q291bnQodmFsdWUubGVuZ3RoLCBjb3VudCwgXCJjb2RlciBhcnJheVwiICsgKHRoaXMubG9jYWxOYW1lID8gKFwiIFwiICsgdGhpcy5sb2NhbE5hbWUpIDogXCJcIikpO1xyXG4gICAgICAgIGxldCBjb2RlcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvZGVycy5wdXNoKHRoaXMuY29kZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZGVjb2RlKHJlYWRlcikge1xyXG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgY291bnQgPSByZWFkZXIucmVhZEluZGV4KCk7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlcmUgaXMgKnJvdWdobHkqIGVub3VnaCBkYXRhIHRvIGVuc3VyZVxyXG4gICAgICAgICAgICAvLyBzdHJheSByYW5kb20gZGF0YSBpcyBub3QgYmVpbmcgcmVhZCBhcyBhIGxlbmd0aC4gRWFjaFxyXG4gICAgICAgICAgICAvLyBzbG90IHJlcXVpcmVzIGF0IGxlYXN0IDMyIGJ5dGVzIGZvciB0aGVpciB2YWx1ZSAob3IgMzJcclxuICAgICAgICAgICAgLy8gYnl0ZXMgYXMgYSBsaW5rIHRvIHRoZSBkYXRhKS4gVGhpcyBjb3VsZCB1c2UgYSBtdWNoXHJcbiAgICAgICAgICAgIC8vIHRpZ2h0ZXIgYm91bmQsIGJ1dCB3ZSBhcmUgZXJyb3Jpbmcgb24gdGhlIHNpZGUgb2Ygc2FmZXR5LlxyXG4gICAgICAgICAgICBhc3NlcnQoY291bnQgKiBXb3JkU2l6ZSA8PSByZWFkZXIuZGF0YUxlbmd0aCwgXCJpbnN1ZmZpY2llbnQgZGF0YSBsZW5ndGhcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7IGJ1ZmZlcjogcmVhZGVyLmJ5dGVzLCBvZmZzZXQ6IGNvdW50ICogV29yZFNpemUsIGxlbmd0aDogcmVhZGVyLmRhdGFMZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjb2RlcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgY29kZXJzLnB1c2gobmV3IEFub255bW91c0NvZGVyKHRoaXMuY29kZXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVucGFjayhyZWFkZXIsIGNvZGVycyk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/array.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/boolean.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/boolean.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BooleanCoder: () => (/* binding */ BooleanCoder)\n/* harmony export */ });\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typed.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\r\n\r\n/**\r\n *  @_ignore\r\n */\r\nclass BooleanCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\r\n    constructor(localName) {\r\n        super(\"bool\", \"bool\", localName, false);\r\n    }\r\n    defaultValue() {\r\n        return false;\r\n    }\r\n    encode(writer, _value) {\r\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_1__.Typed.dereference(_value, \"bool\");\r\n        return writer.writeValue(value ? 1 : 0);\r\n    }\r\n    decode(reader) {\r\n        return !!reader.readValue();\r\n    }\r\n}\r\n//# sourceMappingURL=boolean.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2Jvb2xlYW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW9DO0FBQ1E7QUFDNUM7QUFDQTtBQUNBO0FBQ08sMkJBQTJCLHFEQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRDQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXGFiaVxcY29kZXJzXFxib29sZWFuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XHJcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcclxuLyoqXHJcbiAqICBAX2lnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJvb2xlYW5Db2RlciBleHRlbmRzIENvZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xyXG4gICAgICAgIHN1cGVyKFwiYm9vbFwiLCBcImJvb2xcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwiYm9vbFwiKTtcclxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUgPyAxIDogMCk7XHJcbiAgICB9XHJcbiAgICBkZWNvZGUocmVhZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuICEhcmVhZGVyLnJlYWRWYWx1ZSgpO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb2xlYW4uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/boolean.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/bytes.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/bytes.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BytesCoder: () => (/* binding */ BytesCoder),\n/* harmony export */   DynamicBytesCoder: () => (/* binding */ DynamicBytesCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\r\n\r\n/**\r\n *  @_ignore\r\n */\r\nclass DynamicBytesCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\r\n    constructor(type, localName) {\r\n        super(type, type, localName, true);\r\n    }\r\n    defaultValue() {\r\n        return \"0x\";\r\n    }\r\n    encode(writer, value) {\r\n        value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(value);\r\n        let length = writer.writeValue(value.length);\r\n        length += writer.writeBytes(value);\r\n        return length;\r\n    }\r\n    decode(reader) {\r\n        return reader.readBytes(reader.readIndex(), true);\r\n    }\r\n}\r\n/**\r\n *  @_ignore\r\n */\r\nclass BytesCoder extends DynamicBytesCoder {\r\n    constructor(localName) {\r\n        super(\"bytes\", localName);\r\n    }\r\n    decode(reader) {\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(super.decode(reader));\r\n    }\r\n}\r\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2J5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkQ7QUFDakI7QUFDNUM7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLHFEQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZEQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBTztBQUN0QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcYWJpXFxjb2RlcnNcXGJ5dGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEJ5dGVzQ29weSwgaGV4bGlmeSB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBEeW5hbWljQnl0ZXNDb2RlciBleHRlbmRzIENvZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGxvY2FsTmFtZSkge1xyXG4gICAgICAgIHN1cGVyKHR5cGUsIHR5cGUsIGxvY2FsTmFtZSwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiMHhcIjtcclxuICAgIH1cclxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFsdWUgPSBnZXRCeXRlc0NvcHkodmFsdWUpO1xyXG4gICAgICAgIGxldCBsZW5ndGggPSB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZS5sZW5ndGgpO1xyXG4gICAgICAgIGxlbmd0aCArPSB3cml0ZXIud3JpdGVCeXRlcyh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcclxuICAgIH1cclxuICAgIGRlY29kZShyZWFkZXIpIHtcclxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRCeXRlcyhyZWFkZXIucmVhZEluZGV4KCksIHRydWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBCeXRlc0NvZGVyIGV4dGVuZHMgRHluYW1pY0J5dGVzQ29kZXIge1xyXG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XHJcbiAgICAgICAgc3VwZXIoXCJieXRlc1wiLCBsb2NhbE5hbWUpO1xyXG4gICAgfVxyXG4gICAgZGVjb2RlKHJlYWRlcikge1xyXG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHN1cGVyLmRlY29kZShyZWFkZXIpKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/bytes.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedBytesCoder: () => (/* binding */ FixedBytesCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\r\n\r\n\r\n/**\r\n *  @_ignore\r\n */\r\nclass FixedBytesCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\r\n    size;\r\n    constructor(size, localName) {\r\n        let name = \"bytes\" + String(size);\r\n        super(name, name, localName, false);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { size }, { size: \"number\" });\r\n    }\r\n    defaultValue() {\r\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\r\n    }\r\n    encode(writer, _value) {\r\n        let data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(_typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, this.type));\r\n        if (data.length !== this.size) {\r\n            this._throwError(\"incorrect data length\", _value);\r\n        }\r\n        return writer.writeBytes(data);\r\n    }\r\n    decode(reader) {\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(reader.readBytes(this.size));\r\n    }\r\n}\r\n//# sourceMappingURL=fixed-bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2ZpeGVkLWJ5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0U7QUFDM0M7QUFDUTtBQUM1QztBQUNBO0FBQ0E7QUFDTyw4QkFBOEIscURBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFnQixTQUFTLE1BQU0sSUFBSSxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2REFBWSxDQUFDLDRDQUFLO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQU87QUFDdEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXGFiaVxcY29kZXJzXFxmaXhlZC1ieXRlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCeXRlc0NvcHksIGhleGxpZnkgfSBmcm9tIFwiLi4vLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcclxuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xyXG4vKipcclxuICogIEBfaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRml4ZWRCeXRlc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xyXG4gICAgc2l6ZTtcclxuICAgIGNvbnN0cnVjdG9yKHNpemUsIGxvY2FsTmFtZSkge1xyXG4gICAgICAgIGxldCBuYW1lID0gXCJieXRlc1wiICsgU3RyaW5nKHNpemUpO1xyXG4gICAgICAgIHN1cGVyKG5hbWUsIG5hbWUsIGxvY2FsTmFtZSwgZmFsc2UpO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBzaXplIH0sIHsgc2l6ZTogXCJudW1iZXJcIiB9KTtcclxuICAgIH1cclxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gKFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpLnN1YnN0cmluZygwLCAyICsgdGhpcy5zaXplICogMik7XHJcbiAgICB9XHJcbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcclxuICAgICAgICBsZXQgZGF0YSA9IGdldEJ5dGVzQ29weShUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIHRoaXMudHlwZSkpO1xyXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdGhpcy5zaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJpbmNvcnJlY3QgZGF0YSBsZW5ndGhcIiwgX3ZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgZGVjb2RlKHJlYWRlcikge1xyXG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHJlYWRlci5yZWFkQnl0ZXModGhpcy5zaXplKSk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml4ZWQtYnl0ZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/null.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/null.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NullCoder: () => (/* binding */ NullCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\r\nconst Empty = new Uint8Array([]);\r\n/**\r\n *  @_ignore\r\n */\r\nclass NullCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\r\n    constructor(localName) {\r\n        super(\"null\", \"\", localName, false);\r\n    }\r\n    defaultValue() {\r\n        return null;\r\n    }\r\n    encode(writer, value) {\r\n        if (value != null) {\r\n            this._throwError(\"not null\", value);\r\n        }\r\n        return writer.writeBytes(Empty);\r\n    }\r\n    decode(reader) {\r\n        reader.readBytes(0);\r\n        return null;\r\n    }\r\n}\r\n//# sourceMappingURL=null.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL251bGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDTyx3QkFBd0IscURBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXGFiaVxcY29kZXJzXFxudWxsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcclxuY29uc3QgRW1wdHkgPSBuZXcgVWludDhBcnJheShbXSk7XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBOdWxsQ29kZXIgZXh0ZW5kcyBDb2RlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcclxuICAgICAgICBzdXBlcihcIm51bGxcIiwgXCJcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJub3QgbnVsbFwiLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhFbXB0eSk7XHJcbiAgICB9XHJcbiAgICBkZWNvZGUocmVhZGVyKSB7XHJcbiAgICAgICAgcmVhZGVyLnJlYWRCeXRlcygwKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1udWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/null.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/number.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/number.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NumberCoder: () => (/* binding */ NumberCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\r\n\r\n\r\nconst BN_0 = BigInt(0);\r\nconst BN_1 = BigInt(1);\r\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\r\n/**\r\n *  @_ignore\r\n */\r\nclass NumberCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\r\n    size;\r\n    signed;\r\n    constructor(size, signed, localName) {\r\n        const name = ((signed ? \"int\" : \"uint\") + (size * 8));\r\n        super(name, name, localName, false);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { size, signed }, { size: \"number\", signed: \"boolean\" });\r\n    }\r\n    defaultValue() {\r\n        return 0;\r\n    }\r\n    encode(writer, _value) {\r\n        let value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, this.type));\r\n        // Check bounds are safe for encoding\r\n        let maxUintValue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.mask)(BN_MAX_UINT256, _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.WordSize * 8);\r\n        if (this.signed) {\r\n            let bounds = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.mask)(maxUintValue, (this.size * 8) - 1);\r\n            if (value > bounds || value < -(bounds + BN_1)) {\r\n                this._throwError(\"value out-of-bounds\", _value);\r\n            }\r\n            value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toTwos)(value, 8 * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.WordSize);\r\n        }\r\n        else if (value < BN_0 || value > (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.mask)(maxUintValue, this.size * 8)) {\r\n            this._throwError(\"value out-of-bounds\", _value);\r\n        }\r\n        return writer.writeValue(value);\r\n    }\r\n    decode(reader) {\r\n        let value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.mask)(reader.readValue(), this.size * 8);\r\n        if (this.signed) {\r\n            value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)(value, this.size * 8);\r\n        }\r\n        return value;\r\n    }\r\n}\r\n//# sourceMappingURL=number.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL251bWJlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTJGO0FBQ3ZEO0FBQ2tCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDBCQUEwQixxREFBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0IsU0FBUyxjQUFjLElBQUksbUNBQW1DO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQVMsQ0FBQyw0Q0FBSztBQUNuQztBQUNBLDJCQUEyQixxREFBSSxpQkFBaUIsd0RBQVE7QUFDeEQ7QUFDQSx5QkFBeUIscURBQUk7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVEQUFNLFlBQVksd0RBQVE7QUFDOUM7QUFDQSx5Q0FBeUMscURBQUk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBSTtBQUN4QjtBQUNBLG9CQUFvQix5REFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXGFiaVxcY29kZXJzXFxudW1iZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZnJvbVR3b3MsIGdldEJpZ0ludCwgbWFzaywgdG9Ud29zIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XHJcbmltcG9ydCB7IENvZGVyLCBXb3JkU2l6ZSB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XHJcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XHJcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XHJcbmNvbnN0IEJOX01BWF9VSU5UMjU2ID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xyXG4vKipcclxuICogIEBfaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTnVtYmVyQ29kZXIgZXh0ZW5kcyBDb2RlciB7XHJcbiAgICBzaXplO1xyXG4gICAgc2lnbmVkO1xyXG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgc2lnbmVkLCBsb2NhbE5hbWUpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gKChzaWduZWQgPyBcImludFwiIDogXCJ1aW50XCIpICsgKHNpemUgKiA4KSk7XHJcbiAgICAgICAgc3VwZXIobmFtZSwgbmFtZSwgbG9jYWxOYW1lLCBmYWxzZSk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHNpemUsIHNpZ25lZCB9LCB7IHNpemU6IFwibnVtYmVyXCIsIHNpZ25lZDogXCJib29sZWFuXCIgfSk7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSBnZXRCaWdJbnQoVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCB0aGlzLnR5cGUpKTtcclxuICAgICAgICAvLyBDaGVjayBib3VuZHMgYXJlIHNhZmUgZm9yIGVuY29kaW5nXHJcbiAgICAgICAgbGV0IG1heFVpbnRWYWx1ZSA9IG1hc2soQk5fTUFYX1VJTlQyNTYsIFdvcmRTaXplICogOCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgIGxldCBib3VuZHMgPSBtYXNrKG1heFVpbnRWYWx1ZSwgKHRoaXMuc2l6ZSAqIDgpIC0gMSk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IGJvdW5kcyB8fCB2YWx1ZSA8IC0oYm91bmRzICsgQk5fMSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIF92YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFsdWUgPSB0b1R3b3ModmFsdWUsIDggKiBXb3JkU2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgQk5fMCB8fCB2YWx1ZSA+IG1hc2sobWF4VWludFZhbHVlLCB0aGlzLnNpemUgKiA4KSkge1xyXG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBfdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZGVjb2RlKHJlYWRlcikge1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IG1hc2socmVhZGVyLnJlYWRWYWx1ZSgpLCB0aGlzLnNpemUgKiA4KTtcclxuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBmcm9tVHdvcyh2YWx1ZSwgdGhpcy5zaXplICogOCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/number.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/string.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/string.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StringCoder: () => (/* binding */ StringCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utf8.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/bytes.js\");\n\r\n\r\n\r\n/**\r\n *  @_ignore\r\n */\r\nclass StringCoder extends _bytes_js__WEBPACK_IMPORTED_MODULE_0__.DynamicBytesCoder {\r\n    constructor(localName) {\r\n        super(\"string\", localName);\r\n    }\r\n    defaultValue() {\r\n        return \"\";\r\n    }\r\n    encode(writer, _value) {\r\n        return super.encode(writer, (0,_utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(_typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, \"string\")));\r\n    }\r\n    decode(reader) {\r\n        return (0,_utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(super.decode(reader));\r\n    }\r\n}\r\n//# sourceMappingURL=string.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL3N0cmluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdFO0FBQzVCO0FBQ1c7QUFDL0M7QUFDQTtBQUNBO0FBQ08sMEJBQTBCLHdEQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyREFBVyxDQUFDLDRDQUFLO0FBQ3JEO0FBQ0E7QUFDQSxlQUFlLDREQUFZO0FBQzNCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxhYmlcXGNvZGVyc1xcc3RyaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi4vLi4vdXRpbHMvdXRmOC5qc1wiO1xyXG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xyXG5pbXBvcnQgeyBEeW5hbWljQnl0ZXNDb2RlciB9IGZyb20gXCIuL2J5dGVzLmpzXCI7XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBTdHJpbmdDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xyXG4gICAgICAgIHN1cGVyKFwic3RyaW5nXCIsIGxvY2FsTmFtZSk7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9XHJcbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gc3VwZXIuZW5jb2RlKHdyaXRlciwgdG9VdGY4Qnl0ZXMoVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInN0cmluZ1wiKSkpO1xyXG4gICAgfVxyXG4gICAgZGVjb2RlKHJlYWRlcikge1xyXG4gICAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcoc3VwZXIuZGVjb2RlKHJlYWRlcikpO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/string.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/tuple.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/tuple.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TupleCoder: () => (/* binding */ TupleCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_properties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/properties.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./array.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/array.js\");\n\r\n\r\n\r\n\r\n/**\r\n *  @_ignore\r\n */\r\nclass TupleCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\r\n    coders;\r\n    constructor(coders, localName) {\r\n        let dynamic = false;\r\n        const types = [];\r\n        coders.forEach((coder) => {\r\n            if (coder.dynamic) {\r\n                dynamic = true;\r\n            }\r\n            types.push(coder.type);\r\n        });\r\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\r\n        super(\"tuple\", type, localName, dynamic);\r\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { coders: Object.freeze(coders.slice()) });\r\n    }\r\n    defaultValue() {\r\n        const values = [];\r\n        this.coders.forEach((coder) => {\r\n            values.push(coder.defaultValue());\r\n        });\r\n        // We only output named properties for uniquely named coders\r\n        const uniqueNames = this.coders.reduce((accum, coder) => {\r\n            const name = coder.localName;\r\n            if (name) {\r\n                if (!accum[name]) {\r\n                    accum[name] = 0;\r\n                }\r\n                accum[name]++;\r\n            }\r\n            return accum;\r\n        }, {});\r\n        // Add named values\r\n        this.coders.forEach((coder, index) => {\r\n            let name = coder.localName;\r\n            if (!name || uniqueNames[name] !== 1) {\r\n                return;\r\n            }\r\n            if (name === \"length\") {\r\n                name = \"_length\";\r\n            }\r\n            if (values[name] != null) {\r\n                return;\r\n            }\r\n            values[name] = values[index];\r\n        });\r\n        return Object.freeze(values);\r\n    }\r\n    encode(writer, _value) {\r\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, \"tuple\");\r\n        return (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.pack)(writer, this.coders, value);\r\n    }\r\n    decode(reader) {\r\n        return (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.unpack)(reader, this.coders);\r\n    }\r\n}\r\n//# sourceMappingURL=tuple.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL3R1cGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTZEO0FBQ3pCO0FBQ1E7QUFDRjtBQUMxQztBQUNBO0FBQ0E7QUFDTyx5QkFBeUIscURBQUs7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRLHNFQUFnQixTQUFTLHVDQUF1QztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRDQUFLO0FBQzNCLGVBQWUsK0NBQUk7QUFDbkI7QUFDQTtBQUNBLGVBQWUsaURBQU07QUFDckI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXGFiaVxcY29kZXJzXFx0dXBsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3Byb3BlcnRpZXMuanNcIjtcclxuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcclxuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xyXG5pbXBvcnQgeyBwYWNrLCB1bnBhY2sgfSBmcm9tIFwiLi9hcnJheS5qc1wiO1xyXG4vKipcclxuICogIEBfaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVHVwbGVDb2RlciBleHRlbmRzIENvZGVyIHtcclxuICAgIGNvZGVycztcclxuICAgIGNvbnN0cnVjdG9yKGNvZGVycywgbG9jYWxOYW1lKSB7XHJcbiAgICAgICAgbGV0IGR5bmFtaWMgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB0eXBlcyA9IFtdO1xyXG4gICAgICAgIGNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xyXG4gICAgICAgICAgICAgICAgZHluYW1pYyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHlwZXMucHVzaChjb2Rlci50eXBlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCB0eXBlID0gKFwidHVwbGUoXCIgKyB0eXBlcy5qb2luKFwiLFwiKSArIFwiKVwiKTtcclxuICAgICAgICBzdXBlcihcInR1cGxlXCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGNvZGVyczogT2JqZWN0LmZyZWV6ZShjb2RlcnMuc2xpY2UoKSkgfSk7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0VmFsdWUoKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICAgICAgdGhpcy5jb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcclxuICAgICAgICAgICAgdmFsdWVzLnB1c2goY29kZXIuZGVmYXVsdFZhbHVlKCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFdlIG9ubHkgb3V0cHV0IG5hbWVkIHByb3BlcnRpZXMgZm9yIHVuaXF1ZWx5IG5hbWVkIGNvZGVyc1xyXG4gICAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0gdGhpcy5jb2RlcnMucmVkdWNlKChhY2N1bSwgY29kZXIpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcclxuICAgICAgICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghYWNjdW1bbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcclxuICAgICAgICB9LCB7fSk7XHJcbiAgICAgICAgLy8gQWRkIG5hbWVkIHZhbHVlc1xyXG4gICAgICAgIHRoaXMuY29kZXJzLmZvckVhY2goKGNvZGVyLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcclxuICAgICAgICAgICAgaWYgKCFuYW1lIHx8IHVuaXF1ZU5hbWVzW25hbWVdICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwibGVuZ3RoXCIpIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBcIl9sZW5ndGhcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmFsdWVzW25hbWVdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YWx1ZXNbbmFtZV0gPSB2YWx1ZXNbaW5kZXhdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHZhbHVlcyk7XHJcbiAgICB9XHJcbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJ0dXBsZVwiKTtcclxuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIHRoaXMuY29kZXJzLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBkZWNvZGUocmVhZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHVucGFjayhyZWFkZXIsIHRoaXMuY29kZXJzKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10dXBsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/tuple.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/fragments.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/fragments.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConstructorFragment: () => (/* binding */ ConstructorFragment),\n/* harmony export */   ErrorFragment: () => (/* binding */ ErrorFragment),\n/* harmony export */   EventFragment: () => (/* binding */ EventFragment),\n/* harmony export */   FallbackFragment: () => (/* binding */ FallbackFragment),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   FunctionFragment: () => (/* binding */ FunctionFragment),\n/* harmony export */   NamedFragment: () => (/* binding */ NamedFragment),\n/* harmony export */   ParamType: () => (/* binding */ ParamType),\n/* harmony export */   StructFragment: () => (/* binding */ StructFragment)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hash/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/index.js\");\n/**\r\n *  A fragment is a single item from an ABI, which may represent any of:\r\n *\r\n *  - [Functions](FunctionFragment)\r\n *  - [Events](EventFragment)\r\n *  - [Constructors](ConstructorFragment)\r\n *  - Custom [Errors](ErrorFragment)\r\n *  - [Fallback or Receive](FallbackFragment) functions\r\n *\r\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\r\n */\r\n\r\n\r\n;\r\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\r\nfunction setify(items) {\r\n    const result = new Set();\r\n    items.forEach((k) => result.add(k));\r\n    return Object.freeze(result);\r\n}\r\nconst _kwVisibDeploy = \"external public payable override\";\r\nconst KwVisibDeploy = setify(_kwVisibDeploy.split(\" \"));\r\n// Visibility Keywords\r\nconst _kwVisib = \"constant external internal payable private public pure view override\";\r\nconst KwVisib = setify(_kwVisib.split(\" \"));\r\nconst _kwTypes = \"constructor error event fallback function receive struct\";\r\nconst KwTypes = setify(_kwTypes.split(\" \"));\r\nconst _kwModifiers = \"calldata memory storage payable indexed\";\r\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\r\nconst _kwOther = \"tuple returns\";\r\n// All Keywords\r\nconst _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(\" \");\r\nconst Keywords = setify(_keywords.split(\" \"));\r\n// Single character tokens\r\nconst SimpleTokens = {\r\n    \"(\": \"OPEN_PAREN\", \")\": \"CLOSE_PAREN\",\r\n    \"[\": \"OPEN_BRACKET\", \"]\": \"CLOSE_BRACKET\",\r\n    \",\": \"COMMA\", \"@\": \"AT\"\r\n};\r\n// Parser regexes to consume the next token\r\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\r\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\r\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\r\n// Parser regexs to check validity\r\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\r\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\r\nclass TokenString {\r\n    #offset;\r\n    #tokens;\r\n    get offset() { return this.#offset; }\r\n    get length() { return this.#tokens.length - this.#offset; }\r\n    constructor(tokens) {\r\n        this.#offset = 0;\r\n        this.#tokens = tokens.slice();\r\n    }\r\n    clone() { return new TokenString(this.#tokens); }\r\n    reset() { this.#offset = 0; }\r\n    #subTokenString(from = 0, to = 0) {\r\n        return new TokenString(this.#tokens.slice(from, to).map((t) => {\r\n            return Object.freeze(Object.assign({}, t, {\r\n                match: (t.match - from),\r\n                linkBack: (t.linkBack - from),\r\n                linkNext: (t.linkNext - from),\r\n            }));\r\n        }));\r\n    }\r\n    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\r\n    popKeyword(allowed) {\r\n        const top = this.peek();\r\n        if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) {\r\n            throw new Error(`expected keyword ${top.text}`);\r\n        }\r\n        return this.pop().text;\r\n    }\r\n    // Pops and returns the value of the next token if it is `type`; throws if out of tokens\r\n    popType(type) {\r\n        if (this.peek().type !== type) {\r\n            const top = this.peek();\r\n            throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);\r\n        }\r\n        return this.pop().text;\r\n    }\r\n    // Pops and returns a \"(\" TOKENS \")\"\r\n    popParen() {\r\n        const top = this.peek();\r\n        if (top.type !== \"OPEN_PAREN\") {\r\n            throw new Error(\"bad start\");\r\n        }\r\n        const result = this.#subTokenString(this.#offset + 1, top.match + 1);\r\n        this.#offset = top.match + 1;\r\n        return result;\r\n    }\r\n    // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\r\n    popParams() {\r\n        const top = this.peek();\r\n        if (top.type !== \"OPEN_PAREN\") {\r\n            throw new Error(\"bad start\");\r\n        }\r\n        const result = [];\r\n        while (this.#offset < top.match - 1) {\r\n            const link = this.peek().linkNext;\r\n            result.push(this.#subTokenString(this.#offset + 1, link));\r\n            this.#offset = link;\r\n        }\r\n        this.#offset = top.match + 1;\r\n        return result;\r\n    }\r\n    // Returns the top Token, throwing if out of tokens\r\n    peek() {\r\n        if (this.#offset >= this.#tokens.length) {\r\n            throw new Error(\"out-of-bounds\");\r\n        }\r\n        return this.#tokens[this.#offset];\r\n    }\r\n    // Returns the next value, if it is a keyword in `allowed`\r\n    peekKeyword(allowed) {\r\n        const top = this.peekType(\"KEYWORD\");\r\n        return (top != null && allowed.has(top)) ? top : null;\r\n    }\r\n    // Returns the value of the next token if it is `type`\r\n    peekType(type) {\r\n        if (this.length === 0) {\r\n            return null;\r\n        }\r\n        const top = this.peek();\r\n        return (top.type === type) ? top.text : null;\r\n    }\r\n    // Returns the next token; throws if out of tokens\r\n    pop() {\r\n        const result = this.peek();\r\n        this.#offset++;\r\n        return result;\r\n    }\r\n    toString() {\r\n        const tokens = [];\r\n        for (let i = this.#offset; i < this.#tokens.length; i++) {\r\n            const token = this.#tokens[i];\r\n            tokens.push(`${token.type}:${token.text}`);\r\n        }\r\n        return `<TokenString ${tokens.join(\" \")}>`;\r\n    }\r\n}\r\nfunction lex(text) {\r\n    const tokens = [];\r\n    const throwError = (message) => {\r\n        const token = (offset < text.length) ? JSON.stringify(text[offset]) : \"$EOI\";\r\n        throw new Error(`invalid token ${token} at ${offset}: ${message}`);\r\n    };\r\n    let brackets = [];\r\n    let commas = [];\r\n    let offset = 0;\r\n    while (offset < text.length) {\r\n        // Strip off any leading whitespace\r\n        let cur = text.substring(offset);\r\n        let match = cur.match(regexWhitespacePrefix);\r\n        if (match) {\r\n            offset += match[1].length;\r\n            cur = text.substring(offset);\r\n        }\r\n        const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: \"\", text: \"\", offset, value: -1 };\r\n        tokens.push(token);\r\n        let type = (SimpleTokens[cur[0]] || \"\");\r\n        if (type) {\r\n            token.type = type;\r\n            token.text = cur[0];\r\n            offset++;\r\n            if (type === \"OPEN_PAREN\") {\r\n                brackets.push(tokens.length - 1);\r\n                commas.push(tokens.length - 1);\r\n            }\r\n            else if (type == \"CLOSE_PAREN\") {\r\n                if (brackets.length === 0) {\r\n                    throwError(\"no matching open bracket\");\r\n                }\r\n                token.match = brackets.pop();\r\n                (tokens[token.match]).match = tokens.length - 1;\r\n                token.depth--;\r\n                token.linkBack = commas.pop();\r\n                (tokens[token.linkBack]).linkNext = tokens.length - 1;\r\n            }\r\n            else if (type === \"COMMA\") {\r\n                token.linkBack = commas.pop();\r\n                (tokens[token.linkBack]).linkNext = tokens.length - 1;\r\n                commas.push(tokens.length - 1);\r\n            }\r\n            else if (type === \"OPEN_BRACKET\") {\r\n                token.type = \"BRACKET\";\r\n            }\r\n            else if (type === \"CLOSE_BRACKET\") {\r\n                // Remove the CLOSE_BRACKET\r\n                let suffix = tokens.pop().text;\r\n                if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\r\n                    const value = tokens.pop().text;\r\n                    suffix = value + suffix;\r\n                    (tokens[tokens.length - 1]).value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(value);\r\n                }\r\n                if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\r\n                    throw new Error(\"missing opening bracket\");\r\n                }\r\n                (tokens[tokens.length - 1]).text += suffix;\r\n            }\r\n            continue;\r\n        }\r\n        match = cur.match(regexIdPrefix);\r\n        if (match) {\r\n            token.text = match[1];\r\n            offset += token.text.length;\r\n            if (Keywords.has(token.text)) {\r\n                token.type = \"KEYWORD\";\r\n                continue;\r\n            }\r\n            if (token.text.match(regexType)) {\r\n                token.type = \"TYPE\";\r\n                continue;\r\n            }\r\n            token.type = \"ID\";\r\n            continue;\r\n        }\r\n        match = cur.match(regexNumberPrefix);\r\n        if (match) {\r\n            token.text = match[1];\r\n            token.type = \"NUMBER\";\r\n            offset += token.text.length;\r\n            continue;\r\n        }\r\n        throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);\r\n    }\r\n    return new TokenString(tokens.map((t) => Object.freeze(t)));\r\n}\r\n// Check only one of `allowed` is in `set`\r\nfunction allowSingle(set, allowed) {\r\n    let included = [];\r\n    for (const key in allowed.keys()) {\r\n        if (set.has(key)) {\r\n            included.push(key);\r\n        }\r\n    }\r\n    if (included.length > 1) {\r\n        throw new Error(`conflicting types: ${included.join(\", \")}`);\r\n    }\r\n}\r\n// Functions to process a Solidity Signature TokenString from left-to-right for...\r\n// ...the name with an optional type, returning the name\r\nfunction consumeName(type, tokens) {\r\n    if (tokens.peekKeyword(KwTypes)) {\r\n        const keyword = tokens.pop().text;\r\n        if (keyword !== type) {\r\n            throw new Error(`expected ${type}, got ${keyword}`);\r\n        }\r\n    }\r\n    return tokens.popType(\"ID\");\r\n}\r\n// ...all keywords matching allowed, returning the keywords\r\nfunction consumeKeywords(tokens, allowed) {\r\n    const keywords = new Set();\r\n    while (true) {\r\n        const keyword = tokens.peekType(\"KEYWORD\");\r\n        if (keyword == null || (allowed && !allowed.has(keyword))) {\r\n            break;\r\n        }\r\n        tokens.pop();\r\n        if (keywords.has(keyword)) {\r\n            throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);\r\n        }\r\n        keywords.add(keyword);\r\n    }\r\n    return Object.freeze(keywords);\r\n}\r\n// ...all visibility keywords, returning the coalesced mutability\r\nfunction consumeMutability(tokens) {\r\n    let modifiers = consumeKeywords(tokens, KwVisib);\r\n    // Detect conflicting modifiers\r\n    allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\r\n    allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\r\n    // Process mutability states\r\n    if (modifiers.has(\"view\")) {\r\n        return \"view\";\r\n    }\r\n    if (modifiers.has(\"pure\")) {\r\n        return \"pure\";\r\n    }\r\n    if (modifiers.has(\"payable\")) {\r\n        return \"payable\";\r\n    }\r\n    if (modifiers.has(\"nonpayable\")) {\r\n        return \"nonpayable\";\r\n    }\r\n    // Process legacy `constant` last\r\n    if (modifiers.has(\"constant\")) {\r\n        return \"view\";\r\n    }\r\n    return \"nonpayable\";\r\n}\r\n// ...a parameter list, returning the ParamType list\r\nfunction consumeParams(tokens, allowIndexed) {\r\n    return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));\r\n}\r\n// ...a gas limit, returning a BigNumber or null if none\r\nfunction consumeGas(tokens) {\r\n    if (tokens.peekType(\"AT\")) {\r\n        tokens.pop();\r\n        if (tokens.peekType(\"NUMBER\")) {\r\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(tokens.pop().text);\r\n        }\r\n        throw new Error(\"invalid gas\");\r\n    }\r\n    return null;\r\n}\r\nfunction consumeEoi(tokens) {\r\n    if (tokens.length) {\r\n        throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);\r\n    }\r\n}\r\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\r\nfunction verifyBasicType(type) {\r\n    const match = type.match(regexType);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match, \"invalid type\", \"type\", type);\r\n    if (type === \"uint\") {\r\n        return \"uint256\";\r\n    }\r\n    if (type === \"int\") {\r\n        return \"int256\";\r\n    }\r\n    if (match[2]) {\r\n        // bytesXX\r\n        const length = parseInt(match[2]);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\r\n    }\r\n    else if (match[3]) {\r\n        // intXX or uintXX\r\n        const size = parseInt(match[3]);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(size !== 0 && size <= 256 && (size % 8) === 0, \"invalid numeric width\", \"type\", type);\r\n    }\r\n    return type;\r\n}\r\n// Make the Fragment constructors effectively private\r\nconst _guard = {};\r\nconst internal = Symbol.for(\"_ethers_internal\");\r\nconst ParamTypeInternal = \"_ParamTypeInternal\";\r\nconst ErrorFragmentInternal = \"_ErrorInternal\";\r\nconst EventFragmentInternal = \"_EventInternal\";\r\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\r\nconst FallbackFragmentInternal = \"_FallbackInternal\";\r\nconst FunctionFragmentInternal = \"_FunctionInternal\";\r\nconst StructFragmentInternal = \"_StructInternal\";\r\n/**\r\n *  Each input and output of a [[Fragment]] is an Array of **ParamType**.\r\n */\r\nclass ParamType {\r\n    /**\r\n     *  The local name of the parameter (or ``\"\"`` if unbound)\r\n     */\r\n    name;\r\n    /**\r\n     *  The fully qualified type (e.g. ``\"address\"``, ``\"tuple(address)\"``,\r\n     *  ``\"uint256[3][]\"``)\r\n     */\r\n    type;\r\n    /**\r\n     *  The base type (e.g. ``\"address\"``, ``\"tuple\"``, ``\"array\"``)\r\n     */\r\n    baseType;\r\n    /**\r\n     *  True if the parameters is indexed.\r\n     *\r\n     *  For non-indexable types this is ``null``.\r\n     */\r\n    indexed;\r\n    /**\r\n     *  The components for the tuple.\r\n     *\r\n     *  For non-tuple types this is ``null``.\r\n     */\r\n    components;\r\n    /**\r\n     *  The array length, or ``-1`` for dynamic-lengthed arrays.\r\n     *\r\n     *  For non-array types this is ``null``.\r\n     */\r\n    arrayLength;\r\n    /**\r\n     *  The type of each child in the array.\r\n     *\r\n     *  For non-array types this is ``null``.\r\n     */\r\n    arrayChildren;\r\n    /**\r\n     *  @private\r\n     */\r\n    constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"ParamType\");\r\n        Object.defineProperty(this, internal, { value: ParamTypeInternal });\r\n        if (components) {\r\n            components = Object.freeze(components.slice());\r\n        }\r\n        if (baseType === \"array\") {\r\n            if (arrayLength == null || arrayChildren == null) {\r\n                throw new Error(\"\");\r\n            }\r\n        }\r\n        else if (arrayLength != null || arrayChildren != null) {\r\n            throw new Error(\"\");\r\n        }\r\n        if (baseType === \"tuple\") {\r\n            if (components == null) {\r\n                throw new Error(\"\");\r\n            }\r\n        }\r\n        else if (components != null) {\r\n            throw new Error(\"\");\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\r\n            name, type, baseType, indexed, components, arrayLength, arrayChildren\r\n        });\r\n    }\r\n    /**\r\n     *  Return a string representation of this type.\r\n     *\r\n     *  For example,\r\n     *\r\n     *  ``sighash\" => \"(uint256,address)\"``\r\n     *\r\n     *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\r\n     *\r\n     *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\r\n     */\r\n    format(format) {\r\n        if (format == null) {\r\n            format = \"sighash\";\r\n        }\r\n        if (format === \"json\") {\r\n            const name = this.name || \"\";\r\n            if (this.isArray()) {\r\n                const result = JSON.parse(this.arrayChildren.format(\"json\"));\r\n                result.name = name;\r\n                result.type += `[${(this.arrayLength < 0 ? \"\" : String(this.arrayLength))}]`;\r\n                return JSON.stringify(result);\r\n            }\r\n            const result = {\r\n                type: ((this.baseType === \"tuple\") ? \"tuple\" : this.type),\r\n                name\r\n            };\r\n            if (typeof (this.indexed) === \"boolean\") {\r\n                result.indexed = this.indexed;\r\n            }\r\n            if (this.isTuple()) {\r\n                result.components = this.components.map((c) => JSON.parse(c.format(format)));\r\n            }\r\n            return JSON.stringify(result);\r\n        }\r\n        let result = \"\";\r\n        // Array\r\n        if (this.isArray()) {\r\n            result += this.arrayChildren.format(format);\r\n            result += `[${(this.arrayLength < 0 ? \"\" : String(this.arrayLength))}]`;\r\n        }\r\n        else {\r\n            if (this.isTuple()) {\r\n                result += \"(\" + this.components.map((comp) => comp.format(format)).join((format === \"full\") ? \", \" : \",\") + \")\";\r\n            }\r\n            else {\r\n                result += this.type;\r\n            }\r\n        }\r\n        if (format !== \"sighash\") {\r\n            if (this.indexed === true) {\r\n                result += \" indexed\";\r\n            }\r\n            if (format === \"full\" && this.name) {\r\n                result += \" \" + this.name;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     *  Returns true if %%this%% is an Array type.\r\n     *\r\n     *  This provides a type gaurd ensuring that [[arrayChildren]]\r\n     *  and [[arrayLength]] are non-null.\r\n     */\r\n    isArray() {\r\n        return (this.baseType === \"array\");\r\n    }\r\n    /**\r\n     *  Returns true if %%this%% is a Tuple type.\r\n     *\r\n     *  This provides a type gaurd ensuring that [[components]]\r\n     *  is non-null.\r\n     */\r\n    isTuple() {\r\n        return (this.baseType === \"tuple\");\r\n    }\r\n    /**\r\n     *  Returns true if %%this%% is an Indexable type.\r\n     *\r\n     *  This provides a type gaurd ensuring that [[indexed]]\r\n     *  is non-null.\r\n     */\r\n    isIndexable() {\r\n        return (this.indexed != null);\r\n    }\r\n    /**\r\n     *  Walks the **ParamType** with %%value%%, calling %%process%%\r\n     *  on each type, destructing the %%value%% recursively.\r\n     */\r\n    walk(value, process) {\r\n        if (this.isArray()) {\r\n            if (!Array.isArray(value)) {\r\n                throw new Error(\"invalid array value\");\r\n            }\r\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\r\n                throw new Error(\"array is wrong length\");\r\n            }\r\n            const _this = this;\r\n            return value.map((v) => (_this.arrayChildren.walk(v, process)));\r\n        }\r\n        if (this.isTuple()) {\r\n            if (!Array.isArray(value)) {\r\n                throw new Error(\"invalid tuple value\");\r\n            }\r\n            if (value.length !== this.components.length) {\r\n                throw new Error(\"array is wrong length\");\r\n            }\r\n            const _this = this;\r\n            return value.map((v, i) => (_this.components[i].walk(v, process)));\r\n        }\r\n        return process(this.type, value);\r\n    }\r\n    #walkAsync(promises, value, process, setValue) {\r\n        if (this.isArray()) {\r\n            if (!Array.isArray(value)) {\r\n                throw new Error(\"invalid array value\");\r\n            }\r\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\r\n                throw new Error(\"array is wrong length\");\r\n            }\r\n            const childType = this.arrayChildren;\r\n            const result = value.slice();\r\n            result.forEach((value, index) => {\r\n                childType.#walkAsync(promises, value, process, (value) => {\r\n                    result[index] = value;\r\n                });\r\n            });\r\n            setValue(result);\r\n            return;\r\n        }\r\n        if (this.isTuple()) {\r\n            const components = this.components;\r\n            // Convert the object into an array\r\n            let result;\r\n            if (Array.isArray(value)) {\r\n                result = value.slice();\r\n            }\r\n            else {\r\n                if (value == null || typeof (value) !== \"object\") {\r\n                    throw new Error(\"invalid tuple value\");\r\n                }\r\n                result = components.map((param) => {\r\n                    if (!param.name) {\r\n                        throw new Error(\"cannot use object value with unnamed components\");\r\n                    }\r\n                    if (!(param.name in value)) {\r\n                        throw new Error(`missing value for component ${param.name}`);\r\n                    }\r\n                    return value[param.name];\r\n                });\r\n            }\r\n            if (result.length !== this.components.length) {\r\n                throw new Error(\"array is wrong length\");\r\n            }\r\n            result.forEach((value, index) => {\r\n                components[index].#walkAsync(promises, value, process, (value) => {\r\n                    result[index] = value;\r\n                });\r\n            });\r\n            setValue(result);\r\n            return;\r\n        }\r\n        const result = process(this.type, value);\r\n        if (result.then) {\r\n            promises.push((async function () { setValue(await result); })());\r\n        }\r\n        else {\r\n            setValue(result);\r\n        }\r\n    }\r\n    /**\r\n     *  Walks the **ParamType** with %%value%%, asynchronously calling\r\n     *  %%process%% on each type, destructing the %%value%% recursively.\r\n     *\r\n     *  This can be used to resolve ENS names by walking and resolving each\r\n     *  ``\"address\"`` type.\r\n     */\r\n    async walkAsync(value, process) {\r\n        const promises = [];\r\n        const result = [value];\r\n        this.#walkAsync(promises, value, process, (value) => {\r\n            result[0] = value;\r\n        });\r\n        if (promises.length) {\r\n            await Promise.all(promises);\r\n        }\r\n        return result[0];\r\n    }\r\n    /**\r\n     *  Creates a new **ParamType** for %%obj%%.\r\n     *\r\n     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\r\n     *  otherwise the ``indexed`` keyword will throw an error.\r\n     */\r\n    static from(obj, allowIndexed) {\r\n        if (ParamType.isParamType(obj)) {\r\n            return obj;\r\n        }\r\n        if (typeof (obj) === \"string\") {\r\n            try {\r\n                return ParamType.from(lex(obj), allowIndexed);\r\n            }\r\n            catch (error) {\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid param type\", \"obj\", obj);\r\n            }\r\n        }\r\n        else if (obj instanceof TokenString) {\r\n            let type = \"\", baseType = \"\";\r\n            let comps = null;\r\n            if (consumeKeywords(obj, setify([\"tuple\"])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\r\n                // Tuple\r\n                baseType = \"tuple\";\r\n                comps = obj.popParams().map((t) => ParamType.from(t));\r\n                type = `tuple(${comps.map((c) => c.format()).join(\",\")})`;\r\n            }\r\n            else {\r\n                // Normal\r\n                type = verifyBasicType(obj.popType(\"TYPE\"));\r\n                baseType = type;\r\n            }\r\n            // Check for Array\r\n            let arrayChildren = null;\r\n            let arrayLength = null;\r\n            while (obj.length && obj.peekType(\"BRACKET\")) {\r\n                const bracket = obj.pop(); //arrays[i];\r\n                arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\r\n                arrayLength = bracket.value;\r\n                type += bracket.text;\r\n                baseType = \"array\";\r\n                comps = null;\r\n            }\r\n            let indexed = null;\r\n            const keywords = consumeKeywords(obj, KwModifiers);\r\n            if (keywords.has(\"indexed\")) {\r\n                if (!allowIndexed) {\r\n                    throw new Error(\"\");\r\n                }\r\n                indexed = true;\r\n            }\r\n            const name = (obj.peekType(\"ID\") ? obj.pop().text : \"\");\r\n            if (obj.length) {\r\n                throw new Error(\"leftover tokens\");\r\n            }\r\n            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\r\n        }\r\n        const name = obj.name;\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(!name || (typeof (name) === \"string\" && name.match(regexId)), \"invalid name\", \"obj.name\", name);\r\n        let indexed = obj.indexed;\r\n        if (indexed != null) {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\r\n            indexed = !!indexed;\r\n        }\r\n        let type = obj.type;\r\n        let arrayMatch = type.match(regexArrayType);\r\n        if (arrayMatch) {\r\n            const arrayLength = parseInt(arrayMatch[2] || \"-1\");\r\n            const arrayChildren = ParamType.from({\r\n                type: arrayMatch[1],\r\n                components: obj.components\r\n            });\r\n            return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\r\n        }\r\n        if (type === \"tuple\" || type.startsWith(\"tuple(\" /* fix: ) */) || type.startsWith(\"(\" /* fix: ) */)) {\r\n            const comps = (obj.components != null) ? obj.components.map((c) => ParamType.from(c)) : null;\r\n            const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null);\r\n            // @TODO: use lexer to validate and normalize type\r\n            return tuple;\r\n        }\r\n        type = verifyBasicType(obj.type);\r\n        return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\r\n    }\r\n    /**\r\n     *  Returns true if %%value%% is a **ParamType**.\r\n     */\r\n    static isParamType(value) {\r\n        return (value && value[internal] === ParamTypeInternal);\r\n    }\r\n}\r\n/**\r\n *  An abstract class to represent An individual fragment from a parse ABI.\r\n */\r\nclass Fragment {\r\n    /**\r\n     *  The type of the fragment.\r\n     */\r\n    type;\r\n    /**\r\n     *  The inputs for the fragment.\r\n     */\r\n    inputs;\r\n    /**\r\n     *  @private\r\n     */\r\n    constructor(guard, type, inputs) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"Fragment\");\r\n        inputs = Object.freeze(inputs.slice());\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { type, inputs });\r\n    }\r\n    /**\r\n     *  Creates a new **Fragment** for %%obj%%, wich can be any supported\r\n     *  ABI frgament type.\r\n     */\r\n    static from(obj) {\r\n        if (typeof (obj) === \"string\") {\r\n            // Try parsing JSON...\r\n            try {\r\n                Fragment.from(JSON.parse(obj));\r\n            }\r\n            catch (e) { }\r\n            // ...otherwise, use the human-readable lexer\r\n            return Fragment.from(lex(obj));\r\n        }\r\n        if (obj instanceof TokenString) {\r\n            // Human-readable ABI (already lexed)\r\n            const type = obj.peekKeyword(KwTypes);\r\n            switch (type) {\r\n                case \"constructor\": return ConstructorFragment.from(obj);\r\n                case \"error\": return ErrorFragment.from(obj);\r\n                case \"event\": return EventFragment.from(obj);\r\n                case \"fallback\":\r\n                case \"receive\":\r\n                    return FallbackFragment.from(obj);\r\n                case \"function\": return FunctionFragment.from(obj);\r\n                case \"struct\": return StructFragment.from(obj);\r\n            }\r\n        }\r\n        else if (typeof (obj) === \"object\") {\r\n            // JSON ABI\r\n            switch (obj.type) {\r\n                case \"constructor\": return ConstructorFragment.from(obj);\r\n                case \"error\": return ErrorFragment.from(obj);\r\n                case \"event\": return EventFragment.from(obj);\r\n                case \"fallback\":\r\n                case \"receive\":\r\n                    return FallbackFragment.from(obj);\r\n                case \"function\": return FunctionFragment.from(obj);\r\n                case \"struct\": return StructFragment.from(obj);\r\n            }\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `unsupported type: ${obj.type}`, \"UNSUPPORTED_OPERATION\", {\r\n                operation: \"Fragment.from\"\r\n            });\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported frgament object\", \"obj\", obj);\r\n    }\r\n    /**\r\n     *  Returns true if %%value%% is a [[ConstructorFragment]].\r\n     */\r\n    static isConstructor(value) {\r\n        return ConstructorFragment.isFragment(value);\r\n    }\r\n    /**\r\n     *  Returns true if %%value%% is an [[ErrorFragment]].\r\n     */\r\n    static isError(value) {\r\n        return ErrorFragment.isFragment(value);\r\n    }\r\n    /**\r\n     *  Returns true if %%value%% is an [[EventFragment]].\r\n     */\r\n    static isEvent(value) {\r\n        return EventFragment.isFragment(value);\r\n    }\r\n    /**\r\n     *  Returns true if %%value%% is a [[FunctionFragment]].\r\n     */\r\n    static isFunction(value) {\r\n        return FunctionFragment.isFragment(value);\r\n    }\r\n    /**\r\n     *  Returns true if %%value%% is a [[StructFragment]].\r\n     */\r\n    static isStruct(value) {\r\n        return StructFragment.isFragment(value);\r\n    }\r\n}\r\n/**\r\n *  An abstract class to represent An individual fragment\r\n *  which has a name from a parse ABI.\r\n */\r\nclass NamedFragment extends Fragment {\r\n    /**\r\n     *  The name of the fragment.\r\n     */\r\n    name;\r\n    /**\r\n     *  @private\r\n     */\r\n    constructor(guard, type, name, inputs) {\r\n        super(guard, type, inputs);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (name) === \"string\" && name.match(regexId), \"invalid identifier\", \"name\", name);\r\n        inputs = Object.freeze(inputs.slice());\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { name });\r\n    }\r\n}\r\nfunction joinParams(format, params) {\r\n    return \"(\" + params.map((p) => p.format(format)).join((format === \"full\") ? \", \" : \",\") + \")\";\r\n}\r\n/**\r\n *  A Fragment which represents a //Custom Error//.\r\n */\r\nclass ErrorFragment extends NamedFragment {\r\n    /**\r\n     *  @private\r\n     */\r\n    constructor(guard, name, inputs) {\r\n        super(guard, \"error\", name, inputs);\r\n        Object.defineProperty(this, internal, { value: ErrorFragmentInternal });\r\n    }\r\n    /**\r\n     *  The Custom Error selector.\r\n     */\r\n    get selector() {\r\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_1__.id)(this.format(\"sighash\")).substring(0, 10);\r\n    }\r\n    /**\r\n     *  Returns a string representation of this fragment as %%format%%.\r\n     */\r\n    format(format) {\r\n        if (format == null) {\r\n            format = \"sighash\";\r\n        }\r\n        if (format === \"json\") {\r\n            return JSON.stringify({\r\n                type: \"error\",\r\n                name: this.name,\r\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\r\n            });\r\n        }\r\n        const result = [];\r\n        if (format !== \"sighash\") {\r\n            result.push(\"error\");\r\n        }\r\n        result.push(this.name + joinParams(format, this.inputs));\r\n        return result.join(\" \");\r\n    }\r\n    /**\r\n     *  Returns a new **ErrorFragment** for %%obj%%.\r\n     */\r\n    static from(obj) {\r\n        if (ErrorFragment.isFragment(obj)) {\r\n            return obj;\r\n        }\r\n        if (typeof (obj) === \"string\") {\r\n            return ErrorFragment.from(lex(obj));\r\n        }\r\n        else if (obj instanceof TokenString) {\r\n            const name = consumeName(\"error\", obj);\r\n            const inputs = consumeParams(obj);\r\n            consumeEoi(obj);\r\n            return new ErrorFragment(_guard, name, inputs);\r\n        }\r\n        return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\r\n    }\r\n    /**\r\n     *  Returns ``true`` and provides a type guard if %%value%% is an\r\n     *  **ErrorFragment**.\r\n     */\r\n    static isFragment(value) {\r\n        return (value && value[internal] === ErrorFragmentInternal);\r\n    }\r\n}\r\n/**\r\n *  A Fragment which represents an Event.\r\n */\r\nclass EventFragment extends NamedFragment {\r\n    /**\r\n     *  Whether this event is anonymous.\r\n     */\r\n    anonymous;\r\n    /**\r\n     *  @private\r\n     */\r\n    constructor(guard, name, inputs, anonymous) {\r\n        super(guard, \"event\", name, inputs);\r\n        Object.defineProperty(this, internal, { value: EventFragmentInternal });\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { anonymous });\r\n    }\r\n    /**\r\n     *  The Event topic hash.\r\n     */\r\n    get topicHash() {\r\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_1__.id)(this.format(\"sighash\"));\r\n    }\r\n    /**\r\n     *  Returns a string representation of this event as %%format%%.\r\n     */\r\n    format(format) {\r\n        if (format == null) {\r\n            format = \"sighash\";\r\n        }\r\n        if (format === \"json\") {\r\n            return JSON.stringify({\r\n                type: \"event\",\r\n                anonymous: this.anonymous,\r\n                name: this.name,\r\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\r\n            });\r\n        }\r\n        const result = [];\r\n        if (format !== \"sighash\") {\r\n            result.push(\"event\");\r\n        }\r\n        result.push(this.name + joinParams(format, this.inputs));\r\n        if (format !== \"sighash\" && this.anonymous) {\r\n            result.push(\"anonymous\");\r\n        }\r\n        return result.join(\" \");\r\n    }\r\n    /**\r\n     *  Return the topic hash for an event with %%name%% and %%params%%.\r\n     */\r\n    static getTopicHash(name, params) {\r\n        params = (params || []).map((p) => ParamType.from(p));\r\n        const fragment = new EventFragment(_guard, name, params, false);\r\n        return fragment.topicHash;\r\n    }\r\n    /**\r\n     *  Returns a new **EventFragment** for %%obj%%.\r\n     */\r\n    static from(obj) {\r\n        if (EventFragment.isFragment(obj)) {\r\n            return obj;\r\n        }\r\n        if (typeof (obj) === \"string\") {\r\n            try {\r\n                return EventFragment.from(lex(obj));\r\n            }\r\n            catch (error) {\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid event fragment\", \"obj\", obj);\r\n            }\r\n        }\r\n        else if (obj instanceof TokenString) {\r\n            const name = consumeName(\"event\", obj);\r\n            const inputs = consumeParams(obj, true);\r\n            const anonymous = !!consumeKeywords(obj, setify([\"anonymous\"])).has(\"anonymous\");\r\n            consumeEoi(obj);\r\n            return new EventFragment(_guard, name, inputs, anonymous);\r\n        }\r\n        return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);\r\n    }\r\n    /**\r\n     *  Returns ``true`` and provides a type guard if %%value%% is an\r\n     *  **EventFragment**.\r\n     */\r\n    static isFragment(value) {\r\n        return (value && value[internal] === EventFragmentInternal);\r\n    }\r\n}\r\n/**\r\n *  A Fragment which represents a constructor.\r\n */\r\nclass ConstructorFragment extends Fragment {\r\n    /**\r\n     *  Whether the constructor can receive an endowment.\r\n     */\r\n    payable;\r\n    /**\r\n     *  The recommended gas limit for deployment or ``null``.\r\n     */\r\n    gas;\r\n    /**\r\n     *  @private\r\n     */\r\n    constructor(guard, type, inputs, payable, gas) {\r\n        super(guard, type, inputs);\r\n        Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { payable, gas });\r\n    }\r\n    /**\r\n     *  Returns a string representation of this constructor as %%format%%.\r\n     */\r\n    format(format) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\", \"UNSUPPORTED_OPERATION\", { operation: \"format(sighash)\" });\r\n        if (format === \"json\") {\r\n            return JSON.stringify({\r\n                type: \"constructor\",\r\n                stateMutability: (this.payable ? \"payable\" : \"undefined\"),\r\n                payable: this.payable,\r\n                gas: ((this.gas != null) ? this.gas : undefined),\r\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\r\n            });\r\n        }\r\n        const result = [`constructor${joinParams(format, this.inputs)}`];\r\n        if (this.payable) {\r\n            result.push(\"payable\");\r\n        }\r\n        if (this.gas != null) {\r\n            result.push(`@${this.gas.toString()}`);\r\n        }\r\n        return result.join(\" \");\r\n    }\r\n    /**\r\n     *  Returns a new **ConstructorFragment** for %%obj%%.\r\n     */\r\n    static from(obj) {\r\n        if (ConstructorFragment.isFragment(obj)) {\r\n            return obj;\r\n        }\r\n        if (typeof (obj) === \"string\") {\r\n            try {\r\n                return ConstructorFragment.from(lex(obj));\r\n            }\r\n            catch (error) {\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid constuctor fragment\", \"obj\", obj);\r\n            }\r\n        }\r\n        else if (obj instanceof TokenString) {\r\n            consumeKeywords(obj, setify([\"constructor\"]));\r\n            const inputs = consumeParams(obj);\r\n            const payable = !!consumeKeywords(obj, KwVisibDeploy).has(\"payable\");\r\n            const gas = consumeGas(obj);\r\n            consumeEoi(obj);\r\n            return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\r\n        }\r\n        return new ConstructorFragment(_guard, \"constructor\", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, (obj.gas != null) ? obj.gas : null);\r\n    }\r\n    /**\r\n     *  Returns ``true`` and provides a type guard if %%value%% is a\r\n     *  **ConstructorFragment**.\r\n     */\r\n    static isFragment(value) {\r\n        return (value && value[internal] === ConstructorFragmentInternal);\r\n    }\r\n}\r\n/**\r\n *  A Fragment which represents a method.\r\n */\r\nclass FallbackFragment extends Fragment {\r\n    /**\r\n     *  If the function can be sent value during invocation.\r\n     */\r\n    payable;\r\n    constructor(guard, inputs, payable) {\r\n        super(guard, \"fallback\", inputs);\r\n        Object.defineProperty(this, internal, { value: FallbackFragmentInternal });\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { payable });\r\n    }\r\n    /**\r\n     *  Returns a string representation of this fallback as %%format%%.\r\n     */\r\n    format(format) {\r\n        const type = ((this.inputs.length === 0) ? \"receive\" : \"fallback\");\r\n        if (format === \"json\") {\r\n            const stateMutability = (this.payable ? \"payable\" : \"nonpayable\");\r\n            return JSON.stringify({ type, stateMutability });\r\n        }\r\n        return `${type}()${this.payable ? \" payable\" : \"\"}`;\r\n    }\r\n    /**\r\n     *  Returns a new **FallbackFragment** for %%obj%%.\r\n     */\r\n    static from(obj) {\r\n        if (FallbackFragment.isFragment(obj)) {\r\n            return obj;\r\n        }\r\n        if (typeof (obj) === \"string\") {\r\n            try {\r\n                return FallbackFragment.from(lex(obj));\r\n            }\r\n            catch (error) {\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid fallback fragment\", \"obj\", obj);\r\n            }\r\n        }\r\n        else if (obj instanceof TokenString) {\r\n            const errorObj = obj.toString();\r\n            const topIsValid = obj.peekKeyword(setify([\"fallback\", \"receive\"]));\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\r\n            const type = obj.popKeyword(setify([\"fallback\", \"receive\"]));\r\n            // receive()\r\n            if (type === \"receive\") {\r\n                const inputs = consumeParams(obj);\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(inputs.length === 0, `receive cannot have arguments`, \"obj.inputs\", inputs);\r\n                consumeKeywords(obj, setify([\"payable\"]));\r\n                consumeEoi(obj);\r\n                return new FallbackFragment(_guard, [], true);\r\n            }\r\n            // fallback() [payable]\r\n            // fallback(bytes) [payable] returns (bytes)\r\n            let inputs = consumeParams(obj);\r\n            if (inputs.length) {\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(inputs.length === 1 && inputs[0].type === \"bytes\", \"invalid fallback inputs\", \"obj.inputs\", inputs.map((i) => i.format(\"minimal\")).join(\", \"));\r\n            }\r\n            else {\r\n                inputs = [ParamType.from(\"bytes\")];\r\n            }\r\n            const mutability = consumeMutability(obj);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\r\n            if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\r\n                const outputs = consumeParams(obj);\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(outputs.length === 1 && outputs[0].type === \"bytes\", \"invalid fallback outputs\", \"obj.outputs\", outputs.map((i) => i.format(\"minimal\")).join(\", \"));\r\n            }\r\n            consumeEoi(obj);\r\n            return new FallbackFragment(_guard, inputs, mutability === \"payable\");\r\n        }\r\n        if (obj.type === \"receive\") {\r\n            return new FallbackFragment(_guard, [], true);\r\n        }\r\n        if (obj.type === \"fallback\") {\r\n            const inputs = [ParamType.from(\"bytes\")];\r\n            const payable = (obj.stateMutability === \"payable\");\r\n            return new FallbackFragment(_guard, inputs, payable);\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid fallback description\", \"obj\", obj);\r\n    }\r\n    /**\r\n     *  Returns ``true`` and provides a type guard if %%value%% is a\r\n     *  **FallbackFragment**.\r\n     */\r\n    static isFragment(value) {\r\n        return (value && value[internal] === FallbackFragmentInternal);\r\n    }\r\n}\r\n/**\r\n *  A Fragment which represents a method.\r\n */\r\nclass FunctionFragment extends NamedFragment {\r\n    /**\r\n     *  If the function is constant (e.g. ``pure`` or ``view`` functions).\r\n     */\r\n    constant;\r\n    /**\r\n     *  The returned types for the result of calling this function.\r\n     */\r\n    outputs;\r\n    /**\r\n     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``\r\n     *  or ``pure``)\r\n     */\r\n    stateMutability;\r\n    /**\r\n     *  If the function can be sent value during invocation.\r\n     */\r\n    payable;\r\n    /**\r\n     *  The recommended gas limit to send when calling this function.\r\n     */\r\n    gas;\r\n    /**\r\n     *  @private\r\n     */\r\n    constructor(guard, name, stateMutability, inputs, outputs, gas) {\r\n        super(guard, \"function\", name, inputs);\r\n        Object.defineProperty(this, internal, { value: FunctionFragmentInternal });\r\n        outputs = Object.freeze(outputs.slice());\r\n        const constant = (stateMutability === \"view\" || stateMutability === \"pure\");\r\n        const payable = (stateMutability === \"payable\");\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { constant, gas, outputs, payable, stateMutability });\r\n    }\r\n    /**\r\n     *  The Function selector.\r\n     */\r\n    get selector() {\r\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_1__.id)(this.format(\"sighash\")).substring(0, 10);\r\n    }\r\n    /**\r\n     *  Returns a string representation of this function as %%format%%.\r\n     */\r\n    format(format) {\r\n        if (format == null) {\r\n            format = \"sighash\";\r\n        }\r\n        if (format === \"json\") {\r\n            return JSON.stringify({\r\n                type: \"function\",\r\n                name: this.name,\r\n                constant: this.constant,\r\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\r\n                payable: this.payable,\r\n                gas: ((this.gas != null) ? this.gas : undefined),\r\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),\r\n                outputs: this.outputs.map((o) => JSON.parse(o.format(format))),\r\n            });\r\n        }\r\n        const result = [];\r\n        if (format !== \"sighash\") {\r\n            result.push(\"function\");\r\n        }\r\n        result.push(this.name + joinParams(format, this.inputs));\r\n        if (format !== \"sighash\") {\r\n            if (this.stateMutability !== \"nonpayable\") {\r\n                result.push(this.stateMutability);\r\n            }\r\n            if (this.outputs && this.outputs.length) {\r\n                result.push(\"returns\");\r\n                result.push(joinParams(format, this.outputs));\r\n            }\r\n            if (this.gas != null) {\r\n                result.push(`@${this.gas.toString()}`);\r\n            }\r\n        }\r\n        return result.join(\" \");\r\n    }\r\n    /**\r\n     *  Return the selector for a function with %%name%% and %%params%%.\r\n     */\r\n    static getSelector(name, params) {\r\n        params = (params || []).map((p) => ParamType.from(p));\r\n        const fragment = new FunctionFragment(_guard, name, \"view\", params, [], null);\r\n        return fragment.selector;\r\n    }\r\n    /**\r\n     *  Returns a new **FunctionFragment** for %%obj%%.\r\n     */\r\n    static from(obj) {\r\n        if (FunctionFragment.isFragment(obj)) {\r\n            return obj;\r\n        }\r\n        if (typeof (obj) === \"string\") {\r\n            try {\r\n                return FunctionFragment.from(lex(obj));\r\n            }\r\n            catch (error) {\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid function fragment\", \"obj\", obj);\r\n            }\r\n        }\r\n        else if (obj instanceof TokenString) {\r\n            const name = consumeName(\"function\", obj);\r\n            const inputs = consumeParams(obj);\r\n            const mutability = consumeMutability(obj);\r\n            let outputs = [];\r\n            if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\r\n                outputs = consumeParams(obj);\r\n            }\r\n            const gas = consumeGas(obj);\r\n            consumeEoi(obj);\r\n            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\r\n        }\r\n        let stateMutability = obj.stateMutability;\r\n        // Use legacy Solidity ABI logic if stateMutability is missing\r\n        if (stateMutability == null) {\r\n            stateMutability = \"payable\";\r\n            if (typeof (obj.constant) === \"boolean\") {\r\n                stateMutability = \"view\";\r\n                if (!obj.constant) {\r\n                    stateMutability = \"payable\";\r\n                    if (typeof (obj.payable) === \"boolean\" && !obj.payable) {\r\n                        stateMutability = \"nonpayable\";\r\n                    }\r\n                }\r\n            }\r\n            else if (typeof (obj.payable) === \"boolean\" && !obj.payable) {\r\n                stateMutability = \"nonpayable\";\r\n            }\r\n        }\r\n        // @TODO: verifyState for stateMutability (e.g. throw if\r\n        //        payable: false but stateMutability is \"nonpayable\")\r\n        return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], (obj.gas != null) ? obj.gas : null);\r\n    }\r\n    /**\r\n     *  Returns ``true`` and provides a type guard if %%value%% is a\r\n     *  **FunctionFragment**.\r\n     */\r\n    static isFragment(value) {\r\n        return (value && value[internal] === FunctionFragmentInternal);\r\n    }\r\n}\r\n/**\r\n *  A Fragment which represents a structure.\r\n */\r\nclass StructFragment extends NamedFragment {\r\n    /**\r\n     *  @private\r\n     */\r\n    constructor(guard, name, inputs) {\r\n        super(guard, \"struct\", name, inputs);\r\n        Object.defineProperty(this, internal, { value: StructFragmentInternal });\r\n    }\r\n    /**\r\n     *  Returns a string representation of this struct as %%format%%.\r\n     */\r\n    format() {\r\n        throw new Error(\"@TODO\");\r\n    }\r\n    /**\r\n     *  Returns a new **StructFragment** for %%obj%%.\r\n     */\r\n    static from(obj) {\r\n        if (typeof (obj) === \"string\") {\r\n            try {\r\n                return StructFragment.from(lex(obj));\r\n            }\r\n            catch (error) {\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid struct fragment\", \"obj\", obj);\r\n            }\r\n        }\r\n        else if (obj instanceof TokenString) {\r\n            const name = consumeName(\"struct\", obj);\r\n            const inputs = consumeParams(obj);\r\n            consumeEoi(obj);\r\n            return new StructFragment(_guard, name, inputs);\r\n        }\r\n        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\r\n    }\r\n    // @TODO: fix this return type\r\n    /**\r\n     *  Returns ``true`` and provides a type guard if %%value%% is a\r\n     *  **StructFragment**.\r\n     */\r\n    static isFragment(value) {\r\n        return (value && value[internal] === StructFragmentInternal);\r\n    }\r\n}\r\n//# sourceMappingURL=fragments.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvZnJhZ21lbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrSDtBQUM1RTtBQUN0QztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU8sTUFBTSxVQUFVLEVBQUUseUJBQXlCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5QkFBeUI7QUFDNUQ7QUFDQSwyQkFBMkIsV0FBVyxHQUFHLFdBQVc7QUFDcEQ7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPLEtBQUssT0FBTyxJQUFJLFFBQVE7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDBEQUFTO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3QkFBd0IsY0FBYyxPQUFPO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxvQkFBb0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxLQUFLLFFBQVEsUUFBUTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHdCQUF3QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMERBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYyxJQUFJLGtCQUFrQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOERBQWE7QUFDckIsZ0RBQWdELDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1REFBdUQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVEQUF1RDtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxXQUFXO0FBQ2xGO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MseUJBQXlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUNBQXVDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBLFlBQVksK0RBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4REFBYTtBQUNyQjtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1REFBTSw2QkFBNkIsU0FBUztBQUN4RDtBQUNBLGFBQWE7QUFDYjtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0EsUUFBUSxpRUFBZ0IsU0FBUyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsOEJBQThCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtEQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsOEJBQThCO0FBQzlFLFFBQVEsaUVBQWdCLFNBQVMsV0FBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxvQ0FBb0M7QUFDcEYsUUFBUSxpRUFBZ0IsU0FBUyxjQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFNLCtHQUErRyw4QkFBOEI7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQ0FBc0MsZ0NBQWdDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGlDQUFpQztBQUNqRixRQUFRLGlFQUFnQixTQUFTLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1QkFBdUI7QUFDM0Q7QUFDQSxrQkFBa0IsS0FBSyxJQUFJLCtCQUErQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUFjO0FBQzFCO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUNBQWlDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsa0RBQWtEO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtEQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwrQkFBK0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxhYmlcXGZyYWdtZW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIEEgZnJhZ21lbnQgaXMgYSBzaW5nbGUgaXRlbSBmcm9tIGFuIEFCSSwgd2hpY2ggbWF5IHJlcHJlc2VudCBhbnkgb2Y6XHJcbiAqXHJcbiAqICAtIFtGdW5jdGlvbnNdKEZ1bmN0aW9uRnJhZ21lbnQpXHJcbiAqICAtIFtFdmVudHNdKEV2ZW50RnJhZ21lbnQpXHJcbiAqICAtIFtDb25zdHJ1Y3RvcnNdKENvbnN0cnVjdG9yRnJhZ21lbnQpXHJcbiAqICAtIEN1c3RvbSBbRXJyb3JzXShFcnJvckZyYWdtZW50KVxyXG4gKiAgLSBbRmFsbGJhY2sgb3IgUmVjZWl2ZV0oRmFsbGJhY2tGcmFnbWVudCkgZnVuY3Rpb25zXHJcbiAqXHJcbiAqICBAX3N1YnNlY3Rpb24gYXBpL2FiaS9hYmktY29kZXI6RnJhZ21lbnRzICBbYWJvdXQtZnJhZ21lbnRzXVxyXG4gKi9cclxuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGFzc2VydCwgYXNzZXJ0UHJpdmF0ZSwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgaWQgfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xyXG47XHJcbi8vIFsgXCJhXCIsIFwiYlwiIF0gPT4geyBcImFcIjogMSwgXCJiXCI6IDEgfVxyXG5mdW5jdGlvbiBzZXRpZnkoaXRlbXMpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoKTtcclxuICAgIGl0ZW1zLmZvckVhY2goKGspID0+IHJlc3VsdC5hZGQoaykpO1xyXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUocmVzdWx0KTtcclxufVxyXG5jb25zdCBfa3dWaXNpYkRlcGxveSA9IFwiZXh0ZXJuYWwgcHVibGljIHBheWFibGUgb3ZlcnJpZGVcIjtcclxuY29uc3QgS3dWaXNpYkRlcGxveSA9IHNldGlmeShfa3dWaXNpYkRlcGxveS5zcGxpdChcIiBcIikpO1xyXG4vLyBWaXNpYmlsaXR5IEtleXdvcmRzXHJcbmNvbnN0IF9rd1Zpc2liID0gXCJjb25zdGFudCBleHRlcm5hbCBpbnRlcm5hbCBwYXlhYmxlIHByaXZhdGUgcHVibGljIHB1cmUgdmlldyBvdmVycmlkZVwiO1xyXG5jb25zdCBLd1Zpc2liID0gc2V0aWZ5KF9rd1Zpc2liLnNwbGl0KFwiIFwiKSk7XHJcbmNvbnN0IF9rd1R5cGVzID0gXCJjb25zdHJ1Y3RvciBlcnJvciBldmVudCBmYWxsYmFjayBmdW5jdGlvbiByZWNlaXZlIHN0cnVjdFwiO1xyXG5jb25zdCBLd1R5cGVzID0gc2V0aWZ5KF9rd1R5cGVzLnNwbGl0KFwiIFwiKSk7XHJcbmNvbnN0IF9rd01vZGlmaWVycyA9IFwiY2FsbGRhdGEgbWVtb3J5IHN0b3JhZ2UgcGF5YWJsZSBpbmRleGVkXCI7XHJcbmNvbnN0IEt3TW9kaWZpZXJzID0gc2V0aWZ5KF9rd01vZGlmaWVycy5zcGxpdChcIiBcIikpO1xyXG5jb25zdCBfa3dPdGhlciA9IFwidHVwbGUgcmV0dXJuc1wiO1xyXG4vLyBBbGwgS2V5d29yZHNcclxuY29uc3QgX2tleXdvcmRzID0gW19rd1R5cGVzLCBfa3dNb2RpZmllcnMsIF9rd090aGVyLCBfa3dWaXNpYl0uam9pbihcIiBcIik7XHJcbmNvbnN0IEtleXdvcmRzID0gc2V0aWZ5KF9rZXl3b3Jkcy5zcGxpdChcIiBcIikpO1xyXG4vLyBTaW5nbGUgY2hhcmFjdGVyIHRva2Vuc1xyXG5jb25zdCBTaW1wbGVUb2tlbnMgPSB7XHJcbiAgICBcIihcIjogXCJPUEVOX1BBUkVOXCIsIFwiKVwiOiBcIkNMT1NFX1BBUkVOXCIsXHJcbiAgICBcIltcIjogXCJPUEVOX0JSQUNLRVRcIiwgXCJdXCI6IFwiQ0xPU0VfQlJBQ0tFVFwiLFxyXG4gICAgXCIsXCI6IFwiQ09NTUFcIiwgXCJAXCI6IFwiQVRcIlxyXG59O1xyXG4vLyBQYXJzZXIgcmVnZXhlcyB0byBjb25zdW1lIHRoZSBuZXh0IHRva2VuXHJcbmNvbnN0IHJlZ2V4V2hpdGVzcGFjZVByZWZpeCA9IG5ldyBSZWdFeHAoXCJeKFxcXFxzKilcIik7XHJcbmNvbnN0IHJlZ2V4TnVtYmVyUHJlZml4ID0gbmV3IFJlZ0V4cChcIl4oWzAtOV0rKVwiKTtcclxuY29uc3QgcmVnZXhJZFByZWZpeCA9IG5ldyBSZWdFeHAoXCJeKFthLXpBLVokX11bYS16QS1aMC05JF9dKilcIik7XHJcbi8vIFBhcnNlciByZWdleHMgdG8gY2hlY2sgdmFsaWRpdHlcclxuY29uc3QgcmVnZXhJZCA9IG5ldyBSZWdFeHAoXCJeKFthLXpBLVokX11bYS16QS1aMC05JF9dKikkXCIpO1xyXG5jb25zdCByZWdleFR5cGUgPSBuZXcgUmVnRXhwKFwiXihhZGRyZXNzfGJvb2x8Ynl0ZXMoWzAtOV0qKXxzdHJpbmd8dT9pbnQoWzAtOV0qKSkkXCIpO1xyXG5jbGFzcyBUb2tlblN0cmluZyB7XHJcbiAgICAjb2Zmc2V0O1xyXG4gICAgI3Rva2VucztcclxuICAgIGdldCBvZmZzZXQoKSB7IHJldHVybiB0aGlzLiNvZmZzZXQ7IH1cclxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLiN0b2tlbnMubGVuZ3RoIC0gdGhpcy4jb2Zmc2V0OyB9XHJcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbnMpIHtcclxuICAgICAgICB0aGlzLiNvZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuI3Rva2VucyA9IHRva2Vucy5zbGljZSgpO1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7IHJldHVybiBuZXcgVG9rZW5TdHJpbmcodGhpcy4jdG9rZW5zKTsgfVxyXG4gICAgcmVzZXQoKSB7IHRoaXMuI29mZnNldCA9IDA7IH1cclxuICAgICNzdWJUb2tlblN0cmluZyhmcm9tID0gMCwgdG8gPSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUb2tlblN0cmluZyh0aGlzLiN0b2tlbnMuc2xpY2UoZnJvbSwgdG8pLm1hcCgodCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShPYmplY3QuYXNzaWduKHt9LCB0LCB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaDogKHQubWF0Y2ggLSBmcm9tKSxcclxuICAgICAgICAgICAgICAgIGxpbmtCYWNrOiAodC5saW5rQmFjayAtIGZyb20pLFxyXG4gICAgICAgICAgICAgICAgbGlua05leHQ6ICh0LmxpbmtOZXh0IC0gZnJvbSksXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbmV4dCB0b2tlbiwgaWYgaXQgaXMgYSBrZXl3b3JkIGluIGFsbG93ZWQ7IHRocm93cyBpZiBvdXQgb2YgdG9rZW5zXHJcbiAgICBwb3BLZXl3b3JkKGFsbG93ZWQpIHtcclxuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcclxuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiS0VZV09SRFwiIHx8ICFhbGxvd2VkLmhhcyh0b3AudGV4dCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBrZXl3b3JkICR7dG9wLnRleHR9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnBvcCgpLnRleHQ7XHJcbiAgICB9XHJcbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbmV4dCB0b2tlbiBpZiBpdCBpcyBgdHlwZWA7IHRocm93cyBpZiBvdXQgb2YgdG9rZW5zXHJcbiAgICBwb3BUeXBlKHR5cGUpIHtcclxuICAgICAgICBpZiAodGhpcy5wZWVrKCkudHlwZSAhPT0gdHlwZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke3R5cGV9OyBnb3QgJHt0b3AudHlwZX0gJHtKU09OLnN0cmluZ2lmeSh0b3AudGV4dCl9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnBvcCgpLnRleHQ7XHJcbiAgICB9XHJcbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIGEgXCIoXCIgVE9LRU5TIFwiKVwiXHJcbiAgICBwb3BQYXJlbigpIHtcclxuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcclxuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiT1BFTl9QQVJFTlwiKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBzdGFydFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jc3ViVG9rZW5TdHJpbmcodGhpcy4jb2Zmc2V0ICsgMSwgdG9wLm1hdGNoICsgMSk7XHJcbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gdG9wLm1hdGNoICsgMTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyB0aGUgaXRlbXMgd2l0aGluIFwiKFwiIElURU0xIFwiLFwiIElURU0yIFwiLFwiIC4uLiBcIilcIlxyXG4gICAgcG9wUGFyYW1zKCkge1xyXG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xyXG4gICAgICAgIGlmICh0b3AudHlwZSAhPT0gXCJPUEVOX1BBUkVOXCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHN0YXJ0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICB3aGlsZSAodGhpcy4jb2Zmc2V0IDwgdG9wLm1hdGNoIC0gMSkge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5wZWVrKCkubGlua05leHQ7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuI3N1YlRva2VuU3RyaW5nKHRoaXMuI29mZnNldCArIDEsIGxpbmspKTtcclxuICAgICAgICAgICAgdGhpcy4jb2Zmc2V0ID0gbGluaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gdG9wLm1hdGNoICsgMTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyB0aGUgdG9wIFRva2VuLCB0aHJvd2luZyBpZiBvdXQgb2YgdG9rZW5zXHJcbiAgICBwZWVrKCkge1xyXG4gICAgICAgIGlmICh0aGlzLiNvZmZzZXQgPj0gdGhpcy4jdG9rZW5zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdXQtb2YtYm91bmRzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy4jdG9rZW5zW3RoaXMuI29mZnNldF07XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIHRoZSBuZXh0IHZhbHVlLCBpZiBpdCBpcyBhIGtleXdvcmQgaW4gYGFsbG93ZWRgXHJcbiAgICBwZWVrS2V5d29yZChhbGxvd2VkKSB7XHJcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrVHlwZShcIktFWVdPUkRcIik7XHJcbiAgICAgICAgcmV0dXJuICh0b3AgIT0gbnVsbCAmJiBhbGxvd2VkLmhhcyh0b3ApKSA/IHRvcCA6IG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbmV4dCB0b2tlbiBpZiBpdCBpcyBgdHlwZWBcclxuICAgIHBlZWtUeXBlKHR5cGUpIHtcclxuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xyXG4gICAgICAgIHJldHVybiAodG9wLnR5cGUgPT09IHR5cGUpID8gdG9wLnRleHQgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyB0aGUgbmV4dCB0b2tlbjsgdGhyb3dzIGlmIG91dCBvZiB0b2tlbnNcclxuICAgIHBvcCgpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnBlZWsoKTtcclxuICAgICAgICB0aGlzLiNvZmZzZXQrKztcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgY29uc3QgdG9rZW5zID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuI29mZnNldDsgaSA8IHRoaXMuI3Rva2Vucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuI3Rva2Vuc1tpXTtcclxuICAgICAgICAgICAgdG9rZW5zLnB1c2goYCR7dG9rZW4udHlwZX06JHt0b2tlbi50ZXh0fWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYDxUb2tlblN0cmluZyAke3Rva2Vucy5qb2luKFwiIFwiKX0+YDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBsZXgodGV4dCkge1xyXG4gICAgY29uc3QgdG9rZW5zID0gW107XHJcbiAgICBjb25zdCB0aHJvd0Vycm9yID0gKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICBjb25zdCB0b2tlbiA9IChvZmZzZXQgPCB0ZXh0Lmxlbmd0aCkgPyBKU09OLnN0cmluZ2lmeSh0ZXh0W29mZnNldF0pIDogXCIkRU9JXCI7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHRva2VuICR7dG9rZW59IGF0ICR7b2Zmc2V0fTogJHttZXNzYWdlfWApO1xyXG4gICAgfTtcclxuICAgIGxldCBicmFja2V0cyA9IFtdO1xyXG4gICAgbGV0IGNvbW1hcyA9IFtdO1xyXG4gICAgbGV0IG9mZnNldCA9IDA7XHJcbiAgICB3aGlsZSAob2Zmc2V0IDwgdGV4dC5sZW5ndGgpIHtcclxuICAgICAgICAvLyBTdHJpcCBvZmYgYW55IGxlYWRpbmcgd2hpdGVzcGFjZVxyXG4gICAgICAgIGxldCBjdXIgPSB0ZXh0LnN1YnN0cmluZyhvZmZzZXQpO1xyXG4gICAgICAgIGxldCBtYXRjaCA9IGN1ci5tYXRjaChyZWdleFdoaXRlc3BhY2VQcmVmaXgpO1xyXG4gICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gbWF0Y2hbMV0ubGVuZ3RoO1xyXG4gICAgICAgICAgICBjdXIgPSB0ZXh0LnN1YnN0cmluZyhvZmZzZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0b2tlbiA9IHsgZGVwdGg6IGJyYWNrZXRzLmxlbmd0aCwgbGlua0JhY2s6IC0xLCBsaW5rTmV4dDogLTEsIG1hdGNoOiAtMSwgdHlwZTogXCJcIiwgdGV4dDogXCJcIiwgb2Zmc2V0LCB2YWx1ZTogLTEgfTtcclxuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XHJcbiAgICAgICAgbGV0IHR5cGUgPSAoU2ltcGxlVG9rZW5zW2N1clswXV0gfHwgXCJcIik7XHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgdG9rZW4udHlwZSA9IHR5cGU7XHJcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSBjdXJbMF07XHJcbiAgICAgICAgICAgIG9mZnNldCsrO1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJPUEVOX1BBUkVOXCIpIHtcclxuICAgICAgICAgICAgICAgIGJyYWNrZXRzLnB1c2godG9rZW5zLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgY29tbWFzLnB1c2godG9rZW5zLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJDTE9TRV9QQVJFTlwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihcIm5vIG1hdGNoaW5nIG9wZW4gYnJhY2tldFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRva2VuLm1hdGNoID0gYnJhY2tldHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2VuLm1hdGNoXSkubWF0Y2ggPSB0b2tlbnMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgIHRva2VuLmRlcHRoLS07XHJcbiAgICAgICAgICAgICAgICB0b2tlbi5saW5rQmFjayA9IGNvbW1hcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW4ubGlua0JhY2tdKS5saW5rTmV4dCA9IHRva2Vucy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiQ09NTUFcIikge1xyXG4gICAgICAgICAgICAgICAgdG9rZW4ubGlua0JhY2sgPSBjb21tYXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2VuLmxpbmtCYWNrXSkubGlua05leHQgPSB0b2tlbnMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgIGNvbW1hcy5wdXNoKHRva2Vucy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcIk9QRU5fQlJBQ0tFVFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJCUkFDS0VUXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJDTE9TRV9CUkFDS0VUXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgQ0xPU0VfQlJBQ0tFVFxyXG4gICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IHRva2Vucy5wb3AoKS50ZXh0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAwICYmIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udHlwZSA9PT0gXCJOVU1CRVJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdG9rZW5zLnBvcCgpLnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gdmFsdWUgKyBzdWZmaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0pLnZhbHVlID0gZ2V0TnVtYmVyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udHlwZSAhPT0gXCJCUkFDS0VUXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIG9wZW5pbmcgYnJhY2tldFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKS50ZXh0ICs9IHN1ZmZpeDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWF0Y2ggPSBjdXIubWF0Y2gocmVnZXhJZFByZWZpeCk7XHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSBtYXRjaFsxXTtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IHRva2VuLnRleHQubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoS2V5d29yZHMuaGFzKHRva2VuLnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJLRVlXT1JEXCI7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodG9rZW4udGV4dC5tYXRjaChyZWdleFR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJUWVBFXCI7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0b2tlbi50eXBlID0gXCJJRFwiO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWF0Y2ggPSBjdXIubWF0Y2gocmVnZXhOdW1iZXJQcmVmaXgpO1xyXG4gICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gbWF0Y2hbMV07XHJcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIk5VTUJFUlwiO1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gdG9rZW4udGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgdG9rZW4gJHtKU09OLnN0cmluZ2lmeShjdXJbMF0pfSBhdCBwb3NpdGlvbiAke29mZnNldH1gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgVG9rZW5TdHJpbmcodG9rZW5zLm1hcCgodCkgPT4gT2JqZWN0LmZyZWV6ZSh0KSkpO1xyXG59XHJcbi8vIENoZWNrIG9ubHkgb25lIG9mIGBhbGxvd2VkYCBpcyBpbiBgc2V0YFxyXG5mdW5jdGlvbiBhbGxvd1NpbmdsZShzZXQsIGFsbG93ZWQpIHtcclxuICAgIGxldCBpbmNsdWRlZCA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gYWxsb3dlZC5rZXlzKCkpIHtcclxuICAgICAgICBpZiAoc2V0LmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgIGluY2x1ZGVkLnB1c2goa2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaW5jbHVkZWQubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29uZmxpY3RpbmcgdHlwZXM6ICR7aW5jbHVkZWQuam9pbihcIiwgXCIpfWApO1xyXG4gICAgfVxyXG59XHJcbi8vIEZ1bmN0aW9ucyB0byBwcm9jZXNzIGEgU29saWRpdHkgU2lnbmF0dXJlIFRva2VuU3RyaW5nIGZyb20gbGVmdC10by1yaWdodCBmb3IuLi5cclxuLy8gLi4udGhlIG5hbWUgd2l0aCBhbiBvcHRpb25hbCB0eXBlLCByZXR1cm5pbmcgdGhlIG5hbWVcclxuZnVuY3Rpb24gY29uc3VtZU5hbWUodHlwZSwgdG9rZW5zKSB7XHJcbiAgICBpZiAodG9rZW5zLnBlZWtLZXl3b3JkKEt3VHlwZXMpKSB7XHJcbiAgICAgICAgY29uc3Qga2V5d29yZCA9IHRva2Vucy5wb3AoKS50ZXh0O1xyXG4gICAgICAgIGlmIChrZXl3b3JkICE9PSB0eXBlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHt0eXBlfSwgZ290ICR7a2V5d29yZH1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG9rZW5zLnBvcFR5cGUoXCJJRFwiKTtcclxufVxyXG4vLyAuLi5hbGwga2V5d29yZHMgbWF0Y2hpbmcgYWxsb3dlZCwgcmV0dXJuaW5nIHRoZSBrZXl3b3Jkc1xyXG5mdW5jdGlvbiBjb25zdW1lS2V5d29yZHModG9rZW5zLCBhbGxvd2VkKSB7XHJcbiAgICBjb25zdCBrZXl3b3JkcyA9IG5ldyBTZXQoKTtcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgY29uc3Qga2V5d29yZCA9IHRva2Vucy5wZWVrVHlwZShcIktFWVdPUkRcIik7XHJcbiAgICAgICAgaWYgKGtleXdvcmQgPT0gbnVsbCB8fCAoYWxsb3dlZCAmJiAhYWxsb3dlZC5oYXMoa2V5d29yZCkpKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b2tlbnMucG9wKCk7XHJcbiAgICAgICAgaWYgKGtleXdvcmRzLmhhcyhrZXl3b3JkKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZSBrZXl3b3JkczogJHtKU09OLnN0cmluZ2lmeShrZXl3b3JkKX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAga2V5d29yZHMuYWRkKGtleXdvcmQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoa2V5d29yZHMpO1xyXG59XHJcbi8vIC4uLmFsbCB2aXNpYmlsaXR5IGtleXdvcmRzLCByZXR1cm5pbmcgdGhlIGNvYWxlc2NlZCBtdXRhYmlsaXR5XHJcbmZ1bmN0aW9uIGNvbnN1bWVNdXRhYmlsaXR5KHRva2Vucykge1xyXG4gICAgbGV0IG1vZGlmaWVycyA9IGNvbnN1bWVLZXl3b3Jkcyh0b2tlbnMsIEt3VmlzaWIpO1xyXG4gICAgLy8gRGV0ZWN0IGNvbmZsaWN0aW5nIG1vZGlmaWVyc1xyXG4gICAgYWxsb3dTaW5nbGUobW9kaWZpZXJzLCBzZXRpZnkoXCJjb25zdGFudCBwYXlhYmxlIG5vbnBheWFibGVcIi5zcGxpdChcIiBcIikpKTtcclxuICAgIGFsbG93U2luZ2xlKG1vZGlmaWVycywgc2V0aWZ5KFwicHVyZSB2aWV3IHBheWFibGUgbm9ucGF5YWJsZVwiLnNwbGl0KFwiIFwiKSkpO1xyXG4gICAgLy8gUHJvY2VzcyBtdXRhYmlsaXR5IHN0YXRlc1xyXG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJ2aWV3XCIpKSB7XHJcbiAgICAgICAgcmV0dXJuIFwidmlld1wiO1xyXG4gICAgfVxyXG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJwdXJlXCIpKSB7XHJcbiAgICAgICAgcmV0dXJuIFwicHVyZVwiO1xyXG4gICAgfVxyXG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJwYXlhYmxlXCIpKSB7XHJcbiAgICAgICAgcmV0dXJuIFwicGF5YWJsZVwiO1xyXG4gICAgfVxyXG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJub25wYXlhYmxlXCIpKSB7XHJcbiAgICAgICAgcmV0dXJuIFwibm9ucGF5YWJsZVwiO1xyXG4gICAgfVxyXG4gICAgLy8gUHJvY2VzcyBsZWdhY3kgYGNvbnN0YW50YCBsYXN0XHJcbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcImNvbnN0YW50XCIpKSB7XHJcbiAgICAgICAgcmV0dXJuIFwidmlld1wiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwibm9ucGF5YWJsZVwiO1xyXG59XHJcbi8vIC4uLmEgcGFyYW1ldGVyIGxpc3QsIHJldHVybmluZyB0aGUgUGFyYW1UeXBlIGxpc3RcclxuZnVuY3Rpb24gY29uc3VtZVBhcmFtcyh0b2tlbnMsIGFsbG93SW5kZXhlZCkge1xyXG4gICAgcmV0dXJuIHRva2Vucy5wb3BQYXJhbXMoKS5tYXAoKHQpID0+IFBhcmFtVHlwZS5mcm9tKHQsIGFsbG93SW5kZXhlZCkpO1xyXG59XHJcbi8vIC4uLmEgZ2FzIGxpbWl0LCByZXR1cm5pbmcgYSBCaWdOdW1iZXIgb3IgbnVsbCBpZiBub25lXHJcbmZ1bmN0aW9uIGNvbnN1bWVHYXModG9rZW5zKSB7XHJcbiAgICBpZiAodG9rZW5zLnBlZWtUeXBlKFwiQVRcIikpIHtcclxuICAgICAgICB0b2tlbnMucG9wKCk7XHJcbiAgICAgICAgaWYgKHRva2Vucy5wZWVrVHlwZShcIk5VTUJFUlwiKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0QmlnSW50KHRva2Vucy5wb3AoKS50ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBnYXNcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBjb25zdW1lRW9pKHRva2Vucykge1xyXG4gICAgaWYgKHRva2Vucy5sZW5ndGgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgdG9rZW5zIGF0IG9mZnNldCAke3Rva2Vucy5vZmZzZXR9OiAke3Rva2Vucy50b1N0cmluZygpfWApO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IHJlZ2V4QXJyYXlUeXBlID0gbmV3IFJlZ0V4cCgvXiguKilcXFsoWzAtOV0qKVxcXSQvKTtcclxuZnVuY3Rpb24gdmVyaWZ5QmFzaWNUeXBlKHR5cGUpIHtcclxuICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaChyZWdleFR5cGUpO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQobWF0Y2gsIFwiaW52YWxpZCB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcclxuICAgIGlmICh0eXBlID09PSBcInVpbnRcIikge1xyXG4gICAgICAgIHJldHVybiBcInVpbnQyNTZcIjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlID09PSBcImludFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiaW50MjU2XCI7XHJcbiAgICB9XHJcbiAgICBpZiAobWF0Y2hbMl0pIHtcclxuICAgICAgICAvLyBieXRlc1hYXHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGxlbmd0aCAhPT0gMCAmJiBsZW5ndGggPD0gMzIsIFwiaW52YWxpZCBieXRlcyBsZW5ndGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobWF0Y2hbM10pIHtcclxuICAgICAgICAvLyBpbnRYWCBvciB1aW50WFhcclxuICAgICAgICBjb25zdCBzaXplID0gcGFyc2VJbnQobWF0Y2hbM10pO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHNpemUgIT09IDAgJiYgc2l6ZSA8PSAyNTYgJiYgKHNpemUgJSA4KSA9PT0gMCwgXCJpbnZhbGlkIG51bWVyaWMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHR5cGU7XHJcbn1cclxuLy8gTWFrZSB0aGUgRnJhZ21lbnQgY29uc3RydWN0b3JzIGVmZmVjdGl2ZWx5IHByaXZhdGVcclxuY29uc3QgX2d1YXJkID0ge307XHJcbmNvbnN0IGludGVybmFsID0gU3ltYm9sLmZvcihcIl9ldGhlcnNfaW50ZXJuYWxcIik7XHJcbmNvbnN0IFBhcmFtVHlwZUludGVybmFsID0gXCJfUGFyYW1UeXBlSW50ZXJuYWxcIjtcclxuY29uc3QgRXJyb3JGcmFnbWVudEludGVybmFsID0gXCJfRXJyb3JJbnRlcm5hbFwiO1xyXG5jb25zdCBFdmVudEZyYWdtZW50SW50ZXJuYWwgPSBcIl9FdmVudEludGVybmFsXCI7XHJcbmNvbnN0IENvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCA9IFwiX0NvbnN0cnVjdG9ySW50ZXJuYWxcIjtcclxuY29uc3QgRmFsbGJhY2tGcmFnbWVudEludGVybmFsID0gXCJfRmFsbGJhY2tJbnRlcm5hbFwiO1xyXG5jb25zdCBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwgPSBcIl9GdW5jdGlvbkludGVybmFsXCI7XHJcbmNvbnN0IFN0cnVjdEZyYWdtZW50SW50ZXJuYWwgPSBcIl9TdHJ1Y3RJbnRlcm5hbFwiO1xyXG4vKipcclxuICogIEVhY2ggaW5wdXQgYW5kIG91dHB1dCBvZiBhIFtbRnJhZ21lbnRdXSBpcyBhbiBBcnJheSBvZiAqKlBhcmFtVHlwZSoqLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBhcmFtVHlwZSB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbG9jYWwgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIChvciBgYFwiXCJgYCBpZiB1bmJvdW5kKVxyXG4gICAgICovXHJcbiAgICBuYW1lO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGZ1bGx5IHF1YWxpZmllZCB0eXBlIChlLmcuIGBgXCJhZGRyZXNzXCJgYCwgYGBcInR1cGxlKGFkZHJlc3MpXCJgYCxcclxuICAgICAqICBgYFwidWludDI1NlszXVtdXCJgYClcclxuICAgICAqL1xyXG4gICAgdHlwZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBiYXNlIHR5cGUgKGUuZy4gYGBcImFkZHJlc3NcImBgLCBgYFwidHVwbGVcImBgLCBgYFwiYXJyYXlcImBgKVxyXG4gICAgICovXHJcbiAgICBiYXNlVHlwZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRydWUgaWYgdGhlIHBhcmFtZXRlcnMgaXMgaW5kZXhlZC5cclxuICAgICAqXHJcbiAgICAgKiAgRm9yIG5vbi1pbmRleGFibGUgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cclxuICAgICAqL1xyXG4gICAgaW5kZXhlZDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBjb21wb25lbnRzIGZvciB0aGUgdHVwbGUuXHJcbiAgICAgKlxyXG4gICAgICogIEZvciBub24tdHVwbGUgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cclxuICAgICAqL1xyXG4gICAgY29tcG9uZW50cztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBhcnJheSBsZW5ndGgsIG9yIGBgLTFgYCBmb3IgZHluYW1pYy1sZW5ndGhlZCBhcnJheXMuXHJcbiAgICAgKlxyXG4gICAgICogIEZvciBub24tYXJyYXkgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cclxuICAgICAqL1xyXG4gICAgYXJyYXlMZW5ndGg7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdHlwZSBvZiBlYWNoIGNoaWxkIGluIHRoZSBhcnJheS5cclxuICAgICAqXHJcbiAgICAgKiAgRm9yIG5vbi1hcnJheSB0eXBlcyB0aGlzIGlzIGBgbnVsbGBgLlxyXG4gICAgICovXHJcbiAgICBhcnJheUNoaWxkcmVuO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIHR5cGUsIGJhc2VUeXBlLCBpbmRleGVkLCBjb21wb25lbnRzLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlbikge1xyXG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJQYXJhbVR5cGVcIik7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBQYXJhbVR5cGVJbnRlcm5hbCB9KTtcclxuICAgICAgICBpZiAoY29tcG9uZW50cykge1xyXG4gICAgICAgICAgICBjb21wb25lbnRzID0gT2JqZWN0LmZyZWV6ZShjb21wb25lbnRzLnNsaWNlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xyXG4gICAgICAgICAgICBpZiAoYXJyYXlMZW5ndGggPT0gbnVsbCB8fCBhcnJheUNoaWxkcmVuID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhcnJheUxlbmd0aCAhPSBudWxsIHx8IGFycmF5Q2hpbGRyZW4gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XHJcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb21wb25lbnRzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgICAgICAgICAgbmFtZSwgdHlwZSwgYmFzZVR5cGUsIGluZGV4ZWQsIGNvbXBvbmVudHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0eXBlLlxyXG4gICAgICpcclxuICAgICAqICBGb3IgZXhhbXBsZSxcclxuICAgICAqXHJcbiAgICAgKiAgYGBzaWdoYXNoXCIgPT4gXCIodWludDI1NixhZGRyZXNzKVwiYGBcclxuICAgICAqXHJcbiAgICAgKiAgYGBcIm1pbmltYWxcIiA9PiBcInR1cGxlKHVpbnQyNTYsYWRkcmVzcykgaW5kZXhlZFwiYGBcclxuICAgICAqXHJcbiAgICAgKiAgYGBcImZ1bGxcIiA9PiBcInR1cGxlKHVpbnQyNTYgZm9vLCBhZGRyZXNzIGJhcikgaW5kZXhlZCBiYXpcImBgXHJcbiAgICAgKi9cclxuICAgIGZvcm1hdChmb3JtYXQpIHtcclxuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWUgfHwgXCJcIjtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKHRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoXCJqc29uXCIpKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5uYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC50eXBlICs9IGBbJHsodGhpcy5hcnJheUxlbmd0aCA8IDAgPyBcIlwiIDogU3RyaW5nKHRoaXMuYXJyYXlMZW5ndGgpKX1dYDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICgodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSA/IFwidHVwbGVcIiA6IHRoaXMudHlwZSksXHJcbiAgICAgICAgICAgICAgICBuYW1lXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHRoaXMuaW5kZXhlZCkgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuaW5kZXhlZCA9IHRoaXMuaW5kZXhlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5jb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzLm1hcCgoYykgPT4gSlNPTi5wYXJzZShjLmZvcm1hdChmb3JtYXQpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgIC8vIEFycmF5XHJcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmFycmF5Q2hpbGRyZW4uZm9ybWF0KGZvcm1hdCk7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBgWyR7KHRoaXMuYXJyYXlMZW5ndGggPCAwID8gXCJcIiA6IFN0cmluZyh0aGlzLmFycmF5TGVuZ3RoKSl9XWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIihcIiArIHRoaXMuY29tcG9uZW50cy5tYXAoKGNvbXApID0+IGNvbXAuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gXCJmdWxsXCIpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy50eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ZWQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBpbmRleGVkXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJmdWxsXCIgJiYgdGhpcy5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgXCIgKyB0aGlzLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhbiBBcnJheSB0eXBlLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgdHlwZSBnYXVyZCBlbnN1cmluZyB0aGF0IFtbYXJyYXlDaGlsZHJlbl1dXHJcbiAgICAgKiAgYW5kIFtbYXJyYXlMZW5ndGhdXSBhcmUgbm9uLW51bGwuXHJcbiAgICAgKi9cclxuICAgIGlzQXJyYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhc2VUeXBlID09PSBcImFycmF5XCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGEgVHVwbGUgdHlwZS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIHR5cGUgZ2F1cmQgZW5zdXJpbmcgdGhhdCBbW2NvbXBvbmVudHNdXVxyXG4gICAgICogIGlzIG5vbi1udWxsLlxyXG4gICAgICovXHJcbiAgICBpc1R1cGxlKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhbiBJbmRleGFibGUgdHlwZS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIHR5cGUgZ2F1cmQgZW5zdXJpbmcgdGhhdCBbW2luZGV4ZWRdXVxyXG4gICAgICogIGlzIG5vbi1udWxsLlxyXG4gICAgICovXHJcbiAgICBpc0luZGV4YWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuaW5kZXhlZCAhPSBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFdhbGtzIHRoZSAqKlBhcmFtVHlwZSoqIHdpdGggJSV2YWx1ZSUlLCBjYWxsaW5nICUlcHJvY2VzcyUlXHJcbiAgICAgKiAgb24gZWFjaCB0eXBlLCBkZXN0cnVjdGluZyB0aGUgJSV2YWx1ZSUlIHJlY3Vyc2l2ZWx5LlxyXG4gICAgICovXHJcbiAgICB3YWxrKHZhbHVlLCBwcm9jZXNzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XHJcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXJyYXkgdmFsdWVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXJyYXlMZW5ndGggIT09IC0xICYmIHZhbHVlLmxlbmd0aCAhPT0gdGhpcy5hcnJheUxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gKF90aGlzLmFycmF5Q2hpbGRyZW4ud2Fsayh2LCBwcm9jZXNzKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB0dXBsZSB2YWx1ZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyB3cm9uZyBsZW5ndGhcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2LCBpKSA9PiAoX3RoaXMuY29tcG9uZW50c1tpXS53YWxrKHYsIHByb2Nlc3MpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9jZXNzKHRoaXMudHlwZSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgI3dhbGtBc3luYyhwcm9taXNlcywgdmFsdWUsIHByb2Nlc3MsIHNldFZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XHJcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXJyYXkgdmFsdWVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXJyYXlMZW5ndGggIT09IC0xICYmIHZhbHVlLmxlbmd0aCAhPT0gdGhpcy5hcnJheUxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkVHlwZSA9IHRoaXMuYXJyYXlDaGlsZHJlbjtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUuc2xpY2UoKTtcclxuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRUeXBlLiN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHNldFZhbHVlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNUdXBsZSgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHM7XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIG9iamVjdCBpbnRvIGFuIGFycmF5XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUuc2xpY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiAodmFsdWUpICE9PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB0dXBsZSB2YWx1ZVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvbXBvbmVudHMubWFwKChwYXJhbSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyYW0ubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgdXNlIG9iamVjdCB2YWx1ZSB3aXRoIHVubmFtZWQgY29tcG9uZW50c1wiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocGFyYW0ubmFtZSBpbiB2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIHZhbHVlIGZvciBjb21wb25lbnQgJHtwYXJhbS5uYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVbcGFyYW0ubmFtZV07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gdGhpcy5jb21wb25lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHNbaW5kZXhdLiN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHNldFZhbHVlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcHJvY2Vzcyh0aGlzLnR5cGUsIHZhbHVlKTtcclxuICAgICAgICBpZiAocmVzdWx0LnRoZW4pIHtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgZnVuY3Rpb24gKCkgeyBzZXRWYWx1ZShhd2FpdCByZXN1bHQpOyB9KSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNldFZhbHVlKHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgV2Fsa3MgdGhlICoqUGFyYW1UeXBlKiogd2l0aCAlJXZhbHVlJSUsIGFzeW5jaHJvbm91c2x5IGNhbGxpbmdcclxuICAgICAqICAlJXByb2Nlc3MlJSBvbiBlYWNoIHR5cGUsIGRlc3RydWN0aW5nIHRoZSAlJXZhbHVlJSUgcmVjdXJzaXZlbHkuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgY2FuIGJlIHVzZWQgdG8gcmVzb2x2ZSBFTlMgbmFtZXMgYnkgd2Fsa2luZyBhbmQgcmVzb2x2aW5nIGVhY2hcclxuICAgICAqICBgYFwiYWRkcmVzc1wiYGAgdHlwZS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgd2Fsa0FzeW5jKHZhbHVlLCBwcm9jZXNzKSB7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbdmFsdWVdO1xyXG4gICAgICAgIHRoaXMuI3dhbGtBc3luYyhwcm9taXNlcywgdmFsdWUsIHByb2Nlc3MsICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICByZXN1bHRbMF0gPSB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipQYXJhbVR5cGUqKiBmb3IgJSVvYmolJS5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgJSVhbGxvd0luZGV4ZWQlJSB0aGVuIHRoZSBgYGluZGV4ZWRgYCBrZXl3b3JkIGlzIHBlcm1pdHRlZCxcclxuICAgICAqICBvdGhlcndpc2UgdGhlIGBgaW5kZXhlZGBgIGtleXdvcmQgd2lsbCB0aHJvdyBhbiBlcnJvci5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb20ob2JqLCBhbGxvd0luZGV4ZWQpIHtcclxuICAgICAgICBpZiAoUGFyYW1UeXBlLmlzUGFyYW1UeXBlKG9iaikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcmFtVHlwZS5mcm9tKGxleChvYmopLCBhbGxvd0luZGV4ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBwYXJhbSB0eXBlXCIsIFwib2JqXCIsIG9iaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcclxuICAgICAgICAgICAgbGV0IHR5cGUgPSBcIlwiLCBiYXNlVHlwZSA9IFwiXCI7XHJcbiAgICAgICAgICAgIGxldCBjb21wcyA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1widHVwbGVcIl0pKS5oYXMoXCJ0dXBsZVwiKSB8fCBvYmoucGVla1R5cGUoXCJPUEVOX1BBUkVOXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUdXBsZVxyXG4gICAgICAgICAgICAgICAgYmFzZVR5cGUgPSBcInR1cGxlXCI7XHJcbiAgICAgICAgICAgICAgICBjb21wcyA9IG9iai5wb3BQYXJhbXMoKS5tYXAoKHQpID0+IFBhcmFtVHlwZS5mcm9tKHQpKTtcclxuICAgICAgICAgICAgICAgIHR5cGUgPSBgdHVwbGUoJHtjb21wcy5tYXAoKGMpID0+IGMuZm9ybWF0KCkpLmpvaW4oXCIsXCIpfSlgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsXHJcbiAgICAgICAgICAgICAgICB0eXBlID0gdmVyaWZ5QmFzaWNUeXBlKG9iai5wb3BUeXBlKFwiVFlQRVwiKSk7XHJcbiAgICAgICAgICAgICAgICBiYXNlVHlwZSA9IHR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIEFycmF5XHJcbiAgICAgICAgICAgIGxldCBhcnJheUNoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IGFycmF5TGVuZ3RoID0gbnVsbDtcclxuICAgICAgICAgICAgd2hpbGUgKG9iai5sZW5ndGggJiYgb2JqLnBlZWtUeXBlKFwiQlJBQ0tFVFwiKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnJhY2tldCA9IG9iai5wb3AoKTsgLy9hcnJheXNbaV07XHJcbiAgICAgICAgICAgICAgICBhcnJheUNoaWxkcmVuID0gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIFwiXCIsIHR5cGUsIGJhc2VUeXBlLCBudWxsLCBjb21wcywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgYXJyYXlMZW5ndGggPSBicmFja2V0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdHlwZSArPSBicmFja2V0LnRleHQ7XHJcbiAgICAgICAgICAgICAgICBiYXNlVHlwZSA9IFwiYXJyYXlcIjtcclxuICAgICAgICAgICAgICAgIGNvbXBzID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgaW5kZXhlZCA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleXdvcmRzID0gY29uc3VtZUtleXdvcmRzKG9iaiwgS3dNb2RpZmllcnMpO1xyXG4gICAgICAgICAgICBpZiAoa2V5d29yZHMuaGFzKFwiaW5kZXhlZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhbGxvd0luZGV4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbmRleGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gKG9iai5wZWVrVHlwZShcIklEXCIpID8gb2JqLnBvcCgpLnRleHQgOiBcIlwiKTtcclxuICAgICAgICAgICAgaWYgKG9iai5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImxlZnRvdmVyIHRva2Vuc1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUsIHR5cGUsIGJhc2VUeXBlLCBpbmRleGVkLCBjb21wcywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuYW1lID0gb2JqLm5hbWU7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIW5hbWUgfHwgKHR5cGVvZiAobmFtZSkgPT09IFwic3RyaW5nXCIgJiYgbmFtZS5tYXRjaChyZWdleElkKSksIFwiaW52YWxpZCBuYW1lXCIsIFwib2JqLm5hbWVcIiwgbmFtZSk7XHJcbiAgICAgICAgbGV0IGluZGV4ZWQgPSBvYmouaW5kZXhlZDtcclxuICAgICAgICBpZiAoaW5kZXhlZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFsbG93SW5kZXhlZCwgXCJwYXJhbWV0ZXIgY2Fubm90IGJlIGluZGV4ZWRcIiwgXCJvYmouaW5kZXhlZFwiLCBvYmouaW5kZXhlZCk7XHJcbiAgICAgICAgICAgIGluZGV4ZWQgPSAhIWluZGV4ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0eXBlID0gb2JqLnR5cGU7XHJcbiAgICAgICAgbGV0IGFycmF5TWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4QXJyYXlUeXBlKTtcclxuICAgICAgICBpZiAoYXJyYXlNYXRjaCkge1xyXG4gICAgICAgICAgICBjb25zdCBhcnJheUxlbmd0aCA9IHBhcnNlSW50KGFycmF5TWF0Y2hbMl0gfHwgXCItMVwiKTtcclxuICAgICAgICAgICAgY29uc3QgYXJyYXlDaGlsZHJlbiA9IFBhcmFtVHlwZS5mcm9tKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IGFycmF5TWF0Y2hbMV0sXHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBvYmouY29tcG9uZW50c1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIFwiYXJyYXlcIiwgaW5kZXhlZCwgbnVsbCwgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSA9PT0gXCJ0dXBsZVwiIHx8IHR5cGUuc3RhcnRzV2l0aChcInR1cGxlKFwiIC8qIGZpeDogKSAqLykgfHwgdHlwZS5zdGFydHNXaXRoKFwiKFwiIC8qIGZpeDogKSAqLykpIHtcclxuICAgICAgICAgICAgY29uc3QgY29tcHMgPSAob2JqLmNvbXBvbmVudHMgIT0gbnVsbCkgPyBvYmouY29tcG9uZW50cy5tYXAoKGMpID0+IFBhcmFtVHlwZS5mcm9tKGMpKSA6IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IHR1cGxlID0gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUgfHwgXCJcIiwgdHlwZSwgXCJ0dXBsZVwiLCBpbmRleGVkLCBjb21wcywgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgICAgIC8vIEBUT0RPOiB1c2UgbGV4ZXIgdG8gdmFsaWRhdGUgYW5kIG5vcm1hbGl6ZSB0eXBlXHJcbiAgICAgICAgICAgIHJldHVybiB0dXBsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHlwZSA9IHZlcmlmeUJhc2ljVHlwZShvYmoudHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIHR5cGUsIGluZGV4ZWQsIG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhICoqUGFyYW1UeXBlKiouXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc1BhcmFtVHlwZSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBQYXJhbVR5cGVJbnRlcm5hbCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBBbiBhYnN0cmFjdCBjbGFzcyB0byByZXByZXNlbnQgQW4gaW5kaXZpZHVhbCBmcmFnbWVudCBmcm9tIGEgcGFyc2UgQUJJLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEZyYWdtZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSB0eXBlIG9mIHRoZSBmcmFnbWVudC5cclxuICAgICAqL1xyXG4gICAgdHlwZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBpbnB1dHMgZm9yIHRoZSBmcmFnbWVudC5cclxuICAgICAqL1xyXG4gICAgaW5wdXRzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHR5cGUsIGlucHV0cykge1xyXG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJGcmFnbWVudFwiKTtcclxuICAgICAgICBpbnB1dHMgPSBPYmplY3QuZnJlZXplKGlucHV0cy5zbGljZSgpKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgdHlwZSwgaW5wdXRzIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZyYWdtZW50KiogZm9yICUlb2JqJSUsIHdpY2ggY2FuIGJlIGFueSBzdXBwb3J0ZWRcclxuICAgICAqICBBQkkgZnJnYW1lbnQgdHlwZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAvLyBUcnkgcGFyc2luZyBKU09OLi4uXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBGcmFnbWVudC5mcm9tKEpTT04ucGFyc2Uob2JqKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgICAgICAvLyAuLi5vdGhlcndpc2UsIHVzZSB0aGUgaHVtYW4tcmVhZGFibGUgbGV4ZXJcclxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcclxuICAgICAgICAgICAgLy8gSHVtYW4tcmVhZGFibGUgQUJJIChhbHJlYWR5IGxleGVkKVxyXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gb2JqLnBlZWtLZXl3b3JkKEt3VHlwZXMpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOiByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKG9iaik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjogcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShvYmopO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6IHJldHVybiBFdmVudEZyYWdtZW50LmZyb20ob2JqKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWxsYmFja1wiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcInJlY2VpdmVcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFsbGJhY2tGcmFnbWVudC5mcm9tKG9iaik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjogcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbShvYmopO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cnVjdFwiOiByZXR1cm4gU3RydWN0RnJhZ21lbnQuZnJvbShvYmopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAvLyBKU09OIEFCSVxyXG4gICAgICAgICAgICBzd2l0Y2ggKG9iai50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjogcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbShvYmopO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHJldHVybiBFcnJvckZyYWdtZW50LmZyb20ob2JqKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOiByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tKG9iaik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWNlaXZlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZhbGxiYWNrRnJhZ21lbnQuZnJvbShvYmopO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6IHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb20ob2JqKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJ1Y3RcIjogcmV0dXJuIFN0cnVjdEZyYWdtZW50LmZyb20ob2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGB1bnN1cHBvcnRlZCB0eXBlOiAke29iai50eXBlfWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJGcmFnbWVudC5mcm9tXCJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIGZyZ2FtZW50IG9iamVjdFwiLCBcIm9ialwiLCBvYmopO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIFtbQ29uc3RydWN0b3JGcmFnbWVudF1dLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNDb25zdHJ1Y3Rvcih2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhbiBbW0Vycm9yRnJhZ21lbnRdXS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzRXJyb3IodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYW4gW1tFdmVudEZyYWdtZW50XV0uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0V2ZW50KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgW1tGdW5jdGlvbkZyYWdtZW50XV0uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0Z1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgW1tTdHJ1Y3RGcmFnbWVudF1dLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNTdHJ1Y3QodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gU3RydWN0RnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBBbiBhYnN0cmFjdCBjbGFzcyB0byByZXByZXNlbnQgQW4gaW5kaXZpZHVhbCBmcmFnbWVudFxyXG4gKiAgd2hpY2ggaGFzIGEgbmFtZSBmcm9tIGEgcGFyc2UgQUJJLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE5hbWVkRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgZnJhZ21lbnQuXHJcbiAgICAgKi9cclxuICAgIG5hbWU7XHJcbiAgICAvKipcclxuICAgICAqICBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdHlwZSwgbmFtZSwgaW5wdXRzKSB7XHJcbiAgICAgICAgc3VwZXIoZ3VhcmQsIHR5cGUsIGlucHV0cyk7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiAmJiBuYW1lLm1hdGNoKHJlZ2V4SWQpLCBcImludmFsaWQgaWRlbnRpZmllclwiLCBcIm5hbWVcIiwgbmFtZSk7XHJcbiAgICAgICAgaW5wdXRzID0gT2JqZWN0LmZyZWV6ZShpbnB1dHMuc2xpY2UoKSk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG5hbWUgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gam9pblBhcmFtcyhmb3JtYXQsIHBhcmFtcykge1xyXG4gICAgcmV0dXJuIFwiKFwiICsgcGFyYW1zLm1hcCgocCkgPT4gcC5mb3JtYXQoZm9ybWF0KSkuam9pbigoZm9ybWF0ID09PSBcImZ1bGxcIikgPyBcIiwgXCIgOiBcIixcIikgKyBcIilcIjtcclxufVxyXG4vKipcclxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIC8vQ3VzdG9tIEVycm9yLy8uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRXJyb3JGcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIGlucHV0cykge1xyXG4gICAgICAgIHN1cGVyKGd1YXJkLCBcImVycm9yXCIsIG5hbWUsIGlucHV0cyk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBFcnJvckZyYWdtZW50SW50ZXJuYWwgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgQ3VzdG9tIEVycm9yIHNlbGVjdG9yLlxyXG4gICAgICovXHJcbiAgICBnZXQgc2VsZWN0b3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIGlkKHRoaXMuZm9ybWF0KFwic2lnaGFzaFwiKSkuc3Vic3RyaW5nKDAsIDEwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmcmFnbWVudCBhcyAlJWZvcm1hdCUlLlxyXG4gICAgICovXHJcbiAgICBmb3JtYXQoZm9ybWF0KSB7XHJcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xyXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBKU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKSksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChcImVycm9yXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm5hbWUgKyBqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIgXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkVycm9yRnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XHJcbiAgICAgICAgaWYgKEVycm9yRnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcImVycm9yXCIsIG9iaik7XHJcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcclxuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yRnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBpbnB1dHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEVycm9yRnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgb2JqLmlucHV0cyA/IG9iai5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYW5cclxuICAgICAqICAqKkVycm9yRnJhZ21lbnQqKi5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRXJyb3JGcmFnbWVudEludGVybmFsKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhbiBFdmVudC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBFdmVudEZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XHJcbiAgICAvKipcclxuICAgICAqICBXaGV0aGVyIHRoaXMgZXZlbnQgaXMgYW5vbnltb3VzLlxyXG4gICAgICovXHJcbiAgICBhbm9ueW1vdXM7XHJcbiAgICAvKipcclxuICAgICAqICBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgaW5wdXRzLCBhbm9ueW1vdXMpIHtcclxuICAgICAgICBzdXBlcihndWFyZCwgXCJldmVudFwiLCBuYW1lLCBpbnB1dHMpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogRXZlbnRGcmFnbWVudEludGVybmFsIH0pO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhbm9ueW1vdXMgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgRXZlbnQgdG9waWMgaGFzaC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHRvcGljSGFzaCgpIHtcclxuICAgICAgICByZXR1cm4gaWQodGhpcy5mb3JtYXQoXCJzaWdoYXNoXCIpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBldmVudCBhcyAlJWZvcm1hdCUlLlxyXG4gICAgICovXHJcbiAgICBmb3JtYXQoZm9ybWF0KSB7XHJcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xyXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJldmVudFwiLFxyXG4gICAgICAgICAgICAgICAgYW5vbnltb3VzOiB0aGlzLmFub255bW91cyxcclxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpKSA9PiBKU09OLnBhcnNlKGkuZm9ybWF0KGZvcm1hdCkpKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJldmVudFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5uYW1lICsgam9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKSk7XHJcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIgJiYgdGhpcy5hbm9ueW1vdXMpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJhbm9ueW1vdXNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gdGhlIHRvcGljIGhhc2ggZm9yIGFuIGV2ZW50IHdpdGggJSVuYW1lJSUgYW5kICUlcGFyYW1zJSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRUb3BpY0hhc2gobmFtZSwgcGFyYW1zKSB7XHJcbiAgICAgICAgcGFyYW1zID0gKHBhcmFtcyB8fCBbXSkubWFwKChwKSA9PiBQYXJhbVR5cGUuZnJvbShwKSk7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBuZXcgRXZlbnRGcmFnbWVudChfZ3VhcmQsIG5hbWUsIHBhcmFtcywgZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiBmcmFnbWVudC50b3BpY0hhc2g7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRXZlbnRGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbShvYmopIHtcclxuICAgICAgICBpZiAoRXZlbnRGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGV2ZW50IGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwiZXZlbnRcIiwgb2JqKTtcclxuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmosIHRydWUpO1xyXG4gICAgICAgICAgICBjb25zdCBhbm9ueW1vdXMgPSAhIWNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJhbm9ueW1vdXNcIl0pKS5oYXMoXCJhbm9ueW1vdXNcIik7XHJcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudEZyYWdtZW50KF9ndWFyZCwgbmFtZSwgaW5wdXRzLCBhbm9ueW1vdXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50RnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgb2JqLmlucHV0cyA/IG9iai5pbnB1dHMubWFwKChwKSA9PiBQYXJhbVR5cGUuZnJvbShwLCB0cnVlKSkgOiBbXSwgISFvYmouYW5vbnltb3VzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYW5cclxuICAgICAqICAqKkV2ZW50RnJhZ21lbnQqKi5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRXZlbnRGcmFnbWVudEludGVybmFsKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIGNvbnN0cnVjdG9yLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENvbnN0cnVjdG9yRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XHJcbiAgICAvKipcclxuICAgICAqICBXaGV0aGVyIHRoZSBjb25zdHJ1Y3RvciBjYW4gcmVjZWl2ZSBhbiBlbmRvd21lbnQuXHJcbiAgICAgKi9cclxuICAgIHBheWFibGU7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgcmVjb21tZW5kZWQgZ2FzIGxpbWl0IGZvciBkZXBsb3ltZW50IG9yIGBgbnVsbGBgLlxyXG4gICAgICovXHJcbiAgICBnYXM7XHJcbiAgICAvKipcclxuICAgICAqICBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdHlwZSwgaW5wdXRzLCBwYXlhYmxlLCBnYXMpIHtcclxuICAgICAgICBzdXBlcihndWFyZCwgdHlwZSwgaW5wdXRzKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IENvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCB9KTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcGF5YWJsZSwgZ2FzIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbnN0cnVjdG9yIGFzICUlZm9ybWF0JSUuXHJcbiAgICAgKi9cclxuICAgIGZvcm1hdChmb3JtYXQpIHtcclxuICAgICAgICBhc3NlcnQoZm9ybWF0ICE9IG51bGwgJiYgZm9ybWF0ICE9PSBcInNpZ2hhc2hcIiwgXCJjYW5ub3QgZm9ybWF0IGEgY29uc3RydWN0b3IgZm9yIHNpZ2hhc2hcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZm9ybWF0KHNpZ2hhc2gpXCIgfSk7XHJcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIixcclxuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogKHRoaXMucGF5YWJsZSA/IFwicGF5YWJsZVwiIDogXCJ1bmRlZmluZWRcIiksXHJcbiAgICAgICAgICAgICAgICBwYXlhYmxlOiB0aGlzLnBheWFibGUsXHJcbiAgICAgICAgICAgICAgICBnYXM6ICgodGhpcy5nYXMgIT0gbnVsbCkgPyB0aGlzLmdhcyA6IHVuZGVmaW5lZCksXHJcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaSkgPT4gSlNPTi5wYXJzZShpLmZvcm1hdChmb3JtYXQpKSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtgY29uc3RydWN0b3Ike2pvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLmlucHV0cyl9YF07XHJcbiAgICAgICAgaWYgKHRoaXMucGF5YWJsZSkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChcInBheWFibGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmdhcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGBAJHt0aGlzLmdhcy50b1N0cmluZygpfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIgXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkNvbnN0cnVjdG9yRnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XHJcbiAgICAgICAgaWYgKENvbnN0cnVjdG9yRnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20obGV4KG9iaikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBjb25zdHVjdG9yIGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcclxuICAgICAgICAgICAgY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcImNvbnN0cnVjdG9yXCJdKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcclxuICAgICAgICAgICAgY29uc3QgcGF5YWJsZSA9ICEhY29uc3VtZUtleXdvcmRzKG9iaiwgS3dWaXNpYkRlcGxveSkuaGFzKFwicGF5YWJsZVwiKTtcclxuICAgICAgICAgICAgY29uc3QgZ2FzID0gY29uc3VtZUdhcyhvYmopO1xyXG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3JGcmFnbWVudChfZ3VhcmQsIFwiY29uc3RydWN0b3JcIiwgaW5wdXRzLCBwYXlhYmxlLCBnYXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yRnJhZ21lbnQoX2d1YXJkLCBcImNvbnN0cnVjdG9yXCIsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSwgISFvYmoucGF5YWJsZSwgKG9iai5nYXMgIT0gbnVsbCkgPyBvYmouZ2FzIDogbnVsbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcclxuICAgICAqICAqKkNvbnN0cnVjdG9yRnJhZ21lbnQqKi5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gQ29uc3RydWN0b3JGcmFnbWVudEludGVybmFsKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIG1ldGhvZC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBGYWxsYmFja0ZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgSWYgdGhlIGZ1bmN0aW9uIGNhbiBiZSBzZW50IHZhbHVlIGR1cmluZyBpbnZvY2F0aW9uLlxyXG4gICAgICovXHJcbiAgICBwYXlhYmxlO1xyXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIGlucHV0cywgcGF5YWJsZSkge1xyXG4gICAgICAgIHN1cGVyKGd1YXJkLCBcImZhbGxiYWNrXCIsIGlucHV0cyk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBGYWxsYmFja0ZyYWdtZW50SW50ZXJuYWwgfSk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHBheWFibGUgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZmFsbGJhY2sgYXMgJSVmb3JtYXQlJS5cclxuICAgICAqL1xyXG4gICAgZm9ybWF0KGZvcm1hdCkge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSAoKHRoaXMuaW5wdXRzLmxlbmd0aCA9PT0gMCkgPyBcInJlY2VpdmVcIiA6IFwiZmFsbGJhY2tcIik7XHJcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhdGVNdXRhYmlsaXR5ID0gKHRoaXMucGF5YWJsZSA/IFwicGF5YWJsZVwiIDogXCJub25wYXlhYmxlXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeyB0eXBlLCBzdGF0ZU11dGFiaWxpdHkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBgJHt0eXBlfSgpJHt0aGlzLnBheWFibGUgPyBcIiBwYXlhYmxlXCIgOiBcIlwifWA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRmFsbGJhY2tGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbShvYmopIHtcclxuICAgICAgICBpZiAoRmFsbGJhY2tGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZhbGxiYWNrRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGZhbGxiYWNrIGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3JPYmogPSBvYmoudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY29uc3QgdG9wSXNWYWxpZCA9IG9iai5wZWVrS2V5d29yZChzZXRpZnkoW1wiZmFsbGJhY2tcIiwgXCJyZWNlaXZlXCJdKSk7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHRvcElzVmFsaWQsIFwidHlwZSBtdXN0IGJlIGZhbGxiYWNrIG9yIHJlY2VpdmVcIiwgXCJvYmpcIiwgZXJyb3JPYmopO1xyXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gb2JqLnBvcEtleXdvcmQoc2V0aWZ5KFtcImZhbGxiYWNrXCIsIFwicmVjZWl2ZVwiXSkpO1xyXG4gICAgICAgICAgICAvLyByZWNlaXZlKClcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwicmVjZWl2ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpbnB1dHMubGVuZ3RoID09PSAwLCBgcmVjZWl2ZSBjYW5ub3QgaGF2ZSBhcmd1bWVudHNgLCBcIm9iai5pbnB1dHNcIiwgaW5wdXRzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJwYXlhYmxlXCJdKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBbXSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZmFsbGJhY2soKSBbcGF5YWJsZV1cclxuICAgICAgICAgICAgLy8gZmFsbGJhY2soYnl0ZXMpIFtwYXlhYmxlXSByZXR1cm5zIChieXRlcylcclxuICAgICAgICAgICAgbGV0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcclxuICAgICAgICAgICAgaWYgKGlucHV0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlucHV0cy5sZW5ndGggPT09IDEgJiYgaW5wdXRzWzBdLnR5cGUgPT09IFwiYnl0ZXNcIiwgXCJpbnZhbGlkIGZhbGxiYWNrIGlucHV0c1wiLCBcIm9iai5pbnB1dHNcIiwgaW5wdXRzLm1hcCgoaSkgPT4gaS5mb3JtYXQoXCJtaW5pbWFsXCIpKS5qb2luKFwiLCBcIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaW5wdXRzID0gW1BhcmFtVHlwZS5mcm9tKFwiYnl0ZXNcIildO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG11dGFiaWxpdHkgPSBjb25zdW1lTXV0YWJpbGl0eShvYmopO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChtdXRhYmlsaXR5ID09PSBcIm5vbnBheWFibGVcIiB8fCBtdXRhYmlsaXR5ID09PSBcInBheWFibGVcIiwgXCJmYWxsYmFjayBjYW5ub3QgYmUgY29uc3RhbnRzXCIsIFwib2JqLnN0YXRlTXV0YWJpbGl0eVwiLCBtdXRhYmlsaXR5KTtcclxuICAgICAgICAgICAgaWYgKGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJyZXR1cm5zXCJdKSkuaGFzKFwicmV0dXJuc1wiKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KG91dHB1dHMubGVuZ3RoID09PSAxICYmIG91dHB1dHNbMF0udHlwZSA9PT0gXCJieXRlc1wiLCBcImludmFsaWQgZmFsbGJhY2sgb3V0cHV0c1wiLCBcIm9iai5vdXRwdXRzXCIsIG91dHB1dHMubWFwKChpKSA9PiBpLmZvcm1hdChcIm1pbmltYWxcIikpLmpvaW4oXCIsIFwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBpbnB1dHMsIG11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9iai50eXBlID09PSBcInJlY2VpdmVcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBbXSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJmYWxsYmFja1wiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IFtQYXJhbVR5cGUuZnJvbShcImJ5dGVzXCIpXTtcclxuICAgICAgICAgICAgY29uc3QgcGF5YWJsZSA9IChvYmouc3RhdGVNdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFsbGJhY2tGcmFnbWVudChfZ3VhcmQsIGlucHV0cywgcGF5YWJsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZmFsbGJhY2sgZGVzY3JpcHRpb25cIiwgXCJvYmpcIiwgb2JqKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxyXG4gICAgICogICoqRmFsbGJhY2tGcmFnbWVudCoqLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBGYWxsYmFja0ZyYWdtZW50SW50ZXJuYWwpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgbWV0aG9kLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uRnJhZ21lbnQgZXh0ZW5kcyBOYW1lZEZyYWdtZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogIElmIHRoZSBmdW5jdGlvbiBpcyBjb25zdGFudCAoZS5nLiBgYHB1cmVgYCBvciBgYHZpZXdgYCBmdW5jdGlvbnMpLlxyXG4gICAgICovXHJcbiAgICBjb25zdGFudDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSByZXR1cm5lZCB0eXBlcyBmb3IgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIG91dHB1dHM7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgc3RhdGUgbXV0YWJpbGl0eSAoZS5nLiBgYHBheWFibGVgYCwgYGBub25wYXlhYmxlYGAsIGBgdmlld2BgXHJcbiAgICAgKiAgb3IgYGBwdXJlYGApXHJcbiAgICAgKi9cclxuICAgIHN0YXRlTXV0YWJpbGl0eTtcclxuICAgIC8qKlxyXG4gICAgICogIElmIHRoZSBmdW5jdGlvbiBjYW4gYmUgc2VudCB2YWx1ZSBkdXJpbmcgaW52b2NhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcGF5YWJsZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSByZWNvbW1lbmRlZCBnYXMgbGltaXQgdG8gc2VuZCB3aGVuIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2FzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIHN0YXRlTXV0YWJpbGl0eSwgaW5wdXRzLCBvdXRwdXRzLCBnYXMpIHtcclxuICAgICAgICBzdXBlcihndWFyZCwgXCJmdW5jdGlvblwiLCBuYW1lLCBpbnB1dHMpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogRnVuY3Rpb25GcmFnbWVudEludGVybmFsIH0pO1xyXG4gICAgICAgIG91dHB1dHMgPSBPYmplY3QuZnJlZXplKG91dHB1dHMuc2xpY2UoKSk7XHJcbiAgICAgICAgY29uc3QgY29uc3RhbnQgPSAoc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCBzdGF0ZU11dGFiaWxpdHkgPT09IFwicHVyZVwiKTtcclxuICAgICAgICBjb25zdCBwYXlhYmxlID0gKHN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIpO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBjb25zdGFudCwgZ2FzLCBvdXRwdXRzLCBwYXlhYmxlLCBzdGF0ZU11dGFiaWxpdHkgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgRnVuY3Rpb24gc2VsZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIGdldCBzZWxlY3RvcigpIHtcclxuICAgICAgICByZXR1cm4gaWQodGhpcy5mb3JtYXQoXCJzaWdoYXNoXCIpKS5zdWJzdHJpbmcoMCwgMTApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzICUlZm9ybWF0JSUuXHJcbiAgICAgKi9cclxuICAgIGZvcm1hdChmb3JtYXQpIHtcclxuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBjb25zdGFudDogdGhpcy5jb25zdGFudCxcclxuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogKCh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpID8gdGhpcy5zdGF0ZU11dGFiaWxpdHkgOiB1bmRlZmluZWQpLFxyXG4gICAgICAgICAgICAgICAgcGF5YWJsZTogdGhpcy5wYXlhYmxlLFxyXG4gICAgICAgICAgICAgICAgZ2FzOiAoKHRoaXMuZ2FzICE9IG51bGwpID8gdGhpcy5nYXMgOiB1bmRlZmluZWQpLFxyXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGkpID0+IEpTT04ucGFyc2UoaS5mb3JtYXQoZm9ybWF0KSkpLFxyXG4gICAgICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzLm1hcCgobykgPT4gSlNPTi5wYXJzZShvLmZvcm1hdChmb3JtYXQpKSksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChcImZ1bmN0aW9uXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm5hbWUgKyBqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpKTtcclxuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnN0YXRlTXV0YWJpbGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0cyAmJiB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChcInJldHVybnNcIik7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5vdXRwdXRzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2FzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGBAJHt0aGlzLmdhcy50b1N0cmluZygpfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gdGhlIHNlbGVjdG9yIGZvciBhIGZ1bmN0aW9uIHdpdGggJSVuYW1lJSUgYW5kICUlcGFyYW1zJSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRTZWxlY3RvcihuYW1lLCBwYXJhbXMpIHtcclxuICAgICAgICBwYXJhbXMgPSAocGFyYW1zIHx8IFtdKS5tYXAoKHApID0+IFBhcmFtVHlwZS5mcm9tKHApKTtcclxuICAgICAgICBjb25zdCBmcmFnbWVudCA9IG5ldyBGdW5jdGlvbkZyYWdtZW50KF9ndWFyZCwgbmFtZSwgXCJ2aWV3XCIsIHBhcmFtcywgW10sIG51bGwpO1xyXG4gICAgICAgIHJldHVybiBmcmFnbWVudC5zZWxlY3RvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBuZXcgKipGdW5jdGlvbkZyYWdtZW50KiogZm9yICUlb2JqJSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tKG9iaikge1xyXG4gICAgICAgIGlmIChGdW5jdGlvbkZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tKGxleChvYmopKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZnVuY3Rpb24gZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uc3VtZU5hbWUoXCJmdW5jdGlvblwiLCBvYmopO1xyXG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XHJcbiAgICAgICAgICAgIGNvbnN0IG11dGFiaWxpdHkgPSBjb25zdW1lTXV0YWJpbGl0eShvYmopO1xyXG4gICAgICAgICAgICBsZXQgb3V0cHV0cyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcInJldHVybnNcIl0pKS5oYXMoXCJyZXR1cm5zXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGdhcyA9IGNvbnN1bWVHYXMob2JqKTtcclxuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBtdXRhYmlsaXR5LCBpbnB1dHMsIG91dHB1dHMsIGdhcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBzdGF0ZU11dGFiaWxpdHkgPSBvYmouc3RhdGVNdXRhYmlsaXR5O1xyXG4gICAgICAgIC8vIFVzZSBsZWdhY3kgU29saWRpdHkgQUJJIGxvZ2ljIGlmIHN0YXRlTXV0YWJpbGl0eSBpcyBtaXNzaW5nXHJcbiAgICAgICAgaWYgKHN0YXRlTXV0YWJpbGl0eSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwicGF5YWJsZVwiO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIChvYmouY29uc3RhbnQpID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gXCJ2aWV3XCI7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9iai5jb25zdGFudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwicGF5YWJsZVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKG9iai5wYXlhYmxlKSA9PT0gXCJib29sZWFuXCIgJiYgIW9iai5wYXlhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgKG9iai5wYXlhYmxlKSA9PT0gXCJib29sZWFuXCIgJiYgIW9iai5wYXlhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcIm5vbnBheWFibGVcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBAVE9ETzogdmVyaWZ5U3RhdGUgZm9yIHN0YXRlTXV0YWJpbGl0eSAoZS5nLiB0aHJvdyBpZlxyXG4gICAgICAgIC8vICAgICAgICBwYXlhYmxlOiBmYWxzZSBidXQgc3RhdGVNdXRhYmlsaXR5IGlzIFwibm9ucGF5YWJsZVwiKVxyXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25GcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBzdGF0ZU11dGFiaWxpdHksIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSwgb2JqLm91dHB1dHMgPyBvYmoub3V0cHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10sIChvYmouZ2FzICE9IG51bGwpID8gb2JqLmdhcyA6IG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhXHJcbiAgICAgKiAgKipGdW5jdGlvbkZyYWdtZW50KiouXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEZ1bmN0aW9uRnJhZ21lbnRJbnRlcm5hbCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBzdHJ1Y3R1cmUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU3RydWN0RnJhZ21lbnQgZXh0ZW5kcyBOYW1lZEZyYWdtZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBpbnB1dHMpIHtcclxuICAgICAgICBzdXBlcihndWFyZCwgXCJzdHJ1Y3RcIiwgbmFtZSwgaW5wdXRzKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IFN0cnVjdEZyYWdtZW50SW50ZXJuYWwgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc3RydWN0IGFzICUlZm9ybWF0JSUuXHJcbiAgICAgKi9cclxuICAgIGZvcm1hdCgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBuZXcgKipTdHJ1Y3RGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbShvYmopIHtcclxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RydWN0RnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHN0cnVjdCBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcInN0cnVjdFwiLCBvYmopO1xyXG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XHJcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3RGcmFnbWVudChfZ3VhcmQsIG5hbWUsIGlucHV0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0RnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgb2JqLmlucHV0cyA/IG9iai5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdKTtcclxuICAgIH1cclxuICAgIC8vIEBUT0RPOiBmaXggdGhpcyByZXR1cm4gdHlwZVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhXHJcbiAgICAgKiAgKipTdHJ1Y3RGcmFnbWVudCoqLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBTdHJ1Y3RGcmFnbWVudEludGVybmFsKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcmFnbWVudHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/fragments.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/index.js":
/*!**************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbiCoder: () => (/* reexport safe */ _abi_coder_js__WEBPACK_IMPORTED_MODULE_0__.AbiCoder),\n/* harmony export */   ConstructorFragment: () => (/* reexport safe */ _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ConstructorFragment),\n/* harmony export */   ErrorDescription: () => (/* reexport safe */ _interface_js__WEBPACK_IMPORTED_MODULE_3__.ErrorDescription),\n/* harmony export */   ErrorFragment: () => (/* reexport safe */ _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment),\n/* harmony export */   EventFragment: () => (/* reexport safe */ _fragments_js__WEBPACK_IMPORTED_MODULE_2__.EventFragment),\n/* harmony export */   FallbackFragment: () => (/* reexport safe */ _fragments_js__WEBPACK_IMPORTED_MODULE_2__.FallbackFragment),\n/* harmony export */   Fragment: () => (/* reexport safe */ _fragments_js__WEBPACK_IMPORTED_MODULE_2__.Fragment),\n/* harmony export */   FunctionFragment: () => (/* reexport safe */ _fragments_js__WEBPACK_IMPORTED_MODULE_2__.FunctionFragment),\n/* harmony export */   Indexed: () => (/* reexport safe */ _interface_js__WEBPACK_IMPORTED_MODULE_3__.Indexed),\n/* harmony export */   Interface: () => (/* reexport safe */ _interface_js__WEBPACK_IMPORTED_MODULE_3__.Interface),\n/* harmony export */   LogDescription: () => (/* reexport safe */ _interface_js__WEBPACK_IMPORTED_MODULE_3__.LogDescription),\n/* harmony export */   NamedFragment: () => (/* reexport safe */ _fragments_js__WEBPACK_IMPORTED_MODULE_2__.NamedFragment),\n/* harmony export */   ParamType: () => (/* reexport safe */ _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ParamType),\n/* harmony export */   Result: () => (/* reexport safe */ _interface_js__WEBPACK_IMPORTED_MODULE_3__.Result),\n/* harmony export */   StructFragment: () => (/* reexport safe */ _fragments_js__WEBPACK_IMPORTED_MODULE_2__.StructFragment),\n/* harmony export */   TransactionDescription: () => (/* reexport safe */ _interface_js__WEBPACK_IMPORTED_MODULE_3__.TransactionDescription),\n/* harmony export */   Typed: () => (/* reexport safe */ _typed_js__WEBPACK_IMPORTED_MODULE_4__.Typed),\n/* harmony export */   checkResultErrors: () => (/* reexport safe */ _interface_js__WEBPACK_IMPORTED_MODULE_3__.checkResultErrors),\n/* harmony export */   decodeBytes32String: () => (/* reexport safe */ _bytes32_js__WEBPACK_IMPORTED_MODULE_1__.decodeBytes32String),\n/* harmony export */   encodeBytes32String: () => (/* reexport safe */ _bytes32_js__WEBPACK_IMPORTED_MODULE_1__.encodeBytes32String)\n/* harmony export */ });\n/* harmony import */ var _abi_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abi-coder.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var _bytes32_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bytes32.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/bytes32.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fragments.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/fragments.js\");\n/* harmony import */ var _interface_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interface.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./typed.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/**\r\n *  The Application Binary Interface (ABI) describes how method input\r\n *  parameters should be encoded, their results decoded, and how to\r\n *  decode events and errors.\r\n *\r\n *  See [About ABIs](docs-abi) for more details how they are used.\r\n *\r\n *  @_section api/abi:Application Binary Interface  [about-abi]\r\n *  @_navTitle: ABI\r\n */\r\n//////\r\n\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMEM7QUFDOEI7QUFDb0c7QUFDbkM7QUFDdEc7QUFDbkMiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcYWJpXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIFRoZSBBcHBsaWNhdGlvbiBCaW5hcnkgSW50ZXJmYWNlIChBQkkpIGRlc2NyaWJlcyBob3cgbWV0aG9kIGlucHV0XHJcbiAqICBwYXJhbWV0ZXJzIHNob3VsZCBiZSBlbmNvZGVkLCB0aGVpciByZXN1bHRzIGRlY29kZWQsIGFuZCBob3cgdG9cclxuICogIGRlY29kZSBldmVudHMgYW5kIGVycm9ycy5cclxuICpcclxuICogIFNlZSBbQWJvdXQgQUJJc10oZG9jcy1hYmkpIGZvciBtb3JlIGRldGFpbHMgaG93IHRoZXkgYXJlIHVzZWQuXHJcbiAqXHJcbiAqICBAX3NlY3Rpb24gYXBpL2FiaTpBcHBsaWNhdGlvbiBCaW5hcnkgSW50ZXJmYWNlICBbYWJvdXQtYWJpXVxyXG4gKiAgQF9uYXZUaXRsZTogQUJJXHJcbiAqL1xyXG4vLy8vLy9cclxuZXhwb3J0IHsgQWJpQ29kZXIgfSBmcm9tIFwiLi9hYmktY29kZXIuanNcIjtcclxuZXhwb3J0IHsgZGVjb2RlQnl0ZXMzMlN0cmluZywgZW5jb2RlQnl0ZXMzMlN0cmluZyB9IGZyb20gXCIuL2J5dGVzMzIuanNcIjtcclxuZXhwb3J0IHsgQ29uc3RydWN0b3JGcmFnbWVudCwgRXJyb3JGcmFnbWVudCwgRXZlbnRGcmFnbWVudCwgRmFsbGJhY2tGcmFnbWVudCwgRnJhZ21lbnQsIEZ1bmN0aW9uRnJhZ21lbnQsIE5hbWVkRnJhZ21lbnQsIFBhcmFtVHlwZSwgU3RydWN0RnJhZ21lbnQsIH0gZnJvbSBcIi4vZnJhZ21lbnRzLmpzXCI7XHJcbmV4cG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBJbmRleGVkLCBJbnRlcmZhY2UsIEVycm9yRGVzY3JpcHRpb24sIExvZ0Rlc2NyaXB0aW9uLCBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uLCBSZXN1bHQgfSBmcm9tIFwiLi9pbnRlcmZhY2UuanNcIjtcclxuZXhwb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi90eXBlZC5qc1wiO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/interface.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/interface.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorDescription: () => (/* binding */ ErrorDescription),\n/* harmony export */   Indexed: () => (/* binding */ Indexed),\n/* harmony export */   Interface: () => (/* binding */ Interface),\n/* harmony export */   LogDescription: () => (/* binding */ LogDescription),\n/* harmony export */   Result: () => (/* reexport safe */ _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Result),\n/* harmony export */   TransactionDescription: () => (/* binding */ TransactionDescription),\n/* harmony export */   checkResultErrors: () => (/* reexport safe */ _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.checkResultErrors)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../crypto/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../hash/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _abi_coder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abi-coder.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./coders/abstract-coder.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fragments.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/fragments.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./typed.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/**\r\n *  The Interface class is a low-level class that accepts an\r\n *  ABI and provides all the necessary functionality to encode\r\n *  and decode paramaters to and results from methods, events\r\n *  and errors.\r\n *\r\n *  It also provides several convenience methods to automatically\r\n *  search and find matching transactions and events to parse them.\r\n *\r\n *  @_subsection api/abi:Interfaces  [interfaces]\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n *  When using the [[Interface-parseLog]] to automatically match a Log to its event\r\n *  for parsing, a **LogDescription** is returned.\r\n */\r\nclass LogDescription {\r\n    /**\r\n     *  The matching fragment for the ``topic0``.\r\n     */\r\n    fragment;\r\n    /**\r\n     *  The name of the Event.\r\n     */\r\n    name;\r\n    /**\r\n     *  The full Event signature.\r\n     */\r\n    signature;\r\n    /**\r\n     *  The topic hash for the Event.\r\n     */\r\n    topic;\r\n    /**\r\n     *  The arguments passed into the Event with ``emit``.\r\n     */\r\n    args;\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    constructor(fragment, topic, args) {\r\n        const name = fragment.name, signature = fragment.format();\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\r\n            fragment, name, signature, topic, args\r\n        });\r\n    }\r\n}\r\n/**\r\n *  When using the [[Interface-parseTransaction]] to automatically match\r\n *  a transaction data to its function for parsing,\r\n *  a **TransactionDescription** is returned.\r\n */\r\nclass TransactionDescription {\r\n    /**\r\n     *  The matching fragment from the transaction ``data``.\r\n     */\r\n    fragment;\r\n    /**\r\n     *  The name of the Function from the transaction ``data``.\r\n     */\r\n    name;\r\n    /**\r\n     *  The arguments passed to the Function from the transaction ``data``.\r\n     */\r\n    args;\r\n    /**\r\n     *  The full Function signature from the transaction ``data``.\r\n     */\r\n    signature;\r\n    /**\r\n     *  The selector for the Function from the transaction ``data``.\r\n     */\r\n    selector;\r\n    /**\r\n     *  The ``value`` (in wei) from the transaction.\r\n     */\r\n    value;\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    constructor(fragment, selector, args, value) {\r\n        const name = fragment.name, signature = fragment.format();\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\r\n            fragment, name, args, signature, selector, value\r\n        });\r\n    }\r\n}\r\n/**\r\n *  When using the [[Interface-parseError]] to automatically match an\r\n *  error for a call result for parsing, an **ErrorDescription** is returned.\r\n */\r\nclass ErrorDescription {\r\n    /**\r\n     *  The matching fragment.\r\n     */\r\n    fragment;\r\n    /**\r\n     *  The name of the Error.\r\n     */\r\n    name;\r\n    /**\r\n     *  The arguments passed to the Error with ``revert``.\r\n     */\r\n    args;\r\n    /**\r\n     *  The full Error signature.\r\n     */\r\n    signature;\r\n    /**\r\n     *  The selector for the Error.\r\n     */\r\n    selector;\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    constructor(fragment, selector, args) {\r\n        const name = fragment.name, signature = fragment.format();\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\r\n            fragment, name, args, signature, selector\r\n        });\r\n    }\r\n}\r\n/**\r\n *  An **Indexed** is used as a value when a value that does not\r\n *  fit within a topic (i.e. not a fixed-length, 32-byte type). It\r\n *  is the ``keccak256`` of the value, and used for types such as\r\n *  arrays, tuples, bytes and strings.\r\n */\r\nclass Indexed {\r\n    /**\r\n     *  The ``keccak256`` of the value logged.\r\n     */\r\n    hash;\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    _isIndexed;\r\n    /**\r\n     *  Returns ``true`` if %%value%% is an **Indexed**.\r\n     *\r\n     *  This provides a Type Guard for property access.\r\n     */\r\n    static isIndexed(value) {\r\n        return !!(value && value._isIndexed);\r\n    }\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    constructor(hash) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { hash, _isIndexed: true });\r\n    }\r\n}\r\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\r\nconst PanicReasons = {\r\n    \"0\": \"generic panic\",\r\n    \"1\": \"assert(false)\",\r\n    \"17\": \"arithmetic overflow\",\r\n    \"18\": \"division or modulo by zero\",\r\n    \"33\": \"enum overflow\",\r\n    \"34\": \"invalid encoded storage byte array accessed\",\r\n    \"49\": \"out-of-bounds array access; popping on an empty array\",\r\n    \"50\": \"out-of-bounds access of an array or bytesN\",\r\n    \"65\": \"out of memory\",\r\n    \"81\": \"uninitialized function\",\r\n};\r\nconst BuiltinErrors = {\r\n    \"0x08c379a0\": {\r\n        signature: \"Error(string)\",\r\n        name: \"Error\",\r\n        inputs: [\"string\"],\r\n        reason: (message) => {\r\n            return `reverted with reason string ${JSON.stringify(message)}`;\r\n        }\r\n    },\r\n    \"0x4e487b71\": {\r\n        signature: \"Panic(uint256)\",\r\n        name: \"Panic\",\r\n        inputs: [\"uint256\"],\r\n        reason: (code) => {\r\n            let reason = \"unknown panic code\";\r\n            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\r\n                reason = PanicReasons[code.toString()];\r\n            }\r\n            return `reverted with panic code 0x${code.toString(16)} (${reason})`;\r\n        }\r\n    }\r\n};\r\n/**\r\n *  An Interface abstracts many of the low-level details for\r\n *  encoding and decoding the data on the blockchain.\r\n *\r\n *  An ABI provides information on how to encode data to send to\r\n *  a Contract, how to decode the results and events and how to\r\n *  interpret revert errors.\r\n *\r\n *  The ABI can be specified by [any supported format](InterfaceAbi).\r\n */\r\nclass Interface {\r\n    /**\r\n     *  All the Contract ABI members (i.e. methods, events, errors, etc).\r\n     */\r\n    fragments;\r\n    /**\r\n     *  The Contract constructor.\r\n     */\r\n    deploy;\r\n    /**\r\n     *  The Fallback method, if any.\r\n     */\r\n    fallback;\r\n    /**\r\n     *  If receiving ether is supported.\r\n     */\r\n    receive;\r\n    #errors;\r\n    #events;\r\n    #functions;\r\n    //    #structs: Map<string, StructFragment>;\r\n    #abiCoder;\r\n    /**\r\n     *  Create a new Interface for the %%fragments%%.\r\n     */\r\n    constructor(fragments) {\r\n        let abi = [];\r\n        if (typeof (fragments) === \"string\") {\r\n            abi = JSON.parse(fragments);\r\n        }\r\n        else {\r\n            abi = fragments;\r\n        }\r\n        this.#functions = new Map();\r\n        this.#errors = new Map();\r\n        this.#events = new Map();\r\n        //        this.#structs = new Map();\r\n        const frags = [];\r\n        for (const a of abi) {\r\n            try {\r\n                frags.push(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(a));\r\n            }\r\n            catch (error) {\r\n                console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, error.message);\r\n            }\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\r\n            fragments: Object.freeze(frags)\r\n        });\r\n        let fallback = null;\r\n        let receive = false;\r\n        this.#abiCoder = this.getAbiCoder();\r\n        // Add all fragments by their signature\r\n        this.fragments.forEach((fragment, index) => {\r\n            let bucket;\r\n            switch (fragment.type) {\r\n                case \"constructor\":\r\n                    if (this.deploy) {\r\n                        console.log(\"duplicate definition - constructor\");\r\n                        return;\r\n                    }\r\n                    //checkNames(fragment, \"input\", fragment.inputs);\r\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { deploy: fragment });\r\n                    return;\r\n                case \"fallback\":\r\n                    if (fragment.inputs.length === 0) {\r\n                        receive = true;\r\n                    }\r\n                    else {\r\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(!fallback || fragment.payable !== fallback.payable, \"conflicting fallback fragments\", `fragments[${index}]`, fragment);\r\n                        fallback = fragment;\r\n                        receive = fallback.payable;\r\n                    }\r\n                    return;\r\n                case \"function\":\r\n                    //checkNames(fragment, \"input\", fragment.inputs);\r\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\r\n                    bucket = this.#functions;\r\n                    break;\r\n                case \"event\":\r\n                    //checkNames(fragment, \"input\", fragment.inputs);\r\n                    bucket = this.#events;\r\n                    break;\r\n                case \"error\":\r\n                    bucket = this.#errors;\r\n                    break;\r\n                default:\r\n                    return;\r\n            }\r\n            // Two identical entries; ignore it\r\n            const signature = fragment.format();\r\n            if (bucket.has(signature)) {\r\n                return;\r\n            }\r\n            bucket.set(signature, fragment);\r\n        });\r\n        // If we do not have a constructor add a default\r\n        if (!this.deploy) {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\r\n                deploy: _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ConstructorFragment.from(\"constructor()\")\r\n            });\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { fallback, receive });\r\n    }\r\n    /**\r\n     *  Returns the entire Human-Readable ABI, as an array of\r\n     *  signatures, optionally as %%minimal%% strings, which\r\n     *  removes parameter names and unneceesary spaces.\r\n     */\r\n    format(minimal) {\r\n        const format = (minimal ? \"minimal\" : \"full\");\r\n        const abi = this.fragments.map((f) => f.format(format));\r\n        return abi;\r\n    }\r\n    /**\r\n     *  Return the JSON-encoded ABI. This is the format Solidiy\r\n     *  returns.\r\n     */\r\n    formatJson() {\r\n        const abi = this.fragments.map((f) => f.format(\"json\"));\r\n        // We need to re-bundle the JSON fragments a bit\r\n        return JSON.stringify(abi.map((j) => JSON.parse(j)));\r\n    }\r\n    /**\r\n     *  The ABI coder that will be used to encode and decode binary\r\n     *  data.\r\n     */\r\n    getAbiCoder() {\r\n        return _abi_coder_js__WEBPACK_IMPORTED_MODULE_3__.AbiCoder.defaultAbiCoder();\r\n    }\r\n    // Find a function definition by any means necessary (unless it is ambiguous)\r\n    #getFunction(key, values, forceUnique) {\r\n        // Selector\r\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(key)) {\r\n            const selector = key.toLowerCase();\r\n            for (const fragment of this.#functions.values()) {\r\n                if (selector === fragment.selector) {\r\n                    return fragment;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        // It is a bare name, look up the function (will return null if ambiguous)\r\n        if (key.indexOf(\"(\") === -1) {\r\n            const matching = [];\r\n            for (const [name, fragment] of this.#functions) {\r\n                if (name.split(\"(\" /* fix:) */)[0] === key) {\r\n                    matching.push(fragment);\r\n                }\r\n            }\r\n            if (values) {\r\n                const lastValue = (values.length > 0) ? values[values.length - 1] : null;\r\n                let valueLength = values.length;\r\n                let allowOptions = true;\r\n                if (_typed_js__WEBPACK_IMPORTED_MODULE_4__.Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\r\n                    allowOptions = false;\r\n                    valueLength--;\r\n                }\r\n                // Remove all matches that don't have a compatible length. The args\r\n                // may contain an overrides, so the match may have n or n - 1 parameters\r\n                for (let i = matching.length - 1; i >= 0; i--) {\r\n                    const inputs = matching[i].inputs.length;\r\n                    if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\r\n                        matching.splice(i, 1);\r\n                    }\r\n                }\r\n                // Remove all matches that don't match the Typed signature\r\n                for (let i = matching.length - 1; i >= 0; i--) {\r\n                    const inputs = matching[i].inputs;\r\n                    for (let j = 0; j < values.length; j++) {\r\n                        // Not a typed value\r\n                        if (!_typed_js__WEBPACK_IMPORTED_MODULE_4__.Typed.isTyped(values[j])) {\r\n                            continue;\r\n                        }\r\n                        // We are past the inputs\r\n                        if (j >= inputs.length) {\r\n                            if (values[j].type === \"overrides\") {\r\n                                continue;\r\n                            }\r\n                            matching.splice(i, 1);\r\n                            break;\r\n                        }\r\n                        // Make sure the value type matches the input type\r\n                        if (values[j].type !== inputs[j].baseType) {\r\n                            matching.splice(i, 1);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // We found a single matching signature with an overrides, but the\r\n            // last value is something that cannot possibly be an options\r\n            if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\r\n                const lastArg = values[values.length - 1];\r\n                if (lastArg == null || Array.isArray(lastArg) || typeof (lastArg) !== \"object\") {\r\n                    matching.splice(0, 1);\r\n                }\r\n            }\r\n            if (matching.length === 0) {\r\n                return null;\r\n            }\r\n            if (matching.length > 1 && forceUnique) {\r\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, `ambiguous function description (i.e. matches ${matchStr})`, \"key\", key);\r\n            }\r\n            return matching[0];\r\n        }\r\n        // Normalize the signature and lookup the function\r\n        const result = this.#functions.get(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.FunctionFragment.from(key).format());\r\n        if (result) {\r\n            return result;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     *  Get the function name for %%key%%, which may be a function selector,\r\n     *  function name or function signature that belongs to the ABI.\r\n     */\r\n    getFunctionName(key) {\r\n        const fragment = this.#getFunction(key, null, false);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(fragment, \"no matching function\", \"key\", key);\r\n        return fragment.name;\r\n    }\r\n    /**\r\n     *  Returns true if %%key%% (a function selector, function name or\r\n     *  function signature) is present in the ABI.\r\n     *\r\n     *  In the case of a function name, the name may be ambiguous, so\r\n     *  accessing the [[FunctionFragment]] may require refinement.\r\n     */\r\n    hasFunction(key) {\r\n        return !!this.#getFunction(key, null, false);\r\n    }\r\n    /**\r\n     *  Get the [[FunctionFragment]] for %%key%%, which may be a function\r\n     *  selector, function name or function signature that belongs to the ABI.\r\n     *\r\n     *  If %%values%% is provided, it will use the Typed API to handle\r\n     *  ambiguous cases where multiple functions match by name.\r\n     *\r\n     *  If the %%key%% and %%values%% do not refine to a single function in\r\n     *  the ABI, this will throw.\r\n     */\r\n    getFunction(key, values) {\r\n        return this.#getFunction(key, values || null, true);\r\n    }\r\n    /**\r\n     *  Iterate over all functions, calling %%callback%%, sorted by their name.\r\n     */\r\n    forEachFunction(callback) {\r\n        const names = Array.from(this.#functions.keys());\r\n        names.sort((a, b) => a.localeCompare(b));\r\n        for (let i = 0; i < names.length; i++) {\r\n            const name = names[i];\r\n            callback((this.#functions.get(name)), i);\r\n        }\r\n    }\r\n    // Find an event definition by any means necessary (unless it is ambiguous)\r\n    #getEvent(key, values, forceUnique) {\r\n        // EventTopic\r\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(key)) {\r\n            const eventTopic = key.toLowerCase();\r\n            for (const fragment of this.#events.values()) {\r\n                if (eventTopic === fragment.topicHash) {\r\n                    return fragment;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        // It is a bare name, look up the function (will return null if ambiguous)\r\n        if (key.indexOf(\"(\") === -1) {\r\n            const matching = [];\r\n            for (const [name, fragment] of this.#events) {\r\n                if (name.split(\"(\" /* fix:) */)[0] === key) {\r\n                    matching.push(fragment);\r\n                }\r\n            }\r\n            if (values) {\r\n                // Remove all matches that don't have a compatible length.\r\n                for (let i = matching.length - 1; i >= 0; i--) {\r\n                    if (matching[i].inputs.length < values.length) {\r\n                        matching.splice(i, 1);\r\n                    }\r\n                }\r\n                // Remove all matches that don't match the Typed signature\r\n                for (let i = matching.length - 1; i >= 0; i--) {\r\n                    const inputs = matching[i].inputs;\r\n                    for (let j = 0; j < values.length; j++) {\r\n                        // Not a typed value\r\n                        if (!_typed_js__WEBPACK_IMPORTED_MODULE_4__.Typed.isTyped(values[j])) {\r\n                            continue;\r\n                        }\r\n                        // Make sure the value type matches the input type\r\n                        if (values[j].type !== inputs[j].baseType) {\r\n                            matching.splice(i, 1);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (matching.length === 0) {\r\n                return null;\r\n            }\r\n            if (matching.length > 1 && forceUnique) {\r\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, `ambiguous event description (i.e. matches ${matchStr})`, \"key\", key);\r\n            }\r\n            return matching[0];\r\n        }\r\n        // Normalize the signature and lookup the function\r\n        const result = this.#events.get(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.EventFragment.from(key).format());\r\n        if (result) {\r\n            return result;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     *  Get the event name for %%key%%, which may be a topic hash,\r\n     *  event name or event signature that belongs to the ABI.\r\n     */\r\n    getEventName(key) {\r\n        const fragment = this.#getEvent(key, null, false);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(fragment, \"no matching event\", \"key\", key);\r\n        return fragment.name;\r\n    }\r\n    /**\r\n     *  Returns true if %%key%% (an event topic hash, event name or\r\n     *  event signature) is present in the ABI.\r\n     *\r\n     *  In the case of an event name, the name may be ambiguous, so\r\n     *  accessing the [[EventFragment]] may require refinement.\r\n     */\r\n    hasEvent(key) {\r\n        return !!this.#getEvent(key, null, false);\r\n    }\r\n    /**\r\n     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\r\n     *  event name or event signature that belongs to the ABI.\r\n     *\r\n     *  If %%values%% is provided, it will use the Typed API to handle\r\n     *  ambiguous cases where multiple events match by name.\r\n     *\r\n     *  If the %%key%% and %%values%% do not refine to a single event in\r\n     *  the ABI, this will throw.\r\n     */\r\n    getEvent(key, values) {\r\n        return this.#getEvent(key, values || null, true);\r\n    }\r\n    /**\r\n     *  Iterate over all events, calling %%callback%%, sorted by their name.\r\n     */\r\n    forEachEvent(callback) {\r\n        const names = Array.from(this.#events.keys());\r\n        names.sort((a, b) => a.localeCompare(b));\r\n        for (let i = 0; i < names.length; i++) {\r\n            const name = names[i];\r\n            callback((this.#events.get(name)), i);\r\n        }\r\n    }\r\n    /**\r\n     *  Get the [[ErrorFragment]] for %%key%%, which may be an error\r\n     *  selector, error name or error signature that belongs to the ABI.\r\n     *\r\n     *  If %%values%% is provided, it will use the Typed API to handle\r\n     *  ambiguous cases where multiple errors match by name.\r\n     *\r\n     *  If the %%key%% and %%values%% do not refine to a single error in\r\n     *  the ABI, this will throw.\r\n     */\r\n    getError(key, values) {\r\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(key)) {\r\n            const selector = key.toLowerCase();\r\n            if (BuiltinErrors[selector]) {\r\n                return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(BuiltinErrors[selector].signature);\r\n            }\r\n            for (const fragment of this.#errors.values()) {\r\n                if (selector === fragment.selector) {\r\n                    return fragment;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        // It is a bare name, look up the function (will return null if ambiguous)\r\n        if (key.indexOf(\"(\") === -1) {\r\n            const matching = [];\r\n            for (const [name, fragment] of this.#errors) {\r\n                if (name.split(\"(\" /* fix:) */)[0] === key) {\r\n                    matching.push(fragment);\r\n                }\r\n            }\r\n            if (matching.length === 0) {\r\n                if (key === \"Error\") {\r\n                    return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Error(string)\");\r\n                }\r\n                if (key === \"Panic\") {\r\n                    return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Panic(uint256)\");\r\n                }\r\n                return null;\r\n            }\r\n            else if (matching.length > 1) {\r\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, `ambiguous error description (i.e. ${matchStr})`, \"name\", key);\r\n            }\r\n            return matching[0];\r\n        }\r\n        // Normalize the signature and lookup the function\r\n        key = _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(key).format();\r\n        if (key === \"Error(string)\") {\r\n            return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Error(string)\");\r\n        }\r\n        if (key === \"Panic(uint256)\") {\r\n            return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Panic(uint256)\");\r\n        }\r\n        const result = this.#errors.get(key);\r\n        if (result) {\r\n            return result;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     *  Iterate over all errors, calling %%callback%%, sorted by their name.\r\n     */\r\n    forEachError(callback) {\r\n        const names = Array.from(this.#errors.keys());\r\n        names.sort((a, b) => a.localeCompare(b));\r\n        for (let i = 0; i < names.length; i++) {\r\n            const name = names[i];\r\n            callback((this.#errors.get(name)), i);\r\n        }\r\n    }\r\n    // Get the 4-byte selector used by Solidity to identify a function\r\n    /*\r\ngetSelector(fragment: ErrorFragment | FunctionFragment): string {\r\n    if (typeof(fragment) === \"string\") {\r\n        const matches: Array<Fragment> = [ ];\r\n\r\n        try { matches.push(this.getFunction(fragment)); } catch (error) { }\r\n        try { matches.push(this.getError(<string>fragment)); } catch (_) { }\r\n\r\n        if (matches.length === 0) {\r\n            logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\r\n        } else if (matches.length > 1) {\r\n            logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\r\n        }\r\n\r\n        fragment = matches[0];\r\n    }\r\n\r\n    return dataSlice(id(fragment.format()), 0, 4);\r\n}\r\n    */\r\n    // Get the 32-byte topic hash used by Solidity to identify an event\r\n    /*\r\n    getEventTopic(fragment: EventFragment): string {\r\n        //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\r\n        return id(fragment.format());\r\n    }\r\n    */\r\n    _decodeParams(params, data) {\r\n        return this.#abiCoder.decode(params, data);\r\n    }\r\n    _encodeParams(params, values) {\r\n        return this.#abiCoder.encode(params, values);\r\n    }\r\n    /**\r\n     *  Encodes a ``tx.data`` object for deploying the Contract with\r\n     *  the %%values%% as the constructor arguments.\r\n     */\r\n    encodeDeploy(values) {\r\n        return this._encodeParams(this.deploy.inputs, values || []);\r\n    }\r\n    /**\r\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\r\n     *  specified error (see [[getError]] for valid values for\r\n     *  %%key%%).\r\n     *\r\n     *  Most developers should prefer the [[parseCallResult]] method instead,\r\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\r\n     *  corresponding error.\r\n     */\r\n    decodeErrorResult(fragment, data) {\r\n        if (typeof (fragment) === \"string\") {\r\n            const f = this.getError(fragment);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\r\n            fragment = f;\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, \"data\", data);\r\n        return this._decodeParams(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 4));\r\n    }\r\n    /**\r\n     *  Encodes the transaction revert data for a call result that\r\n     *  reverted from the the Contract with the sepcified %%error%%\r\n     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\r\n     *\r\n     *  This is generally not used by most developers, unless trying to mock\r\n     *  a result from a Contract.\r\n     */\r\n    encodeErrorResult(fragment, values) {\r\n        if (typeof (fragment) === \"string\") {\r\n            const f = this.getError(fragment);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\r\n            fragment = f;\r\n        }\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([\r\n            fragment.selector,\r\n            this._encodeParams(fragment.inputs, values || [])\r\n        ]);\r\n    }\r\n    /**\r\n     *  Decodes the %%data%% from a transaction ``tx.data`` for\r\n     *  the function specified (see [[getFunction]] for valid values\r\n     *  for %%fragment%%).\r\n     *\r\n     *  Most developers should prefer the [[parseTransaction]] method\r\n     *  instead, which will automatically detect the fragment.\r\n     */\r\n    decodeFunctionData(fragment, data) {\r\n        if (typeof (fragment) === \"string\") {\r\n            const f = this.getFunction(fragment);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\r\n            fragment = f;\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, \"data\", data);\r\n        return this._decodeParams(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 4));\r\n    }\r\n    /**\r\n     *  Encodes the ``tx.data`` for a transaction that calls the function\r\n     *  specified (see [[getFunction]] for valid values for %%fragment%%) with\r\n     *  the %%values%%.\r\n     */\r\n    encodeFunctionData(fragment, values) {\r\n        if (typeof (fragment) === \"string\") {\r\n            const f = this.getFunction(fragment);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\r\n            fragment = f;\r\n        }\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([\r\n            fragment.selector,\r\n            this._encodeParams(fragment.inputs, values || [])\r\n        ]);\r\n    }\r\n    /**\r\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\r\n     *  specified function (see [[getFunction]] for valid values for\r\n     *  %%key%%).\r\n     *\r\n     *  Most developers should prefer the [[parseCallResult]] method instead,\r\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\r\n     *  corresponding error.\r\n     */\r\n    decodeFunctionResult(fragment, data) {\r\n        if (typeof (fragment) === \"string\") {\r\n            const f = this.getFunction(fragment);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\r\n            fragment = f;\r\n        }\r\n        let message = \"invalid length for result data\";\r\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(data);\r\n        if ((bytes.length % 32) === 0) {\r\n            try {\r\n                return this.#abiCoder.decode(fragment.outputs, bytes);\r\n            }\r\n            catch (error) {\r\n                message = \"could not decode result data\";\r\n            }\r\n        }\r\n        // Call returned data with no error, but the data is junk\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, message, \"BAD_DATA\", {\r\n            value: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(bytes),\r\n            info: { method: fragment.name, signature: fragment.format() }\r\n        });\r\n    }\r\n    makeError(_data, tx) {\r\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\r\n        const error = _abi_coder_js__WEBPACK_IMPORTED_MODULE_3__.AbiCoder.getBuiltinCallException(\"call\", tx, data);\r\n        // Not a built-in error; try finding a custom error\r\n        const customPrefix = \"execution reverted (unknown custom error)\";\r\n        if (error.message.startsWith(customPrefix)) {\r\n            const selector = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data.slice(0, 4));\r\n            const ef = this.getError(selector);\r\n            if (ef) {\r\n                try {\r\n                    const args = this.#abiCoder.decode(ef.inputs, data.slice(4));\r\n                    error.revert = {\r\n                        name: ef.name, signature: ef.format(), args\r\n                    };\r\n                    error.reason = error.revert.signature;\r\n                    error.message = `execution reverted: ${error.reason}`;\r\n                }\r\n                catch (e) {\r\n                    error.message = `execution reverted (coult not decode custom error)`;\r\n                }\r\n            }\r\n        }\r\n        // Add the invocation, if available\r\n        const parsed = this.parseTransaction(tx);\r\n        if (parsed) {\r\n            error.invocation = {\r\n                method: parsed.name,\r\n                signature: parsed.signature,\r\n                args: parsed.args\r\n            };\r\n        }\r\n        return error;\r\n    }\r\n    /**\r\n     *  Encodes the result data (e.g. from an ``eth_call``) for the\r\n     *  specified function (see [[getFunction]] for valid values\r\n     *  for %%fragment%%) with %%values%%.\r\n     *\r\n     *  This is generally not used by most developers, unless trying to mock\r\n     *  a result from a Contract.\r\n     */\r\n    encodeFunctionResult(fragment, values) {\r\n        if (typeof (fragment) === \"string\") {\r\n            const f = this.getFunction(fragment);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\r\n            fragment = f;\r\n        }\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(this.#abiCoder.encode(fragment.outputs, values || []));\r\n    }\r\n    /*\r\n        spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\r\n            const promises: Array<Promise<>> = [ ];\r\n            const process = function(type: ParamType, value: any): any {\r\n                if (type.baseType === \"array\") {\r\n                    return descend(type.child\r\n                }\r\n                if (type. === \"address\") {\r\n                }\r\n            };\r\n    \r\n            const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\r\n                if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\r\n                \r\n            };\r\n    \r\n            const result: Array<any> = [ ];\r\n            values.forEach((value, index) => {\r\n                if (value == null) {\r\n                    topics.push(null);\r\n                } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\r\n                    logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\r\n                } else if (Array.isArray(value)) {\r\n                    topics.push(value.map((value) => encodeTopic(param, value)));\r\n                } else {\r\n                    topics.push(encodeTopic(param, value));\r\n                }\r\n            });\r\n        }\r\n    */\r\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\r\n    encodeFilterTopics(fragment, values) {\r\n        if (typeof (fragment) === \"string\") {\r\n            const f = this.getEvent(fragment);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\r\n            fragment = f;\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, \"UNEXPECTED_ARGUMENT\", { count: values.length, expectedCount: fragment.inputs.length });\r\n        const topics = [];\r\n        if (!fragment.anonymous) {\r\n            topics.push(fragment.topicHash);\r\n        }\r\n        // @TODO: Use the coders for this; to properly support tuples, etc.\r\n        const encodeTopic = (param, value) => {\r\n            if (param.type === \"string\") {\r\n                return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_5__.id)(value);\r\n            }\r\n            else if (param.type === \"bytes\") {\r\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_6__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(value));\r\n            }\r\n            if (param.type === \"bool\" && typeof (value) === \"boolean\") {\r\n                value = (value ? \"0x01\" : \"0x00\");\r\n            }\r\n            else if (param.type.match(/^u?int/)) {\r\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeHex)(value); // @TODO: Should this toTwos??\r\n            }\r\n            else if (param.type.match(/^bytes/)) {\r\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.zeroPadBytes)(value, 32);\r\n            }\r\n            else if (param.type === \"address\") {\r\n                // Check addresses are valid\r\n                this.#abiCoder.encode([\"address\"], [value]);\r\n            }\r\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.zeroPadValue)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(value), 32);\r\n        };\r\n        values.forEach((value, index) => {\r\n            const param = fragment.inputs[index];\r\n            if (!param.indexed) {\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(value == null, \"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\r\n                return;\r\n            }\r\n            if (value == null) {\r\n                topics.push(null);\r\n            }\r\n            else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\r\n            }\r\n            else if (Array.isArray(value)) {\r\n                topics.push(value.map((value) => encodeTopic(param, value)));\r\n            }\r\n            else {\r\n                topics.push(encodeTopic(param, value));\r\n            }\r\n        });\r\n        // Trim off trailing nulls\r\n        while (topics.length && topics[topics.length - 1] === null) {\r\n            topics.pop();\r\n        }\r\n        return topics;\r\n    }\r\n    encodeEventLog(fragment, values) {\r\n        if (typeof (fragment) === \"string\") {\r\n            const f = this.getEvent(fragment);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\r\n            fragment = f;\r\n        }\r\n        const topics = [];\r\n        const dataTypes = [];\r\n        const dataValues = [];\r\n        if (!fragment.anonymous) {\r\n            topics.push(fragment.topicHash);\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(values.length === fragment.inputs.length, \"event arguments/values mismatch\", \"values\", values);\r\n        fragment.inputs.forEach((param, index) => {\r\n            const value = values[index];\r\n            if (param.indexed) {\r\n                if (param.type === \"string\") {\r\n                    topics.push((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_5__.id)(value));\r\n                }\r\n                else if (param.type === \"bytes\") {\r\n                    topics.push((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_6__.keccak256)(value));\r\n                }\r\n                else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\r\n                    // @TODO\r\n                    throw new Error(\"not implemented\");\r\n                }\r\n                else {\r\n                    topics.push(this.#abiCoder.encode([param.type], [value]));\r\n                }\r\n            }\r\n            else {\r\n                dataTypes.push(param);\r\n                dataValues.push(value);\r\n            }\r\n        });\r\n        return {\r\n            data: this.#abiCoder.encode(dataTypes, dataValues),\r\n            topics: topics\r\n        };\r\n    }\r\n    // Decode a filter for the event and the search criteria\r\n    decodeEventLog(fragment, data, topics) {\r\n        if (typeof (fragment) === \"string\") {\r\n            const f = this.getEvent(fragment);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\r\n            fragment = f;\r\n        }\r\n        if (topics != null && !fragment.anonymous) {\r\n            const eventTopic = fragment.topicHash;\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(topics[0], 32) && topics[0].toLowerCase() === eventTopic, \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\r\n            topics = topics.slice(1);\r\n        }\r\n        const indexed = [];\r\n        const nonIndexed = [];\r\n        const dynamic = [];\r\n        fragment.inputs.forEach((param, index) => {\r\n            if (param.indexed) {\r\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\r\n                    indexed.push(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.ParamType.from({ type: \"bytes32\", name: param.name }));\r\n                    dynamic.push(true);\r\n                }\r\n                else {\r\n                    indexed.push(param);\r\n                    dynamic.push(false);\r\n                }\r\n            }\r\n            else {\r\n                nonIndexed.push(param);\r\n                dynamic.push(false);\r\n            }\r\n        });\r\n        const resultIndexed = (topics != null) ? this.#abiCoder.decode(indexed, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)(topics)) : null;\r\n        const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);\r\n        //const result: (Array<any> & { [ key: string ]: any }) = [ ];\r\n        const values = [];\r\n        const keys = [];\r\n        let nonIndexedIndex = 0, indexedIndex = 0;\r\n        fragment.inputs.forEach((param, index) => {\r\n            let value = null;\r\n            if (param.indexed) {\r\n                if (resultIndexed == null) {\r\n                    value = new Indexed(null);\r\n                }\r\n                else if (dynamic[index]) {\r\n                    value = new Indexed(resultIndexed[indexedIndex++]);\r\n                }\r\n                else {\r\n                    try {\r\n                        value = resultIndexed[indexedIndex++];\r\n                    }\r\n                    catch (error) {\r\n                        value = error;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                try {\r\n                    value = resultNonIndexed[nonIndexedIndex++];\r\n                }\r\n                catch (error) {\r\n                    value = error;\r\n                }\r\n            }\r\n            values.push(value);\r\n            keys.push(param.name || null);\r\n        });\r\n        return _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Result.fromItems(values, keys);\r\n    }\r\n    /**\r\n     *  Parses a transaction, finding the matching function and extracts\r\n     *  the parameter values along with other useful function details.\r\n     *\r\n     *  If the matching function cannot be found, return null.\r\n     */\r\n    parseTransaction(tx) {\r\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(tx.data, \"tx.data\");\r\n        const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)((tx.value != null) ? tx.value : 0, \"tx.value\");\r\n        const fragment = this.getFunction((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data.slice(0, 4)));\r\n        if (!fragment) {\r\n            return null;\r\n        }\r\n        const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));\r\n        return new TransactionDescription(fragment, fragment.selector, args, value);\r\n    }\r\n    parseCallResult(data) {\r\n        throw new Error(\"@TODO\");\r\n    }\r\n    /**\r\n     *  Parses a receipt log, finding the matching event and extracts\r\n     *  the parameter values along with other useful event details.\r\n     *\r\n     *  If the matching event cannot be found, returns null.\r\n     */\r\n    parseLog(log) {\r\n        const fragment = this.getEvent(log.topics[0]);\r\n        if (!fragment || fragment.anonymous) {\r\n            return null;\r\n        }\r\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\r\n        //        Probably not, because just because it is the only event in the ABI does\r\n        //        not mean we have the full ABI; maybe just a fragment?\r\n        return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\r\n    }\r\n    /**\r\n     *  Parses a revert data, finding the matching error and extracts\r\n     *  the parameter values along with other useful error details.\r\n     *\r\n     *  If the matching error cannot be found, returns null.\r\n     */\r\n    parseError(data) {\r\n        const hexData = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data);\r\n        const fragment = this.getError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(hexData, 0, 4));\r\n        if (!fragment) {\r\n            return null;\r\n        }\r\n        const args = this.#abiCoder.decode(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(hexData, 4));\r\n        return new ErrorDescription(fragment, fragment.selector, args);\r\n    }\r\n    /**\r\n     *  Creates a new [[Interface]] from the ABI %%value%%.\r\n     *\r\n     *  The %%value%% may be provided as an existing [[Interface]] object,\r\n     *  a JSON-encoded ABI or any Human-Readable ABI format.\r\n     */\r\n    static from(value) {\r\n        // Already an Interface, which is immutable\r\n        if (value instanceof Interface) {\r\n            return value;\r\n        }\r\n        // JSON\r\n        if (typeof (value) === \"string\") {\r\n            return new Interface(JSON.parse(value));\r\n        }\r\n        // An Interface; possibly from another v6 instance\r\n        if (typeof (value.formatJson) === \"function\") {\r\n            return new Interface(value.formatJson());\r\n        }\r\n        // A legacy Interface; from an older version\r\n        if (typeof (value.format) === \"function\") {\r\n            return new Interface(value.format(\"json\"));\r\n        }\r\n        // Array of fragments\r\n        return new Interface(value);\r\n    }\r\n}\r\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvaW50ZXJmYWNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrQztBQUNUO0FBQ3dKO0FBQ3BKO0FBQzZCO0FBQ21EO0FBQ3ZGO0FBQ0U7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFnQjtBQUN4QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXGFiaVxcaW50ZXJmYWNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgVGhlIEludGVyZmFjZSBjbGFzcyBpcyBhIGxvdy1sZXZlbCBjbGFzcyB0aGF0IGFjY2VwdHMgYW5cclxuICogIEFCSSBhbmQgcHJvdmlkZXMgYWxsIHRoZSBuZWNlc3NhcnkgZnVuY3Rpb25hbGl0eSB0byBlbmNvZGVcclxuICogIGFuZCBkZWNvZGUgcGFyYW1hdGVycyB0byBhbmQgcmVzdWx0cyBmcm9tIG1ldGhvZHMsIGV2ZW50c1xyXG4gKiAgYW5kIGVycm9ycy5cclxuICpcclxuICogIEl0IGFsc28gcHJvdmlkZXMgc2V2ZXJhbCBjb252ZW5pZW5jZSBtZXRob2RzIHRvIGF1dG9tYXRpY2FsbHlcclxuICogIHNlYXJjaCBhbmQgZmluZCBtYXRjaGluZyB0cmFuc2FjdGlvbnMgYW5kIGV2ZW50cyB0byBwYXJzZSB0aGVtLlxyXG4gKlxyXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS9hYmk6SW50ZXJmYWNlcyAgW2ludGVyZmFjZXNdXHJcbiAqL1xyXG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgY29uY2F0LCBkYXRhU2xpY2UsIGdldEJpZ0ludCwgZ2V0Qnl0ZXMsIGdldEJ5dGVzQ29weSwgaGV4bGlmeSwgemVyb1BhZEJ5dGVzLCB6ZXJvUGFkVmFsdWUsIGlzSGV4U3RyaW5nLCBkZWZpbmVQcm9wZXJ0aWVzLCBhc3NlcnRBcmd1bWVudCwgdG9CZUhleCwgYXNzZXJ0IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IEFiaUNvZGVyIH0gZnJvbSBcIi4vYWJpLWNvZGVyLmpzXCI7XHJcbmltcG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBSZXN1bHQgfSBmcm9tIFwiLi9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanNcIjtcclxuaW1wb3J0IHsgQ29uc3RydWN0b3JGcmFnbWVudCwgRXJyb3JGcmFnbWVudCwgRXZlbnRGcmFnbWVudCwgRnJhZ21lbnQsIEZ1bmN0aW9uRnJhZ21lbnQsIFBhcmFtVHlwZSB9IGZyb20gXCIuL2ZyYWdtZW50cy5qc1wiO1xyXG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuL3R5cGVkLmpzXCI7XHJcbmV4cG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBSZXN1bHQgfTtcclxuLyoqXHJcbiAqICBXaGVuIHVzaW5nIHRoZSBbW0ludGVyZmFjZS1wYXJzZUxvZ11dIHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2ggYSBMb2cgdG8gaXRzIGV2ZW50XHJcbiAqICBmb3IgcGFyc2luZywgYSAqKkxvZ0Rlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTG9nRGVzY3JpcHRpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGZyYWdtZW50IGZvciB0aGUgYGB0b3BpYzBgYC5cclxuICAgICAqL1xyXG4gICAgZnJhZ21lbnQ7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgRXZlbnQuXHJcbiAgICAgKi9cclxuICAgIG5hbWU7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZnVsbCBFdmVudCBzaWduYXR1cmUuXHJcbiAgICAgKi9cclxuICAgIHNpZ25hdHVyZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSB0b3BpYyBoYXNoIGZvciB0aGUgRXZlbnQuXHJcbiAgICAgKi9cclxuICAgIHRvcGljO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgRXZlbnQgd2l0aCBgYGVtaXRgYC5cclxuICAgICAqL1xyXG4gICAgYXJncztcclxuICAgIC8qKlxyXG4gICAgICogIEBfaWdub3JlOlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudCwgdG9waWMsIGFyZ3MpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlID0gZnJhZ21lbnQuZm9ybWF0KCk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XHJcbiAgICAgICAgICAgIGZyYWdtZW50LCBuYW1lLCBzaWduYXR1cmUsIHRvcGljLCBhcmdzXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBXaGVuIHVzaW5nIHRoZSBbW0ludGVyZmFjZS1wYXJzZVRyYW5zYWN0aW9uXV0gdG8gYXV0b21hdGljYWxseSBtYXRjaFxyXG4gKiAgYSB0cmFuc2FjdGlvbiBkYXRhIHRvIGl0cyBmdW5jdGlvbiBmb3IgcGFyc2luZyxcclxuICogIGEgKipUcmFuc2FjdGlvbkRlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbWF0Y2hpbmcgZnJhZ21lbnQgZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXHJcbiAgICAgKi9cclxuICAgIGZyYWdtZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIEZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxyXG4gICAgICovXHJcbiAgICBuYW1lO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIEZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxyXG4gICAgICovXHJcbiAgICBhcmdzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGZ1bGwgRnVuY3Rpb24gc2lnbmF0dXJlIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxyXG4gICAgICovXHJcbiAgICBzaWduYXR1cmU7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgc2VsZWN0b3IgZm9yIHRoZSBGdW5jdGlvbiBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cclxuICAgICAqL1xyXG4gICAgc2VsZWN0b3I7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYGB2YWx1ZWBgIChpbiB3ZWkpIGZyb20gdGhlIHRyYW5zYWN0aW9uLlxyXG4gICAgICovXHJcbiAgICB2YWx1ZTtcclxuICAgIC8qKlxyXG4gICAgICogIEBfaWdub3JlOlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudCwgc2VsZWN0b3IsIGFyZ3MsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xyXG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgYXJncywgc2lnbmF0dXJlLCBzZWxlY3RvciwgdmFsdWVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIFdoZW4gdXNpbmcgdGhlIFtbSW50ZXJmYWNlLXBhcnNlRXJyb3JdXSB0byBhdXRvbWF0aWNhbGx5IG1hdGNoIGFuXHJcbiAqICBlcnJvciBmb3IgYSBjYWxsIHJlc3VsdCBmb3IgcGFyc2luZywgYW4gKipFcnJvckRlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRXJyb3JEZXNjcmlwdGlvbiB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbWF0Y2hpbmcgZnJhZ21lbnQuXHJcbiAgICAgKi9cclxuICAgIGZyYWdtZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIEVycm9yLlxyXG4gICAgICovXHJcbiAgICBuYW1lO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIEVycm9yIHdpdGggYGByZXZlcnRgYC5cclxuICAgICAqL1xyXG4gICAgYXJncztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBmdWxsIEVycm9yIHNpZ25hdHVyZS5cclxuICAgICAqL1xyXG4gICAgc2lnbmF0dXJlO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHNlbGVjdG9yIGZvciB0aGUgRXJyb3IuXHJcbiAgICAgKi9cclxuICAgIHNlbGVjdG9yO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50LCBzZWxlY3RvciwgYXJncykge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgICAgICAgICAgZnJhZ21lbnQsIG5hbWUsIGFyZ3MsIHNpZ25hdHVyZSwgc2VsZWN0b3JcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEFuICoqSW5kZXhlZCoqIGlzIHVzZWQgYXMgYSB2YWx1ZSB3aGVuIGEgdmFsdWUgdGhhdCBkb2VzIG5vdFxyXG4gKiAgZml0IHdpdGhpbiBhIHRvcGljIChpLmUuIG5vdCBhIGZpeGVkLWxlbmd0aCwgMzItYnl0ZSB0eXBlKS4gSXRcclxuICogIGlzIHRoZSBgYGtlY2NhazI1NmBgIG9mIHRoZSB2YWx1ZSwgYW5kIHVzZWQgZm9yIHR5cGVzIHN1Y2ggYXNcclxuICogIGFycmF5cywgdHVwbGVzLCBieXRlcyBhbmQgc3RyaW5ncy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBJbmRleGVkIHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBgYGtlY2NhazI1NmBgIG9mIHRoZSB2YWx1ZSBsb2dnZWQuXHJcbiAgICAgKi9cclxuICAgIGhhc2g7XHJcbiAgICAvKipcclxuICAgICAqICBAX2lnbm9yZTpcclxuICAgICAqL1xyXG4gICAgX2lzSW5kZXhlZDtcclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgaWYgJSV2YWx1ZSUlIGlzIGFuICoqSW5kZXhlZCoqLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCBmb3IgcHJvcGVydHkgYWNjZXNzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNJbmRleGVkKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0luZGV4ZWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGhhc2gpIHtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgaGFzaCwgX2lzSW5kZXhlZDogdHJ1ZSB9KTtcclxuICAgIH1cclxufVxyXG4vLyBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi92MC44LjEzL2NvbnRyb2wtc3RydWN0dXJlcy5odG1sP2hpZ2hsaWdodD1wYW5pYyNwYW5pYy12aWEtYXNzZXJ0LWFuZC1lcnJvci12aWEtcmVxdWlyZVxyXG5jb25zdCBQYW5pY1JlYXNvbnMgPSB7XHJcbiAgICBcIjBcIjogXCJnZW5lcmljIHBhbmljXCIsXHJcbiAgICBcIjFcIjogXCJhc3NlcnQoZmFsc2UpXCIsXHJcbiAgICBcIjE3XCI6IFwiYXJpdGhtZXRpYyBvdmVyZmxvd1wiLFxyXG4gICAgXCIxOFwiOiBcImRpdmlzaW9uIG9yIG1vZHVsbyBieSB6ZXJvXCIsXHJcbiAgICBcIjMzXCI6IFwiZW51bSBvdmVyZmxvd1wiLFxyXG4gICAgXCIzNFwiOiBcImludmFsaWQgZW5jb2RlZCBzdG9yYWdlIGJ5dGUgYXJyYXkgYWNjZXNzZWRcIixcclxuICAgIFwiNDlcIjogXCJvdXQtb2YtYm91bmRzIGFycmF5IGFjY2VzczsgcG9wcGluZyBvbiBhbiBlbXB0eSBhcnJheVwiLFxyXG4gICAgXCI1MFwiOiBcIm91dC1vZi1ib3VuZHMgYWNjZXNzIG9mIGFuIGFycmF5IG9yIGJ5dGVzTlwiLFxyXG4gICAgXCI2NVwiOiBcIm91dCBvZiBtZW1vcnlcIixcclxuICAgIFwiODFcIjogXCJ1bmluaXRpYWxpemVkIGZ1bmN0aW9uXCIsXHJcbn07XHJcbmNvbnN0IEJ1aWx0aW5FcnJvcnMgPSB7XHJcbiAgICBcIjB4MDhjMzc5YTBcIjoge1xyXG4gICAgICAgIHNpZ25hdHVyZTogXCJFcnJvcihzdHJpbmcpXCIsXHJcbiAgICAgICAgbmFtZTogXCJFcnJvclwiLFxyXG4gICAgICAgIGlucHV0czogW1wic3RyaW5nXCJdLFxyXG4gICAgICAgIHJlYXNvbjogKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGByZXZlcnRlZCB3aXRoIHJlYXNvbiBzdHJpbmcgJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlKX1gO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcIjB4NGU0ODdiNzFcIjoge1xyXG4gICAgICAgIHNpZ25hdHVyZTogXCJQYW5pYyh1aW50MjU2KVwiLFxyXG4gICAgICAgIG5hbWU6IFwiUGFuaWNcIixcclxuICAgICAgICBpbnB1dHM6IFtcInVpbnQyNTZcIl0sXHJcbiAgICAgICAgcmVhc29uOiAoY29kZSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcmVhc29uID0gXCJ1bmtub3duIHBhbmljIGNvZGVcIjtcclxuICAgICAgICAgICAgaWYgKGNvZGUgPj0gMCAmJiBjb2RlIDw9IDB4ZmYgJiYgUGFuaWNSZWFzb25zW2NvZGUudG9TdHJpbmcoKV0pIHtcclxuICAgICAgICAgICAgICAgIHJlYXNvbiA9IFBhbmljUmVhc29uc1tjb2RlLnRvU3RyaW5nKCldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBgcmV2ZXJ0ZWQgd2l0aCBwYW5pYyBjb2RlIDB4JHtjb2RlLnRvU3RyaW5nKDE2KX0gKCR7cmVhc29ufSlgO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqICBBbiBJbnRlcmZhY2UgYWJzdHJhY3RzIG1hbnkgb2YgdGhlIGxvdy1sZXZlbCBkZXRhaWxzIGZvclxyXG4gKiAgZW5jb2RpbmcgYW5kIGRlY29kaW5nIHRoZSBkYXRhIG9uIHRoZSBibG9ja2NoYWluLlxyXG4gKlxyXG4gKiAgQW4gQUJJIHByb3ZpZGVzIGluZm9ybWF0aW9uIG9uIGhvdyB0byBlbmNvZGUgZGF0YSB0byBzZW5kIHRvXHJcbiAqICBhIENvbnRyYWN0LCBob3cgdG8gZGVjb2RlIHRoZSByZXN1bHRzIGFuZCBldmVudHMgYW5kIGhvdyB0b1xyXG4gKiAgaW50ZXJwcmV0IHJldmVydCBlcnJvcnMuXHJcbiAqXHJcbiAqICBUaGUgQUJJIGNhbiBiZSBzcGVjaWZpZWQgYnkgW2FueSBzdXBwb3J0ZWQgZm9ybWF0XShJbnRlcmZhY2VBYmkpLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEludGVyZmFjZSB7XHJcbiAgICAvKipcclxuICAgICAqICBBbGwgdGhlIENvbnRyYWN0IEFCSSBtZW1iZXJzIChpLmUuIG1ldGhvZHMsIGV2ZW50cywgZXJyb3JzLCBldGMpLlxyXG4gICAgICovXHJcbiAgICBmcmFnbWVudHM7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgQ29udHJhY3QgY29uc3RydWN0b3IuXHJcbiAgICAgKi9cclxuICAgIGRlcGxveTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBGYWxsYmFjayBtZXRob2QsIGlmIGFueS5cclxuICAgICAqL1xyXG4gICAgZmFsbGJhY2s7XHJcbiAgICAvKipcclxuICAgICAqICBJZiByZWNlaXZpbmcgZXRoZXIgaXMgc3VwcG9ydGVkLlxyXG4gICAgICovXHJcbiAgICByZWNlaXZlO1xyXG4gICAgI2Vycm9ycztcclxuICAgICNldmVudHM7XHJcbiAgICAjZnVuY3Rpb25zO1xyXG4gICAgLy8gICAgI3N0cnVjdHM6IE1hcDxzdHJpbmcsIFN0cnVjdEZyYWdtZW50PjtcclxuICAgICNhYmlDb2RlcjtcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZSBhIG5ldyBJbnRlcmZhY2UgZm9yIHRoZSAlJWZyYWdtZW50cyUlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMpIHtcclxuICAgICAgICBsZXQgYWJpID0gW107XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnRzKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBhYmkgPSBKU09OLnBhcnNlKGZyYWdtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhYmkgPSBmcmFnbWVudHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuI2Z1bmN0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLiNlcnJvcnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy4jZXZlbnRzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8vICAgICAgICB0aGlzLiNzdHJ1Y3RzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGNvbnN0IGZyYWdzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBhIG9mIGFiaSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZnJhZ3MucHVzaChGcmFnbWVudC5mcm9tKGEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbV2FybmluZ10gSW52YWxpZCBGcmFnbWVudCAke0pTT04uc3RyaW5naWZ5KGEpfTpgLCBlcnJvci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgICAgICAgICAgZnJhZ21lbnRzOiBPYmplY3QuZnJlZXplKGZyYWdzKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCBmYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgbGV0IHJlY2VpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLiNhYmlDb2RlciA9IHRoaXMuZ2V0QWJpQ29kZXIoKTtcclxuICAgICAgICAvLyBBZGQgYWxsIGZyYWdtZW50cyBieSB0aGVpciBzaWduYXR1cmVcclxuICAgICAgICB0aGlzLmZyYWdtZW50cy5mb3JFYWNoKChmcmFnbWVudCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgbGV0IGJ1Y2tldDtcclxuICAgICAgICAgICAgc3dpdGNoIChmcmFnbWVudC50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXBsb3kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJkdXBsaWNhdGUgZGVmaW5pdGlvbiAtIGNvbnN0cnVjdG9yXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBkZXBsb3k6IGZyYWdtZW50IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWxsYmFja1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWZhbGxiYWNrIHx8IGZyYWdtZW50LnBheWFibGUgIT09IGZhbGxiYWNrLnBheWFibGUsIFwiY29uZmxpY3RpbmcgZmFsbGJhY2sgZnJhZ21lbnRzXCIsIGBmcmFnbWVudHNbJHtpbmRleH1dYCwgZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjayA9IGZyYWdtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlID0gZmFsbGJhY2sucGF5YWJsZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcIm91dHB1dFwiLCAoPEZ1bmN0aW9uRnJhZ21lbnQ+ZnJhZ21lbnQpLm91dHB1dHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2Z1bmN0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2V2ZW50cztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2Vycm9ycztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFR3byBpZGVudGljYWwgZW50cmllczsgaWdub3JlIGl0XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xyXG4gICAgICAgICAgICBpZiAoYnVja2V0LmhhcyhzaWduYXR1cmUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnVja2V0LnNldChzaWduYXR1cmUsIGZyYWdtZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBJZiB3ZSBkbyBub3QgaGF2ZSBhIGNvbnN0cnVjdG9yIGFkZCBhIGRlZmF1bHRcclxuICAgICAgICBpZiAoIXRoaXMuZGVwbG95KSB7XHJcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xyXG4gICAgICAgICAgICAgICAgZGVwbG95OiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20oXCJjb25zdHJ1Y3RvcigpXCIpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZmFsbGJhY2ssIHJlY2VpdmUgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRoZSBlbnRpcmUgSHVtYW4tUmVhZGFibGUgQUJJLCBhcyBhbiBhcnJheSBvZlxyXG4gICAgICogIHNpZ25hdHVyZXMsIG9wdGlvbmFsbHkgYXMgJSVtaW5pbWFsJSUgc3RyaW5ncywgd2hpY2hcclxuICAgICAqICByZW1vdmVzIHBhcmFtZXRlciBuYW1lcyBhbmQgdW5uZWNlZXNhcnkgc3BhY2VzLlxyXG4gICAgICovXHJcbiAgICBmb3JtYXQobWluaW1hbCkge1xyXG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IChtaW5pbWFsID8gXCJtaW5pbWFsXCIgOiBcImZ1bGxcIik7XHJcbiAgICAgICAgY29uc3QgYWJpID0gdGhpcy5mcmFnbWVudHMubWFwKChmKSA9PiBmLmZvcm1hdChmb3JtYXQpKTtcclxuICAgICAgICByZXR1cm4gYWJpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBKU09OLWVuY29kZWQgQUJJLiBUaGlzIGlzIHRoZSBmb3JtYXQgU29saWRpeVxyXG4gICAgICogIHJldHVybnMuXHJcbiAgICAgKi9cclxuICAgIGZvcm1hdEpzb24oKSB7XHJcbiAgICAgICAgY29uc3QgYWJpID0gdGhpcy5mcmFnbWVudHMubWFwKChmKSA9PiBmLmZvcm1hdChcImpzb25cIikpO1xyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmUtYnVuZGxlIHRoZSBKU09OIGZyYWdtZW50cyBhIGJpdFxyXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhYmkubWFwKChqKSA9PiBKU09OLnBhcnNlKGopKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgQUJJIGNvZGVyIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGVuY29kZSBhbmQgZGVjb2RlIGJpbmFyeVxyXG4gICAgICogIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGdldEFiaUNvZGVyKCkge1xyXG4gICAgICAgIHJldHVybiBBYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXIoKTtcclxuICAgIH1cclxuICAgIC8vIEZpbmQgYSBmdW5jdGlvbiBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXHJcbiAgICAjZ2V0RnVuY3Rpb24oa2V5LCB2YWx1ZXMsIGZvcmNlVW5pcXVlKSB7XHJcbiAgICAgICAgLy8gU2VsZWN0b3JcclxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoa2V5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGtleS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2Z1bmN0aW9ucy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSBmcmFnbWVudC5zZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcclxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBmcmFnbWVudF0gb2YgdGhpcy4jZnVuY3Rpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zcGxpdChcIihcIiAvKiBmaXg6KSAqLylbMF0gPT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RWYWx1ZSA9ICh2YWx1ZXMubGVuZ3RoID4gMCkgPyB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIGxldCB2YWx1ZUxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBsZXQgYWxsb3dPcHRpb25zID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChUeXBlZC5pc1R5cGVkKGxhc3RWYWx1ZSkgJiYgbGFzdFZhbHVlLnR5cGUgPT09IFwib3ZlcnJpZGVzXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxvd09wdGlvbnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUxlbmd0aC0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBtYXRjaGVzIHRoYXQgZG9uJ3QgaGF2ZSBhIGNvbXBhdGlibGUgbGVuZ3RoLiBUaGUgYXJnc1xyXG4gICAgICAgICAgICAgICAgLy8gbWF5IGNvbnRhaW4gYW4gb3ZlcnJpZGVzLCBzbyB0aGUgbWF0Y2ggbWF5IGhhdmUgbiBvciBuIC0gMSBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBtYXRjaGluZ1tpXS5pbnB1dHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHMgIT09IHZhbHVlTGVuZ3RoICYmICghYWxsb3dPcHRpb25zIHx8IGlucHV0cyAhPT0gdmFsdWVMZW5ndGggLSAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBtYXRjaGVzIHRoYXQgZG9uJ3QgbWF0Y2ggdGhlIFR5cGVkIHNpZ25hdHVyZVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhIHR5cGVkIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVHlwZWQuaXNUeXBlZCh2YWx1ZXNbal0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgcGFzdCB0aGUgaW5wdXRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqID49IGlucHV0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbal0udHlwZSA9PT0gXCJvdmVycmlkZXNcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB2YWx1ZSB0eXBlIG1hdGNoZXMgdGhlIGlucHV0IHR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlICE9PSBpbnB1dHNbal0uYmFzZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgc2luZ2xlIG1hdGNoaW5nIHNpZ25hdHVyZSB3aXRoIGFuIG92ZXJyaWRlcywgYnV0IHRoZVxyXG4gICAgICAgICAgICAvLyBsYXN0IHZhbHVlIGlzIHNvbWV0aGluZyB0aGF0IGNhbm5vdCBwb3NzaWJseSBiZSBhbiBvcHRpb25zXHJcbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDEgJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGggIT09IG1hdGNoaW5nWzBdLmlucHV0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RBcmcgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RBcmcgPT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGxhc3RBcmcpIHx8IHR5cGVvZiAobGFzdEFyZykgIT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEgJiYgZm9yY2VVbmlxdWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoU3RyID0gbWF0Y2hpbmcubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtLmZvcm1hdCgpKSkuam9pbihcIiwgXCIpO1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBhbWJpZ3VvdXMgZnVuY3Rpb24gZGVzY3JpcHRpb24gKGkuZS4gbWF0Y2hlcyAke21hdGNoU3RyfSlgLCBcImtleVwiLCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNmdW5jdGlvbnMuZ2V0KEZ1bmN0aW9uRnJhZ21lbnQuZnJvbShrZXkpLmZvcm1hdCgpKTtcclxuICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgR2V0IHRoZSBmdW5jdGlvbiBuYW1lIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSBmdW5jdGlvbiBzZWxlY3RvcixcclxuICAgICAqICBmdW5jdGlvbiBuYW1lIG9yIGZ1bmN0aW9uIHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cclxuICAgICAqL1xyXG4gICAgZ2V0RnVuY3Rpb25OYW1lKGtleSkge1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCBudWxsLCBmYWxzZSk7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnVuY3Rpb25cIiwgXCJrZXlcIiwga2V5KTtcclxuICAgICAgICByZXR1cm4gZnJhZ21lbnQubmFtZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJWtleSUlIChhIGZ1bmN0aW9uIHNlbGVjdG9yLCBmdW5jdGlvbiBuYW1lIG9yXHJcbiAgICAgKiAgZnVuY3Rpb24gc2lnbmF0dXJlKSBpcyBwcmVzZW50IGluIHRoZSBBQkkuXHJcbiAgICAgKlxyXG4gICAgICogIEluIHRoZSBjYXNlIG9mIGEgZnVuY3Rpb24gbmFtZSwgdGhlIG5hbWUgbWF5IGJlIGFtYmlndW91cywgc29cclxuICAgICAqICBhY2Nlc3NpbmcgdGhlIFtbRnVuY3Rpb25GcmFnbWVudF1dIG1heSByZXF1aXJlIHJlZmluZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGhhc0Z1bmN0aW9uKGtleSkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuI2dldEZ1bmN0aW9uKGtleSwgbnVsbCwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgR2V0IHRoZSBbW0Z1bmN0aW9uRnJhZ21lbnRdXSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgZnVuY3Rpb25cclxuICAgICAqICBzZWxlY3RvciwgZnVuY3Rpb24gbmFtZSBvciBmdW5jdGlvbiBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXHJcbiAgICAgKlxyXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXHJcbiAgICAgKiAgYW1iaWd1b3VzIGNhc2VzIHdoZXJlIG11bHRpcGxlIGZ1bmN0aW9ucyBtYXRjaCBieSBuYW1lLlxyXG4gICAgICpcclxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGZ1bmN0aW9uIGluXHJcbiAgICAgKiAgdGhlIEFCSSwgdGhpcyB3aWxsIHRocm93LlxyXG4gICAgICovXHJcbiAgICBnZXRGdW5jdGlvbihrZXksIHZhbHVlcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNnZXRGdW5jdGlvbihrZXksIHZhbHVlcyB8fCBudWxsLCB0cnVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEl0ZXJhdGUgb3ZlciBhbGwgZnVuY3Rpb25zLCBjYWxsaW5nICUlY2FsbGJhY2slJSwgc29ydGVkIGJ5IHRoZWlyIG5hbWUuXHJcbiAgICAgKi9cclxuICAgIGZvckVhY2hGdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IG5hbWVzID0gQXJyYXkuZnJvbSh0aGlzLiNmdW5jdGlvbnMua2V5cygpKTtcclxuICAgICAgICBuYW1lcy5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2ldO1xyXG4gICAgICAgICAgICBjYWxsYmFjaygodGhpcy4jZnVuY3Rpb25zLmdldChuYW1lKSksIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIEZpbmQgYW4gZXZlbnQgZGVmaW5pdGlvbiBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh1bmxlc3MgaXQgaXMgYW1iaWd1b3VzKVxyXG4gICAgI2dldEV2ZW50KGtleSwgdmFsdWVzLCBmb3JjZVVuaXF1ZSkge1xyXG4gICAgICAgIC8vIEV2ZW50VG9waWNcclxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoa2V5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBldmVudFRvcGljID0ga2V5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgdGhpcy4jZXZlbnRzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRUb3BpYyA9PT0gZnJhZ21lbnQudG9waWNIYXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxyXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGZyYWdtZW50XSBvZiB0aGlzLiNldmVudHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcucHVzaChmcmFnbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBtYXRjaGVzIHRoYXQgZG9uJ3QgaGF2ZSBhIGNvbXBhdGlibGUgbGVuZ3RoLlxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nW2ldLmlucHV0cy5sZW5ndGggPCB2YWx1ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBtYXRjaCB0aGUgVHlwZWQgc2lnbmF0dXJlXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBtYXRjaGluZ1tpXS5pbnB1dHM7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdHlwZWQgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFUeXBlZC5pc1R5cGVkKHZhbHVlc1tqXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdmFsdWUgdHlwZSBtYXRjaGVzIHRoZSBpbnB1dCB0eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbal0udHlwZSAhPT0gaW5wdXRzW2pdLmJhc2VUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSAmJiBmb3JjZVVuaXF1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hTdHIgPSBtYXRjaGluZy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0uZm9ybWF0KCkpKS5qb2luKFwiLCBcIik7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGFtYmlndW91cyBldmVudCBkZXNjcmlwdGlvbiAoaS5lLiBtYXRjaGVzICR7bWF0Y2hTdHJ9KWAsIFwia2V5XCIsIGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2V2ZW50cy5nZXQoRXZlbnRGcmFnbWVudC5mcm9tKGtleSkuZm9ybWF0KCkpO1xyXG4gICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBHZXQgdGhlIGV2ZW50IG5hbWUgZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhIHRvcGljIGhhc2gsXHJcbiAgICAgKiAgZXZlbnQgbmFtZSBvciBldmVudCBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXHJcbiAgICAgKi9cclxuICAgIGdldEV2ZW50TmFtZShrZXkpIHtcclxuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuI2dldEV2ZW50KGtleSwgbnVsbCwgZmFsc2UpO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGV2ZW50XCIsIFwia2V5XCIsIGtleSk7XHJcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50Lm5hbWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVrZXklJSAoYW4gZXZlbnQgdG9waWMgaGFzaCwgZXZlbnQgbmFtZSBvclxyXG4gICAgICogIGV2ZW50IHNpZ25hdHVyZSkgaXMgcHJlc2VudCBpbiB0aGUgQUJJLlxyXG4gICAgICpcclxuICAgICAqICBJbiB0aGUgY2FzZSBvZiBhbiBldmVudCBuYW1lLCB0aGUgbmFtZSBtYXkgYmUgYW1iaWd1b3VzLCBzb1xyXG4gICAgICogIGFjY2Vzc2luZyB0aGUgW1tFdmVudEZyYWdtZW50XV0gbWF5IHJlcXVpcmUgcmVmaW5lbWVudC5cclxuICAgICAqL1xyXG4gICAgaGFzRXZlbnQoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy4jZ2V0RXZlbnQoa2V5LCBudWxsLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBHZXQgdGhlIFtbRXZlbnRGcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSB0b3BpYyBoYXNoLFxyXG4gICAgICogIGV2ZW50IG5hbWUgb3IgZXZlbnQgc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxyXG4gICAgICpcclxuICAgICAqICBJZiAlJXZhbHVlcyUlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHVzZSB0aGUgVHlwZWQgQVBJIHRvIGhhbmRsZVxyXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBldmVudHMgbWF0Y2ggYnkgbmFtZS5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgdGhlICUla2V5JSUgYW5kICUldmFsdWVzJSUgZG8gbm90IHJlZmluZSB0byBhIHNpbmdsZSBldmVudCBpblxyXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cclxuICAgICAqL1xyXG4gICAgZ2V0RXZlbnQoa2V5LCB2YWx1ZXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0RXZlbnQoa2V5LCB2YWx1ZXMgfHwgbnVsbCwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGV2ZW50cywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxyXG4gICAgICovXHJcbiAgICBmb3JFYWNoRXZlbnQoY2FsbGJhY2spIHtcclxuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZXZlbnRzLmtleXMoKSk7XHJcbiAgICAgICAgbmFtZXMuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcclxuICAgICAgICAgICAgY2FsbGJhY2soKHRoaXMuI2V2ZW50cy5nZXQobmFtZSkpLCBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBHZXQgdGhlIFtbRXJyb3JGcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYW4gZXJyb3JcclxuICAgICAqICBzZWxlY3RvciwgZXJyb3IgbmFtZSBvciBlcnJvciBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXHJcbiAgICAgKlxyXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXHJcbiAgICAgKiAgYW1iaWd1b3VzIGNhc2VzIHdoZXJlIG11bHRpcGxlIGVycm9ycyBtYXRjaCBieSBuYW1lLlxyXG4gICAgICpcclxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGVycm9yIGluXHJcbiAgICAgKiAgdGhlIEFCSSwgdGhpcyB3aWxsIHRocm93LlxyXG4gICAgICovXHJcbiAgICBnZXRFcnJvcihrZXksIHZhbHVlcykge1xyXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhrZXkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0ga2V5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIGlmIChCdWlsdGluRXJyb3JzW3NlbGVjdG9yXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShCdWlsdGluRXJyb3JzW3NlbGVjdG9yXS5zaWduYXR1cmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgdGhpcy4jZXJyb3JzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09IGZyYWdtZW50LnNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxyXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGZyYWdtZW50XSBvZiB0aGlzLiNlcnJvcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcucHVzaChmcmFnbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJFcnJvclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShcImVycm9yIEVycm9yKHN0cmluZylcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcIlBhbmljXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgUGFuaWModWludDI1NilcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaFN0ciA9IG1hdGNoaW5nLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobS5mb3JtYXQoKSkpLmpvaW4oXCIsIFwiKTtcclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgYW1iaWd1b3VzIGVycm9yIGRlc2NyaXB0aW9uIChpLmUuICR7bWF0Y2hTdHJ9KWAsIFwibmFtZVwiLCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cclxuICAgICAgICBrZXkgPSBFcnJvckZyYWdtZW50LmZyb20oa2V5KS5mb3JtYXQoKTtcclxuICAgICAgICBpZiAoa2V5ID09PSBcIkVycm9yKHN0cmluZylcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgRXJyb3Ioc3RyaW5nKVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtleSA9PT0gXCJQYW5pYyh1aW50MjU2KVwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBQYW5pYyh1aW50MjU2KVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZXJyb3JzLmdldChrZXkpO1xyXG4gICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGVycm9ycywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxyXG4gICAgICovXHJcbiAgICBmb3JFYWNoRXJyb3IoY2FsbGJhY2spIHtcclxuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZXJyb3JzLmtleXMoKSk7XHJcbiAgICAgICAgbmFtZXMuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcclxuICAgICAgICAgICAgY2FsbGJhY2soKHRoaXMuI2Vycm9ycy5nZXQobmFtZSkpLCBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBHZXQgdGhlIDQtYnl0ZSBzZWxlY3RvciB1c2VkIGJ5IFNvbGlkaXR5IHRvIGlkZW50aWZ5IGEgZnVuY3Rpb25cclxuICAgIC8qXHJcbmdldFNlbGVjdG9yKGZyYWdtZW50OiBFcnJvckZyYWdtZW50IHwgRnVuY3Rpb25GcmFnbWVudCk6IHN0cmluZyB7XHJcbiAgICBpZiAodHlwZW9mKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoZXM6IEFycmF5PEZyYWdtZW50PiA9IFsgXTtcclxuXHJcbiAgICAgICAgdHJ5IHsgbWF0Y2hlcy5wdXNoKHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpKTsgfSBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgICAgIHRyeSB7IG1hdGNoZXMucHVzaCh0aGlzLmdldEVycm9yKDxzdHJpbmc+ZnJhZ21lbnQpKTsgfSBjYXRjaCAoXykgeyB9XHJcblxyXG4gICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5rbm93biBmcmFnbWVudFwiLCBcImtleVwiLCBmcmFnbWVudCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFtYmlndW91cyBmcmFnbWVudCBtYXRjaGVzIGZ1bmN0aW9uIGFuZCBlcnJvclwiLCBcImtleVwiLCBmcmFnbWVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmcmFnbWVudCA9IG1hdGNoZXNbMF07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRhdGFTbGljZShpZChmcmFnbWVudC5mb3JtYXQoKSksIDAsIDQpO1xyXG59XHJcbiAgICAqL1xyXG4gICAgLy8gR2V0IHRoZSAzMi1ieXRlIHRvcGljIGhhc2ggdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhbiBldmVudFxyXG4gICAgLypcclxuICAgIGdldEV2ZW50VG9waWMoZnJhZ21lbnQ6IEV2ZW50RnJhZ21lbnQpOiBzdHJpbmcge1xyXG4gICAgICAgIC8vaWYgKHR5cGVvZihmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHsgZnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpOyB9XHJcbiAgICAgICAgcmV0dXJuIGlkKGZyYWdtZW50LmZvcm1hdCgpKTtcclxuICAgIH1cclxuICAgICovXHJcbiAgICBfZGVjb2RlUGFyYW1zKHBhcmFtcywgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5kZWNvZGUocGFyYW1zLCBkYXRhKTtcclxuICAgIH1cclxuICAgIF9lbmNvZGVQYXJhbXMocGFyYW1zLCB2YWx1ZXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4jYWJpQ29kZXIuZW5jb2RlKHBhcmFtcywgdmFsdWVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEVuY29kZXMgYSBgYHR4LmRhdGFgYCBvYmplY3QgZm9yIGRlcGxveWluZyB0aGUgQ29udHJhY3Qgd2l0aFxyXG4gICAgICogIHRoZSAlJXZhbHVlcyUlIGFzIHRoZSBjb25zdHJ1Y3RvciBhcmd1bWVudHMuXHJcbiAgICAgKi9cclxuICAgIGVuY29kZURlcGxveSh2YWx1ZXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlUGFyYW1zKHRoaXMuZGVwbG95LmlucHV0cywgdmFsdWVzIHx8IFtdKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIERlY29kZXMgdGhlIHJlc3VsdCAlJWRhdGElJSAoZS5nLiBmcm9tIGFuIGBgZXRoX2NhbGxgYCkgZm9yIHRoZVxyXG4gICAgICogIHNwZWNpZmllZCBlcnJvciAoc2VlIFtbZ2V0RXJyb3JdXSBmb3IgdmFsaWQgdmFsdWVzIGZvclxyXG4gICAgICogICUla2V5JSUpLlxyXG4gICAgICpcclxuICAgICAqICBNb3N0IGRldmVsb3BlcnMgc2hvdWxkIHByZWZlciB0aGUgW1twYXJzZUNhbGxSZXN1bHRdXSBtZXRob2QgaW5zdGVhZCxcclxuICAgICAqICB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IGEgYGBDQUxMX0VYQ0VQVElPTmBgIGFuZCB0aHJvdyB0aGVcclxuICAgICAqICBjb3JyZXNwb25kaW5nIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBkZWNvZGVFcnJvclJlc3VsdChmcmFnbWVudCwgZGF0YSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFcnJvcihmcmFnbWVudCk7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBlcnJvclwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcclxuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhU2xpY2UoZGF0YSwgMCwgNCkgPT09IGZyYWdtZW50LnNlbGVjdG9yLCBgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZXJyb3IgJHtmcmFnbWVudC5uYW1lfS5gLCBcImRhdGFcIiwgZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIGRhdGFTbGljZShkYXRhLCA0KSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBFbmNvZGVzIHRoZSB0cmFuc2FjdGlvbiByZXZlcnQgZGF0YSBmb3IgYSBjYWxsIHJlc3VsdCB0aGF0XHJcbiAgICAgKiAgcmV2ZXJ0ZWQgZnJvbSB0aGUgdGhlIENvbnRyYWN0IHdpdGggdGhlIHNlcGNpZmllZCAlJWVycm9yJSVcclxuICAgICAqICAoc2VlIFtbZ2V0RXJyb3JdXSBmb3IgdmFsaWQgdmFsdWVzIGZvciAlJWZyYWdtZW50JSUpIHdpdGggdGhlICUldmFsdWVzJSUuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VkIGJ5IG1vc3QgZGV2ZWxvcGVycywgdW5sZXNzIHRyeWluZyB0byBtb2NrXHJcbiAgICAgKiAgYSByZXN1bHQgZnJvbSBhIENvbnRyYWN0LlxyXG4gICAgICovXHJcbiAgICBlbmNvZGVFcnJvclJlc3VsdChmcmFnbWVudCwgdmFsdWVzKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGVycm9yXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb25jYXQoW1xyXG4gICAgICAgICAgICBmcmFnbWVudC5zZWxlY3RvcixcclxuICAgICAgICAgICAgdGhpcy5fZW5jb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgdmFsdWVzIHx8IFtdKVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgRGVjb2RlcyB0aGUgJSVkYXRhJSUgZnJvbSBhIHRyYW5zYWN0aW9uIGBgdHguZGF0YWBgIGZvclxyXG4gICAgICogIHRoZSBmdW5jdGlvbiBzcGVjaWZpZWQgKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlc1xyXG4gICAgICogIGZvciAlJWZyYWdtZW50JSUpLlxyXG4gICAgICpcclxuICAgICAqICBNb3N0IGRldmVsb3BlcnMgc2hvdWxkIHByZWZlciB0aGUgW1twYXJzZVRyYW5zYWN0aW9uXV0gbWV0aG9kXHJcbiAgICAgKiAgaW5zdGVhZCwgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVjdCB0aGUgZnJhZ21lbnQuXHJcbiAgICAgKi9cclxuICAgIGRlY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgZGF0YSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRGdW5jdGlvbihmcmFnbWVudCk7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcclxuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhU2xpY2UoZGF0YSwgMCwgNCkgPT09IGZyYWdtZW50LnNlbGVjdG9yLCBgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZnVuY3Rpb24gJHtmcmFnbWVudC5uYW1lfS5gLCBcImRhdGFcIiwgZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIGRhdGFTbGljZShkYXRhLCA0KSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBFbmNvZGVzIHRoZSBgYHR4LmRhdGFgYCBmb3IgYSB0cmFuc2FjdGlvbiB0aGF0IGNhbGxzIHRoZSBmdW5jdGlvblxyXG4gICAgICogIHNwZWNpZmllZCAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzIGZvciAlJWZyYWdtZW50JSUpIHdpdGhcclxuICAgICAqICB0aGUgJSV2YWx1ZXMlJS5cclxuICAgICAqL1xyXG4gICAgZW5jb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCB2YWx1ZXMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZnVuY3Rpb25cIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XHJcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbXHJcbiAgICAgICAgICAgIGZyYWdtZW50LnNlbGVjdG9yLFxyXG4gICAgICAgICAgICB0aGlzLl9lbmNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCB2YWx1ZXMgfHwgW10pXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBEZWNvZGVzIHRoZSByZXN1bHQgJSVkYXRhJSUgKGUuZy4gZnJvbSBhbiBgYGV0aF9jYWxsYGApIGZvciB0aGVcclxuICAgICAqICBzcGVjaWZpZWQgZnVuY3Rpb24gKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3JcclxuICAgICAqICAlJWtleSUlKS5cclxuICAgICAqXHJcbiAgICAgKiAgTW9zdCBkZXZlbG9wZXJzIHNob3VsZCBwcmVmZXIgdGhlIFtbcGFyc2VDYWxsUmVzdWx0XV0gbWV0aG9kIGluc3RlYWQsXHJcbiAgICAgKiAgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVjdCBhIGBgQ0FMTF9FWENFUFRJT05gYCBhbmQgdGhyb3cgdGhlXHJcbiAgICAgKiAgY29ycmVzcG9uZGluZyBlcnJvci5cclxuICAgICAqL1xyXG4gICAgZGVjb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIGRhdGEpIHtcclxuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZnVuY3Rpb25cIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XHJcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBcImludmFsaWQgbGVuZ3RoIGZvciByZXN1bHQgZGF0YVwiO1xyXG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXNDb3B5KGRhdGEpO1xyXG4gICAgICAgIGlmICgoYnl0ZXMubGVuZ3RoICUgMzIpID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50Lm91dHB1dHMsIGJ5dGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcImNvdWxkIG5vdCBkZWNvZGUgcmVzdWx0IGRhdGFcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDYWxsIHJldHVybmVkIGRhdGEgd2l0aCBubyBlcnJvciwgYnV0IHRoZSBkYXRhIGlzIGp1bmtcclxuICAgICAgICBhc3NlcnQoZmFsc2UsIG1lc3NhZ2UsIFwiQkFEX0RBVEFcIiwge1xyXG4gICAgICAgICAgICB2YWx1ZTogaGV4bGlmeShieXRlcyksXHJcbiAgICAgICAgICAgIGluZm86IHsgbWV0aG9kOiBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmU6IGZyYWdtZW50LmZvcm1hdCgpIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG1ha2VFcnJvcihfZGF0YSwgdHgpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcclxuICAgICAgICBjb25zdCBlcnJvciA9IEFiaUNvZGVyLmdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKFwiY2FsbFwiLCB0eCwgZGF0YSk7XHJcbiAgICAgICAgLy8gTm90IGEgYnVpbHQtaW4gZXJyb3I7IHRyeSBmaW5kaW5nIGEgY3VzdG9tIGVycm9yXHJcbiAgICAgICAgY29uc3QgY3VzdG9tUHJlZml4ID0gXCJleGVjdXRpb24gcmV2ZXJ0ZWQgKHVua25vd24gY3VzdG9tIGVycm9yKVwiO1xyXG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoY3VzdG9tUHJlZml4KSkge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGhleGxpZnkoZGF0YS5zbGljZSgwLCA0KSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVmID0gdGhpcy5nZXRFcnJvcihzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIGlmIChlZikge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGVmLmlucHV0cywgZGF0YS5zbGljZSg0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucmV2ZXJ0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBlZi5uYW1lLCBzaWduYXR1cmU6IGVmLmZvcm1hdCgpLCBhcmdzXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvci5yZWFzb24gPSBlcnJvci5yZXZlcnQuc2lnbmF0dXJlO1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgZXhlY3V0aW9uIHJldmVydGVkOiAke2Vycm9yLnJlYXNvbn1gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gYGV4ZWN1dGlvbiByZXZlcnRlZCAoY291bHQgbm90IGRlY29kZSBjdXN0b20gZXJyb3IpYDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgdGhlIGludm9jYXRpb24sIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucGFyc2VUcmFuc2FjdGlvbih0eCk7XHJcbiAgICAgICAgaWYgKHBhcnNlZCkge1xyXG4gICAgICAgICAgICBlcnJvci5pbnZvY2F0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBwYXJzZWQubmFtZSxcclxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogcGFyc2VkLnNpZ25hdHVyZSxcclxuICAgICAgICAgICAgICAgIGFyZ3M6IHBhcnNlZC5hcmdzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEVuY29kZXMgdGhlIHJlc3VsdCBkYXRhIChlLmcuIGZyb20gYW4gYGBldGhfY2FsbGBgKSBmb3IgdGhlXHJcbiAgICAgKiAgc3BlY2lmaWVkIGZ1bmN0aW9uIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXNcclxuICAgICAqICBmb3IgJSVmcmFnbWVudCUlKSB3aXRoICUldmFsdWVzJSUuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VkIGJ5IG1vc3QgZGV2ZWxvcGVycywgdW5sZXNzIHRyeWluZyB0byBtb2NrXHJcbiAgICAgKiAgYSByZXN1bHQgZnJvbSBhIENvbnRyYWN0LlxyXG4gICAgICovXHJcbiAgICBlbmNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgdmFsdWVzKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHRoaXMuI2FiaUNvZGVyLmVuY29kZShmcmFnbWVudC5vdXRwdXRzLCB2YWx1ZXMgfHwgW10pKTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgICAgc3BlbHVuayhpbnB1dHM6IEFycmF5PFBhcmFtVHlwZT4sIHZhbHVlczogUmVhZG9ubHlBcnJheTxhbnk+LCBwcm9jZXNzZnVuYzogKHR5cGU6IHN0cmluZywgdmFsdWU6IGFueSkgPT4gUHJvbWlzZTxhbnk+KTogUHJvbWlzZTxBcnJheTxhbnk+PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzOiBBcnJheTxQcm9taXNlPD4+ID0gWyBdO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzID0gZnVuY3Rpb24odHlwZTogUGFyYW1UeXBlLCB2YWx1ZTogYW55KTogYW55IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzY2VuZCh0eXBlLmNoaWxkXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZS4gPT09IFwiYWRkcmVzc1wiKSB7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICBcclxuICAgICAgICAgICAgY29uc3QgZGVzY2VuZCA9IGZ1bmN0aW9uIChpbnB1dHM6IEFycmF5PFBhcmFtVHlwZT4sIHZhbHVlczogUmVhZG9ubHlBcnJheTxhbnk+KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggbWlzbWF0Y2hcIik7IH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8YW55PiA9IFsgXTtcclxuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChudWxsKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZpbHRlcmluZyB3aXRoIHR1cGxlcyBvciBhcnJheXMgbm90IHN1cHBvcnRlZFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2godmFsdWUubWFwKCh2YWx1ZSkgPT4gZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgKi9cclxuICAgIC8vIENyZWF0ZSB0aGUgZmlsdGVyIGZvciB0aGUgZXZlbnQgd2l0aCBzZWFyY2ggY3JpdGVyaWEgKGUuZy4gZm9yIGV0aF9maWx0ZXJMb2cpXHJcbiAgICBlbmNvZGVGaWx0ZXJUb3BpY3MoZnJhZ21lbnQsIHZhbHVlcykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBldmVudFwiLCBcImV2ZW50RnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydCh2YWx1ZXMubGVuZ3RoIDw9IGZyYWdtZW50LmlucHV0cy5sZW5ndGgsIGB0b28gbWFueSBhcmd1bWVudHMgZm9yICR7ZnJhZ21lbnQuZm9ybWF0KCl9YCwgXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCIsIHsgY291bnQ6IHZhbHVlcy5sZW5ndGgsIGV4cGVjdGVkQ291bnQ6IGZyYWdtZW50LmlucHV0cy5sZW5ndGggfSk7XHJcbiAgICAgICAgY29uc3QgdG9waWNzID0gW107XHJcbiAgICAgICAgaWYgKCFmcmFnbWVudC5hbm9ueW1vdXMpIHtcclxuICAgICAgICAgICAgdG9waWNzLnB1c2goZnJhZ21lbnQudG9waWNIYXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQFRPRE86IFVzZSB0aGUgY29kZXJzIGZvciB0aGlzOyB0byBwcm9wZXJseSBzdXBwb3J0IHR1cGxlcywgZXRjLlxyXG4gICAgICAgIGNvbnN0IGVuY29kZVRvcGljID0gKHBhcmFtLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYoaGV4bGlmeSh2YWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcImJvb2xcIiAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlID8gXCIweDAxXCIgOiBcIjB4MDBcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZS5tYXRjaCgvXnU/aW50LykpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9CZUhleCh2YWx1ZSk7IC8vIEBUT0RPOiBTaG91bGQgdGhpcyB0b1R3b3M/P1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUubWF0Y2goL15ieXRlcy8pKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHplcm9QYWRCeXRlcyh2YWx1ZSwgMzIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBhZGRyZXNzZXMgYXJlIHZhbGlkXHJcbiAgICAgICAgICAgICAgICB0aGlzLiNhYmlDb2Rlci5lbmNvZGUoW1wiYWRkcmVzc1wiXSwgW3ZhbHVlXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHplcm9QYWRWYWx1ZShoZXhsaWZ5KHZhbHVlKSwgMzIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IGZyYWdtZW50LmlucHV0c1tpbmRleF07XHJcbiAgICAgICAgICAgIGlmICghcGFyYW0uaW5kZXhlZCkge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPT0gbnVsbCwgXCJjYW5ub3QgZmlsdGVyIG5vbi1pbmRleGVkIHBhcmFtZXRlcnM7IG11c3QgYmUgbnVsbFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIikge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiZmlsdGVyaW5nIHdpdGggdHVwbGVzIG9yIGFycmF5cyBub3Qgc3VwcG9ydGVkXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2godmFsdWUubWFwKCh2YWx1ZSkgPT4gZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBUcmltIG9mZiB0cmFpbGluZyBudWxsc1xyXG4gICAgICAgIHdoaWxlICh0b3BpY3MubGVuZ3RoICYmIHRvcGljc1t0b3BpY3MubGVuZ3RoIC0gMV0gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdG9waWNzLnBvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG9waWNzO1xyXG4gICAgfVxyXG4gICAgZW5jb2RlRXZlbnRMb2coZnJhZ21lbnQsIHZhbHVlcykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBldmVudFwiLCBcImV2ZW50RnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRvcGljcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGRhdGFUeXBlcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGRhdGFWYWx1ZXMgPSBbXTtcclxuICAgICAgICBpZiAoIWZyYWdtZW50LmFub255bW91cykge1xyXG4gICAgICAgICAgICB0b3BpY3MucHVzaChmcmFnbWVudC50b3BpY0hhc2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZXMubGVuZ3RoID09PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBcImV2ZW50IGFyZ3VtZW50cy92YWx1ZXMgbWlzbWF0Y2hcIiwgXCJ2YWx1ZXNcIiwgdmFsdWVzKTtcclxuICAgICAgICBmcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2luZGV4XTtcclxuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goaWQodmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKGtlY2NhazI1Nih2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE9cclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh0aGlzLiNhYmlDb2Rlci5lbmNvZGUoW3BhcmFtLnR5cGVdLCBbdmFsdWVdKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXMucHVzaChwYXJhbSk7XHJcbiAgICAgICAgICAgICAgICBkYXRhVmFsdWVzLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YTogdGhpcy4jYWJpQ29kZXIuZW5jb2RlKGRhdGFUeXBlcywgZGF0YVZhbHVlcyksXHJcbiAgICAgICAgICAgIHRvcGljczogdG9waWNzXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIERlY29kZSBhIGZpbHRlciBmb3IgdGhlIGV2ZW50IGFuZCB0aGUgc2VhcmNoIGNyaXRlcmlhXHJcbiAgICBkZWNvZGVFdmVudExvZyhmcmFnbWVudCwgZGF0YSwgdG9waWNzKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEV2ZW50KGZyYWdtZW50KTtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGV2ZW50XCIsIFwiZXZlbnRGcmFnbWVudFwiLCBmcmFnbWVudCk7XHJcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRvcGljcyAhPSBudWxsICYmICFmcmFnbWVudC5hbm9ueW1vdXMpIHtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnRUb3BpYyA9IGZyYWdtZW50LnRvcGljSGFzaDtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodG9waWNzWzBdLCAzMikgJiYgdG9waWNzWzBdLnRvTG93ZXJDYXNlKCkgPT09IGV2ZW50VG9waWMsIFwiZnJhZ21lbnQvdG9waWMgbWlzbWF0Y2hcIiwgXCJ0b3BpY3NbMF1cIiwgdG9waWNzWzBdKTtcclxuICAgICAgICAgICAgdG9waWNzID0gdG9waWNzLnNsaWNlKDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbmRleGVkID0gW107XHJcbiAgICAgICAgY29uc3Qgbm9uSW5kZXhlZCA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGR5bmFtaWMgPSBbXTtcclxuICAgICAgICBmcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBwYXJhbS50eXBlID09PSBcImJ5dGVzXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKFBhcmFtVHlwZS5mcm9tKHsgdHlwZTogXCJieXRlczMyXCIsIG5hbWU6IHBhcmFtLm5hbWUgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChwYXJhbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vbkluZGV4ZWQucHVzaChwYXJhbSk7XHJcbiAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2goZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0SW5kZXhlZCA9ICh0b3BpY3MgIT0gbnVsbCkgPyB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoaW5kZXhlZCwgY29uY2F0KHRvcGljcykpIDogbnVsbDtcclxuICAgICAgICBjb25zdCByZXN1bHROb25JbmRleGVkID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKG5vbkluZGV4ZWQsIGRhdGEsIHRydWUpO1xyXG4gICAgICAgIC8vY29uc3QgcmVzdWx0OiAoQXJyYXk8YW55PiAmIHsgWyBrZXk6IHN0cmluZyBdOiBhbnkgfSkgPSBbIF07XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xyXG4gICAgICAgIGxldCBub25JbmRleGVkSW5kZXggPSAwLCBpbmRleGVkSW5kZXggPSAwO1xyXG4gICAgICAgIGZyYWdtZW50LmlucHV0cy5mb3JFYWNoKChwYXJhbSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRJbmRleGVkID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBJbmRleGVkKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZHluYW1pY1tpbmRleF0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBJbmRleGVkKHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0SW5kZXhlZFtpbmRleGVkSW5kZXgrK107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHROb25JbmRleGVkW25vbkluZGV4ZWRJbmRleCsrXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICBrZXlzLnB1c2gocGFyYW0ubmFtZSB8fCBudWxsKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gUmVzdWx0LmZyb21JdGVtcyh2YWx1ZXMsIGtleXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUGFyc2VzIGEgdHJhbnNhY3Rpb24sIGZpbmRpbmcgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIGFuZCBleHRyYWN0c1xyXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGZ1bmN0aW9uIGRldGFpbHMuXHJcbiAgICAgKlxyXG4gICAgICogIElmIHRoZSBtYXRjaGluZyBmdW5jdGlvbiBjYW5ub3QgYmUgZm91bmQsIHJldHVybiBudWxsLlxyXG4gICAgICovXHJcbiAgICBwYXJzZVRyYW5zYWN0aW9uKHR4KSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKHR4LmRhdGEsIFwidHguZGF0YVwiKTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldEJpZ0ludCgodHgudmFsdWUgIT0gbnVsbCkgPyB0eC52YWx1ZSA6IDAsIFwidHgudmFsdWVcIik7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGhleGxpZnkoZGF0YS5zbGljZSgwLCA0KSkpO1xyXG4gICAgICAgIGlmICghZnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQuaW5wdXRzLCBkYXRhLnNsaWNlKDQpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uRGVzY3JpcHRpb24oZnJhZ21lbnQsIGZyYWdtZW50LnNlbGVjdG9yLCBhcmdzLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBwYXJzZUNhbGxSZXN1bHQoZGF0YSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUGFyc2VzIGEgcmVjZWlwdCBsb2csIGZpbmRpbmcgdGhlIG1hdGNoaW5nIGV2ZW50IGFuZCBleHRyYWN0c1xyXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGV2ZW50IGRldGFpbHMuXHJcbiAgICAgKlxyXG4gICAgICogIElmIHRoZSBtYXRjaGluZyBldmVudCBjYW5ub3QgYmUgZm91bmQsIHJldHVybnMgbnVsbC5cclxuICAgICAqL1xyXG4gICAgcGFyc2VMb2cobG9nKSB7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGxvZy50b3BpY3NbMF0pO1xyXG4gICAgICAgIGlmICghZnJhZ21lbnQgfHwgZnJhZ21lbnQuYW5vbnltb3VzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBAVE9ETzogSWYgYW5vbnltb3VzLCBhbmQgdGhlIG9ubHkgbWV0aG9kLCBhbmQgdGhlIGlucHV0IGNvdW50IG1hdGNoZXMsIHNob3VsZCB3ZSBwYXJzZT9cclxuICAgICAgICAvLyAgICAgICAgUHJvYmFibHkgbm90LCBiZWNhdXNlIGp1c3QgYmVjYXVzZSBpdCBpcyB0aGUgb25seSBldmVudCBpbiB0aGUgQUJJIGRvZXNcclxuICAgICAgICAvLyAgICAgICAgbm90IG1lYW4gd2UgaGF2ZSB0aGUgZnVsbCBBQkk7IG1heWJlIGp1c3QgYSBmcmFnbWVudD9cclxuICAgICAgICByZXR1cm4gbmV3IExvZ0Rlc2NyaXB0aW9uKGZyYWdtZW50LCBmcmFnbWVudC50b3BpY0hhc2gsIHRoaXMuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGxvZy5kYXRhLCBsb2cudG9waWNzKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBQYXJzZXMgYSByZXZlcnQgZGF0YSwgZmluZGluZyB0aGUgbWF0Y2hpbmcgZXJyb3IgYW5kIGV4dHJhY3RzXHJcbiAgICAgKiAgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYWxvbmcgd2l0aCBvdGhlciB1c2VmdWwgZXJyb3IgZGV0YWlscy5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgdGhlIG1hdGNoaW5nIGVycm9yIGNhbm5vdCBiZSBmb3VuZCwgcmV0dXJucyBudWxsLlxyXG4gICAgICovXHJcbiAgICBwYXJzZUVycm9yKGRhdGEpIHtcclxuICAgICAgICBjb25zdCBoZXhEYXRhID0gaGV4bGlmeShkYXRhKTtcclxuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuZ2V0RXJyb3IoZGF0YVNsaWNlKGhleERhdGEsIDAsIDQpKTtcclxuICAgICAgICBpZiAoIWZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50LmlucHV0cywgZGF0YVNsaWNlKGhleERhdGEsIDQpKTtcclxuICAgICAgICByZXR1cm4gbmV3IEVycm9yRGVzY3JpcHRpb24oZnJhZ21lbnQsIGZyYWdtZW50LnNlbGVjdG9yLCBhcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tJbnRlcmZhY2VdXSBmcm9tIHRoZSBBQkkgJSV2YWx1ZSUlLlxyXG4gICAgICpcclxuICAgICAqICBUaGUgJSV2YWx1ZSUlIG1heSBiZSBwcm92aWRlZCBhcyBhbiBleGlzdGluZyBbW0ludGVyZmFjZV1dIG9iamVjdCxcclxuICAgICAqICBhIEpTT04tZW5jb2RlZCBBQkkgb3IgYW55IEh1bWFuLVJlYWRhYmxlIEFCSSBmb3JtYXQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XHJcbiAgICAgICAgLy8gQWxyZWFkeSBhbiBJbnRlcmZhY2UsIHdoaWNoIGlzIGltbXV0YWJsZVxyXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEludGVyZmFjZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEpTT05cclxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UoSlNPTi5wYXJzZSh2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBbiBJbnRlcmZhY2U7IHBvc3NpYmx5IGZyb20gYW5vdGhlciB2NiBpbnN0YW5jZVxyXG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlLmZvcm1hdEpzb24pID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UodmFsdWUuZm9ybWF0SnNvbigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQSBsZWdhY3kgSW50ZXJmYWNlOyBmcm9tIGFuIG9sZGVyIHZlcnNpb25cclxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZS5mb3JtYXQpID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UodmFsdWUuZm9ybWF0KFwianNvblwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFycmF5IG9mIGZyYWdtZW50c1xyXG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2UuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/interface.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/typed.js":
/*!**************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/typed.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Typed: () => (/* binding */ Typed)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/**\r\n *  A Typed object allows a value to have its type explicitly\r\n *  specified.\r\n *\r\n *  For example, in Solidity, the value ``45`` could represent a\r\n *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent\r\n *  a ``bytes2`` or ``bytes``.\r\n *\r\n *  Since JavaScript has no meaningful way to explicitly inform any\r\n *  APIs which what the type is, this allows transparent interoperation\r\n *  with Soldity.\r\n *\r\n *  @_subsection: api/abi:Typed Values\r\n */\r\n\r\nconst _gaurd = {};\r\nfunction n(value, width) {\r\n    let signed = false;\r\n    if (width < 0) {\r\n        signed = true;\r\n        width *= -1;\r\n    }\r\n    // @TODO: Check range is valid for value\r\n    return new Typed(_gaurd, `${signed ? \"\" : \"u\"}int${width}`, value, { signed, width });\r\n}\r\nfunction b(value, size) {\r\n    // @TODO: Check range is valid for value\r\n    return new Typed(_gaurd, `bytes${(size) ? size : \"\"}`, value, { size });\r\n}\r\nconst _typedSymbol = Symbol.for(\"_ethers_typed\");\r\n/**\r\n *  The **Typed** class to wrap values providing explicit type information.\r\n */\r\nclass Typed {\r\n    /**\r\n     *  The type, as a Solidity-compatible type.\r\n     */\r\n    type;\r\n    /**\r\n     *  The actual value.\r\n     */\r\n    value;\r\n    #options;\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    _typedSymbol;\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    constructor(gaurd, type, value, options) {\r\n        if (options == null) {\r\n            options = null;\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(_gaurd, gaurd, \"Typed\");\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { _typedSymbol, type, value });\r\n        this.#options = options;\r\n        // Check the value is valid\r\n        this.format();\r\n    }\r\n    /**\r\n     *  Format the type as a Human-Readable type.\r\n     */\r\n    format() {\r\n        if (this.type === \"array\") {\r\n            throw new Error(\"\");\r\n        }\r\n        else if (this.type === \"dynamicArray\") {\r\n            throw new Error(\"\");\r\n        }\r\n        else if (this.type === \"tuple\") {\r\n            return `tuple(${this.value.map((v) => v.format()).join(\",\")})`;\r\n        }\r\n        return this.type;\r\n    }\r\n    /**\r\n     *  The default value returned by this type.\r\n     */\r\n    defaultValue() {\r\n        return 0;\r\n    }\r\n    /**\r\n     *  The minimum value for numeric types.\r\n     */\r\n    minValue() {\r\n        return 0;\r\n    }\r\n    /**\r\n     *  The maximum value for numeric types.\r\n     */\r\n    maxValue() {\r\n        return 0;\r\n    }\r\n    /**\r\n     *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].\r\n     */\r\n    isBigInt() {\r\n        return !!(this.type.match(/^u?int[0-9]+$/));\r\n    }\r\n    /**\r\n     *  Returns ``true`` and provides a type guard is this is a [[TypedData]].\r\n     */\r\n    isData() {\r\n        return this.type.startsWith(\"bytes\");\r\n    }\r\n    /**\r\n     *  Returns ``true`` and provides a type guard is this is a [[TypedString]].\r\n     */\r\n    isString() {\r\n        return (this.type === \"string\");\r\n    }\r\n    /**\r\n     *  Returns the tuple name, if this is a tuple. Throws otherwise.\r\n     */\r\n    get tupleName() {\r\n        if (this.type !== \"tuple\") {\r\n            throw TypeError(\"not a tuple\");\r\n        }\r\n        return this.#options;\r\n    }\r\n    // Returns the length of this type as an array\r\n    // - `null` indicates the length is unforced, it could be dynamic\r\n    // - `-1` indicates the length is dynamic\r\n    // - any other value indicates it is a static array and is its length\r\n    /**\r\n     *  Returns the length of the array type or ``-1`` if it is dynamic.\r\n     *\r\n     *  Throws if the type is not an array.\r\n     */\r\n    get arrayLength() {\r\n        if (this.type !== \"array\") {\r\n            throw TypeError(\"not an array\");\r\n        }\r\n        if (this.#options === true) {\r\n            return -1;\r\n        }\r\n        if (this.#options === false) {\r\n            return (this.value).length;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     *  Returns a new **Typed** of %%type%% with the %%value%%.\r\n     */\r\n    static from(type, value) {\r\n        return new Typed(_gaurd, type, value);\r\n    }\r\n    /**\r\n     *  Return a new ``uint8`` type for %%v%%.\r\n     */\r\n    static uint8(v) { return n(v, 8); }\r\n    /**\r\n     *  Return a new ``uint16`` type for %%v%%.\r\n     */\r\n    static uint16(v) { return n(v, 16); }\r\n    /**\r\n     *  Return a new ``uint24`` type for %%v%%.\r\n     */\r\n    static uint24(v) { return n(v, 24); }\r\n    /**\r\n     *  Return a new ``uint32`` type for %%v%%.\r\n     */\r\n    static uint32(v) { return n(v, 32); }\r\n    /**\r\n     *  Return a new ``uint40`` type for %%v%%.\r\n     */\r\n    static uint40(v) { return n(v, 40); }\r\n    /**\r\n     *  Return a new ``uint48`` type for %%v%%.\r\n     */\r\n    static uint48(v) { return n(v, 48); }\r\n    /**\r\n     *  Return a new ``uint56`` type for %%v%%.\r\n     */\r\n    static uint56(v) { return n(v, 56); }\r\n    /**\r\n     *  Return a new ``uint64`` type for %%v%%.\r\n     */\r\n    static uint64(v) { return n(v, 64); }\r\n    /**\r\n     *  Return a new ``uint72`` type for %%v%%.\r\n     */\r\n    static uint72(v) { return n(v, 72); }\r\n    /**\r\n     *  Return a new ``uint80`` type for %%v%%.\r\n     */\r\n    static uint80(v) { return n(v, 80); }\r\n    /**\r\n     *  Return a new ``uint88`` type for %%v%%.\r\n     */\r\n    static uint88(v) { return n(v, 88); }\r\n    /**\r\n     *  Return a new ``uint96`` type for %%v%%.\r\n     */\r\n    static uint96(v) { return n(v, 96); }\r\n    /**\r\n     *  Return a new ``uint104`` type for %%v%%.\r\n     */\r\n    static uint104(v) { return n(v, 104); }\r\n    /**\r\n     *  Return a new ``uint112`` type for %%v%%.\r\n     */\r\n    static uint112(v) { return n(v, 112); }\r\n    /**\r\n     *  Return a new ``uint120`` type for %%v%%.\r\n     */\r\n    static uint120(v) { return n(v, 120); }\r\n    /**\r\n     *  Return a new ``uint128`` type for %%v%%.\r\n     */\r\n    static uint128(v) { return n(v, 128); }\r\n    /**\r\n     *  Return a new ``uint136`` type for %%v%%.\r\n     */\r\n    static uint136(v) { return n(v, 136); }\r\n    /**\r\n     *  Return a new ``uint144`` type for %%v%%.\r\n     */\r\n    static uint144(v) { return n(v, 144); }\r\n    /**\r\n     *  Return a new ``uint152`` type for %%v%%.\r\n     */\r\n    static uint152(v) { return n(v, 152); }\r\n    /**\r\n     *  Return a new ``uint160`` type for %%v%%.\r\n     */\r\n    static uint160(v) { return n(v, 160); }\r\n    /**\r\n     *  Return a new ``uint168`` type for %%v%%.\r\n     */\r\n    static uint168(v) { return n(v, 168); }\r\n    /**\r\n     *  Return a new ``uint176`` type for %%v%%.\r\n     */\r\n    static uint176(v) { return n(v, 176); }\r\n    /**\r\n     *  Return a new ``uint184`` type for %%v%%.\r\n     */\r\n    static uint184(v) { return n(v, 184); }\r\n    /**\r\n     *  Return a new ``uint192`` type for %%v%%.\r\n     */\r\n    static uint192(v) { return n(v, 192); }\r\n    /**\r\n     *  Return a new ``uint200`` type for %%v%%.\r\n     */\r\n    static uint200(v) { return n(v, 200); }\r\n    /**\r\n     *  Return a new ``uint208`` type for %%v%%.\r\n     */\r\n    static uint208(v) { return n(v, 208); }\r\n    /**\r\n     *  Return a new ``uint216`` type for %%v%%.\r\n     */\r\n    static uint216(v) { return n(v, 216); }\r\n    /**\r\n     *  Return a new ``uint224`` type for %%v%%.\r\n     */\r\n    static uint224(v) { return n(v, 224); }\r\n    /**\r\n     *  Return a new ``uint232`` type for %%v%%.\r\n     */\r\n    static uint232(v) { return n(v, 232); }\r\n    /**\r\n     *  Return a new ``uint240`` type for %%v%%.\r\n     */\r\n    static uint240(v) { return n(v, 240); }\r\n    /**\r\n     *  Return a new ``uint248`` type for %%v%%.\r\n     */\r\n    static uint248(v) { return n(v, 248); }\r\n    /**\r\n     *  Return a new ``uint256`` type for %%v%%.\r\n     */\r\n    static uint256(v) { return n(v, 256); }\r\n    /**\r\n     *  Return a new ``uint256`` type for %%v%%.\r\n     */\r\n    static uint(v) { return n(v, 256); }\r\n    /**\r\n     *  Return a new ``int8`` type for %%v%%.\r\n     */\r\n    static int8(v) { return n(v, -8); }\r\n    /**\r\n     *  Return a new ``int16`` type for %%v%%.\r\n     */\r\n    static int16(v) { return n(v, -16); }\r\n    /**\r\n     *  Return a new ``int24`` type for %%v%%.\r\n     */\r\n    static int24(v) { return n(v, -24); }\r\n    /**\r\n     *  Return a new ``int32`` type for %%v%%.\r\n     */\r\n    static int32(v) { return n(v, -32); }\r\n    /**\r\n     *  Return a new ``int40`` type for %%v%%.\r\n     */\r\n    static int40(v) { return n(v, -40); }\r\n    /**\r\n     *  Return a new ``int48`` type for %%v%%.\r\n     */\r\n    static int48(v) { return n(v, -48); }\r\n    /**\r\n     *  Return a new ``int56`` type for %%v%%.\r\n     */\r\n    static int56(v) { return n(v, -56); }\r\n    /**\r\n     *  Return a new ``int64`` type for %%v%%.\r\n     */\r\n    static int64(v) { return n(v, -64); }\r\n    /**\r\n     *  Return a new ``int72`` type for %%v%%.\r\n     */\r\n    static int72(v) { return n(v, -72); }\r\n    /**\r\n     *  Return a new ``int80`` type for %%v%%.\r\n     */\r\n    static int80(v) { return n(v, -80); }\r\n    /**\r\n     *  Return a new ``int88`` type for %%v%%.\r\n     */\r\n    static int88(v) { return n(v, -88); }\r\n    /**\r\n     *  Return a new ``int96`` type for %%v%%.\r\n     */\r\n    static int96(v) { return n(v, -96); }\r\n    /**\r\n     *  Return a new ``int104`` type for %%v%%.\r\n     */\r\n    static int104(v) { return n(v, -104); }\r\n    /**\r\n     *  Return a new ``int112`` type for %%v%%.\r\n     */\r\n    static int112(v) { return n(v, -112); }\r\n    /**\r\n     *  Return a new ``int120`` type for %%v%%.\r\n     */\r\n    static int120(v) { return n(v, -120); }\r\n    /**\r\n     *  Return a new ``int128`` type for %%v%%.\r\n     */\r\n    static int128(v) { return n(v, -128); }\r\n    /**\r\n     *  Return a new ``int136`` type for %%v%%.\r\n     */\r\n    static int136(v) { return n(v, -136); }\r\n    /**\r\n     *  Return a new ``int144`` type for %%v%%.\r\n     */\r\n    static int144(v) { return n(v, -144); }\r\n    /**\r\n     *  Return a new ``int52`` type for %%v%%.\r\n     */\r\n    static int152(v) { return n(v, -152); }\r\n    /**\r\n     *  Return a new ``int160`` type for %%v%%.\r\n     */\r\n    static int160(v) { return n(v, -160); }\r\n    /**\r\n     *  Return a new ``int168`` type for %%v%%.\r\n     */\r\n    static int168(v) { return n(v, -168); }\r\n    /**\r\n     *  Return a new ``int176`` type for %%v%%.\r\n     */\r\n    static int176(v) { return n(v, -176); }\r\n    /**\r\n     *  Return a new ``int184`` type for %%v%%.\r\n     */\r\n    static int184(v) { return n(v, -184); }\r\n    /**\r\n     *  Return a new ``int92`` type for %%v%%.\r\n     */\r\n    static int192(v) { return n(v, -192); }\r\n    /**\r\n     *  Return a new ``int200`` type for %%v%%.\r\n     */\r\n    static int200(v) { return n(v, -200); }\r\n    /**\r\n     *  Return a new ``int208`` type for %%v%%.\r\n     */\r\n    static int208(v) { return n(v, -208); }\r\n    /**\r\n     *  Return a new ``int216`` type for %%v%%.\r\n     */\r\n    static int216(v) { return n(v, -216); }\r\n    /**\r\n     *  Return a new ``int224`` type for %%v%%.\r\n     */\r\n    static int224(v) { return n(v, -224); }\r\n    /**\r\n     *  Return a new ``int232`` type for %%v%%.\r\n     */\r\n    static int232(v) { return n(v, -232); }\r\n    /**\r\n     *  Return a new ``int240`` type for %%v%%.\r\n     */\r\n    static int240(v) { return n(v, -240); }\r\n    /**\r\n     *  Return a new ``int248`` type for %%v%%.\r\n     */\r\n    static int248(v) { return n(v, -248); }\r\n    /**\r\n     *  Return a new ``int256`` type for %%v%%.\r\n     */\r\n    static int256(v) { return n(v, -256); }\r\n    /**\r\n     *  Return a new ``int256`` type for %%v%%.\r\n     */\r\n    static int(v) { return n(v, -256); }\r\n    /**\r\n     *  Return a new ``bytes1`` type for %%v%%.\r\n     */\r\n    static bytes1(v) { return b(v, 1); }\r\n    /**\r\n     *  Return a new ``bytes2`` type for %%v%%.\r\n     */\r\n    static bytes2(v) { return b(v, 2); }\r\n    /**\r\n     *  Return a new ``bytes3`` type for %%v%%.\r\n     */\r\n    static bytes3(v) { return b(v, 3); }\r\n    /**\r\n     *  Return a new ``bytes4`` type for %%v%%.\r\n     */\r\n    static bytes4(v) { return b(v, 4); }\r\n    /**\r\n     *  Return a new ``bytes5`` type for %%v%%.\r\n     */\r\n    static bytes5(v) { return b(v, 5); }\r\n    /**\r\n     *  Return a new ``bytes6`` type for %%v%%.\r\n     */\r\n    static bytes6(v) { return b(v, 6); }\r\n    /**\r\n     *  Return a new ``bytes7`` type for %%v%%.\r\n     */\r\n    static bytes7(v) { return b(v, 7); }\r\n    /**\r\n     *  Return a new ``bytes8`` type for %%v%%.\r\n     */\r\n    static bytes8(v) { return b(v, 8); }\r\n    /**\r\n     *  Return a new ``bytes9`` type for %%v%%.\r\n     */\r\n    static bytes9(v) { return b(v, 9); }\r\n    /**\r\n     *  Return a new ``bytes10`` type for %%v%%.\r\n     */\r\n    static bytes10(v) { return b(v, 10); }\r\n    /**\r\n     *  Return a new ``bytes11`` type for %%v%%.\r\n     */\r\n    static bytes11(v) { return b(v, 11); }\r\n    /**\r\n     *  Return a new ``bytes12`` type for %%v%%.\r\n     */\r\n    static bytes12(v) { return b(v, 12); }\r\n    /**\r\n     *  Return a new ``bytes13`` type for %%v%%.\r\n     */\r\n    static bytes13(v) { return b(v, 13); }\r\n    /**\r\n     *  Return a new ``bytes14`` type for %%v%%.\r\n     */\r\n    static bytes14(v) { return b(v, 14); }\r\n    /**\r\n     *  Return a new ``bytes15`` type for %%v%%.\r\n     */\r\n    static bytes15(v) { return b(v, 15); }\r\n    /**\r\n     *  Return a new ``bytes16`` type for %%v%%.\r\n     */\r\n    static bytes16(v) { return b(v, 16); }\r\n    /**\r\n     *  Return a new ``bytes17`` type for %%v%%.\r\n     */\r\n    static bytes17(v) { return b(v, 17); }\r\n    /**\r\n     *  Return a new ``bytes18`` type for %%v%%.\r\n     */\r\n    static bytes18(v) { return b(v, 18); }\r\n    /**\r\n     *  Return a new ``bytes19`` type for %%v%%.\r\n     */\r\n    static bytes19(v) { return b(v, 19); }\r\n    /**\r\n     *  Return a new ``bytes20`` type for %%v%%.\r\n     */\r\n    static bytes20(v) { return b(v, 20); }\r\n    /**\r\n     *  Return a new ``bytes21`` type for %%v%%.\r\n     */\r\n    static bytes21(v) { return b(v, 21); }\r\n    /**\r\n     *  Return a new ``bytes22`` type for %%v%%.\r\n     */\r\n    static bytes22(v) { return b(v, 22); }\r\n    /**\r\n     *  Return a new ``bytes23`` type for %%v%%.\r\n     */\r\n    static bytes23(v) { return b(v, 23); }\r\n    /**\r\n     *  Return a new ``bytes24`` type for %%v%%.\r\n     */\r\n    static bytes24(v) { return b(v, 24); }\r\n    /**\r\n     *  Return a new ``bytes25`` type for %%v%%.\r\n     */\r\n    static bytes25(v) { return b(v, 25); }\r\n    /**\r\n     *  Return a new ``bytes26`` type for %%v%%.\r\n     */\r\n    static bytes26(v) { return b(v, 26); }\r\n    /**\r\n     *  Return a new ``bytes27`` type for %%v%%.\r\n     */\r\n    static bytes27(v) { return b(v, 27); }\r\n    /**\r\n     *  Return a new ``bytes28`` type for %%v%%.\r\n     */\r\n    static bytes28(v) { return b(v, 28); }\r\n    /**\r\n     *  Return a new ``bytes29`` type for %%v%%.\r\n     */\r\n    static bytes29(v) { return b(v, 29); }\r\n    /**\r\n     *  Return a new ``bytes30`` type for %%v%%.\r\n     */\r\n    static bytes30(v) { return b(v, 30); }\r\n    /**\r\n     *  Return a new ``bytes31`` type for %%v%%.\r\n     */\r\n    static bytes31(v) { return b(v, 31); }\r\n    /**\r\n     *  Return a new ``bytes32`` type for %%v%%.\r\n     */\r\n    static bytes32(v) { return b(v, 32); }\r\n    /**\r\n     *  Return a new ``address`` type for %%v%%.\r\n     */\r\n    static address(v) { return new Typed(_gaurd, \"address\", v); }\r\n    /**\r\n     *  Return a new ``bool`` type for %%v%%.\r\n     */\r\n    static bool(v) { return new Typed(_gaurd, \"bool\", !!v); }\r\n    /**\r\n     *  Return a new ``bytes`` type for %%v%%.\r\n     */\r\n    static bytes(v) { return new Typed(_gaurd, \"bytes\", v); }\r\n    /**\r\n     *  Return a new ``string`` type for %%v%%.\r\n     */\r\n    static string(v) { return new Typed(_gaurd, \"string\", v); }\r\n    /**\r\n     *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.\r\n     */\r\n    static array(v, dynamic) {\r\n        throw new Error(\"not implemented yet\");\r\n        return new Typed(_gaurd, \"array\", v, dynamic);\r\n    }\r\n    /**\r\n     *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.\r\n     */\r\n    static tuple(v, name) {\r\n        throw new Error(\"not implemented yet\");\r\n        return new Typed(_gaurd, \"tuple\", v, name);\r\n    }\r\n    /**\r\n     *  Return a new ``uint8`` type for %%v%%.\r\n     */\r\n    static overrides(v) {\r\n        return new Typed(_gaurd, \"overrides\", Object.assign({}, v));\r\n    }\r\n    /**\r\n     *  Returns true only if %%value%% is a [[Typed]] instance.\r\n     */\r\n    static isTyped(value) {\r\n        return (value\r\n            && typeof (value) === \"object\"\r\n            && \"_typedSymbol\" in value\r\n            && value._typedSymbol === _typedSymbol);\r\n    }\r\n    /**\r\n     *  If the value is a [[Typed]] instance, validates the underlying value\r\n     *  and returns it, otherwise returns value directly.\r\n     *\r\n     *  This is useful for functions that with to accept either a [[Typed]]\r\n     *  object or values.\r\n     */\r\n    static dereference(value, type) {\r\n        if (Typed.isTyped(value)) {\r\n            if (value.type !== type) {\r\n                throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);\r\n            }\r\n            return value.value;\r\n        }\r\n        return value;\r\n    }\r\n}\r\n//# sourceMappingURL=typed.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvdHlwZWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ29FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCLEtBQUssTUFBTSxZQUFZLGVBQWU7QUFDeEY7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQixZQUFZLE1BQU07QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOERBQWE7QUFDckIsUUFBUSxpRUFBZ0IsU0FBUywyQkFBMkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRDQUE0QztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxLQUFLLFFBQVEsV0FBVztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxhYmlcXHR5cGVkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgQSBUeXBlZCBvYmplY3QgYWxsb3dzIGEgdmFsdWUgdG8gaGF2ZSBpdHMgdHlwZSBleHBsaWNpdGx5XHJcbiAqICBzcGVjaWZpZWQuXHJcbiAqXHJcbiAqICBGb3IgZXhhbXBsZSwgaW4gU29saWRpdHksIHRoZSB2YWx1ZSBgYDQ1YGAgY291bGQgcmVwcmVzZW50IGFcclxuICogIGBgdWludDhgYCBvciBhIGBgdWludDI1NmBgLiBUaGUgdmFsdWUgYGAweDEyMzRgYCBjb3VsZCByZXByZXNlbnRcclxuICogIGEgYGBieXRlczJgYCBvciBgYGJ5dGVzYGAuXHJcbiAqXHJcbiAqICBTaW5jZSBKYXZhU2NyaXB0IGhhcyBubyBtZWFuaW5nZnVsIHdheSB0byBleHBsaWNpdGx5IGluZm9ybSBhbnlcclxuICogIEFQSXMgd2hpY2ggd2hhdCB0aGUgdHlwZSBpcywgdGhpcyBhbGxvd3MgdHJhbnNwYXJlbnQgaW50ZXJvcGVyYXRpb25cclxuICogIHdpdGggU29sZGl0eS5cclxuICpcclxuICogIEBfc3Vic2VjdGlvbjogYXBpL2FiaTpUeXBlZCBWYWx1ZXNcclxuICovXHJcbmltcG9ydCB7IGFzc2VydFByaXZhdGUsIGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuY29uc3QgX2dhdXJkID0ge307XHJcbmZ1bmN0aW9uIG4odmFsdWUsIHdpZHRoKSB7XHJcbiAgICBsZXQgc2lnbmVkID0gZmFsc2U7XHJcbiAgICBpZiAod2lkdGggPCAwKSB7XHJcbiAgICAgICAgc2lnbmVkID0gdHJ1ZTtcclxuICAgICAgICB3aWR0aCAqPSAtMTtcclxuICAgIH1cclxuICAgIC8vIEBUT0RPOiBDaGVjayByYW5nZSBpcyB2YWxpZCBmb3IgdmFsdWVcclxuICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBgJHtzaWduZWQgPyBcIlwiIDogXCJ1XCJ9aW50JHt3aWR0aH1gLCB2YWx1ZSwgeyBzaWduZWQsIHdpZHRoIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGIodmFsdWUsIHNpemUpIHtcclxuICAgIC8vIEBUT0RPOiBDaGVjayByYW5nZSBpcyB2YWxpZCBmb3IgdmFsdWVcclxuICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBgYnl0ZXMkeyhzaXplKSA/IHNpemUgOiBcIlwifWAsIHZhbHVlLCB7IHNpemUgfSk7XHJcbn1cclxuY29uc3QgX3R5cGVkU3ltYm9sID0gU3ltYm9sLmZvcihcIl9ldGhlcnNfdHlwZWRcIik7XHJcbi8qKlxyXG4gKiAgVGhlICoqVHlwZWQqKiBjbGFzcyB0byB3cmFwIHZhbHVlcyBwcm92aWRpbmcgZXhwbGljaXQgdHlwZSBpbmZvcm1hdGlvbi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBUeXBlZCB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdHlwZSwgYXMgYSBTb2xpZGl0eS1jb21wYXRpYmxlIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIHR5cGU7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYWN0dWFsIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICB2YWx1ZTtcclxuICAgICNvcHRpb25zO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIF90eXBlZFN5bWJvbDtcclxuICAgIC8qKlxyXG4gICAgICogIEBfaWdub3JlOlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihnYXVyZCwgdHlwZSwgdmFsdWUsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnRQcml2YXRlKF9nYXVyZCwgZ2F1cmQsIFwiVHlwZWRcIik7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IF90eXBlZFN5bWJvbCwgdHlwZSwgdmFsdWUgfSk7XHJcbiAgICAgICAgdGhpcy4jb3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgLy8gQ2hlY2sgdGhlIHZhbHVlIGlzIHZhbGlkXHJcbiAgICAgICAgdGhpcy5mb3JtYXQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEZvcm1hdCB0aGUgdHlwZSBhcyBhIEh1bWFuLVJlYWRhYmxlIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIGZvcm1hdCgpIHtcclxuICAgICAgICBpZiAodGhpcy50eXBlID09PSBcImFycmF5XCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwiZHluYW1pY0FycmF5XCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwidHVwbGVcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gYHR1cGxlKCR7dGhpcy52YWx1ZS5tYXAoKHYpID0+IHYuZm9ybWF0KCkpLmpvaW4oXCIsXCIpfSlgO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50eXBlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGRlZmF1bHQgdmFsdWUgcmV0dXJuZWQgYnkgdGhpcyB0eXBlLlxyXG4gICAgICovXHJcbiAgICBkZWZhdWx0VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbWluaW11bSB2YWx1ZSBmb3IgbnVtZXJpYyB0eXBlcy5cclxuICAgICAqL1xyXG4gICAgbWluVmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbWF4aW11bSB2YWx1ZSBmb3IgbnVtZXJpYyB0eXBlcy5cclxuICAgICAqL1xyXG4gICAgbWF4VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaXMgdGhpcyBpcyBhIFtbVHlwZWRCaWdJbnRdXS5cclxuICAgICAqL1xyXG4gICAgaXNCaWdJbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhKHRoaXMudHlwZS5tYXRjaCgvXnU/aW50WzAtOV0rJC8pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpcyB0aGlzIGlzIGEgW1tUeXBlZERhdGFdXS5cclxuICAgICAqL1xyXG4gICAgaXNEYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuc3RhcnRzV2l0aChcImJ5dGVzXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlzIHRoaXMgaXMgYSBbW1R5cGVkU3RyaW5nXV0uXHJcbiAgICAgKi9cclxuICAgIGlzU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSBcInN0cmluZ1wiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIHR1cGxlIG5hbWUsIGlmIHRoaXMgaXMgYSB0dXBsZS4gVGhyb3dzIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHR1cGxlTmFtZSgpIHtcclxuICAgICAgICBpZiAodGhpcy50eXBlICE9PSBcInR1cGxlXCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibm90IGEgdHVwbGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLiNvcHRpb25zO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoaXMgdHlwZSBhcyBhbiBhcnJheVxyXG4gICAgLy8gLSBgbnVsbGAgaW5kaWNhdGVzIHRoZSBsZW5ndGggaXMgdW5mb3JjZWQsIGl0IGNvdWxkIGJlIGR5bmFtaWNcclxuICAgIC8vIC0gYC0xYCBpbmRpY2F0ZXMgdGhlIGxlbmd0aCBpcyBkeW5hbWljXHJcbiAgICAvLyAtIGFueSBvdGhlciB2YWx1ZSBpbmRpY2F0ZXMgaXQgaXMgYSBzdGF0aWMgYXJyYXkgYW5kIGlzIGl0cyBsZW5ndGhcclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgdHlwZSBvciBgYC0xYGAgaWYgaXQgaXMgZHluYW1pYy5cclxuICAgICAqXHJcbiAgICAgKiAgVGhyb3dzIGlmIHRoZSB0eXBlIGlzIG5vdCBhbiBhcnJheS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGFycmF5TGVuZ3RoKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFwiYXJyYXlcIikge1xyXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJub3QgYW4gYXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLiNvcHRpb25zID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuI29wdGlvbnMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy52YWx1ZSkubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBuZXcgKipUeXBlZCoqIG9mICUldHlwZSUlIHdpdGggdGhlICUldmFsdWUlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb20odHlwZSwgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgdHlwZSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDhgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQ4KHYpIHsgcmV0dXJuIG4odiwgOCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDE2KHYpIHsgcmV0dXJuIG4odiwgMTYpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjRgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQyNCh2KSB7IHJldHVybiBuKHYsIDI0KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDMyYGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50MzIodikgeyByZXR1cm4gbih2LCAzMik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ0MGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDQwKHYpIHsgcmV0dXJuIG4odiwgNDApOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NDhgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQ0OCh2KSB7IHJldHVybiBuKHYsIDQ4KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDU2YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50NTYodikgeyByZXR1cm4gbih2LCA1Nik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ2NGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDY0KHYpIHsgcmV0dXJuIG4odiwgNjQpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NzJgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQ3Mih2KSB7IHJldHVybiBuKHYsIDcyKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDgwYGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50ODAodikgeyByZXR1cm4gbih2LCA4MCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ4OGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDg4KHYpIHsgcmV0dXJuIG4odiwgODgpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50OTZgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQ5Nih2KSB7IHJldHVybiBuKHYsIDk2KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEwNGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDEwNCh2KSB7IHJldHVybiBuKHYsIDEwNCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMTJgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQxMTIodikgeyByZXR1cm4gbih2LCAxMTIpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTIwYGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50MTIwKHYpIHsgcmV0dXJuIG4odiwgMTIwKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEyOGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDEyOCh2KSB7IHJldHVybiBuKHYsIDEyOCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMzZgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQxMzYodikgeyByZXR1cm4gbih2LCAxMzYpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTQ0YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50MTQ0KHYpIHsgcmV0dXJuIG4odiwgMTQ0KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE1MmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDE1Mih2KSB7IHJldHVybiBuKHYsIDE1Mik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNjBgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQxNjAodikgeyByZXR1cm4gbih2LCAxNjApOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTY4YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50MTY4KHYpIHsgcmV0dXJuIG4odiwgMTY4KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE3NmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDE3Nih2KSB7IHJldHVybiBuKHYsIDE3Nik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxODRgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQxODQodikgeyByZXR1cm4gbih2LCAxODQpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTkyYGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50MTkyKHYpIHsgcmV0dXJuIG4odiwgMTkyKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIwMGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDIwMCh2KSB7IHJldHVybiBuKHYsIDIwMCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMDhgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQyMDgodikgeyByZXR1cm4gbih2LCAyMDgpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjE2YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50MjE2KHYpIHsgcmV0dXJuIG4odiwgMjE2KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIyNGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDIyNCh2KSB7IHJldHVybiBuKHYsIDIyNCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMzJgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQyMzIodikgeyByZXR1cm4gbih2LCAyMzIpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjQwYGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50MjQwKHYpIHsgcmV0dXJuIG4odiwgMjQwKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI0OGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDI0OCh2KSB7IHJldHVybiBuKHYsIDI0OCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQyNTYodikgeyByZXR1cm4gbih2LCAyNTYpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50KHYpIHsgcmV0dXJuIG4odiwgMjU2KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50OGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50OCh2KSB7IHJldHVybiBuKHYsIC04KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTZgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDE2KHYpIHsgcmV0dXJuIG4odiwgLTE2KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjRgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDI0KHYpIHsgcmV0dXJuIG4odiwgLTI0KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MzJgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDMyKHYpIHsgcmV0dXJuIG4odiwgLTMyKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NDBgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDQwKHYpIHsgcmV0dXJuIG4odiwgLTQwKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NDhgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDQ4KHYpIHsgcmV0dXJuIG4odiwgLTQ4KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NTZgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDU2KHYpIHsgcmV0dXJuIG4odiwgLTU2KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NjRgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDY0KHYpIHsgcmV0dXJuIG4odiwgLTY0KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NzJgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDcyKHYpIHsgcmV0dXJuIG4odiwgLTcyKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50ODBgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDgwKHYpIHsgcmV0dXJuIG4odiwgLTgwKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50ODhgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDg4KHYpIHsgcmV0dXJuIG4odiwgLTg4KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50OTZgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDk2KHYpIHsgcmV0dXJuIG4odiwgLTk2KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTA0YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnQxMDQodikgeyByZXR1cm4gbih2LCAtMTA0KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTEyYGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnQxMTIodikgeyByZXR1cm4gbih2LCAtMTEyKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTIwYGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnQxMjAodikgeyByZXR1cm4gbih2LCAtMTIwKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTI4YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnQxMjgodikgeyByZXR1cm4gbih2LCAtMTI4KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTM2YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnQxMzYodikgeyByZXR1cm4gbih2LCAtMTM2KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTQ0YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnQxNDQodikgeyByZXR1cm4gbih2LCAtMTQ0KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NTJgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDE1Mih2KSB7IHJldHVybiBuKHYsIC0xNTIpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNjBgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDE2MCh2KSB7IHJldHVybiBuKHYsIC0xNjApOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNjhgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDE2OCh2KSB7IHJldHVybiBuKHYsIC0xNjgpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNzZgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDE3Nih2KSB7IHJldHVybiBuKHYsIC0xNzYpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxODRgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDE4NCh2KSB7IHJldHVybiBuKHYsIC0xODQpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ5MmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50MTkyKHYpIHsgcmV0dXJuIG4odiwgLTE5Mik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIwMGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50MjAwKHYpIHsgcmV0dXJuIG4odiwgLTIwMCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIwOGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50MjA4KHYpIHsgcmV0dXJuIG4odiwgLTIwOCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIxNmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50MjE2KHYpIHsgcmV0dXJuIG4odiwgLTIxNik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIyNGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50MjI0KHYpIHsgcmV0dXJuIG4odiwgLTIyNCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIzMmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50MjMyKHYpIHsgcmV0dXJuIG4odiwgLTIzMik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI0MGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50MjQwKHYpIHsgcmV0dXJuIG4odiwgLTI0MCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI0OGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50MjQ4KHYpIHsgcmV0dXJuIG4odiwgLTI0OCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI1NmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50MjU2KHYpIHsgcmV0dXJuIG4odiwgLTI1Nik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI1NmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50KHYpIHsgcmV0dXJuIG4odiwgLTI1Nik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMWBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMxKHYpIHsgcmV0dXJuIGIodiwgMSk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMyKHYpIHsgcmV0dXJuIGIodiwgMik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzM2BgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMzKHYpIHsgcmV0dXJuIGIodiwgMyk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzNGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXM0KHYpIHsgcmV0dXJuIGIodiwgNCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzNWBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXM1KHYpIHsgcmV0dXJuIGIodiwgNSk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzNmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXM2KHYpIHsgcmV0dXJuIGIodiwgNik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzN2BgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXM3KHYpIHsgcmV0dXJuIGIodiwgNyk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzOGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXM4KHYpIHsgcmV0dXJuIGIodiwgOCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzOWBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXM5KHYpIHsgcmV0dXJuIGIodiwgOSk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTBgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMTAodikgeyByZXR1cm4gYih2LCAxMCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTFgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMTEodikgeyByZXR1cm4gYih2LCAxMSk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTJgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMTIodikgeyByZXR1cm4gYih2LCAxMik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTNgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMTModikgeyByZXR1cm4gYih2LCAxMyk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTRgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMTQodikgeyByZXR1cm4gYih2LCAxNCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTVgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMTUodikgeyByZXR1cm4gYih2LCAxNSk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTZgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMTYodikgeyByZXR1cm4gYih2LCAxNik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTdgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMTcodikgeyByZXR1cm4gYih2LCAxNyk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMThgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMTgodikgeyByZXR1cm4gYih2LCAxOCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTlgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMTkodikgeyByZXR1cm4gYih2LCAxOSk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjBgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMjAodikgeyByZXR1cm4gYih2LCAyMCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjFgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMjEodikgeyByZXR1cm4gYih2LCAyMSk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjJgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMjIodikgeyByZXR1cm4gYih2LCAyMik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjNgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMjModikgeyByZXR1cm4gYih2LCAyMyk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjRgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMjQodikgeyByZXR1cm4gYih2LCAyNCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjVgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMjUodikgeyByZXR1cm4gYih2LCAyNSk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjZgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMjYodikgeyByZXR1cm4gYih2LCAyNik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjdgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMjcodikgeyByZXR1cm4gYih2LCAyNyk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjhgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMjgodikgeyByZXR1cm4gYih2LCAyOCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjlgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMjkodikgeyByZXR1cm4gYih2LCAyOSk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMzBgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMzAodikgeyByZXR1cm4gYih2LCAzMCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMzFgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMzEodikgeyByZXR1cm4gYih2LCAzMSk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMzJgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ5dGVzMzIodikgeyByZXR1cm4gYih2LCAzMik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGFkZHJlc3NgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFkZHJlc3ModikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJhZGRyZXNzXCIsIHYpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBib29sYGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBib29sKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwiYm9vbFwiLCAhIXYpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlc2BgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXModikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJieXRlc1wiLCB2KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgc3RyaW5nYGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzdHJpbmcodikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJzdHJpbmdcIiwgdik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGFycmF5YGAgdHlwZSBmb3IgJSV2JSUsIGFsbG93aW5nICUlZHluYW1pYyUlIGxlbmd0aC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFycmF5KHYsIGR5bmFtaWMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImFycmF5XCIsIHYsIGR5bmFtaWMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdHVwbGVgYCB0eXBlIGZvciAlJXYlJSwgd2l0aCB0aGUgb3B0aW9uYWwgJSVuYW1lJSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB0dXBsZSh2LCBuYW1lKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkIHlldFwiKTtcclxuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJ0dXBsZVwiLCB2LCBuYW1lKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ4YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBvdmVycmlkZXModikge1xyXG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcIm92ZXJyaWRlc1wiLCBPYmplY3QuYXNzaWduKHt9LCB2KSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgb25seSBpZiAlJXZhbHVlJSUgaXMgYSBbW1R5cGVkXV0gaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc1R5cGVkKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuICh2YWx1ZVxyXG4gICAgICAgICAgICAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIlxyXG4gICAgICAgICAgICAmJiBcIl90eXBlZFN5bWJvbFwiIGluIHZhbHVlXHJcbiAgICAgICAgICAgICYmIHZhbHVlLl90eXBlZFN5bWJvbCA9PT0gX3R5cGVkU3ltYm9sKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIElmIHRoZSB2YWx1ZSBpcyBhIFtbVHlwZWRdXSBpbnN0YW5jZSwgdmFsaWRhdGVzIHRoZSB1bmRlcmx5aW5nIHZhbHVlXHJcbiAgICAgKiAgYW5kIHJldHVybnMgaXQsIG90aGVyd2lzZSByZXR1cm5zIHZhbHVlIGRpcmVjdGx5LlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIHVzZWZ1bCBmb3IgZnVuY3Rpb25zIHRoYXQgd2l0aCB0byBhY2NlcHQgZWl0aGVyIGEgW1tUeXBlZF1dXHJcbiAgICAgKiAgb2JqZWN0IG9yIHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRlcmVmZXJlbmNlKHZhbHVlLCB0eXBlKSB7XHJcbiAgICAgICAgaWYgKFR5cGVkLmlzVHlwZWQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgdHlwZTogZXhwZWNldGQgJHt0eXBlfSwgZ290ICR7dmFsdWUudHlwZX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlZC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/typed.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/address/address.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/address/address.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAddress: () => (/* binding */ getAddress),\n/* harmony export */   getIcapAddress: () => (/* binding */ getIcapAddress)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n\r\n\r\nconst BN_0 = BigInt(0);\r\nconst BN_36 = BigInt(36);\r\nfunction getChecksumAddress(address) {\r\n    //    if (!isHexString(address, 20)) {\r\n    //        logger.throwArgumentError(\"invalid address\", \"address\", address);\r\n    //    }\r\n    address = address.toLowerCase();\r\n    const chars = address.substring(2).split(\"\");\r\n    const expanded = new Uint8Array(40);\r\n    for (let i = 0; i < 40; i++) {\r\n        expanded[i] = chars[i].charCodeAt(0);\r\n    }\r\n    const hashed = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)(expanded));\r\n    for (let i = 0; i < 40; i += 2) {\r\n        if ((hashed[i >> 1] >> 4) >= 8) {\r\n            chars[i] = chars[i].toUpperCase();\r\n        }\r\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\r\n            chars[i + 1] = chars[i + 1].toUpperCase();\r\n        }\r\n    }\r\n    return \"0x\" + chars.join(\"\");\r\n}\r\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\r\n// Create lookup table\r\nconst ibanLookup = {};\r\nfor (let i = 0; i < 10; i++) {\r\n    ibanLookup[String(i)] = String(i);\r\n}\r\nfor (let i = 0; i < 26; i++) {\r\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\r\n}\r\n// How many decimal digits can we process? (for 64-bit float, this is 15)\r\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\r\nconst safeDigits = 15;\r\nfunction ibanChecksum(address) {\r\n    address = address.toUpperCase();\r\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\r\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\r\n    // Javascript can handle integers safely up to 15 (decimal) digits\r\n    while (expanded.length >= safeDigits) {\r\n        let block = expanded.substring(0, safeDigits);\r\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\r\n    }\r\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\r\n    while (checksum.length < 2) {\r\n        checksum = \"0\" + checksum;\r\n    }\r\n    return checksum;\r\n}\r\n;\r\nconst Base36 = (function () {\r\n    ;\r\n    const result = {};\r\n    for (let i = 0; i < 36; i++) {\r\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\r\n        result[key] = BigInt(i);\r\n    }\r\n    return result;\r\n})();\r\nfunction fromBase36(value) {\r\n    value = value.toLowerCase();\r\n    let result = BN_0;\r\n    for (let i = 0; i < value.length; i++) {\r\n        result = result * BN_36 + Base36[value[i]];\r\n    }\r\n    return result;\r\n}\r\n/**\r\n *  Returns a normalized and checksumed address for %%address%%.\r\n *  This accepts non-checksum addresses, checksum addresses and\r\n *  [[getIcapAddress]] formats.\r\n *\r\n *  The checksum in Ethereum uses the capitalization (upper-case\r\n *  vs lower-case) of the characters within an address to encode\r\n *  its checksum, which offers, on average, a checksum of 15-bits.\r\n *\r\n *  If %%address%% contains both upper-case and lower-case, it is\r\n *  assumed to already be a checksum address and its checksum is\r\n *  validated, and if the address fails its expected checksum an\r\n *  error is thrown.\r\n *\r\n *  If you wish the checksum of %%address%% to be ignore, it should\r\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\r\n *  being passed in. This should be a very rare situation though,\r\n *  that you wish to bypass the safegaurds in place to protect\r\n *  against an address that has been incorrectly copied from another\r\n *  source.\r\n *\r\n *  @example:\r\n *    // Adds the checksum (via upper-casing specific letters)\r\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\r\n *    //_result:\r\n *\r\n *    // Converts ICAP address and adds checksum\r\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\r\n *    //_result:\r\n *\r\n *    // Throws an error if an address contains mixed case,\r\n *    // but the checksum fails\r\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\r\n *    //_error:\r\n */\r\nfunction getAddress(address) {\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (address) === \"string\", \"invalid address\", \"address\", address);\r\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\r\n        // Missing the 0x prefix\r\n        if (!address.startsWith(\"0x\")) {\r\n            address = \"0x\" + address;\r\n        }\r\n        const result = getChecksumAddress(address);\r\n        // It is a checksummed address with a bad checksum\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, \"bad address checksum\", \"address\", address);\r\n        return result;\r\n    }\r\n    // Maybe ICAP? (we only support direct mode)\r\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\r\n        // It is an ICAP address with a bad checksum\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\r\n        let result = fromBase36(address.substring(4)).toString(16);\r\n        while (result.length < 40) {\r\n            result = \"0\" + result;\r\n        }\r\n        return getChecksumAddress(\"0x\" + result);\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid address\", \"address\", address);\r\n}\r\n/**\r\n *  The [ICAP Address format](link-icap) format is an early checksum\r\n *  format which attempts to be compatible with the banking\r\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\r\n *\r\n *  It is no longer common or a recommended format.\r\n *\r\n *  @example:\r\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\r\n *    //_result:\r\n *\r\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\r\n *    //_result:\r\n *\r\n *    // Throws an error if the ICAP checksum is wrong\r\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\r\n *    //_error:\r\n */\r\nfunction getIcapAddress(address) {\r\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\r\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\r\n    while (base36.length < 30) {\r\n        base36 = \"0\" + base36;\r\n    }\r\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\r\n}\r\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErQztBQUNjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQSxtQkFBbUIseURBQVEsQ0FBQywyREFBUztBQUNyQyxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx1QkFBdUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksK0RBQWM7QUFDbEIseUNBQXlDLEdBQUc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRSxZQUFZLE1BQU07QUFDcEQ7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0RBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcYWRkcmVzc1xcYWRkcmVzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGdldEJ5dGVzLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xyXG5jb25zdCBCTl8zNiA9IEJpZ0ludCgzNik7XHJcbmZ1bmN0aW9uIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSB7XHJcbiAgICAvLyAgICBpZiAoIWlzSGV4U3RyaW5nKGFkZHJlc3MsIDIwKSkge1xyXG4gICAgLy8gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xyXG4gICAgLy8gICAgfVxyXG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcclxuICAgIGNvbnN0IGNoYXJzID0gYWRkcmVzcy5zdWJzdHJpbmcoMikuc3BsaXQoXCJcIik7XHJcbiAgICBjb25zdCBleHBhbmRlZCA9IG5ldyBVaW50OEFycmF5KDQwKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkrKykge1xyXG4gICAgICAgIGV4cGFuZGVkW2ldID0gY2hhcnNbaV0uY2hhckNvZGVBdCgwKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGhhc2hlZCA9IGdldEJ5dGVzKGtlY2NhazI1NihleHBhbmRlZCkpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0MDsgaSArPSAyKSB7XHJcbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSA+PiA0KSA+PSA4KSB7XHJcbiAgICAgICAgICAgIGNoYXJzW2ldID0gY2hhcnNbaV0udG9VcHBlckNhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSAmIDB4MGYpID49IDgpIHtcclxuICAgICAgICAgICAgY2hhcnNbaSArIDFdID0gY2hhcnNbaSArIDFdLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiMHhcIiArIGNoYXJzLmpvaW4oXCJcIik7XHJcbn1cclxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcm5hdGlvbmFsX0JhbmtfQWNjb3VudF9OdW1iZXJcclxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZVxyXG5jb25zdCBpYmFuTG9va3VwID0ge307XHJcbmZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xyXG4gICAgaWJhbkxvb2t1cFtTdHJpbmcoaSldID0gU3RyaW5nKGkpO1xyXG59XHJcbmZvciAobGV0IGkgPSAwOyBpIDwgMjY7IGkrKykge1xyXG4gICAgaWJhbkxvb2t1cFtTdHJpbmcuZnJvbUNoYXJDb2RlKDY1ICsgaSldID0gU3RyaW5nKDEwICsgaSk7XHJcbn1cclxuLy8gSG93IG1hbnkgZGVjaW1hbCBkaWdpdHMgY2FuIHdlIHByb2Nlc3M/IChmb3IgNjQtYml0IGZsb2F0LCB0aGlzIGlzIDE1KVxyXG4vLyBpLmUuIE1hdGguZmxvb3IoTWF0aC5sb2cxMChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpO1xyXG5jb25zdCBzYWZlRGlnaXRzID0gMTU7XHJcbmZ1bmN0aW9uIGliYW5DaGVja3N1bShhZGRyZXNzKSB7XHJcbiAgICBhZGRyZXNzID0gYWRkcmVzcy50b1VwcGVyQ2FzZSgpO1xyXG4gICAgYWRkcmVzcyA9IGFkZHJlc3Muc3Vic3RyaW5nKDQpICsgYWRkcmVzcy5zdWJzdHJpbmcoMCwgMikgKyBcIjAwXCI7XHJcbiAgICBsZXQgZXhwYW5kZWQgPSBhZGRyZXNzLnNwbGl0KFwiXCIpLm1hcCgoYykgPT4geyByZXR1cm4gaWJhbkxvb2t1cFtjXTsgfSkuam9pbihcIlwiKTtcclxuICAgIC8vIEphdmFzY3JpcHQgY2FuIGhhbmRsZSBpbnRlZ2VycyBzYWZlbHkgdXAgdG8gMTUgKGRlY2ltYWwpIGRpZ2l0c1xyXG4gICAgd2hpbGUgKGV4cGFuZGVkLmxlbmd0aCA+PSBzYWZlRGlnaXRzKSB7XHJcbiAgICAgICAgbGV0IGJsb2NrID0gZXhwYW5kZWQuc3Vic3RyaW5nKDAsIHNhZmVEaWdpdHMpO1xyXG4gICAgICAgIGV4cGFuZGVkID0gcGFyc2VJbnQoYmxvY2ssIDEwKSAlIDk3ICsgZXhwYW5kZWQuc3Vic3RyaW5nKGJsb2NrLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBsZXQgY2hlY2tzdW0gPSBTdHJpbmcoOTggLSAocGFyc2VJbnQoZXhwYW5kZWQsIDEwKSAlIDk3KSk7XHJcbiAgICB3aGlsZSAoY2hlY2tzdW0ubGVuZ3RoIDwgMikge1xyXG4gICAgICAgIGNoZWNrc3VtID0gXCIwXCIgKyBjaGVja3N1bTtcclxuICAgIH1cclxuICAgIHJldHVybiBjaGVja3N1bTtcclxufVxyXG47XHJcbmNvbnN0IEJhc2UzNiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICA7XHJcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzY7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCJbaV07XHJcbiAgICAgICAgcmVzdWx0W2tleV0gPSBCaWdJbnQoaSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59KSgpO1xyXG5mdW5jdGlvbiBmcm9tQmFzZTM2KHZhbHVlKSB7XHJcbiAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBsZXQgcmVzdWx0ID0gQk5fMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICByZXN1bHQgPSByZXN1bHQgKiBCTl8zNiArIEJhc2UzNlt2YWx1ZVtpXV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyBhIG5vcm1hbGl6ZWQgYW5kIGNoZWNrc3VtZWQgYWRkcmVzcyBmb3IgJSVhZGRyZXNzJSUuXHJcbiAqICBUaGlzIGFjY2VwdHMgbm9uLWNoZWNrc3VtIGFkZHJlc3NlcywgY2hlY2tzdW0gYWRkcmVzc2VzIGFuZFxyXG4gKiAgW1tnZXRJY2FwQWRkcmVzc11dIGZvcm1hdHMuXHJcbiAqXHJcbiAqICBUaGUgY2hlY2tzdW0gaW4gRXRoZXJldW0gdXNlcyB0aGUgY2FwaXRhbGl6YXRpb24gKHVwcGVyLWNhc2VcclxuICogIHZzIGxvd2VyLWNhc2UpIG9mIHRoZSBjaGFyYWN0ZXJzIHdpdGhpbiBhbiBhZGRyZXNzIHRvIGVuY29kZVxyXG4gKiAgaXRzIGNoZWNrc3VtLCB3aGljaCBvZmZlcnMsIG9uIGF2ZXJhZ2UsIGEgY2hlY2tzdW0gb2YgMTUtYml0cy5cclxuICpcclxuICogIElmICUlYWRkcmVzcyUlIGNvbnRhaW5zIGJvdGggdXBwZXItY2FzZSBhbmQgbG93ZXItY2FzZSwgaXQgaXNcclxuICogIGFzc3VtZWQgdG8gYWxyZWFkeSBiZSBhIGNoZWNrc3VtIGFkZHJlc3MgYW5kIGl0cyBjaGVja3N1bSBpc1xyXG4gKiAgdmFsaWRhdGVkLCBhbmQgaWYgdGhlIGFkZHJlc3MgZmFpbHMgaXRzIGV4cGVjdGVkIGNoZWNrc3VtIGFuXHJcbiAqICBlcnJvciBpcyB0aHJvd24uXHJcbiAqXHJcbiAqICBJZiB5b3Ugd2lzaCB0aGUgY2hlY2tzdW0gb2YgJSVhZGRyZXNzJSUgdG8gYmUgaWdub3JlLCBpdCBzaG91bGRcclxuICogIGJlIGNvbnZlcnRlZCB0byBsb3dlci1jYXNlIChpLmUuIGBgLnRvTG93ZXJjYXNlKClgYCkgYmVmb3JlXHJcbiAqICBiZWluZyBwYXNzZWQgaW4uIFRoaXMgc2hvdWxkIGJlIGEgdmVyeSByYXJlIHNpdHVhdGlvbiB0aG91Z2gsXHJcbiAqICB0aGF0IHlvdSB3aXNoIHRvIGJ5cGFzcyB0aGUgc2FmZWdhdXJkcyBpbiBwbGFjZSB0byBwcm90ZWN0XHJcbiAqICBhZ2FpbnN0IGFuIGFkZHJlc3MgdGhhdCBoYXMgYmVlbiBpbmNvcnJlY3RseSBjb3BpZWQgZnJvbSBhbm90aGVyXHJcbiAqICBzb3VyY2UuXHJcbiAqXHJcbiAqICBAZXhhbXBsZTpcclxuICogICAgLy8gQWRkcyB0aGUgY2hlY2tzdW0gKHZpYSB1cHBlci1jYXNpbmcgc3BlY2lmaWMgbGV0dGVycylcclxuICogICAgZ2V0QWRkcmVzcyhcIjB4OGJhMWYxMDk1NTFiZDQzMjgwMzAxMjY0NWFjMTM2ZGRkNjRkYmE3MlwiKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIC8vIENvbnZlcnRzIElDQVAgYWRkcmVzcyBhbmQgYWRkcyBjaGVja3N1bVxyXG4gKiAgICBnZXRBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzZcIik7XHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICpcclxuICogICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGFuIGFkZHJlc3MgY29udGFpbnMgbWl4ZWQgY2FzZSxcclxuICogICAgLy8gYnV0IHRoZSBjaGVja3N1bSBmYWlsc1xyXG4gKiAgICBnZXRBZGRyZXNzKFwiMHg4QmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXHJcbiAqICAgIC8vX2Vycm9yOlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFkZHJlc3MoYWRkcmVzcykge1xyXG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChhZGRyZXNzKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xyXG4gICAgaWYgKGFkZHJlc3MubWF0Y2goL14oMHgpP1swLTlhLWZBLUZdezQwfSQvKSkge1xyXG4gICAgICAgIC8vIE1pc3NpbmcgdGhlIDB4IHByZWZpeFxyXG4gICAgICAgIGlmICghYWRkcmVzcy5zdGFydHNXaXRoKFwiMHhcIikpIHtcclxuICAgICAgICAgICAgYWRkcmVzcyA9IFwiMHhcIiArIGFkZHJlc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcclxuICAgICAgICAvLyBJdCBpcyBhIGNoZWNrc3VtbWVkIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCFhZGRyZXNzLm1hdGNoKC8oW0EtRl0uKlthLWZdKXwoW2EtZl0uKltBLUZdKS8pIHx8IHJlc3VsdCA9PT0gYWRkcmVzcywgXCJiYWQgYWRkcmVzcyBjaGVja3N1bVwiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8vIE1heWJlIElDQVA/ICh3ZSBvbmx5IHN1cHBvcnQgZGlyZWN0IG1vZGUpXHJcbiAgICBpZiAoYWRkcmVzcy5tYXRjaCgvXlhFWzAtOV17Mn1bMC05QS1aYS16XXszMCwzMX0kLykpIHtcclxuICAgICAgICAvLyBJdCBpcyBhbiBJQ0FQIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGFkZHJlc3Muc3Vic3RyaW5nKDIsIDQpID09PSBpYmFuQ2hlY2tzdW0oYWRkcmVzcyksIFwiYmFkIGljYXAgY2hlY2tzdW1cIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBmcm9tQmFzZTM2KGFkZHJlc3Muc3Vic3RyaW5nKDQpKS50b1N0cmluZygxNik7XHJcbiAgICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCA0MCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdldENoZWNrc3VtQWRkcmVzcyhcIjB4XCIgKyByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcclxufVxyXG4vKipcclxuICogIFRoZSBbSUNBUCBBZGRyZXNzIGZvcm1hdF0obGluay1pY2FwKSBmb3JtYXQgaXMgYW4gZWFybHkgY2hlY2tzdW1cclxuICogIGZvcm1hdCB3aGljaCBhdHRlbXB0cyB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlIGJhbmtpbmdcclxuICogIGluZHVzdHJ5IFtJQkFOIGZvcm1hdF0obGluay13aWtpLWliYW4pIGZvciBiYW5rIGFjY291bnRzLlxyXG4gKlxyXG4gKiAgSXQgaXMgbm8gbG9uZ2VyIGNvbW1vbiBvciBhIHJlY29tbWVuZGVkIGZvcm1hdC5cclxuICpcclxuICogIEBleGFtcGxlOlxyXG4gKiAgICBnZXRJY2FwQWRkcmVzcyhcIjB4OGJhMWYxMDk1NTFiZDQzMjgwMzAxMjY0NWFjMTM2ZGRkNjRkYmE3MlwiKTtcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKlxyXG4gKiAgICBnZXRJY2FwQWRkcmVzcyhcIlhFNjVHQjZMRE5YWU9GVFgwTlNWM0ZVV0tPV0lYQU1KSzM2XCIpO1xyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiB0aGUgSUNBUCBjaGVja3N1bSBpcyB3cm9uZ1xyXG4gKiAgICBnZXRJY2FwQWRkcmVzcyhcIlhFNjVHQjZMRE5YWU9GVFgwTlNWM0ZVV0tPV0lYQU1KSzM3XCIpO1xyXG4gKiAgICAvL19lcnJvcjpcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRJY2FwQWRkcmVzcyhhZGRyZXNzKSB7XHJcbiAgICAvL2xldCBiYXNlMzYgPSBfYmFzZTE2VG8zNihnZXRBZGRyZXNzKGFkZHJlc3MpLnN1YnN0cmluZygyKSkudG9VcHBlckNhc2UoKTtcclxuICAgIGxldCBiYXNlMzYgPSBCaWdJbnQoZ2V0QWRkcmVzcyhhZGRyZXNzKSkudG9TdHJpbmcoMzYpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICB3aGlsZSAoYmFzZTM2Lmxlbmd0aCA8IDMwKSB7XHJcbiAgICAgICAgYmFzZTM2ID0gXCIwXCIgKyBiYXNlMzY7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXCJYRVwiICsgaWJhbkNoZWNrc3VtKFwiWEUwMFwiICsgYmFzZTM2KSArIGJhc2UzNjtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/address/address.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/address/checks.js":
/*!*******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/address/checks.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isAddress: () => (/* binding */ isAddress),\n/* harmony export */   isAddressable: () => (/* binding */ isAddressable),\n/* harmony export */   resolveAddress: () => (/* binding */ resolveAddress)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./address.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n\r\n\r\n/**\r\n *  Returns true if %%value%% is an object which implements the\r\n *  [[Addressable]] interface.\r\n *\r\n *  @example:\r\n *    // Wallets and AbstractSigner sub-classes\r\n *    isAddressable(Wallet.createRandom())\r\n *    //_result:\r\n *\r\n *    // Contracts\r\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\r\n *    isAddressable(contract)\r\n *    //_result:\r\n */\r\nfunction isAddressable(value) {\r\n    return (value && typeof (value.getAddress) === \"function\");\r\n}\r\n/**\r\n *  Returns true if %%value%% is a valid address.\r\n *\r\n *  @example:\r\n *    // Valid address\r\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\r\n *    //_result:\r\n *\r\n *    // Valid ICAP address\r\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\r\n *    //_result:\r\n *\r\n *    // Invalid checksum\r\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\r\n *    //_result:\r\n *\r\n *    // Invalid ICAP checksum\r\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\r\n *    //_result:\r\n *\r\n *    // Not an address (an ENS name requires a provided and an\r\n *    // asynchronous API to access)\r\n *    isAddress(\"ricmoo.eth\")\r\n *    //_result:\r\n */\r\nfunction isAddress(value) {\r\n    try {\r\n        (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(value);\r\n        return true;\r\n    }\r\n    catch (error) { }\r\n    return false;\r\n}\r\nasync function checkAddress(target, promise) {\r\n    const result = await promise;\r\n    if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof (target) !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", { value: target });\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\r\n    }\r\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(result);\r\n}\r\n/**\r\n *  Resolves to an address for the %%target%%, which may be any\r\n *  supported address type, an [[Addressable]] or a Promise which\r\n *  resolves to an address.\r\n *\r\n *  If an ENS name is provided, but that name has not been correctly\r\n *  configured a [[UnconfiguredNameError]] is thrown.\r\n *\r\n *  @example:\r\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\r\n *\r\n *    // Addresses are return synchronously\r\n *    resolveAddress(addr, provider)\r\n *    //_result:\r\n *\r\n *    // Address promises are resolved asynchronously\r\n *    resolveAddress(Promise.resolve(addr))\r\n *    //_result:\r\n *\r\n *    // ENS names are resolved asynchronously\r\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\r\n *    //_result:\r\n *\r\n *    // Addressable objects are resolved asynchronously\r\n *    contract = new Contract(addr, [ ])\r\n *    resolveAddress(contract, provider)\r\n *    //_result:\r\n *\r\n *    // Unconfigured ENS names reject\r\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\r\n *    //_error:\r\n *\r\n *    // ENS names require a NameResolver object passed in\r\n *    // (notice the provider was omitted)\r\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\r\n *    //_error:\r\n */\r\nfunction resolveAddress(target, resolver) {\r\n    if (typeof (target) === \"string\") {\r\n        if (target.match(/^0x[0-9a-f]{40}$/i)) {\r\n            return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(target);\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(resolver != null, \"ENS resolution requires a provider\", \"UNSUPPORTED_OPERATION\", { operation: \"resolveName\" });\r\n        return checkAddress(target, resolver.resolveName(target));\r\n    }\r\n    else if (isAddressable(target)) {\r\n        return checkAddress(target, target.getAddress());\r\n    }\r\n    else if (target && typeof (target.then) === \"function\") {\r\n        return checkAddress(target, target);\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported addressable value\", \"target\", target);\r\n}\r\n//# sourceMappingURL=checks.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2NoZWNrcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEyRDtBQUNqQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsUUFBUSx1REFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBTSwyRUFBMkUsZUFBZTtBQUN4RyxRQUFRLCtEQUFjLG9DQUFvQztBQUMxRDtBQUNBLFdBQVcsdURBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxzQ0FBc0MsR0FBRztBQUN6QyxtQkFBbUIsdURBQVU7QUFDN0I7QUFDQSxRQUFRLHVEQUFNLG9GQUFvRiwwQkFBMEI7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0RBQWM7QUFDbEI7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxhZGRyZXNzXFxjaGVja3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4vYWRkcmVzcy5qc1wiO1xyXG4vKipcclxuICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYW4gb2JqZWN0IHdoaWNoIGltcGxlbWVudHMgdGhlXHJcbiAqICBbW0FkZHJlc3NhYmxlXV0gaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiAgQGV4YW1wbGU6XHJcbiAqICAgIC8vIFdhbGxldHMgYW5kIEFic3RyYWN0U2lnbmVyIHN1Yi1jbGFzc2VzXHJcbiAqICAgIGlzQWRkcmVzc2FibGUoV2FsbGV0LmNyZWF0ZVJhbmRvbSgpKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIC8vIENvbnRyYWN0c1xyXG4gKiAgICBjb250cmFjdCA9IG5ldyBDb250cmFjdChcImRhaS50b2tlbnMuZXRoZXJzLmV0aFwiLCBbIF0sIHByb3ZpZGVyKVxyXG4gKiAgICBpc0FkZHJlc3NhYmxlKGNvbnRyYWN0KVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNBZGRyZXNzYWJsZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmdldEFkZHJlc3MpID09PSBcImZ1bmN0aW9uXCIpO1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIGFkZHJlc3MuXHJcbiAqXHJcbiAqICBAZXhhbXBsZTpcclxuICogICAgLy8gVmFsaWQgYWRkcmVzc1xyXG4gKiAgICBpc0FkZHJlc3MoXCIweDhiYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKlxyXG4gKiAgICAvLyBWYWxpZCBJQ0FQIGFkZHJlc3NcclxuICogICAgaXNBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzZcIilcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKlxyXG4gKiAgICAvLyBJbnZhbGlkIGNoZWNrc3VtXHJcbiAqICAgIGlzQWRkcmVzcyhcIjB4OEJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQmE3MlwiKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIC8vIEludmFsaWQgSUNBUCBjaGVja3N1bVxyXG4gKiAgICBpc0FkZHJlc3MoXCIweDhCYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKlxyXG4gKiAgICAvLyBOb3QgYW4gYWRkcmVzcyAoYW4gRU5TIG5hbWUgcmVxdWlyZXMgYSBwcm92aWRlZCBhbmQgYW5cclxuICogICAgLy8gYXN5bmNocm9ub3VzIEFQSSB0byBhY2Nlc3MpXHJcbiAqICAgIGlzQWRkcmVzcyhcInJpY21vby5ldGhcIilcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzQWRkcmVzcyh2YWx1ZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBnZXRBZGRyZXNzKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gY2hlY2tBZGRyZXNzKHRhcmdldCwgcHJvbWlzZSkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcclxuICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCByZXN1bHQgPT09IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpIHtcclxuICAgICAgICBhc3NlcnQodHlwZW9mICh0YXJnZXQpICE9PSBcInN0cmluZ1wiLCBcInVuY29uZmlndXJlZCBuYW1lXCIsIFwiVU5DT05GSUdVUkVEX05BTUVcIiwgeyB2YWx1ZTogdGFyZ2V0IH0pO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgQWRkcmVzc0xpa2UgdmFsdWU7IGRpZCBub3QgcmVzb2x2ZSB0byBhIHZhbHVlIGFkZHJlc3NcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBnZXRBZGRyZXNzKHJlc3VsdCk7XHJcbn1cclxuLyoqXHJcbiAqICBSZXNvbHZlcyB0byBhbiBhZGRyZXNzIGZvciB0aGUgJSV0YXJnZXQlJSwgd2hpY2ggbWF5IGJlIGFueVxyXG4gKiAgc3VwcG9ydGVkIGFkZHJlc3MgdHlwZSwgYW4gW1tBZGRyZXNzYWJsZV1dIG9yIGEgUHJvbWlzZSB3aGljaFxyXG4gKiAgcmVzb2x2ZXMgdG8gYW4gYWRkcmVzcy5cclxuICpcclxuICogIElmIGFuIEVOUyBuYW1lIGlzIHByb3ZpZGVkLCBidXQgdGhhdCBuYW1lIGhhcyBub3QgYmVlbiBjb3JyZWN0bHlcclxuICogIGNvbmZpZ3VyZWQgYSBbW1VuY29uZmlndXJlZE5hbWVFcnJvcl1dIGlzIHRocm93bi5cclxuICpcclxuICogIEBleGFtcGxlOlxyXG4gKiAgICBhZGRyID0gXCIweDZCMTc1NDc0RTg5MDk0QzQ0RGE5OGI5NTRFZWRlQUM0OTUyNzFkMEZcIlxyXG4gKlxyXG4gKiAgICAvLyBBZGRyZXNzZXMgYXJlIHJldHVybiBzeW5jaHJvbm91c2x5XHJcbiAqICAgIHJlc29sdmVBZGRyZXNzKGFkZHIsIHByb3ZpZGVyKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIC8vIEFkZHJlc3MgcHJvbWlzZXMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XHJcbiAqICAgIHJlc29sdmVBZGRyZXNzKFByb21pc2UucmVzb2x2ZShhZGRyKSlcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKlxyXG4gKiAgICAvLyBFTlMgbmFtZXMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XHJcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwiZGFpLnRva2Vucy5ldGhlcnMuZXRoXCIsIHByb3ZpZGVyKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIC8vIEFkZHJlc3NhYmxlIG9iamVjdHMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XHJcbiAqICAgIGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGFkZHIsIFsgXSlcclxuICogICAgcmVzb2x2ZUFkZHJlc3MoY29udHJhY3QsIHByb3ZpZGVyKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIC8vIFVuY29uZmlndXJlZCBFTlMgbmFtZXMgcmVqZWN0XHJcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwibm90aGluZy1oZXJlLnJpY21vby5ldGhcIiwgcHJvdmlkZXIpXHJcbiAqICAgIC8vX2Vycm9yOlxyXG4gKlxyXG4gKiAgICAvLyBFTlMgbmFtZXMgcmVxdWlyZSBhIE5hbWVSZXNvbHZlciBvYmplY3QgcGFzc2VkIGluXHJcbiAqICAgIC8vIChub3RpY2UgdGhlIHByb3ZpZGVyIHdhcyBvbWl0dGVkKVxyXG4gKiAgICByZXNvbHZlQWRkcmVzcyhcIm5vdGhpbmctaGVyZS5yaWNtb28uZXRoXCIpXHJcbiAqICAgIC8vX2Vycm9yOlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVBZGRyZXNzKHRhcmdldCwgcmVzb2x2ZXIpIHtcclxuICAgIGlmICh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBpZiAodGFyZ2V0Lm1hdGNoKC9eMHhbMC05YS1mXXs0MH0kL2kpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRBZGRyZXNzKHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydChyZXNvbHZlciAhPSBudWxsLCBcIkVOUyByZXNvbHV0aW9uIHJlcXVpcmVzIGEgcHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIiB9KTtcclxuICAgICAgICByZXR1cm4gY2hlY2tBZGRyZXNzKHRhcmdldCwgcmVzb2x2ZXIucmVzb2x2ZU5hbWUodGFyZ2V0KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FkZHJlc3NhYmxlKHRhcmdldCkpIHtcclxuICAgICAgICByZXR1cm4gY2hlY2tBZGRyZXNzKHRhcmdldCwgdGFyZ2V0LmdldEFkZHJlc3MoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0YXJnZXQgJiYgdHlwZW9mICh0YXJnZXQudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCB0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgYWRkcmVzc2FibGUgdmFsdWVcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja3MuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/address/checks.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/address/contract-address.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/address/contract-address.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCreate2Address: () => (/* binding */ getCreate2Address),\n/* harmony export */   getCreateAddress: () => (/* binding */ getCreateAddress)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./address.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n\r\n\r\n\r\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\r\n/**\r\n *  Returns the address that would result from a ``CREATE`` for %%tx%%.\r\n *\r\n *  This can be used to compute the address a contract will be\r\n *  deployed to by an EOA when sending a deployment transaction (i.e.\r\n *  when the ``to`` address is ``null``).\r\n *\r\n *  This can also be used to compute the address a contract will be\r\n *  deployed to by a contract, by using the contract's address as the\r\n *  ``to`` and the contract's nonce.\r\n *\r\n *  @example\r\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\";\r\n *    nonce = 5;\r\n *\r\n *    getCreateAddress({ from, nonce });\r\n *    //_result:\r\n */\r\nfunction getCreateAddress(tx) {\r\n    const from = (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(tx.from);\r\n    const nonce = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(tx.nonce, \"tx.nonce\");\r\n    let nonceHex = nonce.toString(16);\r\n    if (nonceHex === \"0\") {\r\n        nonceHex = \"0x\";\r\n    }\r\n    else if (nonceHex.length % 2) {\r\n        nonceHex = \"0x0\" + nonceHex;\r\n    }\r\n    else {\r\n        nonceHex = \"0x\" + nonceHex;\r\n    }\r\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.encodeRlp)([from, nonceHex])), 12));\r\n}\r\n/**\r\n *  Returns the address that would result from a ``CREATE2`` operation\r\n *  with the given %%from%%, %%salt%% and %%initCodeHash%%.\r\n *\r\n *  To compute the %%initCodeHash%% from a contract's init code, use\r\n *  the [[keccak256]] function.\r\n *\r\n *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].\r\n *\r\n *  @example\r\n *    // The address of the contract\r\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\"\r\n *\r\n *    // The salt\r\n *    salt = id(\"HelloWorld\")\r\n *\r\n *    // The hash of the initCode\r\n *    initCode = \"0x6394198df16000526103ff60206004601c335afa6040516060f3\";\r\n *    initCodeHash = keccak256(initCode)\r\n *\r\n *    getCreate2Address(from, salt, initCodeHash)\r\n *    //_result:\r\n */\r\nfunction getCreate2Address(_from, _salt, _initCodeHash) {\r\n    const from = (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(_from);\r\n    const salt = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_salt, \"salt\");\r\n    const initCodeHash = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_initCodeHash, \"initCodeHash\");\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(salt.length === 32, \"salt must be 32 bytes\", \"salt\", _salt);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(initCodeHash.length === 32, \"initCodeHash must be 32 bytes\", \"initCodeHash\", _initCodeHash);\r\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([\"0xff\", from, salt, initCodeHash])), 12));\r\n}\r\n//# sourceMappingURL=contract-address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2NvbnRyYWN0LWFkZHJlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBK0M7QUFDdUQ7QUFDNUQ7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ087QUFDUCxpQkFBaUIsdURBQVU7QUFDM0Isa0JBQWtCLDBEQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBVSxDQUFDLDBEQUFTLENBQUMsMkRBQVMsQ0FBQywwREFBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQix1REFBVTtBQUMzQixpQkFBaUIseURBQVE7QUFDekIseUJBQXlCLHlEQUFRO0FBQ2pDLElBQUksK0RBQWM7QUFDbEIsSUFBSSwrREFBYztBQUNsQixXQUFXLHVEQUFVLENBQUMsMERBQVMsQ0FBQywyREFBUyxDQUFDLHVEQUFNO0FBQ2hEO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcYWRkcmVzc1xcY29udHJhY3QtYWRkcmVzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGNvbmNhdCwgZGF0YVNsaWNlLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBlbmNvZGVSbHAsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XHJcbi8vIGh0dHA6Ly9ldGhlcmV1bS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNzYwL2hvdy1pcy10aGUtYWRkcmVzcy1vZi1hbi1ldGhlcmV1bS1jb250cmFjdC1jb21wdXRlZFxyXG4vKipcclxuICogIFJldHVybnMgdGhlIGFkZHJlc3MgdGhhdCB3b3VsZCByZXN1bHQgZnJvbSBhIGBgQ1JFQVRFYGAgZm9yICUldHglJS5cclxuICpcclxuICogIFRoaXMgY2FuIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgYWRkcmVzcyBhIGNvbnRyYWN0IHdpbGwgYmVcclxuICogIGRlcGxveWVkIHRvIGJ5IGFuIEVPQSB3aGVuIHNlbmRpbmcgYSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uIChpLmUuXHJcbiAqICB3aGVuIHRoZSBgYHRvYGAgYWRkcmVzcyBpcyBgYG51bGxgYCkuXHJcbiAqXHJcbiAqICBUaGlzIGNhbiBhbHNvIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgYWRkcmVzcyBhIGNvbnRyYWN0IHdpbGwgYmVcclxuICogIGRlcGxveWVkIHRvIGJ5IGEgY29udHJhY3QsIGJ5IHVzaW5nIHRoZSBjb250cmFjdCdzIGFkZHJlc3MgYXMgdGhlXHJcbiAqICBgYHRvYGAgYW5kIHRoZSBjb250cmFjdCdzIG5vbmNlLlxyXG4gKlxyXG4gKiAgQGV4YW1wbGVcclxuICogICAgZnJvbSA9IFwiMHg4YmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCI7XHJcbiAqICAgIG5vbmNlID0gNTtcclxuICpcclxuICogICAgZ2V0Q3JlYXRlQWRkcmVzcyh7IGZyb20sIG5vbmNlIH0pO1xyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JlYXRlQWRkcmVzcyh0eCkge1xyXG4gICAgY29uc3QgZnJvbSA9IGdldEFkZHJlc3ModHguZnJvbSk7XHJcbiAgICBjb25zdCBub25jZSA9IGdldEJpZ0ludCh0eC5ub25jZSwgXCJ0eC5ub25jZVwiKTtcclxuICAgIGxldCBub25jZUhleCA9IG5vbmNlLnRvU3RyaW5nKDE2KTtcclxuICAgIGlmIChub25jZUhleCA9PT0gXCIwXCIpIHtcclxuICAgICAgICBub25jZUhleCA9IFwiMHhcIjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5vbmNlSGV4Lmxlbmd0aCAlIDIpIHtcclxuICAgICAgICBub25jZUhleCA9IFwiMHgwXCIgKyBub25jZUhleDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG5vbmNlSGV4ID0gXCIweFwiICsgbm9uY2VIZXg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhkYXRhU2xpY2Uoa2VjY2FrMjU2KGVuY29kZVJscChbZnJvbSwgbm9uY2VIZXhdKSksIDEyKSk7XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm5zIHRoZSBhZGRyZXNzIHRoYXQgd291bGQgcmVzdWx0IGZyb20gYSBgYENSRUFURTJgYCBvcGVyYXRpb25cclxuICogIHdpdGggdGhlIGdpdmVuICUlZnJvbSUlLCAlJXNhbHQlJSBhbmQgJSVpbml0Q29kZUhhc2glJS5cclxuICpcclxuICogIFRvIGNvbXB1dGUgdGhlICUlaW5pdENvZGVIYXNoJSUgZnJvbSBhIGNvbnRyYWN0J3MgaW5pdCBjb2RlLCB1c2VcclxuICogIHRoZSBbW2tlY2NhazI1Nl1dIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiAgRm9yIGEgcXVpY2sgb3ZlcnZpZXcgYW5kIGV4YW1wbGUgb2YgYGBDUkVBVEUyYGAsIHNlZSBbW2xpbmstcmljbW9vLXdpc3BzXV0uXHJcbiAqXHJcbiAqICBAZXhhbXBsZVxyXG4gKiAgICAvLyBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3RcclxuICogICAgZnJvbSA9IFwiMHg4YmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCJcclxuICpcclxuICogICAgLy8gVGhlIHNhbHRcclxuICogICAgc2FsdCA9IGlkKFwiSGVsbG9Xb3JsZFwiKVxyXG4gKlxyXG4gKiAgICAvLyBUaGUgaGFzaCBvZiB0aGUgaW5pdENvZGVcclxuICogICAgaW5pdENvZGUgPSBcIjB4NjM5NDE5OGRmMTYwMDA1MjYxMDNmZjYwMjA2MDA0NjAxYzMzNWFmYTYwNDA1MTYwNjBmM1wiO1xyXG4gKiAgICBpbml0Q29kZUhhc2ggPSBrZWNjYWsyNTYoaW5pdENvZGUpXHJcbiAqXHJcbiAqICAgIGdldENyZWF0ZTJBZGRyZXNzKGZyb20sIHNhbHQsIGluaXRDb2RlSGFzaClcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENyZWF0ZTJBZGRyZXNzKF9mcm9tLCBfc2FsdCwgX2luaXRDb2RlSGFzaCkge1xyXG4gICAgY29uc3QgZnJvbSA9IGdldEFkZHJlc3MoX2Zyb20pO1xyXG4gICAgY29uc3Qgc2FsdCA9IGdldEJ5dGVzKF9zYWx0LCBcInNhbHRcIik7XHJcbiAgICBjb25zdCBpbml0Q29kZUhhc2ggPSBnZXRCeXRlcyhfaW5pdENvZGVIYXNoLCBcImluaXRDb2RlSGFzaFwiKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KHNhbHQubGVuZ3RoID09PSAzMiwgXCJzYWx0IG11c3QgYmUgMzIgYnl0ZXNcIiwgXCJzYWx0XCIsIF9zYWx0KTtcclxuICAgIGFzc2VydEFyZ3VtZW50KGluaXRDb2RlSGFzaC5sZW5ndGggPT09IDMyLCBcImluaXRDb2RlSGFzaCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwiaW5pdENvZGVIYXNoXCIsIF9pbml0Q29kZUhhc2gpO1xyXG4gICAgcmV0dXJuIGdldEFkZHJlc3MoZGF0YVNsaWNlKGtlY2NhazI1Nihjb25jYXQoW1wiMHhmZlwiLCBmcm9tLCBzYWx0LCBpbml0Q29kZUhhc2hdKSksIDEyKSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJhY3QtYWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/address/contract-address.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/address/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAddress: () => (/* reexport safe */ _address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress),\n/* harmony export */   getCreate2Address: () => (/* reexport safe */ _contract_address_js__WEBPACK_IMPORTED_MODULE_1__.getCreate2Address),\n/* harmony export */   getCreateAddress: () => (/* reexport safe */ _contract_address_js__WEBPACK_IMPORTED_MODULE_1__.getCreateAddress),\n/* harmony export */   getIcapAddress: () => (/* reexport safe */ _address_js__WEBPACK_IMPORTED_MODULE_0__.getIcapAddress),\n/* harmony export */   isAddress: () => (/* reexport safe */ _checks_js__WEBPACK_IMPORTED_MODULE_2__.isAddress),\n/* harmony export */   isAddressable: () => (/* reexport safe */ _checks_js__WEBPACK_IMPORTED_MODULE_2__.isAddressable),\n/* harmony export */   resolveAddress: () => (/* reexport safe */ _checks_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)\n/* harmony export */ });\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./address.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _contract_address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contract-address.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/contract-address.js\");\n/* harmony import */ var _checks_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./checks.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/checks.js\");\n/**\r\n *  Addresses are a fundamental part of interacting with Ethereum. They\r\n *  represent the global identity of Externally Owned Accounts (accounts\r\n *  backed by a private key) and contracts.\r\n *\r\n *  The Ethereum Naming Service (ENS) provides an interconnected ecosystem\r\n *  of contracts, standards and libraries which enable looking up an\r\n *  address for an ENS name.\r\n *\r\n *  These functions help convert between various formats, validate\r\n *  addresses and safely resolve ENS names.\r\n *\r\n *  @_section: api/address:Addresses  [about-addresses]\r\n */\r\nnull;\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMEQ7QUFDa0I7QUFDTDtBQUN2RSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxhZGRyZXNzXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIEFkZHJlc3NlcyBhcmUgYSBmdW5kYW1lbnRhbCBwYXJ0IG9mIGludGVyYWN0aW5nIHdpdGggRXRoZXJldW0uIFRoZXlcclxuICogIHJlcHJlc2VudCB0aGUgZ2xvYmFsIGlkZW50aXR5IG9mIEV4dGVybmFsbHkgT3duZWQgQWNjb3VudHMgKGFjY291bnRzXHJcbiAqICBiYWNrZWQgYnkgYSBwcml2YXRlIGtleSkgYW5kIGNvbnRyYWN0cy5cclxuICpcclxuICogIFRoZSBFdGhlcmV1bSBOYW1pbmcgU2VydmljZSAoRU5TKSBwcm92aWRlcyBhbiBpbnRlcmNvbm5lY3RlZCBlY29zeXN0ZW1cclxuICogIG9mIGNvbnRyYWN0cywgc3RhbmRhcmRzIGFuZCBsaWJyYXJpZXMgd2hpY2ggZW5hYmxlIGxvb2tpbmcgdXAgYW5cclxuICogIGFkZHJlc3MgZm9yIGFuIEVOUyBuYW1lLlxyXG4gKlxyXG4gKiAgVGhlc2UgZnVuY3Rpb25zIGhlbHAgY29udmVydCBiZXR3ZWVuIHZhcmlvdXMgZm9ybWF0cywgdmFsaWRhdGVcclxuICogIGFkZHJlc3NlcyBhbmQgc2FmZWx5IHJlc29sdmUgRU5TIG5hbWVzLlxyXG4gKlxyXG4gKiAgQF9zZWN0aW9uOiBhcGkvYWRkcmVzczpBZGRyZXNzZXMgIFthYm91dC1hZGRyZXNzZXNdXHJcbiAqL1xyXG5udWxsO1xyXG5leHBvcnQgeyBnZXRBZGRyZXNzLCBnZXRJY2FwQWRkcmVzcyB9IGZyb20gXCIuL2FkZHJlc3MuanNcIjtcclxuZXhwb3J0IHsgZ2V0Q3JlYXRlQWRkcmVzcywgZ2V0Q3JlYXRlMkFkZHJlc3MgfSBmcm9tIFwiLi9jb250cmFjdC1hZGRyZXNzLmpzXCI7XHJcbmV4cG9ydCB7IGlzQWRkcmVzc2FibGUsIGlzQWRkcmVzcywgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi9jaGVja3MuanNcIjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/constants/addresses.js":
/*!************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/constants/addresses.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZeroAddress: () => (/* binding */ ZeroAddress)\n/* harmony export */ });\n/**\r\n *  A constant for the zero address.\r\n *\r\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000\"``)\r\n */\r\nconst ZeroAddress = \"0x0000000000000000000000000000000000000000\";\r\n//# sourceMappingURL=addresses.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvYWRkcmVzc2VzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxjb25zdGFudHNcXGFkZHJlc3Nlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIEEgY29uc3RhbnQgZm9yIHRoZSB6ZXJvIGFkZHJlc3MuXHJcbiAqXHJcbiAqICAoKippLmUuKiogYGBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiYGApXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgWmVyb0FkZHJlc3MgPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/constants/addresses.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/constants/hashes.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/constants/hashes.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZeroHash: () => (/* binding */ ZeroHash)\n/* harmony export */ });\n/**\r\n *  A constant for the zero hash.\r\n *\r\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000000000000000000000000000\"``)\r\n */\r\nconst ZeroHash = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\r\n//# sourceMappingURL=hashes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvaGFzaGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxjb25zdGFudHNcXGhhc2hlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIEEgY29uc3RhbnQgZm9yIHRoZSB6ZXJvIGhhc2guXHJcbiAqXHJcbiAqICAoKippLmUuKiogYGBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiYGApXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgWmVyb0hhc2ggPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/constants/hashes.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/constants/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/constants/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EtherSymbol: () => (/* reexport safe */ _strings_js__WEBPACK_IMPORTED_MODULE_3__.EtherSymbol),\n/* harmony export */   MaxInt256: () => (/* reexport safe */ _numbers_js__WEBPACK_IMPORTED_MODULE_2__.MaxInt256),\n/* harmony export */   MaxUint256: () => (/* reexport safe */ _numbers_js__WEBPACK_IMPORTED_MODULE_2__.MaxUint256),\n/* harmony export */   MessagePrefix: () => (/* reexport safe */ _strings_js__WEBPACK_IMPORTED_MODULE_3__.MessagePrefix),\n/* harmony export */   MinInt256: () => (/* reexport safe */ _numbers_js__WEBPACK_IMPORTED_MODULE_2__.MinInt256),\n/* harmony export */   N: () => (/* reexport safe */ _numbers_js__WEBPACK_IMPORTED_MODULE_2__.N),\n/* harmony export */   WeiPerEther: () => (/* reexport safe */ _numbers_js__WEBPACK_IMPORTED_MODULE_2__.WeiPerEther),\n/* harmony export */   ZeroAddress: () => (/* reexport safe */ _addresses_js__WEBPACK_IMPORTED_MODULE_0__.ZeroAddress),\n/* harmony export */   ZeroHash: () => (/* reexport safe */ _hashes_js__WEBPACK_IMPORTED_MODULE_1__.ZeroHash)\n/* harmony export */ });\n/* harmony import */ var _addresses_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addresses.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _hashes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hashes.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/constants/hashes.js\");\n/* harmony import */ var _numbers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./numbers.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/constants/numbers.js\");\n/* harmony import */ var _strings_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./strings.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/constants/strings.js\");\n/**\r\n *  Some common constants useful for Ethereum.\r\n *\r\n *  @_section: api/constants: Constants  [about-constants]\r\n */\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkM7QUFDTjtBQUN5QztBQUN0QjtBQUMxRCIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxjb25zdGFudHNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgU29tZSBjb21tb24gY29uc3RhbnRzIHVzZWZ1bCBmb3IgRXRoZXJldW0uXHJcbiAqXHJcbiAqICBAX3NlY3Rpb246IGFwaS9jb25zdGFudHM6IENvbnN0YW50cyAgW2Fib3V0LWNvbnN0YW50c11cclxuICovXHJcbmV4cG9ydCB7IFplcm9BZGRyZXNzIH0gZnJvbSBcIi4vYWRkcmVzc2VzLmpzXCI7XHJcbmV4cG9ydCB7IFplcm9IYXNoIH0gZnJvbSBcIi4vaGFzaGVzLmpzXCI7XHJcbmV4cG9ydCB7IE4sIFdlaVBlckV0aGVyLCBNYXhVaW50MjU2LCBNaW5JbnQyNTYsIE1heEludDI1NiB9IGZyb20gXCIuL251bWJlcnMuanNcIjtcclxuZXhwb3J0IHsgRXRoZXJTeW1ib2wsIE1lc3NhZ2VQcmVmaXggfSBmcm9tIFwiLi9zdHJpbmdzLmpzXCI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/constants/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/constants/numbers.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/constants/numbers.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MaxInt256: () => (/* binding */ MaxInt256),\n/* harmony export */   MaxUint256: () => (/* binding */ MaxUint256),\n/* harmony export */   MinInt256: () => (/* binding */ MinInt256),\n/* harmony export */   N: () => (/* binding */ N),\n/* harmony export */   WeiPerEther: () => (/* binding */ WeiPerEther)\n/* harmony export */ });\n/**\r\n *  A constant for the order N for the secp256k1 curve.\r\n *\r\n *  (**i.e.** ``0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n``)\r\n */\r\nconst N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\r\n/**\r\n *  A constant for the number of wei in a single ether.\r\n *\r\n *  (**i.e.** ``1000000000000000000n``)\r\n */\r\nconst WeiPerEther = BigInt(\"1000000000000000000\");\r\n/**\r\n *  A constant for the maximum value for a ``uint256``.\r\n *\r\n *  (**i.e.** ``0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn``)\r\n */\r\nconst MaxUint256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\r\n/**\r\n *  A constant for the minimum value for an ``int256``.\r\n *\r\n *  (**i.e.** ``-8000000000000000000000000000000000000000000000000000000000000000n``)\r\n */\r\nconst MinInt256 = BigInt(\"0x8000000000000000000000000000000000000000000000000000000000000000\") * BigInt(-1);\r\n/**\r\n *  A constant for the maximum value for an ``int256``.\r\n *\r\n *  (**i.e.** ``0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn``)\r\n */\r\nconst MaxInt256 = BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\r\n//# sourceMappingURL=numbers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvbnVtYmVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXGNvbnN0YW50c1xcbnVtYmVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBvcmRlciBOIGZvciB0aGUgc2VjcDI1NmsxIGN1cnZlLlxyXG4gKlxyXG4gKiAgKCoqaS5lLioqIGBgMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxbmBgKVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IE4gPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFcIik7XHJcbi8qKlxyXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIG51bWJlciBvZiB3ZWkgaW4gYSBzaW5nbGUgZXRoZXIuXHJcbiAqXHJcbiAqICAoKippLmUuKiogYGAxMDAwMDAwMDAwMDAwMDAwMDAwbmBgKVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFdlaVBlckV0aGVyID0gQmlnSW50KFwiMTAwMDAwMDAwMDAwMDAwMDAwMFwiKTtcclxuLyoqXHJcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgbWF4aW11bSB2YWx1ZSBmb3IgYSBgYHVpbnQyNTZgYC5cclxuICpcclxuICogICgqKmkuZS4qKiBgYDB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZm5gYClcclxuICovXHJcbmV4cG9ydCBjb25zdCBNYXhVaW50MjU2ID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xyXG4vKipcclxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBtaW5pbXVtIHZhbHVlIGZvciBhbiBgYGludDI1NmBgLlxyXG4gKlxyXG4gKiAgKCoqaS5lLioqIGBgLTgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBuYGApXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgTWluSW50MjU2ID0gQmlnSW50KFwiMHg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpICogQmlnSW50KC0xKTtcclxuLyoqXHJcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgbWF4aW11bSB2YWx1ZSBmb3IgYW4gYGBpbnQyNTZgYC5cclxuICpcclxuICogICgqKmkuZS4qKiBgYDB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZm5gYClcclxuICovXHJcbmV4cG9ydCBjb25zdCBNYXhJbnQyNTYgPSBCaWdJbnQoXCIweDdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/constants/numbers.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/constants/strings.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/constants/strings.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EtherSymbol: () => (/* binding */ EtherSymbol),\n/* harmony export */   MessagePrefix: () => (/* binding */ MessagePrefix)\n/* harmony export */ });\n// NFKC (composed)             // (decomposed)\r\n/**\r\n *  A constant for the ether symbol (normalized using NFKC).\r\n *\r\n *  (**i.e.** ``\"\\\\u039e\"``)\r\n */\r\nconst EtherSymbol = \"\\u039e\"; // \"\\uD835\\uDF63\";\r\n/**\r\n *  A constant for the [[link-eip-191]] personal message prefix.\r\n *\r\n *  (**i.e.** ``\"\\\\x19Ethereum Signed Message:\\\\n\"``)\r\n */\r\nconst MessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\r\n//# sourceMappingURL=strings.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvc3RyaW5ncy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDhCQUE4QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxjb25zdGFudHNcXHN0cmluZ3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTkZLQyAoY29tcG9zZWQpICAgICAgICAgICAgIC8vIChkZWNvbXBvc2VkKVxyXG4vKipcclxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBldGhlciBzeW1ib2wgKG5vcm1hbGl6ZWQgdXNpbmcgTkZLQykuXHJcbiAqXHJcbiAqICAoKippLmUuKiogYGBcIlxcXFx1MDM5ZVwiYGApXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgRXRoZXJTeW1ib2wgPSBcIlxcdTAzOWVcIjsgLy8gXCJcXHVEODM1XFx1REY2M1wiO1xyXG4vKipcclxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBbW2xpbmstZWlwLTE5MV1dIHBlcnNvbmFsIG1lc3NhZ2UgcHJlZml4LlxyXG4gKlxyXG4gKiAgKCoqaS5lLioqIGBgXCJcXFxceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxcXG5cImBgKVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IE1lc3NhZ2VQcmVmaXggPSBcIlxceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuXCI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZ3MuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/constants/strings.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/contract/contract.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/contract/contract.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseContract: () => (/* binding */ BaseContract),\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   copyOverrides: () => (/* binding */ copyOverrides),\n/* harmony export */   resolveArgs: () => (/* binding */ resolveArgs)\n/* harmony export */ });\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../abi/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/index.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _providers_provider_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../providers/provider.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _wrappers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wrappers.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/contract/wrappers.js\");\n\r\n\r\n// import from provider.ts instead of index.ts to prevent circular dep\r\n// from EtherscanProvider\r\n\r\n\r\n\r\nconst BN_0 = BigInt(0);\r\nfunction canCall(value) {\r\n    return (value && typeof (value.call) === \"function\");\r\n}\r\nfunction canEstimate(value) {\r\n    return (value && typeof (value.estimateGas) === \"function\");\r\n}\r\nfunction canResolve(value) {\r\n    return (value && typeof (value.resolveName) === \"function\");\r\n}\r\nfunction canSend(value) {\r\n    return (value && typeof (value.sendTransaction) === \"function\");\r\n}\r\nfunction getResolver(value) {\r\n    if (value != null) {\r\n        if (canResolve(value)) {\r\n            return value;\r\n        }\r\n        if (value.provider) {\r\n            return value.provider;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\nclass PreparedTopicFilter {\r\n    #filter;\r\n    fragment;\r\n    constructor(contract, fragment, args) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { fragment });\r\n        if (fragment.inputs.length < args.length) {\r\n            throw new Error(\"too many arguments\");\r\n        }\r\n        // Recursively descend into args and resolve any addresses\r\n        const runner = getRunner(contract.runner, \"resolveName\");\r\n        const resolver = canResolve(runner) ? runner : null;\r\n        this.#filter = (async function () {\r\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {\r\n                const arg = args[index];\r\n                if (arg == null) {\r\n                    return null;\r\n                }\r\n                return param.walkAsync(args[index], (type, value) => {\r\n                    if (type === \"address\") {\r\n                        if (Array.isArray(value)) {\r\n                            return Promise.all(value.map((v) => (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(v, resolver)));\r\n                        }\r\n                        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(value, resolver);\r\n                    }\r\n                    return value;\r\n                });\r\n            }));\r\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\r\n        })();\r\n    }\r\n    getTopicFilter() {\r\n        return this.#filter;\r\n    }\r\n}\r\n// A = Arguments passed in as a tuple\r\n// R = The result type of the call (i.e. if only one return type,\r\n//     the qualified type, otherwise Result)\r\n// D = The type the default call will return (i.e. R for view/pure,\r\n//     TransactionResponse otherwise)\r\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\r\nfunction getRunner(value, feature) {\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    if (typeof (value[feature]) === \"function\") {\r\n        return value;\r\n    }\r\n    if (value.provider && typeof (value.provider[feature]) === \"function\") {\r\n        return value.provider;\r\n    }\r\n    return null;\r\n}\r\nfunction getProvider(value) {\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    return value.provider || null;\r\n}\r\n/**\r\n *  @_ignore:\r\n */\r\nasync function copyOverrides(arg, allowed) {\r\n    // Make sure the overrides passed in are a valid overrides object\r\n    const _overrides = _abi_index_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(arg, \"overrides\");\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (_overrides) === \"object\", \"invalid overrides parameter\", \"overrides\", arg);\r\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\r\n    const overrides = (0,_providers_provider_js__WEBPACK_IMPORTED_MODULE_3__.copyRequest)(_overrides);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(overrides.to == null || (allowed || []).indexOf(\"to\") >= 0, \"cannot override to\", \"overrides.to\", overrides.to);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(overrides.data == null || (allowed || []).indexOf(\"data\") >= 0, \"cannot override data\", \"overrides.data\", overrides.data);\r\n    // Resolve any from\r\n    if (overrides.from) {\r\n        overrides.from = overrides.from;\r\n    }\r\n    return overrides;\r\n}\r\n/**\r\n *  @_ignore:\r\n */\r\nasync function resolveArgs(_runner, inputs, args) {\r\n    // Recursively descend into args and resolve any addresses\r\n    const runner = getRunner(_runner, \"resolveName\");\r\n    const resolver = canResolve(runner) ? runner : null;\r\n    return await Promise.all(inputs.map((param, index) => {\r\n        return param.walkAsync(args[index], (type, value) => {\r\n            value = _abi_index_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(value, type);\r\n            if (type === \"address\") {\r\n                return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(value, resolver);\r\n            }\r\n            return value;\r\n        });\r\n    }));\r\n}\r\nfunction buildWrappedFallback(contract) {\r\n    const populateTransaction = async function (overrides) {\r\n        // If an overrides was passed in, copy it and normalize the values\r\n        const tx = (await copyOverrides(overrides, [\"data\"]));\r\n        tx.to = await contract.getAddress();\r\n        if (tx.from) {\r\n            tx.from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(tx.from, getResolver(contract.runner));\r\n        }\r\n        const iface = contract.interface;\r\n        const noValue = ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)((tx.value || BN_0), \"overrides.value\") === BN_0);\r\n        const noData = ((tx.data || \"0x\") === \"0x\");\r\n        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\r\n        // Only allow payable contracts to set non-zero value\r\n        const payable = iface.receive || (iface.fallback && iface.fallback.payable);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(payable || noValue, \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\r\n        // Only allow fallback contracts to set non-empty data\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\r\n        return tx;\r\n    };\r\n    const staticCall = async function (overrides) {\r\n        const runner = getRunner(contract.runner, \"call\");\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\r\n        const tx = await populateTransaction(overrides);\r\n        try {\r\n            return await runner.call(tx);\r\n        }\r\n        catch (error) {\r\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isCallException)(error) && error.data) {\r\n                throw contract.interface.makeError(error.data, tx);\r\n            }\r\n            throw error;\r\n        }\r\n    };\r\n    const send = async function (overrides) {\r\n        const runner = contract.runner;\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\r\n        const tx = await runner.sendTransaction(await populateTransaction(overrides));\r\n        const provider = getProvider(contract.runner);\r\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\r\n        // meaningful error\r\n        return new _wrappers_js__WEBPACK_IMPORTED_MODULE_4__.ContractTransactionResponse(contract.interface, provider, tx);\r\n    };\r\n    const estimateGas = async function (overrides) {\r\n        const runner = getRunner(contract.runner, \"estimateGas\");\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\r\n        return await runner.estimateGas(await populateTransaction(overrides));\r\n    };\r\n    const method = async (overrides) => {\r\n        return await send(overrides);\r\n    };\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\r\n        _contract: contract,\r\n        estimateGas,\r\n        populateTransaction,\r\n        send, staticCall\r\n    });\r\n    return method;\r\n}\r\nfunction buildWrappedMethod(contract, key) {\r\n    const getFragment = function (...args) {\r\n        const fragment = contract.interface.getFunction(key, args);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\r\n            operation: \"fragment\",\r\n            info: { key, args }\r\n        });\r\n        return fragment;\r\n    };\r\n    const populateTransaction = async function (...args) {\r\n        const fragment = getFragment(...args);\r\n        // If an overrides was passed in, copy it and normalize the values\r\n        let overrides = {};\r\n        if (fragment.inputs.length + 1 === args.length) {\r\n            overrides = await copyOverrides(args.pop());\r\n            if (overrides.from) {\r\n                overrides.from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(overrides.from, getResolver(contract.runner));\r\n            }\r\n        }\r\n        if (fragment.inputs.length !== args.length) {\r\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\r\n        }\r\n        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\r\n        return Object.assign({}, overrides, await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\r\n            to: contract.getAddress(),\r\n            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\r\n        }));\r\n    };\r\n    const staticCall = async function (...args) {\r\n        const result = await staticCallResult(...args);\r\n        if (result.length === 1) {\r\n            return result[0];\r\n        }\r\n        return result;\r\n    };\r\n    const send = async function (...args) {\r\n        const runner = contract.runner;\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\r\n        const tx = await runner.sendTransaction(await populateTransaction(...args));\r\n        const provider = getProvider(contract.runner);\r\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\r\n        // meaningful error\r\n        return new _wrappers_js__WEBPACK_IMPORTED_MODULE_4__.ContractTransactionResponse(contract.interface, provider, tx);\r\n    };\r\n    const estimateGas = async function (...args) {\r\n        const runner = getRunner(contract.runner, \"estimateGas\");\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\r\n        return await runner.estimateGas(await populateTransaction(...args));\r\n    };\r\n    const staticCallResult = async function (...args) {\r\n        const runner = getRunner(contract.runner, \"call\");\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\r\n        const tx = await populateTransaction(...args);\r\n        let result = \"0x\";\r\n        try {\r\n            result = await runner.call(tx);\r\n        }\r\n        catch (error) {\r\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isCallException)(error) && error.data) {\r\n                throw contract.interface.makeError(error.data, tx);\r\n            }\r\n            throw error;\r\n        }\r\n        const fragment = getFragment(...args);\r\n        return contract.interface.decodeFunctionResult(fragment, result);\r\n    };\r\n    const method = async (...args) => {\r\n        const fragment = getFragment(...args);\r\n        if (fragment.constant) {\r\n            return await staticCall(...args);\r\n        }\r\n        return await send(...args);\r\n    };\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\r\n        name: contract.interface.getFunctionName(key),\r\n        _contract: contract, _key: key,\r\n        getFragment,\r\n        estimateGas,\r\n        populateTransaction,\r\n        send, staticCall, staticCallResult,\r\n    });\r\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\r\n    Object.defineProperty(method, \"fragment\", {\r\n        configurable: false,\r\n        enumerable: true,\r\n        get: () => {\r\n            const fragment = contract.interface.getFunction(key);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\r\n                operation: \"fragment\",\r\n                info: { key }\r\n            });\r\n            return fragment;\r\n        }\r\n    });\r\n    return method;\r\n}\r\nfunction buildWrappedEvent(contract, key) {\r\n    const getFragment = function (...args) {\r\n        const fragment = contract.interface.getEvent(key, args);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\r\n            operation: \"fragment\",\r\n            info: { key, args }\r\n        });\r\n        return fragment;\r\n    };\r\n    const method = function (...args) {\r\n        return new PreparedTopicFilter(contract, getFragment(...args), args);\r\n    };\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\r\n        name: contract.interface.getEventName(key),\r\n        _contract: contract, _key: key,\r\n        getFragment\r\n    });\r\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\r\n    Object.defineProperty(method, \"fragment\", {\r\n        configurable: false,\r\n        enumerable: true,\r\n        get: () => {\r\n            const fragment = contract.interface.getEvent(key);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\r\n                operation: \"fragment\",\r\n                info: { key }\r\n            });\r\n            return fragment;\r\n        }\r\n    });\r\n    return method;\r\n}\r\n// The combination of TypeScrype, Private Fields and Proxies makes\r\n// the world go boom; so we hide variables with some trickery keeping\r\n// a symbol attached to each BaseContract which its sub-class (even\r\n// via a Proxy) can reach and use to look up its internal values.\r\nconst internal = Symbol.for(\"_ethersInternal_contract\");\r\nconst internalValues = new WeakMap();\r\nfunction setInternal(contract, values) {\r\n    internalValues.set(contract[internal], values);\r\n}\r\nfunction getInternal(contract) {\r\n    return internalValues.get(contract[internal]);\r\n}\r\nfunction isDeferred(value) {\r\n    return (value && typeof (value) === \"object\" && (\"getTopicFilter\" in value) &&\r\n        (typeof (value.getTopicFilter) === \"function\") && value.fragment);\r\n}\r\nasync function getSubInfo(contract, event) {\r\n    let topics;\r\n    let fragment = null;\r\n    // Convert named events to topicHash and get the fragment for\r\n    // events which need deconstructing.\r\n    if (Array.isArray(event)) {\r\n        const topicHashify = function (name) {\r\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(name, 32)) {\r\n                return name;\r\n            }\r\n            const fragment = contract.interface.getEvent(name);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(fragment, \"unknown fragment\", \"name\", name);\r\n            return fragment.topicHash;\r\n        };\r\n        // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\r\n        topics = event.map((e) => {\r\n            if (e == null) {\r\n                return null;\r\n            }\r\n            if (Array.isArray(e)) {\r\n                return e.map(topicHashify);\r\n            }\r\n            return topicHashify(e);\r\n        });\r\n    }\r\n    else if (event === \"*\") {\r\n        topics = [null];\r\n    }\r\n    else if (typeof (event) === \"string\") {\r\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(event, 32)) {\r\n            // Topic Hash\r\n            topics = [event];\r\n        }\r\n        else {\r\n            // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\r\n            fragment = contract.interface.getEvent(event);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(fragment, \"unknown fragment\", \"event\", event);\r\n            topics = [fragment.topicHash];\r\n        }\r\n    }\r\n    else if (isDeferred(event)) {\r\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\r\n        topics = await event.getTopicFilter();\r\n    }\r\n    else if (\"fragment\" in event) {\r\n        // ContractEvent; e.g. `contract.filter.Transfer`\r\n        fragment = event.fragment;\r\n        topics = [fragment.topicHash];\r\n    }\r\n    else {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unknown event name\", \"event\", event);\r\n    }\r\n    // Normalize topics and sort TopicSets\r\n    topics = topics.map((t) => {\r\n        if (t == null) {\r\n            return null;\r\n        }\r\n        if (Array.isArray(t)) {\r\n            const items = Array.from(new Set(t.map((t) => t.toLowerCase())).values());\r\n            if (items.length === 1) {\r\n                return items[0];\r\n            }\r\n            items.sort();\r\n            return items;\r\n        }\r\n        return t.toLowerCase();\r\n    });\r\n    const tag = topics.map((t) => {\r\n        if (t == null) {\r\n            return \"null\";\r\n        }\r\n        if (Array.isArray(t)) {\r\n            return t.join(\"|\");\r\n        }\r\n        return t;\r\n    }).join(\"&\");\r\n    return { fragment, tag, topics };\r\n}\r\nasync function hasSub(contract, event) {\r\n    const { subs } = getInternal(contract);\r\n    return subs.get((await getSubInfo(contract, event)).tag) || null;\r\n}\r\nasync function getSub(contract, operation, event) {\r\n    // Make sure our runner can actually subscribe to events\r\n    const provider = getProvider(contract.runner);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(provider, \"contract runner does not support subscribing\", \"UNSUPPORTED_OPERATION\", { operation });\r\n    const { fragment, tag, topics } = await getSubInfo(contract, event);\r\n    const { addr, subs } = getInternal(contract);\r\n    let sub = subs.get(tag);\r\n    if (!sub) {\r\n        const address = (addr ? addr : contract);\r\n        const filter = { address, topics };\r\n        const listener = (log) => {\r\n            let foundFragment = fragment;\r\n            if (foundFragment == null) {\r\n                try {\r\n                    foundFragment = contract.interface.getEvent(log.topics[0]);\r\n                }\r\n                catch (error) { }\r\n            }\r\n            // If fragment is null, we do not deconstruct the args to emit\r\n            if (foundFragment) {\r\n                const _foundFragment = foundFragment;\r\n                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];\r\n                emit(contract, event, args, (listener) => {\r\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_4__.ContractEventPayload(contract, listener, event, _foundFragment, log);\r\n                });\r\n            }\r\n            else {\r\n                emit(contract, event, [], (listener) => {\r\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_4__.ContractUnknownEventPayload(contract, listener, event, log);\r\n                });\r\n            }\r\n        };\r\n        let starting = [];\r\n        const start = () => {\r\n            if (starting.length) {\r\n                return;\r\n            }\r\n            starting.push(provider.on(filter, listener));\r\n        };\r\n        const stop = async () => {\r\n            if (starting.length == 0) {\r\n                return;\r\n            }\r\n            let started = starting;\r\n            starting = [];\r\n            await Promise.all(started);\r\n            provider.off(filter, listener);\r\n        };\r\n        sub = { tag, listeners: [], start, stop };\r\n        subs.set(tag, sub);\r\n    }\r\n    return sub;\r\n}\r\n// We use this to ensure one emit resolves before firing the next to\r\n// ensure correct ordering (note this cannot throw and just adds the\r\n// notice to the event queu using setTimeout).\r\nlet lastEmit = Promise.resolve();\r\nasync function _emit(contract, event, args, payloadFunc) {\r\n    await lastEmit;\r\n    const sub = await hasSub(contract, event);\r\n    if (!sub) {\r\n        return false;\r\n    }\r\n    const count = sub.listeners.length;\r\n    sub.listeners = sub.listeners.filter(({ listener, once }) => {\r\n        const passArgs = Array.from(args);\r\n        if (payloadFunc) {\r\n            passArgs.push(payloadFunc(once ? null : listener));\r\n        }\r\n        try {\r\n            listener.call(contract, ...passArgs);\r\n        }\r\n        catch (error) { }\r\n        return !once;\r\n    });\r\n    if (sub.listeners.length === 0) {\r\n        sub.stop();\r\n        getInternal(contract).subs.delete(sub.tag);\r\n    }\r\n    return (count > 0);\r\n}\r\nasync function emit(contract, event, args, payloadFunc) {\r\n    try {\r\n        await lastEmit;\r\n    }\r\n    catch (error) { }\r\n    const resultPromise = _emit(contract, event, args, payloadFunc);\r\n    lastEmit = resultPromise;\r\n    return await resultPromise;\r\n}\r\nconst passProperties = [\"then\"];\r\nclass BaseContract {\r\n    /**\r\n     *  The target to connect to.\r\n     *\r\n     *  This can be an address, ENS name or any [[Addressable]], such as\r\n     *  another contract. To get the resovled address, use the ``getAddress``\r\n     *  method.\r\n     */\r\n    target;\r\n    /**\r\n     *  The contract Interface.\r\n     */\r\n    interface;\r\n    /**\r\n     *  The connected runner. This is generally a [[Provider]] or a\r\n     *  [[Signer]], which dictates what operations are supported.\r\n     *\r\n     *  For example, a **Contract** connected to a [[Provider]] may\r\n     *  only execute read-only operations.\r\n     */\r\n    runner;\r\n    /**\r\n     *  All the Events available on this contract.\r\n     */\r\n    filters;\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    [internal];\r\n    /**\r\n     *  The fallback or receive function if any.\r\n     */\r\n    fallback;\r\n    /**\r\n     *  Creates a new contract connected to %%target%% with the %%abi%% and\r\n     *  optionally connected to a %%runner%% to perform operations on behalf\r\n     *  of.\r\n     */\r\n    constructor(target, abi, runner, _deployTx) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (target) === \"string\" || (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.isAddressable)(target), \"invalid value for Contract target\", \"target\", target);\r\n        if (runner == null) {\r\n            runner = null;\r\n        }\r\n        const iface = _abi_index_js__WEBPACK_IMPORTED_MODULE_2__.Interface.from(abi);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { target, runner, interface: iface });\r\n        Object.defineProperty(this, internal, { value: {} });\r\n        let addrPromise;\r\n        let addr = null;\r\n        let deployTx = null;\r\n        if (_deployTx) {\r\n            const provider = getProvider(runner);\r\n            // @TODO: the provider can be null; make a custom dummy provider that will throw a\r\n            // meaningful error\r\n            deployTx = new _wrappers_js__WEBPACK_IMPORTED_MODULE_4__.ContractTransactionResponse(this.interface, provider, _deployTx);\r\n        }\r\n        let subs = new Map();\r\n        // Resolve the target as the address\r\n        if (typeof (target) === \"string\") {\r\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(target)) {\r\n                addr = target;\r\n                addrPromise = Promise.resolve(target);\r\n            }\r\n            else {\r\n                const resolver = getRunner(runner, \"resolveName\");\r\n                if (!canResolve(resolver)) {\r\n                    throw (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\r\n                        operation: \"resolveName\"\r\n                    });\r\n                }\r\n                addrPromise = resolver.resolveName(target).then((addr) => {\r\n                    if (addr == null) {\r\n                        throw (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(\"an ENS name used for a contract target must be correctly configured\", \"UNCONFIGURED_NAME\", {\r\n                            value: target\r\n                        });\r\n                    }\r\n                    getInternal(this).addr = addr;\r\n                    return addr;\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            addrPromise = target.getAddress().then((addr) => {\r\n                if (addr == null) {\r\n                    throw new Error(\"TODO\");\r\n                }\r\n                getInternal(this).addr = addr;\r\n                return addr;\r\n            });\r\n        }\r\n        // Set our private values\r\n        setInternal(this, { addrPromise, addr, deployTx, subs });\r\n        // Add the event filters\r\n        const filters = new Proxy({}, {\r\n            get: (target, prop, receiver) => {\r\n                // Pass important checks (like `then` for Promise) through\r\n                if (typeof (prop) === \"symbol\" || passProperties.indexOf(prop) >= 0) {\r\n                    return Reflect.get(target, prop, receiver);\r\n                }\r\n                try {\r\n                    return this.getEvent(prop);\r\n                }\r\n                catch (error) {\r\n                    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\r\n                        throw error;\r\n                    }\r\n                }\r\n                return undefined;\r\n            },\r\n            has: (target, prop) => {\r\n                // Pass important checks (like `then` for Promise) through\r\n                if (passProperties.indexOf(prop) >= 0) {\r\n                    return Reflect.has(target, prop);\r\n                }\r\n                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\r\n            }\r\n        });\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { filters });\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\r\n            fallback: ((iface.receive || iface.fallback) ? (buildWrappedFallback(this)) : null)\r\n        });\r\n        // Return a Proxy that will respond to functions\r\n        return new Proxy(this, {\r\n            get: (target, prop, receiver) => {\r\n                if (typeof (prop) === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\r\n                    return Reflect.get(target, prop, receiver);\r\n                }\r\n                // Undefined properties should return undefined\r\n                try {\r\n                    return target.getFunction(prop);\r\n                }\r\n                catch (error) {\r\n                    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\r\n                        throw error;\r\n                    }\r\n                }\r\n                return undefined;\r\n            },\r\n            has: (target, prop) => {\r\n                if (typeof (prop) === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\r\n                    return Reflect.has(target, prop);\r\n                }\r\n                return target.interface.hasFunction(prop);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     *  Return a new Contract instance with the same target and ABI, but\r\n     *  a different %%runner%%.\r\n     */\r\n    connect(runner) {\r\n        return new BaseContract(this.target, this.interface, runner);\r\n    }\r\n    /**\r\n     *  Return a new Contract instance with the same ABI and runner, but\r\n     *  a different %%target%%.\r\n     */\r\n    attach(target) {\r\n        return new BaseContract(target, this.interface, this.runner);\r\n    }\r\n    /**\r\n     *  Return the resolved address of this Contract.\r\n     */\r\n    async getAddress() { return await getInternal(this).addrPromise; }\r\n    /**\r\n     *  Return the deployed bytecode or null if no bytecode is found.\r\n     */\r\n    async getDeployedCode() {\r\n        const provider = getProvider(this.runner);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(provider, \"runner does not support .provider\", \"UNSUPPORTED_OPERATION\", { operation: \"getDeployedCode\" });\r\n        const code = await provider.getCode(await this.getAddress());\r\n        if (code === \"0x\") {\r\n            return null;\r\n        }\r\n        return code;\r\n    }\r\n    /**\r\n     *  Resolve to this Contract once the bytecode has been deployed, or\r\n     *  resolve immediately if already deployed.\r\n     */\r\n    async waitForDeployment() {\r\n        // We have the deployement transaction; just use that (throws if deployement fails)\r\n        const deployTx = this.deploymentTransaction();\r\n        if (deployTx) {\r\n            await deployTx.wait();\r\n            return this;\r\n        }\r\n        // Check for code\r\n        const code = await this.getDeployedCode();\r\n        if (code != null) {\r\n            return this;\r\n        }\r\n        // Make sure we can subscribe to a provider event\r\n        const provider = getProvider(this.runner);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(provider != null, \"contract runner does not support .provider\", \"UNSUPPORTED_OPERATION\", { operation: \"waitForDeployment\" });\r\n        return new Promise((resolve, reject) => {\r\n            const checkCode = async () => {\r\n                try {\r\n                    const code = await this.getDeployedCode();\r\n                    if (code != null) {\r\n                        return resolve(this);\r\n                    }\r\n                    provider.once(\"block\", checkCode);\r\n                }\r\n                catch (error) {\r\n                    reject(error);\r\n                }\r\n            };\r\n            checkCode();\r\n        });\r\n    }\r\n    /**\r\n     *  Return the transaction used to deploy this contract.\r\n     *\r\n     *  This is only available if this instance was returned from a\r\n     *  [[ContractFactory]].\r\n     */\r\n    deploymentTransaction() {\r\n        return getInternal(this).deployTx;\r\n    }\r\n    /**\r\n     *  Return the function for a given name. This is useful when a contract\r\n     *  method name conflicts with a JavaScript name such as ``prototype`` or\r\n     *  when using a Contract programatically.\r\n     */\r\n    getFunction(key) {\r\n        if (typeof (key) !== \"string\") {\r\n            key = key.format();\r\n        }\r\n        const func = buildWrappedMethod(this, key);\r\n        return func;\r\n    }\r\n    /**\r\n     *  Return the event for a given name. This is useful when a contract\r\n     *  event name conflicts with a JavaScript name such as ``prototype`` or\r\n     *  when using a Contract programatically.\r\n     */\r\n    getEvent(key) {\r\n        if (typeof (key) !== \"string\") {\r\n            key = key.format();\r\n        }\r\n        return buildWrappedEvent(this, key);\r\n    }\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    async queryTransaction(hash) {\r\n        throw new Error(\"@TODO\");\r\n    }\r\n    /*\r\n    // @TODO: this is a non-backwards compatible change, but will be added\r\n    //        in v7 and in a potential SmartContract class in an upcoming\r\n    //        v6 release\r\n    async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {\r\n        const provider = getProvider(this.runner);\r\n        assert(provider, \"contract runner does not have a provider\",\r\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryTransaction\" });\r\n\r\n        const receipt = await provider.getTransactionReceipt(hash);\r\n        if (receipt == null) { return null; }\r\n\r\n        return new ContractTransactionReceipt(this.interface, provider, receipt);\r\n    }\r\n    */\r\n    /**\r\n     *  Provide historic access to event data for %%event%% in the range\r\n     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\r\n     *  inclusive.\r\n     */\r\n    async queryFilter(event, fromBlock, toBlock) {\r\n        if (fromBlock == null) {\r\n            fromBlock = 0;\r\n        }\r\n        if (toBlock == null) {\r\n            toBlock = \"latest\";\r\n        }\r\n        const { addr, addrPromise } = getInternal(this);\r\n        const address = (addr ? addr : (await addrPromise));\r\n        const { fragment, topics } = await getSubInfo(this, event);\r\n        const filter = { address, topics, fromBlock, toBlock };\r\n        const provider = getProvider(this.runner);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(provider, \"contract runner does not have a provider\", \"UNSUPPORTED_OPERATION\", { operation: \"queryFilter\" });\r\n        return (await provider.getLogs(filter)).map((log) => {\r\n            let foundFragment = fragment;\r\n            if (foundFragment == null) {\r\n                try {\r\n                    foundFragment = this.interface.getEvent(log.topics[0]);\r\n                }\r\n                catch (error) { }\r\n            }\r\n            if (foundFragment) {\r\n                try {\r\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_4__.EventLog(log, this.interface, foundFragment);\r\n                }\r\n                catch (error) {\r\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_4__.UndecodedEventLog(log, error);\r\n                }\r\n            }\r\n            return new _providers_provider_js__WEBPACK_IMPORTED_MODULE_3__.Log(log, provider);\r\n        });\r\n    }\r\n    /**\r\n     *  Add an event %%listener%% for the %%event%%.\r\n     */\r\n    async on(event, listener) {\r\n        const sub = await getSub(this, \"on\", event);\r\n        sub.listeners.push({ listener, once: false });\r\n        sub.start();\r\n        return this;\r\n    }\r\n    /**\r\n     *  Add an event %%listener%% for the %%event%%, but remove the listener\r\n     *  after it is fired once.\r\n     */\r\n    async once(event, listener) {\r\n        const sub = await getSub(this, \"once\", event);\r\n        sub.listeners.push({ listener, once: true });\r\n        sub.start();\r\n        return this;\r\n    }\r\n    /**\r\n     *  Emit an %%event%% calling all listeners with %%args%%.\r\n     *\r\n     *  Resolves to ``true`` if any listeners were called.\r\n     */\r\n    async emit(event, ...args) {\r\n        return await emit(this, event, args, null);\r\n    }\r\n    /**\r\n     *  Resolves to the number of listeners of %%event%% or the total number\r\n     *  of listeners if unspecified.\r\n     */\r\n    async listenerCount(event) {\r\n        if (event) {\r\n            const sub = await hasSub(this, event);\r\n            if (!sub) {\r\n                return 0;\r\n            }\r\n            return sub.listeners.length;\r\n        }\r\n        const { subs } = getInternal(this);\r\n        let total = 0;\r\n        for (const { listeners } of subs.values()) {\r\n            total += listeners.length;\r\n        }\r\n        return total;\r\n    }\r\n    /**\r\n     *  Resolves to the listeners subscribed to %%event%% or all listeners\r\n     *  if unspecified.\r\n     */\r\n    async listeners(event) {\r\n        if (event) {\r\n            const sub = await hasSub(this, event);\r\n            if (!sub) {\r\n                return [];\r\n            }\r\n            return sub.listeners.map(({ listener }) => listener);\r\n        }\r\n        const { subs } = getInternal(this);\r\n        let result = [];\r\n        for (const { listeners } of subs.values()) {\r\n            result = result.concat(listeners.map(({ listener }) => listener));\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     *  Remove the %%listener%% from the listeners for %%event%% or remove\r\n     *  all listeners if unspecified.\r\n     */\r\n    async off(event, listener) {\r\n        const sub = await hasSub(this, event);\r\n        if (!sub) {\r\n            return this;\r\n        }\r\n        if (listener) {\r\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\r\n            if (index >= 0) {\r\n                sub.listeners.splice(index, 1);\r\n            }\r\n        }\r\n        if (listener == null || sub.listeners.length === 0) {\r\n            sub.stop();\r\n            getInternal(this).subs.delete(sub.tag);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     *  Remove all the listeners for %%event%% or remove all listeners if\r\n     *  unspecified.\r\n     */\r\n    async removeAllListeners(event) {\r\n        if (event) {\r\n            const sub = await hasSub(this, event);\r\n            if (!sub) {\r\n                return this;\r\n            }\r\n            sub.stop();\r\n            getInternal(this).subs.delete(sub.tag);\r\n        }\r\n        else {\r\n            const { subs } = getInternal(this);\r\n            for (const { tag, stop } of subs.values()) {\r\n                stop();\r\n                subs.delete(tag);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     *  Alias for [on].\r\n     */\r\n    async addListener(event, listener) {\r\n        return await this.on(event, listener);\r\n    }\r\n    /**\r\n     *  Alias for [off].\r\n     */\r\n    async removeListener(event, listener) {\r\n        return await this.off(event, listener);\r\n    }\r\n    /**\r\n     *  Create a new Class for the %%abi%%.\r\n     */\r\n    static buildClass(abi) {\r\n        class CustomContract extends BaseContract {\r\n            constructor(address, runner = null) {\r\n                super(address, abi, runner);\r\n            }\r\n        }\r\n        return CustomContract;\r\n    }\r\n    ;\r\n    /**\r\n     *  Create a new BaseContract with a specified Interface.\r\n     */\r\n    static from(target, abi, runner) {\r\n        if (runner == null) {\r\n            runner = null;\r\n        }\r\n        const contract = new this(target, abi, runner);\r\n        return contract;\r\n    }\r\n}\r\nfunction _ContractBase() {\r\n    return BaseContract;\r\n}\r\n/**\r\n *  A [[BaseContract]] with no type guards on its methods or events.\r\n */\r\nclass Contract extends _ContractBase() {\r\n}\r\n//# sourceMappingURL=contract.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb250cmFjdC9jb250cmFjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBbUQ7QUFDaUI7QUFDcEU7QUFDQTtBQUM0RDtBQUNpRztBQUNqQjtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsVUFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsaUVBQWM7QUFDOUU7QUFDQSwrQkFBK0IsaUVBQWM7QUFDN0M7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSx1QkFBdUIsZ0RBQUs7QUFDNUIsSUFBSSwrREFBYztBQUNsQjtBQUNBLHNCQUFzQixtRUFBVztBQUNqQyxJQUFJLCtEQUFjO0FBQ2xCLElBQUksK0RBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdEQUFLO0FBQ3pCO0FBQ0EsdUJBQXVCLGlFQUFjO0FBQ3JDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qs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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXGNvbnRyYWN0XFxjb250cmFjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnRlcmZhY2UsIFR5cGVkIH0gZnJvbSBcIi4uL2FiaS9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBpc0FkZHJlc3NhYmxlLCByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XHJcbi8vIGltcG9ydCBmcm9tIHByb3ZpZGVyLnRzIGluc3RlYWQgb2YgaW5kZXgudHMgdG8gcHJldmVudCBjaXJjdWxhciBkZXBcclxuLy8gZnJvbSBFdGhlcnNjYW5Qcm92aWRlclxyXG5pbXBvcnQgeyBjb3B5UmVxdWVzdCwgTG9nIH0gZnJvbSBcIi4uL3Byb3ZpZGVycy9wcm92aWRlci5qc1wiO1xyXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGlzQ2FsbEV4Y2VwdGlvbiwgaXNIZXhTdHJpbmcsIHJlc29sdmVQcm9wZXJ0aWVzLCBpc0Vycm9yLCBtYWtlRXJyb3IsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgQ29udHJhY3RFdmVudFBheWxvYWQsIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCwgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlLCBFdmVudExvZywgVW5kZWNvZGVkRXZlbnRMb2cgfSBmcm9tIFwiLi93cmFwcGVycy5qc1wiO1xyXG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xyXG5mdW5jdGlvbiBjYW5DYWxsKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuY2FsbCkgPT09IFwiZnVuY3Rpb25cIik7XHJcbn1cclxuZnVuY3Rpb24gY2FuRXN0aW1hdGUodmFsdWUpIHtcclxuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5lc3RpbWF0ZUdhcykgPT09IFwiZnVuY3Rpb25cIik7XHJcbn1cclxuZnVuY3Rpb24gY2FuUmVzb2x2ZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnJlc29sdmVOYW1lKSA9PT0gXCJmdW5jdGlvblwiKTtcclxufVxyXG5mdW5jdGlvbiBjYW5TZW5kKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuc2VuZFRyYW5zYWN0aW9uKSA9PT0gXCJmdW5jdGlvblwiKTtcclxufVxyXG5mdW5jdGlvbiBnZXRSZXNvbHZlcih2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICBpZiAoY2FuUmVzb2x2ZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUucHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnByb3ZpZGVyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuY2xhc3MgUHJlcGFyZWRUb3BpY0ZpbHRlciB7XHJcbiAgICAjZmlsdGVyO1xyXG4gICAgZnJhZ21lbnQ7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpIHtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZnJhZ21lbnQgfSk7XHJcbiAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggPCBhcmdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbWFueSBhcmd1bWVudHNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGRlc2NlbmQgaW50byBhcmdzIGFuZCByZXNvbHZlIGFueSBhZGRyZXNzZXNcclxuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcInJlc29sdmVOYW1lXCIpO1xyXG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gY2FuUmVzb2x2ZShydW5uZXIpID8gcnVubmVyIDogbnVsbDtcclxuICAgICAgICB0aGlzLiNmaWx0ZXIgPSAoYXN5bmMgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZEFyZ3MgPSBhd2FpdCBQcm9taXNlLmFsbChmcmFnbWVudC5pbnB1dHMubWFwKChwYXJhbSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW0ud2Fsa0FzeW5jKGFyZ3NbaW5kZXhdLCAodHlwZSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodmFsdWUubWFwKCh2KSA9PiByZXNvbHZlQWRkcmVzcyh2LCByZXNvbHZlcikpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUFkZHJlc3ModmFsdWUsIHJlc29sdmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGaWx0ZXJUb3BpY3MoZnJhZ21lbnQsIHJlc29sdmVkQXJncyk7XHJcbiAgICAgICAgfSkoKTtcclxuICAgIH1cclxuICAgIGdldFRvcGljRmlsdGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNmaWx0ZXI7XHJcbiAgICB9XHJcbn1cclxuLy8gQSA9IEFyZ3VtZW50cyBwYXNzZWQgaW4gYXMgYSB0dXBsZVxyXG4vLyBSID0gVGhlIHJlc3VsdCB0eXBlIG9mIHRoZSBjYWxsIChpLmUuIGlmIG9ubHkgb25lIHJldHVybiB0eXBlLFxyXG4vLyAgICAgdGhlIHF1YWxpZmllZCB0eXBlLCBvdGhlcndpc2UgUmVzdWx0KVxyXG4vLyBEID0gVGhlIHR5cGUgdGhlIGRlZmF1bHQgY2FsbCB3aWxsIHJldHVybiAoaS5lLiBSIGZvciB2aWV3L3B1cmUsXHJcbi8vICAgICBUcmFuc2FjdGlvblJlc3BvbnNlIG90aGVyd2lzZSlcclxuLy9leHBvcnQgaW50ZXJmYWNlIENvbnRyYWN0TWV0aG9kPEEgZXh0ZW5kcyBBcnJheTxhbnk+ID0gQXJyYXk8YW55PiwgUiA9IGFueSwgRCBleHRlbmRzIFIgfCBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UgPSBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2U+IHtcclxuZnVuY3Rpb24gZ2V0UnVubmVyKHZhbHVlLCBmZWF0dXJlKSB7XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiAodmFsdWVbZmVhdHVyZV0pID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUucHJvdmlkZXIgJiYgdHlwZW9mICh2YWx1ZS5wcm92aWRlcltmZWF0dXJlXSkgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5wcm92aWRlcjtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIGdldFByb3ZpZGVyKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlLnByb3ZpZGVyIHx8IG51bGw7XHJcbn1cclxuLyoqXHJcbiAqICBAX2lnbm9yZTpcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb3B5T3ZlcnJpZGVzKGFyZywgYWxsb3dlZCkge1xyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBvdmVycmlkZXMgcGFzc2VkIGluIGFyZSBhIHZhbGlkIG92ZXJyaWRlcyBvYmplY3RcclxuICAgIGNvbnN0IF9vdmVycmlkZXMgPSBUeXBlZC5kZXJlZmVyZW5jZShhcmcsIFwib3ZlcnJpZGVzXCIpO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChfb3ZlcnJpZGVzKSA9PT0gXCJvYmplY3RcIiwgXCJpbnZhbGlkIG92ZXJyaWRlcyBwYXJhbWV0ZXJcIiwgXCJvdmVycmlkZXNcIiwgYXJnKTtcclxuICAgIC8vIENyZWF0ZSBhIHNoYWxsb3cgY29weSAod2UnbGwgZGVlcC1pZnkgYW55dGhpbmcgbmVlZGVkIGR1cmluZyBub3JtYWxpemluZylcclxuICAgIGNvbnN0IG92ZXJyaWRlcyA9IGNvcHlSZXF1ZXN0KF9vdmVycmlkZXMpO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQob3ZlcnJpZGVzLnRvID09IG51bGwgfHwgKGFsbG93ZWQgfHwgW10pLmluZGV4T2YoXCJ0b1wiKSA+PSAwLCBcImNhbm5vdCBvdmVycmlkZSB0b1wiLCBcIm92ZXJyaWRlcy50b1wiLCBvdmVycmlkZXMudG8pO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQob3ZlcnJpZGVzLmRhdGEgPT0gbnVsbCB8fCAoYWxsb3dlZCB8fCBbXSkuaW5kZXhPZihcImRhdGFcIikgPj0gMCwgXCJjYW5ub3Qgb3ZlcnJpZGUgZGF0YVwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIG92ZXJyaWRlcy5kYXRhKTtcclxuICAgIC8vIFJlc29sdmUgYW55IGZyb21cclxuICAgIGlmIChvdmVycmlkZXMuZnJvbSkge1xyXG4gICAgICAgIG92ZXJyaWRlcy5mcm9tID0gb3ZlcnJpZGVzLmZyb207XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3ZlcnJpZGVzO1xyXG59XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmU6XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUFyZ3MoX3J1bm5lciwgaW5wdXRzLCBhcmdzKSB7XHJcbiAgICAvLyBSZWN1cnNpdmVseSBkZXNjZW5kIGludG8gYXJncyBhbmQgcmVzb2x2ZSBhbnkgYWRkcmVzc2VzXHJcbiAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoX3J1bm5lciwgXCJyZXNvbHZlTmFtZVwiKTtcclxuICAgIGNvbnN0IHJlc29sdmVyID0gY2FuUmVzb2x2ZShydW5uZXIpID8gcnVubmVyIDogbnVsbDtcclxuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChpbnB1dHMubWFwKChwYXJhbSwgaW5kZXgpID0+IHtcclxuICAgICAgICByZXR1cm4gcGFyYW0ud2Fsa0FzeW5jKGFyZ3NbaW5kZXhdLCAodHlwZSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdmFsdWUgPSBUeXBlZC5kZXJlZmVyZW5jZSh2YWx1ZSwgdHlwZSk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVBZGRyZXNzKHZhbHVlLCByZXNvbHZlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIGJ1aWxkV3JhcHBlZEZhbGxiYWNrKGNvbnRyYWN0KSB7XHJcbiAgICBjb25zdCBwb3B1bGF0ZVRyYW5zYWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xyXG4gICAgICAgIC8vIElmIGFuIG92ZXJyaWRlcyB3YXMgcGFzc2VkIGluLCBjb3B5IGl0IGFuZCBub3JtYWxpemUgdGhlIHZhbHVlc1xyXG4gICAgICAgIGNvbnN0IHR4ID0gKGF3YWl0IGNvcHlPdmVycmlkZXMob3ZlcnJpZGVzLCBbXCJkYXRhXCJdKSk7XHJcbiAgICAgICAgdHgudG8gPSBhd2FpdCBjb250cmFjdC5nZXRBZGRyZXNzKCk7XHJcbiAgICAgICAgaWYgKHR4LmZyb20pIHtcclxuICAgICAgICAgICAgdHguZnJvbSA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHR4LmZyb20sIGdldFJlc29sdmVyKGNvbnRyYWN0LnJ1bm5lcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpZmFjZSA9IGNvbnRyYWN0LmludGVyZmFjZTtcclxuICAgICAgICBjb25zdCBub1ZhbHVlID0gKGdldEJpZ0ludCgodHgudmFsdWUgfHwgQk5fMCksIFwib3ZlcnJpZGVzLnZhbHVlXCIpID09PSBCTl8wKTtcclxuICAgICAgICBjb25zdCBub0RhdGEgPSAoKHR4LmRhdGEgfHwgXCIweFwiKSA9PT0gXCIweFwiKTtcclxuICAgICAgICBpZiAoaWZhY2UuZmFsbGJhY2sgJiYgIWlmYWNlLmZhbGxiYWNrLnBheWFibGUgJiYgaWZhY2UucmVjZWl2ZSAmJiAhbm9EYXRhICYmICFub1ZhbHVlKSB7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImNhbm5vdCBzZW5kIGRhdGEgdG8gcmVjZWl2ZSBvciBzZW5kIHZhbHVlIHRvIG5vbi1wYXlhYmxlIGZhbGxiYWNrXCIsIFwib3ZlcnJpZGVzXCIsIG92ZXJyaWRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGlmYWNlLmZhbGxiYWNrIHx8IG5vRGF0YSwgXCJjYW5ub3Qgc2VuZCBkYXRhIHRvIHJlY2VpdmUtb25seSBjb250cmFjdFwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIHR4LmRhdGEpO1xyXG4gICAgICAgIC8vIE9ubHkgYWxsb3cgcGF5YWJsZSBjb250cmFjdHMgdG8gc2V0IG5vbi16ZXJvIHZhbHVlXHJcbiAgICAgICAgY29uc3QgcGF5YWJsZSA9IGlmYWNlLnJlY2VpdmUgfHwgKGlmYWNlLmZhbGxiYWNrICYmIGlmYWNlLmZhbGxiYWNrLnBheWFibGUpO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHBheWFibGUgfHwgbm9WYWx1ZSwgXCJjYW5ub3Qgc2VuZCB2YWx1ZSB0byBub24tcGF5YWJsZSBmYWxsYmFja1wiLCBcIm92ZXJyaWRlcy52YWx1ZVwiLCB0eC52YWx1ZSk7XHJcbiAgICAgICAgLy8gT25seSBhbGxvdyBmYWxsYmFjayBjb250cmFjdHMgdG8gc2V0IG5vbi1lbXB0eSBkYXRhXHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaWZhY2UuZmFsbGJhY2sgfHwgbm9EYXRhLCBcImNhbm5vdCBzZW5kIGRhdGEgdG8gcmVjZWl2ZS1vbmx5IGNvbnRyYWN0XCIsIFwib3ZlcnJpZGVzLmRhdGFcIiwgdHguZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIHR4O1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHN0YXRpY0NhbGwgPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XHJcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJjYWxsXCIpO1xyXG4gICAgICAgIGFzc2VydChjYW5DYWxsKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgY2FsbGluZ1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJjYWxsXCIgfSk7XHJcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKG92ZXJyaWRlcyk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bm5lci5jYWxsKHR4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0NhbGxFeGNlcHRpb24oZXJyb3IpICYmIGVycm9yLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGNvbnRyYWN0LmludGVyZmFjZS5tYWtlRXJyb3IoZXJyb3IuZGF0YSwgdHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBzZW5kID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xyXG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGNvbnRyYWN0LnJ1bm5lcjtcclxuICAgICAgICBhc3NlcnQoY2FuU2VuZChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IHNlbmRpbmcgdHJhbnNhY3Rpb25zXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiIH0pO1xyXG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcnVubmVyLnNlbmRUcmFuc2FjdGlvbihhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKG92ZXJyaWRlcykpO1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcclxuICAgICAgICAvLyBAVE9ETzogdGhlIHByb3ZpZGVyIGNhbiBiZSBudWxsOyBtYWtlIGEgY3VzdG9tIGR1bW15IHByb3ZpZGVyIHRoYXQgd2lsbCB0aHJvdyBhXHJcbiAgICAgICAgLy8gbWVhbmluZ2Z1bCBlcnJvclxyXG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKGNvbnRyYWN0LmludGVyZmFjZSwgcHJvdmlkZXIsIHR4KTtcclxuICAgIH07XHJcbiAgICBjb25zdCBlc3RpbWF0ZUdhcyA9IGFzeW5jIGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcclxuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImVzdGltYXRlR2FzXCIpO1xyXG4gICAgICAgIGFzc2VydChjYW5Fc3RpbWF0ZShydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGdhcyBlc3RpbWF0aW9uXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImVzdGltYXRlR2FzXCIgfSk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bm5lci5lc3RpbWF0ZUdhcyhhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKG92ZXJyaWRlcykpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IG1ldGhvZCA9IGFzeW5jIChvdmVycmlkZXMpID0+IHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgc2VuZChvdmVycmlkZXMpO1xyXG4gICAgfTtcclxuICAgIGRlZmluZVByb3BlcnRpZXMobWV0aG9kLCB7XHJcbiAgICAgICAgX2NvbnRyYWN0OiBjb250cmFjdCxcclxuICAgICAgICBlc3RpbWF0ZUdhcyxcclxuICAgICAgICBwb3B1bGF0ZVRyYW5zYWN0aW9uLFxyXG4gICAgICAgIHNlbmQsIHN0YXRpY0NhbGxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG1ldGhvZDtcclxufVxyXG5mdW5jdGlvbiBidWlsZFdyYXBwZWRNZXRob2QoY29udHJhY3QsIGtleSkge1xyXG4gICAgY29uc3QgZ2V0RnJhZ21lbnQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEZ1bmN0aW9uKGtleSwgYXJncyk7XHJcbiAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyYWdtZW50XCIsXHJcbiAgICAgICAgICAgIGluZm86IHsga2V5LCBhcmdzIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcG9wdWxhdGVUcmFuc2FjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBnZXRGcmFnbWVudCguLi5hcmdzKTtcclxuICAgICAgICAvLyBJZiBhbiBvdmVycmlkZXMgd2FzIHBhc3NlZCBpbiwgY29weSBpdCBhbmQgbm9ybWFsaXplIHRoZSB2YWx1ZXNcclxuICAgICAgICBsZXQgb3ZlcnJpZGVzID0ge307XHJcbiAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggKyAxID09PSBhcmdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBvdmVycmlkZXMgPSBhd2FpdCBjb3B5T3ZlcnJpZGVzKGFyZ3MucG9wKCkpO1xyXG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVzLmZyb20pIHtcclxuICAgICAgICAgICAgICAgIG92ZXJyaWRlcy5mcm9tID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3Mob3ZlcnJpZGVzLmZyb20sIGdldFJlc29sdmVyKGNvbnRyYWN0LnJ1bm5lcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoICE9PSBhcmdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnRlcm5hbCBlcnJvcjogZnJhZ21lbnQgaW5wdXRzIGRvZXNuJ3QgbWF0Y2ggYXJndW1lbnRzOyBzaG91bGQgbm90IGhhcHBlblwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRBcmdzID0gYXdhaXQgcmVzb2x2ZUFyZ3MoY29udHJhY3QucnVubmVyLCBmcmFnbWVudC5pbnB1dHMsIGFyZ3MpO1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZXMsIGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgdG86IGNvbnRyYWN0LmdldEFkZHJlc3MoKSxcclxuICAgICAgICAgICAgZGF0YTogY29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgcmVzb2x2ZWRBcmdzKVxyXG4gICAgICAgIH0pKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBzdGF0aWNDYWxsID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdGF0aWNDYWxsUmVzdWx0KC4uLmFyZ3MpO1xyXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2VuZCA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgY29uc3QgcnVubmVyID0gY29udHJhY3QucnVubmVyO1xyXG4gICAgICAgIGFzc2VydChjYW5TZW5kKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgc2VuZGluZyB0cmFuc2FjdGlvbnNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwic2VuZFRyYW5zYWN0aW9uXCIgfSk7XHJcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBydW5uZXIuc2VuZFRyYW5zYWN0aW9uKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24oLi4uYXJncykpO1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcclxuICAgICAgICAvLyBAVE9ETzogdGhlIHByb3ZpZGVyIGNhbiBiZSBudWxsOyBtYWtlIGEgY3VzdG9tIGR1bW15IHByb3ZpZGVyIHRoYXQgd2lsbCB0aHJvdyBhXHJcbiAgICAgICAgLy8gbWVhbmluZ2Z1bCBlcnJvclxyXG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKGNvbnRyYWN0LmludGVyZmFjZSwgcHJvdmlkZXIsIHR4KTtcclxuICAgIH07XHJcbiAgICBjb25zdCBlc3RpbWF0ZUdhcyA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJlc3RpbWF0ZUdhc1wiKTtcclxuICAgICAgICBhc3NlcnQoY2FuRXN0aW1hdGUocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBnYXMgZXN0aW1hdGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJlc3RpbWF0ZUdhc1wiIH0pO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBydW5uZXIuZXN0aW1hdGVHYXMoYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbiguLi5hcmdzKSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc3RhdGljQ2FsbFJlc3VsdCA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJjYWxsXCIpO1xyXG4gICAgICAgIGFzc2VydChjYW5DYWxsKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgY2FsbGluZ1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJjYWxsXCIgfSk7XHJcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKC4uLmFyZ3MpO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgcnVubmVyLmNhbGwodHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgaWYgKGlzQ2FsbEV4Y2VwdGlvbihlcnJvcikgJiYgZXJyb3IuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgY29udHJhY3QuaW50ZXJmYWNlLm1ha2VFcnJvcihlcnJvci5kYXRhLCB0eCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZ2V0RnJhZ21lbnQoLi4uYXJncyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgcmVzdWx0KTtcclxuICAgIH07XHJcbiAgICBjb25zdCBtZXRob2QgPSBhc3luYyAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZ2V0RnJhZ21lbnQoLi4uYXJncyk7XHJcbiAgICAgICAgaWYgKGZyYWdtZW50LmNvbnN0YW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBzdGF0aWNDYWxsKC4uLmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXdhaXQgc2VuZCguLi5hcmdzKTtcclxuICAgIH07XHJcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKG1ldGhvZCwge1xyXG4gICAgICAgIG5hbWU6IGNvbnRyYWN0LmludGVyZmFjZS5nZXRGdW5jdGlvbk5hbWUoa2V5KSxcclxuICAgICAgICBfY29udHJhY3Q6IGNvbnRyYWN0LCBfa2V5OiBrZXksXHJcbiAgICAgICAgZ2V0RnJhZ21lbnQsXHJcbiAgICAgICAgZXN0aW1hdGVHYXMsXHJcbiAgICAgICAgcG9wdWxhdGVUcmFuc2FjdGlvbixcclxuICAgICAgICBzZW5kLCBzdGF0aWNDYWxsLCBzdGF0aWNDYWxsUmVzdWx0LFxyXG4gICAgfSk7XHJcbiAgICAvLyBPbmx5IHdvcmtzIG9uIG5vbi1hbWJpZ3VvdXMga2V5cyAocmVmaW5lZCBmcmFnbWVudCBpcyBhbHdheXMgbm9uLWFtYmlndW91cylcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRob2QsIFwiZnJhZ21lbnRcIiwge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RnVuY3Rpb24oa2V5KTtcclxuICAgICAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgaW5mbzogeyBrZXkgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG1ldGhvZDtcclxufVxyXG5mdW5jdGlvbiBidWlsZFdyYXBwZWRFdmVudChjb250cmFjdCwga2V5KSB7XHJcbiAgICBjb25zdCBnZXRGcmFnbWVudCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoa2V5LCBhcmdzKTtcclxuICAgICAgICBhc3NlcnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnJhZ21lbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcclxuICAgICAgICAgICAgaW5mbzogeyBrZXksIGFyZ3MgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcclxuICAgIH07XHJcbiAgICBjb25zdCBtZXRob2QgPSBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlcGFyZWRUb3BpY0ZpbHRlcihjb250cmFjdCwgZ2V0RnJhZ21lbnQoLi4uYXJncyksIGFyZ3MpO1xyXG4gICAgfTtcclxuICAgIGRlZmluZVByb3BlcnRpZXMobWV0aG9kLCB7XHJcbiAgICAgICAgbmFtZTogY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50TmFtZShrZXkpLFxyXG4gICAgICAgIF9jb250cmFjdDogY29udHJhY3QsIF9rZXk6IGtleSxcclxuICAgICAgICBnZXRGcmFnbWVudFxyXG4gICAgfSk7XHJcbiAgICAvLyBPbmx5IHdvcmtzIG9uIG5vbi1hbWJpZ3VvdXMga2V5cyAocmVmaW5lZCBmcmFnbWVudCBpcyBhbHdheXMgbm9uLWFtYmlndW91cylcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRob2QsIFwiZnJhZ21lbnRcIiwge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoa2V5KTtcclxuICAgICAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgaW5mbzogeyBrZXkgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG1ldGhvZDtcclxufVxyXG4vLyBUaGUgY29tYmluYXRpb24gb2YgVHlwZVNjcnlwZSwgUHJpdmF0ZSBGaWVsZHMgYW5kIFByb3hpZXMgbWFrZXNcclxuLy8gdGhlIHdvcmxkIGdvIGJvb207IHNvIHdlIGhpZGUgdmFyaWFibGVzIHdpdGggc29tZSB0cmlja2VyeSBrZWVwaW5nXHJcbi8vIGEgc3ltYm9sIGF0dGFjaGVkIHRvIGVhY2ggQmFzZUNvbnRyYWN0IHdoaWNoIGl0cyBzdWItY2xhc3MgKGV2ZW5cclxuLy8gdmlhIGEgUHJveHkpIGNhbiByZWFjaCBhbmQgdXNlIHRvIGxvb2sgdXAgaXRzIGludGVybmFsIHZhbHVlcy5cclxuY29uc3QgaW50ZXJuYWwgPSBTeW1ib2wuZm9yKFwiX2V0aGVyc0ludGVybmFsX2NvbnRyYWN0XCIpO1xyXG5jb25zdCBpbnRlcm5hbFZhbHVlcyA9IG5ldyBXZWFrTWFwKCk7XHJcbmZ1bmN0aW9uIHNldEludGVybmFsKGNvbnRyYWN0LCB2YWx1ZXMpIHtcclxuICAgIGludGVybmFsVmFsdWVzLnNldChjb250cmFjdFtpbnRlcm5hbF0sIHZhbHVlcyk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0SW50ZXJuYWwoY29udHJhY3QpIHtcclxuICAgIHJldHVybiBpbnRlcm5hbFZhbHVlcy5nZXQoY29udHJhY3RbaW50ZXJuYWxdKTtcclxufVxyXG5mdW5jdGlvbiBpc0RlZmVycmVkKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiICYmIChcImdldFRvcGljRmlsdGVyXCIgaW4gdmFsdWUpICYmXHJcbiAgICAgICAgKHR5cGVvZiAodmFsdWUuZ2V0VG9waWNGaWx0ZXIpID09PSBcImZ1bmN0aW9uXCIpICYmIHZhbHVlLmZyYWdtZW50KTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBnZXRTdWJJbmZvKGNvbnRyYWN0LCBldmVudCkge1xyXG4gICAgbGV0IHRvcGljcztcclxuICAgIGxldCBmcmFnbWVudCA9IG51bGw7XHJcbiAgICAvLyBDb252ZXJ0IG5hbWVkIGV2ZW50cyB0byB0b3BpY0hhc2ggYW5kIGdldCB0aGUgZnJhZ21lbnQgZm9yXHJcbiAgICAvLyBldmVudHMgd2hpY2ggbmVlZCBkZWNvbnN0cnVjdGluZy5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xyXG4gICAgICAgIGNvbnN0IHRvcGljSGFzaGlmeSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhuYW1lLCAzMikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KG5hbWUpO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJ1bmtub3duIGZyYWdtZW50XCIsIFwibmFtZVwiLCBuYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50LnRvcGljSGFzaDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEFycmF5IG9mIFRvcGljcyBhbmQgTmFtZXM7IGUuZy4gYFsgXCIweDEyMzQuLi44OWFiXCIsIFwiVHJhbnNmZXIoYWRkcmVzcylcIiBdYFxyXG4gICAgICAgIHRvcGljcyA9IGV2ZW50Lm1hcCgoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUubWFwKHRvcGljSGFzaGlmeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRvcGljSGFzaGlmeShlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV2ZW50ID09PSBcIipcIikge1xyXG4gICAgICAgIHRvcGljcyA9IFtudWxsXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiAoZXZlbnQpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGV2ZW50LCAzMikpIHtcclxuICAgICAgICAgICAgLy8gVG9waWMgSGFzaFxyXG4gICAgICAgICAgICB0b3BpY3MgPSBbZXZlbnRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTmFtZSBvciBTaWduYXR1cmU7IGUuZy4gYFwiVHJhbnNmZXJcIiwgYFwiVHJhbnNmZXIoYWRkcmVzcylcImBcclxuICAgICAgICAgICAgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJ1bmtub3duIGZyYWdtZW50XCIsIFwiZXZlbnRcIiwgZXZlbnQpO1xyXG4gICAgICAgICAgICB0b3BpY3MgPSBbZnJhZ21lbnQudG9waWNIYXNoXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0RlZmVycmVkKGV2ZW50KSkge1xyXG4gICAgICAgIC8vIERlZmVycmVkIFRvcGljIEZpbHRlcjsgZS5nLiBgY29udHJhY3QuZmlsdGVyLlRyYW5zZmVyKGZyb20pYFxyXG4gICAgICAgIHRvcGljcyA9IGF3YWl0IGV2ZW50LmdldFRvcGljRmlsdGVyKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChcImZyYWdtZW50XCIgaW4gZXZlbnQpIHtcclxuICAgICAgICAvLyBDb250cmFjdEV2ZW50OyBlLmcuIGBjb250cmFjdC5maWx0ZXIuVHJhbnNmZXJgXHJcbiAgICAgICAgZnJhZ21lbnQgPSBldmVudC5mcmFnbWVudDtcclxuICAgICAgICB0b3BpY3MgPSBbZnJhZ21lbnQudG9waWNIYXNoXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVua25vd24gZXZlbnQgbmFtZVwiLCBcImV2ZW50XCIsIGV2ZW50KTtcclxuICAgIH1cclxuICAgIC8vIE5vcm1hbGl6ZSB0b3BpY3MgYW5kIHNvcnQgVG9waWNTZXRzXHJcbiAgICB0b3BpY3MgPSB0b3BpY3MubWFwKCh0KSA9PiB7XHJcbiAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcclxuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5mcm9tKG5ldyBTZXQodC5tYXAoKHQpID0+IHQudG9Mb3dlckNhc2UoKSkpLnZhbHVlcygpKTtcclxuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGl0ZW1zLnNvcnQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCB0YWcgPSB0b3BpY3MubWFwKCh0KSA9PiB7XHJcbiAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0LmpvaW4oXCJ8XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH0pLmpvaW4oXCImXCIpO1xyXG4gICAgcmV0dXJuIHsgZnJhZ21lbnQsIHRhZywgdG9waWNzIH07XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gaGFzU3ViKGNvbnRyYWN0LCBldmVudCkge1xyXG4gICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbChjb250cmFjdCk7XHJcbiAgICByZXR1cm4gc3Vicy5nZXQoKGF3YWl0IGdldFN1YkluZm8oY29udHJhY3QsIGV2ZW50KSkudGFnKSB8fCBudWxsO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGdldFN1Yihjb250cmFjdCwgb3BlcmF0aW9uLCBldmVudCkge1xyXG4gICAgLy8gTWFrZSBzdXJlIG91ciBydW5uZXIgY2FuIGFjdHVhbGx5IHN1YnNjcmliZSB0byBldmVudHNcclxuICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcclxuICAgIGFzc2VydChwcm92aWRlciwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBzdWJzY3JpYmluZ1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbiB9KTtcclxuICAgIGNvbnN0IHsgZnJhZ21lbnQsIHRhZywgdG9waWNzIH0gPSBhd2FpdCBnZXRTdWJJbmZvKGNvbnRyYWN0LCBldmVudCk7XHJcbiAgICBjb25zdCB7IGFkZHIsIHN1YnMgfSA9IGdldEludGVybmFsKGNvbnRyYWN0KTtcclxuICAgIGxldCBzdWIgPSBzdWJzLmdldCh0YWcpO1xyXG4gICAgaWYgKCFzdWIpIHtcclxuICAgICAgICBjb25zdCBhZGRyZXNzID0gKGFkZHIgPyBhZGRyIDogY29udHJhY3QpO1xyXG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHsgYWRkcmVzcywgdG9waWNzIH07XHJcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAobG9nKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBmb3VuZEZyYWdtZW50ID0gZnJhZ21lbnQ7XHJcbiAgICAgICAgICAgIGlmIChmb3VuZEZyYWdtZW50ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmRGcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgZnJhZ21lbnQgaXMgbnVsbCwgd2UgZG8gbm90IGRlY29uc3RydWN0IHRoZSBhcmdzIHRvIGVtaXRcclxuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IF9mb3VuZEZyYWdtZW50ID0gZm91bmRGcmFnbWVudDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBmcmFnbWVudCA/IGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgbG9nLmRhdGEsIGxvZy50b3BpY3MpIDogW107XHJcbiAgICAgICAgICAgICAgICBlbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgKGxpc3RlbmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdEV2ZW50UGF5bG9hZChjb250cmFjdCwgbGlzdGVuZXIsIGV2ZW50LCBfZm91bmRGcmFnbWVudCwgbG9nKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZW1pdChjb250cmFjdCwgZXZlbnQsIFtdLCAobGlzdGVuZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZChjb250cmFjdCwgbGlzdGVuZXIsIGV2ZW50LCBsb2cpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBzdGFydGluZyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc3RhcnRpbmcubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RhcnRpbmcucHVzaChwcm92aWRlci5vbihmaWx0ZXIsIGxpc3RlbmVyKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBzdG9wID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc3RhcnRpbmcubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgc3RhcnRlZCA9IHN0YXJ0aW5nO1xyXG4gICAgICAgICAgICBzdGFydGluZyA9IFtdO1xyXG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChzdGFydGVkKTtcclxuICAgICAgICAgICAgcHJvdmlkZXIub2ZmKGZpbHRlciwgbGlzdGVuZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgc3ViID0geyB0YWcsIGxpc3RlbmVyczogW10sIHN0YXJ0LCBzdG9wIH07XHJcbiAgICAgICAgc3Vicy5zZXQodGFnLCBzdWIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN1YjtcclxufVxyXG4vLyBXZSB1c2UgdGhpcyB0byBlbnN1cmUgb25lIGVtaXQgcmVzb2x2ZXMgYmVmb3JlIGZpcmluZyB0aGUgbmV4dCB0b1xyXG4vLyBlbnN1cmUgY29ycmVjdCBvcmRlcmluZyAobm90ZSB0aGlzIGNhbm5vdCB0aHJvdyBhbmQganVzdCBhZGRzIHRoZVxyXG4vLyBub3RpY2UgdG8gdGhlIGV2ZW50IHF1ZXUgdXNpbmcgc2V0VGltZW91dCkuXHJcbmxldCBsYXN0RW1pdCA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG5hc3luYyBmdW5jdGlvbiBfZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIHBheWxvYWRGdW5jKSB7XHJcbiAgICBhd2FpdCBsYXN0RW1pdDtcclxuICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yihjb250cmFjdCwgZXZlbnQpO1xyXG4gICAgaWYgKCFzdWIpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb3VudCA9IHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xyXG4gICAgc3ViLmxpc3RlbmVycyA9IHN1Yi5saXN0ZW5lcnMuZmlsdGVyKCh7IGxpc3RlbmVyLCBvbmNlIH0pID0+IHtcclxuICAgICAgICBjb25zdCBwYXNzQXJncyA9IEFycmF5LmZyb20oYXJncyk7XHJcbiAgICAgICAgaWYgKHBheWxvYWRGdW5jKSB7XHJcbiAgICAgICAgICAgIHBhc3NBcmdzLnB1c2gocGF5bG9hZEZ1bmMob25jZSA/IG51bGwgOiBsaXN0ZW5lcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBsaXN0ZW5lci5jYWxsKGNvbnRyYWN0LCAuLi5wYXNzQXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICAgICAgcmV0dXJuICFvbmNlO1xyXG4gICAgfSk7XHJcbiAgICBpZiAoc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBzdWIuc3RvcCgpO1xyXG4gICAgICAgIGdldEludGVybmFsKGNvbnRyYWN0KS5zdWJzLmRlbGV0ZShzdWIudGFnKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoY291bnQgPiAwKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBlbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgcGF5bG9hZEZ1bmMpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgbGFzdEVtaXQ7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgY29uc3QgcmVzdWx0UHJvbWlzZSA9IF9lbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgcGF5bG9hZEZ1bmMpO1xyXG4gICAgbGFzdEVtaXQgPSByZXN1bHRQcm9taXNlO1xyXG4gICAgcmV0dXJuIGF3YWl0IHJlc3VsdFByb21pc2U7XHJcbn1cclxuY29uc3QgcGFzc1Byb3BlcnRpZXMgPSBbXCJ0aGVuXCJdO1xyXG5leHBvcnQgY2xhc3MgQmFzZUNvbnRyYWN0IHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSB0YXJnZXQgdG8gY29ubmVjdCB0by5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBjYW4gYmUgYW4gYWRkcmVzcywgRU5TIG5hbWUgb3IgYW55IFtbQWRkcmVzc2FibGVdXSwgc3VjaCBhc1xyXG4gICAgICogIGFub3RoZXIgY29udHJhY3QuIFRvIGdldCB0aGUgcmVzb3ZsZWQgYWRkcmVzcywgdXNlIHRoZSBgYGdldEFkZHJlc3NgYFxyXG4gICAgICogIG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgdGFyZ2V0O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGNvbnRyYWN0IEludGVyZmFjZS5cclxuICAgICAqL1xyXG4gICAgaW50ZXJmYWNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGNvbm5lY3RlZCBydW5uZXIuIFRoaXMgaXMgZ2VuZXJhbGx5IGEgW1tQcm92aWRlcl1dIG9yIGFcclxuICAgICAqICBbW1NpZ25lcl1dLCB3aGljaCBkaWN0YXRlcyB3aGF0IG9wZXJhdGlvbnMgYXJlIHN1cHBvcnRlZC5cclxuICAgICAqXHJcbiAgICAgKiAgRm9yIGV4YW1wbGUsIGEgKipDb250cmFjdCoqIGNvbm5lY3RlZCB0byBhIFtbUHJvdmlkZXJdXSBtYXlcclxuICAgICAqICBvbmx5IGV4ZWN1dGUgcmVhZC1vbmx5IG9wZXJhdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIHJ1bm5lcjtcclxuICAgIC8qKlxyXG4gICAgICogIEFsbCB0aGUgRXZlbnRzIGF2YWlsYWJsZSBvbiB0aGlzIGNvbnRyYWN0LlxyXG4gICAgICovXHJcbiAgICBmaWx0ZXJzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIFtpbnRlcm5hbF07XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZmFsbGJhY2sgb3IgcmVjZWl2ZSBmdW5jdGlvbiBpZiBhbnkuXHJcbiAgICAgKi9cclxuICAgIGZhbGxiYWNrO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBjb250cmFjdCBjb25uZWN0ZWQgdG8gJSV0YXJnZXQlJSB3aXRoIHRoZSAlJWFiaSUlIGFuZFxyXG4gICAgICogIG9wdGlvbmFsbHkgY29ubmVjdGVkIHRvIGEgJSVydW5uZXIlJSB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gYmVoYWxmXHJcbiAgICAgKiAgb2YuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgYWJpLCBydW5uZXIsIF9kZXBsb3lUeCkge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodGFyZ2V0KSA9PT0gXCJzdHJpbmdcIiB8fCBpc0FkZHJlc3NhYmxlKHRhcmdldCksIFwiaW52YWxpZCB2YWx1ZSBmb3IgQ29udHJhY3QgdGFyZ2V0XCIsIFwidGFyZ2V0XCIsIHRhcmdldCk7XHJcbiAgICAgICAgaWYgKHJ1bm5lciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJ1bm5lciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGlmYWNlID0gSW50ZXJmYWNlLmZyb20oYWJpKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgdGFyZ2V0LCBydW5uZXIsIGludGVyZmFjZTogaWZhY2UgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiB7fSB9KTtcclxuICAgICAgICBsZXQgYWRkclByb21pc2U7XHJcbiAgICAgICAgbGV0IGFkZHIgPSBudWxsO1xyXG4gICAgICAgIGxldCBkZXBsb3lUeCA9IG51bGw7XHJcbiAgICAgICAgaWYgKF9kZXBsb3lUeCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHJ1bm5lcik7XHJcbiAgICAgICAgICAgIC8vIEBUT0RPOiB0aGUgcHJvdmlkZXIgY2FuIGJlIG51bGw7IG1ha2UgYSBjdXN0b20gZHVtbXkgcHJvdmlkZXIgdGhhdCB3aWxsIHRocm93IGFcclxuICAgICAgICAgICAgLy8gbWVhbmluZ2Z1bCBlcnJvclxyXG4gICAgICAgICAgICBkZXBsb3lUeCA9IG5ldyBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UodGhpcy5pbnRlcmZhY2UsIHByb3ZpZGVyLCBfZGVwbG95VHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc3VicyA9IG5ldyBNYXAoKTtcclxuICAgICAgICAvLyBSZXNvbHZlIHRoZSB0YXJnZXQgYXMgdGhlIGFkZHJlc3NcclxuICAgICAgICBpZiAodHlwZW9mICh0YXJnZXQpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRyID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgYWRkclByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodGFyZ2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gZ2V0UnVubmVyKHJ1bm5lciwgXCJyZXNvbHZlTmFtZVwiKTtcclxuICAgICAgICAgICAgICAgIGlmICghY2FuUmVzb2x2ZShyZXNvbHZlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBtYWtlRXJyb3IoXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBuYW1lIHJlc29sdXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIlxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYWRkclByb21pc2UgPSByZXNvbHZlci5yZXNvbHZlTmFtZSh0YXJnZXQpLnRoZW4oKGFkZHIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG1ha2VFcnJvcihcImFuIEVOUyBuYW1lIHVzZWQgZm9yIGEgY29udHJhY3QgdGFyZ2V0IG11c3QgYmUgY29ycmVjdGx5IGNvbmZpZ3VyZWRcIiwgXCJVTkNPTkZJR1VSRURfTkFNRVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5hZGRyID0gYWRkcjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkcjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhZGRyUHJvbWlzZSA9IHRhcmdldC5nZXRBZGRyZXNzKCkudGhlbigoYWRkcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFkZHIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5hZGRyID0gYWRkcjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhZGRyO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2V0IG91ciBwcml2YXRlIHZhbHVlc1xyXG4gICAgICAgIHNldEludGVybmFsKHRoaXMsIHsgYWRkclByb21pc2UsIGFkZHIsIGRlcGxveVR4LCBzdWJzIH0pO1xyXG4gICAgICAgIC8vIEFkZCB0aGUgZXZlbnQgZmlsdGVyc1xyXG4gICAgICAgIGNvbnN0IGZpbHRlcnMgPSBuZXcgUHJveHkoe30sIHtcclxuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gUGFzcyBpbXBvcnRhbnQgY2hlY2tzIChsaWtlIGB0aGVuYCBmb3IgUHJvbWlzZSkgdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3ltYm9sXCIgfHwgcGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRFdmVudChwcm9wKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFcnJvcihlcnJvciwgXCJJTlZBTElEX0FSR1VNRU5UXCIpIHx8IGVycm9yLmFyZ3VtZW50ICE9PSBcImtleVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gUGFzcyBpbXBvcnRhbnQgY2hlY2tzIChsaWtlIGB0aGVuYCBmb3IgUHJvbWlzZSkgdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgaWYgKHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCkgfHwgdGhpcy5pbnRlcmZhY2UuaGFzRXZlbnQoU3RyaW5nKHByb3ApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBmaWx0ZXJzIH0pO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xyXG4gICAgICAgICAgICBmYWxsYmFjazogKChpZmFjZS5yZWNlaXZlIHx8IGlmYWNlLmZhbGxiYWNrKSA/IChidWlsZFdyYXBwZWRGYWxsYmFjayh0aGlzKSkgOiBudWxsKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFJldHVybiBhIFByb3h5IHRoYXQgd2lsbCByZXNwb25kIHRvIGZ1bmN0aW9uc1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodGhpcywge1xyXG4gICAgICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzeW1ib2xcIiB8fCBwcm9wIGluIHRhcmdldCB8fCBwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBVbmRlZmluZWQgcHJvcGVydGllcyBzaG91bGQgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmdldEZ1bmN0aW9uKHByb3ApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Vycm9yKGVycm9yLCBcIklOVkFMSURfQVJHVU1FTlRcIikgfHwgZXJyb3IuYXJndW1lbnQgIT09IFwia2V5XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGFzOiAodGFyZ2V0LCBwcm9wKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzeW1ib2xcIiB8fCBwcm9wIGluIHRhcmdldCB8fCBwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuaW50ZXJmYWNlLmhhc0Z1bmN0aW9uKHByb3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgQ29udHJhY3QgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSB0YXJnZXQgYW5kIEFCSSwgYnV0XHJcbiAgICAgKiAgYSBkaWZmZXJlbnQgJSVydW5uZXIlJS5cclxuICAgICAqL1xyXG4gICAgY29ubmVjdChydW5uZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJhc2VDb250cmFjdCh0aGlzLnRhcmdldCwgdGhpcy5pbnRlcmZhY2UsIHJ1bm5lcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgQ29udHJhY3QgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBBQkkgYW5kIHJ1bm5lciwgYnV0XHJcbiAgICAgKiAgYSBkaWZmZXJlbnQgJSV0YXJnZXQlJS5cclxuICAgICAqL1xyXG4gICAgYXR0YWNoKHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmFzZUNvbnRyYWN0KHRhcmdldCwgdGhpcy5pbnRlcmZhY2UsIHRoaXMucnVubmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiB0aGUgcmVzb2x2ZWQgYWRkcmVzcyBvZiB0aGlzIENvbnRyYWN0LlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRBZGRyZXNzKCkgeyByZXR1cm4gYXdhaXQgZ2V0SW50ZXJuYWwodGhpcykuYWRkclByb21pc2U7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiB0aGUgZGVwbG95ZWQgYnl0ZWNvZGUgb3IgbnVsbCBpZiBubyBieXRlY29kZSBpcyBmb3VuZC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0RGVwbG95ZWRDb2RlKCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xyXG4gICAgICAgIGFzc2VydChwcm92aWRlciwgXCJydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCAucHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZ2V0RGVwbG95ZWRDb2RlXCIgfSk7XHJcbiAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHByb3ZpZGVyLmdldENvZGUoYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCkpO1xyXG4gICAgICAgIGlmIChjb2RlID09PSBcIjB4XCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2RlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZSB0byB0aGlzIENvbnRyYWN0IG9uY2UgdGhlIGJ5dGVjb2RlIGhhcyBiZWVuIGRlcGxveWVkLCBvclxyXG4gICAgICogIHJlc29sdmUgaW1tZWRpYXRlbHkgaWYgYWxyZWFkeSBkZXBsb3llZC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgd2FpdEZvckRlcGxveW1lbnQoKSB7XHJcbiAgICAgICAgLy8gV2UgaGF2ZSB0aGUgZGVwbG95ZW1lbnQgdHJhbnNhY3Rpb247IGp1c3QgdXNlIHRoYXQgKHRocm93cyBpZiBkZXBsb3llbWVudCBmYWlscylcclxuICAgICAgICBjb25zdCBkZXBsb3lUeCA9IHRoaXMuZGVwbG95bWVudFRyYW5zYWN0aW9uKCk7XHJcbiAgICAgICAgaWYgKGRlcGxveVR4KSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGRlcGxveVR4LndhaXQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENoZWNrIGZvciBjb2RlXHJcbiAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHRoaXMuZ2V0RGVwbG95ZWRDb2RlKCk7XHJcbiAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGNhbiBzdWJzY3JpYmUgdG8gYSBwcm92aWRlciBldmVudFxyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xyXG4gICAgICAgIGFzc2VydChwcm92aWRlciAhPSBudWxsLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IC5wcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJ3YWl0Rm9yRGVwbG95bWVudFwiIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrQ29kZSA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHRoaXMuZ2V0RGVwbG95ZWRDb2RlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub25jZShcImJsb2NrXCIsIGNoZWNrQ29kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjaGVja0NvZGUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiB0aGUgdHJhbnNhY3Rpb24gdXNlZCB0byBkZXBsb3kgdGhpcyBjb250cmFjdC5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBpZiB0aGlzIGluc3RhbmNlIHdhcyByZXR1cm5lZCBmcm9tIGFcclxuICAgICAqICBbW0NvbnRyYWN0RmFjdG9yeV1dLlxyXG4gICAgICovXHJcbiAgICBkZXBsb3ltZW50VHJhbnNhY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsKHRoaXMpLmRlcGxveVR4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBmdW5jdGlvbiBmb3IgYSBnaXZlbiBuYW1lLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgY29udHJhY3RcclxuICAgICAqICBtZXRob2QgbmFtZSBjb25mbGljdHMgd2l0aCBhIEphdmFTY3JpcHQgbmFtZSBzdWNoIGFzIGBgcHJvdG90eXBlYGAgb3JcclxuICAgICAqICB3aGVuIHVzaW5nIGEgQ29udHJhY3QgcHJvZ3JhbWF0aWNhbGx5LlxyXG4gICAgICovXHJcbiAgICBnZXRGdW5jdGlvbihrZXkpIHtcclxuICAgICAgICBpZiAodHlwZW9mIChrZXkpICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIGtleSA9IGtleS5mb3JtYXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZnVuYyA9IGJ1aWxkV3JhcHBlZE1ldGhvZCh0aGlzLCBrZXkpO1xyXG4gICAgICAgIHJldHVybiBmdW5jO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBldmVudCBmb3IgYSBnaXZlbiBuYW1lLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgY29udHJhY3RcclxuICAgICAqICBldmVudCBuYW1lIGNvbmZsaWN0cyB3aXRoIGEgSmF2YVNjcmlwdCBuYW1lIHN1Y2ggYXMgYGBwcm90b3R5cGVgYCBvclxyXG4gICAgICogIHdoZW4gdXNpbmcgYSBDb250cmFjdCBwcm9ncmFtYXRpY2FsbHkuXHJcbiAgICAgKi9cclxuICAgIGdldEV2ZW50KGtleSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgKGtleSkgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAga2V5ID0ga2V5LmZvcm1hdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnVpbGRXcmFwcGVkRXZlbnQodGhpcywga2V5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEBfaWdub3JlOlxyXG4gICAgICovXHJcbiAgICBhc3luYyBxdWVyeVRyYW5zYWN0aW9uKGhhc2gpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAvLyBAVE9ETzogdGhpcyBpcyBhIG5vbi1iYWNrd2FyZHMgY29tcGF0aWJsZSBjaGFuZ2UsIGJ1dCB3aWxsIGJlIGFkZGVkXHJcbiAgICAvLyAgICAgICAgaW4gdjcgYW5kIGluIGEgcG90ZW50aWFsIFNtYXJ0Q29udHJhY3QgY2xhc3MgaW4gYW4gdXBjb21pbmdcclxuICAgIC8vICAgICAgICB2NiByZWxlYXNlXHJcbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaDogc3RyaW5nKTogUHJvbWlzZTxudWxsIHwgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQ+IHtcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcclxuICAgICAgICBhc3NlcnQocHJvdmlkZXIsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IGhhdmUgYSBwcm92aWRlclwiLFxyXG4gICAgICAgICAgICBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJxdWVyeVRyYW5zYWN0aW9uXCIgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XHJcbiAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMuaW50ZXJmYWNlLCBwcm92aWRlciwgcmVjZWlwdCk7XHJcbiAgICB9XHJcbiAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiAgUHJvdmlkZSBoaXN0b3JpYyBhY2Nlc3MgdG8gZXZlbnQgZGF0YSBmb3IgJSVldmVudCUlIGluIHRoZSByYW5nZVxyXG4gICAgICogICUlZnJvbUJsb2NrJSUgKGRlZmF1bHQ6IGBgMGBgKSB0byAlJXRvQmxvY2slJSAoZGVmYXVsdDogYGBcImxhdGVzdFwiYGApXHJcbiAgICAgKiAgaW5jbHVzaXZlLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBxdWVyeUZpbHRlcihldmVudCwgZnJvbUJsb2NrLCB0b0Jsb2NrKSB7XHJcbiAgICAgICAgaWYgKGZyb21CbG9jayA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZyb21CbG9jayA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b0Jsb2NrID09IG51bGwpIHtcclxuICAgICAgICAgICAgdG9CbG9jayA9IFwibGF0ZXN0XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgYWRkciwgYWRkclByb21pc2UgfSA9IGdldEludGVybmFsKHRoaXMpO1xyXG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSAoYWRkciA/IGFkZHIgOiAoYXdhaXQgYWRkclByb21pc2UpKTtcclxuICAgICAgICBjb25zdCB7IGZyYWdtZW50LCB0b3BpY3MgfSA9IGF3YWl0IGdldFN1YkluZm8odGhpcywgZXZlbnQpO1xyXG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHsgYWRkcmVzcywgdG9waWNzLCBmcm9tQmxvY2ssIHRvQmxvY2sgfTtcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcclxuICAgICAgICBhc3NlcnQocHJvdmlkZXIsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IGhhdmUgYSBwcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJxdWVyeUZpbHRlclwiIH0pO1xyXG4gICAgICAgIHJldHVybiAoYXdhaXQgcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpKS5tYXAoKGxvZykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZm91bmRGcmFnbWVudCA9IGZyYWdtZW50O1xyXG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZ21lbnQgPSB0aGlzLmludGVyZmFjZS5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudExvZyhsb2csIHRoaXMuaW50ZXJmYWNlLCBmb3VuZEZyYWdtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5kZWNvZGVkRXZlbnRMb2cobG9nLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2cobG9nLCBwcm92aWRlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBBZGQgYW4gZXZlbnQgJSVsaXN0ZW5lciUlIGZvciB0aGUgJSVldmVudCUlLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBvbihldmVudCwgbGlzdGVuZXIpIHtcclxuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBnZXRTdWIodGhpcywgXCJvblwiLCBldmVudCk7XHJcbiAgICAgICAgc3ViLmxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IGZhbHNlIH0pO1xyXG4gICAgICAgIHN1Yi5zdGFydCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQWRkIGFuIGV2ZW50ICUlbGlzdGVuZXIlJSBmb3IgdGhlICUlZXZlbnQlJSwgYnV0IHJlbW92ZSB0aGUgbGlzdGVuZXJcclxuICAgICAqICBhZnRlciBpdCBpcyBmaXJlZCBvbmNlLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xyXG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGdldFN1Yih0aGlzLCBcIm9uY2VcIiwgZXZlbnQpO1xyXG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiB0cnVlIH0pO1xyXG4gICAgICAgIHN1Yi5zdGFydCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgRW1pdCBhbiAlJWV2ZW50JSUgY2FsbGluZyBhbGwgbGlzdGVuZXJzIHdpdGggJSVhcmdzJSUuXHJcbiAgICAgKlxyXG4gICAgICogIFJlc29sdmVzIHRvIGBgdHJ1ZWBgIGlmIGFueSBsaXN0ZW5lcnMgd2VyZSBjYWxsZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgZW1pdCh0aGlzLCBldmVudCwgYXJncywgbnVsbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBvZiAlJWV2ZW50JSUgb3IgdGhlIHRvdGFsIG51bWJlclxyXG4gICAgICogIG9mIGxpc3RlbmVycyBpZiB1bnNwZWNpZmllZC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgbGlzdGVuZXJDb3VudChldmVudCkge1xyXG4gICAgICAgIGlmIChldmVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xyXG4gICAgICAgICAgICBpZiAoIXN1Yikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKHRoaXMpO1xyXG4gICAgICAgIGxldCB0b3RhbCA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCB7IGxpc3RlbmVycyB9IG9mIHN1YnMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgdG90YWwgKz0gbGlzdGVuZXJzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGxpc3RlbmVycyBzdWJzY3JpYmVkIHRvICUlZXZlbnQlJSBvciBhbGwgbGlzdGVuZXJzXHJcbiAgICAgKiAgaWYgdW5zcGVjaWZpZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGxpc3RlbmVycyhldmVudCkge1xyXG4gICAgICAgIGlmIChldmVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xyXG4gICAgICAgICAgICBpZiAoIXN1Yikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiBzdWJzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQobGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVtb3ZlIHRoZSAlJWxpc3RlbmVyJSUgZnJvbSB0aGUgbGlzdGVuZXJzIGZvciAlJWV2ZW50JSUgb3IgcmVtb3ZlXHJcbiAgICAgKiAgYWxsIGxpc3RlbmVycyBpZiB1bnNwZWNpZmllZC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xyXG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XHJcbiAgICAgICAgaWYgKCFzdWIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKS5pbmRleE9mKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgIHN1Yi5saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCB8fCBzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBzdWIuc3RvcCgpO1xyXG4gICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5zdWJzLmRlbGV0ZShzdWIudGFnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgZm9yICUlZXZlbnQlJSBvciByZW1vdmUgYWxsIGxpc3RlbmVycyBpZlxyXG4gICAgICogIHVuc3BlY2lmaWVkLlxyXG4gICAgICovXHJcbiAgICBhc3luYyByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKHRoaXMsIGV2ZW50KTtcclxuICAgICAgICAgICAgaWYgKCFzdWIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN1Yi5zdG9wKCk7XHJcbiAgICAgICAgICAgIGdldEludGVybmFsKHRoaXMpLnN1YnMuZGVsZXRlKHN1Yi50YWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB7IHRhZywgc3RvcCB9IG9mIHN1YnMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgICAgIHN0b3AoKTtcclxuICAgICAgICAgICAgICAgIHN1YnMuZGVsZXRlKHRhZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBBbGlhcyBmb3IgW29uXS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgYWRkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub24oZXZlbnQsIGxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEFsaWFzIGZvciBbb2ZmXS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGUgYSBuZXcgQ2xhc3MgZm9yIHRoZSAlJWFiaSUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnVpbGRDbGFzcyhhYmkpIHtcclxuICAgICAgICBjbGFzcyBDdXN0b21Db250cmFjdCBleHRlbmRzIEJhc2VDb250cmFjdCB7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHJ1bm5lciA9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHN1cGVyKGFkZHJlc3MsIGFiaSwgcnVubmVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQ3VzdG9tQ29udHJhY3Q7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGUgYSBuZXcgQmFzZUNvbnRyYWN0IHdpdGggYSBzcGVjaWZpZWQgSW50ZXJmYWNlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbSh0YXJnZXQsIGFiaSwgcnVubmVyKSB7XHJcbiAgICAgICAgaWYgKHJ1bm5lciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJ1bm5lciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IHRoaXModGFyZ2V0LCBhYmksIHJ1bm5lcik7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIF9Db250cmFjdEJhc2UoKSB7XHJcbiAgICByZXR1cm4gQmFzZUNvbnRyYWN0O1xyXG59XHJcbi8qKlxyXG4gKiAgQSBbW0Jhc2VDb250cmFjdF1dIHdpdGggbm8gdHlwZSBndWFyZHMgb24gaXRzIG1ldGhvZHMgb3IgZXZlbnRzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENvbnRyYWN0IGV4dGVuZHMgX0NvbnRyYWN0QmFzZSgpIHtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cmFjdC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/contract/contract.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/contract/factory.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/contract/factory.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContractFactory: () => (/* binding */ ContractFactory)\n/* harmony export */ });\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../abi/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/index.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../address/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _contract_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contract.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n\r\n\r\n\r\n\r\n// A = Arguments to the constructor\r\n// I = Interface of deployed contracts\r\n/**\r\n *  A **ContractFactory** is used to deploy a Contract to the blockchain.\r\n */\r\nclass ContractFactory {\r\n    /**\r\n     *  The Contract Interface.\r\n     */\r\n    interface;\r\n    /**\r\n     *  The Contract deployment bytecode. Often called the initcode.\r\n     */\r\n    bytecode;\r\n    /**\r\n     *  The ContractRunner to deploy the Contract as.\r\n     */\r\n    runner;\r\n    /**\r\n     *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,\r\n     *  optionally connected to %%runner%%.\r\n     *\r\n     *  The %%bytecode%% may be the ``bytecode`` property within the\r\n     *  standard Solidity JSON output.\r\n     */\r\n    constructor(abi, bytecode, runner) {\r\n        const iface = _abi_index_js__WEBPACK_IMPORTED_MODULE_0__.Interface.from(abi);\r\n        // Dereference Solidity bytecode objects and allow a missing `0x`-prefix\r\n        if (bytecode instanceof Uint8Array) {\r\n            bytecode = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(bytecode));\r\n        }\r\n        else {\r\n            if (typeof (bytecode) === \"object\") {\r\n                bytecode = bytecode.object;\r\n            }\r\n            if (!bytecode.startsWith(\"0x\")) {\r\n                bytecode = \"0x\" + bytecode;\r\n            }\r\n            bytecode = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(bytecode));\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\r\n            bytecode, interface: iface, runner: (runner || null)\r\n        });\r\n    }\r\n    attach(target) {\r\n        return new _contract_js__WEBPACK_IMPORTED_MODULE_2__.BaseContract(target, this.interface, this.runner);\r\n    }\r\n    /**\r\n     *  Resolves to the transaction to deploy the contract, passing %%args%%\r\n     *  into the constructor.\r\n     */\r\n    async getDeployTransaction(...args) {\r\n        let overrides = {};\r\n        const fragment = this.interface.deploy;\r\n        if (fragment.inputs.length + 1 === args.length) {\r\n            overrides = await (0,_contract_js__WEBPACK_IMPORTED_MODULE_2__.copyOverrides)(args.pop());\r\n        }\r\n        if (fragment.inputs.length !== args.length) {\r\n            throw new Error(\"incorrect number of arguments to constructor\");\r\n        }\r\n        const resolvedArgs = await (0,_contract_js__WEBPACK_IMPORTED_MODULE_2__.resolveArgs)(this.runner, fragment.inputs, args);\r\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);\r\n        return Object.assign({}, overrides, { data });\r\n    }\r\n    /**\r\n     *  Resolves to the Contract deployed by passing %%args%% into the\r\n     *  constructor.\r\n     *\r\n     *  This will resolve to the Contract before it has been deployed to the\r\n     *  network, so the [[BaseContract-waitForDeployment]] should be used before\r\n     *  sending any transactions to it.\r\n     */\r\n    async deploy(...args) {\r\n        const tx = await this.getDeployTransaction(...args);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.runner && typeof (this.runner.sendTransaction) === \"function\", \"factory runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\r\n            operation: \"sendTransaction\"\r\n        });\r\n        const sentTx = await this.runner.sendTransaction(tx);\r\n        const address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getCreateAddress)(sentTx);\r\n        return new _contract_js__WEBPACK_IMPORTED_MODULE_2__.BaseContract(address, this.interface, this.runner, sentTx);\r\n    }\r\n    /**\r\n     *  Return a new **ContractFactory** with the same ABI and bytecode,\r\n     *  but connected to %%runner%%.\r\n     */\r\n    connect(runner) {\r\n        return new ContractFactory(this.interface, this.bytecode, runner);\r\n    }\r\n    /**\r\n     *  Create a new **ContractFactory** from the standard Solidity JSON output.\r\n     */\r\n    static fromSolidity(output, runner) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(output != null, \"bad compiler output\", \"output\", output);\r\n        if (typeof (output) === \"string\") {\r\n            output = JSON.parse(output);\r\n        }\r\n        const abi = output.abi;\r\n        let bytecode = \"\";\r\n        if (output.bytecode) {\r\n            bytecode = output.bytecode;\r\n        }\r\n        else if (output.evm && output.evm.bytecode) {\r\n            bytecode = output.evm.bytecode;\r\n        }\r\n        return new this(abi, bytecode, runner);\r\n    }\r\n}\r\n//# sourceMappingURL=factory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb250cmFjdC9mYWN0b3J5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTRDO0FBQ1c7QUFDaUQ7QUFDL0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvREFBUztBQUMvQjtBQUNBO0FBQ0EsdUJBQXVCLHdEQUFPLENBQUMseURBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBTyxDQUFDLHlEQUFRO0FBQ3ZDO0FBQ0EsUUFBUSxpRUFBZ0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQixzREFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkRBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseURBQVc7QUFDOUMscUJBQXFCLHVEQUFNO0FBQzNCLCtCQUErQixlQUFlLE1BQU07QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBLHdCQUF3QixtRUFBZ0I7QUFDeEMsbUJBQW1CLHNEQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXGNvbnRyYWN0XFxmYWN0b3J5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEludGVyZmFjZSB9IGZyb20gXCIuLi9hYmkvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgZ2V0Q3JlYXRlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGNvbmNhdCwgZGVmaW5lUHJvcGVydGllcywgZ2V0Qnl0ZXMsIGhleGxpZnksIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgQmFzZUNvbnRyYWN0LCBjb3B5T3ZlcnJpZGVzLCByZXNvbHZlQXJncyB9IGZyb20gXCIuL2NvbnRyYWN0LmpzXCI7XHJcbi8vIEEgPSBBcmd1bWVudHMgdG8gdGhlIGNvbnN0cnVjdG9yXHJcbi8vIEkgPSBJbnRlcmZhY2Ugb2YgZGVwbG95ZWQgY29udHJhY3RzXHJcbi8qKlxyXG4gKiAgQSAqKkNvbnRyYWN0RmFjdG9yeSoqIGlzIHVzZWQgdG8gZGVwbG95IGEgQ29udHJhY3QgdG8gdGhlIGJsb2NrY2hhaW4uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ29udHJhY3RGYWN0b3J5IHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBDb250cmFjdCBJbnRlcmZhY2UuXHJcbiAgICAgKi9cclxuICAgIGludGVyZmFjZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBDb250cmFjdCBkZXBsb3ltZW50IGJ5dGVjb2RlLiBPZnRlbiBjYWxsZWQgdGhlIGluaXRjb2RlLlxyXG4gICAgICovXHJcbiAgICBieXRlY29kZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBDb250cmFjdFJ1bm5lciB0byBkZXBsb3kgdGhlIENvbnRyYWN0IGFzLlxyXG4gICAgICovXHJcbiAgICBydW5uZXI7XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGUgYSBuZXcgKipDb250cmFjdEZhY3RvcnkqKiB3aXRoICUlYWJpJSUgYW5kICUlYnl0ZWNvZGUlJSxcclxuICAgICAqICBvcHRpb25hbGx5IGNvbm5lY3RlZCB0byAlJXJ1bm5lciUlLlxyXG4gICAgICpcclxuICAgICAqICBUaGUgJSVieXRlY29kZSUlIG1heSBiZSB0aGUgYGBieXRlY29kZWBgIHByb3BlcnR5IHdpdGhpbiB0aGVcclxuICAgICAqICBzdGFuZGFyZCBTb2xpZGl0eSBKU09OIG91dHB1dC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYWJpLCBieXRlY29kZSwgcnVubmVyKSB7XHJcbiAgICAgICAgY29uc3QgaWZhY2UgPSBJbnRlcmZhY2UuZnJvbShhYmkpO1xyXG4gICAgICAgIC8vIERlcmVmZXJlbmNlIFNvbGlkaXR5IGJ5dGVjb2RlIG9iamVjdHMgYW5kIGFsbG93IGEgbWlzc2luZyBgMHhgLXByZWZpeFxyXG4gICAgICAgIGlmIChieXRlY29kZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcclxuICAgICAgICAgICAgYnl0ZWNvZGUgPSBoZXhsaWZ5KGdldEJ5dGVzKGJ5dGVjb2RlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIChieXRlY29kZSkgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIGJ5dGVjb2RlID0gYnl0ZWNvZGUub2JqZWN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghYnl0ZWNvZGUuc3RhcnRzV2l0aChcIjB4XCIpKSB7XHJcbiAgICAgICAgICAgICAgICBieXRlY29kZSA9IFwiMHhcIiArIGJ5dGVjb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJ5dGVjb2RlID0gaGV4bGlmeShnZXRCeXRlcyhieXRlY29kZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgICAgICAgICAgYnl0ZWNvZGUsIGludGVyZmFjZTogaWZhY2UsIHJ1bm5lcjogKHJ1bm5lciB8fCBudWxsKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYXR0YWNoKHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmFzZUNvbnRyYWN0KHRhcmdldCwgdGhpcy5pbnRlcmZhY2UsIHRoaXMucnVubmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiB0byBkZXBsb3kgdGhlIGNvbnRyYWN0LCBwYXNzaW5nICUlYXJncyUlXHJcbiAgICAgKiAgaW50byB0aGUgY29uc3RydWN0b3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldERlcGxveVRyYW5zYWN0aW9uKC4uLmFyZ3MpIHtcclxuICAgICAgICBsZXQgb3ZlcnJpZGVzID0ge307XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmludGVyZmFjZS5kZXBsb3k7XHJcbiAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggKyAxID09PSBhcmdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBvdmVycmlkZXMgPSBhd2FpdCBjb3B5T3ZlcnJpZGVzKGFyZ3MucG9wKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCAhPT0gYXJncy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMgdG8gY29uc3RydWN0b3JcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc29sdmVkQXJncyA9IGF3YWl0IHJlc29sdmVBcmdzKHRoaXMucnVubmVyLCBmcmFnbWVudC5pbnB1dHMsIGFyZ3MpO1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBjb25jYXQoW3RoaXMuYnl0ZWNvZGUsIHRoaXMuaW50ZXJmYWNlLmVuY29kZURlcGxveShyZXNvbHZlZEFyZ3MpXSk7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG92ZXJyaWRlcywgeyBkYXRhIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIENvbnRyYWN0IGRlcGxveWVkIGJ5IHBhc3NpbmcgJSVhcmdzJSUgaW50byB0aGVcclxuICAgICAqICBjb25zdHJ1Y3Rvci5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyB3aWxsIHJlc29sdmUgdG8gdGhlIENvbnRyYWN0IGJlZm9yZSBpdCBoYXMgYmVlbiBkZXBsb3llZCB0byB0aGVcclxuICAgICAqICBuZXR3b3JrLCBzbyB0aGUgW1tCYXNlQ29udHJhY3Qtd2FpdEZvckRlcGxveW1lbnRdXSBzaG91bGQgYmUgdXNlZCBiZWZvcmVcclxuICAgICAqICBzZW5kaW5nIGFueSB0cmFuc2FjdGlvbnMgdG8gaXQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGRlcGxveSguLi5hcmdzKSB7XHJcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLmdldERlcGxveVRyYW5zYWN0aW9uKC4uLmFyZ3MpO1xyXG4gICAgICAgIGFzc2VydCh0aGlzLnJ1bm5lciAmJiB0eXBlb2YgKHRoaXMucnVubmVyLnNlbmRUcmFuc2FjdGlvbikgPT09IFwiZnVuY3Rpb25cIiwgXCJmYWN0b3J5IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IHNlbmRpbmcgdHJhbnNhY3Rpb25zXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3Qgc2VudFR4ID0gYXdhaXQgdGhpcy5ydW5uZXIuc2VuZFRyYW5zYWN0aW9uKHR4KTtcclxuICAgICAgICBjb25zdCBhZGRyZXNzID0gZ2V0Q3JlYXRlQWRkcmVzcyhzZW50VHgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmFzZUNvbnRyYWN0KGFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCB0aGlzLnJ1bm5lciwgc2VudFR4KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyAqKkNvbnRyYWN0RmFjdG9yeSoqIHdpdGggdGhlIHNhbWUgQUJJIGFuZCBieXRlY29kZSxcclxuICAgICAqICBidXQgY29ubmVjdGVkIHRvICUlcnVubmVyJSUuXHJcbiAgICAgKi9cclxuICAgIGNvbm5lY3QocnVubmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdEZhY3RvcnkodGhpcy5pbnRlcmZhY2UsIHRoaXMuYnl0ZWNvZGUsIHJ1bm5lcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGUgYSBuZXcgKipDb250cmFjdEZhY3RvcnkqKiBmcm9tIHRoZSBzdGFuZGFyZCBTb2xpZGl0eSBKU09OIG91dHB1dC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21Tb2xpZGl0eShvdXRwdXQsIHJ1bm5lcikge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KG91dHB1dCAhPSBudWxsLCBcImJhZCBjb21waWxlciBvdXRwdXRcIiwgXCJvdXRwdXRcIiwgb3V0cHV0KTtcclxuICAgICAgICBpZiAodHlwZW9mIChvdXRwdXQpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIG91dHB1dCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWJpID0gb3V0cHV0LmFiaTtcclxuICAgICAgICBsZXQgYnl0ZWNvZGUgPSBcIlwiO1xyXG4gICAgICAgIGlmIChvdXRwdXQuYnl0ZWNvZGUpIHtcclxuICAgICAgICAgICAgYnl0ZWNvZGUgPSBvdXRwdXQuYnl0ZWNvZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG91dHB1dC5ldm0gJiYgb3V0cHV0LmV2bS5ieXRlY29kZSkge1xyXG4gICAgICAgICAgICBieXRlY29kZSA9IG91dHB1dC5ldm0uYnl0ZWNvZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhhYmksIGJ5dGVjb2RlLCBydW5uZXIpO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZhY3RvcnkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/contract/factory.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/contract/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/contract/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseContract: () => (/* reexport safe */ _contract_js__WEBPACK_IMPORTED_MODULE_0__.BaseContract),\n/* harmony export */   Contract: () => (/* reexport safe */ _contract_js__WEBPACK_IMPORTED_MODULE_0__.Contract),\n/* harmony export */   ContractEventPayload: () => (/* reexport safe */ _wrappers_js__WEBPACK_IMPORTED_MODULE_2__.ContractEventPayload),\n/* harmony export */   ContractFactory: () => (/* reexport safe */ _factory_js__WEBPACK_IMPORTED_MODULE_1__.ContractFactory),\n/* harmony export */   ContractTransactionReceipt: () => (/* reexport safe */ _wrappers_js__WEBPACK_IMPORTED_MODULE_2__.ContractTransactionReceipt),\n/* harmony export */   ContractTransactionResponse: () => (/* reexport safe */ _wrappers_js__WEBPACK_IMPORTED_MODULE_2__.ContractTransactionResponse),\n/* harmony export */   ContractUnknownEventPayload: () => (/* reexport safe */ _wrappers_js__WEBPACK_IMPORTED_MODULE_2__.ContractUnknownEventPayload),\n/* harmony export */   EventLog: () => (/* reexport safe */ _wrappers_js__WEBPACK_IMPORTED_MODULE_2__.EventLog),\n/* harmony export */   UndecodedEventLog: () => (/* reexport safe */ _wrappers_js__WEBPACK_IMPORTED_MODULE_2__.UndecodedEventLog)\n/* harmony export */ });\n/* harmony import */ var _contract_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contract.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./factory.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/contract/factory.js\");\n/* harmony import */ var _wrappers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wrappers.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/contract/wrappers.js\");\n/**\r\n *  A **Contract** object is a meta-class (a class whose definition is\r\n *  defined at runtime), which communicates with a deployed smart contract\r\n *  on the blockchain and provides a simple JavaScript interface to call\r\n *  methods, send transaction, query historic logs and listen for its events.\r\n *\r\n *  @_section: api/contract:Contracts  [about-contracts]\r\n */\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb250cmFjdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VEO0FBQ1I7QUFDeUg7QUFDeEsiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcY29udHJhY3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgQSAqKkNvbnRyYWN0Kiogb2JqZWN0IGlzIGEgbWV0YS1jbGFzcyAoYSBjbGFzcyB3aG9zZSBkZWZpbml0aW9uIGlzXHJcbiAqICBkZWZpbmVkIGF0IHJ1bnRpbWUpLCB3aGljaCBjb21tdW5pY2F0ZXMgd2l0aCBhIGRlcGxveWVkIHNtYXJ0IGNvbnRyYWN0XHJcbiAqICBvbiB0aGUgYmxvY2tjaGFpbiBhbmQgcHJvdmlkZXMgYSBzaW1wbGUgSmF2YVNjcmlwdCBpbnRlcmZhY2UgdG8gY2FsbFxyXG4gKiAgbWV0aG9kcywgc2VuZCB0cmFuc2FjdGlvbiwgcXVlcnkgaGlzdG9yaWMgbG9ncyBhbmQgbGlzdGVuIGZvciBpdHMgZXZlbnRzLlxyXG4gKlxyXG4gKiAgQF9zZWN0aW9uOiBhcGkvY29udHJhY3Q6Q29udHJhY3RzICBbYWJvdXQtY29udHJhY3RzXVxyXG4gKi9cclxuZXhwb3J0IHsgQmFzZUNvbnRyYWN0LCBDb250cmFjdCB9IGZyb20gXCIuL2NvbnRyYWN0LmpzXCI7XHJcbmV4cG9ydCB7IENvbnRyYWN0RmFjdG9yeSB9IGZyb20gXCIuL2ZhY3RvcnkuanNcIjtcclxuZXhwb3J0IHsgQ29udHJhY3RFdmVudFBheWxvYWQsIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCwgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQsIENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSwgRXZlbnRMb2csIFVuZGVjb2RlZEV2ZW50TG9nIH0gZnJvbSBcIi4vd3JhcHBlcnMuanNcIjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/contract/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/contract/wrappers.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/contract/wrappers.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContractEventPayload: () => (/* binding */ ContractEventPayload),\n/* harmony export */   ContractTransactionReceipt: () => (/* binding */ ContractTransactionReceipt),\n/* harmony export */   ContractTransactionResponse: () => (/* binding */ ContractTransactionResponse),\n/* harmony export */   ContractUnknownEventPayload: () => (/* binding */ ContractUnknownEventPayload),\n/* harmony export */   EventLog: () => (/* binding */ EventLog),\n/* harmony export */   UndecodedEventLog: () => (/* binding */ UndecodedEventLog)\n/* harmony export */ });\n/* harmony import */ var _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../providers/provider.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n// import from provider.ts instead of index.ts to prevent circular dep\r\n// from EtherscanProvider\r\n\r\n\r\n/**\r\n *  An **EventLog** contains additional properties parsed from the [[Log]].\r\n */\r\nclass EventLog extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.Log {\r\n    /**\r\n     *  The Contract Interface.\r\n     */\r\n    interface;\r\n    /**\r\n     *  The matching event.\r\n     */\r\n    fragment;\r\n    /**\r\n     *  The parsed arguments passed to the event by ``emit``.\r\n     */\r\n    args;\r\n    /**\r\n     * @_ignore:\r\n     */\r\n    constructor(log, iface, fragment) {\r\n        super(log, log.provider);\r\n        const args = iface.decodeEventLog(fragment, log.data, log.topics);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { args, fragment, interface: iface });\r\n    }\r\n    /**\r\n     *  The name of the event.\r\n     */\r\n    get eventName() { return this.fragment.name; }\r\n    /**\r\n     *  The signature of the event.\r\n     */\r\n    get eventSignature() { return this.fragment.format(); }\r\n}\r\n/**\r\n *  An **EventLog** contains additional properties parsed from the [[Log]].\r\n */\r\nclass UndecodedEventLog extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.Log {\r\n    /**\r\n     *  The error encounted when trying to decode the log.\r\n     */\r\n    error;\r\n    /**\r\n     * @_ignore:\r\n     */\r\n    constructor(log, error) {\r\n        super(log, log.provider);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { error });\r\n    }\r\n}\r\n/**\r\n *  A **ContractTransactionReceipt** includes the parsed logs from a\r\n *  [[TransactionReceipt]].\r\n */\r\nclass ContractTransactionReceipt extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.TransactionReceipt {\r\n    #iface;\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    constructor(iface, provider, tx) {\r\n        super(tx, provider);\r\n        this.#iface = iface;\r\n    }\r\n    /**\r\n     *  The parsed logs for any [[Log]] which has a matching event in the\r\n     *  Contract ABI.\r\n     */\r\n    get logs() {\r\n        return super.logs.map((log) => {\r\n            const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;\r\n            if (fragment) {\r\n                try {\r\n                    return new EventLog(log, this.#iface, fragment);\r\n                }\r\n                catch (error) {\r\n                    return new UndecodedEventLog(log, error);\r\n                }\r\n            }\r\n            return log;\r\n        });\r\n    }\r\n}\r\n/**\r\n *  A **ContractTransactionResponse** will return a\r\n *  [[ContractTransactionReceipt]] when waited on.\r\n */\r\nclass ContractTransactionResponse extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.TransactionResponse {\r\n    #iface;\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    constructor(iface, provider, tx) {\r\n        super(tx, provider);\r\n        this.#iface = iface;\r\n    }\r\n    /**\r\n     *  Resolves once this transaction has been mined and has\r\n     *  %%confirms%% blocks including it (default: ``1``) with an\r\n     *  optional %%timeout%%.\r\n     *\r\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\r\n     *  and the transaction has not been mined, otherwise this will\r\n     *  wait until enough confirmations have completed.\r\n     */\r\n    async wait(confirms, timeout) {\r\n        const receipt = await super.wait(confirms, timeout);\r\n        if (receipt == null) {\r\n            return null;\r\n        }\r\n        return new ContractTransactionReceipt(this.#iface, this.provider, receipt);\r\n    }\r\n}\r\n/**\r\n *  A **ContractUnknownEventPayload** is included as the last parameter to\r\n *  Contract Events when the event does not match any events in the ABI.\r\n */\r\nclass ContractUnknownEventPayload extends _utils_index_js__WEBPACK_IMPORTED_MODULE_1__.EventPayload {\r\n    /**\r\n     *  The log with no matching events.\r\n     */\r\n    log;\r\n    /**\r\n     *  @_event:\r\n     */\r\n    constructor(contract, listener, filter, log) {\r\n        super(contract, listener, filter);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { log });\r\n    }\r\n    /**\r\n     *  Resolves to the block the event occured in.\r\n     */\r\n    async getBlock() {\r\n        return await this.log.getBlock();\r\n    }\r\n    /**\r\n     *  Resolves to the transaction the event occured in.\r\n     */\r\n    async getTransaction() {\r\n        return await this.log.getTransaction();\r\n    }\r\n    /**\r\n     *  Resolves to the transaction receipt the event occured in.\r\n     */\r\n    async getTransactionReceipt() {\r\n        return await this.log.getTransactionReceipt();\r\n    }\r\n}\r\n/**\r\n *  A **ContractEventPayload** is included as the last parameter to\r\n *  Contract Events when the event is known.\r\n */\r\nclass ContractEventPayload extends ContractUnknownEventPayload {\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    constructor(contract, listener, filter, fragment, _log) {\r\n        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));\r\n        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { args, fragment });\r\n    }\r\n    /**\r\n     *  The event name.\r\n     */\r\n    get eventName() {\r\n        return this.fragment.name;\r\n    }\r\n    /**\r\n     *  The event signature.\r\n     */\r\n    get eventSignature() {\r\n        return this.fragment.format();\r\n    }\r\n}\r\n//# sourceMappingURL=wrappers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb250cmFjdC93cmFwcGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDd0Y7QUFDckI7QUFDbkU7QUFDQTtBQUNBO0FBQ08sdUJBQXVCLHVEQUFHO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsa0NBQWtDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQyx1REFBRztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFnQixTQUFTLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08seUNBQXlDLHNFQUFrQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMENBQTBDLHVFQUFtQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMENBQTBDLHlEQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxjb250cmFjdFxcd3JhcHBlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaW1wb3J0IGZyb20gcHJvdmlkZXIudHMgaW5zdGVhZCBvZiBpbmRleC50cyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcFxyXG4vLyBmcm9tIEV0aGVyc2NhblByb3ZpZGVyXHJcbmltcG9ydCB7IExvZywgVHJhbnNhY3Rpb25SZWNlaXB0LCBUcmFuc2FjdGlvblJlc3BvbnNlIH0gZnJvbSBcIi4uL3Byb3ZpZGVycy9wcm92aWRlci5qc1wiO1xyXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBFdmVudFBheWxvYWQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuLyoqXHJcbiAqICBBbiAqKkV2ZW50TG9nKiogY29udGFpbnMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHBhcnNlZCBmcm9tIHRoZSBbW0xvZ11dLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEV2ZW50TG9nIGV4dGVuZHMgTG9nIHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBDb250cmFjdCBJbnRlcmZhY2UuXHJcbiAgICAgKi9cclxuICAgIGludGVyZmFjZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBtYXRjaGluZyBldmVudC5cclxuICAgICAqL1xyXG4gICAgZnJhZ21lbnQ7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgcGFyc2VkIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGV2ZW50IGJ5IGBgZW1pdGBgLlxyXG4gICAgICovXHJcbiAgICBhcmdzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAX2lnbm9yZTpcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobG9nLCBpZmFjZSwgZnJhZ21lbnQpIHtcclxuICAgICAgICBzdXBlcihsb2csIGxvZy5wcm92aWRlcik7XHJcbiAgICAgICAgY29uc3QgYXJncyA9IGlmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcyk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFyZ3MsIGZyYWdtZW50LCBpbnRlcmZhY2U6IGlmYWNlIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBnZXQgZXZlbnROYW1lKCkgeyByZXR1cm4gdGhpcy5mcmFnbWVudC5uYW1lOyB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgc2lnbmF0dXJlIG9mIHRoZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGV2ZW50U2lnbmF0dXJlKCkgeyByZXR1cm4gdGhpcy5mcmFnbWVudC5mb3JtYXQoKTsgfVxyXG59XHJcbi8qKlxyXG4gKiAgQW4gKipFdmVudExvZyoqIGNvbnRhaW5zIGFkZGl0aW9uYWwgcHJvcGVydGllcyBwYXJzZWQgZnJvbSB0aGUgW1tMb2ddXS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBVbmRlY29kZWRFdmVudExvZyBleHRlbmRzIExvZyB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZXJyb3IgZW5jb3VudGVkIHdoZW4gdHJ5aW5nIHRvIGRlY29kZSB0aGUgbG9nLlxyXG4gICAgICovXHJcbiAgICBlcnJvcjtcclxuICAgIC8qKlxyXG4gICAgICogQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvZywgZXJyb3IpIHtcclxuICAgICAgICBzdXBlcihsb2csIGxvZy5wcm92aWRlcik7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGVycm9yIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgQSAqKkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0KiogaW5jbHVkZXMgdGhlIHBhcnNlZCBsb2dzIGZyb20gYVxyXG4gKiAgW1tUcmFuc2FjdGlvblJlY2VpcHRdXS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCBleHRlbmRzIFRyYW5zYWN0aW9uUmVjZWlwdCB7XHJcbiAgICAjaWZhY2U7XHJcbiAgICAvKipcclxuICAgICAqICBAX2lnbm9yZTpcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaWZhY2UsIHByb3ZpZGVyLCB0eCkge1xyXG4gICAgICAgIHN1cGVyKHR4LCBwcm92aWRlcik7XHJcbiAgICAgICAgdGhpcy4jaWZhY2UgPSBpZmFjZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBwYXJzZWQgbG9ncyBmb3IgYW55IFtbTG9nXV0gd2hpY2ggaGFzIGEgbWF0Y2hpbmcgZXZlbnQgaW4gdGhlXHJcbiAgICAgKiAgQ29udHJhY3QgQUJJLlxyXG4gICAgICovXHJcbiAgICBnZXQgbG9ncygpIHtcclxuICAgICAgICByZXR1cm4gc3VwZXIubG9ncy5tYXAoKGxvZykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGxvZy50b3BpY3MubGVuZ3RoID8gdGhpcy4jaWZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSkgOiBudWxsO1xyXG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudExvZyhsb2csIHRoaXMuI2lmYWNlLCBmcmFnbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVuZGVjb2RlZEV2ZW50TG9nKGxvZywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBsb2c7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBBICoqQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKiogd2lsbCByZXR1cm4gYVxyXG4gKiAgW1tDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdF1dIHdoZW4gd2FpdGVkIG9uLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSBleHRlbmRzIFRyYW5zYWN0aW9uUmVzcG9uc2Uge1xyXG4gICAgI2lmYWNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGlmYWNlLCBwcm92aWRlciwgdHgpIHtcclxuICAgICAgICBzdXBlcih0eCwgcHJvdmlkZXIpO1xyXG4gICAgICAgIHRoaXMuI2lmYWNlID0gaWZhY2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlcyBvbmNlIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQgYW5kIGhhc1xyXG4gICAgICogICUlY29uZmlybXMlJSBibG9ja3MgaW5jbHVkaW5nIGl0IChkZWZhdWx0OiBgYDFgYCkgd2l0aCBhblxyXG4gICAgICogIG9wdGlvbmFsICUldGltZW91dCUlLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGNhbiByZXNvbHZlIHRvIGBgbnVsbGBgIG9ubHkgaWYgJSVjb25maXJtcyUlIGlzIGBgMGBgXHJcbiAgICAgKiAgYW5kIHRoZSB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gbWluZWQsIG90aGVyd2lzZSB0aGlzIHdpbGxcclxuICAgICAqICB3YWl0IHVudGlsIGVub3VnaCBjb25maXJtYXRpb25zIGhhdmUgY29tcGxldGVkLlxyXG4gICAgICovXHJcbiAgICBhc3luYyB3YWl0KGNvbmZpcm1zLCB0aW1lb3V0KSB7XHJcbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHN1cGVyLndhaXQoY29uZmlybXMsIHRpbWVvdXQpO1xyXG4gICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQodGhpcy4jaWZhY2UsIHRoaXMucHJvdmlkZXIsIHJlY2VpcHQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgQSAqKkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCoqIGlzIGluY2x1ZGVkIGFzIHRoZSBsYXN0IHBhcmFtZXRlciB0b1xyXG4gKiAgQ29udHJhY3QgRXZlbnRzIHdoZW4gdGhlIGV2ZW50IGRvZXMgbm90IG1hdGNoIGFueSBldmVudHMgaW4gdGhlIEFCSS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb250cmFjdFVua25vd25FdmVudFBheWxvYWQgZXh0ZW5kcyBFdmVudFBheWxvYWQge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGxvZyB3aXRoIG5vIG1hdGNoaW5nIGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgbG9nO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9ldmVudDpcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIsIGxvZykge1xyXG4gICAgICAgIHN1cGVyKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbG9nIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGJsb2NrIHRoZSBldmVudCBvY2N1cmVkIGluLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRCbG9jaygpIHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2cuZ2V0QmxvY2soKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiB0aGUgZXZlbnQgb2NjdXJlZCBpbi5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9nLmdldFRyYW5zYWN0aW9uKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdCB0aGUgZXZlbnQgb2NjdXJlZCBpbi5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KCkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvZy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEEgKipDb250cmFjdEV2ZW50UGF5bG9hZCoqIGlzIGluY2x1ZGVkIGFzIHRoZSBsYXN0IHBhcmFtZXRlciB0b1xyXG4gKiAgQ29udHJhY3QgRXZlbnRzIHdoZW4gdGhlIGV2ZW50IGlzIGtub3duLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENvbnRyYWN0RXZlbnRQYXlsb2FkIGV4dGVuZHMgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkIHtcclxuICAgIC8qKlxyXG4gICAgICogIEBfaWdub3JlOlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlciwgZnJhZ21lbnQsIF9sb2cpIHtcclxuICAgICAgICBzdXBlcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlciwgbmV3IEV2ZW50TG9nKF9sb2csIGNvbnRyYWN0LmludGVyZmFjZSwgZnJhZ21lbnQpKTtcclxuICAgICAgICBjb25zdCBhcmdzID0gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCB0aGlzLmxvZy5kYXRhLCB0aGlzLmxvZy50b3BpY3MpO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhcmdzLCBmcmFnbWVudCB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICovXHJcbiAgICBnZXQgZXZlbnROYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50Lm5hbWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZXZlbnQgc2lnbmF0dXJlLlxyXG4gICAgICovXHJcbiAgICBnZXQgZXZlbnRTaWduYXR1cmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnQuZm9ybWF0KCk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3JhcHBlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/contract/wrappers.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/crypto-browser.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/crypto-browser.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHash: () => (/* binding */ createHash),\n/* harmony export */   createHmac: () => (/* binding */ createHmac),\n/* harmony export */   pbkdf2Sync: () => (/* binding */ pbkdf2Sync),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/pbkdf2 */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/pbkdf2.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* Browser Crypto Shims */\r\n\r\n\r\n\r\n\r\n\r\nfunction getGlobal() {\r\n    if (typeof self !== 'undefined') {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined') {\r\n        return window;\r\n    }\r\n    if (typeof global !== 'undefined') {\r\n        return global;\r\n    }\r\n    throw new Error('unable to locate global object');\r\n}\r\n;\r\nconst anyGlobal = getGlobal();\r\nconst crypto = anyGlobal.crypto || anyGlobal.msCrypto;\r\nfunction createHash(algo) {\r\n    switch (algo) {\r\n        case \"sha256\": return _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256.create();\r\n        case \"sha512\": return _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512.create();\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"invalid hashing algorithm name\", \"algorithm\", algo);\r\n}\r\nfunction createHmac(_algo, key) {\r\n    const algo = ({ sha256: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256, sha512: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512 }[_algo]);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(algo != null, \"invalid hmac algorithm\", \"algorithm\", _algo);\r\n    return _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_3__.hmac.create(algo, key);\r\n}\r\nfunction pbkdf2Sync(password, salt, iterations, keylen, _algo) {\r\n    const algo = ({ sha256: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256, sha512: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512 }[_algo]);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(algo != null, \"invalid pbkdf2 algorithm\", \"algorithm\", _algo);\r\n    return (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__.pbkdf2)(algo, password, salt, { c: iterations, dkLen: keylen });\r\n}\r\nfunction randomBytes(length) {\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(crypto != null, \"platform does not support secure random numbers\", \"UNSUPPORTED_OPERATION\", {\r\n        operation: \"randomBytes\"\r\n    });\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(Number.isInteger(length) && length > 0 && length <= 1024, \"invalid length\", \"length\", length);\r\n    const result = new Uint8Array(length);\r\n    crypto.getRandomValues(result);\r\n    return result;\r\n}\r\n//# sourceMappingURL=crypto-browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vY3J5cHRvLWJyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDMEM7QUFDSTtBQUNBO0FBQ0E7QUFDYTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsOEJBQThCLHdEQUFNO0FBQ3BDLDhCQUE4Qix3REFBTTtBQUNwQztBQUNBLElBQUksK0RBQWM7QUFDbEI7QUFDTztBQUNQLG9CQUFvQixNQUFNLGtFQUFRLDREQUFFO0FBQ3BDLElBQUksK0RBQWM7QUFDbEIsV0FBVyxvREFBSTtBQUNmO0FBQ087QUFDUCxvQkFBb0IsTUFBTSxrRUFBUSw0REFBRTtBQUNwQyxJQUFJLCtEQUFjO0FBQ2xCLFdBQVcsNERBQU0seUJBQXlCLDhCQUE4QjtBQUN4RTtBQUNPO0FBQ1AsSUFBSSx1REFBTTtBQUNWO0FBQ0EsS0FBSztBQUNMLElBQUksK0RBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxjcnlwdG9cXGNyeXB0by1icm93c2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIEJyb3dzZXIgQ3J5cHRvIFNoaW1zICovXHJcbmltcG9ydCB7IGhtYWMgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9obWFjXCI7XHJcbmltcG9ydCB7IHBia2RmMiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3Bia2RmMlwiO1xyXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIjtcclxuaW1wb3J0IHsgc2hhNTEyIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhNTEyXCI7XHJcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xyXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWw7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdCcpO1xyXG59XHJcbjtcclxuY29uc3QgYW55R2xvYmFsID0gZ2V0R2xvYmFsKCk7XHJcbmNvbnN0IGNyeXB0byA9IGFueUdsb2JhbC5jcnlwdG8gfHwgYW55R2xvYmFsLm1zQ3J5cHRvO1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaChhbGdvKSB7XHJcbiAgICBzd2l0Y2ggKGFsZ28pIHtcclxuICAgICAgICBjYXNlIFwic2hhMjU2XCI6IHJldHVybiBzaGEyNTYuY3JlYXRlKCk7XHJcbiAgICAgICAgY2FzZSBcInNoYTUxMlwiOiByZXR1cm4gc2hhNTEyLmNyZWF0ZSgpO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBoYXNoaW5nIGFsZ29yaXRobSBuYW1lXCIsIFwiYWxnb3JpdGhtXCIsIGFsZ28pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjKF9hbGdvLCBrZXkpIHtcclxuICAgIGNvbnN0IGFsZ28gPSAoeyBzaGEyNTYsIHNoYTUxMiB9W19hbGdvXSk7XHJcbiAgICBhc3NlcnRBcmd1bWVudChhbGdvICE9IG51bGwsIFwiaW52YWxpZCBobWFjIGFsZ29yaXRobVwiLCBcImFsZ29yaXRobVwiLCBfYWxnbyk7XHJcbiAgICByZXR1cm4gaG1hYy5jcmVhdGUoYWxnbywga2V5KTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcGJrZGYyU3luYyhwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBfYWxnbykge1xyXG4gICAgY29uc3QgYWxnbyA9ICh7IHNoYTI1Niwgc2hhNTEyIH1bX2FsZ29dKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KGFsZ28gIT0gbnVsbCwgXCJpbnZhbGlkIHBia2RmMiBhbGdvcml0aG1cIiwgXCJhbGdvcml0aG1cIiwgX2FsZ28pO1xyXG4gICAgcmV0dXJuIHBia2RmMihhbGdvLCBwYXNzd29yZCwgc2FsdCwgeyBjOiBpdGVyYXRpb25zLCBka0xlbjoga2V5bGVuIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhsZW5ndGgpIHtcclxuICAgIGFzc2VydChjcnlwdG8gIT0gbnVsbCwgXCJwbGF0Zm9ybSBkb2VzIG5vdCBzdXBwb3J0IHNlY3VyZSByYW5kb20gbnVtYmVyc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgb3BlcmF0aW9uOiBcInJhbmRvbUJ5dGVzXCJcclxuICAgIH0pO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcihsZW5ndGgpICYmIGxlbmd0aCA+IDAgJiYgbGVuZ3RoIDw9IDEwMjQsIFwiaW52YWxpZCBsZW5ndGhcIiwgXCJsZW5ndGhcIiwgbGVuZ3RoKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XHJcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJlc3VsdCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by1icm93c2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/crypto-browser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/hmac.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/hmac.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeHmac: () => (/* binding */ computeHmac)\n/* harmony export */ });\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crypto.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/crypto-browser.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/**\r\n *  An **HMAC** enables verification that a given key was used\r\n *  to authenticate a payload.\r\n *\r\n *  See: [[link-wiki-hmac]]\r\n *\r\n *  @_subsection: api/crypto:HMAC  [about-hmac]\r\n */\r\n\r\n\r\nlet locked = false;\r\nconst _computeHmac = function (algorithm, key, data) {\r\n    return (0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.createHmac)(algorithm, key).update(data).digest();\r\n};\r\nlet __computeHmac = _computeHmac;\r\n/**\r\n *  Return the HMAC for %%data%% using the %%key%% key with the underlying\r\n *  %%algo%% used for compression.\r\n *\r\n *  @example:\r\n *    key = id(\"some-secret\")\r\n *\r\n *    // Compute the HMAC\r\n *    computeHmac(\"sha256\", key, \"0x1337\")\r\n *    //_result:\r\n *\r\n *    // To compute the HMAC of UTF-8 data, the data must be\r\n *    // converted to UTF-8 bytes\r\n *    computeHmac(\"sha256\", key, toUtf8Bytes(\"Hello World\"))\r\n *    //_result:\r\n *\r\n */\r\nfunction computeHmac(algorithm, _key, _data) {\r\n    const key = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_key, \"key\");\r\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__computeHmac(algorithm, key, data));\r\n}\r\ncomputeHmac._ = _computeHmac;\r\ncomputeHmac.lock = function () { locked = true; };\r\ncomputeHmac.register = function (func) {\r\n    if (locked) {\r\n        throw new Error(\"computeHmac is locked\");\r\n    }\r\n    __computeHmac = func;\r\n};\r\nObject.freeze(computeHmac);\r\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vaG1hYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lDO0FBQ2E7QUFDdEQ7QUFDQTtBQUNBLFdBQVcsc0RBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGdCQUFnQix5REFBUTtBQUN4QixpQkFBaUIseURBQVE7QUFDekIsV0FBVyx3REFBTztBQUNsQjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcY3J5cHRvXFxobWFjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgQW4gKipITUFDKiogZW5hYmxlcyB2ZXJpZmljYXRpb24gdGhhdCBhIGdpdmVuIGtleSB3YXMgdXNlZFxyXG4gKiAgdG8gYXV0aGVudGljYXRlIGEgcGF5bG9hZC5cclxuICpcclxuICogIFNlZTogW1tsaW5rLXdpa2ktaG1hY11dXHJcbiAqXHJcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86SE1BQyAgW2Fib3V0LWhtYWNdXHJcbiAqL1xyXG5pbXBvcnQgeyBjcmVhdGVIbWFjIH0gZnJvbSBcIi4vY3J5cHRvLmpzXCI7XHJcbmltcG9ydCB7IGdldEJ5dGVzLCBoZXhsaWZ5IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmxldCBsb2NrZWQgPSBmYWxzZTtcclxuY29uc3QgX2NvbXB1dGVIbWFjID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlSG1hYyhhbGdvcml0aG0sIGtleSkudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xyXG59O1xyXG5sZXQgX19jb21wdXRlSG1hYyA9IF9jb21wdXRlSG1hYztcclxuLyoqXHJcbiAqICBSZXR1cm4gdGhlIEhNQUMgZm9yICUlZGF0YSUlIHVzaW5nIHRoZSAlJWtleSUlIGtleSB3aXRoIHRoZSB1bmRlcmx5aW5nXHJcbiAqICAlJWFsZ28lJSB1c2VkIGZvciBjb21wcmVzc2lvbi5cclxuICpcclxuICogIEBleGFtcGxlOlxyXG4gKiAgICBrZXkgPSBpZChcInNvbWUtc2VjcmV0XCIpXHJcbiAqXHJcbiAqICAgIC8vIENvbXB1dGUgdGhlIEhNQUNcclxuICogICAgY29tcHV0ZUhtYWMoXCJzaGEyNTZcIiwga2V5LCBcIjB4MTMzN1wiKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIC8vIFRvIGNvbXB1dGUgdGhlIEhNQUMgb2YgVVRGLTggZGF0YSwgdGhlIGRhdGEgbXVzdCBiZVxyXG4gKiAgICAvLyBjb252ZXJ0ZWQgdG8gVVRGLTggYnl0ZXNcclxuICogICAgY29tcHV0ZUhtYWMoXCJzaGEyNTZcIiwga2V5LCB0b1V0ZjhCeXRlcyhcIkhlbGxvIFdvcmxkXCIpKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhtYWMoYWxnb3JpdGhtLCBfa2V5LCBfZGF0YSkge1xyXG4gICAgY29uc3Qga2V5ID0gZ2V0Qnl0ZXMoX2tleSwgXCJrZXlcIik7XHJcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcclxuICAgIHJldHVybiBoZXhsaWZ5KF9fY29tcHV0ZUhtYWMoYWxnb3JpdGhtLCBrZXksIGRhdGEpKTtcclxufVxyXG5jb21wdXRlSG1hYy5fID0gX2NvbXB1dGVIbWFjO1xyXG5jb21wdXRlSG1hYy5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQgPSB0cnVlOyB9O1xyXG5jb21wdXRlSG1hYy5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XHJcbiAgICBpZiAobG9ja2VkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29tcHV0ZUhtYWMgaXMgbG9ja2VkXCIpO1xyXG4gICAgfVxyXG4gICAgX19jb21wdXRlSG1hYyA9IGZ1bmM7XHJcbn07XHJcbk9iamVjdC5mcmVlemUoY29tcHV0ZUhtYWMpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/hmac.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Signature: () => (/* reexport safe */ _signature_js__WEBPACK_IMPORTED_MODULE_8__.Signature),\n/* harmony export */   SigningKey: () => (/* reexport safe */ _signing_key_js__WEBPACK_IMPORTED_MODULE_7__.SigningKey),\n/* harmony export */   computeHmac: () => (/* reexport safe */ _hmac_js__WEBPACK_IMPORTED_MODULE_0__.computeHmac),\n/* harmony export */   keccak256: () => (/* reexport safe */ _keccak_js__WEBPACK_IMPORTED_MODULE_2__.keccak256),\n/* harmony export */   lock: () => (/* binding */ lock),\n/* harmony export */   pbkdf2: () => (/* reexport safe */ _pbkdf2_js__WEBPACK_IMPORTED_MODULE_5__.pbkdf2),\n/* harmony export */   randomBytes: () => (/* reexport safe */ _random_js__WEBPACK_IMPORTED_MODULE_1__.randomBytes),\n/* harmony export */   ripemd160: () => (/* reexport safe */ _ripemd160_js__WEBPACK_IMPORTED_MODULE_3__.ripemd160),\n/* harmony export */   scrypt: () => (/* reexport safe */ _scrypt_js__WEBPACK_IMPORTED_MODULE_6__.scrypt),\n/* harmony export */   scryptSync: () => (/* reexport safe */ _scrypt_js__WEBPACK_IMPORTED_MODULE_6__.scryptSync),\n/* harmony export */   sha256: () => (/* reexport safe */ _sha2_js__WEBPACK_IMPORTED_MODULE_4__.sha256),\n/* harmony export */   sha512: () => (/* reexport safe */ _sha2_js__WEBPACK_IMPORTED_MODULE_4__.sha512)\n/* harmony export */ });\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hmac.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/hmac.js\");\n/* harmony import */ var _keccak_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keccak.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _ripemd160_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ripemd160.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/ripemd160.js\");\n/* harmony import */ var _pbkdf2_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pbkdf2.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/pbkdf2.js\");\n/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./random.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/random.js\");\n/* harmony import */ var _scrypt_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./scrypt.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/scrypt.js\");\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sha2.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/sha2.js\");\n/* harmony import */ var _signing_key_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./signing-key.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/signing-key.js\");\n/* harmony import */ var _signature_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./signature.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/signature.js\");\n/**\r\n *  A fundamental building block of Ethereum is the underlying\r\n *  cryptographic primitives.\r\n *\r\n *  @_section: api/crypto:Cryptographic Functions   [about-crypto]\r\n */\r\nnull;\r\n// We import all these so we can export lock()\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n *  Once called, prevents any future change to the underlying cryptographic\r\n *  primitives using the ``.register`` feature for hooks.\r\n */\r\nfunction lock() {\r\n    _hmac_js__WEBPACK_IMPORTED_MODULE_0__.computeHmac.lock();\r\n    _keccak_js__WEBPACK_IMPORTED_MODULE_2__.keccak256.lock();\r\n    _pbkdf2_js__WEBPACK_IMPORTED_MODULE_5__.pbkdf2.lock();\r\n    _random_js__WEBPACK_IMPORTED_MODULE_1__.randomBytes.lock();\r\n    _ripemd160_js__WEBPACK_IMPORTED_MODULE_3__.ripemd160.lock();\r\n    _scrypt_js__WEBPACK_IMPORTED_MODULE_6__.scrypt.lock();\r\n    _scrypt_js__WEBPACK_IMPORTED_MODULE_6__.scryptSync.lock();\r\n    _sha2_js__WEBPACK_IMPORTED_MODULE_4__.sha256.lock();\r\n    _sha2_js__WEBPACK_IMPORTED_MODULE_4__.sha512.lock();\r\n    _random_js__WEBPACK_IMPORTED_MODULE_1__.randomBytes.lock();\r\n}\r\n\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN3QztBQUNBO0FBQ0c7QUFDTjtBQUNLO0FBQ087QUFDTjtBQUMyRDtBQUN4RDtBQUNIO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlEQUFXO0FBQ2YsSUFBSSxpREFBUztBQUNiLElBQUksOENBQU07QUFDVixJQUFJLG1EQUFXO0FBQ2YsSUFBSSxvREFBUztBQUNiLElBQUksOENBQU07QUFDVixJQUFJLGtEQUFVO0FBQ2QsSUFBSSw0Q0FBTTtBQUNWLElBQUksNENBQU07QUFDVixJQUFJLG1EQUFXO0FBQ2Y7QUFDZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcY3J5cHRvXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIEEgZnVuZGFtZW50YWwgYnVpbGRpbmcgYmxvY2sgb2YgRXRoZXJldW0gaXMgdGhlIHVuZGVybHlpbmdcclxuICogIGNyeXB0b2dyYXBoaWMgcHJpbWl0aXZlcy5cclxuICpcclxuICogIEBfc2VjdGlvbjogYXBpL2NyeXB0bzpDcnlwdG9ncmFwaGljIEZ1bmN0aW9ucyAgIFthYm91dC1jcnlwdG9dXHJcbiAqL1xyXG5udWxsO1xyXG4vLyBXZSBpbXBvcnQgYWxsIHRoZXNlIHNvIHdlIGNhbiBleHBvcnQgbG9jaygpXHJcbmltcG9ydCB7IGNvbXB1dGVIbWFjIH0gZnJvbSBcIi4vaG1hYy5qc1wiO1xyXG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi9rZWNjYWsuanNcIjtcclxuaW1wb3J0IHsgcmlwZW1kMTYwIH0gZnJvbSBcIi4vcmlwZW1kMTYwLmpzXCI7XHJcbmltcG9ydCB7IHBia2RmMiB9IGZyb20gXCIuL3Bia2RmMi5qc1wiO1xyXG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gXCIuL3JhbmRvbS5qc1wiO1xyXG5pbXBvcnQgeyBzY3J5cHQsIHNjcnlwdFN5bmMgfSBmcm9tIFwiLi9zY3J5cHQuanNcIjtcclxuaW1wb3J0IHsgc2hhMjU2LCBzaGE1MTIgfSBmcm9tIFwiLi9zaGEyLmpzXCI7XHJcbmV4cG9ydCB7IGNvbXB1dGVIbWFjLCByYW5kb21CeXRlcywga2VjY2FrMjU2LCByaXBlbWQxNjAsIHNoYTI1Niwgc2hhNTEyLCBwYmtkZjIsIHNjcnlwdCwgc2NyeXB0U3luYyB9O1xyXG5leHBvcnQgeyBTaWduaW5nS2V5IH0gZnJvbSBcIi4vc2lnbmluZy1rZXkuanNcIjtcclxuZXhwb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4vc2lnbmF0dXJlLmpzXCI7XHJcbi8qKlxyXG4gKiAgT25jZSBjYWxsZWQsIHByZXZlbnRzIGFueSBmdXR1cmUgY2hhbmdlIHRvIHRoZSB1bmRlcmx5aW5nIGNyeXB0b2dyYXBoaWNcclxuICogIHByaW1pdGl2ZXMgdXNpbmcgdGhlIGBgLnJlZ2lzdGVyYGAgZmVhdHVyZSBmb3IgaG9va3MuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2NrKCkge1xyXG4gICAgY29tcHV0ZUhtYWMubG9jaygpO1xyXG4gICAga2VjY2FrMjU2LmxvY2soKTtcclxuICAgIHBia2RmMi5sb2NrKCk7XHJcbiAgICByYW5kb21CeXRlcy5sb2NrKCk7XHJcbiAgICByaXBlbWQxNjAubG9jaygpO1xyXG4gICAgc2NyeXB0LmxvY2soKTtcclxuICAgIHNjcnlwdFN5bmMubG9jaygpO1xyXG4gICAgc2hhMjU2LmxvY2soKTtcclxuICAgIHNoYTUxMi5sb2NrKCk7XHJcbiAgICByYW5kb21CeXRlcy5sb2NrKCk7XHJcbn1cclxuZXhwb3J0IHsgbG9jayB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/keccak.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/keccak.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/**\r\n *  Cryptographic hashing functions\r\n *\r\n *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]\r\n */\r\n\r\n\r\nlet locked = false;\r\nconst _keccak256 = function (data) {\r\n    return (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256)(data);\r\n};\r\nlet __keccak256 = _keccak256;\r\n/**\r\n *  Compute the cryptographic KECCAK256 hash of %%data%%.\r\n *\r\n *  The %%data%% **must** be a data representation, to compute the\r\n *  hash of UTF-8 data use the [[id]] function.\r\n *\r\n *  @returns DataHexstring\r\n *  @example:\r\n *    keccak256(\"0x\")\r\n *    //_result:\r\n *\r\n *    keccak256(\"0x1337\")\r\n *    //_result:\r\n *\r\n *    keccak256(new Uint8Array([ 0x13, 0x37 ]))\r\n *    //_result:\r\n *\r\n *    // Strings are assumed to be DataHexString, otherwise it will\r\n *    // throw. To hash UTF-8 data, see the note above.\r\n *    keccak256(\"Hello World\")\r\n *    //_error:\r\n */\r\nfunction keccak256(_data) {\r\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__keccak256(data));\r\n}\r\nkeccak256._ = _keccak256;\r\nkeccak256.lock = function () { locked = true; };\r\nkeccak256.register = function (func) {\r\n    if (locked) {\r\n        throw new TypeError(\"keccak256 is locked\");\r\n    }\r\n    __keccak256 = func;\r\n};\r\nObject.freeze(keccak256);\r\n//# sourceMappingURL=keccak.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8va2VjY2FrLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZ0Q7QUFDTTtBQUN0RDtBQUNBO0FBQ0EsV0FBVyw4REFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQix5REFBUTtBQUN6QixXQUFXLHdEQUFPO0FBQ2xCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxjcnlwdG9cXGtlY2Nhay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIENyeXB0b2dyYXBoaWMgaGFzaGluZyBmdW5jdGlvbnNcclxuICpcclxuICogIEBfc3Vic2VjdGlvbjogYXBpL2NyeXB0bzpIYXNoIEZ1bmN0aW9ucyBbYWJvdXQtY3J5cHRvLWhhc2hpbmddXHJcbiAqL1xyXG5pbXBvcnQgeyBrZWNjYWtfMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhM1wiO1xyXG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5sZXQgbG9ja2VkID0gZmFsc2U7XHJcbmNvbnN0IF9rZWNjYWsyNTYgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgcmV0dXJuIGtlY2Nha18yNTYoZGF0YSk7XHJcbn07XHJcbmxldCBfX2tlY2NhazI1NiA9IF9rZWNjYWsyNTY7XHJcbi8qKlxyXG4gKiAgQ29tcHV0ZSB0aGUgY3J5cHRvZ3JhcGhpYyBLRUNDQUsyNTYgaGFzaCBvZiAlJWRhdGElJS5cclxuICpcclxuICogIFRoZSAlJWRhdGElJSAqKm11c3QqKiBiZSBhIGRhdGEgcmVwcmVzZW50YXRpb24sIHRvIGNvbXB1dGUgdGhlXHJcbiAqICBoYXNoIG9mIFVURi04IGRhdGEgdXNlIHRoZSBbW2lkXV0gZnVuY3Rpb24uXHJcbiAqXHJcbiAqICBAcmV0dXJucyBEYXRhSGV4c3RyaW5nXHJcbiAqICBAZXhhbXBsZTpcclxuICogICAga2VjY2FrMjU2KFwiMHhcIilcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKlxyXG4gKiAgICBrZWNjYWsyNTYoXCIweDEzMzdcIilcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKlxyXG4gKiAgICBrZWNjYWsyNTYobmV3IFVpbnQ4QXJyYXkoWyAweDEzLCAweDM3IF0pKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIC8vIFN0cmluZ3MgYXJlIGFzc3VtZWQgdG8gYmUgRGF0YUhleFN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGxcclxuICogICAgLy8gdGhyb3cuIFRvIGhhc2ggVVRGLTggZGF0YSwgc2VlIHRoZSBub3RlIGFib3ZlLlxyXG4gKiAgICBrZWNjYWsyNTYoXCJIZWxsbyBXb3JsZFwiKVxyXG4gKiAgICAvL19lcnJvcjpcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWsyNTYoX2RhdGEpIHtcclxuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xyXG4gICAgcmV0dXJuIGhleGxpZnkoX19rZWNjYWsyNTYoZGF0YSkpO1xyXG59XHJcbmtlY2NhazI1Ni5fID0gX2tlY2NhazI1Njtcclxua2VjY2FrMjU2LmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZCA9IHRydWU7IH07XHJcbmtlY2NhazI1Ni5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XHJcbiAgICBpZiAobG9ja2VkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtlY2NhazI1NiBpcyBsb2NrZWRcIik7XHJcbiAgICB9XHJcbiAgICBfX2tlY2NhazI1NiA9IGZ1bmM7XHJcbn07XHJcbk9iamVjdC5mcmVlemUoa2VjY2FrMjU2KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2VjY2FrLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/keccak.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/pbkdf2.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/pbkdf2.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pbkdf2: () => (/* binding */ pbkdf2)\n/* harmony export */ });\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crypto.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/crypto-browser.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/**\r\n *  A **Password-Based Key-Derivation Function** is designed to create\r\n *  a sequence of bytes suitible as a **key** from a human-rememberable\r\n *  password.\r\n *\r\n *  @_subsection: api/crypto:Passwords  [about-pbkdf]\r\n */\r\n\r\n\r\nlet locked = false;\r\nconst _pbkdf2 = function (password, salt, iterations, keylen, algo) {\r\n    return (0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.pbkdf2Sync)(password, salt, iterations, keylen, algo);\r\n};\r\nlet __pbkdf2 = _pbkdf2;\r\n/**\r\n *  Return the [[link-pbkdf2]] for %%keylen%% bytes for %%password%% using\r\n *  the %%salt%% and using %%iterations%% of %%algo%%.\r\n *\r\n *  This PBKDF is outdated and should not be used in new projects, but is\r\n *  required to decrypt older files.\r\n *\r\n *  @example:\r\n *    // The password must be converted to bytes, and it is generally\r\n *    // best practices to ensure the string has been normalized. Many\r\n *    // formats explicitly indicate the normalization form to use.\r\n *    password = \"hello\"\r\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\r\n *\r\n *    salt = id(\"some-salt\")\r\n *\r\n *    // Compute the PBKDF2\r\n *    pbkdf2(passwordBytes, salt, 1024, 16, \"sha256\")\r\n *    //_result:\r\n */\r\nfunction pbkdf2(_password, _salt, iterations, keylen, algo) {\r\n    const password = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_password, \"password\");\r\n    const salt = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_salt, \"salt\");\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__pbkdf2(password, salt, iterations, keylen, algo));\r\n}\r\npbkdf2._ = _pbkdf2;\r\npbkdf2.lock = function () { locked = true; };\r\npbkdf2.register = function (func) {\r\n    if (locked) {\r\n        throw new Error(\"pbkdf2 is locked\");\r\n    }\r\n    __pbkdf2 = func;\r\n};\r\nObject.freeze(pbkdf2);\r\n//# sourceMappingURL=pbkdf2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vcGJrZGYyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lDO0FBQ2E7QUFDdEQ7QUFDQTtBQUNBLFdBQVcsc0RBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHFCQUFxQix5REFBUTtBQUM3QixpQkFBaUIseURBQVE7QUFDekIsV0FBVyx3REFBTztBQUNsQjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcY3J5cHRvXFxwYmtkZjIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqICBBICoqUGFzc3dvcmQtQmFzZWQgS2V5LURlcml2YXRpb24gRnVuY3Rpb24qKiBpcyBkZXNpZ25lZCB0byBjcmVhdGVcclxuICogIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgc3VpdGlibGUgYXMgYSAqKmtleSoqIGZyb20gYSBodW1hbi1yZW1lbWJlcmFibGVcclxuICogIHBhc3N3b3JkLlxyXG4gKlxyXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvY3J5cHRvOlBhc3N3b3JkcyAgW2Fib3V0LXBia2RmXVxyXG4gKi9cclxuaW1wb3J0IHsgcGJrZGYyU3luYyB9IGZyb20gXCIuL2NyeXB0by5qc1wiO1xyXG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5sZXQgbG9ja2VkID0gZmFsc2U7XHJcbmNvbnN0IF9wYmtkZjIgPSBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgYWxnbykge1xyXG4gICAgcmV0dXJuIHBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgYWxnbyk7XHJcbn07XHJcbmxldCBfX3Bia2RmMiA9IF9wYmtkZjI7XHJcbi8qKlxyXG4gKiAgUmV0dXJuIHRoZSBbW2xpbmstcGJrZGYyXV0gZm9yICUla2V5bGVuJSUgYnl0ZXMgZm9yICUlcGFzc3dvcmQlJSB1c2luZ1xyXG4gKiAgdGhlICUlc2FsdCUlIGFuZCB1c2luZyAlJWl0ZXJhdGlvbnMlJSBvZiAlJWFsZ28lJS5cclxuICpcclxuICogIFRoaXMgUEJLREYgaXMgb3V0ZGF0ZWQgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBpbiBuZXcgcHJvamVjdHMsIGJ1dCBpc1xyXG4gKiAgcmVxdWlyZWQgdG8gZGVjcnlwdCBvbGRlciBmaWxlcy5cclxuICpcclxuICogIEBleGFtcGxlOlxyXG4gKiAgICAvLyBUaGUgcGFzc3dvcmQgbXVzdCBiZSBjb252ZXJ0ZWQgdG8gYnl0ZXMsIGFuZCBpdCBpcyBnZW5lcmFsbHlcclxuICogICAgLy8gYmVzdCBwcmFjdGljZXMgdG8gZW5zdXJlIHRoZSBzdHJpbmcgaGFzIGJlZW4gbm9ybWFsaXplZC4gTWFueVxyXG4gKiAgICAvLyBmb3JtYXRzIGV4cGxpY2l0bHkgaW5kaWNhdGUgdGhlIG5vcm1hbGl6YXRpb24gZm9ybSB0byB1c2UuXHJcbiAqICAgIHBhc3N3b3JkID0gXCJoZWxsb1wiXHJcbiAqICAgIHBhc3N3b3JkQnl0ZXMgPSB0b1V0ZjhCeXRlcyhwYXNzd29yZCwgXCJORktDXCIpXHJcbiAqXHJcbiAqICAgIHNhbHQgPSBpZChcInNvbWUtc2FsdFwiKVxyXG4gKlxyXG4gKiAgICAvLyBDb21wdXRlIHRoZSBQQktERjJcclxuICogICAgcGJrZGYyKHBhc3N3b3JkQnl0ZXMsIHNhbHQsIDEwMjQsIDE2LCBcInNoYTI1NlwiKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGJrZGYyKF9wYXNzd29yZCwgX3NhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgYWxnbykge1xyXG4gICAgY29uc3QgcGFzc3dvcmQgPSBnZXRCeXRlcyhfcGFzc3dvcmQsIFwicGFzc3dvcmRcIik7XHJcbiAgICBjb25zdCBzYWx0ID0gZ2V0Qnl0ZXMoX3NhbHQsIFwic2FsdFwiKTtcclxuICAgIHJldHVybiBoZXhsaWZ5KF9fcGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGFsZ28pKTtcclxufVxyXG5wYmtkZjIuXyA9IF9wYmtkZjI7XHJcbnBia2RmMi5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQgPSB0cnVlOyB9O1xyXG5wYmtkZjIucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xyXG4gICAgaWYgKGxvY2tlZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInBia2RmMiBpcyBsb2NrZWRcIik7XHJcbiAgICB9XHJcbiAgICBfX3Bia2RmMiA9IGZ1bmM7XHJcbn07XHJcbk9iamVjdC5mcmVlemUocGJrZGYyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGJrZGYyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/pbkdf2.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/random.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/random.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes)\n/* harmony export */ });\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crypto.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/crypto-browser.js\");\n/**\r\n *  A **Cryptographically Secure Random Value** is one that has been\r\n *  generated with additional care take to prevent side-channels\r\n *  from allowing others to detect it and prevent others from through\r\n *  coincidence generate the same values.\r\n *\r\n *  @_subsection: api/crypto:Random Values  [about-crypto-random]\r\n */\r\n\r\nlet locked = false;\r\nconst _randomBytes = function (length) {\r\n    return new Uint8Array((0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(length));\r\n};\r\nlet __randomBytes = _randomBytes;\r\n/**\r\n *  Return %%length%% bytes of cryptographically secure random data.\r\n *\r\n *  @example:\r\n *    randomBytes(8)\r\n *    //_result:\r\n */\r\nfunction randomBytes(length) {\r\n    return __randomBytes(length);\r\n}\r\nrandomBytes._ = _randomBytes;\r\nrandomBytes.lock = function () { locked = true; };\r\nrandomBytes.register = function (func) {\r\n    if (locked) {\r\n        throw new Error(\"randomBytes is locked\");\r\n    }\r\n    __randomBytes = func;\r\n};\r\nObject.freeze(randomBytes);\r\n//# sourceMappingURL=random.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vcmFuZG9tLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMyRDtBQUMzRDtBQUNBO0FBQ0EsMEJBQTBCLHVEQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcY3J5cHRvXFxyYW5kb20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqICBBICoqQ3J5cHRvZ3JhcGhpY2FsbHkgU2VjdXJlIFJhbmRvbSBWYWx1ZSoqIGlzIG9uZSB0aGF0IGhhcyBiZWVuXHJcbiAqICBnZW5lcmF0ZWQgd2l0aCBhZGRpdGlvbmFsIGNhcmUgdGFrZSB0byBwcmV2ZW50IHNpZGUtY2hhbm5lbHNcclxuICogIGZyb20gYWxsb3dpbmcgb3RoZXJzIHRvIGRldGVjdCBpdCBhbmQgcHJldmVudCBvdGhlcnMgZnJvbSB0aHJvdWdoXHJcbiAqICBjb2luY2lkZW5jZSBnZW5lcmF0ZSB0aGUgc2FtZSB2YWx1ZXMuXHJcbiAqXHJcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86UmFuZG9tIFZhbHVlcyAgW2Fib3V0LWNyeXB0by1yYW5kb21dXHJcbiAqL1xyXG5pbXBvcnQgeyByYW5kb21CeXRlcyBhcyBjcnlwdG9fcmFuZG9tIH0gZnJvbSBcIi4vY3J5cHRvLmpzXCI7XHJcbmxldCBsb2NrZWQgPSBmYWxzZTtcclxuY29uc3QgX3JhbmRvbUJ5dGVzID0gZnVuY3Rpb24gKGxlbmd0aCkge1xyXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNyeXB0b19yYW5kb20obGVuZ3RoKSk7XHJcbn07XHJcbmxldCBfX3JhbmRvbUJ5dGVzID0gX3JhbmRvbUJ5dGVzO1xyXG4vKipcclxuICogIFJldHVybiAlJWxlbmd0aCUlIGJ5dGVzIG9mIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSByYW5kb20gZGF0YS5cclxuICpcclxuICogIEBleGFtcGxlOlxyXG4gKiAgICByYW5kb21CeXRlcyg4KVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMobGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gX19yYW5kb21CeXRlcyhsZW5ndGgpO1xyXG59XHJcbnJhbmRvbUJ5dGVzLl8gPSBfcmFuZG9tQnl0ZXM7XHJcbnJhbmRvbUJ5dGVzLmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZCA9IHRydWU7IH07XHJcbnJhbmRvbUJ5dGVzLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgIGlmIChsb2NrZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYW5kb21CeXRlcyBpcyBsb2NrZWRcIik7XHJcbiAgICB9XHJcbiAgICBfX3JhbmRvbUJ5dGVzID0gZnVuYztcclxufTtcclxuT2JqZWN0LmZyZWV6ZShyYW5kb21CeXRlcyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhbmRvbS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/random.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/ripemd160.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/ripemd160.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/ripemd160.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n\r\n\r\nlet locked = false;\r\nconst _ripemd160 = function (data) {\r\n    return (0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_0__.ripemd160)(data);\r\n};\r\nlet __ripemd160 = _ripemd160;\r\n/**\r\n *  Compute the cryptographic RIPEMD-160 hash of %%data%%.\r\n *\r\n *  @_docloc: api/crypto:Hash Functions\r\n *  @returns DataHexstring\r\n *\r\n *  @example:\r\n *    ripemd160(\"0x\")\r\n *    //_result:\r\n *\r\n *    ripemd160(\"0x1337\")\r\n *    //_result:\r\n *\r\n *    ripemd160(new Uint8Array([ 0x13, 0x37 ]))\r\n *    //_result:\r\n *\r\n */\r\nfunction ripemd160(_data) {\r\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__ripemd160(data));\r\n}\r\nripemd160._ = _ripemd160;\r\nripemd160.lock = function () { locked = true; };\r\nripemd160.register = function (func) {\r\n    if (locked) {\r\n        throw new TypeError(\"ripemd160 is locked\");\r\n    }\r\n    __ripemd160 = func;\r\n};\r\nObject.freeze(ripemd160);\r\n//# sourceMappingURL=ripemd160.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vcmlwZW1kMTYwLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF1RTtBQUNqQjtBQUN0RDtBQUNBO0FBQ0EsV0FBVyxrRUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsaUJBQWlCLHlEQUFRO0FBQ3pCLFdBQVcsd0RBQU87QUFDbEI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXGNyeXB0b1xccmlwZW1kMTYwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJpcGVtZDE2MCBhcyBub2JsZV9yaXBlbWQxNjAgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9yaXBlbWQxNjBcIjtcclxuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnkgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxubGV0IGxvY2tlZCA9IGZhbHNlO1xyXG5jb25zdCBfcmlwZW1kMTYwID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIHJldHVybiBub2JsZV9yaXBlbWQxNjAoZGF0YSk7XHJcbn07XHJcbmxldCBfX3JpcGVtZDE2MCA9IF9yaXBlbWQxNjA7XHJcbi8qKlxyXG4gKiAgQ29tcHV0ZSB0aGUgY3J5cHRvZ3JhcGhpYyBSSVBFTUQtMTYwIGhhc2ggb2YgJSVkYXRhJSUuXHJcbiAqXHJcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpIYXNoIEZ1bmN0aW9uc1xyXG4gKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xyXG4gKlxyXG4gKiAgQGV4YW1wbGU6XHJcbiAqICAgIHJpcGVtZDE2MChcIjB4XCIpXHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICpcclxuICogICAgcmlwZW1kMTYwKFwiMHgxMzM3XCIpXHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICpcclxuICogICAgcmlwZW1kMTYwKG5ldyBVaW50OEFycmF5KFsgMHgxMywgMHgzNyBdKSlcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJpcGVtZDE2MChfZGF0YSkge1xyXG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XHJcbiAgICByZXR1cm4gaGV4bGlmeShfX3JpcGVtZDE2MChkYXRhKSk7XHJcbn1cclxucmlwZW1kMTYwLl8gPSBfcmlwZW1kMTYwO1xyXG5yaXBlbWQxNjAubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkID0gdHJ1ZTsgfTtcclxucmlwZW1kMTYwLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgIGlmIChsb2NrZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmlwZW1kMTYwIGlzIGxvY2tlZFwiKTtcclxuICAgIH1cclxuICAgIF9fcmlwZW1kMTYwID0gZnVuYztcclxufTtcclxuT2JqZWN0LmZyZWV6ZShyaXBlbWQxNjApO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yaXBlbWQxNjAuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/ripemd160.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/scrypt.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/scrypt.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scrypt: () => (/* binding */ scrypt),\n/* harmony export */   scryptSync: () => (/* binding */ scryptSync)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_scrypt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/scrypt */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/scrypt.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n\r\n\r\nlet lockedSync = false, lockedAsync = false;\r\nconst _scryptAsync = async function (passwd, salt, N, r, p, dkLen, onProgress) {\r\n    return await (0,_noble_hashes_scrypt__WEBPACK_IMPORTED_MODULE_0__.scryptAsync)(passwd, salt, { N, r, p, dkLen, onProgress });\r\n};\r\nconst _scryptSync = function (passwd, salt, N, r, p, dkLen) {\r\n    return (0,_noble_hashes_scrypt__WEBPACK_IMPORTED_MODULE_0__.scrypt)(passwd, salt, { N, r, p, dkLen });\r\n};\r\nlet __scryptAsync = _scryptAsync;\r\nlet __scryptSync = _scryptSync;\r\n/**\r\n *  The [[link-wiki-scrypt]] uses a memory and cpu hard method of\r\n *  derivation to increase the resource cost to brute-force a password\r\n *  for a given key.\r\n *\r\n *  This means this algorithm is intentionally slow, and can be tuned to\r\n *  become slower. As computation and memory speed improve over time,\r\n *  increasing the difficulty maintains the cost of an attacker.\r\n *\r\n *  For example, if a target time of 5 seconds is used, a legitimate user\r\n *  which knows their password requires only 5 seconds to unlock their\r\n *  account. A 6 character password has 68 billion possibilities, which\r\n *  would require an attacker to invest over 10,000 years of CPU time. This\r\n *  is of course a crude example (as password generally aren't random),\r\n *  but demonstrates to value of imposing large costs to decryption.\r\n *\r\n *  For this reason, if building a UI which involved decrypting or\r\n *  encrypting datsa using scrypt, it is recommended to use a\r\n *  [[ProgressCallback]] (as event short periods can seem lik an eternity\r\n *  if the UI freezes). Including the phrase //\"decrypting\"// in the UI\r\n *  can also help, assuring the user their waiting is for a good reason.\r\n *\r\n *  @_docloc: api/crypto:Passwords\r\n *\r\n *  @example:\r\n *    // The password must be converted to bytes, and it is generally\r\n *    // best practices to ensure the string has been normalized. Many\r\n *    // formats explicitly indicate the normalization form to use.\r\n *    password = \"hello\"\r\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\r\n *\r\n *    salt = id(\"some-salt\")\r\n *\r\n *    // Compute the scrypt\r\n *    scrypt(passwordBytes, salt, 1024, 8, 1, 16)\r\n *    //_result:\r\n */\r\nasync function scrypt(_passwd, _salt, N, r, p, dkLen, progress) {\r\n    const passwd = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_passwd, \"passwd\");\r\n    const salt = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_salt, \"salt\");\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await __scryptAsync(passwd, salt, N, r, p, dkLen, progress));\r\n}\r\nscrypt._ = _scryptAsync;\r\nscrypt.lock = function () { lockedAsync = true; };\r\nscrypt.register = function (func) {\r\n    if (lockedAsync) {\r\n        throw new Error(\"scrypt is locked\");\r\n    }\r\n    __scryptAsync = func;\r\n};\r\nObject.freeze(scrypt);\r\n/**\r\n *  Provides a synchronous variant of [[scrypt]].\r\n *\r\n *  This will completely lock up and freeze the UI in a browser and will\r\n *  prevent any event loop from progressing. For this reason, it is\r\n *  preferred to use the [async variant](scrypt).\r\n *\r\n *  @_docloc: api/crypto:Passwords\r\n *\r\n *  @example:\r\n *    // The password must be converted to bytes, and it is generally\r\n *    // best practices to ensure the string has been normalized. Many\r\n *    // formats explicitly indicate the normalization form to use.\r\n *    password = \"hello\"\r\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\r\n *\r\n *    salt = id(\"some-salt\")\r\n *\r\n *    // Compute the scrypt\r\n *    scryptSync(passwordBytes, salt, 1024, 8, 1, 16)\r\n *    //_result:\r\n */\r\nfunction scryptSync(_passwd, _salt, N, r, p, dkLen) {\r\n    const passwd = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_passwd, \"passwd\");\r\n    const salt = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_salt, \"salt\");\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__scryptSync(passwd, salt, N, r, p, dkLen));\r\n}\r\nscryptSync._ = _scryptSync;\r\nscryptSync.lock = function () { lockedSync = true; };\r\nscryptSync.register = function (func) {\r\n    if (lockedSync) {\r\n        throw new Error(\"scryptSync is locked\");\r\n    }\r\n    __scryptSync = func;\r\n};\r\nObject.freeze(scryptSync);\r\n//# sourceMappingURL=scrypt.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vc2NyeXB0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0Y7QUFDN0I7QUFDM0Q7QUFDQTtBQUNBLGlCQUFpQixpRUFBVyxpQkFBaUIsNEJBQTRCO0FBQ3pFO0FBQ0E7QUFDQSxXQUFXLDREQUFVLGlCQUFpQixnQkFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG1CQUFtQix5REFBUTtBQUMzQixpQkFBaUIseURBQVE7QUFDekIsV0FBVyx3REFBQztBQUNaO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsbUJBQW1CLHlEQUFRO0FBQzNCLGlCQUFpQix5REFBUTtBQUN6QixXQUFXLHdEQUFDO0FBQ1o7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXGNyeXB0b1xcc2NyeXB0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNjcnlwdCBhcyBfbm9ibGVTeW5jLCBzY3J5cHRBc3luYyBhcyBfbm9ibGVBc3luYyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NjcnlwdFwiO1xyXG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSBhcyBIIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmxldCBsb2NrZWRTeW5jID0gZmFsc2UsIGxvY2tlZEFzeW5jID0gZmFsc2U7XHJcbmNvbnN0IF9zY3J5cHRBc3luYyA9IGFzeW5jIGZ1bmN0aW9uIChwYXNzd2QsIHNhbHQsIE4sIHIsIHAsIGRrTGVuLCBvblByb2dyZXNzKSB7XHJcbiAgICByZXR1cm4gYXdhaXQgX25vYmxlQXN5bmMocGFzc3dkLCBzYWx0LCB7IE4sIHIsIHAsIGRrTGVuLCBvblByb2dyZXNzIH0pO1xyXG59O1xyXG5jb25zdCBfc2NyeXB0U3luYyA9IGZ1bmN0aW9uIChwYXNzd2QsIHNhbHQsIE4sIHIsIHAsIGRrTGVuKSB7XHJcbiAgICByZXR1cm4gX25vYmxlU3luYyhwYXNzd2QsIHNhbHQsIHsgTiwgciwgcCwgZGtMZW4gfSk7XHJcbn07XHJcbmxldCBfX3NjcnlwdEFzeW5jID0gX3NjcnlwdEFzeW5jO1xyXG5sZXQgX19zY3J5cHRTeW5jID0gX3NjcnlwdFN5bmM7XHJcbi8qKlxyXG4gKiAgVGhlIFtbbGluay13aWtpLXNjcnlwdF1dIHVzZXMgYSBtZW1vcnkgYW5kIGNwdSBoYXJkIG1ldGhvZCBvZlxyXG4gKiAgZGVyaXZhdGlvbiB0byBpbmNyZWFzZSB0aGUgcmVzb3VyY2UgY29zdCB0byBicnV0ZS1mb3JjZSBhIHBhc3N3b3JkXHJcbiAqICBmb3IgYSBnaXZlbiBrZXkuXHJcbiAqXHJcbiAqICBUaGlzIG1lYW5zIHRoaXMgYWxnb3JpdGhtIGlzIGludGVudGlvbmFsbHkgc2xvdywgYW5kIGNhbiBiZSB0dW5lZCB0b1xyXG4gKiAgYmVjb21lIHNsb3dlci4gQXMgY29tcHV0YXRpb24gYW5kIG1lbW9yeSBzcGVlZCBpbXByb3ZlIG92ZXIgdGltZSxcclxuICogIGluY3JlYXNpbmcgdGhlIGRpZmZpY3VsdHkgbWFpbnRhaW5zIHRoZSBjb3N0IG9mIGFuIGF0dGFja2VyLlxyXG4gKlxyXG4gKiAgRm9yIGV4YW1wbGUsIGlmIGEgdGFyZ2V0IHRpbWUgb2YgNSBzZWNvbmRzIGlzIHVzZWQsIGEgbGVnaXRpbWF0ZSB1c2VyXHJcbiAqICB3aGljaCBrbm93cyB0aGVpciBwYXNzd29yZCByZXF1aXJlcyBvbmx5IDUgc2Vjb25kcyB0byB1bmxvY2sgdGhlaXJcclxuICogIGFjY291bnQuIEEgNiBjaGFyYWN0ZXIgcGFzc3dvcmQgaGFzIDY4IGJpbGxpb24gcG9zc2liaWxpdGllcywgd2hpY2hcclxuICogIHdvdWxkIHJlcXVpcmUgYW4gYXR0YWNrZXIgdG8gaW52ZXN0IG92ZXIgMTAsMDAwIHllYXJzIG9mIENQVSB0aW1lLiBUaGlzXHJcbiAqICBpcyBvZiBjb3Vyc2UgYSBjcnVkZSBleGFtcGxlIChhcyBwYXNzd29yZCBnZW5lcmFsbHkgYXJlbid0IHJhbmRvbSksXHJcbiAqICBidXQgZGVtb25zdHJhdGVzIHRvIHZhbHVlIG9mIGltcG9zaW5nIGxhcmdlIGNvc3RzIHRvIGRlY3J5cHRpb24uXHJcbiAqXHJcbiAqICBGb3IgdGhpcyByZWFzb24sIGlmIGJ1aWxkaW5nIGEgVUkgd2hpY2ggaW52b2x2ZWQgZGVjcnlwdGluZyBvclxyXG4gKiAgZW5jcnlwdGluZyBkYXRzYSB1c2luZyBzY3J5cHQsIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBhXHJcbiAqICBbW1Byb2dyZXNzQ2FsbGJhY2tdXSAoYXMgZXZlbnQgc2hvcnQgcGVyaW9kcyBjYW4gc2VlbSBsaWsgYW4gZXRlcm5pdHlcclxuICogIGlmIHRoZSBVSSBmcmVlemVzKS4gSW5jbHVkaW5nIHRoZSBwaHJhc2UgLy9cImRlY3J5cHRpbmdcIi8vIGluIHRoZSBVSVxyXG4gKiAgY2FuIGFsc28gaGVscCwgYXNzdXJpbmcgdGhlIHVzZXIgdGhlaXIgd2FpdGluZyBpcyBmb3IgYSBnb29kIHJlYXNvbi5cclxuICpcclxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOlBhc3N3b3Jkc1xyXG4gKlxyXG4gKiAgQGV4YW1wbGU6XHJcbiAqICAgIC8vIFRoZSBwYXNzd29yZCBtdXN0IGJlIGNvbnZlcnRlZCB0byBieXRlcywgYW5kIGl0IGlzIGdlbmVyYWxseVxyXG4gKiAgICAvLyBiZXN0IHByYWN0aWNlcyB0byBlbnN1cmUgdGhlIHN0cmluZyBoYXMgYmVlbiBub3JtYWxpemVkLiBNYW55XHJcbiAqICAgIC8vIGZvcm1hdHMgZXhwbGljaXRseSBpbmRpY2F0ZSB0aGUgbm9ybWFsaXphdGlvbiBmb3JtIHRvIHVzZS5cclxuICogICAgcGFzc3dvcmQgPSBcImhlbGxvXCJcclxuICogICAgcGFzc3dvcmRCeXRlcyA9IHRvVXRmOEJ5dGVzKHBhc3N3b3JkLCBcIk5GS0NcIilcclxuICpcclxuICogICAgc2FsdCA9IGlkKFwic29tZS1zYWx0XCIpXHJcbiAqXHJcbiAqICAgIC8vIENvbXB1dGUgdGhlIHNjcnlwdFxyXG4gKiAgICBzY3J5cHQocGFzc3dvcmRCeXRlcywgc2FsdCwgMTAyNCwgOCwgMSwgMTYpXHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzY3J5cHQoX3Bhc3N3ZCwgX3NhbHQsIE4sIHIsIHAsIGRrTGVuLCBwcm9ncmVzcykge1xyXG4gICAgY29uc3QgcGFzc3dkID0gZ2V0Qnl0ZXMoX3Bhc3N3ZCwgXCJwYXNzd2RcIik7XHJcbiAgICBjb25zdCBzYWx0ID0gZ2V0Qnl0ZXMoX3NhbHQsIFwic2FsdFwiKTtcclxuICAgIHJldHVybiBIKGF3YWl0IF9fc2NyeXB0QXN5bmMocGFzc3dkLCBzYWx0LCBOLCByLCBwLCBka0xlbiwgcHJvZ3Jlc3MpKTtcclxufVxyXG5zY3J5cHQuXyA9IF9zY3J5cHRBc3luYztcclxuc2NyeXB0LmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZEFzeW5jID0gdHJ1ZTsgfTtcclxuc2NyeXB0LnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgIGlmIChsb2NrZWRBc3luYykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNjcnlwdCBpcyBsb2NrZWRcIik7XHJcbiAgICB9XHJcbiAgICBfX3NjcnlwdEFzeW5jID0gZnVuYztcclxufTtcclxuT2JqZWN0LmZyZWV6ZShzY3J5cHQpO1xyXG4vKipcclxuICogIFByb3ZpZGVzIGEgc3luY2hyb25vdXMgdmFyaWFudCBvZiBbW3NjcnlwdF1dLlxyXG4gKlxyXG4gKiAgVGhpcyB3aWxsIGNvbXBsZXRlbHkgbG9jayB1cCBhbmQgZnJlZXplIHRoZSBVSSBpbiBhIGJyb3dzZXIgYW5kIHdpbGxcclxuICogIHByZXZlbnQgYW55IGV2ZW50IGxvb3AgZnJvbSBwcm9ncmVzc2luZy4gRm9yIHRoaXMgcmVhc29uLCBpdCBpc1xyXG4gKiAgcHJlZmVycmVkIHRvIHVzZSB0aGUgW2FzeW5jIHZhcmlhbnRdKHNjcnlwdCkuXHJcbiAqXHJcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpQYXNzd29yZHNcclxuICpcclxuICogIEBleGFtcGxlOlxyXG4gKiAgICAvLyBUaGUgcGFzc3dvcmQgbXVzdCBiZSBjb252ZXJ0ZWQgdG8gYnl0ZXMsIGFuZCBpdCBpcyBnZW5lcmFsbHlcclxuICogICAgLy8gYmVzdCBwcmFjdGljZXMgdG8gZW5zdXJlIHRoZSBzdHJpbmcgaGFzIGJlZW4gbm9ybWFsaXplZC4gTWFueVxyXG4gKiAgICAvLyBmb3JtYXRzIGV4cGxpY2l0bHkgaW5kaWNhdGUgdGhlIG5vcm1hbGl6YXRpb24gZm9ybSB0byB1c2UuXHJcbiAqICAgIHBhc3N3b3JkID0gXCJoZWxsb1wiXHJcbiAqICAgIHBhc3N3b3JkQnl0ZXMgPSB0b1V0ZjhCeXRlcyhwYXNzd29yZCwgXCJORktDXCIpXHJcbiAqXHJcbiAqICAgIHNhbHQgPSBpZChcInNvbWUtc2FsdFwiKVxyXG4gKlxyXG4gKiAgICAvLyBDb21wdXRlIHRoZSBzY3J5cHRcclxuICogICAgc2NyeXB0U3luYyhwYXNzd29yZEJ5dGVzLCBzYWx0LCAxMDI0LCA4LCAxLCAxNilcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNjcnlwdFN5bmMoX3Bhc3N3ZCwgX3NhbHQsIE4sIHIsIHAsIGRrTGVuKSB7XHJcbiAgICBjb25zdCBwYXNzd2QgPSBnZXRCeXRlcyhfcGFzc3dkLCBcInBhc3N3ZFwiKTtcclxuICAgIGNvbnN0IHNhbHQgPSBnZXRCeXRlcyhfc2FsdCwgXCJzYWx0XCIpO1xyXG4gICAgcmV0dXJuIEgoX19zY3J5cHRTeW5jKHBhc3N3ZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4pKTtcclxufVxyXG5zY3J5cHRTeW5jLl8gPSBfc2NyeXB0U3luYztcclxuc2NyeXB0U3luYy5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWRTeW5jID0gdHJ1ZTsgfTtcclxuc2NyeXB0U3luYy5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XHJcbiAgICBpZiAobG9ja2VkU3luYykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNjcnlwdFN5bmMgaXMgbG9ja2VkXCIpO1xyXG4gICAgfVxyXG4gICAgX19zY3J5cHRTeW5jID0gZnVuYztcclxufTtcclxuT2JqZWN0LmZyZWV6ZShzY3J5cHRTeW5jKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NyeXB0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/scrypt.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/sha2.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/sha2.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha512: () => (/* binding */ sha512)\n/* harmony export */ });\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crypto.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/crypto-browser.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n\r\n\r\nconst _sha256 = function (data) {\r\n    return (0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.createHash)(\"sha256\").update(data).digest();\r\n};\r\nconst _sha512 = function (data) {\r\n    return (0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.createHash)(\"sha512\").update(data).digest();\r\n};\r\nlet __sha256 = _sha256;\r\nlet __sha512 = _sha512;\r\nlet locked256 = false, locked512 = false;\r\n/**\r\n *  Compute the cryptographic SHA2-256 hash of %%data%%.\r\n *\r\n *  @_docloc: api/crypto:Hash Functions\r\n *  @returns DataHexstring\r\n *\r\n *  @example:\r\n *    sha256(\"0x\")\r\n *    //_result:\r\n *\r\n *    sha256(\"0x1337\")\r\n *    //_result:\r\n *\r\n *    sha256(new Uint8Array([ 0x13, 0x37 ]))\r\n *    //_result:\r\n *\r\n */\r\nfunction sha256(_data) {\r\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__sha256(data));\r\n}\r\nsha256._ = _sha256;\r\nsha256.lock = function () { locked256 = true; };\r\nsha256.register = function (func) {\r\n    if (locked256) {\r\n        throw new Error(\"sha256 is locked\");\r\n    }\r\n    __sha256 = func;\r\n};\r\nObject.freeze(sha256);\r\n/**\r\n *  Compute the cryptographic SHA2-512 hash of %%data%%.\r\n *\r\n *  @_docloc: api/crypto:Hash Functions\r\n *  @returns DataHexstring\r\n *\r\n *  @example:\r\n *    sha512(\"0x\")\r\n *    //_result:\r\n *\r\n *    sha512(\"0x1337\")\r\n *    //_result:\r\n *\r\n *    sha512(new Uint8Array([ 0x13, 0x37 ]))\r\n *    //_result:\r\n */\r\nfunction sha512(_data) {\r\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__sha512(data));\r\n}\r\nsha512._ = _sha512;\r\nsha512.lock = function () { locked512 = true; };\r\nsha512.register = function (func) {\r\n    if (locked512) {\r\n        throw new Error(\"sha512 is locked\");\r\n    }\r\n    __sha512 = func;\r\n};\r\nObject.freeze(sha256);\r\n//# sourceMappingURL=sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vc2hhMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXlDO0FBQ2E7QUFDdEQ7QUFDQSxXQUFXLHNEQUFVO0FBQ3JCO0FBQ0E7QUFDQSxXQUFXLHNEQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsaUJBQWlCLHlEQUFRO0FBQ3pCLFdBQVcsd0RBQU87QUFDbEI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpQkFBaUIseURBQVE7QUFDekIsV0FBVyx3REFBTztBQUNsQjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcY3J5cHRvXFxzaGEyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUhhc2ggfSBmcm9tIFwiLi9jcnlwdG8uanNcIjtcclxuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnkgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuY29uc3QgX3NoYTI1NiA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlSGFzaChcInNoYTI1NlwiKS51cGRhdGUoZGF0YSkuZGlnZXN0KCk7XHJcbn07XHJcbmNvbnN0IF9zaGE1MTIgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUhhc2goXCJzaGE1MTJcIikudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xyXG59O1xyXG5sZXQgX19zaGEyNTYgPSBfc2hhMjU2O1xyXG5sZXQgX19zaGE1MTIgPSBfc2hhNTEyO1xyXG5sZXQgbG9ja2VkMjU2ID0gZmFsc2UsIGxvY2tlZDUxMiA9IGZhbHNlO1xyXG4vKipcclxuICogIENvbXB1dGUgdGhlIGNyeXB0b2dyYXBoaWMgU0hBMi0yNTYgaGFzaCBvZiAlJWRhdGElJS5cclxuICpcclxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOkhhc2ggRnVuY3Rpb25zXHJcbiAqICBAcmV0dXJucyBEYXRhSGV4c3RyaW5nXHJcbiAqXHJcbiAqICBAZXhhbXBsZTpcclxuICogICAgc2hhMjU2KFwiMHhcIilcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKlxyXG4gKiAgICBzaGEyNTYoXCIweDEzMzdcIilcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKlxyXG4gKiAgICBzaGEyNTYobmV3IFVpbnQ4QXJyYXkoWyAweDEzLCAweDM3IF0pKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2hhMjU2KF9kYXRhKSB7XHJcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcclxuICAgIHJldHVybiBoZXhsaWZ5KF9fc2hhMjU2KGRhdGEpKTtcclxufVxyXG5zaGEyNTYuXyA9IF9zaGEyNTY7XHJcbnNoYTI1Ni5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQyNTYgPSB0cnVlOyB9O1xyXG5zaGEyNTYucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xyXG4gICAgaWYgKGxvY2tlZDI1Nikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNoYTI1NiBpcyBsb2NrZWRcIik7XHJcbiAgICB9XHJcbiAgICBfX3NoYTI1NiA9IGZ1bmM7XHJcbn07XHJcbk9iamVjdC5mcmVlemUoc2hhMjU2KTtcclxuLyoqXHJcbiAqICBDb21wdXRlIHRoZSBjcnlwdG9ncmFwaGljIFNIQTItNTEyIGhhc2ggb2YgJSVkYXRhJSUuXHJcbiAqXHJcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpIYXNoIEZ1bmN0aW9uc1xyXG4gKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xyXG4gKlxyXG4gKiAgQGV4YW1wbGU6XHJcbiAqICAgIHNoYTUxMihcIjB4XCIpXHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICpcclxuICogICAgc2hhNTEyKFwiMHgxMzM3XCIpXHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICpcclxuICogICAgc2hhNTEyKG5ldyBVaW50OEFycmF5KFsgMHgxMywgMHgzNyBdKSlcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNoYTUxMihfZGF0YSkge1xyXG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XHJcbiAgICByZXR1cm4gaGV4bGlmeShfX3NoYTUxMihkYXRhKSk7XHJcbn1cclxuc2hhNTEyLl8gPSBfc2hhNTEyO1xyXG5zaGE1MTIubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkNTEyID0gdHJ1ZTsgfTtcclxuc2hhNTEyLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgIGlmIChsb2NrZWQ1MTIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaGE1MTIgaXMgbG9ja2VkXCIpO1xyXG4gICAgfVxyXG4gICAgX19zaGE1MTIgPSBmdW5jO1xyXG59O1xyXG5PYmplY3QuZnJlZXplKHNoYTI1Nik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/sha2.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/signature.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/signature.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Signature: () => (/* binding */ Signature)\n/* harmony export */ });\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/constants/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n\r\n\r\n// Constants\r\nconst BN_0 = BigInt(0);\r\nconst BN_1 = BigInt(1);\r\nconst BN_2 = BigInt(2);\r\nconst BN_27 = BigInt(27);\r\nconst BN_28 = BigInt(28);\r\nconst BN_35 = BigInt(35);\r\nconst _guard = {};\r\nfunction toUint256(value) {\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(value), 32);\r\n}\r\n/**\r\n *  A Signature  @TODO\r\n *\r\n *\r\n *  @_docloc: api/crypto:Signing\r\n */\r\nclass Signature {\r\n    #r;\r\n    #s;\r\n    #v;\r\n    #networkV;\r\n    /**\r\n     *  The ``r`` value for a signature.\r\n     *\r\n     *  This represents the ``x`` coordinate of a \"reference\" or\r\n     *  challenge point, from which the ``y`` can be computed.\r\n     */\r\n    get r() { return this.#r; }\r\n    set r(value) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(value) === 32, \"invalid r\", \"value\", value);\r\n        this.#r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(value);\r\n    }\r\n    /**\r\n     *  The ``s`` value for a signature.\r\n     */\r\n    get s() {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(parseInt(this.#s.substring(0, 3)) < 8, \"non-canonical s; use ._s\", \"s\", this.#s);\r\n        return this.#s;\r\n    }\r\n    set s(_value) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(_value) === 32, \"invalid s\", \"value\", _value);\r\n        this.#s = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(_value);\r\n    }\r\n    /**\r\n     *  Return the s value, unchecked for EIP-2 compliance.\r\n     *\r\n     *  This should generally not be used and is for situations where\r\n     *  a non-canonical S value might be relevant, such as Frontier blocks\r\n     *  that were mined prior to EIP-2 or invalid Authorization List\r\n     *  signatures.\r\n     */\r\n    get _s() { return this.#s; }\r\n    /**\r\n     *  Returns true if the Signature is valid for [[link-eip-2]] signatures.\r\n     */\r\n    isValid() {\r\n        return (parseInt(this.#s.substring(0, 3)) < 8);\r\n    }\r\n    /**\r\n     *  The ``v`` value for a signature.\r\n     *\r\n     *  Since a given ``x`` value for ``r`` has two possible values for\r\n     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``\r\n     *  values to use.\r\n     *\r\n     *  It is normalized to the values ``27`` or ``28`` for legacy\r\n     *  purposes.\r\n     */\r\n    get v() { return this.#v; }\r\n    set v(value) {\r\n        const v = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(value, \"value\");\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(v === 27 || v === 28, \"invalid v\", \"v\", value);\r\n        this.#v = v;\r\n    }\r\n    /**\r\n     *  The EIP-155 ``v`` for legacy transactions. For non-legacy\r\n     *  transactions, this value is ``null``.\r\n     */\r\n    get networkV() { return this.#networkV; }\r\n    /**\r\n     *  The chain ID for EIP-155 legacy transactions. For non-legacy\r\n     *  transactions, this value is ``null``.\r\n     */\r\n    get legacyChainId() {\r\n        const v = this.networkV;\r\n        if (v == null) {\r\n            return null;\r\n        }\r\n        return Signature.getChainId(v);\r\n    }\r\n    /**\r\n     *  The ``yParity`` for the signature.\r\n     *\r\n     *  See ``v`` for more details on how this value is used.\r\n     */\r\n    get yParity() {\r\n        return (this.v === 27) ? 0 : 1;\r\n    }\r\n    /**\r\n     *  The [[link-eip-2098]] compact representation of the ``yParity``\r\n     *  and ``s`` compacted into a single ``bytes32``.\r\n     */\r\n    get yParityAndS() {\r\n        // The EIP-2098 compact representation\r\n        const yParityAndS = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(this.s);\r\n        if (this.yParity) {\r\n            yParityAndS[0] |= 0x80;\r\n        }\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(yParityAndS);\r\n    }\r\n    /**\r\n     *  The [[link-eip-2098]] compact representation.\r\n     */\r\n    get compactSerialized() {\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([this.r, this.yParityAndS]);\r\n    }\r\n    /**\r\n     *  The serialized representation.\r\n     */\r\n    get serialized() {\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([this.r, this.s, (this.yParity ? \"0x1c\" : \"0x1b\")]);\r\n    }\r\n    /**\r\n     *  @private\r\n     */\r\n    constructor(guard, r, s, v) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"Signature\");\r\n        this.#r = r;\r\n        this.#s = s;\r\n        this.#v = v;\r\n        this.#networkV = null;\r\n    }\r\n    [Symbol.for('nodejs.util.inspect.custom')]() {\r\n        return `Signature { r: \"${this.r}\", s: \"${this._s}\"${this.isValid() ? \"\" : ', valid: \"false\"'}, yParity: ${this.yParity}, networkV: ${this.networkV} }`;\r\n    }\r\n    /**\r\n     *  Returns a new identical [[Signature]].\r\n     */\r\n    clone() {\r\n        const clone = new Signature(_guard, this.r, this._s, this.v);\r\n        if (this.networkV) {\r\n            clone.#networkV = this.networkV;\r\n        }\r\n        return clone;\r\n    }\r\n    /**\r\n     *  Returns a representation that is compatible with ``JSON.stringify``.\r\n     */\r\n    toJSON() {\r\n        const networkV = this.networkV;\r\n        return {\r\n            _type: \"signature\",\r\n            networkV: ((networkV != null) ? networkV.toString() : null),\r\n            r: this.r, s: this._s, v: this.v,\r\n        };\r\n    }\r\n    /**\r\n     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.\r\n     *\r\n     *  @example:\r\n     *    Signature.getChainId(45)\r\n     *    //_result:\r\n     *\r\n     *    Signature.getChainId(46)\r\n     *    //_result:\r\n     */\r\n    static getChainId(v) {\r\n        const bv = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(v, \"v\");\r\n        // The v is not an EIP-155 v, so it is the unspecified chain ID\r\n        if ((bv == BN_27) || (bv == BN_28)) {\r\n            return BN_0;\r\n        }\r\n        // Bad value for an EIP-155 v\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(bv >= BN_35, \"invalid EIP-155 v\", \"v\", v);\r\n        return (bv - BN_35) / BN_2;\r\n    }\r\n    /**\r\n     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.\r\n     *\r\n     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``\r\n     *  property to include the chain ID.\r\n     *\r\n     *  @example:\r\n     *    Signature.getChainIdV(5, 27)\r\n     *    //_result:\r\n     *\r\n     *    Signature.getChainIdV(5, 28)\r\n     *    //_result:\r\n     *\r\n     */\r\n    static getChainIdV(chainId, v) {\r\n        return ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(chainId) * BN_2) + BigInt(35 + v - 27);\r\n    }\r\n    /**\r\n     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,\r\n     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.\r\n     *\r\n     *  @example:\r\n     *    // The values 0 and 1 imply v is actually yParity\r\n     *    Signature.getNormalizedV(0)\r\n     *    //_result:\r\n     *\r\n     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)\r\n     *    Signature.getNormalizedV(27)\r\n     *    //_result:\r\n     *\r\n     *    // Legacy EIP-155 transaction (i.e. >= 35)\r\n     *    Signature.getNormalizedV(46)\r\n     *    //_result:\r\n     *\r\n     *    // Invalid values throw\r\n     *    Signature.getNormalizedV(5)\r\n     *    //_error:\r\n     */\r\n    static getNormalizedV(v) {\r\n        const bv = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(v);\r\n        if (bv === BN_0 || bv === BN_27) {\r\n            return 27;\r\n        }\r\n        if (bv === BN_1 || bv === BN_28) {\r\n            return 28;\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(bv >= BN_35, \"invalid v\", \"v\", v);\r\n        // Otherwise, EIP-155 v means odd is 27 and even is 28\r\n        return (bv & BN_1) ? 27 : 28;\r\n    }\r\n    /**\r\n     *  Creates a new [[Signature]].\r\n     *\r\n     *  If no %%sig%% is provided, a new [[Signature]] is created\r\n     *  with default values.\r\n     *\r\n     *  If %%sig%% is a string, it is parsed.\r\n     */\r\n    static from(sig) {\r\n        function assertError(check, message) {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(check, message, \"signature\", sig);\r\n        }\r\n        ;\r\n        if (sig == null) {\r\n            return new Signature(_guard, _constants_index_js__WEBPACK_IMPORTED_MODULE_1__.ZeroHash, _constants_index_js__WEBPACK_IMPORTED_MODULE_1__.ZeroHash, 27);\r\n        }\r\n        if (typeof (sig) === \"string\") {\r\n            const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(sig, \"signature\");\r\n            if (bytes.length === 64) {\r\n                const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 32));\r\n                const s = bytes.slice(32, 64);\r\n                const v = (s[0] & 0x80) ? 28 : 27;\r\n                s[0] &= 0x7f;\r\n                return new Signature(_guard, r, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(s), v);\r\n            }\r\n            if (bytes.length === 65) {\r\n                const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 32));\r\n                const s = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(32, 64));\r\n                const v = Signature.getNormalizedV(bytes[64]);\r\n                return new Signature(_guard, r, s, v);\r\n            }\r\n            assertError(false, \"invalid raw signature length\");\r\n        }\r\n        if (sig instanceof Signature) {\r\n            return sig.clone();\r\n        }\r\n        // Get r\r\n        const _r = sig.r;\r\n        assertError(_r != null, \"missing r\");\r\n        const r = toUint256(_r);\r\n        // Get s; by any means necessary (we check consistency below)\r\n        const s = (function (s, yParityAndS) {\r\n            if (s != null) {\r\n                return toUint256(s);\r\n            }\r\n            if (yParityAndS != null) {\r\n                assertError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\r\n                const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(yParityAndS);\r\n                bytes[0] &= 0x7f;\r\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\r\n            }\r\n            assertError(false, \"missing s\");\r\n        })(sig.s, sig.yParityAndS);\r\n        // Get v; by any means necessary (we check consistency below)\r\n        const { networkV, v } = (function (_v, yParityAndS, yParity) {\r\n            if (_v != null) {\r\n                const v = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(_v);\r\n                return {\r\n                    networkV: ((v >= BN_35) ? v : undefined),\r\n                    v: Signature.getNormalizedV(v)\r\n                };\r\n            }\r\n            if (yParityAndS != null) {\r\n                assertError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\r\n                return { v: (((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(yParityAndS)[0] & 0x80) ? 28 : 27) };\r\n            }\r\n            if (yParity != null) {\r\n                switch ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(yParity, \"sig.yParity\")) {\r\n                    case 0: return { v: 27 };\r\n                    case 1: return { v: 28 };\r\n                }\r\n                assertError(false, \"invalid yParity\");\r\n            }\r\n            assertError(false, \"missing v\");\r\n        })(sig.v, sig.yParityAndS, sig.yParity);\r\n        const result = new Signature(_guard, r, s, v);\r\n        if (networkV) {\r\n            result.#networkV = networkV;\r\n        }\r\n        // If multiple of v, yParity, yParityAndS we given, check they match\r\n        assertError(sig.yParity == null || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(sig.yParity, \"sig.yParity\") === result.yParity, \"yParity mismatch\");\r\n        assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, \"yParityAndS mismatch\");\r\n        return result;\r\n    }\r\n}\r\n//# sourceMappingURL=signature.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vc2lnbmF0dXJlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpRDtBQUNvSDtBQUNySztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZEQUFZLENBQUMsMERBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsUUFBUSwrREFBYyxDQUFDLDJEQUFVO0FBQ2pDLGtCQUFrQix3REFBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYywwREFBMEQ7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYyxDQUFDLDJEQUFVO0FBQ2pDLGtCQUFrQix3REFBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxrQkFBa0IsMERBQVM7QUFDM0IsUUFBUSwrREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseURBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4REFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTSxPQUFPLFNBQVMsUUFBUSxHQUFHLHlDQUF5QyxhQUFhLGFBQWEsY0FBYyxnQkFBZ0I7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwREFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseURBQVEsRUFBRSx5REFBUTtBQUMzRDtBQUNBO0FBQ0EsMEJBQTBCLHlEQUFRO0FBQ2xDO0FBQ0EsMEJBQTBCLHdEQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx3REFBTztBQUN2RDtBQUNBO0FBQ0EsMEJBQTBCLHdEQUFPO0FBQ2pDLDBCQUEwQix3REFBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0REFBVztBQUN2Qyw4QkFBOEIseURBQVE7QUFDdEM7QUFDQSx1QkFBdUIsd0RBQU87QUFDOUI7QUFDQTtBQUNBLFNBQVM7QUFDVCxrQkFBa0I7QUFDbEIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQSwwQkFBMEIsMERBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDREQUFXO0FBQ3ZDLHlCQUF5QixLQUFLLHlEQUFRO0FBQ3RDO0FBQ0E7QUFDQSx3QkFBd0IsMERBQVM7QUFDakMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDBEQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcY3J5cHRvXFxzaWduYXR1cmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgWmVyb0hhc2ggfSBmcm9tIFwiLi4vY29uc3RhbnRzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGNvbmNhdCwgZGF0YUxlbmd0aCwgZ2V0QmlnSW50LCBnZXRCeXRlcywgZ2V0TnVtYmVyLCBoZXhsaWZ5LCB0b0JlQXJyYXksIGlzSGV4U3RyaW5nLCB6ZXJvUGFkVmFsdWUsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRQcml2YXRlIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbi8vIENvbnN0YW50c1xyXG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xyXG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xyXG5jb25zdCBCTl8yID0gQmlnSW50KDIpO1xyXG5jb25zdCBCTl8yNyA9IEJpZ0ludCgyNyk7XHJcbmNvbnN0IEJOXzI4ID0gQmlnSW50KDI4KTtcclxuY29uc3QgQk5fMzUgPSBCaWdJbnQoMzUpO1xyXG5jb25zdCBfZ3VhcmQgPSB7fTtcclxuZnVuY3Rpb24gdG9VaW50MjU2KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gemVyb1BhZFZhbHVlKHRvQmVBcnJheSh2YWx1ZSksIDMyKTtcclxufVxyXG4vKipcclxuICogIEEgU2lnbmF0dXJlICBAVE9ET1xyXG4gKlxyXG4gKlxyXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86U2lnbmluZ1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNpZ25hdHVyZSB7XHJcbiAgICAjcjtcclxuICAgICNzO1xyXG4gICAgI3Y7XHJcbiAgICAjbmV0d29ya1Y7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYGByYGAgdmFsdWUgZm9yIGEgc2lnbmF0dXJlLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIHJlcHJlc2VudHMgdGhlIGBgeGBgIGNvb3JkaW5hdGUgb2YgYSBcInJlZmVyZW5jZVwiIG9yXHJcbiAgICAgKiAgY2hhbGxlbmdlIHBvaW50LCBmcm9tIHdoaWNoIHRoZSBgYHlgYCBjYW4gYmUgY29tcHV0ZWQuXHJcbiAgICAgKi9cclxuICAgIGdldCByKCkgeyByZXR1cm4gdGhpcy4jcjsgfVxyXG4gICAgc2V0IHIodmFsdWUpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKHZhbHVlKSA9PT0gMzIsIFwiaW52YWxpZCByXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgICAgIHRoaXMuI3IgPSBoZXhsaWZ5KHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBgYHNgYCB2YWx1ZSBmb3IgYSBzaWduYXR1cmUuXHJcbiAgICAgKi9cclxuICAgIGdldCBzKCkge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHBhcnNlSW50KHRoaXMuI3Muc3Vic3RyaW5nKDAsIDMpKSA8IDgsIFwibm9uLWNhbm9uaWNhbCBzOyB1c2UgLl9zXCIsIFwic1wiLCB0aGlzLiNzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy4jcztcclxuICAgIH1cclxuICAgIHNldCBzKF92YWx1ZSkge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgoX3ZhbHVlKSA9PT0gMzIsIFwiaW52YWxpZCBzXCIsIFwidmFsdWVcIiwgX3ZhbHVlKTtcclxuICAgICAgICB0aGlzLiNzID0gaGV4bGlmeShfdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBzIHZhbHVlLCB1bmNoZWNrZWQgZm9yIEVJUC0yIGNvbXBsaWFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgc2hvdWxkIGdlbmVyYWxseSBub3QgYmUgdXNlZCBhbmQgaXMgZm9yIHNpdHVhdGlvbnMgd2hlcmVcclxuICAgICAqICBhIG5vbi1jYW5vbmljYWwgUyB2YWx1ZSBtaWdodCBiZSByZWxldmFudCwgc3VjaCBhcyBGcm9udGllciBibG9ja3NcclxuICAgICAqICB0aGF0IHdlcmUgbWluZWQgcHJpb3IgdG8gRUlQLTIgb3IgaW52YWxpZCBBdXRob3JpemF0aW9uIExpc3RcclxuICAgICAqICBzaWduYXR1cmVzLlxyXG4gICAgICovXHJcbiAgICBnZXQgX3MoKSB7IHJldHVybiB0aGlzLiNzOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIFNpZ25hdHVyZSBpcyB2YWxpZCBmb3IgW1tsaW5rLWVpcC0yXV0gc2lnbmF0dXJlcy5cclxuICAgICAqL1xyXG4gICAgaXNWYWxpZCgpIHtcclxuICAgICAgICByZXR1cm4gKHBhcnNlSW50KHRoaXMuI3Muc3Vic3RyaW5nKDAsIDMpKSA8IDgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGBgdmBgIHZhbHVlIGZvciBhIHNpZ25hdHVyZS5cclxuICAgICAqXHJcbiAgICAgKiAgU2luY2UgYSBnaXZlbiBgYHhgYCB2YWx1ZSBmb3IgYGByYGAgaGFzIHR3byBwb3NzaWJsZSB2YWx1ZXMgZm9yXHJcbiAgICAgKiAgaXRzIGNvcnJlc3BvbmRpbiBgYHlgYCwgdGhlIGBgdmBgIGluZGljYXRlcyB3aGljaCBvZiB0aGUgdHdvIGBgeWBgXHJcbiAgICAgKiAgdmFsdWVzIHRvIHVzZS5cclxuICAgICAqXHJcbiAgICAgKiAgSXQgaXMgbm9ybWFsaXplZCB0byB0aGUgdmFsdWVzIGBgMjdgYCBvciBgYDI4YGAgZm9yIGxlZ2FjeVxyXG4gICAgICogIHB1cnBvc2VzLlxyXG4gICAgICovXHJcbiAgICBnZXQgdigpIHsgcmV0dXJuIHRoaXMuI3Y7IH1cclxuICAgIHNldCB2KHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgdiA9IGdldE51bWJlcih2YWx1ZSwgXCJ2YWx1ZVwiKTtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudCh2ID09PSAyNyB8fCB2ID09PSAyOCwgXCJpbnZhbGlkIHZcIiwgXCJ2XCIsIHZhbHVlKTtcclxuICAgICAgICB0aGlzLiN2ID0gdjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBFSVAtMTU1IGBgdmBgIGZvciBsZWdhY3kgdHJhbnNhY3Rpb25zLiBGb3Igbm9uLWxlZ2FjeVxyXG4gICAgICogIHRyYW5zYWN0aW9ucywgdGhpcyB2YWx1ZSBpcyBgYG51bGxgYC5cclxuICAgICAqL1xyXG4gICAgZ2V0IG5ldHdvcmtWKCkgeyByZXR1cm4gdGhpcy4jbmV0d29ya1Y7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBjaGFpbiBJRCBmb3IgRUlQLTE1NSBsZWdhY3kgdHJhbnNhY3Rpb25zLiBGb3Igbm9uLWxlZ2FjeVxyXG4gICAgICogIHRyYW5zYWN0aW9ucywgdGhpcyB2YWx1ZSBpcyBgYG51bGxgYC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGxlZ2FjeUNoYWluSWQoKSB7XHJcbiAgICAgICAgY29uc3QgdiA9IHRoaXMubmV0d29ya1Y7XHJcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5nZXRDaGFpbklkKHYpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGBgeVBhcml0eWBgIGZvciB0aGUgc2lnbmF0dXJlLlxyXG4gICAgICpcclxuICAgICAqICBTZWUgYGB2YGAgZm9yIG1vcmUgZGV0YWlscyBvbiBob3cgdGhpcyB2YWx1ZSBpcyB1c2VkLlxyXG4gICAgICovXHJcbiAgICBnZXQgeVBhcml0eSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudiA9PT0gMjcpID8gMCA6IDE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yMDk4XV0gY29tcGFjdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgYGB5UGFyaXR5YGBcclxuICAgICAqICBhbmQgYGBzYGAgY29tcGFjdGVkIGludG8gYSBzaW5nbGUgYGBieXRlczMyYGAuXHJcbiAgICAgKi9cclxuICAgIGdldCB5UGFyaXR5QW5kUygpIHtcclxuICAgICAgICAvLyBUaGUgRUlQLTIwOTggY29tcGFjdCByZXByZXNlbnRhdGlvblxyXG4gICAgICAgIGNvbnN0IHlQYXJpdHlBbmRTID0gZ2V0Qnl0ZXModGhpcy5zKTtcclxuICAgICAgICBpZiAodGhpcy55UGFyaXR5KSB7XHJcbiAgICAgICAgICAgIHlQYXJpdHlBbmRTWzBdIHw9IDB4ODA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHlQYXJpdHlBbmRTKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTIwOThdXSBjb21wYWN0IHJlcHJlc2VudGF0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXQgY29tcGFjdFNlcmlhbGl6ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbdGhpcy5yLCB0aGlzLnlQYXJpdHlBbmRTXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgc2VyaWFsaXplZCByZXByZXNlbnRhdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0IHNlcmlhbGl6ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbdGhpcy5yLCB0aGlzLnMsICh0aGlzLnlQYXJpdHkgPyBcIjB4MWNcIiA6IFwiMHgxYlwiKV0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHIsIHMsIHYpIHtcclxuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiU2lnbmF0dXJlXCIpO1xyXG4gICAgICAgIHRoaXMuI3IgPSByO1xyXG4gICAgICAgIHRoaXMuI3MgPSBzO1xyXG4gICAgICAgIHRoaXMuI3YgPSB2O1xyXG4gICAgICAgIHRoaXMuI25ldHdvcmtWID0gbnVsbDtcclxuICAgIH1cclxuICAgIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcclxuICAgICAgICByZXR1cm4gYFNpZ25hdHVyZSB7IHI6IFwiJHt0aGlzLnJ9XCIsIHM6IFwiJHt0aGlzLl9zfVwiJHt0aGlzLmlzVmFsaWQoKSA/IFwiXCIgOiAnLCB2YWxpZDogXCJmYWxzZVwiJ30sIHlQYXJpdHk6ICR7dGhpcy55UGFyaXR5fSwgbmV0d29ya1Y6ICR7dGhpcy5uZXR3b3JrVn0gfWA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgbmV3IGlkZW50aWNhbCBbW1NpZ25hdHVyZV1dLlxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBTaWduYXR1cmUoX2d1YXJkLCB0aGlzLnIsIHRoaXMuX3MsIHRoaXMudik7XHJcbiAgICAgICAgaWYgKHRoaXMubmV0d29ya1YpIHtcclxuICAgICAgICAgICAgY2xvbmUuI25ldHdvcmtWID0gdGhpcy5uZXR3b3JrVjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIHJlcHJlc2VudGF0aW9uIHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIGBgSlNPTi5zdHJpbmdpZnlgYC5cclxuICAgICAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGNvbnN0IG5ldHdvcmtWID0gdGhpcy5uZXR3b3JrVjtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBfdHlwZTogXCJzaWduYXR1cmVcIixcclxuICAgICAgICAgICAgbmV0d29ya1Y6ICgobmV0d29ya1YgIT0gbnVsbCkgPyBuZXR3b3JrVi50b1N0cmluZygpIDogbnVsbCksXHJcbiAgICAgICAgICAgIHI6IHRoaXMuciwgczogdGhpcy5fcywgdjogdGhpcy52LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDb21wdXRlIHRoZSBjaGFpbiBJRCBmcm9tIHRoZSBgYHZgYCBpbiBhIGxlZ2FjeSBFSVAtMTU1IHRyYW5zYWN0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiAgQGV4YW1wbGU6XHJcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Q2hhaW5JZCg0NSlcclxuICAgICAqICAgIC8vX3Jlc3VsdDpcclxuICAgICAqXHJcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Q2hhaW5JZCg0NilcclxuICAgICAqICAgIC8vX3Jlc3VsdDpcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldENoYWluSWQodikge1xyXG4gICAgICAgIGNvbnN0IGJ2ID0gZ2V0QmlnSW50KHYsIFwidlwiKTtcclxuICAgICAgICAvLyBUaGUgdiBpcyBub3QgYW4gRUlQLTE1NSB2LCBzbyBpdCBpcyB0aGUgdW5zcGVjaWZpZWQgY2hhaW4gSURcclxuICAgICAgICBpZiAoKGJ2ID09IEJOXzI3KSB8fCAoYnYgPT0gQk5fMjgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBCTl8wO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBCYWQgdmFsdWUgZm9yIGFuIEVJUC0xNTUgdlxyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ2ID49IEJOXzM1LCBcImludmFsaWQgRUlQLTE1NSB2XCIsIFwidlwiLCB2KTtcclxuICAgICAgICByZXR1cm4gKGJ2IC0gQk5fMzUpIC8gQk5fMjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENvbXB1dGUgdGhlIGBgdmBgIGZvciBhIGNoYWluIElEIGZvciBhIGxlZ2FjeSBFSVAtMTU1IHRyYW5zYWN0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiAgTGVnYWN5IHRyYW5zYWN0aW9ucyB3aGljaCB1c2UgW1tsaW5rLWVpcC0xNTVdXSBoaWphY2sgdGhlIGBgdmBgXHJcbiAgICAgKiAgcHJvcGVydHkgdG8gaW5jbHVkZSB0aGUgY2hhaW4gSUQuXHJcbiAgICAgKlxyXG4gICAgICogIEBleGFtcGxlOlxyXG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWRWKDUsIDI3KVxyXG4gICAgICogICAgLy9fcmVzdWx0OlxyXG4gICAgICpcclxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkVig1LCAyOClcclxuICAgICAqICAgIC8vX3Jlc3VsdDpcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRDaGFpbklkVihjaGFpbklkLCB2KSB7XHJcbiAgICAgICAgcmV0dXJuIChnZXRCaWdJbnQoY2hhaW5JZCkgKiBCTl8yKSArIEJpZ0ludCgzNSArIHYgLSAyNyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDb21wdXRlIHRoZSBub3JtYWxpemVkIGxlZ2FjeSB0cmFuc2FjdGlvbiBgYHZgYCBmcm9tIGEgYGB5UGFyaXJ0eWBgLFxyXG4gICAgICogIGEgbGVnYWN5IHRyYW5zYWN0aW9uIGBgdmBgIG9yIGEgbGVnYWN5IFtbbGluay1laXAtMTU1XV0gdHJhbnNhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogIEBleGFtcGxlOlxyXG4gICAgICogICAgLy8gVGhlIHZhbHVlcyAwIGFuZCAxIGltcGx5IHYgaXMgYWN0dWFsbHkgeVBhcml0eVxyXG4gICAgICogICAgU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKDApXHJcbiAgICAgKiAgICAvL19yZXN1bHQ6XHJcbiAgICAgKlxyXG4gICAgICogICAgLy8gTGVnYWN5IG5vbi1FSVAtMTU1OSB0cmFuc2FjdGlvbiAoaS5lLiAyNyBvciAyOClcclxuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVigyNylcclxuICAgICAqICAgIC8vX3Jlc3VsdDpcclxuICAgICAqXHJcbiAgICAgKiAgICAvLyBMZWdhY3kgRUlQLTE1NSB0cmFuc2FjdGlvbiAoaS5lLiA+PSAzNSlcclxuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVig0NilcclxuICAgICAqICAgIC8vX3Jlc3VsdDpcclxuICAgICAqXHJcbiAgICAgKiAgICAvLyBJbnZhbGlkIHZhbHVlcyB0aHJvd1xyXG4gICAgICogICAgU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKDUpXHJcbiAgICAgKiAgICAvL19lcnJvcjpcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldE5vcm1hbGl6ZWRWKHYpIHtcclxuICAgICAgICBjb25zdCBidiA9IGdldEJpZ0ludCh2KTtcclxuICAgICAgICBpZiAoYnYgPT09IEJOXzAgfHwgYnYgPT09IEJOXzI3KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAyNztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJ2ID09PSBCTl8xIHx8IGJ2ID09PSBCTl8yOCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMjg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ2ID49IEJOXzM1LCBcImludmFsaWQgdlwiLCBcInZcIiwgdik7XHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBFSVAtMTU1IHYgbWVhbnMgb2RkIGlzIDI3IGFuZCBldmVuIGlzIDI4XHJcbiAgICAgICAgcmV0dXJuIChidiAmIEJOXzEpID8gMjcgOiAyODtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tTaWduYXR1cmVdXS5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgbm8gJSVzaWclJSBpcyBwcm92aWRlZCwgYSBuZXcgW1tTaWduYXR1cmVdXSBpcyBjcmVhdGVkXHJcbiAgICAgKiAgd2l0aCBkZWZhdWx0IHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgJSVzaWclJSBpcyBhIHN0cmluZywgaXQgaXMgcGFyc2VkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbShzaWcpIHtcclxuICAgICAgICBmdW5jdGlvbiBhc3NlcnRFcnJvcihjaGVjaywgbWVzc2FnZSkge1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChjaGVjaywgbWVzc2FnZSwgXCJzaWduYXR1cmVcIiwgc2lnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgO1xyXG4gICAgICAgIGlmIChzaWcgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIFplcm9IYXNoLCBaZXJvSGFzaCwgMjcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIChzaWcpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoc2lnLCBcInNpZ25hdHVyZVwiKTtcclxuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDMyKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYnl0ZXMuc2xpY2UoMzIsIDY0KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSAoc1swXSAmIDB4ODApID8gMjggOiAyNztcclxuICAgICAgICAgICAgICAgIHNbMF0gJj0gMHg3ZjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgciwgaGV4bGlmeShzKSwgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDMyKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoYnl0ZXNbNjRdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgciwgcywgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwiaW52YWxpZCByYXcgc2lnbmF0dXJlIGxlbmd0aFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNpZyBpbnN0YW5jZW9mIFNpZ25hdHVyZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2lnLmNsb25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdldCByXHJcbiAgICAgICAgY29uc3QgX3IgPSBzaWcucjtcclxuICAgICAgICBhc3NlcnRFcnJvcihfciAhPSBudWxsLCBcIm1pc3NpbmcgclwiKTtcclxuICAgICAgICBjb25zdCByID0gdG9VaW50MjU2KF9yKTtcclxuICAgICAgICAvLyBHZXQgczsgYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAod2UgY2hlY2sgY29uc2lzdGVuY3kgYmVsb3cpXHJcbiAgICAgICAgY29uc3QgcyA9IChmdW5jdGlvbiAocywgeVBhcml0eUFuZFMpIHtcclxuICAgICAgICAgICAgaWYgKHMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvVWludDI1NihzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoeVBhcml0eUFuZFMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoaXNIZXhTdHJpbmcoeVBhcml0eUFuZFMsIDMyKSwgXCJpbnZhbGlkIHlQYXJpdHlBbmRTXCIpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh5UGFyaXR5QW5kUyk7XHJcbiAgICAgICAgICAgICAgICBieXRlc1swXSAmPSAweDdmO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcIm1pc3Npbmcgc1wiKTtcclxuICAgICAgICB9KShzaWcucywgc2lnLnlQYXJpdHlBbmRTKTtcclxuICAgICAgICAvLyBHZXQgdjsgYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAod2UgY2hlY2sgY29uc2lzdGVuY3kgYmVsb3cpXHJcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrViwgdiB9ID0gKGZ1bmN0aW9uIChfdiwgeVBhcml0eUFuZFMsIHlQYXJpdHkpIHtcclxuICAgICAgICAgICAgaWYgKF92ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBnZXRCaWdJbnQoX3YpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrVjogKCh2ID49IEJOXzM1KSA/IHYgOiB1bmRlZmluZWQpLFxyXG4gICAgICAgICAgICAgICAgICAgIHY6IFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVih2KVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoeVBhcml0eUFuZFMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoaXNIZXhTdHJpbmcoeVBhcml0eUFuZFMsIDMyKSwgXCJpbnZhbGlkIHlQYXJpdHlBbmRTXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdjogKChnZXRCeXRlcyh5UGFyaXR5QW5kUylbMF0gJiAweDgwKSA/IDI4IDogMjcpIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHlQYXJpdHkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChnZXROdW1iZXIoeVBhcml0eSwgXCJzaWcueVBhcml0eVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIHsgdjogMjcgfTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiB7IHY6IDI4IH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRFcnJvcihmYWxzZSwgXCJpbnZhbGlkIHlQYXJpdHlcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwibWlzc2luZyB2XCIpO1xyXG4gICAgICAgIH0pKHNpZy52LCBzaWcueVBhcml0eUFuZFMsIHNpZy55UGFyaXR5KTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgciwgcywgdik7XHJcbiAgICAgICAgaWYgKG5ldHdvcmtWKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC4jbmV0d29ya1YgPSBuZXR3b3JrVjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgbXVsdGlwbGUgb2YgdiwgeVBhcml0eSwgeVBhcml0eUFuZFMgd2UgZ2l2ZW4sIGNoZWNrIHRoZXkgbWF0Y2hcclxuICAgICAgICBhc3NlcnRFcnJvcihzaWcueVBhcml0eSA9PSBudWxsIHx8IGdldE51bWJlcihzaWcueVBhcml0eSwgXCJzaWcueVBhcml0eVwiKSA9PT0gcmVzdWx0LnlQYXJpdHksIFwieVBhcml0eSBtaXNtYXRjaFwiKTtcclxuICAgICAgICBhc3NlcnRFcnJvcihzaWcueVBhcml0eUFuZFMgPT0gbnVsbCB8fCBzaWcueVBhcml0eUFuZFMgPT09IHJlc3VsdC55UGFyaXR5QW5kUywgXCJ5UGFyaXR5QW5kUyBtaXNtYXRjaFwiKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25hdHVyZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/signature.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/signing-key.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/signing-key.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SigningKey: () => (/* binding */ SigningKey)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _signature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./signature.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/signature.js\");\n/**\r\n *  Add details about signing here.\r\n *\r\n *  @_subsection: api/crypto:Signing  [about-signing]\r\n */\r\n\r\n\r\n\r\n/**\r\n *  A **SigningKey** provides high-level access to the elliptic curve\r\n *  cryptography (ECC) operations and key management.\r\n */\r\nclass SigningKey {\r\n    #privateKey;\r\n    /**\r\n     *  Creates a new **SigningKey** for %%privateKey%%.\r\n     */\r\n    constructor(privateKey) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(privateKey) === 32, \"invalid private key\", \"privateKey\", \"[REDACTED]\");\r\n        this.#privateKey = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(privateKey);\r\n    }\r\n    /**\r\n     *  The private key.\r\n     */\r\n    get privateKey() { return this.#privateKey; }\r\n    /**\r\n     *  The uncompressed public key.\r\n     *\r\n     * This will always begin with the prefix ``0x04`` and be 132\r\n     * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).\r\n     */\r\n    get publicKey() { return SigningKey.computePublicKey(this.#privateKey); }\r\n    /**\r\n     *  The compressed public key.\r\n     *\r\n     *  This will always begin with either the prefix ``0x02`` or ``0x03``\r\n     *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal\r\n     *  nibbles)\r\n     */\r\n    get compressedPublicKey() { return SigningKey.computePublicKey(this.#privateKey, true); }\r\n    /**\r\n     *  Return the signature of the signed %%digest%%.\r\n     */\r\n    sign(digest) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(digest) === 32, \"invalid digest length\", \"digest\", digest);\r\n        const sig = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.sign((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(digest), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(this.#privateKey), {\r\n            lowS: true\r\n        });\r\n        return _signature_js__WEBPACK_IMPORTED_MODULE_2__.Signature.from({\r\n            r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeHex)(sig.r, 32),\r\n            s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeHex)(sig.s, 32),\r\n            v: (sig.recovery ? 0x1c : 0x1b)\r\n        });\r\n    }\r\n    /**\r\n     *  Returns the [[link-wiki-ecdh]] shared secret between this\r\n     *  private key and the %%other%% key.\r\n     *\r\n     *  The %%other%% key may be any type of key, a raw public key,\r\n     *  a compressed/uncompressed pubic key or aprivate key.\r\n     *\r\n     *  Best practice is usually to use a cryptographic hash on the\r\n     *  returned value before using it as a symetric secret.\r\n     *\r\n     *  @example:\r\n     *    sign1 = new SigningKey(id(\"some-secret-1\"))\r\n     *    sign2 = new SigningKey(id(\"some-secret-2\"))\r\n     *\r\n     *    // Notice that privA.computeSharedSecret(pubB)...\r\n     *    sign1.computeSharedSecret(sign2.publicKey)\r\n     *    //_result:\r\n     *\r\n     *    // ...is equal to privB.computeSharedSecret(pubA).\r\n     *    sign2.computeSharedSecret(sign1.publicKey)\r\n     *    //_result:\r\n     */\r\n    computeSharedSecret(other) {\r\n        const pubKey = SigningKey.computePublicKey(other);\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.getSharedSecret((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(this.#privateKey), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(pubKey), false));\r\n    }\r\n    /**\r\n     *  Compute the public key for %%key%%, optionally %%compressed%%.\r\n     *\r\n     *  The %%key%% may be any type of key, a raw public key, a\r\n     *  compressed/uncompressed public key or private key.\r\n     *\r\n     *  @example:\r\n     *    sign = new SigningKey(id(\"some-secret\"));\r\n     *\r\n     *    // Compute the uncompressed public key for a private key\r\n     *    SigningKey.computePublicKey(sign.privateKey)\r\n     *    //_result:\r\n     *\r\n     *    // Compute the compressed public key for a private key\r\n     *    SigningKey.computePublicKey(sign.privateKey, true)\r\n     *    //_result:\r\n     *\r\n     *    // Compute the uncompressed public key\r\n     *    SigningKey.computePublicKey(sign.publicKey, false);\r\n     *    //_result:\r\n     *\r\n     *    // Compute the Compressed a public key\r\n     *    SigningKey.computePublicKey(sign.publicKey, true);\r\n     *    //_result:\r\n     */\r\n    static computePublicKey(key, compressed) {\r\n        let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(key, \"key\");\r\n        // private key\r\n        if (bytes.length === 32) {\r\n            const pubKey = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.getPublicKey(bytes, !!compressed);\r\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(pubKey);\r\n        }\r\n        // raw public key; use uncompressed key with 0x04 prefix\r\n        if (bytes.length === 64) {\r\n            const pub = new Uint8Array(65);\r\n            pub[0] = 0x04;\r\n            pub.set(bytes, 1);\r\n            bytes = pub;\r\n        }\r\n        const point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.ProjectivePoint.fromHex(bytes);\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(point.toRawBytes(compressed));\r\n    }\r\n    /**\r\n     *  Returns the public key for the private key which produced the\r\n     *  %%signature%% for the given %%digest%%.\r\n     *\r\n     *  @example:\r\n     *    key = new SigningKey(id(\"some-secret\"))\r\n     *    digest = id(\"hello world\")\r\n     *    sig = key.sign(digest)\r\n     *\r\n     *    // Notice the signer public key...\r\n     *    key.publicKey\r\n     *    //_result:\r\n     *\r\n     *    // ...is equal to the recovered public key\r\n     *    SigningKey.recoverPublicKey(digest, sig)\r\n     *    //_result:\r\n     *\r\n     */\r\n    static recoverPublicKey(digest, signature) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(digest) === 32, \"invalid digest length\", \"digest\", digest);\r\n        const sig = _signature_js__WEBPACK_IMPORTED_MODULE_2__.Signature.from(signature);\r\n        let secpSig = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.Signature.fromCompact((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([sig.r, sig.s])));\r\n        secpSig = secpSig.addRecoveryBit(sig.yParity);\r\n        const pubKey = secpSig.recoverPublicKey((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(digest));\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(pubKey != null, \"invalid signature for digest\", \"signature\", signature);\r\n        return \"0x\" + pubKey.toHex(false);\r\n    }\r\n    /**\r\n     *  Returns the point resulting from adding the ellipic curve points\r\n     *  %%p0%% and %%p1%%.\r\n     *\r\n     *  This is not a common function most developers should require, but\r\n     *  can be useful for certain privacy-specific techniques.\r\n     *\r\n     *  For example, it is used by [[HDNodeWallet]] to compute child\r\n     *  addresses from parent public keys and chain codes.\r\n     */\r\n    static addPoints(p0, p1, compressed) {\r\n        const pub0 = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));\r\n        const pub1 = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));\r\n        return \"0x\" + pub0.add(pub1).toHex(!!compressed);\r\n    }\r\n}\r\n//# sourceMappingURL=signing-key.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vc2lnbmluZy1rZXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0Q7QUFDNkQ7QUFDdEU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjLENBQUMsMkRBQVU7QUFDakMsMkJBQTJCLHdEQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWMsQ0FBQywyREFBVTtBQUNqQyxvQkFBb0IsOERBQVMsTUFBTSw2REFBWSxVQUFVLDZEQUFZO0FBQ3JFO0FBQ0EsU0FBUztBQUNULGVBQWUsb0RBQVM7QUFDeEIsZUFBZSx3REFBTztBQUN0QixlQUFlLHdEQUFPO0FBQ3RCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBTyxDQUFDLDhEQUFTLGlCQUFpQiw2REFBWSxvQkFBb0IseURBQVE7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlEQUFRO0FBQzVCO0FBQ0E7QUFDQSwyQkFBMkIsOERBQVM7QUFDcEMsbUJBQW1CLHdEQUFPO0FBQzFCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4REFBUztBQUMvQixlQUFlLHdEQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjLENBQUMsMkRBQVU7QUFDakMsb0JBQW9CLG9EQUFTO0FBQzdCLHNCQUFzQiw4REFBUyx1QkFBdUIsNkRBQVksQ0FBQyx1REFBTTtBQUN6RTtBQUNBLGdEQUFnRCw2REFBWTtBQUM1RCxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhEQUFTO0FBQzlCLHFCQUFxQiw4REFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxjcnlwdG9cXHNpZ25pbmcta2V5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgQWRkIGRldGFpbHMgYWJvdXQgc2lnbmluZyBoZXJlLlxyXG4gKlxyXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvY3J5cHRvOlNpZ25pbmcgIFthYm91dC1zaWduaW5nXVxyXG4gKi9cclxuaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCI7XHJcbmltcG9ydCB7IGNvbmNhdCwgZGF0YUxlbmd0aCwgZ2V0Qnl0ZXMsIGdldEJ5dGVzQ29weSwgaGV4bGlmeSwgdG9CZUhleCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4vc2lnbmF0dXJlLmpzXCI7XHJcbi8qKlxyXG4gKiAgQSAqKlNpZ25pbmdLZXkqKiBwcm92aWRlcyBoaWdoLWxldmVsIGFjY2VzcyB0byB0aGUgZWxsaXB0aWMgY3VydmVcclxuICogIGNyeXB0b2dyYXBoeSAoRUNDKSBvcGVyYXRpb25zIGFuZCBrZXkgbWFuYWdlbWVudC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBTaWduaW5nS2V5IHtcclxuICAgICNwcml2YXRlS2V5O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlNpZ25pbmdLZXkqKiBmb3IgJSVwcml2YXRlS2V5JSUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGVLZXkpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKHByaXZhdGVLZXkpID09PSAzMiwgXCJpbnZhbGlkIHByaXZhdGUga2V5XCIsIFwicHJpdmF0ZUtleVwiLCBcIltSRURBQ1RFRF1cIik7XHJcbiAgICAgICAgdGhpcy4jcHJpdmF0ZUtleSA9IGhleGxpZnkocHJpdmF0ZUtleSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgcHJpdmF0ZSBrZXkuXHJcbiAgICAgKi9cclxuICAgIGdldCBwcml2YXRlS2V5KCkgeyByZXR1cm4gdGhpcy4jcHJpdmF0ZUtleTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5LlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgd2lsbCBhbHdheXMgYmVnaW4gd2l0aCB0aGUgcHJlZml4IGBgMHgwNGBgIGFuZCBiZSAxMzJcclxuICAgICAqIGNoYXJhY3RlcnMgbG9uZyAodGhlIGBgMHhgYCBwcmVmaXggYW5kIDEzMCBoZXhhZGVjaW1hbCBuaWJibGVzKS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHB1YmxpY0tleSgpIHsgcmV0dXJuIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleSh0aGlzLiNwcml2YXRlS2V5KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGNvbXByZXNzZWQgcHVibGljIGtleS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyB3aWxsIGFsd2F5cyBiZWdpbiB3aXRoIGVpdGhlciB0aGUgcHJlZml4IGBgMHgwMmBgIG9yIGBgMHgwM2BgXHJcbiAgICAgKiAgYW5kIGJlIDY4IGNoYXJhY3RlcnMgbG9uZyAodGhlIGBgMHhgYCBwcmVmaXggYW5kIDMzIGhleGFkZWNpbWFsXHJcbiAgICAgKiAgbmliYmxlcylcclxuICAgICAqL1xyXG4gICAgZ2V0IGNvbXByZXNzZWRQdWJsaWNLZXkoKSB7IHJldHVybiBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkodGhpcy4jcHJpdmF0ZUtleSwgdHJ1ZSk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiB0aGUgc2lnbmF0dXJlIG9mIHRoZSBzaWduZWQgJSVkaWdlc3QlJS5cclxuICAgICAqL1xyXG4gICAgc2lnbihkaWdlc3QpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKGRpZ2VzdCkgPT09IDMyLCBcImludmFsaWQgZGlnZXN0IGxlbmd0aFwiLCBcImRpZ2VzdFwiLCBkaWdlc3QpO1xyXG4gICAgICAgIGNvbnN0IHNpZyA9IHNlY3AyNTZrMS5zaWduKGdldEJ5dGVzQ29weShkaWdlc3QpLCBnZXRCeXRlc0NvcHkodGhpcy4jcHJpdmF0ZUtleSksIHtcclxuICAgICAgICAgICAgbG93UzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuZnJvbSh7XHJcbiAgICAgICAgICAgIHI6IHRvQmVIZXgoc2lnLnIsIDMyKSxcclxuICAgICAgICAgICAgczogdG9CZUhleChzaWcucywgMzIpLFxyXG4gICAgICAgICAgICB2OiAoc2lnLnJlY292ZXJ5ID8gMHgxYyA6IDB4MWIpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRoZSBbW2xpbmstd2lraS1lY2RoXV0gc2hhcmVkIHNlY3JldCBiZXR3ZWVuIHRoaXNcclxuICAgICAqICBwcml2YXRlIGtleSBhbmQgdGhlICUlb3RoZXIlJSBrZXkuXHJcbiAgICAgKlxyXG4gICAgICogIFRoZSAlJW90aGVyJSUga2V5IG1heSBiZSBhbnkgdHlwZSBvZiBrZXksIGEgcmF3IHB1YmxpYyBrZXksXHJcbiAgICAgKiAgYSBjb21wcmVzc2VkL3VuY29tcHJlc3NlZCBwdWJpYyBrZXkgb3IgYXByaXZhdGUga2V5LlxyXG4gICAgICpcclxuICAgICAqICBCZXN0IHByYWN0aWNlIGlzIHVzdWFsbHkgdG8gdXNlIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIG9uIHRoZVxyXG4gICAgICogIHJldHVybmVkIHZhbHVlIGJlZm9yZSB1c2luZyBpdCBhcyBhIHN5bWV0cmljIHNlY3JldC5cclxuICAgICAqXHJcbiAgICAgKiAgQGV4YW1wbGU6XHJcbiAgICAgKiAgICBzaWduMSA9IG5ldyBTaWduaW5nS2V5KGlkKFwic29tZS1zZWNyZXQtMVwiKSlcclxuICAgICAqICAgIHNpZ24yID0gbmV3IFNpZ25pbmdLZXkoaWQoXCJzb21lLXNlY3JldC0yXCIpKVxyXG4gICAgICpcclxuICAgICAqICAgIC8vIE5vdGljZSB0aGF0IHByaXZBLmNvbXB1dGVTaGFyZWRTZWNyZXQocHViQikuLi5cclxuICAgICAqICAgIHNpZ24xLmNvbXB1dGVTaGFyZWRTZWNyZXQoc2lnbjIucHVibGljS2V5KVxyXG4gICAgICogICAgLy9fcmVzdWx0OlxyXG4gICAgICpcclxuICAgICAqICAgIC8vIC4uLmlzIGVxdWFsIHRvIHByaXZCLmNvbXB1dGVTaGFyZWRTZWNyZXQocHViQSkuXHJcbiAgICAgKiAgICBzaWduMi5jb21wdXRlU2hhcmVkU2VjcmV0KHNpZ24xLnB1YmxpY0tleSlcclxuICAgICAqICAgIC8vX3Jlc3VsdDpcclxuICAgICAqL1xyXG4gICAgY29tcHV0ZVNoYXJlZFNlY3JldChvdGhlcikge1xyXG4gICAgICAgIGNvbnN0IHB1YktleSA9IFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShvdGhlcik7XHJcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoc2VjcDI1NmsxLmdldFNoYXJlZFNlY3JldChnZXRCeXRlc0NvcHkodGhpcy4jcHJpdmF0ZUtleSksIGdldEJ5dGVzKHB1YktleSksIGZhbHNlKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDb21wdXRlIHRoZSBwdWJsaWMga2V5IGZvciAlJWtleSUlLCBvcHRpb25hbGx5ICUlY29tcHJlc3NlZCUlLlxyXG4gICAgICpcclxuICAgICAqICBUaGUgJSVrZXklJSBtYXkgYmUgYW55IHR5cGUgb2Yga2V5LCBhIHJhdyBwdWJsaWMga2V5LCBhXHJcbiAgICAgKiAgY29tcHJlc3NlZC91bmNvbXByZXNzZWQgcHVibGljIGtleSBvciBwcml2YXRlIGtleS5cclxuICAgICAqXHJcbiAgICAgKiAgQGV4YW1wbGU6XHJcbiAgICAgKiAgICBzaWduID0gbmV3IFNpZ25pbmdLZXkoaWQoXCJzb21lLXNlY3JldFwiKSk7XHJcbiAgICAgKlxyXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXlcclxuICAgICAqICAgIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShzaWduLnByaXZhdGVLZXkpXHJcbiAgICAgKiAgICAvL19yZXN1bHQ6XHJcbiAgICAgKlxyXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgY29tcHJlc3NlZCBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5XHJcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wcml2YXRlS2V5LCB0cnVlKVxyXG4gICAgICogICAgLy9fcmVzdWx0OlxyXG4gICAgICpcclxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5XHJcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wdWJsaWNLZXksIGZhbHNlKTtcclxuICAgICAqICAgIC8vX3Jlc3VsdDpcclxuICAgICAqXHJcbiAgICAgKiAgICAvLyBDb21wdXRlIHRoZSBDb21wcmVzc2VkIGEgcHVibGljIGtleVxyXG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHVibGljS2V5LCB0cnVlKTtcclxuICAgICAqICAgIC8vX3Jlc3VsdDpcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNvbXB1dGVQdWJsaWNLZXkoa2V5LCBjb21wcmVzc2VkKSB7XHJcbiAgICAgICAgbGV0IGJ5dGVzID0gZ2V0Qnl0ZXMoa2V5LCBcImtleVwiKTtcclxuICAgICAgICAvLyBwcml2YXRlIGtleVxyXG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDMyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHB1YktleSA9IHNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoYnl0ZXMsICEhY29tcHJlc3NlZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KHB1YktleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJhdyBwdWJsaWMga2V5OyB1c2UgdW5jb21wcmVzc2VkIGtleSB3aXRoIDB4MDQgcHJlZml4XHJcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjQpIHtcclxuICAgICAgICAgICAgY29uc3QgcHViID0gbmV3IFVpbnQ4QXJyYXkoNjUpO1xyXG4gICAgICAgICAgICBwdWJbMF0gPSAweDA0O1xyXG4gICAgICAgICAgICBwdWIuc2V0KGJ5dGVzLCAxKTtcclxuICAgICAgICAgICAgYnl0ZXMgPSBwdWI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBvaW50ID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tSGV4KGJ5dGVzKTtcclxuICAgICAgICByZXR1cm4gaGV4bGlmeShwb2ludC50b1Jhd0J5dGVzKGNvbXByZXNzZWQpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIHB1YmxpYyBrZXkgZm9yIHRoZSBwcml2YXRlIGtleSB3aGljaCBwcm9kdWNlZCB0aGVcclxuICAgICAqICAlJXNpZ25hdHVyZSUlIGZvciB0aGUgZ2l2ZW4gJSVkaWdlc3QlJS5cclxuICAgICAqXHJcbiAgICAgKiAgQGV4YW1wbGU6XHJcbiAgICAgKiAgICBrZXkgPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0XCIpKVxyXG4gICAgICogICAgZGlnZXN0ID0gaWQoXCJoZWxsbyB3b3JsZFwiKVxyXG4gICAgICogICAgc2lnID0ga2V5LnNpZ24oZGlnZXN0KVxyXG4gICAgICpcclxuICAgICAqICAgIC8vIE5vdGljZSB0aGUgc2lnbmVyIHB1YmxpYyBrZXkuLi5cclxuICAgICAqICAgIGtleS5wdWJsaWNLZXlcclxuICAgICAqICAgIC8vX3Jlc3VsdDpcclxuICAgICAqXHJcbiAgICAgKiAgICAvLyAuLi5pcyBlcXVhbCB0byB0aGUgcmVjb3ZlcmVkIHB1YmxpYyBrZXlcclxuICAgICAqICAgIFNpZ25pbmdLZXkucmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZylcclxuICAgICAqICAgIC8vX3Jlc3VsdDpcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyByZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnbmF0dXJlKSB7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YUxlbmd0aChkaWdlc3QpID09PSAzMiwgXCJpbnZhbGlkIGRpZ2VzdCBsZW5ndGhcIiwgXCJkaWdlc3RcIiwgZGlnZXN0KTtcclxuICAgICAgICBjb25zdCBzaWcgPSBTaWduYXR1cmUuZnJvbShzaWduYXR1cmUpO1xyXG4gICAgICAgIGxldCBzZWNwU2lnID0gc2VjcDI1NmsxLlNpZ25hdHVyZS5mcm9tQ29tcGFjdChnZXRCeXRlc0NvcHkoY29uY2F0KFtzaWcuciwgc2lnLnNdKSkpO1xyXG4gICAgICAgIHNlY3BTaWcgPSBzZWNwU2lnLmFkZFJlY292ZXJ5Qml0KHNpZy55UGFyaXR5KTtcclxuICAgICAgICBjb25zdCBwdWJLZXkgPSBzZWNwU2lnLnJlY292ZXJQdWJsaWNLZXkoZ2V0Qnl0ZXNDb3B5KGRpZ2VzdCkpO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHB1YktleSAhPSBudWxsLCBcImludmFsaWQgc2lnbmF0dXJlIGZvciBkaWdlc3RcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcclxuICAgICAgICByZXR1cm4gXCIweFwiICsgcHViS2V5LnRvSGV4KGZhbHNlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIHBvaW50IHJlc3VsdGluZyBmcm9tIGFkZGluZyB0aGUgZWxsaXBpYyBjdXJ2ZSBwb2ludHNcclxuICAgICAqICAlJXAwJSUgYW5kICUlcDElJS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBpcyBub3QgYSBjb21tb24gZnVuY3Rpb24gbW9zdCBkZXZlbG9wZXJzIHNob3VsZCByZXF1aXJlLCBidXRcclxuICAgICAqICBjYW4gYmUgdXNlZnVsIGZvciBjZXJ0YWluIHByaXZhY3ktc3BlY2lmaWMgdGVjaG5pcXVlcy5cclxuICAgICAqXHJcbiAgICAgKiAgRm9yIGV4YW1wbGUsIGl0IGlzIHVzZWQgYnkgW1tIRE5vZGVXYWxsZXRdXSB0byBjb21wdXRlIGNoaWxkXHJcbiAgICAgKiAgYWRkcmVzc2VzIGZyb20gcGFyZW50IHB1YmxpYyBrZXlzIGFuZCBjaGFpbiBjb2Rlcy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFkZFBvaW50cyhwMCwgcDEsIGNvbXByZXNzZWQpIHtcclxuICAgICAgICBjb25zdCBwdWIwID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tSGV4KFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShwMCkuc3Vic3RyaW5nKDIpKTtcclxuICAgICAgICBjb25zdCBwdWIxID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tSGV4KFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShwMSkuc3Vic3RyaW5nKDIpKTtcclxuICAgICAgICByZXR1cm4gXCIweFwiICsgcHViMC5hZGQocHViMSkudG9IZXgoISFjb21wcmVzc2VkKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduaW5nLWtleS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/signing-key.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/ethers.js":
/*!***********************************************!*\
  !*** ./node_modules/ethers/lib.esm/ethers.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbiCoder: () => (/* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.AbiCoder),\n/* harmony export */   AbstractProvider: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.AbstractProvider),\n/* harmony export */   AbstractSigner: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.AbstractSigner),\n/* harmony export */   AlchemyProvider: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.AlchemyProvider),\n/* harmony export */   AnkrProvider: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.AnkrProvider),\n/* harmony export */   BaseContract: () => (/* reexport safe */ _contract_index_js__WEBPACK_IMPORTED_MODULE_4__.BaseContract),\n/* harmony export */   BaseWallet: () => (/* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.BaseWallet),\n/* harmony export */   Block: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.Block),\n/* harmony export */   BlockscoutProvider: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.BlockscoutProvider),\n/* harmony export */   BrowserProvider: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.BrowserProvider),\n/* harmony export */   ChainstackProvider: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.ChainstackProvider),\n/* harmony export */   CloudflareProvider: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.CloudflareProvider),\n/* harmony export */   ConstructorFragment: () => (/* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.ConstructorFragment),\n/* harmony export */   Contract: () => (/* reexport safe */ _contract_index_js__WEBPACK_IMPORTED_MODULE_4__.Contract),\n/* harmony export */   ContractEventPayload: () => (/* reexport safe */ _contract_index_js__WEBPACK_IMPORTED_MODULE_4__.ContractEventPayload),\n/* harmony export */   ContractFactory: () => (/* reexport safe */ _contract_index_js__WEBPACK_IMPORTED_MODULE_4__.ContractFactory),\n/* harmony export */   ContractTransactionReceipt: () => (/* reexport safe */ _contract_index_js__WEBPACK_IMPORTED_MODULE_4__.ContractTransactionReceipt),\n/* harmony export */   ContractTransactionResponse: () => (/* reexport safe */ _contract_index_js__WEBPACK_IMPORTED_MODULE_4__.ContractTransactionResponse),\n/* harmony export */   ContractUnknownEventPayload: () => (/* reexport safe */ _contract_index_js__WEBPACK_IMPORTED_MODULE_4__.ContractUnknownEventPayload),\n/* harmony export */   EnsPlugin: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.EnsPlugin),\n/* harmony export */   EnsResolver: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.EnsResolver),\n/* harmony export */   ErrorDescription: () => (/* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.ErrorDescription),\n/* harmony export */   ErrorFragment: () => (/* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.ErrorFragment),\n/* harmony export */   EtherSymbol: () => (/* reexport safe */ _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.EtherSymbol),\n/* harmony export */   EtherscanPlugin: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.EtherscanPlugin),\n/* harmony export */   EtherscanProvider: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.EtherscanProvider),\n/* harmony export */   EventFragment: () => (/* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.EventFragment),\n/* harmony export */   EventLog: () => (/* reexport safe */ _contract_index_js__WEBPACK_IMPORTED_MODULE_4__.EventLog),\n/* harmony export */   EventPayload: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.EventPayload),\n/* harmony export */   FallbackFragment: () => (/* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.FallbackFragment),\n/* harmony export */   FallbackProvider: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.FallbackProvider),\n/* harmony export */   FeeData: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.FeeData),\n/* harmony export */   FeeDataNetworkPlugin: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.FeeDataNetworkPlugin),\n/* harmony export */   FetchCancelSignal: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.FetchCancelSignal),\n/* harmony export */   FetchRequest: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.FetchRequest),\n/* harmony export */   FetchResponse: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.FetchResponse),\n/* harmony export */   FetchUrlFeeDataNetworkPlugin: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.FetchUrlFeeDataNetworkPlugin),\n/* harmony export */   FixedNumber: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.FixedNumber),\n/* harmony export */   Fragment: () => (/* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.Fragment),\n/* harmony export */   FunctionFragment: () => (/* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.FunctionFragment),\n/* harmony export */   GasCostPlugin: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.GasCostPlugin),\n/* harmony export */   HDNodeVoidWallet: () => (/* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.HDNodeVoidWallet),\n/* harmony export */   HDNodeWallet: () => (/* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.HDNodeWallet),\n/* harmony export */   Indexed: () => (/* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.Indexed),\n/* harmony export */   InfuraProvider: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.InfuraProvider),\n/* harmony export */   InfuraWebSocketProvider: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.InfuraWebSocketProvider),\n/* harmony export */   Interface: () => (/* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.Interface),\n/* harmony export */   IpcSocketProvider: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.IpcSocketProvider),\n/* harmony export */   JsonRpcApiProvider: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.JsonRpcApiProvider),\n/* harmony export */   JsonRpcProvider: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.JsonRpcProvider),\n/* harmony export */   JsonRpcSigner: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.JsonRpcSigner),\n/* harmony export */   LangEn: () => (/* reexport safe */ _wordlists_index_js__WEBPACK_IMPORTED_MODULE_11__.LangEn),\n/* harmony export */   Log: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.Log),\n/* harmony export */   LogDescription: () => (/* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.LogDescription),\n/* harmony export */   MaxInt256: () => (/* reexport safe */ _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.MaxInt256),\n/* harmony export */   MaxUint256: () => (/* reexport safe */ _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.MaxUint256),\n/* harmony export */   MessagePrefix: () => (/* reexport safe */ _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.MessagePrefix),\n/* harmony export */   MinInt256: () => (/* reexport safe */ _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.MinInt256),\n/* harmony export */   Mnemonic: () => (/* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.Mnemonic),\n/* harmony export */   MulticoinProviderPlugin: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.MulticoinProviderPlugin),\n/* harmony export */   N: () => (/* reexport safe */ _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.N),\n/* harmony export */   NamedFragment: () => (/* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.NamedFragment),\n/* harmony export */   Network: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.Network),\n/* harmony export */   NetworkPlugin: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.NetworkPlugin),\n/* harmony export */   NonceManager: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.NonceManager),\n/* harmony export */   ParamType: () => (/* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.ParamType),\n/* harmony export */   PocketProvider: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.PocketProvider),\n/* harmony export */   QuickNodeProvider: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.QuickNodeProvider),\n/* harmony export */   Result: () => (/* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.Result),\n/* harmony export */   Signature: () => (/* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature),\n/* harmony export */   SigningKey: () => (/* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.SigningKey),\n/* harmony export */   SocketBlockSubscriber: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.SocketBlockSubscriber),\n/* harmony export */   SocketEventSubscriber: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.SocketEventSubscriber),\n/* harmony export */   SocketPendingSubscriber: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.SocketPendingSubscriber),\n/* harmony export */   SocketProvider: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.SocketProvider),\n/* harmony export */   SocketSubscriber: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.SocketSubscriber),\n/* harmony export */   StructFragment: () => (/* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.StructFragment),\n/* harmony export */   Transaction: () => (/* reexport safe */ _transaction_index_js__WEBPACK_IMPORTED_MODULE_8__.Transaction),\n/* harmony export */   TransactionDescription: () => (/* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.TransactionDescription),\n/* harmony export */   TransactionReceipt: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.TransactionReceipt),\n/* harmony export */   TransactionResponse: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.TransactionResponse),\n/* harmony export */   Typed: () => (/* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.Typed),\n/* harmony export */   TypedDataEncoder: () => (/* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.TypedDataEncoder),\n/* harmony export */   UndecodedEventLog: () => (/* reexport safe */ _contract_index_js__WEBPACK_IMPORTED_MODULE_4__.UndecodedEventLog),\n/* harmony export */   UnmanagedSubscriber: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.UnmanagedSubscriber),\n/* harmony export */   Utf8ErrorFuncs: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.Utf8ErrorFuncs),\n/* harmony export */   VoidSigner: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.VoidSigner),\n/* harmony export */   Wallet: () => (/* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.Wallet),\n/* harmony export */   WebSocketProvider: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.WebSocketProvider),\n/* harmony export */   WeiPerEther: () => (/* reexport safe */ _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.WeiPerEther),\n/* harmony export */   Wordlist: () => (/* reexport safe */ _wordlists_index_js__WEBPACK_IMPORTED_MODULE_11__.Wordlist),\n/* harmony export */   WordlistOwl: () => (/* reexport safe */ _wordlists_index_js__WEBPACK_IMPORTED_MODULE_11__.WordlistOwl),\n/* harmony export */   WordlistOwlA: () => (/* reexport safe */ _wordlists_index_js__WEBPACK_IMPORTED_MODULE_11__.WordlistOwlA),\n/* harmony export */   ZeroAddress: () => (/* reexport safe */ _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.ZeroAddress),\n/* harmony export */   ZeroHash: () => (/* reexport safe */ _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.ZeroHash),\n/* harmony export */   accessListify: () => (/* reexport safe */ _transaction_index_js__WEBPACK_IMPORTED_MODULE_8__.accessListify),\n/* harmony export */   assert: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.assert),\n/* harmony export */   assertArgument: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.assertArgument),\n/* harmony export */   assertArgumentCount: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.assertArgumentCount),\n/* harmony export */   assertNormalize: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.assertNormalize),\n/* harmony export */   assertPrivate: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.assertPrivate),\n/* harmony export */   authorizationify: () => (/* reexport safe */ _transaction_index_js__WEBPACK_IMPORTED_MODULE_8__.authorizationify),\n/* harmony export */   checkResultErrors: () => (/* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.checkResultErrors),\n/* harmony export */   computeAddress: () => (/* reexport safe */ _transaction_index_js__WEBPACK_IMPORTED_MODULE_8__.computeAddress),\n/* harmony export */   computeHmac: () => (/* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.computeHmac),\n/* harmony export */   concat: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.concat),\n/* harmony export */   copyRequest: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.copyRequest),\n/* harmony export */   dataLength: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.dataLength),\n/* harmony export */   dataSlice: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.dataSlice),\n/* harmony export */   decodeBase58: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.decodeBase58),\n/* harmony export */   decodeBase64: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.decodeBase64),\n/* harmony export */   decodeBytes32String: () => (/* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.decodeBytes32String),\n/* harmony export */   decodeRlp: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.decodeRlp),\n/* harmony export */   decryptCrowdsaleJson: () => (/* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.decryptCrowdsaleJson),\n/* harmony export */   decryptKeystoreJson: () => (/* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.decryptKeystoreJson),\n/* harmony export */   decryptKeystoreJsonSync: () => (/* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.decryptKeystoreJsonSync),\n/* harmony export */   defaultPath: () => (/* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.defaultPath),\n/* harmony export */   defineProperties: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.defineProperties),\n/* harmony export */   dnsEncode: () => (/* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.dnsEncode),\n/* harmony export */   encodeBase58: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.encodeBase58),\n/* harmony export */   encodeBase64: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.encodeBase64),\n/* harmony export */   encodeBytes32String: () => (/* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.encodeBytes32String),\n/* harmony export */   encodeRlp: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.encodeRlp),\n/* harmony export */   encryptKeystoreJson: () => (/* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.encryptKeystoreJson),\n/* harmony export */   encryptKeystoreJsonSync: () => (/* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.encryptKeystoreJsonSync),\n/* harmony export */   ensNormalize: () => (/* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.ensNormalize),\n/* harmony export */   formatEther: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.formatEther),\n/* harmony export */   formatUnits: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.formatUnits),\n/* harmony export */   fromTwos: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.fromTwos),\n/* harmony export */   getAccountPath: () => (/* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.getAccountPath),\n/* harmony export */   getAddress: () => (/* reexport safe */ _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress),\n/* harmony export */   getBigInt: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBigInt),\n/* harmony export */   getBytes: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBytes),\n/* harmony export */   getBytesCopy: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBytesCopy),\n/* harmony export */   getCreate2Address: () => (/* reexport safe */ _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getCreate2Address),\n/* harmony export */   getCreateAddress: () => (/* reexport safe */ _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getCreateAddress),\n/* harmony export */   getDefaultProvider: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.getDefaultProvider),\n/* harmony export */   getIcapAddress: () => (/* reexport safe */ _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getIcapAddress),\n/* harmony export */   getIndexedAccountPath: () => (/* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.getIndexedAccountPath),\n/* harmony export */   getNumber: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getNumber),\n/* harmony export */   getUint: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getUint),\n/* harmony export */   hashAuthorization: () => (/* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.hashAuthorization),\n/* harmony export */   hashMessage: () => (/* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.hashMessage),\n/* harmony export */   hexlify: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.hexlify),\n/* harmony export */   id: () => (/* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.id),\n/* harmony export */   isAddress: () => (/* reexport safe */ _address_index_js__WEBPACK_IMPORTED_MODULE_2__.isAddress),\n/* harmony export */   isAddressable: () => (/* reexport safe */ _address_index_js__WEBPACK_IMPORTED_MODULE_2__.isAddressable),\n/* harmony export */   isBytesLike: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.isBytesLike),\n/* harmony export */   isCallException: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.isCallException),\n/* harmony export */   isCrowdsaleJson: () => (/* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.isCrowdsaleJson),\n/* harmony export */   isError: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.isError),\n/* harmony export */   isHexString: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.isHexString),\n/* harmony export */   isKeystoreJson: () => (/* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.isKeystoreJson),\n/* harmony export */   isValidName: () => (/* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.isValidName),\n/* harmony export */   keccak256: () => (/* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.keccak256),\n/* harmony export */   lock: () => (/* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.lock),\n/* harmony export */   makeError: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.makeError),\n/* harmony export */   mask: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.mask),\n/* harmony export */   namehash: () => (/* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.namehash),\n/* harmony export */   parseEther: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.parseEther),\n/* harmony export */   parseUnits: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.parseUnits),\n/* harmony export */   pbkdf2: () => (/* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.pbkdf2),\n/* harmony export */   randomBytes: () => (/* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.randomBytes),\n/* harmony export */   recoverAddress: () => (/* reexport safe */ _transaction_index_js__WEBPACK_IMPORTED_MODULE_8__.recoverAddress),\n/* harmony export */   resolveAddress: () => (/* reexport safe */ _address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress),\n/* harmony export */   resolveProperties: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.resolveProperties),\n/* harmony export */   ripemd160: () => (/* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.ripemd160),\n/* harmony export */   scrypt: () => (/* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.scrypt),\n/* harmony export */   scryptSync: () => (/* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.scryptSync),\n/* harmony export */   sha256: () => (/* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.sha256),\n/* harmony export */   sha512: () => (/* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.sha512),\n/* harmony export */   showThrottleMessage: () => (/* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.showThrottleMessage),\n/* harmony export */   solidityPacked: () => (/* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.solidityPacked),\n/* harmony export */   solidityPackedKeccak256: () => (/* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.solidityPackedKeccak256),\n/* harmony export */   solidityPackedSha256: () => (/* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.solidityPackedSha256),\n/* harmony export */   stripZerosLeft: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.stripZerosLeft),\n/* harmony export */   toBeArray: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toBeArray),\n/* harmony export */   toBeHex: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toBeHex),\n/* harmony export */   toBigInt: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toBigInt),\n/* harmony export */   toNumber: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toNumber),\n/* harmony export */   toQuantity: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toQuantity),\n/* harmony export */   toTwos: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toTwos),\n/* harmony export */   toUtf8Bytes: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toUtf8Bytes),\n/* harmony export */   toUtf8CodePoints: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toUtf8CodePoints),\n/* harmony export */   toUtf8String: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toUtf8String),\n/* harmony export */   uuidV4: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.uuidV4),\n/* harmony export */   verifyAuthorization: () => (/* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.verifyAuthorization),\n/* harmony export */   verifyMessage: () => (/* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.verifyMessage),\n/* harmony export */   verifyTypedData: () => (/* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.verifyTypedData),\n/* harmony export */   version: () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_0__.version),\n/* harmony export */   wordlists: () => (/* reexport safe */ _wordlists_index_js__WEBPACK_IMPORTED_MODULE_11__.wordlists),\n/* harmony export */   zeroPadBytes: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.zeroPadBytes),\n/* harmony export */   zeroPadValue: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.zeroPadValue)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_version.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/_version.js\");\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abi/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/index.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./address/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/constants/index.js\");\n/* harmony import */ var _contract_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./contract/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/contract/index.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./crypto/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hash/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/index.js\");\n/* harmony import */ var _providers_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./providers/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./transaction/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./wallet/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/index.js\");\n/* harmony import */ var _wordlists_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./wordlists/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/index.js\");\n/////////////////////////////\r\n//\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// dummy change; to pick-up ws security issue changes\r\n//# sourceMappingURL=ethers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9ldGhlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDd0M7QUFDd1M7QUFDak07QUFDSjtBQUM0RTtBQUMzRDtBQUMrRjtBQUM2aUI7QUFDbHJCO0FBQ3FrQjtBQUNsWjtBQUMzTTtBQUM5RixpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcZXRoZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbmV4cG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvbi5qc1wiO1xyXG5leHBvcnQgeyBkZWNvZGVCeXRlczMyU3RyaW5nLCBlbmNvZGVCeXRlczMyU3RyaW5nLCBBYmlDb2RlciwgQ29uc3RydWN0b3JGcmFnbWVudCwgRXJyb3JGcmFnbWVudCwgRXZlbnRGcmFnbWVudCwgRnJhZ21lbnQsIEZhbGxiYWNrRnJhZ21lbnQsIEZ1bmN0aW9uRnJhZ21lbnQsIE5hbWVkRnJhZ21lbnQsIFBhcmFtVHlwZSwgU3RydWN0RnJhZ21lbnQsIGNoZWNrUmVzdWx0RXJyb3JzLCBFcnJvckRlc2NyaXB0aW9uLCBJbmRleGVkLCBJbnRlcmZhY2UsIExvZ0Rlc2NyaXB0aW9uLCBSZXN1bHQsIFRyYW5zYWN0aW9uRGVzY3JpcHRpb24sIFR5cGVkLCB9IGZyb20gXCIuL2FiaS9pbmRleC5qc1wiO1xyXG5leHBvcnQgeyBnZXRBZGRyZXNzLCBnZXRJY2FwQWRkcmVzcywgZ2V0Q3JlYXRlQWRkcmVzcywgZ2V0Q3JlYXRlMkFkZHJlc3MsIGlzQWRkcmVzc2FibGUsIGlzQWRkcmVzcywgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzL2luZGV4LmpzXCI7XHJcbmV4cG9ydCB7IFplcm9BZGRyZXNzLCBXZWlQZXJFdGhlciwgTWF4VWludDI1NiwgTWluSW50MjU2LCBNYXhJbnQyNTYsIE4sIFplcm9IYXNoLCBFdGhlclN5bWJvbCwgTWVzc2FnZVByZWZpeCB9IGZyb20gXCIuL2NvbnN0YW50cy9pbmRleC5qc1wiO1xyXG5leHBvcnQgeyBCYXNlQ29udHJhY3QsIENvbnRyYWN0LCBDb250cmFjdEZhY3RvcnksIENvbnRyYWN0RXZlbnRQYXlsb2FkLCBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCwgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlLCBDb250cmFjdFVua25vd25FdmVudFBheWxvYWQsIEV2ZW50TG9nLCBVbmRlY29kZWRFdmVudExvZyB9IGZyb20gXCIuL2NvbnRyYWN0L2luZGV4LmpzXCI7XHJcbmV4cG9ydCB7IGNvbXB1dGVIbWFjLCByYW5kb21CeXRlcywga2VjY2FrMjU2LCByaXBlbWQxNjAsIHNoYTI1Niwgc2hhNTEyLCBwYmtkZjIsIHNjcnlwdCwgc2NyeXB0U3luYywgbG9jaywgU2lnbmF0dXJlLCBTaWduaW5nS2V5IH0gZnJvbSBcIi4vY3J5cHRvL2luZGV4LmpzXCI7XHJcbmV4cG9ydCB7IGlkLCBlbnNOb3JtYWxpemUsIGlzVmFsaWROYW1lLCBuYW1laGFzaCwgZG5zRW5jb2RlLCBoYXNoQXV0aG9yaXphdGlvbiwgdmVyaWZ5QXV0aG9yaXphdGlvbiwgaGFzaE1lc3NhZ2UsIHZlcmlmeU1lc3NhZ2UsIHNvbGlkaXR5UGFja2VkLCBzb2xpZGl0eVBhY2tlZEtlY2NhazI1Niwgc29saWRpdHlQYWNrZWRTaGEyNTYsIFR5cGVkRGF0YUVuY29kZXIsIHZlcmlmeVR5cGVkRGF0YSB9IGZyb20gXCIuL2hhc2gvaW5kZXguanNcIjtcclxuZXhwb3J0IHsgZ2V0RGVmYXVsdFByb3ZpZGVyLCBCbG9jaywgRmVlRGF0YSwgTG9nLCBUcmFuc2FjdGlvblJlY2VpcHQsIFRyYW5zYWN0aW9uUmVzcG9uc2UsIEFic3RyYWN0U2lnbmVyLCBOb25jZU1hbmFnZXIsIFZvaWRTaWduZXIsIEFic3RyYWN0UHJvdmlkZXIsIEZhbGxiYWNrUHJvdmlkZXIsIEpzb25ScGNBcGlQcm92aWRlciwgSnNvblJwY1Byb3ZpZGVyLCBKc29uUnBjU2lnbmVyLCBCcm93c2VyUHJvdmlkZXIsIEFsY2hlbXlQcm92aWRlciwgQW5rclByb3ZpZGVyLCBCbG9ja3Njb3V0UHJvdmlkZXIsIENoYWluc3RhY2tQcm92aWRlciwgQ2xvdWRmbGFyZVByb3ZpZGVyLCBFdGhlcnNjYW5Qcm92aWRlciwgSW5mdXJhUHJvdmlkZXIsIEluZnVyYVdlYlNvY2tldFByb3ZpZGVyLCBQb2NrZXRQcm92aWRlciwgUXVpY2tOb2RlUHJvdmlkZXIsIElwY1NvY2tldFByb3ZpZGVyLCBTb2NrZXRQcm92aWRlciwgV2ViU29ja2V0UHJvdmlkZXIsIEVuc1Jlc29sdmVyLCBOZXR3b3JrLCBFbnNQbHVnaW4sIEV0aGVyc2NhblBsdWdpbiwgRmVlRGF0YU5ldHdvcmtQbHVnaW4sIEZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4sIEdhc0Nvc3RQbHVnaW4sIE5ldHdvcmtQbHVnaW4sIE11bHRpY29pblByb3ZpZGVyUGx1Z2luLCBTb2NrZXRCbG9ja1N1YnNjcmliZXIsIFNvY2tldEV2ZW50U3Vic2NyaWJlciwgU29ja2V0UGVuZGluZ1N1YnNjcmliZXIsIFNvY2tldFN1YnNjcmliZXIsIFVubWFuYWdlZFN1YnNjcmliZXIsIGNvcHlSZXF1ZXN0LCBzaG93VGhyb3R0bGVNZXNzYWdlIH0gZnJvbSBcIi4vcHJvdmlkZXJzL2luZGV4LmpzXCI7XHJcbmV4cG9ydCB7IGFjY2Vzc0xpc3RpZnksIGF1dGhvcml6YXRpb25pZnksIGNvbXB1dGVBZGRyZXNzLCByZWNvdmVyQWRkcmVzcywgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xyXG5leHBvcnQgeyBkZWNvZGVCYXNlNTgsIGVuY29kZUJhc2U1OCwgZGVjb2RlQmFzZTY0LCBlbmNvZGVCYXNlNjQsIGNvbmNhdCwgZGF0YUxlbmd0aCwgZGF0YVNsaWNlLCBnZXRCeXRlcywgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5LCBpc0hleFN0cmluZywgaXNCeXRlc0xpa2UsIHN0cmlwWmVyb3NMZWZ0LCB6ZXJvUGFkQnl0ZXMsIHplcm9QYWRWYWx1ZSwgZGVmaW5lUHJvcGVydGllcywgcmVzb2x2ZVByb3BlcnRpZXMsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGFzc2VydEFyZ3VtZW50Q291bnQsIGFzc2VydE5vcm1hbGl6ZSwgYXNzZXJ0UHJpdmF0ZSwgbWFrZUVycm9yLCBpc0NhbGxFeGNlcHRpb24sIGlzRXJyb3IsIEV2ZW50UGF5bG9hZCwgRmV0Y2hSZXF1ZXN0LCBGZXRjaFJlc3BvbnNlLCBGZXRjaENhbmNlbFNpZ25hbCwgRml4ZWROdW1iZXIsIGdldEJpZ0ludCwgZ2V0TnVtYmVyLCBnZXRVaW50LCB0b0JlQXJyYXksIHRvQmlnSW50LCB0b0JlSGV4LCB0b051bWJlciwgdG9RdWFudGl0eSwgZnJvbVR3b3MsIHRvVHdvcywgbWFzaywgZm9ybWF0RXRoZXIsIHBhcnNlRXRoZXIsIGZvcm1hdFVuaXRzLCBwYXJzZVVuaXRzLCB0b1V0ZjhCeXRlcywgdG9VdGY4Q29kZVBvaW50cywgdG9VdGY4U3RyaW5nLCBVdGY4RXJyb3JGdW5jcywgZGVjb2RlUmxwLCBlbmNvZGVSbHAsIHV1aWRWNCwgfSBmcm9tIFwiLi91dGlscy9pbmRleC5qc1wiO1xyXG5leHBvcnQgeyBNbmVtb25pYywgQmFzZVdhbGxldCwgSEROb2RlV2FsbGV0LCBIRE5vZGVWb2lkV2FsbGV0LCBXYWxsZXQsIGRlZmF1bHRQYXRoLCBnZXRBY2NvdW50UGF0aCwgZ2V0SW5kZXhlZEFjY291bnRQYXRoLCBpc0Nyb3dkc2FsZUpzb24sIGlzS2V5c3RvcmVKc29uLCBkZWNyeXB0Q3Jvd2RzYWxlSnNvbiwgZGVjcnlwdEtleXN0b3JlSnNvblN5bmMsIGRlY3J5cHRLZXlzdG9yZUpzb24sIGVuY3J5cHRLZXlzdG9yZUpzb24sIGVuY3J5cHRLZXlzdG9yZUpzb25TeW5jLCB9IGZyb20gXCIuL3dhbGxldC9pbmRleC5qc1wiO1xyXG5leHBvcnQgeyBXb3JkbGlzdCwgTGFuZ0VuLCBXb3JkbGlzdE93bCwgV29yZGxpc3RPd2xBLCB3b3JkbGlzdHMgfSBmcm9tIFwiLi93b3JkbGlzdHMvaW5kZXguanNcIjtcclxuLy8gZHVtbXkgY2hhbmdlOyB0byBwaWNrLXVwIHdzIHNlY3VyaXR5IGlzc3VlIGNoYW5nZXNcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXRoZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/ethers.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/authorization.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/hash/authorization.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hashAuthorization: () => (/* binding */ hashAuthorization),\n/* harmony export */   verifyAuthorization: () => (/* binding */ verifyAuthorization)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transaction/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n\r\n\r\n\r\n\r\n/**\r\n *  Computes the [[link-eip-7702]] authorization digest to sign.\r\n */\r\nfunction hashAuthorization(auth) {\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (auth.address) === \"string\", \"invalid address for hashAuthorization\", \"auth.address\", auth);\r\n    return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\r\n        \"0x05\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.encodeRlp)([\r\n            (auth.chainId != null) ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(auth.chainId) : \"0x\",\r\n            (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)(auth.address),\r\n            (auth.nonce != null) ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(auth.nonce) : \"0x\",\r\n        ])\r\n    ]));\r\n}\r\n/**\r\n *  Return the address of the private key that produced\r\n *  the signature %%sig%% during signing for %%message%%.\r\n */\r\nfunction verifyAuthorization(auth, sig) {\r\n    return (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.recoverAddress)(hashAuthorization(auth), sig);\r\n}\r\n//# sourceMappingURL=authorization.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL2F1dGhvcml6YXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlEO0FBQ0Y7QUFDVTtBQUN3QjtBQUNqRjtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksK0RBQWM7QUFDbEIsV0FBVywyREFBUyxDQUFDLHVEQUFNO0FBQzNCLGdCQUFnQiwwREFBUztBQUN6QixxQ0FBcUMsMERBQVM7QUFDOUMsWUFBWSw2REFBVTtBQUN0QixtQ0FBbUMsMERBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcscUVBQWM7QUFDekI7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxoYXNoXFxhdXRob3JpemF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IHJlY292ZXJBZGRyZXNzIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50LCBjb25jYXQsIGVuY29kZVJscCwgdG9CZUFycmF5IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbi8qKlxyXG4gKiAgQ29tcHV0ZXMgdGhlIFtbbGluay1laXAtNzcwMl1dIGF1dGhvcml6YXRpb24gZGlnZXN0IHRvIHNpZ24uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaGFzaEF1dGhvcml6YXRpb24oYXV0aCkge1xyXG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChhdXRoLmFkZHJlc3MpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgYWRkcmVzcyBmb3IgaGFzaEF1dGhvcml6YXRpb25cIiwgXCJhdXRoLmFkZHJlc3NcIiwgYXV0aCk7XHJcbiAgICByZXR1cm4ga2VjY2FrMjU2KGNvbmNhdChbXHJcbiAgICAgICAgXCIweDA1XCIsIGVuY29kZVJscChbXHJcbiAgICAgICAgICAgIChhdXRoLmNoYWluSWQgIT0gbnVsbCkgPyB0b0JlQXJyYXkoYXV0aC5jaGFpbklkKSA6IFwiMHhcIixcclxuICAgICAgICAgICAgZ2V0QWRkcmVzcyhhdXRoLmFkZHJlc3MpLFxyXG4gICAgICAgICAgICAoYXV0aC5ub25jZSAhPSBudWxsKSA/IHRvQmVBcnJheShhdXRoLm5vbmNlKSA6IFwiMHhcIixcclxuICAgICAgICBdKVxyXG4gICAgXSkpO1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJuIHRoZSBhZGRyZXNzIG9mIHRoZSBwcml2YXRlIGtleSB0aGF0IHByb2R1Y2VkXHJcbiAqICB0aGUgc2lnbmF0dXJlICUlc2lnJSUgZHVyaW5nIHNpZ25pbmcgZm9yICUlbWVzc2FnZSUlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeUF1dGhvcml6YXRpb24oYXV0aCwgc2lnKSB7XHJcbiAgICByZXR1cm4gcmVjb3ZlckFkZHJlc3MoaGFzaEF1dGhvcml6YXRpb24oYXV0aCksIHNpZyk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aG9yaXphdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/authorization.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/id.js":
/*!************************************************!*\
  !*** ./node_modules/ethers/lib.esm/hash/id.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   id: () => (/* binding */ id)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../crypto/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n\r\n\r\n/**\r\n *  A simple hashing function which operates on UTF-8 strings to\r\n *  compute an 32-byte identifier.\r\n *\r\n *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes\r\n *  the [[keccak256]].\r\n *\r\n *  @example:\r\n *    id(\"hello world\")\r\n *    //_result:\r\n */\r\nfunction id(value) {\r\n    return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(value));\r\n}\r\n//# sourceMappingURL=id.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL2lkLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQztBQUNDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsMkRBQVMsQ0FBQyw0REFBVztBQUNoQztBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXGhhc2hcXGlkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcclxuaW1wb3J0IHsgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuLyoqXHJcbiAqICBBIHNpbXBsZSBoYXNoaW5nIGZ1bmN0aW9uIHdoaWNoIG9wZXJhdGVzIG9uIFVURi04IHN0cmluZ3MgdG9cclxuICogIGNvbXB1dGUgYW4gMzItYnl0ZSBpZGVudGlmaWVyLlxyXG4gKlxyXG4gKiAgVGhpcyBzaW1wbHkgY29tcHV0ZXMgdGhlIFtVVEYtOCBieXRlc10odG9VdGY4Qnl0ZXMpIGFuZCBjb21wdXRlc1xyXG4gKiAgdGhlIFtba2VjY2FrMjU2XV0uXHJcbiAqXHJcbiAqICBAZXhhbXBsZTpcclxuICogICAgaWQoXCJoZWxsbyB3b3JsZFwiKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaWQodmFsdWUpIHtcclxuICAgIHJldHVybiBrZWNjYWsyNTYodG9VdGY4Qnl0ZXModmFsdWUpKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/id.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/index.js":
/*!***************************************************!*\
  !*** ./node_modules/ethers/lib.esm/hash/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypedDataEncoder: () => (/* reexport safe */ _typed_data_js__WEBPACK_IMPORTED_MODULE_5__.TypedDataEncoder),\n/* harmony export */   dnsEncode: () => (/* reexport safe */ _namehash_js__WEBPACK_IMPORTED_MODULE_2__.dnsEncode),\n/* harmony export */   ensNormalize: () => (/* reexport safe */ _namehash_js__WEBPACK_IMPORTED_MODULE_2__.ensNormalize),\n/* harmony export */   hashAuthorization: () => (/* reexport safe */ _authorization_js__WEBPACK_IMPORTED_MODULE_0__.hashAuthorization),\n/* harmony export */   hashMessage: () => (/* reexport safe */ _message_js__WEBPACK_IMPORTED_MODULE_3__.hashMessage),\n/* harmony export */   id: () => (/* reexport safe */ _id_js__WEBPACK_IMPORTED_MODULE_1__.id),\n/* harmony export */   isValidName: () => (/* reexport safe */ _namehash_js__WEBPACK_IMPORTED_MODULE_2__.isValidName),\n/* harmony export */   namehash: () => (/* reexport safe */ _namehash_js__WEBPACK_IMPORTED_MODULE_2__.namehash),\n/* harmony export */   solidityPacked: () => (/* reexport safe */ _solidity_js__WEBPACK_IMPORTED_MODULE_4__.solidityPacked),\n/* harmony export */   solidityPackedKeccak256: () => (/* reexport safe */ _solidity_js__WEBPACK_IMPORTED_MODULE_4__.solidityPackedKeccak256),\n/* harmony export */   solidityPackedSha256: () => (/* reexport safe */ _solidity_js__WEBPACK_IMPORTED_MODULE_4__.solidityPackedSha256),\n/* harmony export */   verifyAuthorization: () => (/* reexport safe */ _authorization_js__WEBPACK_IMPORTED_MODULE_0__.verifyAuthorization),\n/* harmony export */   verifyMessage: () => (/* reexport safe */ _message_js__WEBPACK_IMPORTED_MODULE_3__.verifyMessage),\n/* harmony export */   verifyTypedData: () => (/* reexport safe */ _typed_data_js__WEBPACK_IMPORTED_MODULE_5__.verifyTypedData)\n/* harmony export */ });\n/* harmony import */ var _authorization_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./authorization.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/authorization.js\");\n/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./id.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var _namehash_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./namehash.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/namehash.js\");\n/* harmony import */ var _message_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./message.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/message.js\");\n/* harmony import */ var _solidity_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./solidity.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/solidity.js\");\n/* harmony import */ var _typed_data_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./typed-data.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/typed-data.js\");\n/**\r\n *  Utilities for common tasks involving hashing. Also see\r\n *  [cryptographic hashing](about-crypto-hashing).\r\n *\r\n *  @_section: api/hashing:Hashing Utilities  [about-hashing]\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzRFO0FBQy9DO0FBQ2tEO0FBQ3JCO0FBQ29DO0FBQzFCO0FBQ3BFIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXGhhc2hcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgVXRpbGl0aWVzIGZvciBjb21tb24gdGFza3MgaW52b2x2aW5nIGhhc2hpbmcuIEFsc28gc2VlXHJcbiAqICBbY3J5cHRvZ3JhcGhpYyBoYXNoaW5nXShhYm91dC1jcnlwdG8taGFzaGluZykuXHJcbiAqXHJcbiAqICBAX3NlY3Rpb246IGFwaS9oYXNoaW5nOkhhc2hpbmcgVXRpbGl0aWVzICBbYWJvdXQtaGFzaGluZ11cclxuICovXHJcbmV4cG9ydCB7IGhhc2hBdXRob3JpemF0aW9uLCB2ZXJpZnlBdXRob3JpemF0aW9uIH0gZnJvbSBcIi4vYXV0aG9yaXphdGlvbi5qc1wiO1xyXG5leHBvcnQgeyBpZCB9IGZyb20gXCIuL2lkLmpzXCI7XHJcbmV4cG9ydCB7IGVuc05vcm1hbGl6ZSwgaXNWYWxpZE5hbWUsIG5hbWVoYXNoLCBkbnNFbmNvZGUgfSBmcm9tIFwiLi9uYW1laGFzaC5qc1wiO1xyXG5leHBvcnQgeyBoYXNoTWVzc2FnZSwgdmVyaWZ5TWVzc2FnZSB9IGZyb20gXCIuL21lc3NhZ2UuanNcIjtcclxuZXhwb3J0IHsgc29saWRpdHlQYWNrZWQsIHNvbGlkaXR5UGFja2VkS2VjY2FrMjU2LCBzb2xpZGl0eVBhY2tlZFNoYTI1NiB9IGZyb20gXCIuL3NvbGlkaXR5LmpzXCI7XHJcbmV4cG9ydCB7IFR5cGVkRGF0YUVuY29kZXIsIHZlcmlmeVR5cGVkRGF0YSB9IGZyb20gXCIuL3R5cGVkLWRhdGEuanNcIjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/message.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/hash/message.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hashMessage: () => (/* binding */ hashMessage),\n/* harmony export */   verifyMessage: () => (/* binding */ verifyMessage)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/constants/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transaction/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n\r\n\r\n\r\n\r\n/**\r\n *  Computes the [[link-eip-191]] personal-sign message digest to sign.\r\n *\r\n *  This prefixes the message with [[MessagePrefix]] and the decimal length\r\n *  of %%message%% and computes the [[keccak256]] digest.\r\n *\r\n *  If %%message%% is a string, it is converted to its UTF-8 bytes\r\n *  first. To compute the digest of a [[DataHexString]], it must be converted\r\n *  to [bytes](getBytes).\r\n *\r\n *  @example:\r\n *    hashMessage(\"Hello World\")\r\n *    //_result:\r\n *\r\n *    // Hashes the SIX (6) string characters, i.e.\r\n *    // [ \"0\", \"x\", \"4\", \"2\", \"4\", \"3\" ]\r\n *    hashMessage(\"0x4243\")\r\n *    //_result:\r\n *\r\n *    // Hashes the TWO (2) bytes [ 0x42, 0x43 ]...\r\n *    hashMessage(getBytes(\"0x4243\"))\r\n *    //_result:\r\n *\r\n *    // ...which is equal to using data\r\n *    hashMessage(new Uint8Array([ 0x42, 0x43 ]))\r\n *    //_result:\r\n *\r\n */\r\nfunction hashMessage(message) {\r\n    if (typeof (message) === \"string\") {\r\n        message = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(message);\r\n    }\r\n    return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(_constants_index_js__WEBPACK_IMPORTED_MODULE_2__.MessagePrefix),\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(String(message.length)),\r\n        message\r\n    ]));\r\n}\r\n/**\r\n *  Return the address of the private key that produced\r\n *  the signature %%sig%% during signing for %%message%%.\r\n */\r\nfunction verifyMessage(message, sig) {\r\n    const digest = hashMessage(message);\r\n    return (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.recoverAddress)(digest, sig);\r\n}\r\n//# sourceMappingURL=message.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL21lc3NhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQStDO0FBQ087QUFDRztBQUNEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGtCQUFrQiw0REFBVztBQUM3QjtBQUNBLFdBQVcsMkRBQVMsQ0FBQyx1REFBTTtBQUMzQixRQUFRLDREQUFXLENBQUMsOERBQWE7QUFDakMsUUFBUSw0REFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxXQUFXLHFFQUFjO0FBQ3pCO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcaGFzaFxcbWVzc2FnZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IE1lc3NhZ2VQcmVmaXggfSBmcm9tIFwiLi4vY29uc3RhbnRzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IHJlY292ZXJBZGRyZXNzIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGNvbmNhdCwgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuLyoqXHJcbiAqICBDb21wdXRlcyB0aGUgW1tsaW5rLWVpcC0xOTFdXSBwZXJzb25hbC1zaWduIG1lc3NhZ2UgZGlnZXN0IHRvIHNpZ24uXHJcbiAqXHJcbiAqICBUaGlzIHByZWZpeGVzIHRoZSBtZXNzYWdlIHdpdGggW1tNZXNzYWdlUHJlZml4XV0gYW5kIHRoZSBkZWNpbWFsIGxlbmd0aFxyXG4gKiAgb2YgJSVtZXNzYWdlJSUgYW5kIGNvbXB1dGVzIHRoZSBbW2tlY2NhazI1Nl1dIGRpZ2VzdC5cclxuICpcclxuICogIElmICUlbWVzc2FnZSUlIGlzIGEgc3RyaW5nLCBpdCBpcyBjb252ZXJ0ZWQgdG8gaXRzIFVURi04IGJ5dGVzXHJcbiAqICBmaXJzdC4gVG8gY29tcHV0ZSB0aGUgZGlnZXN0IG9mIGEgW1tEYXRhSGV4U3RyaW5nXV0sIGl0IG11c3QgYmUgY29udmVydGVkXHJcbiAqICB0byBbYnl0ZXNdKGdldEJ5dGVzKS5cclxuICpcclxuICogIEBleGFtcGxlOlxyXG4gKiAgICBoYXNoTWVzc2FnZShcIkhlbGxvIFdvcmxkXCIpXHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICpcclxuICogICAgLy8gSGFzaGVzIHRoZSBTSVggKDYpIHN0cmluZyBjaGFyYWN0ZXJzLCBpLmUuXHJcbiAqICAgIC8vIFsgXCIwXCIsIFwieFwiLCBcIjRcIiwgXCIyXCIsIFwiNFwiLCBcIjNcIiBdXHJcbiAqICAgIGhhc2hNZXNzYWdlKFwiMHg0MjQzXCIpXHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICpcclxuICogICAgLy8gSGFzaGVzIHRoZSBUV08gKDIpIGJ5dGVzIFsgMHg0MiwgMHg0MyBdLi4uXHJcbiAqICAgIGhhc2hNZXNzYWdlKGdldEJ5dGVzKFwiMHg0MjQzXCIpKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIC8vIC4uLndoaWNoIGlzIGVxdWFsIHRvIHVzaW5nIGRhdGFcclxuICogICAgaGFzaE1lc3NhZ2UobmV3IFVpbnQ4QXJyYXkoWyAweDQyLCAweDQzIF0pKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaGFzaE1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgaWYgKHR5cGVvZiAobWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBtZXNzYWdlID0gdG9VdGY4Qnl0ZXMobWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga2VjY2FrMjU2KGNvbmNhdChbXHJcbiAgICAgICAgdG9VdGY4Qnl0ZXMoTWVzc2FnZVByZWZpeCksXHJcbiAgICAgICAgdG9VdGY4Qnl0ZXMoU3RyaW5nKG1lc3NhZ2UubGVuZ3RoKSksXHJcbiAgICAgICAgbWVzc2FnZVxyXG4gICAgXSkpO1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJuIHRoZSBhZGRyZXNzIG9mIHRoZSBwcml2YXRlIGtleSB0aGF0IHByb2R1Y2VkXHJcbiAqICB0aGUgc2lnbmF0dXJlICUlc2lnJSUgZHVyaW5nIHNpZ25pbmcgZm9yICUlbWVzc2FnZSUlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeU1lc3NhZ2UobWVzc2FnZSwgc2lnKSB7XHJcbiAgICBjb25zdCBkaWdlc3QgPSBoYXNoTWVzc2FnZShtZXNzYWdlKTtcclxuICAgIHJldHVybiByZWNvdmVyQWRkcmVzcyhkaWdlc3QsIHNpZyk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzc2FnZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/message.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/namehash.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/hash/namehash.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dnsEncode: () => (/* binding */ dnsEncode),\n/* harmony export */   ensNormalize: () => (/* binding */ ensNormalize),\n/* harmony export */   isValidName: () => (/* binding */ isValidName),\n/* harmony export */   namehash: () => (/* binding */ namehash)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @adraffy/ens-normalize */ \"(pages-dir-browser)/./node_modules/@adraffy/ens-normalize/dist/index.mjs\");\n\r\n\r\n\r\nconst Zeros = new Uint8Array(32);\r\nZeros.fill(0);\r\nfunction checkComponent(comp) {\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(comp.length !== 0, \"invalid ENS name; empty component\", \"comp\", comp);\r\n    return comp;\r\n}\r\nfunction ensNameSplit(name) {\r\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(ensNormalize(name));\r\n    const comps = [];\r\n    if (name.length === 0) {\r\n        return comps;\r\n    }\r\n    let last = 0;\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        const d = bytes[i];\r\n        // A separator (i.e. \".\"); copy this component\r\n        if (d === 0x2e) {\r\n            comps.push(checkComponent(bytes.slice(last, i)));\r\n            last = i + 1;\r\n        }\r\n    }\r\n    // There was a stray separator at the end of the name\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(last < bytes.length, \"invalid ENS name; empty component\", \"name\", name);\r\n    comps.push(checkComponent(bytes.slice(last)));\r\n    return comps;\r\n}\r\n/**\r\n *  Returns the ENS %%name%% normalized.\r\n */\r\nfunction ensNormalize(name) {\r\n    try {\r\n        if (name.length === 0) {\r\n            throw new Error(\"empty label\");\r\n        }\r\n        return (0,_adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__.ens_normalize)(name);\r\n    }\r\n    catch (error) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, `invalid ENS name (${error.message})`, \"name\", name);\r\n    }\r\n}\r\n/**\r\n *  Returns ``true`` if %%name%% is a valid ENS name.\r\n */\r\nfunction isValidName(name) {\r\n    try {\r\n        return (ensNameSplit(name).length !== 0);\r\n    }\r\n    catch (error) { }\r\n    return false;\r\n}\r\n/**\r\n *  Returns the [[link-namehash]] for %%name%%.\r\n */\r\nfunction namehash(name) {\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof (name) === \"string\", \"invalid ENS name; not a string\", \"name\", name);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(name.length, `invalid ENS name (empty label)`, \"name\", name);\r\n    let result = Zeros;\r\n    const comps = ensNameSplit(name);\r\n    while (comps.length) {\r\n        result = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([result, (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)((comps.pop()))]));\r\n    }\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(result);\r\n}\r\n/**\r\n *  Returns the DNS encoded %%name%%.\r\n *\r\n *  This is used for various parts of ENS name resolution, such\r\n *  as the wildcard resolution.\r\n */\r\nfunction dnsEncode(name, _maxLength) {\r\n    const length = (_maxLength != null) ? _maxLength : 63;\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(length <= 255, \"DNS encoded label cannot exceed 255\", \"length\", length);\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)(ensNameSplit(name).map((comp) => {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, \"name\", name);\r\n        const bytes = new Uint8Array(comp.length + 1);\r\n        bytes.set(comp, 1);\r\n        bytes[0] = bytes.length - 1;\r\n        return bytes;\r\n    }))) + \"00\";\r\n}\r\n//# sourceMappingURL=namehash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL25hbWVoYXNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBK0M7QUFDa0M7QUFDMUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrREFBYyx1Q0FBdUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDREQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0RBQWMseUNBQXlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFFQUFhO0FBQzVCO0FBQ0E7QUFDQSxRQUFRLCtEQUFjLDZCQUE2QixjQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSwrREFBYyxnREFBZ0Q7QUFDbEUsSUFBSSwrREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkRBQVMsQ0FBQyx1REFBTSxVQUFVLDJEQUFTO0FBQ3BEO0FBQ0EsV0FBVyx3REFBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCLFdBQVcsd0RBQU8sQ0FBQyx1REFBTTtBQUN6QixRQUFRLCtEQUFjLGlDQUFpQyxzQkFBc0IsVUFBVSxRQUFRO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcaGFzaFxcbmFtZWhhc2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBjb25jYXQsIGhleGxpZnksIGFzc2VydEFyZ3VtZW50LCB0b1V0ZjhCeXRlcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBlbnNfbm9ybWFsaXplIH0gZnJvbSBcIkBhZHJhZmZ5L2Vucy1ub3JtYWxpemVcIjtcclxuY29uc3QgWmVyb3MgPSBuZXcgVWludDhBcnJheSgzMik7XHJcblplcm9zLmZpbGwoMCk7XHJcbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50KGNvbXApIHtcclxuICAgIGFzc2VydEFyZ3VtZW50KGNvbXAubGVuZ3RoICE9PSAwLCBcImludmFsaWQgRU5TIG5hbWU7IGVtcHR5IGNvbXBvbmVudFwiLCBcImNvbXBcIiwgY29tcCk7XHJcbiAgICByZXR1cm4gY29tcDtcclxufVxyXG5mdW5jdGlvbiBlbnNOYW1lU3BsaXQobmFtZSkge1xyXG4gICAgY29uc3QgYnl0ZXMgPSB0b1V0ZjhCeXRlcyhlbnNOb3JtYWxpemUobmFtZSkpO1xyXG4gICAgY29uc3QgY29tcHMgPSBbXTtcclxuICAgIGlmIChuYW1lLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBjb21wcztcclxuICAgIH1cclxuICAgIGxldCBsYXN0ID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBkID0gYnl0ZXNbaV07XHJcbiAgICAgICAgLy8gQSBzZXBhcmF0b3IgKGkuZS4gXCIuXCIpOyBjb3B5IHRoaXMgY29tcG9uZW50XHJcbiAgICAgICAgaWYgKGQgPT09IDB4MmUpIHtcclxuICAgICAgICAgICAgY29tcHMucHVzaChjaGVja0NvbXBvbmVudChieXRlcy5zbGljZShsYXN0LCBpKSkpO1xyXG4gICAgICAgICAgICBsYXN0ID0gaSArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gVGhlcmUgd2FzIGEgc3RyYXkgc2VwYXJhdG9yIGF0IHRoZSBlbmQgb2YgdGhlIG5hbWVcclxuICAgIGFzc2VydEFyZ3VtZW50KGxhc3QgPCBieXRlcy5sZW5ndGgsIFwiaW52YWxpZCBFTlMgbmFtZTsgZW1wdHkgY29tcG9uZW50XCIsIFwibmFtZVwiLCBuYW1lKTtcclxuICAgIGNvbXBzLnB1c2goY2hlY2tDb21wb25lbnQoYnl0ZXMuc2xpY2UobGFzdCkpKTtcclxuICAgIHJldHVybiBjb21wcztcclxufVxyXG4vKipcclxuICogIFJldHVybnMgdGhlIEVOUyAlJW5hbWUlJSBub3JtYWxpemVkLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuc05vcm1hbGl6ZShuYW1lKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmIChuYW1lLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBsYWJlbFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVuc19ub3JtYWxpemUobmFtZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgRU5TIG5hbWUgKCR7ZXJyb3IubWVzc2FnZX0pYCwgXCJuYW1lXCIsIG5hbWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyBgYHRydWVgYCBpZiAlJW5hbWUlJSBpcyBhIHZhbGlkIEVOUyBuYW1lLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWROYW1lKG5hbWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIChlbnNOYW1lU3BsaXQobmFtZSkubGVuZ3RoICE9PSAwKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm5zIHRoZSBbW2xpbmstbmFtZWhhc2hdXSBmb3IgJSVuYW1lJSUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbmFtZWhhc2gobmFtZSkge1xyXG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIEVOUyBuYW1lOyBub3QgYSBzdHJpbmdcIiwgXCJuYW1lXCIsIG5hbWUpO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQobmFtZS5sZW5ndGgsIGBpbnZhbGlkIEVOUyBuYW1lIChlbXB0eSBsYWJlbClgLCBcIm5hbWVcIiwgbmFtZSk7XHJcbiAgICBsZXQgcmVzdWx0ID0gWmVyb3M7XHJcbiAgICBjb25zdCBjb21wcyA9IGVuc05hbWVTcGxpdChuYW1lKTtcclxuICAgIHdoaWxlIChjb21wcy5sZW5ndGgpIHtcclxuICAgICAgICByZXN1bHQgPSBrZWNjYWsyNTYoY29uY2F0KFtyZXN1bHQsIGtlY2NhazI1NigoY29tcHMucG9wKCkpKV0pKTtcclxuICAgIH1cclxuICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm5zIHRoZSBETlMgZW5jb2RlZCAlJW5hbWUlJS5cclxuICpcclxuICogIFRoaXMgaXMgdXNlZCBmb3IgdmFyaW91cyBwYXJ0cyBvZiBFTlMgbmFtZSByZXNvbHV0aW9uLCBzdWNoXHJcbiAqICBhcyB0aGUgd2lsZGNhcmQgcmVzb2x1dGlvbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkbnNFbmNvZGUobmFtZSwgX21heExlbmd0aCkge1xyXG4gICAgY29uc3QgbGVuZ3RoID0gKF9tYXhMZW5ndGggIT0gbnVsbCkgPyBfbWF4TGVuZ3RoIDogNjM7XHJcbiAgICBhc3NlcnRBcmd1bWVudChsZW5ndGggPD0gMjU1LCBcIkROUyBlbmNvZGVkIGxhYmVsIGNhbm5vdCBleGNlZWQgMjU1XCIsIFwibGVuZ3RoXCIsIGxlbmd0aCk7XHJcbiAgICByZXR1cm4gaGV4bGlmeShjb25jYXQoZW5zTmFtZVNwbGl0KG5hbWUpLm1hcCgoY29tcCkgPT4ge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGNvbXAubGVuZ3RoIDw9IGxlbmd0aCwgYGxhYmVsICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9IGV4Y2VlZHMgJHtsZW5ndGh9IGJ5dGVzYCwgXCJuYW1lXCIsIG5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoY29tcC5sZW5ndGggKyAxKTtcclxuICAgICAgICBieXRlcy5zZXQoY29tcCwgMSk7XHJcbiAgICAgICAgYnl0ZXNbMF0gPSBieXRlcy5sZW5ndGggLSAxO1xyXG4gICAgICAgIHJldHVybiBieXRlcztcclxuICAgIH0pKSkgKyBcIjAwXCI7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZWhhc2guanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/namehash.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/solidity.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/hash/solidity.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   solidityPacked: () => (/* binding */ solidityPacked),\n/* harmony export */   solidityPackedKeccak256: () => (/* binding */ solidityPackedKeccak256),\n/* harmony export */   solidityPackedSha256: () => (/* binding */ solidityPackedSha256)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n\r\n\r\n\r\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\r\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\r\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\r\nfunction _pack(type, value, isArray) {\r\n    switch (type) {\r\n        case \"address\":\r\n            if (isArray) {\r\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(value, 32));\r\n            }\r\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(value));\r\n        case \"string\":\r\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(value);\r\n        case \"bytes\":\r\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value);\r\n        case \"bool\":\r\n            value = (!!value ? \"0x01\" : \"0x00\");\r\n            if (isArray) {\r\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(value, 32));\r\n            }\r\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value);\r\n    }\r\n    let match = type.match(regexNumber);\r\n    if (match) {\r\n        let signed = (match[1] === \"int\");\r\n        let size = parseInt(match[2] || \"256\");\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((!match[2] || match[2] === String(size)) && (size % 8 === 0) && size !== 0 && size <= 256, \"invalid number type\", \"type\", type);\r\n        if (isArray) {\r\n            size = 256;\r\n        }\r\n        if (signed) {\r\n            value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toTwos)(value, size);\r\n        }\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(value), size / 8));\r\n    }\r\n    match = type.match(regexBytes);\r\n    if (match) {\r\n        const size = parseInt(match[1]);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(String(size) === match[1] && size !== 0 && size <= 32, \"invalid bytes type\", \"type\", type);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(value) === size, `invalid value for ${type}`, \"value\", value);\r\n        if (isArray) {\r\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadBytes)(value, 32));\r\n        }\r\n        return value;\r\n    }\r\n    match = type.match(regexArray);\r\n    if (match && Array.isArray(value)) {\r\n        const baseType = match[1];\r\n        const count = parseInt(match[2] || String(value.length));\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(count === value.length, `invalid array length for ${type}`, \"value\", value);\r\n        const result = [];\r\n        value.forEach(function (value) {\r\n            result.push(_pack(baseType, value, true));\r\n        });\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(result));\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid type\", \"type\", type);\r\n}\r\n// @TODO: Array Enum\r\n/**\r\n *   Computes the [[link-solc-packed]] representation of %%values%%\r\n *   respectively to their %%types%%.\r\n *\r\n *   @example:\r\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\r\n *       solidityPacked([ \"address\", \"uint\" ], [ addr, 45 ]);\r\n *       //_result:\r\n */\r\nfunction solidityPacked(types, values) {\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(types.length === values.length, \"wrong number of values; expected ${ types.length }\", \"values\", values);\r\n    const tight = [];\r\n    types.forEach(function (type, index) {\r\n        tight.push(_pack(type, values[index]));\r\n    });\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(tight));\r\n}\r\n/**\r\n *   Computes the [[link-solc-packed]] [[keccak256]] hash of %%values%%\r\n *   respectively to their %%types%%.\r\n *\r\n *   @example:\r\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\r\n *       solidityPackedKeccak256([ \"address\", \"uint\" ], [ addr, 45 ]);\r\n *       //_result:\r\n */\r\nfunction solidityPackedKeccak256(types, values) {\r\n    return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)(solidityPacked(types, values));\r\n}\r\n/**\r\n *   Computes the [[link-solc-packed]] [[sha256]] hash of %%values%%\r\n *   respectively to their %%types%%.\r\n *\r\n *   @example:\r\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\r\n *       solidityPackedSha256([ \"address\", \"uint\" ], [ addr, 45 ]);\r\n *       //_result:\r\n */\r\nfunction solidityPackedSha256(types, values) {\r\n    return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.sha256)(solidityPacked(types, values));\r\n}\r\n//# sourceMappingURL=solidity.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL3NvbGlkaXR5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFpRDtBQUMrQjtBQUNzRTtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBUSxDQUFDLDZEQUFZO0FBQzVDO0FBQ0EsbUJBQW1CLHlEQUFRLENBQUMsNkRBQVU7QUFDdEM7QUFDQSxtQkFBbUIsNERBQVc7QUFDOUI7QUFDQSxtQkFBbUIseURBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlEQUFRLENBQUMsNkRBQVk7QUFDNUM7QUFDQSxtQkFBbUIseURBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQU07QUFDMUI7QUFDQSxlQUFlLHlEQUFRLENBQUMsNkRBQVksQ0FBQywwREFBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEIsUUFBUSwrREFBYyxDQUFDLDJEQUFVLHVDQUF1QyxLQUFLO0FBQzdFO0FBQ0EsbUJBQW1CLHlEQUFRLENBQUMsNkRBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjLHFEQUFxRCxLQUFLO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxlQUFlLHlEQUFRLENBQUMsdURBQU07QUFDOUI7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksK0RBQWMsMERBQTBELFlBQVksY0FBYztBQUN0RztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsV0FBVyx3REFBTyxDQUFDLHVEQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLDJEQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLHdEQUFPO0FBQ2xCO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcaGFzaFxcc29saWRpdHkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGtlY2NhazI1NiBhcyBfa2VjY2FrMjU2LCBzaGEyNTYgYXMgX3NoYTI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcclxuaW1wb3J0IHsgY29uY2F0LCBkYXRhTGVuZ3RoLCBnZXRCeXRlcywgaGV4bGlmeSwgdG9CZUFycmF5LCB0b1R3b3MsIHRvVXRmOEJ5dGVzLCB6ZXJvUGFkQnl0ZXMsIHplcm9QYWRWYWx1ZSwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuY29uc3QgcmVnZXhCeXRlcyA9IG5ldyBSZWdFeHAoXCJeYnl0ZXMoWzAtOV0rKSRcIik7XHJcbmNvbnN0IHJlZ2V4TnVtYmVyID0gbmV3IFJlZ0V4cChcIl4odT9pbnQpKFswLTldKikkXCIpO1xyXG5jb25zdCByZWdleEFycmF5ID0gbmV3IFJlZ0V4cChcIl4oLiopXFxcXFsoWzAtOV0qKVxcXFxdJFwiKTtcclxuZnVuY3Rpb24gX3BhY2sodHlwZSwgdmFsdWUsIGlzQXJyYXkpIHtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZXMoemVyb1BhZFZhbHVlKHZhbHVlLCAzMikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyhnZXRBZGRyZXNzKHZhbHVlKSk7XHJcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gdG9VdGY4Qnl0ZXModmFsdWUpO1xyXG4gICAgICAgIGNhc2UgXCJieXRlc1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZXModmFsdWUpO1xyXG4gICAgICAgIGNhc2UgXCJib29sXCI6XHJcbiAgICAgICAgICAgIHZhbHVlID0gKCEhdmFsdWUgPyBcIjB4MDFcIiA6IFwiMHgwMFwiKTtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyh6ZXJvUGFkVmFsdWUodmFsdWUsIDMyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVzKHZhbHVlKTtcclxuICAgIH1cclxuICAgIGxldCBtYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhOdW1iZXIpO1xyXG4gICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgbGV0IHNpZ25lZCA9IChtYXRjaFsxXSA9PT0gXCJpbnRcIik7XHJcbiAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsyXSB8fCBcIjI1NlwiKTtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudCgoIW1hdGNoWzJdIHx8IG1hdGNoWzJdID09PSBTdHJpbmcoc2l6ZSkpICYmIChzaXplICUgOCA9PT0gMCkgJiYgc2l6ZSAhPT0gMCAmJiBzaXplIDw9IDI1NiwgXCJpbnZhbGlkIG51bWJlciB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcclxuICAgICAgICBpZiAoaXNBcnJheSkge1xyXG4gICAgICAgICAgICBzaXplID0gMjU2O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2lnbmVkKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdG9Ud29zKHZhbHVlLCBzaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdldEJ5dGVzKHplcm9QYWRWYWx1ZSh0b0JlQXJyYXkodmFsdWUpLCBzaXplIC8gOCkpO1xyXG4gICAgfVxyXG4gICAgbWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4Qnl0ZXMpO1xyXG4gICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzFdKTtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChTdHJpbmcoc2l6ZSkgPT09IG1hdGNoWzFdICYmIHNpemUgIT09IDAgJiYgc2l6ZSA8PSAzMiwgXCJpbnZhbGlkIGJ5dGVzIHR5cGVcIiwgXCJ0eXBlXCIsIHR5cGUpO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgodmFsdWUpID09PSBzaXplLCBgaW52YWxpZCB2YWx1ZSBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgICAgIGlmIChpc0FycmF5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyh6ZXJvUGFkQnl0ZXModmFsdWUsIDMyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIG1hdGNoID0gdHlwZS5tYXRjaChyZWdleEFycmF5KTtcclxuICAgIGlmIChtYXRjaCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGNvbnN0IGJhc2VUeXBlID0gbWF0Y2hbMV07XHJcbiAgICAgICAgY29uc3QgY291bnQgPSBwYXJzZUludChtYXRjaFsyXSB8fCBTdHJpbmcodmFsdWUubGVuZ3RoKSk7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoY291bnQgPT09IHZhbHVlLmxlbmd0aCwgYGludmFsaWQgYXJyYXkgbGVuZ3RoIGZvciAke3R5cGV9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goX3BhY2soYmFzZVR5cGUsIHZhbHVlLCB0cnVlKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGdldEJ5dGVzKGNvbmNhdChyZXN1bHQpKTtcclxuICAgIH1cclxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XHJcbn1cclxuLy8gQFRPRE86IEFycmF5IEVudW1cclxuLyoqXHJcbiAqICAgQ29tcHV0ZXMgdGhlIFtbbGluay1zb2xjLXBhY2tlZF1dIHJlcHJlc2VudGF0aW9uIG9mICUldmFsdWVzJSVcclxuICogICByZXNwZWN0aXZlbHkgdG8gdGhlaXIgJSV0eXBlcyUlLlxyXG4gKlxyXG4gKiAgIEBleGFtcGxlOlxyXG4gKiAgICAgICBhZGRyID0gXCIweDhiYTFmMTA5NTUxYmQ0MzI4MDMwMTI2NDVhYzEzNmRkZDY0ZGJhNzJcIlxyXG4gKiAgICAgICBzb2xpZGl0eVBhY2tlZChbIFwiYWRkcmVzc1wiLCBcInVpbnRcIiBdLCBbIGFkZHIsIDQ1IF0pO1xyXG4gKiAgICAgICAvL19yZXN1bHQ6XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc29saWRpdHlQYWNrZWQodHlwZXMsIHZhbHVlcykge1xyXG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZXMubGVuZ3RoID09PSB2YWx1ZXMubGVuZ3RoLCBcIndyb25nIG51bWJlciBvZiB2YWx1ZXM7IGV4cGVjdGVkICR7IHR5cGVzLmxlbmd0aCB9XCIsIFwidmFsdWVzXCIsIHZhbHVlcyk7XHJcbiAgICBjb25zdCB0aWdodCA9IFtdO1xyXG4gICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSwgaW5kZXgpIHtcclxuICAgICAgICB0aWdodC5wdXNoKF9wYWNrKHR5cGUsIHZhbHVlc1tpbmRleF0pKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KHRpZ2h0KSk7XHJcbn1cclxuLyoqXHJcbiAqICAgQ29tcHV0ZXMgdGhlIFtbbGluay1zb2xjLXBhY2tlZF1dIFtba2VjY2FrMjU2XV0gaGFzaCBvZiAlJXZhbHVlcyUlXHJcbiAqICAgcmVzcGVjdGl2ZWx5IHRvIHRoZWlyICUldHlwZXMlJS5cclxuICpcclxuICogICBAZXhhbXBsZTpcclxuICogICAgICAgYWRkciA9IFwiMHg4YmExZjEwOTU1MWJkNDMyODAzMDEyNjQ1YWMxMzZkZGQ2NGRiYTcyXCJcclxuICogICAgICAgc29saWRpdHlQYWNrZWRLZWNjYWsyNTYoWyBcImFkZHJlc3NcIiwgXCJ1aW50XCIgXSwgWyBhZGRyLCA0NSBdKTtcclxuICogICAgICAgLy9fcmVzdWx0OlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNvbGlkaXR5UGFja2VkS2VjY2FrMjU2KHR5cGVzLCB2YWx1ZXMpIHtcclxuICAgIHJldHVybiBfa2VjY2FrMjU2KHNvbGlkaXR5UGFja2VkKHR5cGVzLCB2YWx1ZXMpKTtcclxufVxyXG4vKipcclxuICogICBDb21wdXRlcyB0aGUgW1tsaW5rLXNvbGMtcGFja2VkXV0gW1tzaGEyNTZdXSBoYXNoIG9mICUldmFsdWVzJSVcclxuICogICByZXNwZWN0aXZlbHkgdG8gdGhlaXIgJSV0eXBlcyUlLlxyXG4gKlxyXG4gKiAgIEBleGFtcGxlOlxyXG4gKiAgICAgICBhZGRyID0gXCIweDhiYTFmMTA5NTUxYmQ0MzI4MDMwMTI2NDVhYzEzNmRkZDY0ZGJhNzJcIlxyXG4gKiAgICAgICBzb2xpZGl0eVBhY2tlZFNoYTI1NihbIFwiYWRkcmVzc1wiLCBcInVpbnRcIiBdLCBbIGFkZHIsIDQ1IF0pO1xyXG4gKiAgICAgICAvL19yZXN1bHQ6XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc29saWRpdHlQYWNrZWRTaGEyNTYodHlwZXMsIHZhbHVlcykge1xyXG4gICAgcmV0dXJuIF9zaGEyNTYoc29saWRpdHlQYWNrZWQodHlwZXMsIHZhbHVlcykpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvbGlkaXR5LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/solidity.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/typed-data.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/hash/typed-data.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypedDataEncoder: () => (/* binding */ TypedDataEncoder),\n/* harmony export */   verifyTypedData: () => (/* binding */ verifyTypedData)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transaction/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./id.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/id.js\");\n//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\r\n\r\n\r\n\r\n\r\n\r\nconst padding = new Uint8Array(32);\r\npadding.fill(0);\r\nconst BN__1 = BigInt(-1);\r\nconst BN_0 = BigInt(0);\r\nconst BN_1 = BigInt(1);\r\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\r\n;\r\n;\r\nfunction hexPadRight(value) {\r\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value);\r\n    const padOffset = bytes.length % 32;\r\n    if (padOffset) {\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([bytes, padding.slice(padOffset)]);\r\n    }\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\r\n}\r\nconst hexTrue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeHex)(BN_1, 32);\r\nconst hexFalse = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeHex)(BN_0, 32);\r\nconst domainFieldTypes = {\r\n    name: \"string\",\r\n    version: \"string\",\r\n    chainId: \"uint256\",\r\n    verifyingContract: \"address\",\r\n    salt: \"bytes32\"\r\n};\r\nconst domainFieldNames = [\r\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\r\n];\r\nfunction checkString(key) {\r\n    return function (value) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (value) === \"string\", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\r\n        return value;\r\n    };\r\n}\r\nconst domainChecks = {\r\n    name: checkString(\"name\"),\r\n    version: checkString(\"version\"),\r\n    chainId: function (_value) {\r\n        const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(_value, \"domain.chainId\");\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= 0, \"invalid chain ID\", \"domain.chainId\", _value);\r\n        if (Number.isSafeInteger(value)) {\r\n            return Number(value);\r\n        }\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toQuantity)(value);\r\n    },\r\n    verifyingContract: function (value) {\r\n        try {\r\n            return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(value).toLowerCase();\r\n        }\r\n        catch (error) { }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\r\n    },\r\n    salt: function (value) {\r\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value, \"domain.salt\");\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(bytes.length === 32, `invalid domain value \"salt\"`, \"domain.salt\", value);\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\r\n    }\r\n};\r\nfunction getBaseEncoder(type) {\r\n    // intXX and uintXX\r\n    {\r\n        const match = type.match(/^(u?)int(\\d+)$/);\r\n        if (match) {\r\n            const signed = (match[1] === \"\");\r\n            const width = parseInt(match[2]);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), \"invalid numeric width\", \"type\", type);\r\n            const boundsUpper = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.mask)(BN_MAX_UINT256, signed ? (width - 1) : width);\r\n            const boundsLower = signed ? ((boundsUpper + BN_1) * BN__1) : BN_0;\r\n            return function (_value) {\r\n                const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(_value, \"value\");\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, \"value\", value);\r\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeHex)(signed ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toTwos)(value, 256) : value, 32);\r\n            };\r\n        }\r\n    }\r\n    // bytesXX\r\n    {\r\n        const match = type.match(/^bytes(\\d+)$/);\r\n        if (match) {\r\n            const width = parseInt(match[1]);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(width !== 0 && width <= 32 && match[1] === String(width), \"invalid bytes width\", \"type\", type);\r\n            return function (value) {\r\n                const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value);\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(bytes.length === width, `invalid length for ${type}`, \"value\", value);\r\n                return hexPadRight(value);\r\n            };\r\n        }\r\n    }\r\n    switch (type) {\r\n        case \"address\": return function (value) {\r\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)((0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(value), 32);\r\n        };\r\n        case \"bool\": return function (value) {\r\n            return ((!value) ? hexFalse : hexTrue);\r\n        };\r\n        case \"bytes\": return function (value) {\r\n            return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)(value);\r\n        };\r\n        case \"string\": return function (value) {\r\n            return (0,_id_js__WEBPACK_IMPORTED_MODULE_3__.id)(value);\r\n        };\r\n    }\r\n    return null;\r\n}\r\nfunction encodeType(name, fields) {\r\n    return `${name}(${fields.map(({ name, type }) => (type + \" \" + name)).join(\",\")})`;\r\n}\r\n// foo[][3] => { base: \"foo\", index: \"[][3]\", array: {\r\n//     base: \"foo\", prefix: \"foo[]\", count: 3 } }\r\nfunction splitArray(type) {\r\n    const match = type.match(/^([^\\x5b]*)((\\x5b\\d*\\x5d)*)(\\x5b(\\d*)\\x5d)$/);\r\n    if (match) {\r\n        return {\r\n            base: match[1],\r\n            index: (match[2] + match[4]),\r\n            array: {\r\n                base: match[1],\r\n                prefix: (match[1] + match[2]),\r\n                count: (match[5] ? parseInt(match[5]) : -1),\r\n            }\r\n        };\r\n    }\r\n    return { base: type };\r\n}\r\n/**\r\n *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\r\n *  for signed typed data.\r\n *\r\n *  This is useful for those that wish to compute various components of a\r\n *  typed data hash, primary types, or sub-components, but generally the\r\n *  higher level [[Signer-signTypedData]] is more useful.\r\n */\r\nclass TypedDataEncoder {\r\n    /**\r\n     *  The primary type for the structured [[types]].\r\n     *\r\n     *  This is derived automatically from the [[types]], since no\r\n     *  recursion is possible, once the DAG for the types is consturcted\r\n     *  internally, the primary type must be the only remaining type with\r\n     *  no parent nodes.\r\n     */\r\n    primaryType;\r\n    #types;\r\n    /**\r\n     *  The types.\r\n     */\r\n    get types() {\r\n        return JSON.parse(this.#types);\r\n    }\r\n    #fullTypes;\r\n    #encoderCache;\r\n    /**\r\n     *  Create a new **TypedDataEncoder** for %%types%%.\r\n     *\r\n     *  This performs all necessary checking that types are valid and\r\n     *  do not violate the [[link-eip-712]] structural constraints as\r\n     *  well as computes the [[primaryType]].\r\n     */\r\n    constructor(_types) {\r\n        this.#fullTypes = new Map();\r\n        this.#encoderCache = new Map();\r\n        // Link struct types to their direct child structs\r\n        const links = new Map();\r\n        // Link structs to structs which contain them as a child\r\n        const parents = new Map();\r\n        // Link all subtypes within a given struct\r\n        const subtypes = new Map();\r\n        const types = {};\r\n        Object.keys(_types).forEach((type) => {\r\n            types[type] = _types[type].map(({ name, type }) => {\r\n                // Normalize the base type (unless name conflict)\r\n                let { base, index } = splitArray(type);\r\n                if (base === \"int\" && !_types[\"int\"]) {\r\n                    base = \"int256\";\r\n                }\r\n                if (base === \"uint\" && !_types[\"uint\"]) {\r\n                    base = \"uint256\";\r\n                }\r\n                return { name, type: (base + (index || \"\")) };\r\n            });\r\n            links.set(type, new Set());\r\n            parents.set(type, []);\r\n            subtypes.set(type, new Set());\r\n        });\r\n        this.#types = JSON.stringify(types);\r\n        for (const name in types) {\r\n            const uniqueNames = new Set();\r\n            for (const field of types[name]) {\r\n                // Check each field has a unique name\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", _types);\r\n                uniqueNames.add(field.name);\r\n                // Get the base type (drop any array specifiers)\r\n                const baseType = splitArray(field.type).base;\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, \"types\", _types);\r\n                // Is this a base encoding type?\r\n                const encoder = getBaseEncoder(baseType);\r\n                if (encoder) {\r\n                    continue;\r\n                }\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, \"types\", _types);\r\n                // Add linkage\r\n                parents.get(baseType).push(name);\r\n                links.get(name).add(baseType);\r\n            }\r\n        }\r\n        // Deduce the primary type\r\n        const primaryTypes = Array.from(parents.keys()).filter((n) => (parents.get(n).length === 0));\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(primaryTypes.length !== 0, \"missing primary type\", \"types\", _types);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(\", \")}`, \"types\", _types);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { primaryType: primaryTypes[0] });\r\n        // Check for circular type references\r\n        function checkCircular(type, found) {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, \"types\", _types);\r\n            found.add(type);\r\n            for (const child of links.get(type)) {\r\n                if (!parents.has(child)) {\r\n                    continue;\r\n                }\r\n                // Recursively check children\r\n                checkCircular(child, found);\r\n                // Mark all ancestors as having this decendant\r\n                for (const subtype of found) {\r\n                    subtypes.get(subtype).add(child);\r\n                }\r\n            }\r\n            found.delete(type);\r\n        }\r\n        checkCircular(this.primaryType, new Set());\r\n        // Compute each fully describe type\r\n        for (const [name, set] of subtypes) {\r\n            const st = Array.from(set);\r\n            st.sort();\r\n            this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\"));\r\n        }\r\n    }\r\n    /**\r\n     *  Returnthe encoder for the specific %%type%%.\r\n     */\r\n    getEncoder(type) {\r\n        let encoder = this.#encoderCache.get(type);\r\n        if (!encoder) {\r\n            encoder = this.#getEncoder(type);\r\n            this.#encoderCache.set(type, encoder);\r\n        }\r\n        return encoder;\r\n    }\r\n    #getEncoder(type) {\r\n        // Basic encoder type (address, bool, uint256, etc)\r\n        {\r\n            const encoder = getBaseEncoder(type);\r\n            if (encoder) {\r\n                return encoder;\r\n            }\r\n        }\r\n        // Array\r\n        const array = splitArray(type).array;\r\n        if (array) {\r\n            const subtype = array.prefix;\r\n            const subEncoder = this.getEncoder(subtype);\r\n            return (value) => {\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, \"value\", value);\r\n                let result = value.map(subEncoder);\r\n                if (this.#fullTypes.has(subtype)) {\r\n                    result = result.map(_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256);\r\n                }\r\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(result));\r\n            };\r\n        }\r\n        // Struct\r\n        const fields = this.types[type];\r\n        if (fields) {\r\n            const encodedType = (0,_id_js__WEBPACK_IMPORTED_MODULE_3__.id)(this.#fullTypes.get(type));\r\n            return (value) => {\r\n                const values = fields.map(({ name, type }) => {\r\n                    const result = this.getEncoder(type)(value[name]);\r\n                    if (this.#fullTypes.has(type)) {\r\n                        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)(result);\r\n                    }\r\n                    return result;\r\n                });\r\n                values.unshift(encodedType);\r\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(values);\r\n            };\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\r\n    }\r\n    /**\r\n     *  Return the full type for %%name%%.\r\n     */\r\n    encodeType(name) {\r\n        const result = this.#fullTypes.get(name);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(result, `unknown type: ${JSON.stringify(name)}`, \"name\", name);\r\n        return result;\r\n    }\r\n    /**\r\n     *  Return the encoded %%value%% for the %%type%%.\r\n     */\r\n    encodeData(type, value) {\r\n        return this.getEncoder(type)(value);\r\n    }\r\n    /**\r\n     *  Returns the hash of %%value%% for the type of %%name%%.\r\n     */\r\n    hashStruct(name, value) {\r\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)(this.encodeData(name, value));\r\n    }\r\n    /**\r\n     *  Return the fulled encoded %%value%% for the [[types]].\r\n     */\r\n    encode(value) {\r\n        return this.encodeData(this.primaryType, value);\r\n    }\r\n    /**\r\n     *  Return the hash of the fully encoded %%value%% for the [[types]].\r\n     */\r\n    hash(value) {\r\n        return this.hashStruct(this.primaryType, value);\r\n    }\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    _visit(type, value, callback) {\r\n        // Basic encoder type (address, bool, uint256, etc)\r\n        {\r\n            const encoder = getBaseEncoder(type);\r\n            if (encoder) {\r\n                return callback(type, value);\r\n            }\r\n        }\r\n        // Array\r\n        const array = splitArray(type).array;\r\n        if (array) {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, \"value\", value);\r\n            return value.map((v) => this._visit(array.prefix, v, callback));\r\n        }\r\n        // Struct\r\n        const fields = this.types[type];\r\n        if (fields) {\r\n            return fields.reduce((accum, { name, type }) => {\r\n                accum[name] = this._visit(type, value[name], callback);\r\n                return accum;\r\n            }, {});\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\r\n    }\r\n    /**\r\n     *  Call %%calback%% for each value in %%value%%, passing the type and\r\n     *  component within %%value%%.\r\n     *\r\n     *  This is useful for replacing addresses or other transformation that\r\n     *  may be desired on each component, based on its type.\r\n     */\r\n    visit(value, callback) {\r\n        return this._visit(this.primaryType, value, callback);\r\n    }\r\n    /**\r\n     *  Create a new **TypedDataEncoder** for %%types%%.\r\n     */\r\n    static from(types) {\r\n        return new TypedDataEncoder(types);\r\n    }\r\n    /**\r\n     *  Return the primary type for %%types%%.\r\n     */\r\n    static getPrimaryType(types) {\r\n        return TypedDataEncoder.from(types).primaryType;\r\n    }\r\n    /**\r\n     *  Return the hashed struct for %%value%% using %%types%% and %%name%%.\r\n     */\r\n    static hashStruct(name, types, value) {\r\n        return TypedDataEncoder.from(types).hashStruct(name, value);\r\n    }\r\n    /**\r\n     *  Return the domain hash for %%domain%%.\r\n     */\r\n    static hashDomain(domain) {\r\n        const domainFields = [];\r\n        for (const name in domain) {\r\n            if (domain[name] == null) {\r\n                continue;\r\n            }\r\n            const type = domainFieldTypes[name];\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\r\n            domainFields.push({ name, type });\r\n        }\r\n        domainFields.sort((a, b) => {\r\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\r\n        });\r\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\r\n    }\r\n    /**\r\n     *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\r\n     */\r\n    static encode(domain, types, value) {\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\r\n            \"0x1901\",\r\n            TypedDataEncoder.hashDomain(domain),\r\n            TypedDataEncoder.from(types).hash(value)\r\n        ]);\r\n    }\r\n    /**\r\n     *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\r\n     */\r\n    static hash(domain, types, value) {\r\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)(TypedDataEncoder.encode(domain, types, value));\r\n    }\r\n    // Replaces all address types with ENS names with their looked up address\r\n    /**\r\n     * Resolves to the value from resolving all addresses in %%value%% for\r\n     * %%types%% and the %%domain%%.\r\n     */\r\n    static async resolveNames(domain, types, value, resolveName) {\r\n        // Make a copy to isolate it from the object passed in\r\n        domain = Object.assign({}, domain);\r\n        // Allow passing null to ignore value\r\n        for (const key in domain) {\r\n            if (domain[key] == null) {\r\n                delete domain[key];\r\n            }\r\n        }\r\n        // Look up all ENS names\r\n        const ensCache = {};\r\n        // Do we need to look up the domain's verifyingContract?\r\n        if (domain.verifyingContract && !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(domain.verifyingContract, 20)) {\r\n            ensCache[domain.verifyingContract] = \"0x\";\r\n        }\r\n        // We are going to use the encoder to visit all the base values\r\n        const encoder = TypedDataEncoder.from(types);\r\n        // Get a list of all the addresses\r\n        encoder.visit(value, (type, value) => {\r\n            if (type === \"address\" && !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value, 20)) {\r\n                ensCache[value] = \"0x\";\r\n            }\r\n            return value;\r\n        });\r\n        // Lookup each name\r\n        for (const name in ensCache) {\r\n            ensCache[name] = await resolveName(name);\r\n        }\r\n        // Replace the domain verifyingContract if needed\r\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\r\n            domain.verifyingContract = ensCache[domain.verifyingContract];\r\n        }\r\n        // Replace all ENS names with their address\r\n        value = encoder.visit(value, (type, value) => {\r\n            if (type === \"address\" && ensCache[value]) {\r\n                return ensCache[value];\r\n            }\r\n            return value;\r\n        });\r\n        return { domain, value };\r\n    }\r\n    /**\r\n     *  Returns the JSON-encoded payload expected by nodes which implement\r\n     *  the JSON-RPC [[link-eip-712]] method.\r\n     */\r\n    static getPayload(domain, types, value) {\r\n        // Validate the domain fields\r\n        TypedDataEncoder.hashDomain(domain);\r\n        // Derive the EIP712Domain Struct reference type\r\n        const domainValues = {};\r\n        const domainTypes = [];\r\n        domainFieldNames.forEach((name) => {\r\n            const value = domain[name];\r\n            if (value == null) {\r\n                return;\r\n            }\r\n            domainValues[name] = domainChecks[name](value);\r\n            domainTypes.push({ name, type: domainFieldTypes[name] });\r\n        });\r\n        const encoder = TypedDataEncoder.from(types);\r\n        // Get the normalized types\r\n        types = encoder.types;\r\n        const typesWithDomain = Object.assign({}, types);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\r\n        typesWithDomain.EIP712Domain = domainTypes;\r\n        // Validate the data structures and types\r\n        encoder.encode(value);\r\n        return {\r\n            types: typesWithDomain,\r\n            domain: domainValues,\r\n            primaryType: encoder.primaryType,\r\n            message: encoder.visit(value, (type, value) => {\r\n                // bytes\r\n                if (type.match(/^bytes(\\d*)/)) {\r\n                    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value));\r\n                }\r\n                // uint or int\r\n                if (type.match(/^u?int/)) {\r\n                    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value).toString();\r\n                }\r\n                switch (type) {\r\n                    case \"address\":\r\n                        return value.toLowerCase();\r\n                    case \"bool\":\r\n                        return !!value;\r\n                    case \"string\":\r\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (value) === \"string\", \"invalid string\", \"value\", value);\r\n                        return value;\r\n                }\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported type\", \"type\", type);\r\n            })\r\n        };\r\n    }\r\n}\r\n/**\r\n *  Compute the address used to sign the typed data for the %%signature%%.\r\n */\r\nfunction verifyTypedData(domain, types, value, signature) {\r\n    return (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_4__.recoverAddress)(TypedDataEncoder.hash(domain, types, value), signature);\r\n}\r\n//# sourceMappingURL=typed-data.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL3R5cGVkLWRhdGEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLFdBQVcsa0NBQWtDO0FBQ0k7QUFDRjtBQUNVO0FBQ2dIO0FBQzVJO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5REFBUTtBQUMxQjtBQUNBO0FBQ0EsZUFBZSx1REFBTTtBQUNyQjtBQUNBLFdBQVcsd0RBQU87QUFDbEI7QUFDQSxnQkFBZ0Isd0RBQU87QUFDdkIsaUJBQWlCLHdEQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWMsMERBQTBELG9CQUFvQixhQUFhLElBQUk7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMERBQVM7QUFDL0IsUUFBUSwrREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJEQUFVO0FBQ3pCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CLDZEQUFVO0FBQzdCO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCLEtBQUs7QUFDTDtBQUNBLHNCQUFzQix5REFBUTtBQUM5QixRQUFRLCtEQUFjO0FBQ3RCLGVBQWUsd0RBQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBYztBQUMxQixnQ0FBZ0MscURBQUk7QUFDcEM7QUFDQTtBQUNBLDhCQUE4QiwwREFBUztBQUN2QyxnQkFBZ0IsK0RBQWMsMEVBQTBFLEtBQUs7QUFDN0csdUJBQXVCLHdEQUFPLFVBQVUsdURBQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQWM7QUFDMUI7QUFDQSw4QkFBOEIseURB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O0FBQ0EsK0JBQStCLG9DQUFvQztBQUNuRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0RBQU8sQ0FBQyx5REFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMERBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0RBQWM7QUFDdEM7QUFDQTtBQUNBLGdCQUFnQiwrREFBYztBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLHFFQUFjO0FBQ3pCO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcaGFzaFxcdHlwZWQtZGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvL2ltcG9ydCB7IFR5cGVkRGF0YURvbWFpbiwgVHlwZWREYXRhRmllbGQgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJhYnN0cmFjdC1zaWduZXJcIjtcclxuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcclxuaW1wb3J0IHsgcmVjb3ZlckFkZHJlc3MgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcclxuaW1wb3J0IHsgY29uY2F0LCBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBoZXhsaWZ5LCBpc0hleFN0cmluZywgbWFzaywgdG9CZUhleCwgdG9RdWFudGl0eSwgdG9Ud29zLCB6ZXJvUGFkVmFsdWUsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4vaWQuanNcIjtcclxuY29uc3QgcGFkZGluZyA9IG5ldyBVaW50OEFycmF5KDMyKTtcclxucGFkZGluZy5maWxsKDApO1xyXG5jb25zdCBCTl9fMSA9IEJpZ0ludCgtMSk7XHJcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XHJcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XHJcbmNvbnN0IEJOX01BWF9VSU5UMjU2ID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xyXG47XHJcbjtcclxuZnVuY3Rpb24gaGV4UGFkUmlnaHQodmFsdWUpIHtcclxuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXModmFsdWUpO1xyXG4gICAgY29uc3QgcGFkT2Zmc2V0ID0gYnl0ZXMubGVuZ3RoICUgMzI7XHJcbiAgICBpZiAocGFkT2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbYnl0ZXMsIHBhZGRpbmcuc2xpY2UocGFkT2Zmc2V0KV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xyXG59XHJcbmNvbnN0IGhleFRydWUgPSB0b0JlSGV4KEJOXzEsIDMyKTtcclxuY29uc3QgaGV4RmFsc2UgPSB0b0JlSGV4KEJOXzAsIDMyKTtcclxuY29uc3QgZG9tYWluRmllbGRUeXBlcyA9IHtcclxuICAgIG5hbWU6IFwic3RyaW5nXCIsXHJcbiAgICB2ZXJzaW9uOiBcInN0cmluZ1wiLFxyXG4gICAgY2hhaW5JZDogXCJ1aW50MjU2XCIsXHJcbiAgICB2ZXJpZnlpbmdDb250cmFjdDogXCJhZGRyZXNzXCIsXHJcbiAgICBzYWx0OiBcImJ5dGVzMzJcIlxyXG59O1xyXG5jb25zdCBkb21haW5GaWVsZE5hbWVzID0gW1xyXG4gICAgXCJuYW1lXCIsIFwidmVyc2lvblwiLCBcImNoYWluSWRcIiwgXCJ2ZXJpZnlpbmdDb250cmFjdFwiLCBcInNhbHRcIlxyXG5dO1xyXG5mdW5jdGlvbiBjaGVja1N0cmluZyhrZXkpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiwgYGludmFsaWQgZG9tYWluIHZhbHVlIGZvciAke0pTT04uc3RyaW5naWZ5KGtleSl9YCwgYGRvbWFpbi4ke2tleX1gLCB2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBkb21haW5DaGVja3MgPSB7XHJcbiAgICBuYW1lOiBjaGVja1N0cmluZyhcIm5hbWVcIiksXHJcbiAgICB2ZXJzaW9uOiBjaGVja1N0cmluZyhcInZlcnNpb25cIiksXHJcbiAgICBjaGFpbklkOiBmdW5jdGlvbiAoX3ZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcImRvbWFpbi5jaGFpbklkXCIpO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IDAsIFwiaW52YWxpZCBjaGFpbiBJRFwiLCBcImRvbWFpbi5jaGFpbklkXCIsIF92YWx1ZSk7XHJcbiAgICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvUXVhbnRpdHkodmFsdWUpO1xyXG4gICAgfSxcclxuICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgZG9tYWluIHZhbHVlIFwidmVyaWZ5aW5nQ29udHJhY3RcImAsIFwiZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XCIsIHZhbHVlKTtcclxuICAgIH0sXHJcbiAgICBzYWx0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHZhbHVlLCBcImRvbWFpbi5zYWx0XCIpO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ5dGVzLmxlbmd0aCA9PT0gMzIsIGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInNhbHRcImAsIFwiZG9tYWluLnNhbHRcIiwgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gZ2V0QmFzZUVuY29kZXIodHlwZSkge1xyXG4gICAgLy8gaW50WFggYW5kIHVpbnRYWFxyXG4gICAge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXih1PylpbnQoXFxkKykkLyk7XHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZCA9IChtYXRjaFsxXSA9PT0gXCJcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh3aWR0aCAlIDggPT09IDAgJiYgd2lkdGggIT09IDAgJiYgd2lkdGggPD0gMjU2ICYmIG1hdGNoWzJdID09PSBTdHJpbmcod2lkdGgpLCBcImludmFsaWQgbnVtZXJpYyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kc1VwcGVyID0gbWFzayhCTl9NQVhfVUlOVDI1Niwgc2lnbmVkID8gKHdpZHRoIC0gMSkgOiB3aWR0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kc0xvd2VyID0gc2lnbmVkID8gKChib3VuZHNVcHBlciArIEJOXzEpICogQk5fXzEpIDogQk5fMDtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IGJvdW5kc0xvd2VyICYmIHZhbHVlIDw9IGJvdW5kc1VwcGVyLCBgdmFsdWUgb3V0LW9mLWJvdW5kcyBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvQmVIZXgoc2lnbmVkID8gdG9Ud29zKHZhbHVlLCAyNTYpIDogdmFsdWUsIDMyKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBieXRlc1hYXHJcbiAgICB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eYnl0ZXMoXFxkKykkLyk7XHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh3aWR0aCAhPT0gMCAmJiB3aWR0aCA8PSAzMiAmJiBtYXRjaFsxXSA9PT0gU3RyaW5nKHdpZHRoKSwgXCJpbnZhbGlkIGJ5dGVzIHdpZHRoXCIsIFwidHlwZVwiLCB0eXBlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChieXRlcy5sZW5ndGggPT09IHdpZHRoLCBgaW52YWxpZCBsZW5ndGggZm9yICR7dHlwZX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBoZXhQYWRSaWdodCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSBcImFkZHJlc3NcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gemVyb1BhZFZhbHVlKGdldEFkZHJlc3ModmFsdWUpLCAzMik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjYXNlIFwiYm9vbFwiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKCF2YWx1ZSkgPyBoZXhGYWxzZSA6IGhleFRydWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY2FzZSBcImJ5dGVzXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih2YWx1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkKHZhbHVlKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gZW5jb2RlVHlwZShuYW1lLCBmaWVsZHMpIHtcclxuICAgIHJldHVybiBgJHtuYW1lfSgke2ZpZWxkcy5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiAodHlwZSArIFwiIFwiICsgbmFtZSkpLmpvaW4oXCIsXCIpfSlgO1xyXG59XHJcbi8vIGZvb1tdWzNdID0+IHsgYmFzZTogXCJmb29cIiwgaW5kZXg6IFwiW11bM11cIiwgYXJyYXk6IHtcclxuLy8gICAgIGJhc2U6IFwiZm9vXCIsIHByZWZpeDogXCJmb29bXVwiLCBjb3VudDogMyB9IH1cclxuZnVuY3Rpb24gc3BsaXRBcnJheSh0eXBlKSB7XHJcbiAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL14oW15cXHg1Yl0qKSgoXFx4NWJcXGQqXFx4NWQpKikoXFx4NWIoXFxkKilcXHg1ZCkkLyk7XHJcbiAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBiYXNlOiBtYXRjaFsxXSxcclxuICAgICAgICAgICAgaW5kZXg6IChtYXRjaFsyXSArIG1hdGNoWzRdKSxcclxuICAgICAgICAgICAgYXJyYXk6IHtcclxuICAgICAgICAgICAgICAgIGJhc2U6IG1hdGNoWzFdLFxyXG4gICAgICAgICAgICAgICAgcHJlZml4OiAobWF0Y2hbMV0gKyBtYXRjaFsyXSksXHJcbiAgICAgICAgICAgICAgICBjb3VudDogKG1hdGNoWzVdID8gcGFyc2VJbnQobWF0Y2hbNV0pIDogLTEpLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGJhc2U6IHR5cGUgfTtcclxufVxyXG4vKipcclxuICogIEEgKipUeXBlZERhdGFFbmNvZGUqKiBwcmVwYXJlcyBhbmQgZW5jb2RlcyBbW2xpbmstZWlwLTcxMl1dIHBheWxvYWRzXHJcbiAqICBmb3Igc2lnbmVkIHR5cGVkIGRhdGEuXHJcbiAqXHJcbiAqICBUaGlzIGlzIHVzZWZ1bCBmb3IgdGhvc2UgdGhhdCB3aXNoIHRvIGNvbXB1dGUgdmFyaW91cyBjb21wb25lbnRzIG9mIGFcclxuICogIHR5cGVkIGRhdGEgaGFzaCwgcHJpbWFyeSB0eXBlcywgb3Igc3ViLWNvbXBvbmVudHMsIGJ1dCBnZW5lcmFsbHkgdGhlXHJcbiAqICBoaWdoZXIgbGV2ZWwgW1tTaWduZXItc2lnblR5cGVkRGF0YV1dIGlzIG1vcmUgdXNlZnVsLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFR5cGVkRGF0YUVuY29kZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHByaW1hcnkgdHlwZSBmb3IgdGhlIHN0cnVjdHVyZWQgW1t0eXBlc11dLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIGRlcml2ZWQgYXV0b21hdGljYWxseSBmcm9tIHRoZSBbW3R5cGVzXV0sIHNpbmNlIG5vXHJcbiAgICAgKiAgcmVjdXJzaW9uIGlzIHBvc3NpYmxlLCBvbmNlIHRoZSBEQUcgZm9yIHRoZSB0eXBlcyBpcyBjb25zdHVyY3RlZFxyXG4gICAgICogIGludGVybmFsbHksIHRoZSBwcmltYXJ5IHR5cGUgbXVzdCBiZSB0aGUgb25seSByZW1haW5pbmcgdHlwZSB3aXRoXHJcbiAgICAgKiAgbm8gcGFyZW50IG5vZGVzLlxyXG4gICAgICovXHJcbiAgICBwcmltYXJ5VHlwZTtcclxuICAgICN0eXBlcztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSB0eXBlcy5cclxuICAgICAqL1xyXG4gICAgZ2V0IHR5cGVzKCkge1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuI3R5cGVzKTtcclxuICAgIH1cclxuICAgICNmdWxsVHlwZXM7XHJcbiAgICAjZW5jb2RlckNhY2hlO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqVHlwZWREYXRhRW5jb2RlcioqIGZvciAlJXR5cGVzJSUuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgcGVyZm9ybXMgYWxsIG5lY2Vzc2FyeSBjaGVja2luZyB0aGF0IHR5cGVzIGFyZSB2YWxpZCBhbmRcclxuICAgICAqICBkbyBub3QgdmlvbGF0ZSB0aGUgW1tsaW5rLWVpcC03MTJdXSBzdHJ1Y3R1cmFsIGNvbnN0cmFpbnRzIGFzXHJcbiAgICAgKiAgd2VsbCBhcyBjb21wdXRlcyB0aGUgW1twcmltYXJ5VHlwZV1dLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihfdHlwZXMpIHtcclxuICAgICAgICB0aGlzLiNmdWxsVHlwZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy4jZW5jb2RlckNhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8vIExpbmsgc3RydWN0IHR5cGVzIHRvIHRoZWlyIGRpcmVjdCBjaGlsZCBzdHJ1Y3RzXHJcbiAgICAgICAgY29uc3QgbGlua3MgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLy8gTGluayBzdHJ1Y3RzIHRvIHN0cnVjdHMgd2hpY2ggY29udGFpbiB0aGVtIGFzIGEgY2hpbGRcclxuICAgICAgICBjb25zdCBwYXJlbnRzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8vIExpbmsgYWxsIHN1YnR5cGVzIHdpdGhpbiBhIGdpdmVuIHN0cnVjdFxyXG4gICAgICAgIGNvbnN0IHN1YnR5cGVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGNvbnN0IHR5cGVzID0ge307XHJcbiAgICAgICAgT2JqZWN0LmtleXMoX3R5cGVzKS5mb3JFYWNoKCh0eXBlKSA9PiB7XHJcbiAgICAgICAgICAgIHR5cGVzW3R5cGVdID0gX3R5cGVzW3R5cGVdLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgYmFzZSB0eXBlICh1bmxlc3MgbmFtZSBjb25mbGljdClcclxuICAgICAgICAgICAgICAgIGxldCB7IGJhc2UsIGluZGV4IH0gPSBzcGxpdEFycmF5KHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJhc2UgPT09IFwiaW50XCIgJiYgIV90eXBlc1tcImludFwiXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBcImludDI1NlwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGJhc2UgPT09IFwidWludFwiICYmICFfdHlwZXNbXCJ1aW50XCJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IFwidWludDI1NlwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFtZSwgdHlwZTogKGJhc2UgKyAoaW5kZXggfHwgXCJcIikpIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsaW5rcy5zZXQodHlwZSwgbmV3IFNldCgpKTtcclxuICAgICAgICAgICAgcGFyZW50cy5zZXQodHlwZSwgW10pO1xyXG4gICAgICAgICAgICBzdWJ0eXBlcy5zZXQodHlwZSwgbmV3IFNldCgpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLiN0eXBlcyA9IEpTT04uc3RyaW5naWZ5KHR5cGVzKTtcclxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdHlwZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZXNbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGVhY2ggZmllbGQgaGFzIGEgdW5pcXVlIG5hbWVcclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KCF1bmlxdWVOYW1lcy5oYXMoZmllbGQubmFtZSksIGBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZSAke0pTT04uc3RyaW5naWZ5KGZpZWxkLm5hbWUpfSBpbiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcclxuICAgICAgICAgICAgICAgIHVuaXF1ZU5hbWVzLmFkZChmaWVsZC5uYW1lKTtcclxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgYmFzZSB0eXBlIChkcm9wIGFueSBhcnJheSBzcGVjaWZpZXJzKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZVR5cGUgPSBzcGxpdEFycmF5KGZpZWxkLnR5cGUpLmJhc2U7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChiYXNlVHlwZSAhPT0gbmFtZSwgYGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIHRvICR7SlNPTi5zdHJpbmdpZnkoYmFzZVR5cGUpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcclxuICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgYSBiYXNlIGVuY29kaW5nIHR5cGU/XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIoYmFzZVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHBhcmVudHMuaGFzKGJhc2VUeXBlKSwgYHVua25vd24gdHlwZSAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLCBcInR5cGVzXCIsIF90eXBlcyk7XHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgbGlua2FnZVxyXG4gICAgICAgICAgICAgICAgcGFyZW50cy5nZXQoYmFzZVR5cGUpLnB1c2gobmFtZSk7XHJcbiAgICAgICAgICAgICAgICBsaW5rcy5nZXQobmFtZSkuYWRkKGJhc2VUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEZWR1Y2UgdGhlIHByaW1hcnkgdHlwZVxyXG4gICAgICAgIGNvbnN0IHByaW1hcnlUeXBlcyA9IEFycmF5LmZyb20ocGFyZW50cy5rZXlzKCkpLmZpbHRlcigobikgPT4gKHBhcmVudHMuZ2V0KG4pLmxlbmd0aCA9PT0gMCkpO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHByaW1hcnlUeXBlcy5sZW5ndGggIT09IDAsIFwibWlzc2luZyBwcmltYXJ5IHR5cGVcIiwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHByaW1hcnlUeXBlcy5sZW5ndGggPT09IDEsIGBhbWJpZ3VvdXMgcHJpbWFyeSB0eXBlcyBvciB1bnVzZWQgdHlwZXM6ICR7cHJpbWFyeVR5cGVzLm1hcCgodCkgPT4gKEpTT04uc3RyaW5naWZ5KHQpKSkuam9pbihcIiwgXCIpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcHJpbWFyeVR5cGU6IHByaW1hcnlUeXBlc1swXSB9KTtcclxuICAgICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2VzXHJcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tDaXJjdWxhcih0eXBlLCBmb3VuZCkge1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCghZm91bmQuaGFzKHR5cGUpLCBgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2UgdG8gJHtKU09OLnN0cmluZ2lmeSh0eXBlKX1gLCBcInR5cGVzXCIsIF90eXBlcyk7XHJcbiAgICAgICAgICAgIGZvdW5kLmFkZCh0eXBlKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBsaW5rcy5nZXQodHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcGFyZW50cy5oYXMoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjaGVjayBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgY2hlY2tDaXJjdWxhcihjaGlsZCwgZm91bmQpO1xyXG4gICAgICAgICAgICAgICAgLy8gTWFyayBhbGwgYW5jZXN0b3JzIGFzIGhhdmluZyB0aGlzIGRlY2VuZGFudFxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdWJ0eXBlIG9mIGZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VidHlwZXMuZ2V0KHN1YnR5cGUpLmFkZChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm91bmQuZGVsZXRlKHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGVja0NpcmN1bGFyKHRoaXMucHJpbWFyeVR5cGUsIG5ldyBTZXQoKSk7XHJcbiAgICAgICAgLy8gQ29tcHV0ZSBlYWNoIGZ1bGx5IGRlc2NyaWJlIHR5cGVcclxuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBzZXRdIG9mIHN1YnR5cGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0ID0gQXJyYXkuZnJvbShzZXQpO1xyXG4gICAgICAgICAgICBzdC5zb3J0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuI2Z1bGxUeXBlcy5zZXQobmFtZSwgZW5jb2RlVHlwZShuYW1lLCB0eXBlc1tuYW1lXSkgKyBzdC5tYXAoKHQpID0+IGVuY29kZVR5cGUodCwgdHlwZXNbdF0pKS5qb2luKFwiXCIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm50aGUgZW5jb2RlciBmb3IgdGhlIHNwZWNpZmljICUldHlwZSUlLlxyXG4gICAgICovXHJcbiAgICBnZXRFbmNvZGVyKHR5cGUpIHtcclxuICAgICAgICBsZXQgZW5jb2RlciA9IHRoaXMuI2VuY29kZXJDYWNoZS5nZXQodHlwZSk7XHJcbiAgICAgICAgaWYgKCFlbmNvZGVyKSB7XHJcbiAgICAgICAgICAgIGVuY29kZXIgPSB0aGlzLiNnZXRFbmNvZGVyKHR5cGUpO1xyXG4gICAgICAgICAgICB0aGlzLiNlbmNvZGVyQ2FjaGUuc2V0KHR5cGUsIGVuY29kZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW5jb2RlcjtcclxuICAgIH1cclxuICAgICNnZXRFbmNvZGVyKHR5cGUpIHtcclxuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcclxuICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFycmF5XHJcbiAgICAgICAgY29uc3QgYXJyYXkgPSBzcGxpdEFycmF5KHR5cGUpLmFycmF5O1xyXG4gICAgICAgIGlmIChhcnJheSkge1xyXG4gICAgICAgICAgICBjb25zdCBzdWJ0eXBlID0gYXJyYXkucHJlZml4O1xyXG4gICAgICAgICAgICBjb25zdCBzdWJFbmNvZGVyID0gdGhpcy5nZXRFbmNvZGVyKHN1YnR5cGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhcnJheS5jb3VudCA9PT0gLTEgfHwgYXJyYXkuY291bnQgPT09IHZhbHVlLmxlbmd0aCwgYGFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7YXJyYXkuY291bnR9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdmFsdWUubWFwKHN1YkVuY29kZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2Z1bGxUeXBlcy5oYXMoc3VidHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKGtlY2NhazI1Nik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGNvbmNhdChyZXN1bHQpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3RydWN0XHJcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy50eXBlc1t0eXBlXTtcclxuICAgICAgICBpZiAoZmllbGRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRUeXBlID0gaWQodGhpcy4jZnVsbFR5cGVzLmdldCh0eXBlKSk7XHJcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGZpZWxkcy5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRFbmNvZGVyKHR5cGUpKHZhbHVlW25hbWVdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jZnVsbFR5cGVzLmhhcyh0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZhbHVlcy51bnNoaWZ0KGVuY29kZWRUeXBlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb25jYXQodmFsdWVzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGB1bmtub3duIHR5cGU6ICR7dHlwZX1gLCBcInR5cGVcIiwgdHlwZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gdGhlIGZ1bGwgdHlwZSBmb3IgJSVuYW1lJSUuXHJcbiAgICAgKi9cclxuICAgIGVuY29kZVR5cGUobmFtZSkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2Z1bGxUeXBlcy5nZXQobmFtZSk7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0LCBgdW5rbm93biB0eXBlOiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwibmFtZVwiLCBuYW1lKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBlbmNvZGVkICUldmFsdWUlJSBmb3IgdGhlICUldHlwZSUlLlxyXG4gICAgICovXHJcbiAgICBlbmNvZGVEYXRhKHR5cGUsIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW5jb2Rlcih0eXBlKSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRoZSBoYXNoIG9mICUldmFsdWUlJSBmb3IgdGhlIHR5cGUgb2YgJSVuYW1lJSUuXHJcbiAgICAgKi9cclxuICAgIGhhc2hTdHJ1Y3QobmFtZSwgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHRoaXMuZW5jb2RlRGF0YShuYW1lLCB2YWx1ZSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxsZWQgZW5jb2RlZCAlJXZhbHVlJSUgZm9yIHRoZSBbW3R5cGVzXV0uXHJcbiAgICAgKi9cclxuICAgIGVuY29kZSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZURhdGEodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBoYXNoIG9mIHRoZSBmdWxseSBlbmNvZGVkICUldmFsdWUlJSBmb3IgdGhlIFtbdHlwZXNdXS5cclxuICAgICAqL1xyXG4gICAgaGFzaCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhhc2hTdHJ1Y3QodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIF92aXNpdCh0eXBlLCB2YWx1ZSwgY2FsbGJhY2spIHtcclxuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcclxuICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0eXBlLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQXJyYXlcclxuICAgICAgICBjb25zdCBhcnJheSA9IHNwbGl0QXJyYXkodHlwZSkuYXJyYXk7XHJcbiAgICAgICAgaWYgKGFycmF5KSB7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFycmF5LmNvdW50ID09PSAtMSB8fCBhcnJheS5jb3VudCA9PT0gdmFsdWUubGVuZ3RoLCBgYXJyYXkgbGVuZ3RoIG1pc21hdGNoOyBleHBlY3RlZCBsZW5ndGggJHthcnJheS5jb3VudH1gLCBcInZhbHVlXCIsIHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gdGhpcy5fdmlzaXQoYXJyYXkucHJlZml4LCB2LCBjYWxsYmFjaykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdHJ1Y3RcclxuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnR5cGVzW3R5cGVdO1xyXG4gICAgICAgIGlmIChmaWVsZHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoKGFjY3VtLCB7IG5hbWUsIHR5cGUgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSB0aGlzLl92aXNpdCh0eXBlLCB2YWx1ZVtuYW1lXSwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xyXG4gICAgICAgICAgICB9LCB7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgdW5rbm93biB0eXBlOiAke3R5cGV9YCwgXCJ0eXBlXCIsIHR5cGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ2FsbCAlJWNhbGJhY2slJSBmb3IgZWFjaCB2YWx1ZSBpbiAlJXZhbHVlJSUsIHBhc3NpbmcgdGhlIHR5cGUgYW5kXHJcbiAgICAgKiAgY29tcG9uZW50IHdpdGhpbiAlJXZhbHVlJSUuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgaXMgdXNlZnVsIGZvciByZXBsYWNpbmcgYWRkcmVzc2VzIG9yIG90aGVyIHRyYW5zZm9ybWF0aW9uIHRoYXRcclxuICAgICAqICBtYXkgYmUgZGVzaXJlZCBvbiBlYWNoIGNvbXBvbmVudCwgYmFzZWQgb24gaXRzIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIHZpc2l0KHZhbHVlLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdCh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSwgY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqVHlwZWREYXRhRW5jb2RlcioqIGZvciAlJXR5cGVzJSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tKHR5cGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZERhdGFFbmNvZGVyKHR5cGVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiB0aGUgcHJpbWFyeSB0eXBlIGZvciAlJXR5cGVzJSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRQcmltYXJ5VHlwZSh0eXBlcykge1xyXG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLnByaW1hcnlUeXBlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBoYXNoZWQgc3RydWN0IGZvciAlJXZhbHVlJSUgdXNpbmcgJSV0eXBlcyUlIGFuZCAlJW5hbWUlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGhhc2hTdHJ1Y3QobmFtZSwgdHlwZXMsIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykuaGFzaFN0cnVjdChuYW1lLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gdGhlIGRvbWFpbiBoYXNoIGZvciAlJWRvbWFpbiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaGFzaERvbWFpbihkb21haW4pIHtcclxuICAgICAgICBjb25zdCBkb21haW5GaWVsZHMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZG9tYWluKSB7XHJcbiAgICAgICAgICAgIGlmIChkb21haW5bbmFtZV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGRvbWFpbkZpZWxkVHlwZXNbbmFtZV07XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGUsIGBpbnZhbGlkIHR5cGVkLWRhdGEgZG9tYWluIGtleTogJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcImRvbWFpblwiLCBkb21haW4pO1xyXG4gICAgICAgICAgICBkb21haW5GaWVsZHMucHVzaCh7IG5hbWUsIHR5cGUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvbWFpbkZpZWxkcy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBkb21haW5GaWVsZE5hbWVzLmluZGV4T2YoYS5uYW1lKSAtIGRvbWFpbkZpZWxkTmFtZXMuaW5kZXhPZihiLm5hbWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmhhc2hTdHJ1Y3QoXCJFSVA3MTJEb21haW5cIiwgeyBFSVA3MTJEb21haW46IGRvbWFpbkZpZWxkcyB9LCBkb21haW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxseSBlbmNvZGVkIFtbbGluay1laXAtNzEyXV0gJSV2YWx1ZSUlIGZvciAlJXR5cGVzJSUgd2l0aCAlJWRvbWFpbiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZW5jb2RlKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbXHJcbiAgICAgICAgICAgIFwiMHgxOTAxXCIsXHJcbiAgICAgICAgICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbihkb21haW4pLFxyXG4gICAgICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLmhhc2godmFsdWUpXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gdGhlIGhhc2ggb2YgdGhlIGZ1bGx5IGVuY29kZWQgW1tsaW5rLWVpcC03MTJdXSAlJXZhbHVlJSUgZm9yICUldHlwZXMlJSB3aXRoICUlZG9tYWluJSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBoYXNoKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGtlY2NhazI1NihUeXBlZERhdGFFbmNvZGVyLmVuY29kZShkb21haW4sIHR5cGVzLCB2YWx1ZSkpO1xyXG4gICAgfVxyXG4gICAgLy8gUmVwbGFjZXMgYWxsIGFkZHJlc3MgdHlwZXMgd2l0aCBFTlMgbmFtZXMgd2l0aCB0aGVpciBsb29rZWQgdXAgYWRkcmVzc1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNvbHZlcyB0byB0aGUgdmFsdWUgZnJvbSByZXNvbHZpbmcgYWxsIGFkZHJlc3NlcyBpbiAlJXZhbHVlJSUgZm9yXHJcbiAgICAgKiAlJXR5cGVzJSUgYW5kIHRoZSAlJWRvbWFpbiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYXN5bmMgcmVzb2x2ZU5hbWVzKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCByZXNvbHZlTmFtZSkge1xyXG4gICAgICAgIC8vIE1ha2UgYSBjb3B5IHRvIGlzb2xhdGUgaXQgZnJvbSB0aGUgb2JqZWN0IHBhc3NlZCBpblxyXG4gICAgICAgIGRvbWFpbiA9IE9iamVjdC5hc3NpZ24oe30sIGRvbWFpbik7XHJcbiAgICAgICAgLy8gQWxsb3cgcGFzc2luZyBudWxsIHRvIGlnbm9yZSB2YWx1ZVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRvbWFpbikge1xyXG4gICAgICAgICAgICBpZiAoZG9tYWluW2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGRvbWFpbltrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIExvb2sgdXAgYWxsIEVOUyBuYW1lc1xyXG4gICAgICAgIGNvbnN0IGVuc0NhY2hlID0ge307XHJcbiAgICAgICAgLy8gRG8gd2UgbmVlZCB0byBsb29rIHVwIHRoZSBkb21haW4ncyB2ZXJpZnlpbmdDb250cmFjdD9cclxuICAgICAgICBpZiAoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ICYmICFpc0hleFN0cmluZyhkb21haW4udmVyaWZ5aW5nQ29udHJhY3QsIDIwKSkge1xyXG4gICAgICAgICAgICBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdID0gXCIweFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gdXNlIHRoZSBlbmNvZGVyIHRvIHZpc2l0IGFsbCB0aGUgYmFzZSB2YWx1ZXNcclxuICAgICAgICBjb25zdCBlbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtcclxuICAgICAgICAvLyBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgYWRkcmVzc2VzXHJcbiAgICAgICAgZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiAhaXNIZXhTdHJpbmcodmFsdWUsIDIwKSkge1xyXG4gICAgICAgICAgICAgICAgZW5zQ2FjaGVbdmFsdWVdID0gXCIweFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBMb29rdXAgZWFjaCBuYW1lXHJcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGVuc0NhY2hlKSB7XHJcbiAgICAgICAgICAgIGVuc0NhY2hlW25hbWVdID0gYXdhaXQgcmVzb2x2ZU5hbWUobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGRvbWFpbiB2ZXJpZnlpbmdDb250cmFjdCBpZiBuZWVkZWRcclxuICAgICAgICBpZiAoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ICYmIGVuc0NhY2hlW2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdF0pIHtcclxuICAgICAgICAgICAgZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ID0gZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVwbGFjZSBhbGwgRU5TIG5hbWVzIHdpdGggdGhlaXIgYWRkcmVzc1xyXG4gICAgICAgIHZhbHVlID0gZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiBlbnNDYWNoZVt2YWx1ZV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbnNDYWNoZVt2YWx1ZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB7IGRvbWFpbiwgdmFsdWUgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIEpTT04tZW5jb2RlZCBwYXlsb2FkIGV4cGVjdGVkIGJ5IG5vZGVzIHdoaWNoIGltcGxlbWVudFxyXG4gICAgICogIHRoZSBKU09OLVJQQyBbW2xpbmstZWlwLTcxMl1dIG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldFBheWxvYWQoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcclxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZG9tYWluIGZpZWxkc1xyXG4gICAgICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbihkb21haW4pO1xyXG4gICAgICAgIC8vIERlcml2ZSB0aGUgRUlQNzEyRG9tYWluIFN0cnVjdCByZWZlcmVuY2UgdHlwZVxyXG4gICAgICAgIGNvbnN0IGRvbWFpblZhbHVlcyA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGRvbWFpblR5cGVzID0gW107XHJcbiAgICAgICAgZG9tYWluRmllbGROYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9tYWluW25hbWVdO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRvbWFpblZhbHVlc1tuYW1lXSA9IGRvbWFpbkNoZWNrc1tuYW1lXSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGRvbWFpblR5cGVzLnB1c2goeyBuYW1lLCB0eXBlOiBkb21haW5GaWVsZFR5cGVzW25hbWVdIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpO1xyXG4gICAgICAgIC8vIEdldCB0aGUgbm9ybWFsaXplZCB0eXBlc1xyXG4gICAgICAgIHR5cGVzID0gZW5jb2Rlci50eXBlcztcclxuICAgICAgICBjb25zdCB0eXBlc1dpdGhEb21haW4gPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlcyk7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZXNXaXRoRG9tYWluLkVJUDcxMkRvbWFpbiA9PSBudWxsLCBcInR5cGVzIG11c3Qgbm90IGNvbnRhaW4gRUlQNzEyRG9tYWluIHR5cGVcIiwgXCJ0eXBlcy5FSVA3MTJEb21haW5cIiwgdHlwZXMpO1xyXG4gICAgICAgIHR5cGVzV2l0aERvbWFpbi5FSVA3MTJEb21haW4gPSBkb21haW5UeXBlcztcclxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZGF0YSBzdHJ1Y3R1cmVzIGFuZCB0eXBlc1xyXG4gICAgICAgIGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlczogdHlwZXNXaXRoRG9tYWluLFxyXG4gICAgICAgICAgICBkb21haW46IGRvbWFpblZhbHVlcyxcclxuICAgICAgICAgICAgcHJpbWFyeVR5cGU6IGVuY29kZXIucHJpbWFyeVR5cGUsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVuY29kZXIudmlzaXQodmFsdWUsICh0eXBlLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gYnl0ZXNcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlLm1hdGNoKC9eYnl0ZXMoXFxkKikvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGdldEJ5dGVzKHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB1aW50IG9yIGludFxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUubWF0Y2goL151P2ludC8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib29sXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIsIFwiaW52YWxpZCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIHR5cGVcIiwgXCJ0eXBlXCIsIHR5cGUpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBDb21wdXRlIHRoZSBhZGRyZXNzIHVzZWQgdG8gc2lnbiB0aGUgdHlwZWQgZGF0YSBmb3IgdGhlICUlc2lnbmF0dXJlJSUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5VHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCBzaWduYXR1cmUpIHtcclxuICAgIHJldHVybiByZWNvdmVyQWRkcmVzcyhUeXBlZERhdGFFbmNvZGVyLmhhc2goZG9tYWluLCB0eXBlcywgdmFsdWUpLCBzaWduYXR1cmUpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVkLWRhdGEuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/typed-data.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/index.js":
/*!**********************************************!*\
  !*** ./node_modules/ethers/lib.esm/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ethers: () => (/* reexport module object */ _ethers_js__WEBPACK_IMPORTED_MODULE_0__)\n/* harmony export */ });\n/* harmony import */ var _ethers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ethers.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/ethers.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _ethers_js__WEBPACK_IMPORTED_MODULE_0__) if([\"default\",\"ethers\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _ethers_js__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/**\r\n *  The Application Programming Interface (API) is the collection of\r\n *  functions, classes and types offered by the Ethers library.\r\n *\r\n *  @_section: api:Application Programming Interface  [about-api]\r\n *  @_navTitle: API\r\n */\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NDO0FBQ3BCO0FBQ1U7QUFDNUIiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqICBUaGUgQXBwbGljYXRpb24gUHJvZ3JhbW1pbmcgSW50ZXJmYWNlIChBUEkpIGlzIHRoZSBjb2xsZWN0aW9uIG9mXHJcbiAqICBmdW5jdGlvbnMsIGNsYXNzZXMgYW5kIHR5cGVzIG9mZmVyZWQgYnkgdGhlIEV0aGVycyBsaWJyYXJ5LlxyXG4gKlxyXG4gKiAgQF9zZWN0aW9uOiBhcGk6QXBwbGljYXRpb24gUHJvZ3JhbW1pbmcgSW50ZXJmYWNlICBbYWJvdXQtYXBpXVxyXG4gKiAgQF9uYXZUaXRsZTogQVBJXHJcbiAqL1xyXG5pbXBvcnQgKiBhcyBldGhlcnMgZnJvbSBcIi4vZXRoZXJzLmpzXCI7XHJcbmV4cG9ydCB7IGV0aGVycyB9O1xyXG5leHBvcnQgKiBmcm9tIFwiLi9ldGhlcnMuanNcIjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/abstract-provider.js":
/*!********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/abstract-provider.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractProvider: () => (/* binding */ AbstractProvider),\n/* harmony export */   UnmanagedSubscriber: () => (/* binding */ UnmanagedSubscriber)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/constants/index.js\");\n/* harmony import */ var _contract_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../contract/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/contract/index.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../hash/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../transaction/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _ens_resolver_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ens-resolver.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/ens-resolver.js\");\n/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./format.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/format.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./provider.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n/**\r\n *  The available providers should suffice for most developers purposes,\r\n *  but the [[AbstractProvider]] class has many features which enable\r\n *  sub-classing it for specific purposes.\r\n *\r\n *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]\r\n */\r\n// @TODO\r\n// Event coalescence\r\n//   When we register an event with an async value (e.g. address is a Signer\r\n//   or ENS name), we need to add it immeidately for the Event API, but also\r\n//   need time to resolve the address. Upon resolving the address, we need to\r\n//   migrate the listener to the static event. We also need to maintain a map\r\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Constants\r\nconst BN_2 = BigInt(2);\r\nconst MAX_CCIP_REDIRECTS = 10;\r\nfunction isPromise(value) {\r\n    return (value && typeof (value.then) === \"function\");\r\n}\r\nfunction getTag(prefix, value) {\r\n    return prefix + \":\" + JSON.stringify(value, (k, v) => {\r\n        if (v == null) {\r\n            return \"null\";\r\n        }\r\n        if (typeof (v) === \"bigint\") {\r\n            return `bigint:${v.toString()}`;\r\n        }\r\n        if (typeof (v) === \"string\") {\r\n            return v.toLowerCase();\r\n        }\r\n        // Sort object keys\r\n        if (typeof (v) === \"object\" && !Array.isArray(v)) {\r\n            const keys = Object.keys(v);\r\n            keys.sort();\r\n            return keys.reduce((accum, key) => {\r\n                accum[key] = v[key];\r\n                return accum;\r\n            }, {});\r\n        }\r\n        return v;\r\n    });\r\n}\r\n/**\r\n *  An **UnmanagedSubscriber** is useful for events which do not require\r\n *  any additional management, such as ``\"debug\"`` which only requires\r\n *  emit in synchronous event loop triggered calls.\r\n */\r\nclass UnmanagedSubscriber {\r\n    /**\r\n     *  The name fof the event.\r\n     */\r\n    name;\r\n    /**\r\n     *  Create a new UnmanagedSubscriber with %%name%%.\r\n     */\r\n    constructor(name) { (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { name }); }\r\n    start() { }\r\n    stop() { }\r\n    pause(dropWhilePaused) { }\r\n    resume() { }\r\n}\r\nfunction copy(value) {\r\n    return JSON.parse(JSON.stringify(value));\r\n}\r\nfunction concisify(items) {\r\n    items = Array.from((new Set(items)).values());\r\n    items.sort();\r\n    return items;\r\n}\r\nasync function getSubscription(_event, provider) {\r\n    if (_event == null) {\r\n        throw new Error(\"invalid event\");\r\n    }\r\n    // Normalize topic array info an EventFilter\r\n    if (Array.isArray(_event)) {\r\n        _event = { topics: _event };\r\n    }\r\n    if (typeof (_event) === \"string\") {\r\n        switch (_event) {\r\n            case \"block\":\r\n            case \"debug\":\r\n            case \"error\":\r\n            case \"finalized\":\r\n            case \"network\":\r\n            case \"pending\":\r\n            case \"safe\": {\r\n                return { type: _event, tag: _event };\r\n            }\r\n        }\r\n    }\r\n    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(_event, 32)) {\r\n        const hash = _event.toLowerCase();\r\n        return { type: \"transaction\", tag: getTag(\"tx\", { hash }), hash };\r\n    }\r\n    if (_event.orphan) {\r\n        const event = _event;\r\n        // @TODO: Should lowercase and whatnot things here instead of copy...\r\n        return { type: \"orphan\", tag: getTag(\"orphan\", event), filter: copy(event) };\r\n    }\r\n    if ((_event.address || _event.topics)) {\r\n        const event = _event;\r\n        const filter = {\r\n            topics: ((event.topics || []).map((t) => {\r\n                if (t == null) {\r\n                    return null;\r\n                }\r\n                if (Array.isArray(t)) {\r\n                    return concisify(t.map((t) => t.toLowerCase()));\r\n                }\r\n                return t.toLowerCase();\r\n            }))\r\n        };\r\n        if (event.address) {\r\n            const addresses = [];\r\n            const promises = [];\r\n            const addAddress = (addr) => {\r\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(addr)) {\r\n                    addresses.push(addr);\r\n                }\r\n                else {\r\n                    promises.push((async () => {\r\n                        addresses.push(await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(addr, provider));\r\n                    })());\r\n                }\r\n            };\r\n            if (Array.isArray(event.address)) {\r\n                event.address.forEach(addAddress);\r\n            }\r\n            else {\r\n                addAddress(event.address);\r\n            }\r\n            if (promises.length) {\r\n                await Promise.all(promises);\r\n            }\r\n            filter.address = concisify(addresses.map((a) => a.toLowerCase()));\r\n        }\r\n        return { filter, tag: getTag(\"event\", filter), type: \"event\" };\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unknown ProviderEvent\", \"event\", _event);\r\n}\r\nfunction getTime() { return (new Date()).getTime(); }\r\nconst defaultOptions = {\r\n    cacheTimeout: 250,\r\n    pollingInterval: 4000\r\n};\r\n/**\r\n *  An **AbstractProvider** provides a base class for other sub-classes to\r\n *  implement the [[Provider]] API by normalizing input arguments and\r\n *  formatting output results as well as tracking events for consistent\r\n *  behaviour on an eventually-consistent network.\r\n */\r\nclass AbstractProvider {\r\n    #subs;\r\n    #plugins;\r\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\r\n    #pausedState;\r\n    #destroyed;\r\n    #networkPromise;\r\n    #anyNetwork;\r\n    #performCache;\r\n    // The most recent block number if running an event or -1 if no \"block\" event\r\n    #lastBlockNumber;\r\n    #nextTimer;\r\n    #timers;\r\n    #disableCcipRead;\r\n    #options;\r\n    /**\r\n     *  Create a new **AbstractProvider** connected to %%network%%, or\r\n     *  use the various network detection capabilities to discover the\r\n     *  [[Network]] if necessary.\r\n     */\r\n    constructor(_network, options) {\r\n        this.#options = Object.assign({}, defaultOptions, options || {});\r\n        if (_network === \"any\") {\r\n            this.#anyNetwork = true;\r\n            this.#networkPromise = null;\r\n        }\r\n        else if (_network) {\r\n            const network = _network_js__WEBPACK_IMPORTED_MODULE_2__.Network.from(_network);\r\n            this.#anyNetwork = false;\r\n            this.#networkPromise = Promise.resolve(network);\r\n            setTimeout(() => { this.emit(\"network\", network, null); }, 0);\r\n        }\r\n        else {\r\n            this.#anyNetwork = false;\r\n            this.#networkPromise = null;\r\n        }\r\n        this.#lastBlockNumber = -1;\r\n        this.#performCache = new Map();\r\n        this.#subs = new Map();\r\n        this.#plugins = new Map();\r\n        this.#pausedState = null;\r\n        this.#destroyed = false;\r\n        this.#nextTimer = 1;\r\n        this.#timers = new Map();\r\n        this.#disableCcipRead = false;\r\n    }\r\n    get pollingInterval() { return this.#options.pollingInterval; }\r\n    /**\r\n     *  Returns ``this``, to allow an **AbstractProvider** to implement\r\n     *  the [[ContractRunner]] interface.\r\n     */\r\n    get provider() { return this; }\r\n    /**\r\n     *  Returns all the registered plug-ins.\r\n     */\r\n    get plugins() {\r\n        return Array.from(this.#plugins.values());\r\n    }\r\n    /**\r\n     *  Attach a new plug-in.\r\n     */\r\n    attachPlugin(plugin) {\r\n        if (this.#plugins.get(plugin.name)) {\r\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\r\n        }\r\n        this.#plugins.set(plugin.name, plugin.connect(this));\r\n        return this;\r\n    }\r\n    /**\r\n     *  Get a plugin by name.\r\n     */\r\n    getPlugin(name) {\r\n        return (this.#plugins.get(name)) || null;\r\n    }\r\n    /**\r\n     *  Prevent any CCIP-read operation, regardless of whether requested\r\n     *  in a [[call]] using ``enableCcipRead``.\r\n     */\r\n    get disableCcipRead() { return this.#disableCcipRead; }\r\n    set disableCcipRead(value) { this.#disableCcipRead = !!value; }\r\n    // Shares multiple identical requests made during the same 250ms\r\n    async #perform(req) {\r\n        const timeout = this.#options.cacheTimeout;\r\n        // Caching disabled\r\n        if (timeout < 0) {\r\n            return await this._perform(req);\r\n        }\r\n        // Create a tag\r\n        const tag = getTag(req.method, req);\r\n        let perform = this.#performCache.get(tag);\r\n        if (!perform) {\r\n            perform = this._perform(req);\r\n            this.#performCache.set(tag, perform);\r\n            setTimeout(() => {\r\n                if (this.#performCache.get(tag) === perform) {\r\n                    this.#performCache.delete(tag);\r\n                }\r\n            }, timeout);\r\n        }\r\n        return await perform;\r\n    }\r\n    /**\r\n     *  Resolves to the data for executing the CCIP-read operations.\r\n     */\r\n    async ccipReadFetch(tx, calldata, urls) {\r\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) {\r\n            return null;\r\n        }\r\n        const sender = tx.to.toLowerCase();\r\n        const data = calldata.toLowerCase();\r\n        const errorMessages = [];\r\n        for (let i = 0; i < urls.length; i++) {\r\n            const url = urls[i];\r\n            // URL expansion\r\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\r\n            // If no {data} is present, use POST; otherwise GET\r\n            //const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\r\n            //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\r\n            //    value.status = response.statusCode;\r\n            //    return value;\r\n            //});\r\n            const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(href);\r\n            if (url.indexOf(\"{data}\") === -1) {\r\n                request.body = { data, sender };\r\n            }\r\n            this.emit(\"debug\", { action: \"sendCcipReadFetchRequest\", request, index: i, urls });\r\n            let errorMessage = \"unknown error\";\r\n            // Fetch the resource...\r\n            let resp;\r\n            try {\r\n                resp = await request.send();\r\n            }\r\n            catch (error) {\r\n                // ...low-level fetch error (missing host, bad SSL, etc.),\r\n                // so try next URL\r\n                errorMessages.push(error.message);\r\n                this.emit(\"debug\", { action: \"receiveCcipReadFetchError\", request, result: { error } });\r\n                continue;\r\n            }\r\n            try {\r\n                const result = resp.bodyJson;\r\n                if (result.data) {\r\n                    this.emit(\"debug\", { action: \"receiveCcipReadFetchResult\", request, result });\r\n                    return result.data;\r\n                }\r\n                if (result.message) {\r\n                    errorMessage = result.message;\r\n                }\r\n                this.emit(\"debug\", { action: \"receiveCcipReadFetchError\", request, result });\r\n            }\r\n            catch (error) { }\r\n            // 4xx indicates the result is not present; stop\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, \"OFFCHAIN_FAULT\", { reason: \"404_MISSING_RESOURCE\", transaction: tx, info: { url, errorMessage } });\r\n            // 5xx indicates server issue; try the next url\r\n            errorMessages.push(errorMessage);\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(\", \")}`, \"OFFCHAIN_FAULT\", {\r\n            reason: \"500_SERVER_ERROR\",\r\n            transaction: tx, info: { urls, errorMessages }\r\n        });\r\n    }\r\n    /**\r\n     *  Provides the opportunity for a sub-class to wrap a block before\r\n     *  returning it, to add additional properties or an alternate\r\n     *  sub-class of [[Block]].\r\n     */\r\n    _wrapBlock(value, network) {\r\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_3__.Block((0,_format_js__WEBPACK_IMPORTED_MODULE_4__.formatBlock)(value), this);\r\n    }\r\n    /**\r\n     *  Provides the opportunity for a sub-class to wrap a log before\r\n     *  returning it, to add additional properties or an alternate\r\n     *  sub-class of [[Log]].\r\n     */\r\n    _wrapLog(value, network) {\r\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_3__.Log((0,_format_js__WEBPACK_IMPORTED_MODULE_4__.formatLog)(value), this);\r\n    }\r\n    /**\r\n     *  Provides the opportunity for a sub-class to wrap a transaction\r\n     *  receipt before returning it, to add additional properties or an\r\n     *  alternate sub-class of [[TransactionReceipt]].\r\n     */\r\n    _wrapTransactionReceipt(value, network) {\r\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_3__.TransactionReceipt((0,_format_js__WEBPACK_IMPORTED_MODULE_4__.formatTransactionReceipt)(value), this);\r\n    }\r\n    /**\r\n     *  Provides the opportunity for a sub-class to wrap a transaction\r\n     *  response before returning it, to add additional properties or an\r\n     *  alternate sub-class of [[TransactionResponse]].\r\n     */\r\n    _wrapTransactionResponse(tx, network) {\r\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_3__.TransactionResponse((0,_format_js__WEBPACK_IMPORTED_MODULE_4__.formatTransactionResponse)(tx), this);\r\n    }\r\n    /**\r\n     *  Resolves to the Network, forcing a network detection using whatever\r\n     *  technique the sub-class requires.\r\n     *\r\n     *  Sub-classes **must** override this.\r\n     */\r\n    _detectNetwork() {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\r\n            operation: \"_detectNetwork\"\r\n        });\r\n    }\r\n    /**\r\n     *  Sub-classes should use this to perform all built-in operations. All\r\n     *  methods sanitizes and normalizes the values passed into this.\r\n     *\r\n     *  Sub-classes **must** override this.\r\n     */\r\n    async _perform(req) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `unsupported method: ${req.method}`, \"UNSUPPORTED_OPERATION\", {\r\n            operation: req.method,\r\n            info: req\r\n        });\r\n    }\r\n    // State\r\n    async getBlockNumber() {\r\n        const blockNumber = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(await this.#perform({ method: \"getBlockNumber\" }), \"%response\");\r\n        if (this.#lastBlockNumber >= 0) {\r\n            this.#lastBlockNumber = blockNumber;\r\n        }\r\n        return blockNumber;\r\n    }\r\n    /**\r\n     *  Returns or resolves to the address for %%address%%, resolving ENS\r\n     *  names and [[Addressable]] objects and returning if already an\r\n     *  address.\r\n     */\r\n    _getAddress(address) {\r\n        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(address, this);\r\n    }\r\n    /**\r\n     *  Returns or resolves to a valid block tag for %%blockTag%%, resolving\r\n     *  negative values and returning if already a valid block tag.\r\n     */\r\n    _getBlockTag(blockTag) {\r\n        if (blockTag == null) {\r\n            return \"latest\";\r\n        }\r\n        switch (blockTag) {\r\n            case \"earliest\":\r\n                return \"0x0\";\r\n            case \"finalized\":\r\n            case \"latest\":\r\n            case \"pending\":\r\n            case \"safe\":\r\n                return blockTag;\r\n        }\r\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(blockTag)) {\r\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(blockTag, 32)) {\r\n                return blockTag;\r\n            }\r\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toQuantity)(blockTag);\r\n        }\r\n        if (typeof (blockTag) === \"bigint\") {\r\n            blockTag = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(blockTag, \"blockTag\");\r\n        }\r\n        if (typeof (blockTag) === \"number\") {\r\n            if (blockTag >= 0) {\r\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toQuantity)(blockTag);\r\n            }\r\n            if (this.#lastBlockNumber >= 0) {\r\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toQuantity)(this.#lastBlockNumber + blockTag);\r\n            }\r\n            return this.getBlockNumber().then((b) => (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toQuantity)(b + blockTag));\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid blockTag\", \"blockTag\", blockTag);\r\n    }\r\n    /**\r\n     *  Returns or resolves to a filter for %%filter%%, resolving any ENS\r\n     *  names or [[Addressable]] object and returning if already a valid\r\n     *  filter.\r\n     */\r\n    _getFilter(filter) {\r\n        // Create a canonical representation of the topics\r\n        const topics = (filter.topics || []).map((t) => {\r\n            if (t == null) {\r\n                return null;\r\n            }\r\n            if (Array.isArray(t)) {\r\n                return concisify(t.map((t) => t.toLowerCase()));\r\n            }\r\n            return t.toLowerCase();\r\n        });\r\n        const blockHash = (\"blockHash\" in filter) ? filter.blockHash : undefined;\r\n        const resolve = (_address, fromBlock, toBlock) => {\r\n            let address = undefined;\r\n            switch (_address.length) {\r\n                case 0: break;\r\n                case 1:\r\n                    address = _address[0];\r\n                    break;\r\n                default:\r\n                    _address.sort();\r\n                    address = _address;\r\n            }\r\n            if (blockHash) {\r\n                if (fromBlock != null || toBlock != null) {\r\n                    throw new Error(\"invalid filter\");\r\n                }\r\n            }\r\n            const filter = {};\r\n            if (address) {\r\n                filter.address = address;\r\n            }\r\n            if (topics.length) {\r\n                filter.topics = topics;\r\n            }\r\n            if (fromBlock) {\r\n                filter.fromBlock = fromBlock;\r\n            }\r\n            if (toBlock) {\r\n                filter.toBlock = toBlock;\r\n            }\r\n            if (blockHash) {\r\n                filter.blockHash = blockHash;\r\n            }\r\n            return filter;\r\n        };\r\n        // Addresses could be async (ENS names or Addressables)\r\n        let address = [];\r\n        if (filter.address) {\r\n            if (Array.isArray(filter.address)) {\r\n                for (const addr of filter.address) {\r\n                    address.push(this._getAddress(addr));\r\n                }\r\n            }\r\n            else {\r\n                address.push(this._getAddress(filter.address));\r\n            }\r\n        }\r\n        let fromBlock = undefined;\r\n        if (\"fromBlock\" in filter) {\r\n            fromBlock = this._getBlockTag(filter.fromBlock);\r\n        }\r\n        let toBlock = undefined;\r\n        if (\"toBlock\" in filter) {\r\n            toBlock = this._getBlockTag(filter.toBlock);\r\n        }\r\n        if (address.filter((a) => (typeof (a) !== \"string\")).length ||\r\n            (fromBlock != null && typeof (fromBlock) !== \"string\") ||\r\n            (toBlock != null && typeof (toBlock) !== \"string\")) {\r\n            return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {\r\n                return resolve(result[0], result[1], result[2]);\r\n            });\r\n        }\r\n        return resolve(address, fromBlock, toBlock);\r\n    }\r\n    /**\r\n     *  Returns or resolves to a transaction for %%request%%, resolving\r\n     *  any ENS names or [[Addressable]] and returning if already a valid\r\n     *  transaction.\r\n     */\r\n    _getTransactionRequest(_request) {\r\n        const request = (0,_provider_js__WEBPACK_IMPORTED_MODULE_3__.copyRequest)(_request);\r\n        const promises = [];\r\n        [\"to\", \"from\"].forEach((key) => {\r\n            if (request[key] == null) {\r\n                return;\r\n            }\r\n            const addr = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(request[key], this);\r\n            if (isPromise(addr)) {\r\n                promises.push((async function () { request[key] = await addr; })());\r\n            }\r\n            else {\r\n                request[key] = addr;\r\n            }\r\n        });\r\n        if (request.blockTag != null) {\r\n            const blockTag = this._getBlockTag(request.blockTag);\r\n            if (isPromise(blockTag)) {\r\n                promises.push((async function () { request.blockTag = await blockTag; })());\r\n            }\r\n            else {\r\n                request.blockTag = blockTag;\r\n            }\r\n        }\r\n        if (promises.length) {\r\n            return (async function () {\r\n                await Promise.all(promises);\r\n                return request;\r\n            })();\r\n        }\r\n        return request;\r\n    }\r\n    async getNetwork() {\r\n        // No explicit network was set and this is our first time\r\n        if (this.#networkPromise == null) {\r\n            // Detect the current network (shared with all calls)\r\n            const detectNetwork = (async () => {\r\n                try {\r\n                    const network = await this._detectNetwork();\r\n                    this.emit(\"network\", network, null);\r\n                    return network;\r\n                }\r\n                catch (error) {\r\n                    if (this.#networkPromise === detectNetwork) {\r\n                        this.#networkPromise = null;\r\n                    }\r\n                    throw error;\r\n                }\r\n            })();\r\n            this.#networkPromise = detectNetwork;\r\n            return (await detectNetwork).clone();\r\n        }\r\n        const networkPromise = this.#networkPromise;\r\n        const [expected, actual] = await Promise.all([\r\n            networkPromise,\r\n            this._detectNetwork() // The actual connected network\r\n        ]);\r\n        if (expected.chainId !== actual.chainId) {\r\n            if (this.#anyNetwork) {\r\n                // The \"any\" network can change, so notify listeners\r\n                this.emit(\"network\", actual, expected);\r\n                // Update the network if something else hasn't already changed it\r\n                if (this.#networkPromise === networkPromise) {\r\n                    this.#networkPromise = Promise.resolve(actual);\r\n                }\r\n            }\r\n            else {\r\n                // Otherwise, we do not allow changes to the underlying network\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `network changed: ${expected.chainId} => ${actual.chainId} `, \"NETWORK_ERROR\", {\r\n                    event: \"changed\"\r\n                });\r\n            }\r\n        }\r\n        return expected.clone();\r\n    }\r\n    async getFeeData() {\r\n        const network = await this.getNetwork();\r\n        const getFeeDataFunc = async () => {\r\n            const { _block, gasPrice, priorityFee } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\r\n                _block: this.#getBlock(\"latest\", false),\r\n                gasPrice: ((async () => {\r\n                    try {\r\n                        const value = await this.#perform({ method: \"getGasPrice\" });\r\n                        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"%response\");\r\n                    }\r\n                    catch (error) { }\r\n                    return null;\r\n                })()),\r\n                priorityFee: ((async () => {\r\n                    try {\r\n                        const value = await this.#perform({ method: \"getPriorityFee\" });\r\n                        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"%response\");\r\n                    }\r\n                    catch (error) { }\r\n                    return null;\r\n                })())\r\n            });\r\n            let maxFeePerGas = null;\r\n            let maxPriorityFeePerGas = null;\r\n            // These are the recommended EIP-1559 heuristics for fee data\r\n            const block = this._wrapBlock(_block, network);\r\n            if (block && block.baseFeePerGas) {\r\n                maxPriorityFeePerGas = (priorityFee != null) ? priorityFee : BigInt(\"1000000000\");\r\n                maxFeePerGas = (block.baseFeePerGas * BN_2) + maxPriorityFeePerGas;\r\n            }\r\n            return new _provider_js__WEBPACK_IMPORTED_MODULE_3__.FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);\r\n        };\r\n        // Check for a FeeDataNetWorkPlugin\r\n        const plugin = network.getPlugin(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\r\n        if (plugin) {\r\n            const req = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(plugin.url);\r\n            const feeData = await plugin.processFunc(getFeeDataFunc, this, req);\r\n            return new _provider_js__WEBPACK_IMPORTED_MODULE_3__.FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);\r\n        }\r\n        return await getFeeDataFunc();\r\n    }\r\n    async estimateGas(_tx) {\r\n        let tx = this._getTransactionRequest(_tx);\r\n        if (isPromise(tx)) {\r\n            tx = await tx;\r\n        }\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(await this.#perform({\r\n            method: \"estimateGas\", transaction: tx\r\n        }), \"%response\");\r\n    }\r\n    async #call(tx, blockTag, attempt) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\r\n            reason: \"TOO_MANY_REDIRECTS\",\r\n            transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })\r\n        });\r\n        // This came in as a PerformActionTransaction, so to/from are safe; we can cast\r\n        const transaction = (0,_provider_js__WEBPACK_IMPORTED_MODULE_3__.copyRequest)(tx);\r\n        try {\r\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(await this._perform({ method: \"call\", transaction, blockTag }));\r\n        }\r\n        catch (error) {\r\n            // CCIP Read OffchainLookup\r\n            if (!this.disableCcipRead && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isCallException)(error) && error.data && attempt >= 0 && blockTag === \"latest\" && transaction.to != null && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(error.data, 0, 4) === \"0x556f1830\") {\r\n                const data = error.data;\r\n                const txSender = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(transaction.to, this);\r\n                // Parse the CCIP Read Arguments\r\n                let ccipArgs;\r\n                try {\r\n                    ccipArgs = parseOffchainLookup((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(error.data, 4));\r\n                }\r\n                catch (error) {\r\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, error.message, \"OFFCHAIN_FAULT\", {\r\n                        reason: \"BAD_DATA\", transaction, info: { data }\r\n                    });\r\n                }\r\n                // Check the sender of the OffchainLookup matches the transaction\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), \"CCIP Read sender mismatch\", \"CALL_EXCEPTION\", {\r\n                    action: \"call\",\r\n                    data,\r\n                    reason: \"OffchainLookup\",\r\n                    transaction: transaction,\r\n                    invocation: null,\r\n                    revert: {\r\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\r\n                        name: \"OffchainLookup\",\r\n                        args: ccipArgs.errorArgs\r\n                    }\r\n                });\r\n                const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(ccipResult != null, \"CCIP Read failed to fetch data\", \"OFFCHAIN_FAULT\", {\r\n                    reason: \"FETCH_FAILED\", transaction, info: { data: error.data, errorArgs: ccipArgs.errorArgs }\r\n                });\r\n                const tx = {\r\n                    to: txSender,\r\n                    data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])\r\n                };\r\n                this.emit(\"debug\", { action: \"sendCcipReadCall\", transaction: tx });\r\n                try {\r\n                    const result = await this.#call(tx, blockTag, attempt + 1);\r\n                    this.emit(\"debug\", { action: \"receiveCcipReadCallResult\", transaction: Object.assign({}, tx), result });\r\n                    return result;\r\n                }\r\n                catch (error) {\r\n                    this.emit(\"debug\", { action: \"receiveCcipReadCallError\", transaction: Object.assign({}, tx), error });\r\n                    throw error;\r\n                }\r\n            }\r\n            throw error;\r\n        }\r\n    }\r\n    async #checkNetwork(promise) {\r\n        const { value } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\r\n            network: this.getNetwork(),\r\n            value: promise\r\n        });\r\n        return value;\r\n    }\r\n    async call(_tx) {\r\n        const { tx, blockTag } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\r\n            tx: this._getTransactionRequest(_tx),\r\n            blockTag: this._getBlockTag(_tx.blockTag)\r\n        });\r\n        return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));\r\n    }\r\n    // Account\r\n    async #getAccountValue(request, _address, _blockTag) {\r\n        let address = this._getAddress(_address);\r\n        let blockTag = this._getBlockTag(_blockTag);\r\n        if (typeof (address) !== \"string\" || typeof (blockTag) !== \"string\") {\r\n            [address, blockTag] = await Promise.all([address, blockTag]);\r\n        }\r\n        return await this.#checkNetwork(this.#perform(Object.assign(request, { address, blockTag })));\r\n    }\r\n    async getBalance(address, blockTag) {\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(await this.#getAccountValue({ method: \"getBalance\" }, address, blockTag), \"%response\");\r\n    }\r\n    async getTransactionCount(address, blockTag) {\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(await this.#getAccountValue({ method: \"getTransactionCount\" }, address, blockTag), \"%response\");\r\n    }\r\n    async getCode(address, blockTag) {\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(await this.#getAccountValue({ method: \"getCode\" }, address, blockTag));\r\n    }\r\n    async getStorage(address, _position, blockTag) {\r\n        const position = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(_position, \"position\");\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(await this.#getAccountValue({ method: \"getStorage\", position }, address, blockTag));\r\n    }\r\n    // Write\r\n    async broadcastTransaction(signedTx) {\r\n        const { blockNumber, hash, network } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\r\n            blockNumber: this.getBlockNumber(),\r\n            hash: this._perform({\r\n                method: \"broadcastTransaction\",\r\n                signedTransaction: signedTx\r\n            }),\r\n            network: this.getNetwork()\r\n        });\r\n        const tx = _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__.Transaction.from(signedTx);\r\n        if (tx.hash !== hash) {\r\n            throw new Error(\"@TODO: the returned hash did not match\");\r\n        }\r\n        return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);\r\n    }\r\n    async #getBlock(block, includeTransactions) {\r\n        // @TODO: Add CustomBlockPlugin check\r\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(block, 32)) {\r\n            return await this.#perform({\r\n                method: \"getBlock\", blockHash: block, includeTransactions\r\n            });\r\n        }\r\n        let blockTag = this._getBlockTag(block);\r\n        if (typeof (blockTag) !== \"string\") {\r\n            blockTag = await blockTag;\r\n        }\r\n        return await this.#perform({\r\n            method: \"getBlock\", blockTag, includeTransactions\r\n        });\r\n    }\r\n    // Queries\r\n    async getBlock(block, prefetchTxs) {\r\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\r\n            network: this.getNetwork(),\r\n            params: this.#getBlock(block, !!prefetchTxs)\r\n        });\r\n        if (params == null) {\r\n            return null;\r\n        }\r\n        return this._wrapBlock(params, network);\r\n    }\r\n    async getTransaction(hash) {\r\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\r\n            network: this.getNetwork(),\r\n            params: this.#perform({ method: \"getTransaction\", hash })\r\n        });\r\n        if (params == null) {\r\n            return null;\r\n        }\r\n        return this._wrapTransactionResponse(params, network);\r\n    }\r\n    async getTransactionReceipt(hash) {\r\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\r\n            network: this.getNetwork(),\r\n            params: this.#perform({ method: \"getTransactionReceipt\", hash })\r\n        });\r\n        if (params == null) {\r\n            return null;\r\n        }\r\n        // Some backends did not backfill the effectiveGasPrice into old transactions\r\n        // in the receipt, so we look it up manually and inject it.\r\n        if (params.gasPrice == null && params.effectiveGasPrice == null) {\r\n            const tx = await this.#perform({ method: \"getTransaction\", hash });\r\n            if (tx == null) {\r\n                throw new Error(\"report this; could not find tx or effectiveGasPrice\");\r\n            }\r\n            params.effectiveGasPrice = tx.gasPrice;\r\n        }\r\n        return this._wrapTransactionReceipt(params, network);\r\n    }\r\n    async getTransactionResult(hash) {\r\n        const { result } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\r\n            network: this.getNetwork(),\r\n            result: this.#perform({ method: \"getTransactionResult\", hash })\r\n        });\r\n        if (result == null) {\r\n            return null;\r\n        }\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(result);\r\n    }\r\n    // Bloom-filter Queries\r\n    async getLogs(_filter) {\r\n        let filter = this._getFilter(_filter);\r\n        if (isPromise(filter)) {\r\n            filter = await filter;\r\n        }\r\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\r\n            network: this.getNetwork(),\r\n            params: this.#perform({ method: \"getLogs\", filter })\r\n        });\r\n        return params.map((p) => this._wrapLog(p, network));\r\n    }\r\n    // ENS\r\n    _getProvider(chainId) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\r\n            operation: \"_getProvider()\"\r\n        });\r\n    }\r\n    async getResolver(name) {\r\n        return await _ens_resolver_js__WEBPACK_IMPORTED_MODULE_6__.EnsResolver.fromName(this, name);\r\n    }\r\n    async getAvatar(name) {\r\n        const resolver = await this.getResolver(name);\r\n        if (resolver) {\r\n            return await resolver.getAvatar();\r\n        }\r\n        return null;\r\n    }\r\n    async resolveName(name) {\r\n        const resolver = await this.getResolver(name);\r\n        if (resolver) {\r\n            return await resolver.getAddress();\r\n        }\r\n        return null;\r\n    }\r\n    async lookupAddress(address) {\r\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address);\r\n        const node = (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_7__.namehash)(address.substring(2).toLowerCase() + \".addr.reverse\");\r\n        try {\r\n            const ensAddr = await _ens_resolver_js__WEBPACK_IMPORTED_MODULE_6__.EnsResolver.getEnsAddress(this);\r\n            const ensContract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_8__.Contract(ensAddr, [\r\n                \"function resolver(bytes32) view returns (address)\"\r\n            ], this);\r\n            const resolver = await ensContract.resolver(node);\r\n            if (resolver == null || resolver === _constants_index_js__WEBPACK_IMPORTED_MODULE_9__.ZeroAddress) {\r\n                return null;\r\n            }\r\n            const resolverContract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_8__.Contract(resolver, [\r\n                \"function name(bytes32) view returns (string)\"\r\n            ], this);\r\n            const name = await resolverContract.name(node);\r\n            // Failed forward resolution\r\n            const check = await this.resolveName(name);\r\n            if (check !== address) {\r\n                return null;\r\n            }\r\n            return name;\r\n        }\r\n        catch (error) {\r\n            // No data was returned from the resolver\r\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"BAD_DATA\") && error.value === \"0x\") {\r\n                return null;\r\n            }\r\n            // Something reerted\r\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\r\n                return null;\r\n            }\r\n            throw error;\r\n        }\r\n        return null;\r\n    }\r\n    async waitForTransaction(hash, _confirms, timeout) {\r\n        const confirms = (_confirms != null) ? _confirms : 1;\r\n        if (confirms === 0) {\r\n            return this.getTransactionReceipt(hash);\r\n        }\r\n        return new Promise(async (resolve, reject) => {\r\n            let timer = null;\r\n            const listener = (async (blockNumber) => {\r\n                try {\r\n                    const receipt = await this.getTransactionReceipt(hash);\r\n                    if (receipt != null) {\r\n                        if (blockNumber - receipt.blockNumber + 1 >= confirms) {\r\n                            resolve(receipt);\r\n                            //this.off(\"block\", listener);\r\n                            if (timer) {\r\n                                clearTimeout(timer);\r\n                                timer = null;\r\n                            }\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    console.log(\"EEE\", error);\r\n                }\r\n                this.once(\"block\", listener);\r\n            });\r\n            if (timeout != null) {\r\n                timer = setTimeout(() => {\r\n                    if (timer == null) {\r\n                        return;\r\n                    }\r\n                    timer = null;\r\n                    this.off(\"block\", listener);\r\n                    reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(\"timeout\", \"TIMEOUT\", { reason: \"timeout\" }));\r\n                }, timeout);\r\n            }\r\n            listener(await this.getBlockNumber());\r\n        });\r\n    }\r\n    async waitForBlock(blockTag) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\r\n            operation: \"waitForBlock\"\r\n        });\r\n    }\r\n    /**\r\n     *  Clear a timer created using the [[_setTimeout]] method.\r\n     */\r\n    _clearTimeout(timerId) {\r\n        const timer = this.#timers.get(timerId);\r\n        if (!timer) {\r\n            return;\r\n        }\r\n        if (timer.timer) {\r\n            clearTimeout(timer.timer);\r\n        }\r\n        this.#timers.delete(timerId);\r\n    }\r\n    /**\r\n     *  Create a timer that will execute %%func%% after at least %%timeout%%\r\n     *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute\r\n     *  in the next event loop.\r\n     *\r\n     *  [Pausing](AbstractProvider-paused) the provider will pause any\r\n     *  associated timers.\r\n     */\r\n    _setTimeout(_func, timeout) {\r\n        if (timeout == null) {\r\n            timeout = 0;\r\n        }\r\n        const timerId = this.#nextTimer++;\r\n        const func = () => {\r\n            this.#timers.delete(timerId);\r\n            _func();\r\n        };\r\n        if (this.paused) {\r\n            this.#timers.set(timerId, { timer: null, func, time: timeout });\r\n        }\r\n        else {\r\n            const timer = setTimeout(func, timeout);\r\n            this.#timers.set(timerId, { timer, func, time: getTime() });\r\n        }\r\n        return timerId;\r\n    }\r\n    /**\r\n     *  Perform %%func%% on each subscriber.\r\n     */\r\n    _forEachSubscriber(func) {\r\n        for (const sub of this.#subs.values()) {\r\n            func(sub.subscriber);\r\n        }\r\n    }\r\n    /**\r\n     *  Sub-classes may override this to customize subscription\r\n     *  implementations.\r\n     */\r\n    _getSubscriber(sub) {\r\n        switch (sub.type) {\r\n            case \"debug\":\r\n            case \"error\":\r\n            case \"network\":\r\n                return new UnmanagedSubscriber(sub.type);\r\n            case \"block\": {\r\n                const subscriber = new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_10__.PollingBlockSubscriber(this);\r\n                subscriber.pollingInterval = this.pollingInterval;\r\n                return subscriber;\r\n            }\r\n            case \"safe\":\r\n            case \"finalized\":\r\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_10__.PollingBlockTagSubscriber(this, sub.type);\r\n            case \"event\":\r\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_10__.PollingEventSubscriber(this, sub.filter);\r\n            case \"transaction\":\r\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_10__.PollingTransactionSubscriber(this, sub.hash);\r\n            case \"orphan\":\r\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_10__.PollingOrphanSubscriber(this, sub.filter);\r\n        }\r\n        throw new Error(`unsupported event: ${sub.type}`);\r\n    }\r\n    /**\r\n     *  If a [[Subscriber]] fails and needs to replace itself, this\r\n     *  method may be used.\r\n     *\r\n     *  For example, this is used for providers when using the\r\n     *  ``eth_getFilterChanges`` method, which can return null if state\r\n     *  filters are not supported by the backend, allowing the Subscriber\r\n     *  to swap in a [[PollingEventSubscriber]].\r\n     */\r\n    _recoverSubscriber(oldSub, newSub) {\r\n        for (const sub of this.#subs.values()) {\r\n            if (sub.subscriber === oldSub) {\r\n                if (sub.started) {\r\n                    sub.subscriber.stop();\r\n                }\r\n                sub.subscriber = newSub;\r\n                if (sub.started) {\r\n                    newSub.start();\r\n                }\r\n                if (this.#pausedState != null) {\r\n                    newSub.pause(this.#pausedState);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    async #hasSub(event, emitArgs) {\r\n        let sub = await getSubscription(event, this);\r\n        // This is a log that is removing an existing log; we actually want\r\n        // to emit an orphan event for the removed log\r\n        if (sub.type === \"event\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {\r\n            sub = await getSubscription({ orphan: \"drop-log\", log: emitArgs[0] }, this);\r\n        }\r\n        return this.#subs.get(sub.tag) || null;\r\n    }\r\n    async #getSub(event) {\r\n        const subscription = await getSubscription(event, this);\r\n        // Prevent tampering with our tag in any subclass' _getSubscriber\r\n        const tag = subscription.tag;\r\n        let sub = this.#subs.get(tag);\r\n        if (!sub) {\r\n            const subscriber = this._getSubscriber(subscription);\r\n            const addressableMap = new WeakMap();\r\n            const nameMap = new Map();\r\n            sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };\r\n            this.#subs.set(tag, sub);\r\n        }\r\n        return sub;\r\n    }\r\n    async on(event, listener) {\r\n        const sub = await this.#getSub(event);\r\n        sub.listeners.push({ listener, once: false });\r\n        if (!sub.started) {\r\n            sub.subscriber.start();\r\n            sub.started = true;\r\n            if (this.#pausedState != null) {\r\n                sub.subscriber.pause(this.#pausedState);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    async once(event, listener) {\r\n        const sub = await this.#getSub(event);\r\n        sub.listeners.push({ listener, once: true });\r\n        if (!sub.started) {\r\n            sub.subscriber.start();\r\n            sub.started = true;\r\n            if (this.#pausedState != null) {\r\n                sub.subscriber.pause(this.#pausedState);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    async emit(event, ...args) {\r\n        const sub = await this.#hasSub(event, args);\r\n        // If there is not subscription or if a recent emit removed\r\n        // the last of them (which also deleted the sub) do nothing\r\n        if (!sub || sub.listeners.length === 0) {\r\n            return false;\r\n        }\r\n        ;\r\n        const count = sub.listeners.length;\r\n        sub.listeners = sub.listeners.filter(({ listener, once }) => {\r\n            const payload = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.EventPayload(this, (once ? null : listener), event);\r\n            try {\r\n                listener.call(this, ...args, payload);\r\n            }\r\n            catch (error) { }\r\n            return !once;\r\n        });\r\n        if (sub.listeners.length === 0) {\r\n            if (sub.started) {\r\n                sub.subscriber.stop();\r\n            }\r\n            this.#subs.delete(sub.tag);\r\n        }\r\n        return (count > 0);\r\n    }\r\n    async listenerCount(event) {\r\n        if (event) {\r\n            const sub = await this.#hasSub(event);\r\n            if (!sub) {\r\n                return 0;\r\n            }\r\n            return sub.listeners.length;\r\n        }\r\n        let total = 0;\r\n        for (const { listeners } of this.#subs.values()) {\r\n            total += listeners.length;\r\n        }\r\n        return total;\r\n    }\r\n    async listeners(event) {\r\n        if (event) {\r\n            const sub = await this.#hasSub(event);\r\n            if (!sub) {\r\n                return [];\r\n            }\r\n            return sub.listeners.map(({ listener }) => listener);\r\n        }\r\n        let result = [];\r\n        for (const { listeners } of this.#subs.values()) {\r\n            result = result.concat(listeners.map(({ listener }) => listener));\r\n        }\r\n        return result;\r\n    }\r\n    async off(event, listener) {\r\n        const sub = await this.#hasSub(event);\r\n        if (!sub) {\r\n            return this;\r\n        }\r\n        if (listener) {\r\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\r\n            if (index >= 0) {\r\n                sub.listeners.splice(index, 1);\r\n            }\r\n        }\r\n        if (!listener || sub.listeners.length === 0) {\r\n            if (sub.started) {\r\n                sub.subscriber.stop();\r\n            }\r\n            this.#subs.delete(sub.tag);\r\n        }\r\n        return this;\r\n    }\r\n    async removeAllListeners(event) {\r\n        if (event) {\r\n            const { tag, started, subscriber } = await this.#getSub(event);\r\n            if (started) {\r\n                subscriber.stop();\r\n            }\r\n            this.#subs.delete(tag);\r\n        }\r\n        else {\r\n            for (const [tag, { started, subscriber }] of this.#subs) {\r\n                if (started) {\r\n                    subscriber.stop();\r\n                }\r\n                this.#subs.delete(tag);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    // Alias for \"on\"\r\n    async addListener(event, listener) {\r\n        return await this.on(event, listener);\r\n    }\r\n    // Alias for \"off\"\r\n    async removeListener(event, listener) {\r\n        return this.off(event, listener);\r\n    }\r\n    /**\r\n     *  If this provider has been destroyed using the [[destroy]] method.\r\n     *\r\n     *  Once destroyed, all resources are reclaimed, internal event loops\r\n     *  and timers are cleaned up and no further requests may be sent to\r\n     *  the provider.\r\n     */\r\n    get destroyed() {\r\n        return this.#destroyed;\r\n    }\r\n    /**\r\n     *  Sub-classes may use this to shutdown any sockets or release their\r\n     *  resources and reject any pending requests.\r\n     *\r\n     *  Sub-classes **must** call ``super.destroy()``.\r\n     */\r\n    destroy() {\r\n        // Stop all listeners\r\n        this.removeAllListeners();\r\n        // Shut down all tiemrs\r\n        for (const timerId of this.#timers.keys()) {\r\n            this._clearTimeout(timerId);\r\n        }\r\n        this.#destroyed = true;\r\n    }\r\n    /**\r\n     *  Whether the provider is currently paused.\r\n     *\r\n     *  A paused provider will not emit any events, and generally should\r\n     *  not make any requests to the network, but that is up to sub-classes\r\n     *  to manage.\r\n     *\r\n     *  Setting ``paused = true`` is identical to calling ``.pause(false)``,\r\n     *  which will buffer any events that occur while paused until the\r\n     *  provider is unpaused.\r\n     */\r\n    get paused() { return (this.#pausedState != null); }\r\n    set paused(pause) {\r\n        if (!!pause === this.paused) {\r\n            return;\r\n        }\r\n        if (this.paused) {\r\n            this.resume();\r\n        }\r\n        else {\r\n            this.pause(false);\r\n        }\r\n    }\r\n    /**\r\n     *  Pause the provider. If %%dropWhilePaused%%, any events that occur\r\n     *  while paused are dropped, otherwise all events will be emitted once\r\n     *  the provider is unpaused.\r\n     */\r\n    pause(dropWhilePaused) {\r\n        this.#lastBlockNumber = -1;\r\n        if (this.#pausedState != null) {\r\n            if (this.#pausedState == !!dropWhilePaused) {\r\n                return;\r\n            }\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\r\n                operation: \"pause\"\r\n            });\r\n        }\r\n        this._forEachSubscriber((s) => s.pause(dropWhilePaused));\r\n        this.#pausedState = !!dropWhilePaused;\r\n        for (const timer of this.#timers.values()) {\r\n            // Clear the timer\r\n            if (timer.timer) {\r\n                clearTimeout(timer.timer);\r\n            }\r\n            // Remaining time needed for when we become unpaused\r\n            timer.time = getTime() - timer.time;\r\n        }\r\n    }\r\n    /**\r\n     *  Resume the provider.\r\n     */\r\n    resume() {\r\n        if (this.#pausedState == null) {\r\n            return;\r\n        }\r\n        this._forEachSubscriber((s) => s.resume());\r\n        this.#pausedState = null;\r\n        for (const timer of this.#timers.values()) {\r\n            // Remaining time when we were paused\r\n            let timeout = timer.time;\r\n            if (timeout < 0) {\r\n                timeout = 0;\r\n            }\r\n            // Start time (in cause paused, so we con compute remaininf time)\r\n            timer.time = getTime();\r\n            // Start the timer\r\n            setTimeout(timer.func, timeout);\r\n        }\r\n    }\r\n}\r\nfunction _parseString(result, start) {\r\n    try {\r\n        const bytes = _parseBytes(result, start);\r\n        if (bytes) {\r\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8String)(bytes);\r\n        }\r\n    }\r\n    catch (error) { }\r\n    return null;\r\n}\r\nfunction _parseBytes(result, start) {\r\n    if (result === \"0x\") {\r\n        return null;\r\n    }\r\n    try {\r\n        const offset = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(result, start, start + 32));\r\n        const length = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(result, offset, offset + 32));\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(result, offset + 32, offset + 32 + length);\r\n    }\r\n    catch (error) { }\r\n    return null;\r\n}\r\nfunction numPad(value) {\r\n    const result = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(value);\r\n    if (result.length > 32) {\r\n        throw new Error(\"internal; should not happen\");\r\n    }\r\n    const padded = new Uint8Array(32);\r\n    padded.set(result, 32 - result.length);\r\n    return padded;\r\n}\r\nfunction bytesPad(value) {\r\n    if ((value.length % 32) === 0) {\r\n        return value;\r\n    }\r\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\r\n    result.set(value);\r\n    return result;\r\n}\r\nconst empty = new Uint8Array([]);\r\n// ABI Encodes a series of (bytes, bytes, ...)\r\nfunction encodeBytes(datas) {\r\n    const result = [];\r\n    let byteCount = 0;\r\n    // Add place-holders for pointers as we add items\r\n    for (let i = 0; i < datas.length; i++) {\r\n        result.push(empty);\r\n        byteCount += 32;\r\n    }\r\n    for (let i = 0; i < datas.length; i++) {\r\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(datas[i]);\r\n        // Update the bytes offset\r\n        result[i] = numPad(byteCount);\r\n        // The length and padded value of data\r\n        result.push(numPad(data.length));\r\n        result.push(bytesPad(data));\r\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\r\n    }\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(result);\r\n}\r\nconst zeros = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\r\nfunction parseOffchainLookup(data) {\r\n    const result = {\r\n        sender: \"\", urls: [], calldata: \"\", selector: \"\", extraData: \"\", errorArgs: []\r\n    };\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(data) >= 5 * 32, \"insufficient OffchainLookup data\", \"OFFCHAIN_FAULT\", {\r\n        reason: \"insufficient OffchainLookup data\"\r\n    });\r\n    const sender = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(data, 0, 32);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(sender, 0, 12) === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(zeros, 0, 12), \"corrupt OffchainLookup sender\", \"OFFCHAIN_FAULT\", {\r\n        reason: \"corrupt OffchainLookup sender\"\r\n    });\r\n    result.sender = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(sender, 12);\r\n    // Read the URLs from the response\r\n    try {\r\n        const urls = [];\r\n        const urlsOffset = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(data, 32, 64));\r\n        const urlsLength = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(data, urlsOffset, urlsOffset + 32));\r\n        const urlsData = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(data, urlsOffset + 32);\r\n        for (let u = 0; u < urlsLength; u++) {\r\n            const url = _parseString(urlsData, u * 32);\r\n            if (url == null) {\r\n                throw new Error(\"abort\");\r\n            }\r\n            urls.push(url);\r\n        }\r\n        result.urls = urls;\r\n    }\r\n    catch (error) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\r\n            reason: \"corrupt OffchainLookup urls\"\r\n        });\r\n    }\r\n    // Get the CCIP calldata to forward\r\n    try {\r\n        const calldata = _parseBytes(data, 64);\r\n        if (calldata == null) {\r\n            throw new Error(\"abort\");\r\n        }\r\n        result.calldata = calldata;\r\n    }\r\n    catch (error) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\r\n            reason: \"corrupt OffchainLookup calldata\"\r\n        });\r\n    }\r\n    // Get the callbackSelector (bytes4)\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(data, 100, 128) === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(zeros, 0, 28), \"corrupt OffchainLookup callbaackSelector\", \"OFFCHAIN_FAULT\", {\r\n        reason: \"corrupt OffchainLookup callbaackSelector\"\r\n    });\r\n    result.selector = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(data, 96, 100);\r\n    // Get the extra data to send back to the contract as context\r\n    try {\r\n        const extraData = _parseBytes(data, 128);\r\n        if (extraData == null) {\r\n            throw new Error(\"abort\");\r\n        }\r\n        result.extraData = extraData;\r\n    }\r\n    catch (error) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\r\n            reason: \"corrupt OffchainLookup extraData\"\r\n        });\r\n    }\r\n    result.errorArgs = \"sender,urls,calldata,selector,extraData\".split(/,/).map((k) => result[k]);\r\n    return result;\r\n}\r\n//# sourceMappingURL=abstract-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDaUU7QUFDYjtBQUNKO0FBQ0o7QUFDVTtBQUNxTztBQUMzTztBQUMwRDtBQUNuRTtBQUNtRTtBQUNpRTtBQUMzSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpRUFBZ0IsU0FBUyxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQVc7QUFDbkI7QUFDQSxpQkFBaUIseUNBQXlDLE1BQU07QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxv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O0FBQ0EsUUFBUSx1REFBTTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxJQUFJLHVEQUFNLENBQUMsMERBQVMscUJBQXFCLDBEQUFTO0FBQ2xEO0FBQ0EsS0FBSztBQUNMLHNCQUFzQiwwREFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxwcm92aWRlcnNcXGFic3RyYWN0LXByb3ZpZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgVGhlIGF2YWlsYWJsZSBwcm92aWRlcnMgc2hvdWxkIHN1ZmZpY2UgZm9yIG1vc3QgZGV2ZWxvcGVycyBwdXJwb3NlcyxcclxuICogIGJ1dCB0aGUgW1tBYnN0cmFjdFByb3ZpZGVyXV0gY2xhc3MgaGFzIG1hbnkgZmVhdHVyZXMgd2hpY2ggZW5hYmxlXHJcbiAqICBzdWItY2xhc3NpbmcgaXQgZm9yIHNwZWNpZmljIHB1cnBvc2VzLlxyXG4gKlxyXG4gKiAgQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyOiBTdWJjbGFzc2luZyBQcm92aWRlciAgW2Fic3RyYWN0LXByb3ZpZGVyXVxyXG4gKi9cclxuLy8gQFRPRE9cclxuLy8gRXZlbnQgY29hbGVzY2VuY2VcclxuLy8gICBXaGVuIHdlIHJlZ2lzdGVyIGFuIGV2ZW50IHdpdGggYW4gYXN5bmMgdmFsdWUgKGUuZy4gYWRkcmVzcyBpcyBhIFNpZ25lclxyXG4vLyAgIG9yIEVOUyBuYW1lKSwgd2UgbmVlZCB0byBhZGQgaXQgaW1tZWlkYXRlbHkgZm9yIHRoZSBFdmVudCBBUEksIGJ1dCBhbHNvXHJcbi8vICAgbmVlZCB0aW1lIHRvIHJlc29sdmUgdGhlIGFkZHJlc3MuIFVwb24gcmVzb2x2aW5nIHRoZSBhZGRyZXNzLCB3ZSBuZWVkIHRvXHJcbi8vICAgbWlncmF0ZSB0aGUgbGlzdGVuZXIgdG8gdGhlIHN0YXRpYyBldmVudC4gV2UgYWxzbyBuZWVkIHRvIG1haW50YWluIGEgbWFwXHJcbi8vICAgb2YgU2lnbmVyL0VOUyBuYW1lIHRvIGFkZHJlc3Mgc28gd2UgY2FuIHN5bmMgcmVzcG9uZCB0byBsaXN0ZW5lckNvdW50LlxyXG5pbXBvcnQgeyBnZXRBZGRyZXNzLCByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IFplcm9BZGRyZXNzIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBDb250cmFjdCB9IGZyb20gXCIuLi9jb250cmFjdC9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBuYW1laGFzaCB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGNvbmNhdCwgZGF0YUxlbmd0aCwgZGF0YVNsaWNlLCBoZXhsaWZ5LCBpc0hleFN0cmluZywgZ2V0QmlnSW50LCBnZXRCeXRlcywgZ2V0TnVtYmVyLCBpc0NhbGxFeGNlcHRpb24sIGlzRXJyb3IsIG1ha2VFcnJvciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgRmV0Y2hSZXF1ZXN0LCB0b0JlQXJyYXksIHRvUXVhbnRpdHksIGRlZmluZVByb3BlcnRpZXMsIEV2ZW50UGF5bG9hZCwgcmVzb2x2ZVByb3BlcnRpZXMsIHRvVXRmOFN0cmluZyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBFbnNSZXNvbHZlciB9IGZyb20gXCIuL2Vucy1yZXNvbHZlci5qc1wiO1xyXG5pbXBvcnQgeyBmb3JtYXRCbG9jaywgZm9ybWF0TG9nLCBmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQsIGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UgfSBmcm9tIFwiLi9mb3JtYXQuanNcIjtcclxuaW1wb3J0IHsgTmV0d29yayB9IGZyb20gXCIuL25ldHdvcmsuanNcIjtcclxuaW1wb3J0IHsgY29weVJlcXVlc3QsIEJsb2NrLCBGZWVEYXRhLCBMb2csIFRyYW5zYWN0aW9uUmVjZWlwdCwgVHJhbnNhY3Rpb25SZXNwb25zZSB9IGZyb20gXCIuL3Byb3ZpZGVyLmpzXCI7XHJcbmltcG9ydCB7IFBvbGxpbmdCbG9ja1N1YnNjcmliZXIsIFBvbGxpbmdCbG9ja1RhZ1N1YnNjcmliZXIsIFBvbGxpbmdFdmVudFN1YnNjcmliZXIsIFBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyLCBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyIH0gZnJvbSBcIi4vc3Vic2NyaWJlci1wb2xsaW5nLmpzXCI7XHJcbi8vIENvbnN0YW50c1xyXG5jb25zdCBCTl8yID0gQmlnSW50KDIpO1xyXG5jb25zdCBNQVhfQ0NJUF9SRURJUkVDVFMgPSAxMDtcclxuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VGFnKHByZWZpeCwgdmFsdWUpIHtcclxuICAgIHJldHVybiBwcmVmaXggKyBcIjpcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlLCAoaywgdikgPT4ge1xyXG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJiaWdpbnRcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gYGJpZ2ludDoke3YudG9TdHJpbmcoKX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gdi50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTb3J0IG9iamVjdCBrZXlzXHJcbiAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodikpIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHYpO1xyXG4gICAgICAgICAgICBrZXlzLnNvcnQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGtleXMucmVkdWNlKChhY2N1bSwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhY2N1bVtrZXldID0gdltrZXldO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xyXG4gICAgICAgICAgICB9LCB7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2O1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqICBBbiAqKlVubWFuYWdlZFN1YnNjcmliZXIqKiBpcyB1c2VmdWwgZm9yIGV2ZW50cyB3aGljaCBkbyBub3QgcmVxdWlyZVxyXG4gKiAgYW55IGFkZGl0aW9uYWwgbWFuYWdlbWVudCwgc3VjaCBhcyBgYFwiZGVidWdcImBgIHdoaWNoIG9ubHkgcmVxdWlyZXNcclxuICogIGVtaXQgaW4gc3luY2hyb25vdXMgZXZlbnQgbG9vcCB0cmlnZ2VyZWQgY2FsbHMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVW5tYW5hZ2VkU3Vic2NyaWJlciB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbmFtZSBmb2YgdGhlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBuYW1lO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IFVubWFuYWdlZFN1YnNjcmliZXIgd2l0aCAlJW5hbWUlJS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobmFtZSkgeyBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSB9KTsgfVxyXG4gICAgc3RhcnQoKSB7IH1cclxuICAgIHN0b3AoKSB7IH1cclxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkgeyB9XHJcbiAgICByZXN1bWUoKSB7IH1cclxufVxyXG5mdW5jdGlvbiBjb3B5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xyXG59XHJcbmZ1bmN0aW9uIGNvbmNpc2lmeShpdGVtcykge1xyXG4gICAgaXRlbXMgPSBBcnJheS5mcm9tKChuZXcgU2V0KGl0ZW1zKSkudmFsdWVzKCkpO1xyXG4gICAgaXRlbXMuc29ydCgpO1xyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGdldFN1YnNjcmlwdGlvbihfZXZlbnQsIHByb3ZpZGVyKSB7XHJcbiAgICBpZiAoX2V2ZW50ID09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGV2ZW50XCIpO1xyXG4gICAgfVxyXG4gICAgLy8gTm9ybWFsaXplIHRvcGljIGFycmF5IGluZm8gYW4gRXZlbnRGaWx0ZXJcclxuICAgIGlmIChBcnJheS5pc0FycmF5KF9ldmVudCkpIHtcclxuICAgICAgICBfZXZlbnQgPSB7IHRvcGljczogX2V2ZW50IH07XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIChfZXZlbnQpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgc3dpdGNoIChfZXZlbnQpIHtcclxuICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcclxuICAgICAgICAgICAgY2FzZSBcImZpbmFsaXplZFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwibmV0d29ya1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwic2FmZVwiOiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBfZXZlbnQsIHRhZzogX2V2ZW50IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNIZXhTdHJpbmcoX2V2ZW50LCAzMikpIHtcclxuICAgICAgICBjb25zdCBoYXNoID0gX2V2ZW50LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0cmFuc2FjdGlvblwiLCB0YWc6IGdldFRhZyhcInR4XCIsIHsgaGFzaCB9KSwgaGFzaCB9O1xyXG4gICAgfVxyXG4gICAgaWYgKF9ldmVudC5vcnBoYW4pIHtcclxuICAgICAgICBjb25zdCBldmVudCA9IF9ldmVudDtcclxuICAgICAgICAvLyBAVE9ETzogU2hvdWxkIGxvd2VyY2FzZSBhbmQgd2hhdG5vdCB0aGluZ3MgaGVyZSBpbnN0ZWFkIG9mIGNvcHkuLi5cclxuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm9ycGhhblwiLCB0YWc6IGdldFRhZyhcIm9ycGhhblwiLCBldmVudCksIGZpbHRlcjogY29weShldmVudCkgfTtcclxuICAgIH1cclxuICAgIGlmICgoX2V2ZW50LmFkZHJlc3MgfHwgX2V2ZW50LnRvcGljcykpIHtcclxuICAgICAgICBjb25zdCBldmVudCA9IF9ldmVudDtcclxuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7XHJcbiAgICAgICAgICAgIHRvcGljczogKChldmVudC50b3BpY3MgfHwgW10pLm1hcCgodCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uY2lzaWZ5KHQubWFwKCh0KSA9PiB0LnRvTG93ZXJDYXNlKCkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGV2ZW50LmFkZHJlc3MpIHtcclxuICAgICAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZEFkZHJlc3MgPSAoYWRkcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGFkZHIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goYWRkcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKGF3YWl0IHJlc29sdmVBZGRyZXNzKGFkZHIsIHByb3ZpZGVyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50LmFkZHJlc3MpKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudC5hZGRyZXNzLmZvckVhY2goYWRkQWRkcmVzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhZGRBZGRyZXNzKGV2ZW50LmFkZHJlc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaWx0ZXIuYWRkcmVzcyA9IGNvbmNpc2lmeShhZGRyZXNzZXMubWFwKChhKSA9PiBhLnRvTG93ZXJDYXNlKCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgZmlsdGVyLCB0YWc6IGdldFRhZyhcImV2ZW50XCIsIGZpbHRlciksIHR5cGU6IFwiZXZlbnRcIiB9O1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5rbm93biBQcm92aWRlckV2ZW50XCIsIFwiZXZlbnRcIiwgX2V2ZW50KTtcclxufVxyXG5mdW5jdGlvbiBnZXRUaW1lKCkgeyByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTsgfVxyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICAgIGNhY2hlVGltZW91dDogMjUwLFxyXG4gICAgcG9sbGluZ0ludGVydmFsOiA0MDAwXHJcbn07XHJcbi8qKlxyXG4gKiAgQW4gKipBYnN0cmFjdFByb3ZpZGVyKiogcHJvdmlkZXMgYSBiYXNlIGNsYXNzIGZvciBvdGhlciBzdWItY2xhc3NlcyB0b1xyXG4gKiAgaW1wbGVtZW50IHRoZSBbW1Byb3ZpZGVyXV0gQVBJIGJ5IG5vcm1hbGl6aW5nIGlucHV0IGFyZ3VtZW50cyBhbmRcclxuICogIGZvcm1hdHRpbmcgb3V0cHV0IHJlc3VsdHMgYXMgd2VsbCBhcyB0cmFja2luZyBldmVudHMgZm9yIGNvbnNpc3RlbnRcclxuICogIGJlaGF2aW91ciBvbiBhbiBldmVudHVhbGx5LWNvbnNpc3RlbnQgbmV0d29yay5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBBYnN0cmFjdFByb3ZpZGVyIHtcclxuICAgICNzdWJzO1xyXG4gICAgI3BsdWdpbnM7XHJcbiAgICAvLyBudWxsPXVucGF1c2VkLCB0cnVlPXBhdXNlZCtkcm9wV2hpbGVQYXVzZWQsIGZhbHNlPXBhdXNlZFxyXG4gICAgI3BhdXNlZFN0YXRlO1xyXG4gICAgI2Rlc3Ryb3llZDtcclxuICAgICNuZXR3b3JrUHJvbWlzZTtcclxuICAgICNhbnlOZXR3b3JrO1xyXG4gICAgI3BlcmZvcm1DYWNoZTtcclxuICAgIC8vIFRoZSBtb3N0IHJlY2VudCBibG9jayBudW1iZXIgaWYgcnVubmluZyBhbiBldmVudCBvciAtMSBpZiBubyBcImJsb2NrXCIgZXZlbnRcclxuICAgICNsYXN0QmxvY2tOdW1iZXI7XHJcbiAgICAjbmV4dFRpbWVyO1xyXG4gICAgI3RpbWVycztcclxuICAgICNkaXNhYmxlQ2NpcFJlYWQ7XHJcbiAgICAjb3B0aW9ucztcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkFic3RyYWN0UHJvdmlkZXIqKiBjb25uZWN0ZWQgdG8gJSVuZXR3b3JrJSUsIG9yXHJcbiAgICAgKiAgdXNlIHRoZSB2YXJpb3VzIG5ldHdvcmsgZGV0ZWN0aW9uIGNhcGFiaWxpdGllcyB0byBkaXNjb3ZlciB0aGVcclxuICAgICAqICBbW05ldHdvcmtdXSBpZiBuZWNlc3NhcnkuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy4jb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcclxuICAgICAgICBpZiAoX25ldHdvcmsgPT09IFwiYW55XCIpIHtcclxuICAgICAgICAgICAgdGhpcy4jYW55TmV0d29yayA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoX25ldHdvcmspIHtcclxuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IE5ldHdvcmsuZnJvbShfbmV0d29yayk7XHJcbiAgICAgICAgICAgIHRoaXMuI2FueU5ldHdvcmsgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUobmV0d29yayk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIG5ldHdvcmssIG51bGwpOyB9LCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuI2FueU5ldHdvcmsgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPSAtMTtcclxuICAgICAgICB0aGlzLiNwZXJmb3JtQ2FjaGUgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy4jc3VicyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLiNwbHVnaW5zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuI3BhdXNlZFN0YXRlID0gbnVsbDtcclxuICAgICAgICB0aGlzLiNkZXN0cm95ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLiNuZXh0VGltZXIgPSAxO1xyXG4gICAgICAgIHRoaXMuI3RpbWVycyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLiNkaXNhYmxlQ2NpcFJlYWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7IHJldHVybiB0aGlzLiNvcHRpb25zLnBvbGxpbmdJbnRlcnZhbDsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBgYHRoaXNgYCwgdG8gYWxsb3cgYW4gKipBYnN0cmFjdFByb3ZpZGVyKiogdG8gaW1wbGVtZW50XHJcbiAgICAgKiAgdGhlIFtbQ29udHJhY3RSdW5uZXJdXSBpbnRlcmZhY2UuXHJcbiAgICAgKi9cclxuICAgIGdldCBwcm92aWRlcigpIHsgcmV0dXJuIHRoaXM7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYWxsIHRoZSByZWdpc3RlcmVkIHBsdWctaW5zLlxyXG4gICAgICovXHJcbiAgICBnZXQgcGx1Z2lucygpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiNwbHVnaW5zLnZhbHVlcygpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEF0dGFjaCBhIG5ldyBwbHVnLWluLlxyXG4gICAgICovXHJcbiAgICBhdHRhY2hQbHVnaW4ocGx1Z2luKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuI3BsdWdpbnMuZ2V0KHBsdWdpbi5uYW1lKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZXBsYWNlIGV4aXN0aW5nIHBsdWdpbjogJHtwbHVnaW4ubmFtZX0gYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuI3BsdWdpbnMuc2V0KHBsdWdpbi5uYW1lLCBwbHVnaW4uY29ubmVjdCh0aGlzKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBHZXQgYSBwbHVnaW4gYnkgbmFtZS5cclxuICAgICAqL1xyXG4gICAgZ2V0UGx1Z2luKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuI3BsdWdpbnMuZ2V0KG5hbWUpKSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUHJldmVudCBhbnkgQ0NJUC1yZWFkIG9wZXJhdGlvbiwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHJlcXVlc3RlZFxyXG4gICAgICogIGluIGEgW1tjYWxsXV0gdXNpbmcgYGBlbmFibGVDY2lwUmVhZGBgLlxyXG4gICAgICovXHJcbiAgICBnZXQgZGlzYWJsZUNjaXBSZWFkKCkgeyByZXR1cm4gdGhpcy4jZGlzYWJsZUNjaXBSZWFkOyB9XHJcbiAgICBzZXQgZGlzYWJsZUNjaXBSZWFkKHZhbHVlKSB7IHRoaXMuI2Rpc2FibGVDY2lwUmVhZCA9ICEhdmFsdWU7IH1cclxuICAgIC8vIFNoYXJlcyBtdWx0aXBsZSBpZGVudGljYWwgcmVxdWVzdHMgbWFkZSBkdXJpbmcgdGhlIHNhbWUgMjUwbXNcclxuICAgIGFzeW5jICNwZXJmb3JtKHJlcSkge1xyXG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLiNvcHRpb25zLmNhY2hlVGltZW91dDtcclxuICAgICAgICAvLyBDYWNoaW5nIGRpc2FibGVkXHJcbiAgICAgICAgaWYgKHRpbWVvdXQgPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9wZXJmb3JtKHJlcSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENyZWF0ZSBhIHRhZ1xyXG4gICAgICAgIGNvbnN0IHRhZyA9IGdldFRhZyhyZXEubWV0aG9kLCByZXEpO1xyXG4gICAgICAgIGxldCBwZXJmb3JtID0gdGhpcy4jcGVyZm9ybUNhY2hlLmdldCh0YWcpO1xyXG4gICAgICAgIGlmICghcGVyZm9ybSkge1xyXG4gICAgICAgICAgICBwZXJmb3JtID0gdGhpcy5fcGVyZm9ybShyZXEpO1xyXG4gICAgICAgICAgICB0aGlzLiNwZXJmb3JtQ2FjaGUuc2V0KHRhZywgcGVyZm9ybSk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3BlcmZvcm1DYWNoZS5nZXQodGFnKSA9PT0gcGVyZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3BlcmZvcm1DYWNoZS5kZWxldGUodGFnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdGltZW91dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhd2FpdCBwZXJmb3JtO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGRhdGEgZm9yIGV4ZWN1dGluZyB0aGUgQ0NJUC1yZWFkIG9wZXJhdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGNjaXBSZWFkRmV0Y2godHgsIGNhbGxkYXRhLCB1cmxzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZUNjaXBSZWFkIHx8IHVybHMubGVuZ3RoID09PSAwIHx8IHR4LnRvID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlbmRlciA9IHR4LnRvLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGNhbGxkYXRhLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB1cmwgPSB1cmxzW2ldO1xyXG4gICAgICAgICAgICAvLyBVUkwgZXhwYW5zaW9uXHJcbiAgICAgICAgICAgIGNvbnN0IGhyZWYgPSB1cmwucmVwbGFjZShcIntzZW5kZXJ9XCIsIHNlbmRlcikucmVwbGFjZShcIntkYXRhfVwiLCBkYXRhKTtcclxuICAgICAgICAgICAgLy8gSWYgbm8ge2RhdGF9IGlzIHByZXNlbnQsIHVzZSBQT1NUOyBvdGhlcndpc2UgR0VUXHJcbiAgICAgICAgICAgIC8vY29uc3QganNvbjogc3RyaW5nIHwgbnVsbCA9ICh1cmwuaW5kZXhPZihcIntkYXRhfVwiKSA+PSAwKSA/IG51bGw6IEpTT04uc3RyaW5naWZ5KHsgZGF0YSwgc2VuZGVyIH0pO1xyXG4gICAgICAgICAgICAvL2NvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoSnNvbih7IHVybDogaHJlZiwgZXJyb3JQYXNzVGhyb3VnaDogdHJ1ZSB9LCBqc29uLCAodmFsdWUsIHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgIC8vICAgIHZhbHVlLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XHJcbiAgICAgICAgICAgIC8vICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgLy99KTtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBGZXRjaFJlcXVlc3QoaHJlZik7XHJcbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZihcIntkYXRhfVwiKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QuYm9keSA9IHsgZGF0YSwgc2VuZGVyIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZENjaXBSZWFkRmV0Y2hSZXF1ZXN0XCIsIHJlcXVlc3QsIGluZGV4OiBpLCB1cmxzIH0pO1xyXG4gICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJ1bmtub3duIGVycm9yXCI7XHJcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSByZXNvdXJjZS4uLlxyXG4gICAgICAgICAgICBsZXQgcmVzcDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJlc3AgPSBhd2FpdCByZXF1ZXN0LnNlbmQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIC4uLmxvdy1sZXZlbCBmZXRjaCBlcnJvciAobWlzc2luZyBob3N0LCBiYWQgU1NMLCBldGMuKSxcclxuICAgICAgICAgICAgICAgIC8vIHNvIHRyeSBuZXh0IFVSTFxyXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlcy5wdXNoKGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkRmV0Y2hFcnJvclwiLCByZXF1ZXN0LCByZXN1bHQ6IHsgZXJyb3IgfSB9KTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXNwLmJvZHlKc29uO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkRmV0Y2hSZXN1bHRcIiwgcmVxdWVzdCwgcmVzdWx0IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHJlc3VsdC5tZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkRmV0Y2hFcnJvclwiLCByZXF1ZXN0LCByZXN1bHQgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgICAgICAgICAgLy8gNHh4IGluZGljYXRlcyB0aGUgcmVzdWx0IGlzIG5vdCBwcmVzZW50OyBzdG9wXHJcbiAgICAgICAgICAgIGFzc2VydChyZXNwLnN0YXR1c0NvZGUgPCA0MDAgfHwgcmVzcC5zdGF0dXNDb2RlID49IDUwMCwgYHJlc3BvbnNlIG5vdCBmb3VuZCBkdXJpbmcgQ0NJUCBmZXRjaDogJHtlcnJvck1lc3NhZ2V9YCwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7IHJlYXNvbjogXCI0MDRfTUlTU0lOR19SRVNPVVJDRVwiLCB0cmFuc2FjdGlvbjogdHgsIGluZm86IHsgdXJsLCBlcnJvck1lc3NhZ2UgfSB9KTtcclxuICAgICAgICAgICAgLy8gNXh4IGluZGljYXRlcyBzZXJ2ZXIgaXNzdWU7IHRyeSB0aGUgbmV4dCB1cmxcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlcy5wdXNoKGVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydChmYWxzZSwgYGVycm9yIGVuY291bnRlcmVkIGR1cmluZyBDQ0lQIGZldGNoOiAke2Vycm9yTWVzc2FnZXMubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtKSkuam9pbihcIiwgXCIpfWAsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xyXG4gICAgICAgICAgICByZWFzb246IFwiNTAwX1NFUlZFUl9FUlJPUlwiLFxyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHgsIGluZm86IHsgdXJscywgZXJyb3JNZXNzYWdlcyB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSBibG9jayBiZWZvcmVcclxuICAgICAqICByZXR1cm5pbmcgaXQsIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgYW4gYWx0ZXJuYXRlXHJcbiAgICAgKiAgc3ViLWNsYXNzIG9mIFtbQmxvY2tdXS5cclxuICAgICAqL1xyXG4gICAgX3dyYXBCbG9jayh2YWx1ZSwgbmV0d29yaykge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmxvY2soZm9ybWF0QmxvY2sodmFsdWUpLCB0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIGxvZyBiZWZvcmVcclxuICAgICAqICByZXR1cm5pbmcgaXQsIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgYW4gYWx0ZXJuYXRlXHJcbiAgICAgKiAgc3ViLWNsYXNzIG9mIFtbTG9nXV0uXHJcbiAgICAgKi9cclxuICAgIF93cmFwTG9nKHZhbHVlLCBuZXR3b3JrKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMb2coZm9ybWF0TG9nKHZhbHVlKSwgdGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSB0cmFuc2FjdGlvblxyXG4gICAgICogIHJlY2VpcHQgYmVmb3JlIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhblxyXG4gICAgICogIGFsdGVybmF0ZSBzdWItY2xhc3Mgb2YgW1tUcmFuc2FjdGlvblJlY2VpcHRdXS5cclxuICAgICAqL1xyXG4gICAgX3dyYXBUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUsIG5ldHdvcmspIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uUmVjZWlwdChmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUpLCB0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIHRyYW5zYWN0aW9uXHJcbiAgICAgKiAgcmVzcG9uc2UgYmVmb3JlIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhblxyXG4gICAgICogIGFsdGVybmF0ZSBzdWItY2xhc3Mgb2YgW1tUcmFuc2FjdGlvblJlc3BvbnNlXV0uXHJcbiAgICAgKi9cclxuICAgIF93cmFwVHJhbnNhY3Rpb25SZXNwb25zZSh0eCwgbmV0d29yaykge1xyXG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZShmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlKHR4KSwgdGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgTmV0d29yaywgZm9yY2luZyBhIG5ldHdvcmsgZGV0ZWN0aW9uIHVzaW5nIHdoYXRldmVyXHJcbiAgICAgKiAgdGVjaG5pcXVlIHRoZSBzdWItY2xhc3MgcmVxdWlyZXMuXHJcbiAgICAgKlxyXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMuXHJcbiAgICAgKi9cclxuICAgIF9kZXRlY3ROZXR3b3JrKCkge1xyXG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJzdWItY2xhc3NlcyBtdXN0IGltcGxlbWVudCB0aGlzXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIl9kZXRlY3ROZXR3b3JrXCJcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFN1Yi1jbGFzc2VzIHNob3VsZCB1c2UgdGhpcyB0byBwZXJmb3JtIGFsbCBidWlsdC1pbiBvcGVyYXRpb25zLiBBbGxcclxuICAgICAqICBtZXRob2RzIHNhbml0aXplcyBhbmQgbm9ybWFsaXplcyB0aGUgdmFsdWVzIHBhc3NlZCBpbnRvIHRoaXMuXHJcbiAgICAgKlxyXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIF9wZXJmb3JtKHJlcSkge1xyXG4gICAgICAgIGFzc2VydChmYWxzZSwgYHVuc3VwcG9ydGVkIG1ldGhvZDogJHtyZXEubWV0aG9kfWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiByZXEubWV0aG9kLFxyXG4gICAgICAgICAgICBpbmZvOiByZXFcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIFN0YXRlXHJcbiAgICBhc3luYyBnZXRCbG9ja051bWJlcigpIHtcclxuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGdldE51bWJlcihhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldEJsb2NrTnVtYmVyXCIgfSksIFwiJXJlc3BvbnNlXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPj0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBvciByZXNvbHZlcyB0byB0aGUgYWRkcmVzcyBmb3IgJSVhZGRyZXNzJSUsIHJlc29sdmluZyBFTlNcclxuICAgICAqICBuYW1lcyBhbmQgW1tBZGRyZXNzYWJsZV1dIG9iamVjdHMgYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGFuXHJcbiAgICAgKiAgYWRkcmVzcy5cclxuICAgICAqL1xyXG4gICAgX2dldEFkZHJlc3MoYWRkcmVzcykge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlQWRkcmVzcyhhZGRyZXNzLCB0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgb3IgcmVzb2x2ZXMgdG8gYSB2YWxpZCBibG9jayB0YWcgZm9yICUlYmxvY2tUYWclJSwgcmVzb2x2aW5nXHJcbiAgICAgKiAgbmVnYXRpdmUgdmFsdWVzIGFuZCByZXR1cm5pbmcgaWYgYWxyZWFkeSBhIHZhbGlkIGJsb2NrIHRhZy5cclxuICAgICAqL1xyXG4gICAgX2dldEJsb2NrVGFnKGJsb2NrVGFnKSB7XHJcbiAgICAgICAgaWYgKGJsb2NrVGFnID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwibGF0ZXN0XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoYmxvY2tUYWcpIHtcclxuICAgICAgICAgICAgY2FzZSBcImVhcmxpZXN0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIweDBcIjtcclxuICAgICAgICAgICAgY2FzZSBcImZpbmFsaXplZFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwibGF0ZXN0XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJzYWZlXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tUYWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhibG9ja1RhZykpIHtcclxuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGJsb2NrVGFnLCAzMikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBibG9ja1RhZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdG9RdWFudGl0eShibG9ja1RhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgKGJsb2NrVGFnKSA9PT0gXCJiaWdpbnRcIikge1xyXG4gICAgICAgICAgICBibG9ja1RhZyA9IGdldE51bWJlcihibG9ja1RhZywgXCJibG9ja1RhZ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIGlmIChibG9ja1RhZyA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9RdWFudGl0eShibG9ja1RhZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuI2xhc3RCbG9ja051bWJlciA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9RdWFudGl0eSh0aGlzLiNsYXN0QmxvY2tOdW1iZXIgKyBibG9ja1RhZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKChiKSA9PiB0b1F1YW50aXR5KGIgKyBibG9ja1RhZykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGJsb2NrVGFnXCIsIFwiYmxvY2tUYWdcIiwgYmxvY2tUYWcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBvciByZXNvbHZlcyB0byBhIGZpbHRlciBmb3IgJSVmaWx0ZXIlJSwgcmVzb2x2aW5nIGFueSBFTlNcclxuICAgICAqICBuYW1lcyBvciBbW0FkZHJlc3NhYmxlXV0gb2JqZWN0IGFuZCByZXR1cm5pbmcgaWYgYWxyZWFkeSBhIHZhbGlkXHJcbiAgICAgKiAgZmlsdGVyLlxyXG4gICAgICovXHJcbiAgICBfZ2V0RmlsdGVyKGZpbHRlcikge1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIGNhbm9uaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdG9waWNzXHJcbiAgICAgICAgY29uc3QgdG9waWNzID0gKGZpbHRlci50b3BpY3MgfHwgW10pLm1hcCgodCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNpc2lmeSh0Lm1hcCgodCkgPT4gdC50b0xvd2VyQ2FzZSgpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBibG9ja0hhc2ggPSAoXCJibG9ja0hhc2hcIiBpbiBmaWx0ZXIpID8gZmlsdGVyLmJsb2NrSGFzaCA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCByZXNvbHZlID0gKF9hZGRyZXNzLCBmcm9tQmxvY2ssIHRvQmxvY2spID0+IHtcclxuICAgICAgICAgICAgbGV0IGFkZHJlc3MgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2FkZHJlc3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBfYWRkcmVzc1swXTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgX2FkZHJlc3Muc29ydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBfYWRkcmVzcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYmxvY2tIYXNoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUJsb2NrICE9IG51bGwgfHwgdG9CbG9jayAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmaWx0ZXJcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZmlsdGVyID0ge307XHJcbiAgICAgICAgICAgIGlmIChhZGRyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXIuYWRkcmVzcyA9IGFkZHJlc3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRvcGljcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGZpbHRlci50b3BpY3MgPSB0b3BpY3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZyb21CbG9jaykge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyLmZyb21CbG9jayA9IGZyb21CbG9jaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodG9CbG9jaykge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyLnRvQmxvY2sgPSB0b0Jsb2NrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChibG9ja0hhc2gpIHtcclxuICAgICAgICAgICAgICAgIGZpbHRlci5ibG9ja0hhc2ggPSBibG9ja0hhc2g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEFkZHJlc3NlcyBjb3VsZCBiZSBhc3luYyAoRU5TIG5hbWVzIG9yIEFkZHJlc3NhYmxlcylcclxuICAgICAgICBsZXQgYWRkcmVzcyA9IFtdO1xyXG4gICAgICAgIGlmIChmaWx0ZXIuYWRkcmVzcykge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXIuYWRkcmVzcykpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWRkciBvZiBmaWx0ZXIuYWRkcmVzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MucHVzaCh0aGlzLl9nZXRBZGRyZXNzKGFkZHIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFkZHJlc3MucHVzaCh0aGlzLl9nZXRBZGRyZXNzKGZpbHRlci5hZGRyZXNzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGZyb21CbG9jayA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoXCJmcm9tQmxvY2tcIiBpbiBmaWx0ZXIpIHtcclxuICAgICAgICAgICAgZnJvbUJsb2NrID0gdGhpcy5fZ2V0QmxvY2tUYWcoZmlsdGVyLmZyb21CbG9jayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0b0Jsb2NrID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmIChcInRvQmxvY2tcIiBpbiBmaWx0ZXIpIHtcclxuICAgICAgICAgICAgdG9CbG9jayA9IHRoaXMuX2dldEJsb2NrVGFnKGZpbHRlci50b0Jsb2NrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFkZHJlc3MuZmlsdGVyKChhKSA9PiAodHlwZW9mIChhKSAhPT0gXCJzdHJpbmdcIikpLmxlbmd0aCB8fFxyXG4gICAgICAgICAgICAoZnJvbUJsb2NrICE9IG51bGwgJiYgdHlwZW9mIChmcm9tQmxvY2spICE9PSBcInN0cmluZ1wiKSB8fFxyXG4gICAgICAgICAgICAodG9CbG9jayAhPSBudWxsICYmIHR5cGVvZiAodG9CbG9jaykgIT09IFwic3RyaW5nXCIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbUHJvbWlzZS5hbGwoYWRkcmVzcyksIGZyb21CbG9jaywgdG9CbG9ja10pLnRoZW4oKHJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0WzBdLCByZXN1bHRbMV0sIHJlc3VsdFsyXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzb2x2ZShhZGRyZXNzLCBmcm9tQmxvY2ssIHRvQmxvY2spO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBvciByZXNvbHZlcyB0byBhIHRyYW5zYWN0aW9uIGZvciAlJXJlcXVlc3QlJSwgcmVzb2x2aW5nXHJcbiAgICAgKiAgYW55IEVOUyBuYW1lcyBvciBbW0FkZHJlc3NhYmxlXV0gYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGEgdmFsaWRcclxuICAgICAqICB0cmFuc2FjdGlvbi5cclxuICAgICAqL1xyXG4gICAgX2dldFRyYW5zYWN0aW9uUmVxdWVzdChfcmVxdWVzdCkge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjb3B5UmVxdWVzdChfcmVxdWVzdCk7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICBbXCJ0b1wiLCBcImZyb21cIl0uZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0W2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZHIgPSByZXNvbHZlQWRkcmVzcyhyZXF1ZXN0W2tleV0sIHRoaXMpO1xyXG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKGFkZHIpKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyBmdW5jdGlvbiAoKSB7IHJlcXVlc3Rba2V5XSA9IGF3YWl0IGFkZHI7IH0pKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdFtrZXldID0gYWRkcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChyZXF1ZXN0LmJsb2NrVGFnICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgYmxvY2tUYWcgPSB0aGlzLl9nZXRCbG9ja1RhZyhyZXF1ZXN0LmJsb2NrVGFnKTtcclxuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShibG9ja1RhZykpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jIGZ1bmN0aW9uICgpIHsgcmVxdWVzdC5ibG9ja1RhZyA9IGF3YWl0IGJsb2NrVGFnOyB9KSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QuYmxvY2tUYWcgPSBibG9ja1RhZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoYXN5bmMgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XHJcbiAgICAgICAgICAgIH0pKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0TmV0d29yaygpIHtcclxuICAgICAgICAvLyBObyBleHBsaWNpdCBuZXR3b3JrIHdhcyBzZXQgYW5kIHRoaXMgaXMgb3VyIGZpcnN0IHRpbWVcclxuICAgICAgICBpZiAodGhpcy4jbmV0d29ya1Byb21pc2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBEZXRlY3QgdGhlIGN1cnJlbnQgbmV0d29yayAoc2hhcmVkIHdpdGggYWxsIGNhbGxzKVxyXG4gICAgICAgICAgICBjb25zdCBkZXRlY3ROZXR3b3JrID0gKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHRoaXMuX2RldGVjdE5ldHdvcmsoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIG5ldHdvcmssIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI25ldHdvcmtQcm9taXNlID09PSBkZXRlY3ROZXR3b3JrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKCk7XHJcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gZGV0ZWN0TmV0d29yaztcclxuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCBkZXRlY3ROZXR3b3JrKS5jbG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXR3b3JrUHJvbWlzZSA9IHRoaXMuI25ldHdvcmtQcm9taXNlO1xyXG4gICAgICAgIGNvbnN0IFtleHBlY3RlZCwgYWN0dWFsXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgbmV0d29ya1Byb21pc2UsXHJcbiAgICAgICAgICAgIHRoaXMuX2RldGVjdE5ldHdvcmsoKSAvLyBUaGUgYWN0dWFsIGNvbm5lY3RlZCBuZXR3b3JrXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgaWYgKGV4cGVjdGVkLmNoYWluSWQgIT09IGFjdHVhbC5jaGFpbklkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLiNhbnlOZXR3b3JrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgXCJhbnlcIiBuZXR3b3JrIGNhbiBjaGFuZ2UsIHNvIG5vdGlmeSBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgYWN0dWFsLCBleHBlY3RlZCk7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIG5ldHdvcmsgaWYgc29tZXRoaW5nIGVsc2UgaGFzbid0IGFscmVhZHkgY2hhbmdlZCBpdFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI25ldHdvcmtQcm9taXNlID09PSBuZXR3b3JrUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGFjdHVhbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIGRvIG5vdCBhbGxvdyBjaGFuZ2VzIHRvIHRoZSB1bmRlcmx5aW5nIG5ldHdvcmtcclxuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYG5ldHdvcmsgY2hhbmdlZDogJHtleHBlY3RlZC5jaGFpbklkfSA9PiAke2FjdHVhbC5jaGFpbklkfSBgLCBcIk5FVFdPUktfRVJST1JcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImNoYW5nZWRcIlxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkLmNsb25lKCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRGZWVEYXRhKCkge1xyXG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCB0aGlzLmdldE5ldHdvcmsoKTtcclxuICAgICAgICBjb25zdCBnZXRGZWVEYXRhRnVuYyA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBfYmxvY2ssIGdhc1ByaWNlLCBwcmlvcml0eUZlZSB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICAgICAgX2Jsb2NrOiB0aGlzLiNnZXRCbG9jayhcImxhdGVzdFwiLCBmYWxzZSksXHJcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogKChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldEdhc1ByaWNlXCIgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRCaWdJbnQodmFsdWUsIFwiJXJlc3BvbnNlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfSkoKSksXHJcbiAgICAgICAgICAgICAgICBwcmlvcml0eUZlZTogKChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFByaW9yaXR5RmVlXCIgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRCaWdJbnQodmFsdWUsIFwiJXJlc3BvbnNlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfSkoKSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxldCBtYXhGZWVQZXJHYXMgPSBudWxsO1xyXG4gICAgICAgICAgICBsZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBudWxsO1xyXG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIHJlY29tbWVuZGVkIEVJUC0xNTU5IGhldXJpc3RpY3MgZm9yIGZlZSBkYXRhXHJcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5fd3JhcEJsb2NrKF9ibG9jaywgbmV0d29yayk7XHJcbiAgICAgICAgICAgIGlmIChibG9jayAmJiBibG9jay5iYXNlRmVlUGVyR2FzKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IChwcmlvcml0eUZlZSAhPSBudWxsKSA/IHByaW9yaXR5RmVlIDogQmlnSW50KFwiMTAwMDAwMDAwMFwiKTtcclxuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhcyA9IChibG9jay5iYXNlRmVlUGVyR2FzICogQk5fMikgKyBtYXhQcmlvcml0eUZlZVBlckdhcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZlZURhdGEoZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGEgRmVlRGF0YU5ldFdvcmtQbHVnaW5cclxuICAgICAgICBjb25zdCBwbHVnaW4gPSBuZXR3b3JrLmdldFBsdWdpbihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkZldGNoVXJsRmVlRGF0YVBsdWdpblwiKTtcclxuICAgICAgICBpZiAocGx1Z2luKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QocGx1Z2luLnVybCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwbHVnaW4ucHJvY2Vzc0Z1bmMoZ2V0RmVlRGF0YUZ1bmMsIHRoaXMsIHJlcSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmVlRGF0YShmZWVEYXRhLmdhc1ByaWNlLCBmZWVEYXRhLm1heEZlZVBlckdhcywgZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhd2FpdCBnZXRGZWVEYXRhRnVuYygpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZXN0aW1hdGVHYXMoX3R4KSB7XHJcbiAgICAgICAgbGV0IHR4ID0gdGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KF90eCk7XHJcbiAgICAgICAgaWYgKGlzUHJvbWlzZSh0eCkpIHtcclxuICAgICAgICAgICAgdHggPSBhd2FpdCB0eDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdldEJpZ0ludChhd2FpdCB0aGlzLiNwZXJmb3JtKHtcclxuICAgICAgICAgICAgbWV0aG9kOiBcImVzdGltYXRlR2FzXCIsIHRyYW5zYWN0aW9uOiB0eFxyXG4gICAgICAgIH0pLCBcIiVyZXNwb25zZVwiKTtcclxuICAgIH1cclxuICAgIGFzeW5jICNjYWxsKHR4LCBibG9ja1RhZywgYXR0ZW1wdCkge1xyXG4gICAgICAgIGFzc2VydChhdHRlbXB0IDwgTUFYX0NDSVBfUkVESVJFQ1RTLCBcIkNDSVAgcmVhZCBleGNlZWRlZCBtYXhpbXVtIHJlZGlyZWN0aW9uc1wiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcclxuICAgICAgICAgICAgcmVhc29uOiBcIlRPT19NQU5ZX1JFRElSRUNUU1wiLFxyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbih7fSwgdHgsIHsgYmxvY2tUYWcsIGVuYWJsZUNjaXBSZWFkOiB0cnVlIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gVGhpcyBjYW1lIGluIGFzIGEgUGVyZm9ybUFjdGlvblRyYW5zYWN0aW9uLCBzbyB0by9mcm9tIGFyZSBzYWZlOyB3ZSBjYW4gY2FzdFxyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gY29weVJlcXVlc3QodHgpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGF3YWl0IHRoaXMuX3BlcmZvcm0oeyBtZXRob2Q6IFwiY2FsbFwiLCB0cmFuc2FjdGlvbiwgYmxvY2tUYWcgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgLy8gQ0NJUCBSZWFkIE9mZmNoYWluTG9va3VwXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5kaXNhYmxlQ2NpcFJlYWQgJiYgaXNDYWxsRXhjZXB0aW9uKGVycm9yKSAmJiBlcnJvci5kYXRhICYmIGF0dGVtcHQgPj0gMCAmJiBibG9ja1RhZyA9PT0gXCJsYXRlc3RcIiAmJiB0cmFuc2FjdGlvbi50byAhPSBudWxsICYmIGRhdGFTbGljZShlcnJvci5kYXRhLCAwLCA0KSA9PT0gXCIweDU1NmYxODMwXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlcnJvci5kYXRhO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHhTZW5kZXIgPSBhd2FpdCByZXNvbHZlQWRkcmVzcyh0cmFuc2FjdGlvbi50bywgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgQ0NJUCBSZWFkIEFyZ3VtZW50c1xyXG4gICAgICAgICAgICAgICAgbGV0IGNjaXBBcmdzO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjY2lwQXJncyA9IHBhcnNlT2ZmY2hhaW5Mb29rdXAoZGF0YVNsaWNlKGVycm9yLmRhdGEsIDQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgZXJyb3IubWVzc2FnZSwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJCQURfREFUQVwiLCB0cmFuc2FjdGlvbiwgaW5mbzogeyBkYXRhIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBzZW5kZXIgb2YgdGhlIE9mZmNoYWluTG9va3VwIG1hdGNoZXMgdGhlIHRyYW5zYWN0aW9uXHJcbiAgICAgICAgICAgICAgICBhc3NlcnQoY2NpcEFyZ3Muc2VuZGVyLnRvTG93ZXJDYXNlKCkgPT09IHR4U2VuZGVyLnRvTG93ZXJDYXNlKCksIFwiQ0NJUCBSZWFkIHNlbmRlciBtaXNtYXRjaFwiLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiY2FsbFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIk9mZmNoYWluTG9va3VwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGludm9jYXRpb246IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJPZmZjaGFpbkxvb2t1cChhZGRyZXNzLHN0cmluZ1tdLGJ5dGVzLGJ5dGVzNCxieXRlcylcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBjY2lwQXJncy5lcnJvckFyZ3NcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNjaXBSZXN1bHQgPSBhd2FpdCB0aGlzLmNjaXBSZWFkRmV0Y2godHJhbnNhY3Rpb24sIGNjaXBBcmdzLmNhbGxkYXRhLCBjY2lwQXJncy51cmxzKTtcclxuICAgICAgICAgICAgICAgIGFzc2VydChjY2lwUmVzdWx0ICE9IG51bGwsIFwiQ0NJUCBSZWFkIGZhaWxlZCB0byBmZXRjaCBkYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJGRVRDSF9GQUlMRURcIiwgdHJhbnNhY3Rpb24sIGluZm86IHsgZGF0YTogZXJyb3IuZGF0YSwgZXJyb3JBcmdzOiBjY2lwQXJncy5lcnJvckFyZ3MgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0bzogdHhTZW5kZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY29uY2F0KFtjY2lwQXJncy5zZWxlY3RvciwgZW5jb2RlQnl0ZXMoW2NjaXBSZXN1bHQsIGNjaXBBcmdzLmV4dHJhRGF0YV0pXSlcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kQ2NpcFJlYWRDYWxsXCIsIHRyYW5zYWN0aW9uOiB0eCB9KTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jY2FsbCh0eCwgYmxvY2tUYWcsIGF0dGVtcHQgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRDYWxsUmVzdWx0XCIsIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCksIHJlc3VsdCB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkQ2FsbEVycm9yXCIsIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCksIGVycm9yIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jICNjaGVja05ldHdvcmsocHJvbWlzZSkge1xyXG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXHJcbiAgICAgICAgICAgIHZhbHVlOiBwcm9taXNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgY2FsbChfdHgpIHtcclxuICAgICAgICBjb25zdCB7IHR4LCBibG9ja1RhZyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICB0eDogdGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KF90eCksXHJcbiAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhfdHguYmxvY2tUYWcpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NoZWNrTmV0d29yayh0aGlzLiNjYWxsKHR4LCBibG9ja1RhZywgX3R4LmVuYWJsZUNjaXBSZWFkID8gMCA6IC0xKSk7XHJcbiAgICB9XHJcbiAgICAvLyBBY2NvdW50XHJcbiAgICBhc3luYyAjZ2V0QWNjb3VudFZhbHVlKHJlcXVlc3QsIF9hZGRyZXNzLCBfYmxvY2tUYWcpIHtcclxuICAgICAgICBsZXQgYWRkcmVzcyA9IHRoaXMuX2dldEFkZHJlc3MoX2FkZHJlc3MpO1xyXG4gICAgICAgIGxldCBibG9ja1RhZyA9IHRoaXMuX2dldEJsb2NrVGFnKF9ibG9ja1RhZyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoYWRkcmVzcykgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIChibG9ja1RhZykgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgW2FkZHJlc3MsIGJsb2NrVGFnXSA9IGF3YWl0IFByb21pc2UuYWxsKFthZGRyZXNzLCBibG9ja1RhZ10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jY2hlY2tOZXR3b3JrKHRoaXMuI3BlcmZvcm0oT2JqZWN0LmFzc2lnbihyZXF1ZXN0LCB7IGFkZHJlc3MsIGJsb2NrVGFnIH0pKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRCYWxhbmNlKGFkZHJlc3MsIGJsb2NrVGFnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldEJpZ0ludChhd2FpdCB0aGlzLiNnZXRBY2NvdW50VmFsdWUoeyBtZXRob2Q6IFwiZ2V0QmFsYW5jZVwiIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSwgXCIlcmVzcG9uc2VcIik7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbkNvdW50KGFkZHJlc3MsIGJsb2NrVGFnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldE51bWJlcihhd2FpdCB0aGlzLiNnZXRBY2NvdW50VmFsdWUoeyBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSwgXCIlcmVzcG9uc2VcIik7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRDb2RlKGFkZHJlc3MsIGJsb2NrVGFnKSB7XHJcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoYXdhaXQgdGhpcy4jZ2V0QWNjb3VudFZhbHVlKHsgbWV0aG9kOiBcImdldENvZGVcIiB9LCBhZGRyZXNzLCBibG9ja1RhZykpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0U3RvcmFnZShhZGRyZXNzLCBfcG9zaXRpb24sIGJsb2NrVGFnKSB7XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRCaWdJbnQoX3Bvc2l0aW9uLCBcInBvc2l0aW9uXCIpO1xyXG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRTdG9yYWdlXCIsIHBvc2l0aW9uIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSk7XHJcbiAgICB9XHJcbiAgICAvLyBXcml0ZVxyXG4gICAgYXN5bmMgYnJvYWRjYXN0VHJhbnNhY3Rpb24oc2lnbmVkVHgpIHtcclxuICAgICAgICBjb25zdCB7IGJsb2NrTnVtYmVyLCBoYXNoLCBuZXR3b3JrIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XHJcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLmdldEJsb2NrTnVtYmVyKCksXHJcbiAgICAgICAgICAgIGhhc2g6IHRoaXMuX3BlcmZvcm0oe1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcImJyb2FkY2FzdFRyYW5zYWN0aW9uXCIsXHJcbiAgICAgICAgICAgICAgICBzaWduZWRUcmFuc2FjdGlvbjogc2lnbmVkVHhcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgdHggPSBUcmFuc2FjdGlvbi5mcm9tKHNpZ25lZFR4KTtcclxuICAgICAgICBpZiAodHguaGFzaCAhPT0gaGFzaCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ETzogdGhlIHJldHVybmVkIGhhc2ggZGlkIG5vdCBtYXRjaFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvblJlc3BvbnNlKHR4LCBuZXR3b3JrKS5yZXBsYWNlYWJsZVRyYW5zYWN0aW9uKGJsb2NrTnVtYmVyKTtcclxuICAgIH1cclxuICAgIGFzeW5jICNnZXRCbG9jayhibG9jaywgaW5jbHVkZVRyYW5zYWN0aW9ucykge1xyXG4gICAgICAgIC8vIEBUT0RPOiBBZGQgQ3VzdG9tQmxvY2tQbHVnaW4gY2hlY2tcclxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoYmxvY2ssIDMyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVyZm9ybSh7XHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZ2V0QmxvY2tcIiwgYmxvY2tIYXNoOiBibG9jaywgaW5jbHVkZVRyYW5zYWN0aW9uc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGJsb2NrVGFnID0gdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2spO1xyXG4gICAgICAgIGlmICh0eXBlb2YgKGJsb2NrVGFnKSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBibG9ja1RhZyA9IGF3YWl0IGJsb2NrVGFnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVyZm9ybSh7XHJcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRCbG9ja1wiLCBibG9ja1RhZywgaW5jbHVkZVRyYW5zYWN0aW9uc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gUXVlcmllc1xyXG4gICAgYXN5bmMgZ2V0QmxvY2soYmxvY2ssIHByZWZldGNoVHhzKSB7XHJcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXHJcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jZ2V0QmxvY2soYmxvY2ssICEhcHJlZmV0Y2hUeHMpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcEJsb2NrKHBhcmFtcywgbmV0d29yayk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbihoYXNoKSB7XHJcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXHJcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblwiLCBoYXNoIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uUmVzcG9uc2UocGFyYW1zLCBuZXR3b3JrKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKSB7XHJcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXHJcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgaGFzaCB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU29tZSBiYWNrZW5kcyBkaWQgbm90IGJhY2tmaWxsIHRoZSBlZmZlY3RpdmVHYXNQcmljZSBpbnRvIG9sZCB0cmFuc2FjdGlvbnNcclxuICAgICAgICAvLyBpbiB0aGUgcmVjZWlwdCwgc28gd2UgbG9vayBpdCB1cCBtYW51YWxseSBhbmQgaW5qZWN0IGl0LlxyXG4gICAgICAgIGlmIChwYXJhbXMuZ2FzUHJpY2UgPT0gbnVsbCAmJiBwYXJhbXMuZWZmZWN0aXZlR2FzUHJpY2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25cIiwgaGFzaCB9KTtcclxuICAgICAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlcG9ydCB0aGlzOyBjb3VsZCBub3QgZmluZCB0eCBvciBlZmZlY3RpdmVHYXNQcmljZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXJhbXMuZWZmZWN0aXZlR2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvblJlY2VpcHQocGFyYW1zLCBuZXR3b3JrKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVzdWx0KGhhc2gpIHtcclxuICAgICAgICBjb25zdCB7IHJlc3VsdCB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcclxuICAgICAgICAgICAgcmVzdWx0OiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uUmVzdWx0XCIsIGhhc2ggfSlcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICAvLyBCbG9vbS1maWx0ZXIgUXVlcmllc1xyXG4gICAgYXN5bmMgZ2V0TG9ncyhfZmlsdGVyKSB7XHJcbiAgICAgICAgbGV0IGZpbHRlciA9IHRoaXMuX2dldEZpbHRlcihfZmlsdGVyKTtcclxuICAgICAgICBpZiAoaXNQcm9taXNlKGZpbHRlcikpIHtcclxuICAgICAgICAgICAgZmlsdGVyID0gYXdhaXQgZmlsdGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcclxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldExvZ3NcIiwgZmlsdGVyIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5tYXAoKHApID0+IHRoaXMuX3dyYXBMb2cocCwgbmV0d29yaykpO1xyXG4gICAgfVxyXG4gICAgLy8gRU5TXHJcbiAgICBfZ2V0UHJvdmlkZXIoY2hhaW5JZCkge1xyXG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJwcm92aWRlciBjYW5ub3QgY29ubmVjdCB0byB0YXJnZXQgbmV0d29ya1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJfZ2V0UHJvdmlkZXIoKVwiXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRSZXNvbHZlcihuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IEVuc1Jlc29sdmVyLmZyb21OYW1lKHRoaXMsIG5hbWUpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0QXZhdGFyKG5hbWUpIHtcclxuICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IHRoaXMuZ2V0UmVzb2x2ZXIobmFtZSk7XHJcbiAgICAgICAgaWYgKHJlc29sdmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlci5nZXRBdmF0YXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBhc3luYyByZXNvbHZlTmFtZShuYW1lKSB7XHJcbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBhd2FpdCB0aGlzLmdldFJlc29sdmVyKG5hbWUpO1xyXG4gICAgICAgIGlmIChyZXNvbHZlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZXIuZ2V0QWRkcmVzcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGFzeW5jIGxvb2t1cEFkZHJlc3MoYWRkcmVzcykge1xyXG4gICAgICAgIGFkZHJlc3MgPSBnZXRBZGRyZXNzKGFkZHJlc3MpO1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSBuYW1laGFzaChhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpICsgXCIuYWRkci5yZXZlcnNlXCIpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuc0FkZHIgPSBhd2FpdCBFbnNSZXNvbHZlci5nZXRFbnNBZGRyZXNzKHRoaXMpO1xyXG4gICAgICAgICAgICBjb25zdCBlbnNDb250cmFjdCA9IG5ldyBDb250cmFjdChlbnNBZGRyLCBbXHJcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIHJlc29sdmVyKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIlxyXG4gICAgICAgICAgICBdLCB0aGlzKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBhd2FpdCBlbnNDb250cmFjdC5yZXNvbHZlcihub2RlKTtcclxuICAgICAgICAgICAgaWYgKHJlc29sdmVyID09IG51bGwgfHwgcmVzb2x2ZXIgPT09IFplcm9BZGRyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlckNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KHJlc29sdmVyLCBbXHJcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIG5hbWUoYnl0ZXMzMikgdmlldyByZXR1cm5zIChzdHJpbmcpXCJcclxuICAgICAgICAgICAgXSwgdGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhd2FpdCByZXNvbHZlckNvbnRyYWN0Lm5hbWUobm9kZSk7XHJcbiAgICAgICAgICAgIC8vIEZhaWxlZCBmb3J3YXJkIHJlc29sdXRpb25cclxuICAgICAgICAgICAgY29uc3QgY2hlY2sgPSBhd2FpdCB0aGlzLnJlc29sdmVOYW1lKG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoY2hlY2sgIT09IGFkZHJlc3MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgLy8gTm8gZGF0YSB3YXMgcmV0dXJuZWQgZnJvbSB0aGUgcmVzb2x2ZXJcclxuICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQkFEX0RBVEFcIikgJiYgZXJyb3IudmFsdWUgPT09IFwiMHhcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU29tZXRoaW5nIHJlZXJ0ZWRcclxuICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGFzeW5jIHdhaXRGb3JUcmFuc2FjdGlvbihoYXNoLCBfY29uZmlybXMsIHRpbWVvdXQpIHtcclxuICAgICAgICBjb25zdCBjb25maXJtcyA9IChfY29uZmlybXMgIT0gbnVsbCkgPyBfY29uZmlybXMgOiAxO1xyXG4gICAgICAgIGlmIChjb25maXJtcyA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB0aW1lciA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKGFzeW5jIChibG9ja051bWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyICsgMSA+PSBjb25maXJtcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZWNlaXB0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5vZmYoXCJibG9ja1wiLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRUVFXCIsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMub25jZShcImJsb2NrXCIsIGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYoXCJibG9ja1wiLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcInRpbWVvdXRcIiwgXCJUSU1FT1VUXCIsIHsgcmVhc29uOiBcInRpbWVvdXRcIiB9KSk7XHJcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsaXN0ZW5lcihhd2FpdCB0aGlzLmdldEJsb2NrTnVtYmVyKCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgd2FpdEZvckJsb2NrKGJsb2NrVGFnKSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIiwgXCJOT1RfSU1QTEVNRU5URURcIiwge1xyXG4gICAgICAgICAgICBvcGVyYXRpb246IFwid2FpdEZvckJsb2NrXCJcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENsZWFyIGEgdGltZXIgY3JlYXRlZCB1c2luZyB0aGUgW1tfc2V0VGltZW91dF1dIG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgX2NsZWFyVGltZW91dCh0aW1lcklkKSB7XHJcbiAgICAgICAgY29uc3QgdGltZXIgPSB0aGlzLiN0aW1lcnMuZ2V0KHRpbWVySWQpO1xyXG4gICAgICAgIGlmICghdGltZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGltZXIudGltZXIpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyLnRpbWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jdGltZXJzLmRlbGV0ZSh0aW1lcklkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZSBhIHRpbWVyIHRoYXQgd2lsbCBleGVjdXRlICUlZnVuYyUlIGFmdGVyIGF0IGxlYXN0ICUldGltZW91dCUlXHJcbiAgICAgKiAgKGluIG1zKS4gSWYgJSV0aW1lb3V0JSUgaXMgdW5zcGVjaWZpZWQsIHRoZW4gJSVmdW5jJSUgd2lsbCBleGVjdXRlXHJcbiAgICAgKiAgaW4gdGhlIG5leHQgZXZlbnQgbG9vcC5cclxuICAgICAqXHJcbiAgICAgKiAgW1BhdXNpbmddKEFic3RyYWN0UHJvdmlkZXItcGF1c2VkKSB0aGUgcHJvdmlkZXIgd2lsbCBwYXVzZSBhbnlcclxuICAgICAqICBhc3NvY2lhdGVkIHRpbWVycy5cclxuICAgICAqL1xyXG4gICAgX3NldFRpbWVvdXQoX2Z1bmMsIHRpbWVvdXQpIHtcclxuICAgICAgICBpZiAodGltZW91dCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0aW1lcklkID0gdGhpcy4jbmV4dFRpbWVyKys7XHJcbiAgICAgICAgY29uc3QgZnVuYyA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy4jdGltZXJzLmRlbGV0ZSh0aW1lcklkKTtcclxuICAgICAgICAgICAgX2Z1bmMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xyXG4gICAgICAgICAgICB0aGlzLiN0aW1lcnMuc2V0KHRpbWVySWQsIHsgdGltZXI6IG51bGwsIGZ1bmMsIHRpbWU6IHRpbWVvdXQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoZnVuYywgdGltZW91dCk7XHJcbiAgICAgICAgICAgIHRoaXMuI3RpbWVycy5zZXQodGltZXJJZCwgeyB0aW1lciwgZnVuYywgdGltZTogZ2V0VGltZSgpIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGltZXJJZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFBlcmZvcm0gJSVmdW5jJSUgb24gZWFjaCBzdWJzY3JpYmVyLlxyXG4gICAgICovXHJcbiAgICBfZm9yRWFjaFN1YnNjcmliZXIoZnVuYykge1xyXG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuI3N1YnMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgZnVuYyhzdWIuc3Vic2NyaWJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gY3VzdG9taXplIHN1YnNjcmlwdGlvblxyXG4gICAgICogIGltcGxlbWVudGF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgX2dldFN1YnNjcmliZXIoc3ViKSB7XHJcbiAgICAgICAgc3dpdGNoIChzdWIudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcclxuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJuZXR3b3JrXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVubWFuYWdlZFN1YnNjcmliZXIoc3ViLnR5cGUpO1xyXG4gICAgICAgICAgICBjYXNlIFwiYmxvY2tcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IG5ldyBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5wb2xsaW5nSW50ZXJ2YWwgPSB0aGlzLnBvbGxpbmdJbnRlcnZhbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJzYWZlXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJmaW5hbGl6ZWRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9sbGluZ0Jsb2NrVGFnU3Vic2NyaWJlcih0aGlzLCBzdWIudHlwZSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xyXG4gICAgICAgICAgICBjYXNlIFwidHJhbnNhY3Rpb25cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcih0aGlzLCBzdWIuaGFzaCk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJvcnBoYW5cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9sbGluZ09ycGhhblN1YnNjcmliZXIodGhpcywgc3ViLmZpbHRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXZlbnQ6ICR7c3ViLnR5cGV9YCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBJZiBhIFtbU3Vic2NyaWJlcl1dIGZhaWxzIGFuZCBuZWVkcyB0byByZXBsYWNlIGl0c2VsZiwgdGhpc1xyXG4gICAgICogIG1ldGhvZCBtYXkgYmUgdXNlZC5cclxuICAgICAqXHJcbiAgICAgKiAgRm9yIGV4YW1wbGUsIHRoaXMgaXMgdXNlZCBmb3IgcHJvdmlkZXJzIHdoZW4gdXNpbmcgdGhlXHJcbiAgICAgKiAgYGBldGhfZ2V0RmlsdGVyQ2hhbmdlc2BgIG1ldGhvZCwgd2hpY2ggY2FuIHJldHVybiBudWxsIGlmIHN0YXRlXHJcbiAgICAgKiAgZmlsdGVycyBhcmUgbm90IHN1cHBvcnRlZCBieSB0aGUgYmFja2VuZCwgYWxsb3dpbmcgdGhlIFN1YnNjcmliZXJcclxuICAgICAqICB0byBzd2FwIGluIGEgW1tQb2xsaW5nRXZlbnRTdWJzY3JpYmVyXV0uXHJcbiAgICAgKi9cclxuICAgIF9yZWNvdmVyU3Vic2NyaWJlcihvbGRTdWIsIG5ld1N1Yikge1xyXG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuI3N1YnMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgaWYgKHN1Yi5zdWJzY3JpYmVyID09PSBvbGRTdWIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyID0gbmV3U3ViO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1Yi5zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U3ViLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1N1Yi5wYXVzZSh0aGlzLiNwYXVzZWRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jICNoYXNTdWIoZXZlbnQsIGVtaXRBcmdzKSB7XHJcbiAgICAgICAgbGV0IHN1YiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvbihldmVudCwgdGhpcyk7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBhIGxvZyB0aGF0IGlzIHJlbW92aW5nIGFuIGV4aXN0aW5nIGxvZzsgd2UgYWN0dWFsbHkgd2FudFxyXG4gICAgICAgIC8vIHRvIGVtaXQgYW4gb3JwaGFuIGV2ZW50IGZvciB0aGUgcmVtb3ZlZCBsb2dcclxuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwiZXZlbnRcIiAmJiBlbWl0QXJncyAmJiBlbWl0QXJncy5sZW5ndGggPiAwICYmIGVtaXRBcmdzWzBdLnJlbW92ZWQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgc3ViID0gYXdhaXQgZ2V0U3Vic2NyaXB0aW9uKHsgb3JwaGFuOiBcImRyb3AtbG9nXCIsIGxvZzogZW1pdEFyZ3NbMF0gfSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLiNzdWJzLmdldChzdWIudGFnKSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgI2dldFN1YihldmVudCkge1xyXG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvbihldmVudCwgdGhpcyk7XHJcbiAgICAgICAgLy8gUHJldmVudCB0YW1wZXJpbmcgd2l0aCBvdXIgdGFnIGluIGFueSBzdWJjbGFzcycgX2dldFN1YnNjcmliZXJcclxuICAgICAgICBjb25zdCB0YWcgPSBzdWJzY3JpcHRpb24udGFnO1xyXG4gICAgICAgIGxldCBzdWIgPSB0aGlzLiNzdWJzLmdldCh0YWcpO1xyXG4gICAgICAgIGlmICghc3ViKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSB0aGlzLl9nZXRTdWJzY3JpYmVyKHN1YnNjcmlwdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NhYmxlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICAgICAgY29uc3QgbmFtZU1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgc3ViID0geyBzdWJzY3JpYmVyLCB0YWcsIGFkZHJlc3NhYmxlTWFwLCBuYW1lTWFwLCBzdGFydGVkOiBmYWxzZSwgbGlzdGVuZXJzOiBbXSB9O1xyXG4gICAgICAgICAgICB0aGlzLiNzdWJzLnNldCh0YWcsIHN1Yik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdWI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbihldmVudCwgbGlzdGVuZXIpIHtcclxuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNnZXRTdWIoZXZlbnQpO1xyXG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiBmYWxzZSB9KTtcclxuICAgICAgICBpZiAoIXN1Yi5zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIHN1Yi5zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnBhdXNlKHRoaXMuI3BhdXNlZFN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGFzeW5jIG9uY2UoZXZlbnQsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jZ2V0U3ViKGV2ZW50KTtcclxuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogdHJ1ZSB9KTtcclxuICAgICAgICBpZiAoIXN1Yi5zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIHN1Yi5zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnBhdXNlKHRoaXMuI3BhdXNlZFN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGFzeW5jIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcclxuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQsIGFyZ3MpO1xyXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vdCBzdWJzY3JpcHRpb24gb3IgaWYgYSByZWNlbnQgZW1pdCByZW1vdmVkXHJcbiAgICAgICAgLy8gdGhlIGxhc3Qgb2YgdGhlbSAod2hpY2ggYWxzbyBkZWxldGVkIHRoZSBzdWIpIGRvIG5vdGhpbmdcclxuICAgICAgICBpZiAoIXN1YiB8fCBzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDtcclxuICAgICAgICBjb25zdCBjb3VudCA9IHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xyXG4gICAgICAgIHN1Yi5saXN0ZW5lcnMgPSBzdWIubGlzdGVuZXJzLmZpbHRlcigoeyBsaXN0ZW5lciwgb25jZSB9KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBuZXcgRXZlbnRQYXlsb2FkKHRoaXMsIChvbmNlID8gbnVsbCA6IGxpc3RlbmVyKSwgZXZlbnQpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCAuLi5hcmdzLCBwYXlsb2FkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgICAgICAgICByZXR1cm4gIW9uY2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHN1Yi50YWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKGNvdW50ID4gMCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCk7XHJcbiAgICAgICAgICAgIGlmICghc3ViKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3ViLmxpc3RlbmVycy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0b3RhbCA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCB7IGxpc3RlbmVycyB9IG9mIHRoaXMuI3N1YnMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgdG90YWwgKz0gbGlzdGVuZXJzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgbGlzdGVuZXJzKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCk7XHJcbiAgICAgICAgICAgIGlmICghc3ViKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQobGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xyXG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCk7XHJcbiAgICAgICAgaWYgKCFzdWIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKS5pbmRleE9mKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgIHN1Yi5saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWxpc3RlbmVyIHx8IHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHN1Yi50YWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGFzeW5jIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xyXG4gICAgICAgIGlmIChldmVudCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHRhZywgc3RhcnRlZCwgc3Vic2NyaWJlciB9ID0gYXdhaXQgdGhpcy4jZ2V0U3ViKGV2ZW50KTtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFt0YWcsIHsgc3RhcnRlZCwgc3Vic2NyaWJlciB9XSBvZiB0aGlzLiNzdWJzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy4jc3Vicy5kZWxldGUodGFnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8vIEFsaWFzIGZvciBcIm9uXCJcclxuICAgIGFzeW5jIGFkZExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9uKGV2ZW50LCBsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICAvLyBBbGlhcyBmb3IgXCJvZmZcIlxyXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBJZiB0aGlzIHByb3ZpZGVyIGhhcyBiZWVuIGRlc3Ryb3llZCB1c2luZyB0aGUgW1tkZXN0cm95XV0gbWV0aG9kLlxyXG4gICAgICpcclxuICAgICAqICBPbmNlIGRlc3Ryb3llZCwgYWxsIHJlc291cmNlcyBhcmUgcmVjbGFpbWVkLCBpbnRlcm5hbCBldmVudCBsb29wc1xyXG4gICAgICogIGFuZCB0aW1lcnMgYXJlIGNsZWFuZWQgdXAgYW5kIG5vIGZ1cnRoZXIgcmVxdWVzdHMgbWF5IGJlIHNlbnQgdG9cclxuICAgICAqICB0aGUgcHJvdmlkZXIuXHJcbiAgICAgKi9cclxuICAgIGdldCBkZXN0cm95ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Rlc3Ryb3llZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSB1c2UgdGhpcyB0byBzaHV0ZG93biBhbnkgc29ja2V0cyBvciByZWxlYXNlIHRoZWlyXHJcbiAgICAgKiAgcmVzb3VyY2VzIGFuZCByZWplY3QgYW55IHBlbmRpbmcgcmVxdWVzdHMuXHJcbiAgICAgKlxyXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIGNhbGwgYGBzdXBlci5kZXN0cm95KClgYC5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICAvLyBTdG9wIGFsbCBsaXN0ZW5lcnNcclxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG4gICAgICAgIC8vIFNodXQgZG93biBhbGwgdGllbXJzXHJcbiAgICAgICAgZm9yIChjb25zdCB0aW1lcklkIG9mIHRoaXMuI3RpbWVycy5rZXlzKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiNkZXN0cm95ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgV2hldGhlciB0aGUgcHJvdmlkZXIgaXMgY3VycmVudGx5IHBhdXNlZC5cclxuICAgICAqXHJcbiAgICAgKiAgQSBwYXVzZWQgcHJvdmlkZXIgd2lsbCBub3QgZW1pdCBhbnkgZXZlbnRzLCBhbmQgZ2VuZXJhbGx5IHNob3VsZFxyXG4gICAgICogIG5vdCBtYWtlIGFueSByZXF1ZXN0cyB0byB0aGUgbmV0d29yaywgYnV0IHRoYXQgaXMgdXAgdG8gc3ViLWNsYXNzZXNcclxuICAgICAqICB0byBtYW5hZ2UuXHJcbiAgICAgKlxyXG4gICAgICogIFNldHRpbmcgYGBwYXVzZWQgPSB0cnVlYGAgaXMgaWRlbnRpY2FsIHRvIGNhbGxpbmcgYGAucGF1c2UoZmFsc2UpYGAsXHJcbiAgICAgKiAgd2hpY2ggd2lsbCBidWZmZXIgYW55IGV2ZW50cyB0aGF0IG9jY3VyIHdoaWxlIHBhdXNlZCB1bnRpbCB0aGVcclxuICAgICAqICBwcm92aWRlciBpcyB1bnBhdXNlZC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHBhdXNlZCgpIHsgcmV0dXJuICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKTsgfVxyXG4gICAgc2V0IHBhdXNlZChwYXVzZSkge1xyXG4gICAgICAgIGlmICghIXBhdXNlID09PSB0aGlzLnBhdXNlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc3VtZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wYXVzZShmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUGF1c2UgdGhlIHByb3ZpZGVyLiBJZiAlJWRyb3BXaGlsZVBhdXNlZCUlLCBhbnkgZXZlbnRzIHRoYXQgb2NjdXJcclxuICAgICAqICB3aGlsZSBwYXVzZWQgYXJlIGRyb3BwZWQsIG90aGVyd2lzZSBhbGwgZXZlbnRzIHdpbGwgYmUgZW1pdHRlZCBvbmNlXHJcbiAgICAgKiAgdGhlIHByb3ZpZGVyIGlzIHVucGF1c2VkLlxyXG4gICAgICovXHJcbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHtcclxuICAgICAgICB0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPSAtMTtcclxuICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgPT0gISFkcm9wV2hpbGVQYXVzZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY2Fubm90IGNoYW5nZSBwYXVzZSB0eXBlOyByZXN1bWUgZmlyc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInBhdXNlXCJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzKSA9PiBzLnBhdXNlKGRyb3BXaGlsZVBhdXNlZCkpO1xyXG4gICAgICAgIHRoaXMuI3BhdXNlZFN0YXRlID0gISFkcm9wV2hpbGVQYXVzZWQ7XHJcbiAgICAgICAgZm9yIChjb25zdCB0aW1lciBvZiB0aGlzLiN0aW1lcnMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIHRpbWVyXHJcbiAgICAgICAgICAgIGlmICh0aW1lci50aW1lcikge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyLnRpbWVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZW1haW5pbmcgdGltZSBuZWVkZWQgZm9yIHdoZW4gd2UgYmVjb21lIHVucGF1c2VkXHJcbiAgICAgICAgICAgIHRpbWVyLnRpbWUgPSBnZXRUaW1lKCkgLSB0aW1lci50aW1lO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc3VtZSB0aGUgcHJvdmlkZXIuXHJcbiAgICAgKi9cclxuICAgIHJlc3VtZSgpIHtcclxuICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzKSA9PiBzLnJlc3VtZSgpKTtcclxuICAgICAgICB0aGlzLiNwYXVzZWRTdGF0ZSA9IG51bGw7XHJcbiAgICAgICAgZm9yIChjb25zdCB0aW1lciBvZiB0aGlzLiN0aW1lcnMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgLy8gUmVtYWluaW5nIHRpbWUgd2hlbiB3ZSB3ZXJlIHBhdXNlZFxyXG4gICAgICAgICAgICBsZXQgdGltZW91dCA9IHRpbWVyLnRpbWU7XHJcbiAgICAgICAgICAgIGlmICh0aW1lb3V0IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGltZW91dCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU3RhcnQgdGltZSAoaW4gY2F1c2UgcGF1c2VkLCBzbyB3ZSBjb24gY29tcHV0ZSByZW1haW5pbmYgdGltZSlcclxuICAgICAgICAgICAgdGltZXIudGltZSA9IGdldFRpbWUoKTtcclxuICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHRpbWVyXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGltZXIuZnVuYywgdGltZW91dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIF9wYXJzZVN0cmluZyhyZXN1bHQsIHN0YXJ0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGJ5dGVzID0gX3BhcnNlQnl0ZXMocmVzdWx0LCBzdGFydCk7XHJcbiAgICAgICAgaWYgKGJ5dGVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcoYnl0ZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBfcGFyc2VCeXRlcyhyZXN1bHQsIHN0YXJ0KSB7XHJcbiAgICBpZiAocmVzdWx0ID09PSBcIjB4XCIpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZ2V0TnVtYmVyKGRhdGFTbGljZShyZXN1bHQsIHN0YXJ0LCBzdGFydCArIDMyKSk7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZ2V0TnVtYmVyKGRhdGFTbGljZShyZXN1bHQsIG9mZnNldCwgb2Zmc2V0ICsgMzIpKTtcclxuICAgICAgICByZXR1cm4gZGF0YVNsaWNlKHJlc3VsdCwgb2Zmc2V0ICsgMzIsIG9mZnNldCArIDMyICsgbGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBudW1QYWQodmFsdWUpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHRvQmVBcnJheSh2YWx1ZSk7XHJcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDMyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJuYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGFkZGVkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xyXG4gICAgcGFkZGVkLnNldChyZXN1bHQsIDMyIC0gcmVzdWx0Lmxlbmd0aCk7XHJcbiAgICByZXR1cm4gcGFkZGVkO1xyXG59XHJcbmZ1bmN0aW9uIGJ5dGVzUGFkKHZhbHVlKSB7XHJcbiAgICBpZiAoKHZhbHVlLmxlbmd0aCAlIDMyKSA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbCh2YWx1ZS5sZW5ndGggLyAzMikgKiAzMik7XHJcbiAgICByZXN1bHQuc2V0KHZhbHVlKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuY29uc3QgZW1wdHkgPSBuZXcgVWludDhBcnJheShbXSk7XHJcbi8vIEFCSSBFbmNvZGVzIGEgc2VyaWVzIG9mIChieXRlcywgYnl0ZXMsIC4uLilcclxuZnVuY3Rpb24gZW5jb2RlQnl0ZXMoZGF0YXMpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgbGV0IGJ5dGVDb3VudCA9IDA7XHJcbiAgICAvLyBBZGQgcGxhY2UtaG9sZGVycyBmb3IgcG9pbnRlcnMgYXMgd2UgYWRkIGl0ZW1zXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2goZW1wdHkpO1xyXG4gICAgICAgIGJ5dGVDb3VudCArPSAzMjtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoZGF0YXNbaV0pO1xyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYnl0ZXMgb2Zmc2V0XHJcbiAgICAgICAgcmVzdWx0W2ldID0gbnVtUGFkKGJ5dGVDb3VudCk7XHJcbiAgICAgICAgLy8gVGhlIGxlbmd0aCBhbmQgcGFkZGVkIHZhbHVlIG9mIGRhdGFcclxuICAgICAgICByZXN1bHQucHVzaChudW1QYWQoZGF0YS5sZW5ndGgpKTtcclxuICAgICAgICByZXN1bHQucHVzaChieXRlc1BhZChkYXRhKSk7XHJcbiAgICAgICAgYnl0ZUNvdW50ICs9IDMyICsgTWF0aC5jZWlsKGRhdGEubGVuZ3RoIC8gMzIpICogMzI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29uY2F0KHJlc3VsdCk7XHJcbn1cclxuY29uc3QgemVyb3MgPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xyXG5mdW5jdGlvbiBwYXJzZU9mZmNoYWluTG9va3VwKGRhdGEpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgICBzZW5kZXI6IFwiXCIsIHVybHM6IFtdLCBjYWxsZGF0YTogXCJcIiwgc2VsZWN0b3I6IFwiXCIsIGV4dHJhRGF0YTogXCJcIiwgZXJyb3JBcmdzOiBbXVxyXG4gICAgfTtcclxuICAgIGFzc2VydChkYXRhTGVuZ3RoKGRhdGEpID49IDUgKiAzMiwgXCJpbnN1ZmZpY2llbnQgT2ZmY2hhaW5Mb29rdXAgZGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcclxuICAgICAgICByZWFzb246IFwiaW5zdWZmaWNpZW50IE9mZmNoYWluTG9va3VwIGRhdGFcIlxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBzZW5kZXIgPSBkYXRhU2xpY2UoZGF0YSwgMCwgMzIpO1xyXG4gICAgYXNzZXJ0KGRhdGFTbGljZShzZW5kZXIsIDAsIDEyKSA9PT0gZGF0YVNsaWNlKHplcm9zLCAwLCAxMiksIFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBzZW5kZXJcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XHJcbiAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgc2VuZGVyXCJcclxuICAgIH0pO1xyXG4gICAgcmVzdWx0LnNlbmRlciA9IGRhdGFTbGljZShzZW5kZXIsIDEyKTtcclxuICAgIC8vIFJlYWQgdGhlIFVSTHMgZnJvbSB0aGUgcmVzcG9uc2VcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgdXJscyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHVybHNPZmZzZXQgPSBnZXROdW1iZXIoZGF0YVNsaWNlKGRhdGEsIDMyLCA2NCkpO1xyXG4gICAgICAgIGNvbnN0IHVybHNMZW5ndGggPSBnZXROdW1iZXIoZGF0YVNsaWNlKGRhdGEsIHVybHNPZmZzZXQsIHVybHNPZmZzZXQgKyAzMikpO1xyXG4gICAgICAgIGNvbnN0IHVybHNEYXRhID0gZGF0YVNsaWNlKGRhdGEsIHVybHNPZmZzZXQgKyAzMik7XHJcbiAgICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCB1cmxzTGVuZ3RoOyB1KyspIHtcclxuICAgICAgICAgICAgY29uc3QgdXJsID0gX3BhcnNlU3RyaW5nKHVybHNEYXRhLCB1ICogMzIpO1xyXG4gICAgICAgICAgICBpZiAodXJsID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFib3J0XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVybHMucHVzaCh1cmwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQudXJscyA9IHVybHM7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCB1cmxzXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xyXG4gICAgICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCB1cmxzXCJcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIEdldCB0aGUgQ0NJUCBjYWxsZGF0YSB0byBmb3J3YXJkXHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGNhbGxkYXRhID0gX3BhcnNlQnl0ZXMoZGF0YSwgNjQpO1xyXG4gICAgICAgIGlmIChjYWxsZGF0YSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFib3J0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQuY2FsbGRhdGEgPSBjYWxsZGF0YTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxkYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xyXG4gICAgICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBjYWxsZGF0YVwiXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBHZXQgdGhlIGNhbGxiYWNrU2VsZWN0b3IgKGJ5dGVzNClcclxuICAgIGFzc2VydChkYXRhU2xpY2UoZGF0YSwgMTAwLCAxMjgpID09PSBkYXRhU2xpY2UoemVyb3MsIDAsIDI4KSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxiYWFja1NlbGVjdG9yXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xyXG4gICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxiYWFja1NlbGVjdG9yXCJcclxuICAgIH0pO1xyXG4gICAgcmVzdWx0LnNlbGVjdG9yID0gZGF0YVNsaWNlKGRhdGEsIDk2LCAxMDApO1xyXG4gICAgLy8gR2V0IHRoZSBleHRyYSBkYXRhIHRvIHNlbmQgYmFjayB0byB0aGUgY29udHJhY3QgYXMgY29udGV4dFxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBleHRyYURhdGEgPSBfcGFyc2VCeXRlcyhkYXRhLCAxMjgpO1xyXG4gICAgICAgIGlmIChleHRyYURhdGEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhYm9ydFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LmV4dHJhRGF0YSA9IGV4dHJhRGF0YTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGV4dHJhRGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcclxuICAgICAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgZXh0cmFEYXRhXCJcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlc3VsdC5lcnJvckFyZ3MgPSBcInNlbmRlcix1cmxzLGNhbGxkYXRhLHNlbGVjdG9yLGV4dHJhRGF0YVwiLnNwbGl0KC8sLykubWFwKChrKSA9PiByZXN1bHRba10pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/abstract-provider.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/abstract-signer.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/abstract-signer.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractSigner: () => (/* binding */ AbstractSigner),\n/* harmony export */   VoidSigner: () => (/* binding */ VoidSigner)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transaction/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/**\r\n *  Generally the [[Wallet]] and [[JsonRpcSigner]] and their sub-classes\r\n *  are sufficent for most developers, but this is provided to\r\n *  fascilitate more complex Signers.\r\n *\r\n *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]\r\n */\r\n\r\n\r\n\r\n\r\nfunction checkProvider(signer, operation) {\r\n    if (signer.provider) {\r\n        return signer.provider;\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"missing provider\", \"UNSUPPORTED_OPERATION\", { operation });\r\n}\r\nasync function populate(signer, tx) {\r\n    let pop = (0,_provider_js__WEBPACK_IMPORTED_MODULE_1__.copyRequest)(tx);\r\n    if (pop.to != null) {\r\n        pop.to = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(pop.to, signer);\r\n    }\r\n    if (pop.from != null) {\r\n        const from = pop.from;\r\n        pop.from = Promise.all([\r\n            signer.getAddress(),\r\n            (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(from, signer)\r\n        ]).then(([address, from]) => {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(address.toLowerCase() === from.toLowerCase(), \"transaction from mismatch\", \"tx.from\", from);\r\n            return address;\r\n        });\r\n    }\r\n    else {\r\n        pop.from = signer.getAddress();\r\n    }\r\n    return await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)(pop);\r\n}\r\n/**\r\n *  An **AbstractSigner** includes most of teh functionality required\r\n *  to get a [[Signer]] working as expected, but requires a few\r\n *  Signer-specific methods be overridden.\r\n *\r\n */\r\nclass AbstractSigner {\r\n    /**\r\n     *  The provider this signer is connected to.\r\n     */\r\n    provider;\r\n    /**\r\n     *  Creates a new Signer connected to %%provider%%.\r\n     */\r\n    constructor(provider) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { provider: (provider || null) });\r\n    }\r\n    async getNonce(blockTag) {\r\n        return checkProvider(this, \"getTransactionCount\").getTransactionCount(await this.getAddress(), blockTag);\r\n    }\r\n    async populateCall(tx) {\r\n        const pop = await populate(this, tx);\r\n        return pop;\r\n    }\r\n    async populateTransaction(tx) {\r\n        const provider = checkProvider(this, \"populateTransaction\");\r\n        const pop = await populate(this, tx);\r\n        if (pop.nonce == null) {\r\n            pop.nonce = await this.getNonce(\"pending\");\r\n        }\r\n        if (pop.gasLimit == null) {\r\n            pop.gasLimit = await this.estimateGas(pop);\r\n        }\r\n        // Populate the chain ID\r\n        const network = await (this.provider).getNetwork();\r\n        if (pop.chainId != null) {\r\n            const chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(pop.chainId);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(chainId === network.chainId, \"transaction chainId mismatch\", \"tx.chainId\", tx.chainId);\r\n        }\r\n        else {\r\n            pop.chainId = network.chainId;\r\n        }\r\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\r\n        const hasEip1559 = (pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null);\r\n        if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"eip-1559 transaction do not support gasPrice\", \"tx\", tx);\r\n        }\r\n        else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"tx\", tx);\r\n        }\r\n        if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {\r\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\r\n            pop.type = 2;\r\n        }\r\n        else if (pop.type === 0 || pop.type === 1) {\r\n            // Explicit Legacy or EIP-2930 transaction\r\n            // We need to get fee data to determine things\r\n            const feeData = await provider.getFeeData();\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(feeData.gasPrice != null, \"network does not support gasPrice\", \"UNSUPPORTED_OPERATION\", {\r\n                operation: \"getGasPrice\"\r\n            });\r\n            // Populate missing gasPrice\r\n            if (pop.gasPrice == null) {\r\n                pop.gasPrice = feeData.gasPrice;\r\n            }\r\n        }\r\n        else {\r\n            // We need to get fee data to determine things\r\n            const feeData = await provider.getFeeData();\r\n            if (pop.type == null) {\r\n                // We need to auto-detect the intended type of this transaction...\r\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\r\n                    // The network supports EIP-1559!\r\n                    // Upgrade transaction from null to eip-1559\r\n                    if (pop.authorizationList && pop.authorizationList.length) {\r\n                        pop.type = 4;\r\n                    }\r\n                    else {\r\n                        pop.type = 2;\r\n                    }\r\n                    if (pop.gasPrice != null) {\r\n                        // Using legacy gasPrice property on an eip-1559 network,\r\n                        // so use gasPrice as both fee properties\r\n                        const gasPrice = pop.gasPrice;\r\n                        delete pop.gasPrice;\r\n                        pop.maxFeePerGas = gasPrice;\r\n                        pop.maxPriorityFeePerGas = gasPrice;\r\n                    }\r\n                    else {\r\n                        // Populate missing fee data\r\n                        if (pop.maxFeePerGas == null) {\r\n                            pop.maxFeePerGas = feeData.maxFeePerGas;\r\n                        }\r\n                        if (pop.maxPriorityFeePerGas == null) {\r\n                            pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\r\n                        }\r\n                    }\r\n                }\r\n                else if (feeData.gasPrice != null) {\r\n                    // Network doesn't support EIP-1559...\r\n                    // ...but they are trying to use EIP-1559 properties\r\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!hasEip1559, \"network does not support EIP-1559\", \"UNSUPPORTED_OPERATION\", {\r\n                        operation: \"populateTransaction\"\r\n                    });\r\n                    // Populate missing fee data\r\n                    if (pop.gasPrice == null) {\r\n                        pop.gasPrice = feeData.gasPrice;\r\n                    }\r\n                    // Explicitly set untyped transaction to legacy\r\n                    // @TODO: Maybe this shold allow type 1?\r\n                    pop.type = 0;\r\n                }\r\n                else {\r\n                    // getFeeData has failed us.\r\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"failed to get consistent fee data\", \"UNSUPPORTED_OPERATION\", {\r\n                        operation: \"signer.getFeeData\"\r\n                    });\r\n                }\r\n            }\r\n            else if (pop.type === 2 || pop.type === 3 || pop.type === 4) {\r\n                // Explicitly using EIP-1559 or EIP-4844\r\n                // Populate missing fee data\r\n                if (pop.maxFeePerGas == null) {\r\n                    pop.maxFeePerGas = feeData.maxFeePerGas;\r\n                }\r\n                if (pop.maxPriorityFeePerGas == null) {\r\n                    pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\r\n                }\r\n            }\r\n        }\r\n        //@TOOD: Don't await all over the place; save them up for\r\n        // the end for better batching\r\n        return await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)(pop);\r\n    }\r\n    async populateAuthorization(_auth) {\r\n        const auth = Object.assign({}, _auth);\r\n        // Add a chain ID if not explicitly set to 0\r\n        if (auth.chainId == null) {\r\n            auth.chainId = (await checkProvider(this, \"getNetwork\").getNetwork()).chainId;\r\n        }\r\n        // @TODO: Take chain ID into account when populating noce?\r\n        if (auth.nonce == null) {\r\n            auth.nonce = await this.getNonce();\r\n        }\r\n        return auth;\r\n    }\r\n    async estimateGas(tx) {\r\n        return checkProvider(this, \"estimateGas\").estimateGas(await this.populateCall(tx));\r\n    }\r\n    async call(tx) {\r\n        return checkProvider(this, \"call\").call(await this.populateCall(tx));\r\n    }\r\n    async resolveName(name) {\r\n        const provider = checkProvider(this, \"resolveName\");\r\n        return await provider.resolveName(name);\r\n    }\r\n    async sendTransaction(tx) {\r\n        const provider = checkProvider(this, \"sendTransaction\");\r\n        const pop = await this.populateTransaction(tx);\r\n        delete pop.from;\r\n        const txObj = _transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.Transaction.from(pop);\r\n        return await provider.broadcastTransaction(await this.signTransaction(txObj));\r\n    }\r\n    // @TODO: in v7 move this to be abstract\r\n    authorize(authorization) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"authorization not implemented for this signer\", \"UNSUPPORTED_OPERATION\", { operation: \"authorize\" });\r\n    }\r\n}\r\n/**\r\n *  A **VoidSigner** is a class deisgned to allow an address to be used\r\n *  in any API which accepts a Signer, but for which there are no\r\n *  credentials available to perform any actual signing.\r\n *\r\n *  This for example allow impersonating an account for the purpose of\r\n *  static calls or estimating gas, but does not allow sending transactions.\r\n */\r\nclass VoidSigner extends AbstractSigner {\r\n    /**\r\n     *  The signer address.\r\n     */\r\n    address;\r\n    /**\r\n     *  Creates a new **VoidSigner** with %%address%% attached to\r\n     *  %%provider%%.\r\n     */\r\n    constructor(address, provider) {\r\n        super(provider);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { address });\r\n    }\r\n    async getAddress() { return this.address; }\r\n    connect(provider) {\r\n        return new VoidSigner(this.address, provider);\r\n    }\r\n    #throwUnsupported(suffix, operation) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `VoidSigner cannot sign ${suffix}`, \"UNSUPPORTED_OPERATION\", { operation });\r\n    }\r\n    async signTransaction(tx) {\r\n        this.#throwUnsupported(\"transactions\", \"signTransaction\");\r\n    }\r\n    async signMessage(message) {\r\n        this.#throwUnsupported(\"messages\", \"signMessage\");\r\n    }\r\n    async signTypedData(domain, types, value) {\r\n        this.#throwUnsupported(\"typed-data\", \"signTypedData\");\r\n    }\r\n}\r\n//# sourceMappingURL=abstract-signer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvYWJzdHJhY3Qtc2lnbmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FEO0FBQ0M7QUFDcUQ7QUFDL0Q7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVEQUFNLHVEQUF1RCxXQUFXO0FBQzVFO0FBQ0E7QUFDQSxjQUFjLHlEQUFXO0FBQ3pCO0FBQ0EsaUJBQWlCLGlFQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlFQUFjO0FBQzFCO0FBQ0EsWUFBWSwrREFBYztBQUMxQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrRUFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFnQixTQUFTLDhCQUE4QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBEQUFTO0FBQ3JDLFlBQVksK0RBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUFjO0FBQzFCO0FBQ0E7QUFDQSxZQUFZLCtEQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQU07QUFDbEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQU07QUFDMUI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQU07QUFDMUI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxxQkFBcUIsa0VBQWlCO0FBQ3RDO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhEQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBTSxvRkFBb0Ysd0JBQXdCO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsU0FBUztBQUMxQztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQU0sa0NBQWtDLE9BQU8sOEJBQThCLFdBQVc7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHByb3ZpZGVyc1xcYWJzdHJhY3Qtc2lnbmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgR2VuZXJhbGx5IHRoZSBbW1dhbGxldF1dIGFuZCBbW0pzb25ScGNTaWduZXJdXSBhbmQgdGhlaXIgc3ViLWNsYXNzZXNcclxuICogIGFyZSBzdWZmaWNlbnQgZm9yIG1vc3QgZGV2ZWxvcGVycywgYnV0IHRoaXMgaXMgcHJvdmlkZWQgdG9cclxuICogIGZhc2NpbGl0YXRlIG1vcmUgY29tcGxleCBTaWduZXJzLlxyXG4gKlxyXG4gKiAgQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXNpZ25lcjogU3ViY2xhc3NpbmcgU2lnbmVyIFthYnN0cmFjdC1zaWduZXJdXHJcbiAqL1xyXG5pbXBvcnQgeyByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgcmVzb2x2ZVByb3BlcnRpZXMsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgY29weVJlcXVlc3QgfSBmcm9tIFwiLi9wcm92aWRlci5qc1wiO1xyXG5mdW5jdGlvbiBjaGVja1Byb3ZpZGVyKHNpZ25lciwgb3BlcmF0aW9uKSB7XHJcbiAgICBpZiAoc2lnbmVyLnByb3ZpZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHNpZ25lci5wcm92aWRlcjtcclxuICAgIH1cclxuICAgIGFzc2VydChmYWxzZSwgXCJtaXNzaW5nIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uIH0pO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHBvcHVsYXRlKHNpZ25lciwgdHgpIHtcclxuICAgIGxldCBwb3AgPSBjb3B5UmVxdWVzdCh0eCk7XHJcbiAgICBpZiAocG9wLnRvICE9IG51bGwpIHtcclxuICAgICAgICBwb3AudG8gPSByZXNvbHZlQWRkcmVzcyhwb3AudG8sIHNpZ25lcik7XHJcbiAgICB9XHJcbiAgICBpZiAocG9wLmZyb20gIT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IGZyb20gPSBwb3AuZnJvbTtcclxuICAgICAgICBwb3AuZnJvbSA9IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgc2lnbmVyLmdldEFkZHJlc3MoKSxcclxuICAgICAgICAgICAgcmVzb2x2ZUFkZHJlc3MoZnJvbSwgc2lnbmVyKVxyXG4gICAgICAgIF0pLnRoZW4oKFthZGRyZXNzLCBmcm9tXSkgPT4ge1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGZyb20udG9Mb3dlckNhc2UoKSwgXCJ0cmFuc2FjdGlvbiBmcm9tIG1pc21hdGNoXCIsIFwidHguZnJvbVwiLCBmcm9tKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwb3AuZnJvbSA9IHNpZ25lci5nZXRBZGRyZXNzKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMocG9wKTtcclxufVxyXG4vKipcclxuICogIEFuICoqQWJzdHJhY3RTaWduZXIqKiBpbmNsdWRlcyBtb3N0IG9mIHRlaCBmdW5jdGlvbmFsaXR5IHJlcXVpcmVkXHJcbiAqICB0byBnZXQgYSBbW1NpZ25lcl1dIHdvcmtpbmcgYXMgZXhwZWN0ZWQsIGJ1dCByZXF1aXJlcyBhIGZld1xyXG4gKiAgU2lnbmVyLXNwZWNpZmljIG1ldGhvZHMgYmUgb3ZlcnJpZGRlbi5cclxuICpcclxuICovXHJcbmV4cG9ydCBjbGFzcyBBYnN0cmFjdFNpZ25lciB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgcHJvdmlkZXIgdGhpcyBzaWduZXIgaXMgY29ubmVjdGVkIHRvLlxyXG4gICAgICovXHJcbiAgICBwcm92aWRlcjtcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgU2lnbmVyIGNvbm5lY3RlZCB0byAlJXByb3ZpZGVyJSUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHByb3ZpZGVyOiAocHJvdmlkZXIgfHwgbnVsbCkgfSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXROb25jZShibG9ja1RhZykge1xyXG4gICAgICAgIHJldHVybiBjaGVja1Byb3ZpZGVyKHRoaXMsIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiKS5nZXRUcmFuc2FjdGlvbkNvdW50KGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpLCBibG9ja1RhZyk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBwb3B1bGF0ZUNhbGwodHgpIHtcclxuICAgICAgICBjb25zdCBwb3AgPSBhd2FpdCBwb3B1bGF0ZSh0aGlzLCB0eCk7XHJcbiAgICAgICAgcmV0dXJuIHBvcDtcclxuICAgIH1cclxuICAgIGFzeW5jIHBvcHVsYXRlVHJhbnNhY3Rpb24odHgpIHtcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IGNoZWNrUHJvdmlkZXIodGhpcywgXCJwb3B1bGF0ZVRyYW5zYWN0aW9uXCIpO1xyXG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHBvcHVsYXRlKHRoaXMsIHR4KTtcclxuICAgICAgICBpZiAocG9wLm5vbmNlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcG9wLm5vbmNlID0gYXdhaXQgdGhpcy5nZXROb25jZShcInBlbmRpbmdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwb3AuZ2FzTGltaXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwb3AuZ2FzTGltaXQgPSBhd2FpdCB0aGlzLmVzdGltYXRlR2FzKHBvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBvcHVsYXRlIHRoZSBjaGFpbiBJRFxyXG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCAodGhpcy5wcm92aWRlcikuZ2V0TmV0d29yaygpO1xyXG4gICAgICAgIGlmIChwb3AuY2hhaW5JZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSBnZXRCaWdJbnQocG9wLmNoYWluSWQpO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChjaGFpbklkID09PSBuZXR3b3JrLmNoYWluSWQsIFwidHJhbnNhY3Rpb24gY2hhaW5JZCBtaXNtYXRjaFwiLCBcInR4LmNoYWluSWRcIiwgdHguY2hhaW5JZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwb3AuY2hhaW5JZCA9IG5ldHdvcmsuY2hhaW5JZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90IGFsbG93IG1peGluZyBwcmUtZWlwLTE1NTkgYW5kIGVpcC0xNTU5IHByb3BlcnRpZXNcclxuICAgICAgICBjb25zdCBoYXNFaXAxNTU5ID0gKHBvcC5tYXhGZWVQZXJHYXMgIT0gbnVsbCB8fCBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCk7XHJcbiAgICAgICAgaWYgKHBvcC5nYXNQcmljZSAhPSBudWxsICYmIChwb3AudHlwZSA9PT0gMiB8fCBoYXNFaXAxNTU5KSkge1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJlaXAtMTU1OSB0cmFuc2FjdGlvbiBkbyBub3Qgc3VwcG9ydCBnYXNQcmljZVwiLCBcInR4XCIsIHR4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHBvcC50eXBlID09PSAwIHx8IHBvcC50eXBlID09PSAxKSAmJiBoYXNFaXAxNTU5KSB7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInByZS1laXAtMTU1OSB0cmFuc2FjdGlvbiBkbyBub3Qgc3VwcG9ydCBtYXhGZWVQZXJHYXMvbWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJ0eFwiLCB0eCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocG9wLnR5cGUgPT09IDIgfHwgcG9wLnR5cGUgPT0gbnVsbCkgJiYgKHBvcC5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgLy8gRnVsbHktZm9ybWVkIEVJUC0xNTU5IHRyYW5zYWN0aW9uIChza2lwIGdldEZlZURhdGEpXHJcbiAgICAgICAgICAgIHBvcC50eXBlID0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocG9wLnR5cGUgPT09IDAgfHwgcG9wLnR5cGUgPT09IDEpIHtcclxuICAgICAgICAgICAgLy8gRXhwbGljaXQgTGVnYWN5IG9yIEVJUC0yOTMwIHRyYW5zYWN0aW9uXHJcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IGZlZSBkYXRhIHRvIGRldGVybWluZSB0aGluZ3NcclxuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHByb3ZpZGVyLmdldEZlZURhdGEoKTtcclxuICAgICAgICAgICAgYXNzZXJ0KGZlZURhdGEuZ2FzUHJpY2UgIT0gbnVsbCwgXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgZ2FzUHJpY2VcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEdhc1ByaWNlXCJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZ2FzUHJpY2VcclxuICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBwb3AuZ2FzUHJpY2UgPSBmZWVEYXRhLmdhc1ByaWNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGdldCBmZWUgZGF0YSB0byBkZXRlcm1pbmUgdGhpbmdzXHJcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCk7XHJcbiAgICAgICAgICAgIGlmIChwb3AudHlwZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGF1dG8tZGV0ZWN0IHRoZSBpbnRlbmRlZCB0eXBlIG9mIHRoaXMgdHJhbnNhY3Rpb24uLi5cclxuICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyAhPSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBuZXR3b3JrIHN1cHBvcnRzIEVJUC0xNTU5IVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZ3JhZGUgdHJhbnNhY3Rpb24gZnJvbSBudWxsIHRvIGVpcC0xNTU5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5hdXRob3JpemF0aW9uTGlzdCAmJiBwb3AuYXV0aG9yaXphdGlvbkxpc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcC50eXBlID0gNDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcC50eXBlID0gMjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzaW5nIGxlZ2FjeSBnYXNQcmljZSBwcm9wZXJ0eSBvbiBhbiBlaXAtMTU1OSBuZXR3b3JrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB1c2UgZ2FzUHJpY2UgYXMgYm90aCBmZWUgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXNQcmljZSA9IHBvcC5nYXNQcmljZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBvcC5nYXNQcmljZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heEZlZVBlckdhcyA9IGdhc1ByaWNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBnYXNQcmljZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5tYXhGZWVQZXJHYXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heEZlZVBlckdhcyA9IGZlZURhdGEubWF4RmVlUGVyR2FzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZlZURhdGEuZ2FzUHJpY2UgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBzdXBwb3J0IEVJUC0xNTU5Li4uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uYnV0IHRoZXkgYXJlIHRyeWluZyB0byB1c2UgRUlQLTE1NTkgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCghaGFzRWlwMTU1OSwgXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRUlQLTE1NTlcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicG9wdWxhdGVUcmFuc2FjdGlvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3AuZ2FzUHJpY2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AuZ2FzUHJpY2UgPSBmZWVEYXRhLmdhc1ByaWNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHNldCB1bnR5cGVkIHRyYW5zYWN0aW9uIHRvIGxlZ2FjeVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBNYXliZSB0aGlzIHNob2xkIGFsbG93IHR5cGUgMT9cclxuICAgICAgICAgICAgICAgICAgICBwb3AudHlwZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBnZXRGZWVEYXRhIGhhcyBmYWlsZWQgdXMuXHJcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImZhaWxlZCB0byBnZXQgY29uc2lzdGVudCBmZWUgZGF0YVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzaWduZXIuZ2V0RmVlRGF0YVwiXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocG9wLnR5cGUgPT09IDIgfHwgcG9wLnR5cGUgPT09IDMgfHwgcG9wLnR5cGUgPT09IDQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgdXNpbmcgRUlQLTE1NTkgb3IgRUlQLTQ4NDRcclxuICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcclxuICAgICAgICAgICAgICAgIGlmIChwb3AubWF4RmVlUGVyR2FzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3AubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vQFRPT0Q6IERvbid0IGF3YWl0IGFsbCBvdmVyIHRoZSBwbGFjZTsgc2F2ZSB0aGVtIHVwIGZvclxyXG4gICAgICAgIC8vIHRoZSBlbmQgZm9yIGJldHRlciBiYXRjaGluZ1xyXG4gICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlUHJvcGVydGllcyhwb3ApO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcG9wdWxhdGVBdXRob3JpemF0aW9uKF9hdXRoKSB7XHJcbiAgICAgICAgY29uc3QgYXV0aCA9IE9iamVjdC5hc3NpZ24oe30sIF9hdXRoKTtcclxuICAgICAgICAvLyBBZGQgYSBjaGFpbiBJRCBpZiBub3QgZXhwbGljaXRseSBzZXQgdG8gMFxyXG4gICAgICAgIGlmIChhdXRoLmNoYWluSWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBhdXRoLmNoYWluSWQgPSAoYXdhaXQgY2hlY2tQcm92aWRlcih0aGlzLCBcImdldE5ldHdvcmtcIikuZ2V0TmV0d29yaygpKS5jaGFpbklkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBAVE9ETzogVGFrZSBjaGFpbiBJRCBpbnRvIGFjY291bnQgd2hlbiBwb3B1bGF0aW5nIG5vY2U/XHJcbiAgICAgICAgaWYgKGF1dGgubm9uY2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBhdXRoLm5vbmNlID0gYXdhaXQgdGhpcy5nZXROb25jZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXV0aDtcclxuICAgIH1cclxuICAgIGFzeW5jIGVzdGltYXRlR2FzKHR4KSB7XHJcbiAgICAgICAgcmV0dXJuIGNoZWNrUHJvdmlkZXIodGhpcywgXCJlc3RpbWF0ZUdhc1wiKS5lc3RpbWF0ZUdhcyhhd2FpdCB0aGlzLnBvcHVsYXRlQ2FsbCh0eCkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgY2FsbCh0eCkge1xyXG4gICAgICAgIHJldHVybiBjaGVja1Byb3ZpZGVyKHRoaXMsIFwiY2FsbFwiKS5jYWxsKGF3YWl0IHRoaXMucG9wdWxhdGVDYWxsKHR4KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyByZXNvbHZlTmFtZShuYW1lKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBjaGVja1Byb3ZpZGVyKHRoaXMsIFwicmVzb2x2ZU5hbWVcIik7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLnJlc29sdmVOYW1lKG5hbWUpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHR4KSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBjaGVja1Byb3ZpZGVyKHRoaXMsIFwic2VuZFRyYW5zYWN0aW9uXCIpO1xyXG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbih0eCk7XHJcbiAgICAgICAgZGVsZXRlIHBvcC5mcm9tO1xyXG4gICAgICAgIGNvbnN0IHR4T2JqID0gVHJhbnNhY3Rpb24uZnJvbShwb3ApO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5icm9hZGNhc3RUcmFuc2FjdGlvbihhd2FpdCB0aGlzLnNpZ25UcmFuc2FjdGlvbih0eE9iaikpO1xyXG4gICAgfVxyXG4gICAgLy8gQFRPRE86IGluIHY3IG1vdmUgdGhpcyB0byBiZSBhYnN0cmFjdFxyXG4gICAgYXV0aG9yaXplKGF1dGhvcml6YXRpb24pIHtcclxuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiYXV0aG9yaXphdGlvbiBub3QgaW1wbGVtZW50ZWQgZm9yIHRoaXMgc2lnbmVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImF1dGhvcml6ZVwiIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgQSAqKlZvaWRTaWduZXIqKiBpcyBhIGNsYXNzIGRlaXNnbmVkIHRvIGFsbG93IGFuIGFkZHJlc3MgdG8gYmUgdXNlZFxyXG4gKiAgaW4gYW55IEFQSSB3aGljaCBhY2NlcHRzIGEgU2lnbmVyLCBidXQgZm9yIHdoaWNoIHRoZXJlIGFyZSBub1xyXG4gKiAgY3JlZGVudGlhbHMgYXZhaWxhYmxlIHRvIHBlcmZvcm0gYW55IGFjdHVhbCBzaWduaW5nLlxyXG4gKlxyXG4gKiAgVGhpcyBmb3IgZXhhbXBsZSBhbGxvdyBpbXBlcnNvbmF0aW5nIGFuIGFjY291bnQgZm9yIHRoZSBwdXJwb3NlIG9mXHJcbiAqICBzdGF0aWMgY2FsbHMgb3IgZXN0aW1hdGluZyBnYXMsIGJ1dCBkb2VzIG5vdCBhbGxvdyBzZW5kaW5nIHRyYW5zYWN0aW9ucy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBWb2lkU2lnbmVyIGV4dGVuZHMgQWJzdHJhY3RTaWduZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHNpZ25lciBhZGRyZXNzLlxyXG4gICAgICovXHJcbiAgICBhZGRyZXNzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlZvaWRTaWduZXIqKiB3aXRoICUlYWRkcmVzcyUlIGF0dGFjaGVkIHRvXHJcbiAgICAgKiAgJSVwcm92aWRlciUlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm92aWRlcikge1xyXG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYWRkcmVzcyB9KTtcclxuICAgIH1cclxuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7IHJldHVybiB0aGlzLmFkZHJlc3M7IH1cclxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZvaWRTaWduZXIodGhpcy5hZGRyZXNzLCBwcm92aWRlcik7XHJcbiAgICB9XHJcbiAgICAjdGhyb3dVbnN1cHBvcnRlZChzdWZmaXgsIG9wZXJhdGlvbikge1xyXG4gICAgICAgIGFzc2VydChmYWxzZSwgYFZvaWRTaWduZXIgY2Fubm90IHNpZ24gJHtzdWZmaXh9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb24gfSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHgpIHtcclxuICAgICAgICB0aGlzLiN0aHJvd1Vuc3VwcG9ydGVkKFwidHJhbnNhY3Rpb25zXCIsIFwic2lnblRyYW5zYWN0aW9uXCIpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJtZXNzYWdlc1wiLCBcInNpZ25NZXNzYWdlXCIpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJ0eXBlZC1kYXRhXCIsIFwic2lnblR5cGVkRGF0YVwiKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1zaWduZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/abstract-signer.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/community.js":
/*!************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/community.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   showThrottleMessage: () => (/* binding */ showThrottleMessage)\n/* harmony export */ });\n/**\r\n *  There are many awesome community services that provide Ethereum\r\n *  nodes both for developers just starting out and for large-scale\r\n *  communities.\r\n *\r\n *  @_section: api/providers/thirdparty: Community Providers  [thirdparty]\r\n */\r\n// Show the throttle message only once per service\r\nconst shown = new Set();\r\n/**\r\n *  Displays a warning in the console when the community resource is\r\n *  being used too heavily by the app, recommending the developer\r\n *  acquire their own credentials instead of using the community\r\n *  credentials.\r\n *\r\n *  The notification will only occur once per service.\r\n */\r\nfunction showThrottleMessage(service) {\r\n    if (shown.has(service)) {\r\n        return;\r\n    }\r\n    shown.add(service);\r\n    console.log(\"========= NOTICE =========\");\r\n    console.log(`Request-Rate Exceeded for ${service} (this message will not be repeated)`);\r\n    console.log(\"\");\r\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\r\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\r\n    console.log(\"\");\r\n    console.log(\"While your application will continue to function, we highly recommended\");\r\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\r\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\r\n    console.log(\"\");\r\n    console.log(\"For more details: https:/\\/docs.ethers.org/api-keys/\");\r\n    console.log(\"==========================\");\r\n}\r\n//# sourceMappingURL=community.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvY29tbXVuaXR5LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHByb3ZpZGVyc1xcY29tbXVuaXR5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgVGhlcmUgYXJlIG1hbnkgYXdlc29tZSBjb21tdW5pdHkgc2VydmljZXMgdGhhdCBwcm92aWRlIEV0aGVyZXVtXHJcbiAqICBub2RlcyBib3RoIGZvciBkZXZlbG9wZXJzIGp1c3Qgc3RhcnRpbmcgb3V0IGFuZCBmb3IgbGFyZ2Utc2NhbGVcclxuICogIGNvbW11bml0aWVzLlxyXG4gKlxyXG4gKiAgQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHk6IENvbW11bml0eSBQcm92aWRlcnMgIFt0aGlyZHBhcnR5XVxyXG4gKi9cclxuLy8gU2hvdyB0aGUgdGhyb3R0bGUgbWVzc2FnZSBvbmx5IG9uY2UgcGVyIHNlcnZpY2VcclxuY29uc3Qgc2hvd24gPSBuZXcgU2V0KCk7XHJcbi8qKlxyXG4gKiAgRGlzcGxheXMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIHdoZW4gdGhlIGNvbW11bml0eSByZXNvdXJjZSBpc1xyXG4gKiAgYmVpbmcgdXNlZCB0b28gaGVhdmlseSBieSB0aGUgYXBwLCByZWNvbW1lbmRpbmcgdGhlIGRldmVsb3BlclxyXG4gKiAgYWNxdWlyZSB0aGVpciBvd24gY3JlZGVudGlhbHMgaW5zdGVhZCBvZiB1c2luZyB0aGUgY29tbXVuaXR5XHJcbiAqICBjcmVkZW50aWFscy5cclxuICpcclxuICogIFRoZSBub3RpZmljYXRpb24gd2lsbCBvbmx5IG9jY3VyIG9uY2UgcGVyIHNlcnZpY2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2hvd1Rocm90dGxlTWVzc2FnZShzZXJ2aWNlKSB7XHJcbiAgICBpZiAoc2hvd24uaGFzKHNlcnZpY2UpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgc2hvd24uYWRkKHNlcnZpY2UpO1xyXG4gICAgY29uc29sZS5sb2coXCI9PT09PT09PT0gTk9USUNFID09PT09PT09PVwiKTtcclxuICAgIGNvbnNvbGUubG9nKGBSZXF1ZXN0LVJhdGUgRXhjZWVkZWQgZm9yICR7c2VydmljZX0gKHRoaXMgbWVzc2FnZSB3aWxsIG5vdCBiZSByZXBlYXRlZClgKTtcclxuICAgIGNvbnNvbGUubG9nKFwiXCIpO1xyXG4gICAgY29uc29sZS5sb2coXCJUaGUgZGVmYXVsdCBBUEkga2V5cyBmb3IgZWFjaCBzZXJ2aWNlIGFyZSBwcm92aWRlZCBhcyBhIGhpZ2hseS10aHJvdHRsZWQsXCIpO1xyXG4gICAgY29uc29sZS5sb2coXCJjb21tdW5pdHkgcmVzb3VyY2UgZm9yIGxvdy10cmFmZmljIHByb2plY3RzIGFuZCBlYXJseSBwcm90b3R5cGluZy5cIik7XHJcbiAgICBjb25zb2xlLmxvZyhcIlwiKTtcclxuICAgIGNvbnNvbGUubG9nKFwiV2hpbGUgeW91ciBhcHBsaWNhdGlvbiB3aWxsIGNvbnRpbnVlIHRvIGZ1bmN0aW9uLCB3ZSBoaWdobHkgcmVjb21tZW5kZWRcIik7XHJcbiAgICBjb25zb2xlLmxvZyhcInNpZ25pbmcgdXAgZm9yIHlvdXIgb3duIEFQSSBrZXlzIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UsIGluY3JlYXNlIHlvdXJcIik7XHJcbiAgICBjb25zb2xlLmxvZyhcInJlcXVlc3QgcmF0ZS9saW1pdCBhbmQgZW5hYmxlIG90aGVyIHBlcmtzLCBzdWNoIGFzIG1ldHJpY3MgYW5kIGFkdmFuY2VkIEFQSXMuXCIpO1xyXG4gICAgY29uc29sZS5sb2coXCJcIik7XHJcbiAgICBjb25zb2xlLmxvZyhcIkZvciBtb3JlIGRldGFpbHM6IGh0dHBzOi9cXC9kb2NzLmV0aGVycy5vcmcvYXBpLWtleXMvXCIpO1xyXG4gICAgY29uc29sZS5sb2coXCI9PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tdW5pdHkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/community.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/default-provider.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/default-provider.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDefaultProvider: () => (/* binding */ getDefaultProvider)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _provider_ankr_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./provider-ankr.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-ankr.js\");\n/* harmony import */ var _provider_alchemy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./provider-alchemy.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-alchemy.js\");\n/* harmony import */ var _provider_chainstack_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./provider-chainstack.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-chainstack.js\");\n/* harmony import */ var _provider_cloudflare_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./provider-cloudflare.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-cloudflare.js\");\n/* harmony import */ var _provider_etherscan_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./provider-etherscan.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-etherscan.js\");\n/* harmony import */ var _provider_infura_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./provider-infura.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-infura.js\");\n/* harmony import */ var _provider_quicknode_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./provider-quicknode.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-quicknode.js\");\n/* harmony import */ var _provider_fallback_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./provider-fallback.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-fallback.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_websocket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider-websocket.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-websocket.js\");\n\r\n\r\n\r\n//import { BlockscoutProvider } from \"./provider-blockscout.js\";\r\n\r\n\r\n\r\n\r\n//import { PocketProvider } from \"./provider-pocket.js\";\r\n\r\n\r\n\r\n\r\n\r\nfunction isWebSocketLike(value) {\r\n    return (value && typeof (value.send) === \"function\" &&\r\n        typeof (value.close) === \"function\");\r\n}\r\nconst Testnets = \"goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt\".split(\" \");\r\n/**\r\n *  Returns a default provider for %%network%%.\r\n *\r\n *  If %%network%% is a [[WebSocketLike]] or string that begins with\r\n *  ``\"ws:\"`` or ``\"wss:\"``, a [[WebSocketProvider]] is returned backed\r\n *  by that WebSocket or URL.\r\n *\r\n *  If %%network%% is a string that begins with ``\"HTTP:\"`` or ``\"HTTPS:\"``,\r\n *  a [[JsonRpcProvider]] is returned connected to that URL.\r\n *\r\n *  Otherwise, a default provider is created backed by well-known public\r\n *  Web3 backends (such as [[link-infura]]) using community-provided API\r\n *  keys.\r\n *\r\n *  The %%options%% allows specifying custom API keys per backend (setting\r\n *  an API key to ``\"-\"`` will omit that provider) and ``options.exclusive``\r\n *  can be set to either a backend name or and array of backend names, which\r\n *  will whitelist **only** those backends.\r\n *\r\n *  Current backend strings supported are:\r\n *  - ``\"alchemy\"``\r\n *  - ``\"ankr\"``\r\n *  - ``\"cloudflare\"``\r\n *  - ``\"chainstack\"``\r\n *  - ``\"etherscan\"``\r\n *  - ``\"infura\"``\r\n *  - ``\"publicPolygon\"``\r\n *  - ``\"quicknode\"``\r\n *\r\n *  @example:\r\n *    // Connect to a local Geth node\r\n *    provider = getDefaultProvider(\"http://localhost:8545/\");\r\n *\r\n *    // Connect to Ethereum mainnet with any current and future\r\n *    // third-party services available\r\n *    provider = getDefaultProvider(\"mainnet\");\r\n *\r\n *    // Connect to Polygon, but only allow Etherscan and\r\n *    // INFURA and use \"MY_API_KEY\" in calls to Etherscan.\r\n *    provider = getDefaultProvider(\"matic\", {\r\n *      etherscan: \"MY_API_KEY\",\r\n *      exclusive: [ \"etherscan\", \"infura\" ]\r\n *    });\r\n */\r\nfunction getDefaultProvider(network, options) {\r\n    if (options == null) {\r\n        options = {};\r\n    }\r\n    const allowService = (name) => {\r\n        if (options[name] === \"-\") {\r\n            return false;\r\n        }\r\n        if (typeof (options.exclusive) === \"string\") {\r\n            return (name === options.exclusive);\r\n        }\r\n        if (Array.isArray(options.exclusive)) {\r\n            return (options.exclusive.indexOf(name) !== -1);\r\n        }\r\n        return true;\r\n    };\r\n    if (typeof (network) === \"string\" && network.match(/^https?:/)) {\r\n        return new _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpcProvider(network);\r\n    }\r\n    if (typeof (network) === \"string\" && network.match(/^wss?:/) || isWebSocketLike(network)) {\r\n        return new _provider_websocket_js__WEBPACK_IMPORTED_MODULE_1__.WebSocketProvider(network);\r\n    }\r\n    // Get the network and name, if possible\r\n    let staticNetwork = null;\r\n    try {\r\n        staticNetwork = _network_js__WEBPACK_IMPORTED_MODULE_2__.Network.from(network);\r\n    }\r\n    catch (error) { }\r\n    const providers = [];\r\n    if (allowService(\"publicPolygon\") && staticNetwork) {\r\n        if (staticNetwork.name === \"matic\") {\r\n            providers.push(new _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpcProvider(\"https:/\\/polygon-rpc.com/\", staticNetwork, { staticNetwork }));\r\n        }\r\n        else if (staticNetwork.name === \"matic-amoy\") {\r\n            providers.push(new _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpcProvider(\"https:/\\/rpc-amoy.polygon.technology/\", staticNetwork, { staticNetwork }));\r\n        }\r\n    }\r\n    if (allowService(\"alchemy\")) {\r\n        try {\r\n            providers.push(new _provider_alchemy_js__WEBPACK_IMPORTED_MODULE_3__.AlchemyProvider(network, options.alchemy));\r\n        }\r\n        catch (error) { }\r\n    }\r\n    if (allowService(\"ankr\") && options.ankr != null) {\r\n        try {\r\n            providers.push(new _provider_ankr_js__WEBPACK_IMPORTED_MODULE_4__.AnkrProvider(network, options.ankr));\r\n        }\r\n        catch (error) { }\r\n    }\r\n    /* Temporarily remove until custom error issue is fixed\r\n        if (allowService(\"blockscout\")) {\r\n            try {\r\n                providers.push(new BlockscoutProvider(network, options.blockscout));\r\n            } catch (error) { }\r\n        }\r\n    */\r\n    if (allowService(\"chainstack\")) {\r\n        try {\r\n            providers.push(new _provider_chainstack_js__WEBPACK_IMPORTED_MODULE_5__.ChainstackProvider(network, options.chainstack));\r\n        }\r\n        catch (error) { }\r\n    }\r\n    if (allowService(\"cloudflare\")) {\r\n        try {\r\n            providers.push(new _provider_cloudflare_js__WEBPACK_IMPORTED_MODULE_6__.CloudflareProvider(network));\r\n        }\r\n        catch (error) { }\r\n    }\r\n    if (allowService(\"etherscan\")) {\r\n        try {\r\n            providers.push(new _provider_etherscan_js__WEBPACK_IMPORTED_MODULE_7__.EtherscanProvider(network, options.etherscan));\r\n        }\r\n        catch (error) { }\r\n    }\r\n    if (allowService(\"infura\")) {\r\n        try {\r\n            let projectId = options.infura;\r\n            let projectSecret = undefined;\r\n            if (typeof (projectId) === \"object\") {\r\n                projectSecret = projectId.projectSecret;\r\n                projectId = projectId.projectId;\r\n            }\r\n            providers.push(new _provider_infura_js__WEBPACK_IMPORTED_MODULE_8__.InfuraProvider(network, projectId, projectSecret));\r\n        }\r\n        catch (error) { }\r\n    }\r\n    /*\r\n        if (options.pocket !== \"-\") {\r\n            try {\r\n                let appId = options.pocket;\r\n                let secretKey: undefined | string = undefined;\r\n                let loadBalancer: undefined | boolean = undefined;\r\n                if (typeof(appId) === \"object\") {\r\n                    loadBalancer = !!appId.loadBalancer;\r\n                    secretKey = appId.secretKey;\r\n                    appId = appId.appId;\r\n                }\r\n                providers.push(new PocketProvider(network, appId, secretKey, loadBalancer));\r\n            } catch (error) { console.log(error); }\r\n        }\r\n    */\r\n    if (allowService(\"quicknode\")) {\r\n        try {\r\n            let token = options.quicknode;\r\n            providers.push(new _provider_quicknode_js__WEBPACK_IMPORTED_MODULE_9__.QuickNodeProvider(network, token));\r\n        }\r\n        catch (error) { }\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.assert)(providers.length, \"unsupported default network\", \"UNSUPPORTED_OPERATION\", {\r\n        operation: \"getDefaultProvider\"\r\n    });\r\n    // No need for a FallbackProvider\r\n    if (providers.length === 1) {\r\n        return providers[0];\r\n    }\r\n    // We use the floor because public third-party providers can be unreliable,\r\n    // so a low number of providers with a large quorum will fail too often\r\n    let quorum = Math.floor(providers.length / 2);\r\n    if (quorum > 2) {\r\n        quorum = 2;\r\n    }\r\n    // Testnets don't need as strong a security gaurantee and speed is\r\n    // more useful during testing\r\n    if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {\r\n        quorum = 1;\r\n    }\r\n    // Provided override qorum takes priority\r\n    if (options && options.quorum) {\r\n        quorum = options.quorum;\r\n    }\r\n    return new _provider_fallback_js__WEBPACK_IMPORTED_MODULE_11__.FallbackProvider(providers, undefined, { quorum });\r\n}\r\n//# sourceMappingURL=default-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvZGVmYXVsdC1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQTJDO0FBQ087QUFDTTtBQUN4RCxXQUFXLHFCQUFxQjtBQUM4QjtBQUNBO0FBQ0Y7QUFDTjtBQUN0RCxXQUFXLGlCQUFpQjtBQUNnQztBQUNGO0FBQ0Y7QUFDakI7QUFDcUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUVBQWU7QUFDbEM7QUFDQTtBQUNBLG1CQUFtQixxRUFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0RBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpRUFBZSwrQ0FBK0MsZUFBZTtBQUM1RztBQUNBO0FBQ0EsK0JBQStCLGlFQUFlLDJEQUEyRCxlQUFlO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlFQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkRBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUVBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUVBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUVBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0RBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxRUFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3REFBTTtBQUNWO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvRUFBZ0IseUJBQXlCLFFBQVE7QUFDaEU7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxwcm92aWRlcnNcXGRlZmF1bHQtcHJvdmlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IEFua3JQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWFua3IuanNcIjtcclxuaW1wb3J0IHsgQWxjaGVteVByb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItYWxjaGVteS5qc1wiO1xyXG4vL2ltcG9ydCB7IEJsb2Nrc2NvdXRQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWJsb2Nrc2NvdXQuanNcIjtcclxuaW1wb3J0IHsgQ2hhaW5zdGFja1Byb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItY2hhaW5zdGFjay5qc1wiO1xyXG5pbXBvcnQgeyBDbG91ZGZsYXJlUHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1jbG91ZGZsYXJlLmpzXCI7XHJcbmltcG9ydCB7IEV0aGVyc2NhblByb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItZXRoZXJzY2FuLmpzXCI7XHJcbmltcG9ydCB7IEluZnVyYVByb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItaW5mdXJhLmpzXCI7XHJcbi8vaW1wb3J0IHsgUG9ja2V0UHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1wb2NrZXQuanNcIjtcclxuaW1wb3J0IHsgUXVpY2tOb2RlUHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1xdWlja25vZGUuanNcIjtcclxuaW1wb3J0IHsgRmFsbGJhY2tQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWZhbGxiYWNrLmpzXCI7XHJcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIjtcclxuaW1wb3J0IHsgTmV0d29yayB9IGZyb20gXCIuL25ldHdvcmsuanNcIjtcclxuaW1wb3J0IHsgV2ViU29ja2V0UHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci13ZWJzb2NrZXQuanNcIjtcclxuZnVuY3Rpb24gaXNXZWJTb2NrZXRMaWtlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuc2VuZCkgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG4gICAgICAgIHR5cGVvZiAodmFsdWUuY2xvc2UpID09PSBcImZ1bmN0aW9uXCIpO1xyXG59XHJcbmNvbnN0IFRlc3RuZXRzID0gXCJnb2VybGkga292YW4gc2Vwb2xpYSBjbGFzc2ljS290dGkgb3B0aW1pc20tZ29lcmxpIGFyYml0cnVtLWdvZXJsaSBtYXRpYy1tdW1iYWkgYm5idFwiLnNwbGl0KFwiIFwiKTtcclxuLyoqXHJcbiAqICBSZXR1cm5zIGEgZGVmYXVsdCBwcm92aWRlciBmb3IgJSVuZXR3b3JrJSUuXHJcbiAqXHJcbiAqICBJZiAlJW5ldHdvcmslJSBpcyBhIFtbV2ViU29ja2V0TGlrZV1dIG9yIHN0cmluZyB0aGF0IGJlZ2lucyB3aXRoXHJcbiAqICBgYFwid3M6XCJgYCBvciBgYFwid3NzOlwiYGAsIGEgW1tXZWJTb2NrZXRQcm92aWRlcl1dIGlzIHJldHVybmVkIGJhY2tlZFxyXG4gKiAgYnkgdGhhdCBXZWJTb2NrZXQgb3IgVVJMLlxyXG4gKlxyXG4gKiAgSWYgJSVuZXR3b3JrJSUgaXMgYSBzdHJpbmcgdGhhdCBiZWdpbnMgd2l0aCBgYFwiSFRUUDpcImBgIG9yIGBgXCJIVFRQUzpcImBgLFxyXG4gKiAgYSBbW0pzb25ScGNQcm92aWRlcl1dIGlzIHJldHVybmVkIGNvbm5lY3RlZCB0byB0aGF0IFVSTC5cclxuICpcclxuICogIE90aGVyd2lzZSwgYSBkZWZhdWx0IHByb3ZpZGVyIGlzIGNyZWF0ZWQgYmFja2VkIGJ5IHdlbGwta25vd24gcHVibGljXHJcbiAqICBXZWIzIGJhY2tlbmRzIChzdWNoIGFzIFtbbGluay1pbmZ1cmFdXSkgdXNpbmcgY29tbXVuaXR5LXByb3ZpZGVkIEFQSVxyXG4gKiAga2V5cy5cclxuICpcclxuICogIFRoZSAlJW9wdGlvbnMlJSBhbGxvd3Mgc3BlY2lmeWluZyBjdXN0b20gQVBJIGtleXMgcGVyIGJhY2tlbmQgKHNldHRpbmdcclxuICogIGFuIEFQSSBrZXkgdG8gYGBcIi1cImBgIHdpbGwgb21pdCB0aGF0IHByb3ZpZGVyKSBhbmQgYGBvcHRpb25zLmV4Y2x1c2l2ZWBgXHJcbiAqICBjYW4gYmUgc2V0IHRvIGVpdGhlciBhIGJhY2tlbmQgbmFtZSBvciBhbmQgYXJyYXkgb2YgYmFja2VuZCBuYW1lcywgd2hpY2hcclxuICogIHdpbGwgd2hpdGVsaXN0ICoqb25seSoqIHRob3NlIGJhY2tlbmRzLlxyXG4gKlxyXG4gKiAgQ3VycmVudCBiYWNrZW5kIHN0cmluZ3Mgc3VwcG9ydGVkIGFyZTpcclxuICogIC0gYGBcImFsY2hlbXlcImBgXHJcbiAqICAtIGBgXCJhbmtyXCJgYFxyXG4gKiAgLSBgYFwiY2xvdWRmbGFyZVwiYGBcclxuICogIC0gYGBcImNoYWluc3RhY2tcImBgXHJcbiAqICAtIGBgXCJldGhlcnNjYW5cImBgXHJcbiAqICAtIGBgXCJpbmZ1cmFcImBgXHJcbiAqICAtIGBgXCJwdWJsaWNQb2x5Z29uXCJgYFxyXG4gKiAgLSBgYFwicXVpY2tub2RlXCJgYFxyXG4gKlxyXG4gKiAgQGV4YW1wbGU6XHJcbiAqICAgIC8vIENvbm5lY3QgdG8gYSBsb2NhbCBHZXRoIG5vZGVcclxuICogICAgcHJvdmlkZXIgPSBnZXREZWZhdWx0UHJvdmlkZXIoXCJodHRwOi8vbG9jYWxob3N0Ojg1NDUvXCIpO1xyXG4gKlxyXG4gKiAgICAvLyBDb25uZWN0IHRvIEV0aGVyZXVtIG1haW5uZXQgd2l0aCBhbnkgY3VycmVudCBhbmQgZnV0dXJlXHJcbiAqICAgIC8vIHRoaXJkLXBhcnR5IHNlcnZpY2VzIGF2YWlsYWJsZVxyXG4gKiAgICBwcm92aWRlciA9IGdldERlZmF1bHRQcm92aWRlcihcIm1haW5uZXRcIik7XHJcbiAqXHJcbiAqICAgIC8vIENvbm5lY3QgdG8gUG9seWdvbiwgYnV0IG9ubHkgYWxsb3cgRXRoZXJzY2FuIGFuZFxyXG4gKiAgICAvLyBJTkZVUkEgYW5kIHVzZSBcIk1ZX0FQSV9LRVlcIiBpbiBjYWxscyB0byBFdGhlcnNjYW4uXHJcbiAqICAgIHByb3ZpZGVyID0gZ2V0RGVmYXVsdFByb3ZpZGVyKFwibWF0aWNcIiwge1xyXG4gKiAgICAgIGV0aGVyc2NhbjogXCJNWV9BUElfS0VZXCIsXHJcbiAqICAgICAgZXhjbHVzaXZlOiBbIFwiZXRoZXJzY2FuXCIsIFwiaW5mdXJhXCIgXVxyXG4gKiAgICB9KTtcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0UHJvdmlkZXIobmV0d29yaywgb3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xyXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgIH1cclxuICAgIGNvbnN0IGFsbG93U2VydmljZSA9IChuYW1lKSA9PiB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnNbbmFtZV0gPT09IFwiLVwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiAob3B0aW9ucy5leGNsdXNpdmUpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAobmFtZSA9PT0gb3B0aW9ucy5leGNsdXNpdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmV4Y2x1c2l2ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChvcHRpb25zLmV4Y2x1c2l2ZS5pbmRleE9mKG5hbWUpICE9PSAtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcInN0cmluZ1wiICYmIG5ldHdvcmsubWF0Y2goL15odHRwcz86LykpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEpzb25ScGNQcm92aWRlcihuZXR3b3JrKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcInN0cmluZ1wiICYmIG5ldHdvcmsubWF0Y2goL153c3M/Oi8pIHx8IGlzV2ViU29ja2V0TGlrZShuZXR3b3JrKSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgV2ViU29ja2V0UHJvdmlkZXIobmV0d29yayk7XHJcbiAgICB9XHJcbiAgICAvLyBHZXQgdGhlIG5ldHdvcmsgYW5kIG5hbWUsIGlmIHBvc3NpYmxlXHJcbiAgICBsZXQgc3RhdGljTmV0d29yayA9IG51bGw7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHN0YXRpY05ldHdvcmsgPSBOZXR3b3JrLmZyb20obmV0d29yayk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgY29uc3QgcHJvdmlkZXJzID0gW107XHJcbiAgICBpZiAoYWxsb3dTZXJ2aWNlKFwicHVibGljUG9seWdvblwiKSAmJiBzdGF0aWNOZXR3b3JrKSB7XHJcbiAgICAgICAgaWYgKHN0YXRpY05ldHdvcmsubmFtZSA9PT0gXCJtYXRpY1wiKSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoKG5ldyBKc29uUnBjUHJvdmlkZXIoXCJodHRwczovXFwvcG9seWdvbi1ycGMuY29tL1wiLCBzdGF0aWNOZXR3b3JrLCB7IHN0YXRpY05ldHdvcmsgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzdGF0aWNOZXR3b3JrLm5hbWUgPT09IFwibWF0aWMtYW1veVwiKSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoKG5ldyBKc29uUnBjUHJvdmlkZXIoXCJodHRwczovXFwvcnBjLWFtb3kucG9seWdvbi50ZWNobm9sb2d5L1wiLCBzdGF0aWNOZXR3b3JrLCB7IHN0YXRpY05ldHdvcmsgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChhbGxvd1NlcnZpY2UoXCJhbGNoZW15XCIpKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IEFsY2hlbXlQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmFsY2hlbXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgIH1cclxuICAgIGlmIChhbGxvd1NlcnZpY2UoXCJhbmtyXCIpICYmIG9wdGlvbnMuYW5rciAhPSBudWxsKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IEFua3JQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmFua3IpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgIH1cclxuICAgIC8qIFRlbXBvcmFyaWx5IHJlbW92ZSB1bnRpbCBjdXN0b20gZXJyb3IgaXNzdWUgaXMgZml4ZWRcclxuICAgICAgICBpZiAoYWxsb3dTZXJ2aWNlKFwiYmxvY2tzY291dFwiKSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IEJsb2Nrc2NvdXRQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmJsb2Nrc2NvdXQpKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgICAgIH1cclxuICAgICovXHJcbiAgICBpZiAoYWxsb3dTZXJ2aWNlKFwiY2hhaW5zdGFja1wiKSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoKG5ldyBDaGFpbnN0YWNrUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5jaGFpbnN0YWNrKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICB9XHJcbiAgICBpZiAoYWxsb3dTZXJ2aWNlKFwiY2xvdWRmbGFyZVwiKSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoKG5ldyBDbG91ZGZsYXJlUHJvdmlkZXIobmV0d29yaykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgfVxyXG4gICAgaWYgKGFsbG93U2VydmljZShcImV0aGVyc2NhblwiKSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoKG5ldyBFdGhlcnNjYW5Qcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmV0aGVyc2NhbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgfVxyXG4gICAgaWYgKGFsbG93U2VydmljZShcImluZnVyYVwiKSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCBwcm9qZWN0SWQgPSBvcHRpb25zLmluZnVyYTtcclxuICAgICAgICAgICAgbGV0IHByb2plY3RTZWNyZXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb2plY3RJZCkgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIHByb2plY3RTZWNyZXQgPSBwcm9qZWN0SWQucHJvamVjdFNlY3JldDtcclxuICAgICAgICAgICAgICAgIHByb2plY3RJZCA9IHByb2plY3RJZC5wcm9qZWN0SWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IEluZnVyYVByb3ZpZGVyKG5ldHdvcmssIHByb2plY3RJZCwgcHJvamVjdFNlY3JldCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgfVxyXG4gICAgLypcclxuICAgICAgICBpZiAob3B0aW9ucy5wb2NrZXQgIT09IFwiLVwiKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYXBwSWQgPSBvcHRpb25zLnBvY2tldDtcclxuICAgICAgICAgICAgICAgIGxldCBzZWNyZXRLZXk6IHVuZGVmaW5lZCB8IHN0cmluZyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGxldCBsb2FkQmFsYW5jZXI6IHVuZGVmaW5lZCB8IGJvb2xlYW4gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGFwcElkKSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvYWRCYWxhbmNlciA9ICEhYXBwSWQubG9hZEJhbGFuY2VyO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlY3JldEtleSA9IGFwcElkLnNlY3JldEtleTtcclxuICAgICAgICAgICAgICAgICAgICBhcHBJZCA9IGFwcElkLmFwcElkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IFBvY2tldFByb3ZpZGVyKG5ldHdvcmssIGFwcElkLCBzZWNyZXRLZXksIGxvYWRCYWxhbmNlcikpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgeyBjb25zb2xlLmxvZyhlcnJvcik7IH1cclxuICAgICAgICB9XHJcbiAgICAqL1xyXG4gICAgaWYgKGFsbG93U2VydmljZShcInF1aWNrbm9kZVwiKSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCB0b2tlbiA9IG9wdGlvbnMucXVpY2tub2RlO1xyXG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaChuZXcgUXVpY2tOb2RlUHJvdmlkZXIobmV0d29yaywgdG9rZW4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgIH1cclxuICAgIGFzc2VydChwcm92aWRlcnMubGVuZ3RoLCBcInVuc3VwcG9ydGVkIGRlZmF1bHQgbmV0d29ya1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgb3BlcmF0aW9uOiBcImdldERlZmF1bHRQcm92aWRlclwiXHJcbiAgICB9KTtcclxuICAgIC8vIE5vIG5lZWQgZm9yIGEgRmFsbGJhY2tQcm92aWRlclxyXG4gICAgaWYgKHByb3ZpZGVycy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICByZXR1cm4gcHJvdmlkZXJzWzBdO1xyXG4gICAgfVxyXG4gICAgLy8gV2UgdXNlIHRoZSBmbG9vciBiZWNhdXNlIHB1YmxpYyB0aGlyZC1wYXJ0eSBwcm92aWRlcnMgY2FuIGJlIHVucmVsaWFibGUsXHJcbiAgICAvLyBzbyBhIGxvdyBudW1iZXIgb2YgcHJvdmlkZXJzIHdpdGggYSBsYXJnZSBxdW9ydW0gd2lsbCBmYWlsIHRvbyBvZnRlblxyXG4gICAgbGV0IHF1b3J1bSA9IE1hdGguZmxvb3IocHJvdmlkZXJzLmxlbmd0aCAvIDIpO1xyXG4gICAgaWYgKHF1b3J1bSA+IDIpIHtcclxuICAgICAgICBxdW9ydW0gPSAyO1xyXG4gICAgfVxyXG4gICAgLy8gVGVzdG5ldHMgZG9uJ3QgbmVlZCBhcyBzdHJvbmcgYSBzZWN1cml0eSBnYXVyYW50ZWUgYW5kIHNwZWVkIGlzXHJcbiAgICAvLyBtb3JlIHVzZWZ1bCBkdXJpbmcgdGVzdGluZ1xyXG4gICAgaWYgKHN0YXRpY05ldHdvcmsgJiYgVGVzdG5ldHMuaW5kZXhPZihzdGF0aWNOZXR3b3JrLm5hbWUpICE9PSAtMSkge1xyXG4gICAgICAgIHF1b3J1bSA9IDE7XHJcbiAgICB9XHJcbiAgICAvLyBQcm92aWRlZCBvdmVycmlkZSBxb3J1bSB0YWtlcyBwcmlvcml0eVxyXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5xdW9ydW0pIHtcclxuICAgICAgICBxdW9ydW0gPSBvcHRpb25zLnF1b3J1bTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgRmFsbGJhY2tQcm92aWRlcihwcm92aWRlcnMsIHVuZGVmaW5lZCwgeyBxdW9ydW0gfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdC1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/default-provider.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/ens-resolver.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/ens-resolver.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasicMulticoinProviderPlugin: () => (/* binding */ BasicMulticoinProviderPlugin),\n/* harmony export */   EnsResolver: () => (/* binding */ EnsResolver),\n/* harmony export */   MulticoinProviderPlugin: () => (/* binding */ MulticoinProviderPlugin)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../address/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/constants/index.js\");\n/* harmony import */ var _contract_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contract/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/contract/index.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../hash/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/**\r\n *  ENS is a service which allows easy-to-remember names to map to\r\n *  network addresses.\r\n *\r\n *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]\r\n */\r\n\r\n\r\n\r\n\r\n\r\n// @TODO: This should use the fetch-data:ipfs gateway\r\n// Trim off the ipfs:// prefix and return the default gateway URL\r\nfunction getIpfsLink(link) {\r\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\r\n        link = link.substring(12);\r\n    }\r\n    else if (link.match(/^ipfs:\\/\\//i)) {\r\n        link = link.substring(7);\r\n    }\r\n    else {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported IPFS format\", \"link\", link);\r\n    }\r\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\r\n}\r\n;\r\n;\r\n/**\r\n *  A provider plugin super-class for processing multicoin address types.\r\n */\r\nclass MulticoinProviderPlugin {\r\n    /**\r\n     *  The name.\r\n     */\r\n    name;\r\n    /**\r\n     *  Creates a new **MulticoinProviderPluing** for %%name%%.\r\n     */\r\n    constructor(name) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { name });\r\n    }\r\n    connect(proivder) {\r\n        return this;\r\n    }\r\n    /**\r\n     *  Returns ``true`` if %%coinType%% is supported by this plugin.\r\n     */\r\n    supportsCoinType(coinType) {\r\n        return false;\r\n    }\r\n    /**\r\n     *  Resolves to the encoded %%address%% for %%coinType%%.\r\n     */\r\n    async encodeAddress(coinType, address) {\r\n        throw new Error(\"unsupported coin\");\r\n    }\r\n    /**\r\n     *  Resolves to the decoded %%data%% for %%coinType%%.\r\n     */\r\n    async decodeAddress(coinType, data) {\r\n        throw new Error(\"unsupported coin\");\r\n    }\r\n}\r\nconst BasicMulticoinPluginId = \"org.ethers.plugins.provider.BasicMulticoin\";\r\n/**\r\n *  A **BasicMulticoinProviderPlugin** provides service for common\r\n *  coin types, which do not require additional libraries to encode or\r\n *  decode.\r\n */\r\nclass BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {\r\n    /**\r\n     *  Creates a new **BasicMulticoinProviderPlugin**.\r\n     */\r\n    constructor() {\r\n        super(BasicMulticoinPluginId);\r\n    }\r\n}\r\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\r\nconst matchers = [\r\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\r\n    new RegExp(\"^(data):(.*)$\", \"i\"),\r\n    matcherIpfs,\r\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\r\n];\r\n/**\r\n *  A connected object to a resolved ENS name resolver, which can be\r\n *  used to query additional details.\r\n */\r\nclass EnsResolver {\r\n    /**\r\n     *  The connected provider.\r\n     */\r\n    provider;\r\n    /**\r\n     *  The address of the resolver.\r\n     */\r\n    address;\r\n    /**\r\n     *  The name this resolver was resolved against.\r\n     */\r\n    name;\r\n    // For EIP-2544 names, the ancestor that provided the resolver\r\n    #supports2544;\r\n    #resolver;\r\n    constructor(provider, address, name) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { provider, address, name });\r\n        this.#supports2544 = null;\r\n        this.#resolver = new _contract_index_js__WEBPACK_IMPORTED_MODULE_1__.Contract(address, [\r\n            \"function supportsInterface(bytes4) view returns (bool)\",\r\n            \"function resolve(bytes, bytes) view returns (bytes)\",\r\n            \"function addr(bytes32) view returns (address)\",\r\n            \"function addr(bytes32, uint) view returns (bytes)\",\r\n            \"function text(bytes32, string) view returns (string)\",\r\n            \"function contenthash(bytes32) view returns (bytes)\",\r\n        ], provider);\r\n    }\r\n    /**\r\n     *  Resolves to true if the resolver supports wildcard resolution.\r\n     */\r\n    async supportsWildcard() {\r\n        if (this.#supports2544 == null) {\r\n            this.#supports2544 = (async () => {\r\n                try {\r\n                    return await this.#resolver.supportsInterface(\"0x9061b923\");\r\n                }\r\n                catch (error) {\r\n                    // Wildcard resolvers must understand supportsInterface\r\n                    // and return true.\r\n                    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\r\n                        return false;\r\n                    }\r\n                    // Let future attempts try again...\r\n                    this.#supports2544 = null;\r\n                    throw error;\r\n                }\r\n            })();\r\n        }\r\n        return await this.#supports2544;\r\n    }\r\n    async #fetch(funcName, params) {\r\n        params = (params || []).slice();\r\n        const iface = this.#resolver.interface;\r\n        // The first parameters is always the nodehash\r\n        params.unshift((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_2__.namehash)(this.name));\r\n        let fragment = null;\r\n        if (await this.supportsWildcard()) {\r\n            fragment = iface.getFunction(funcName);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(fragment, \"missing fragment\", \"UNKNOWN_ERROR\", {\r\n                info: { funcName }\r\n            });\r\n            params = [\r\n                (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_2__.dnsEncode)(this.name, 255),\r\n                iface.encodeFunctionData(fragment, params)\r\n            ];\r\n            funcName = \"resolve(bytes,bytes)\";\r\n        }\r\n        params.push({\r\n            enableCcipRead: true\r\n        });\r\n        try {\r\n            const result = await this.#resolver[funcName](...params);\r\n            if (fragment) {\r\n                return iface.decodeFunctionResult(fragment, result)[0];\r\n            }\r\n            return result;\r\n        }\r\n        catch (error) {\r\n            if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\r\n                throw error;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     *  Resolves to the address for %%coinType%% or null if the\r\n     *  provided %%coinType%% has not been configured.\r\n     */\r\n    async getAddress(coinType) {\r\n        if (coinType == null) {\r\n            coinType = 60;\r\n        }\r\n        if (coinType === 60) {\r\n            try {\r\n                const result = await this.#fetch(\"addr(bytes32)\");\r\n                // No address\r\n                if (result == null || result === _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.ZeroAddress) {\r\n                    return null;\r\n                }\r\n                return result;\r\n            }\r\n            catch (error) {\r\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\r\n                    return null;\r\n                }\r\n                throw error;\r\n            }\r\n        }\r\n        // Try decoding its EVM canonical chain as an EVM chain address first\r\n        if (coinType >= 0 && coinType < 0x80000000) {\r\n            let ethCoinType = coinType + 0x80000000;\r\n            const data = await this.#fetch(\"addr(bytes32,uint)\", [ethCoinType]);\r\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(data, 20)) {\r\n                return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.getAddress)(data);\r\n            }\r\n        }\r\n        let coinPlugin = null;\r\n        for (const plugin of this.provider.plugins) {\r\n            if (!(plugin instanceof MulticoinProviderPlugin)) {\r\n                continue;\r\n            }\r\n            if (plugin.supportsCoinType(coinType)) {\r\n                coinPlugin = plugin;\r\n                break;\r\n            }\r\n        }\r\n        if (coinPlugin == null) {\r\n            return null;\r\n        }\r\n        // keccak256(\"addr(bytes32,uint256\")\r\n        const data = await this.#fetch(\"addr(bytes32,uint)\", [coinType]);\r\n        // No address\r\n        if (data == null || data === \"0x\") {\r\n            return null;\r\n        }\r\n        // Compute the address\r\n        const address = await coinPlugin.decodeAddress(coinType, data);\r\n        if (address != null) {\r\n            return address;\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid coin data`, \"UNSUPPORTED_OPERATION\", {\r\n            operation: `getAddress(${coinType})`,\r\n            info: { coinType, data }\r\n        });\r\n    }\r\n    /**\r\n     *  Resolves to the EIP-634 text record for %%key%%, or ``null``\r\n     *  if unconfigured.\r\n     */\r\n    async getText(key) {\r\n        const data = await this.#fetch(\"text(bytes32,string)\", [key]);\r\n        if (data == null || data === \"0x\") {\r\n            return null;\r\n        }\r\n        return data;\r\n    }\r\n    /**\r\n     *  Rsolves to the content-hash or ``null`` if unconfigured.\r\n     */\r\n    async getContentHash() {\r\n        // keccak256(\"contenthash()\")\r\n        const data = await this.#fetch(\"contenthash(bytes32)\");\r\n        // No contenthash\r\n        if (data == null || data === \"0x\") {\r\n            return null;\r\n        }\r\n        // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)\r\n        const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\r\n        if (ipfs) {\r\n            const scheme = (ipfs[1] === \"e3010170\") ? \"ipfs\" : \"ipns\";\r\n            const length = parseInt(ipfs[4], 16);\r\n            if (ipfs[5].length === length * 2) {\r\n                return `${scheme}:/\\/${(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.encodeBase58)(\"0x\" + ipfs[2])}`;\r\n            }\r\n        }\r\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\r\n        const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);\r\n        if (swarm && swarm[1].length === 64) {\r\n            return `bzz:/\\/${swarm[1]}`;\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid or unsupported content hash data`, \"UNSUPPORTED_OPERATION\", {\r\n            operation: \"getContentHash()\",\r\n            info: { data }\r\n        });\r\n    }\r\n    /**\r\n     *  Resolves to the avatar url or ``null`` if the avatar is either\r\n     *  unconfigured or incorrectly configured (e.g. references an NFT\r\n     *  not owned by the address).\r\n     *\r\n     *  If diagnosing issues with configurations, the [[_getAvatar]]\r\n     *  method may be useful.\r\n     */\r\n    async getAvatar() {\r\n        const avatar = await this._getAvatar();\r\n        return avatar.url;\r\n    }\r\n    /**\r\n     *  When resolving an avatar, there are many steps involved, such\r\n     *  fetching metadata and possibly validating ownership of an\r\n     *  NFT.\r\n     *\r\n     *  This method can be used to examine each step and the value it\r\n     *  was working from.\r\n     */\r\n    async _getAvatar() {\r\n        const linkage = [{ type: \"name\", value: this.name }];\r\n        try {\r\n            // test data for ricmoo.eth\r\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\r\n            const avatar = await this.getText(\"avatar\");\r\n            if (avatar == null) {\r\n                linkage.push({ type: \"!avatar\", value: \"\" });\r\n                return { url: null, linkage };\r\n            }\r\n            linkage.push({ type: \"avatar\", value: avatar });\r\n            for (let i = 0; i < matchers.length; i++) {\r\n                const match = avatar.match(matchers[i]);\r\n                if (match == null) {\r\n                    continue;\r\n                }\r\n                const scheme = match[1].toLowerCase();\r\n                switch (scheme) {\r\n                    case \"https\":\r\n                    case \"data\":\r\n                        linkage.push({ type: \"url\", value: avatar });\r\n                        return { linkage, url: avatar };\r\n                    case \"ipfs\": {\r\n                        const url = getIpfsLink(avatar);\r\n                        linkage.push({ type: \"ipfs\", value: avatar });\r\n                        linkage.push({ type: \"url\", value: url });\r\n                        return { linkage, url };\r\n                    }\r\n                    case \"erc721\":\r\n                    case \"erc1155\": {\r\n                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\r\n                        const selector = (scheme === \"erc721\") ? \"tokenURI(uint256)\" : \"uri(uint256)\";\r\n                        linkage.push({ type: scheme, value: avatar });\r\n                        // The owner of this name\r\n                        const owner = await this.getAddress();\r\n                        if (owner == null) {\r\n                            linkage.push({ type: \"!owner\", value: \"\" });\r\n                            return { url: null, linkage };\r\n                        }\r\n                        const comps = (match[2] || \"\").split(\"/\");\r\n                        if (comps.length !== 2) {\r\n                            linkage.push({ type: `!${scheme}caip`, value: (match[2] || \"\") });\r\n                            return { url: null, linkage };\r\n                        }\r\n                        const tokenId = comps[1];\r\n                        const contract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_1__.Contract(comps[0], [\r\n                            // ERC-721\r\n                            \"function tokenURI(uint) view returns (string)\",\r\n                            \"function ownerOf(uint) view returns (address)\",\r\n                            // ERC-1155\r\n                            \"function uri(uint) view returns (string)\",\r\n                            \"function balanceOf(address, uint256) view returns (uint)\"\r\n                        ], this.provider);\r\n                        // Check that this account owns the token\r\n                        if (scheme === \"erc721\") {\r\n                            const tokenOwner = await contract.ownerOf(tokenId);\r\n                            if (owner !== tokenOwner) {\r\n                                linkage.push({ type: \"!owner\", value: tokenOwner });\r\n                                return { url: null, linkage };\r\n                            }\r\n                            linkage.push({ type: \"owner\", value: tokenOwner });\r\n                        }\r\n                        else if (scheme === \"erc1155\") {\r\n                            const balance = await contract.balanceOf(owner, tokenId);\r\n                            if (!balance) {\r\n                                linkage.push({ type: \"!balance\", value: \"0\" });\r\n                                return { url: null, linkage };\r\n                            }\r\n                            linkage.push({ type: \"balance\", value: balance.toString() });\r\n                        }\r\n                        // Call the token contract for the metadata URL\r\n                        let metadataUrl = await contract[selector](tokenId);\r\n                        if (metadataUrl == null || metadataUrl === \"0x\") {\r\n                            linkage.push({ type: \"!metadata-url\", value: \"\" });\r\n                            return { url: null, linkage };\r\n                        }\r\n                        linkage.push({ type: \"metadata-url-base\", value: metadataUrl });\r\n                        // ERC-1155 allows a generic {id} in the URL\r\n                        if (scheme === \"erc1155\") {\r\n                            metadataUrl = metadataUrl.replace(\"{id}\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeHex)(tokenId, 32).substring(2));\r\n                            linkage.push({ type: \"metadata-url-expanded\", value: metadataUrl });\r\n                        }\r\n                        // Transform IPFS metadata links\r\n                        if (metadataUrl.match(/^ipfs:/i)) {\r\n                            metadataUrl = getIpfsLink(metadataUrl);\r\n                        }\r\n                        linkage.push({ type: \"metadata-url\", value: metadataUrl });\r\n                        // Get the token metadata\r\n                        let metadata = {};\r\n                        const response = await (new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(metadataUrl)).send();\r\n                        response.assertOk();\r\n                        try {\r\n                            metadata = response.bodyJson;\r\n                        }\r\n                        catch (error) {\r\n                            try {\r\n                                linkage.push({ type: \"!metadata\", value: response.bodyText });\r\n                            }\r\n                            catch (error) {\r\n                                const bytes = response.body;\r\n                                if (bytes) {\r\n                                    linkage.push({ type: \"!metadata\", value: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes) });\r\n                                }\r\n                                return { url: null, linkage };\r\n                            }\r\n                            return { url: null, linkage };\r\n                        }\r\n                        if (!metadata) {\r\n                            linkage.push({ type: \"!metadata\", value: \"\" });\r\n                            return { url: null, linkage };\r\n                        }\r\n                        linkage.push({ type: \"metadata\", value: JSON.stringify(metadata) });\r\n                        // Pull the image URL out\r\n                        let imageUrl = metadata.image;\r\n                        if (typeof (imageUrl) !== \"string\") {\r\n                            linkage.push({ type: \"!imageUrl\", value: \"\" });\r\n                            return { url: null, linkage };\r\n                        }\r\n                        if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\r\n                            // Allow\r\n                        }\r\n                        else {\r\n                            // Transform IPFS link to gateway\r\n                            const ipfs = imageUrl.match(matcherIpfs);\r\n                            if (ipfs == null) {\r\n                                linkage.push({ type: \"!imageUrl-ipfs\", value: imageUrl });\r\n                                return { url: null, linkage };\r\n                            }\r\n                            linkage.push({ type: \"imageUrl-ipfs\", value: imageUrl });\r\n                            imageUrl = getIpfsLink(imageUrl);\r\n                        }\r\n                        linkage.push({ type: \"url\", value: imageUrl });\r\n                        return { linkage, url: imageUrl };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch (error) { }\r\n        return { linkage, url: null };\r\n    }\r\n    static async getEnsAddress(provider) {\r\n        const network = await provider.getNetwork();\r\n        const ensPlugin = network.getPlugin(\"org.ethers.plugins.network.Ens\");\r\n        // No ENS...\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(ensPlugin, \"network does not support ENS\", \"UNSUPPORTED_OPERATION\", {\r\n            operation: \"getEnsAddress\", info: { network }\r\n        });\r\n        return ensPlugin.address;\r\n    }\r\n    static async #getResolver(provider, name) {\r\n        const ensAddr = await EnsResolver.getEnsAddress(provider);\r\n        try {\r\n            const contract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_1__.Contract(ensAddr, [\r\n                \"function resolver(bytes32) view returns (address)\"\r\n            ], provider);\r\n            const addr = await contract.resolver((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_2__.namehash)(name), {\r\n                enableCcipRead: true\r\n            });\r\n            if (addr === _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.ZeroAddress) {\r\n                return null;\r\n            }\r\n            return addr;\r\n        }\r\n        catch (error) {\r\n            // ENS registry cannot throw errors on resolver(bytes32),\r\n            // so probably a link error\r\n            throw error;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     *  Resolve to the ENS resolver for %%name%% using %%provider%% or\r\n     *  ``null`` if unconfigured.\r\n     */\r\n    static async fromName(provider, name) {\r\n        let currentName = name;\r\n        while (true) {\r\n            if (currentName === \"\" || currentName === \".\") {\r\n                return null;\r\n            }\r\n            // Optimization since the eth node cannot change and does\r\n            // not have a wildcard resolver\r\n            if (name !== \"eth\" && currentName === \"eth\") {\r\n                return null;\r\n            }\r\n            // Check the current node for a resolver\r\n            const addr = await EnsResolver.#getResolver(provider, currentName);\r\n            // Found a resolver!\r\n            if (addr != null) {\r\n                const resolver = new EnsResolver(provider, addr, name);\r\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\r\n                if (currentName !== name && !(await resolver.supportsWildcard())) {\r\n                    return null;\r\n                }\r\n                return resolver;\r\n            }\r\n            // Get the parent node\r\n            currentName = currentName.split(\".\").slice(1).join(\".\");\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=ens-resolver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvZW5zLXJlc29sdmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lEO0FBQ0c7QUFDSjtBQUNPO0FBQzBGO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYztBQUN0QjtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0IsU0FBUyx5QkFBeUI7QUFDMUQ7QUFDQSw2QkFBNkIsd0RBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3REFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxccHJvdmlkZXJzXFxlbnMtcmVzb2x2ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqICBFTlMgaXMgYSBzZXJ2aWNlIHdoaWNoIGFsbG93cyBlYXN5LXRvLXJlbWVtYmVyIG5hbWVzIHRvIG1hcCB0b1xyXG4gKiAgbmV0d29yayBhZGRyZXNzZXMuXHJcbiAqXHJcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvZW5zLXJlc29sdmVyOkVOUyBSZXNvbHZlciAgW2Fib3V0LWVucy1yc29sdmVyXVxyXG4gKi9cclxuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IFplcm9BZGRyZXNzIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBDb250cmFjdCB9IGZyb20gXCIuLi9jb250cmFjdC9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBkbnNFbmNvZGUsIG5hbWVoYXNoIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIHRvQmVIZXgsIGRlZmluZVByb3BlcnRpZXMsIGVuY29kZUJhc2U1OCwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgaXNFcnJvciwgRmV0Y2hSZXF1ZXN0IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbi8vIEBUT0RPOiBUaGlzIHNob3VsZCB1c2UgdGhlIGZldGNoLWRhdGE6aXBmcyBnYXRld2F5XHJcbi8vIFRyaW0gb2ZmIHRoZSBpcGZzOi8vIHByZWZpeCBhbmQgcmV0dXJuIHRoZSBkZWZhdWx0IGdhdGV3YXkgVVJMXHJcbmZ1bmN0aW9uIGdldElwZnNMaW5rKGxpbmspIHtcclxuICAgIGlmIChsaW5rLm1hdGNoKC9eaXBmczpcXC9cXC9pcGZzXFwvL2kpKSB7XHJcbiAgICAgICAgbGluayA9IGxpbmsuc3Vic3RyaW5nKDEyKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxpbmsubWF0Y2goL15pcGZzOlxcL1xcLy9pKSkge1xyXG4gICAgICAgIGxpbmsgPSBsaW5rLnN1YnN0cmluZyg3KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIElQRlMgZm9ybWF0XCIsIFwibGlua1wiLCBsaW5rKTtcclxuICAgIH1cclxuICAgIHJldHVybiBgaHR0cHM6L1xcL2dhdGV3YXkuaXBmcy5pby9pcGZzLyR7bGlua31gO1xyXG59XHJcbjtcclxuO1xyXG4vKipcclxuICogIEEgcHJvdmlkZXIgcGx1Z2luIHN1cGVyLWNsYXNzIGZvciBwcm9jZXNzaW5nIG11bHRpY29pbiBhZGRyZXNzIHR5cGVzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE11bHRpY29pblByb3ZpZGVyUGx1Z2luIHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBuYW1lLlxyXG4gICAgICovXHJcbiAgICBuYW1lO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk11bHRpY29pblByb3ZpZGVyUGx1aW5nKiogZm9yICUlbmFtZSUlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG5hbWUgfSk7XHJcbiAgICB9XHJcbiAgICBjb25uZWN0KHByb2l2ZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUlY29pblR5cGUlJSBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBwbHVnaW4uXHJcbiAgICAgKi9cclxuICAgIHN1cHBvcnRzQ29pblR5cGUoY29pblR5cGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgZW5jb2RlZCAlJWFkZHJlc3MlJSBmb3IgJSVjb2luVHlwZSUlLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBlbmNvZGVBZGRyZXNzKGNvaW5UeXBlLCBhZGRyZXNzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgY29pblwiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBkZWNvZGVkICUlZGF0YSUlIGZvciAlJWNvaW5UeXBlJSUuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGRlY29kZUFkZHJlc3MoY29pblR5cGUsIGRhdGEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBjb2luXCIpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IEJhc2ljTXVsdGljb2luUGx1Z2luSWQgPSBcIm9yZy5ldGhlcnMucGx1Z2lucy5wcm92aWRlci5CYXNpY011bHRpY29pblwiO1xyXG4vKipcclxuICogIEEgKipCYXNpY011bHRpY29pblByb3ZpZGVyUGx1Z2luKiogcHJvdmlkZXMgc2VydmljZSBmb3IgY29tbW9uXHJcbiAqICBjb2luIHR5cGVzLCB3aGljaCBkbyBub3QgcmVxdWlyZSBhZGRpdGlvbmFsIGxpYnJhcmllcyB0byBlbmNvZGUgb3JcclxuICogIGRlY29kZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBCYXNpY011bHRpY29pblByb3ZpZGVyUGx1Z2luIGV4dGVuZHMgTXVsdGljb2luUHJvdmlkZXJQbHVnaW4ge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4qKi5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoQmFzaWNNdWx0aWNvaW5QbHVnaW5JZCk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgbWF0Y2hlcklwZnMgPSBuZXcgUmVnRXhwKFwiXihpcGZzKTovXFwvKC4qKSRcIiwgXCJpXCIpO1xyXG5jb25zdCBtYXRjaGVycyA9IFtcclxuICAgIG5ldyBSZWdFeHAoXCJeKGh0dHBzKTovXFwvKC4qKSRcIiwgXCJpXCIpLFxyXG4gICAgbmV3IFJlZ0V4cChcIl4oZGF0YSk6KC4qKSRcIiwgXCJpXCIpLFxyXG4gICAgbWF0Y2hlcklwZnMsXHJcbiAgICBuZXcgUmVnRXhwKFwiXmVpcDE1NTpbMC05XSsvKGVyY1swLTldKyk6KC4qKSRcIiwgXCJpXCIpLFxyXG5dO1xyXG4vKipcclxuICogIEEgY29ubmVjdGVkIG9iamVjdCB0byBhIHJlc29sdmVkIEVOUyBuYW1lIHJlc29sdmVyLCB3aGljaCBjYW4gYmVcclxuICogIHVzZWQgdG8gcXVlcnkgYWRkaXRpb25hbCBkZXRhaWxzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEVuc1Jlc29sdmVyIHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBjb25uZWN0ZWQgcHJvdmlkZXIuXHJcbiAgICAgKi9cclxuICAgIHByb3ZpZGVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGFkZHJlc3Mgb2YgdGhlIHJlc29sdmVyLlxyXG4gICAgICovXHJcbiAgICBhZGRyZXNzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG5hbWUgdGhpcyByZXNvbHZlciB3YXMgcmVzb2x2ZWQgYWdhaW5zdC5cclxuICAgICAqL1xyXG4gICAgbmFtZTtcclxuICAgIC8vIEZvciBFSVAtMjU0NCBuYW1lcywgdGhlIGFuY2VzdG9yIHRoYXQgcHJvdmlkZWQgdGhlIHJlc29sdmVyXHJcbiAgICAjc3VwcG9ydHMyNTQ0O1xyXG4gICAgI3Jlc29sdmVyO1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGFkZHJlc3MsIG5hbWUpIHtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcHJvdmlkZXIsIGFkZHJlc3MsIG5hbWUgfSk7XHJcbiAgICAgICAgdGhpcy4jc3VwcG9ydHMyNTQ0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLiNyZXNvbHZlciA9IG5ldyBDb250cmFjdChhZGRyZXNzLCBbXHJcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gc3VwcG9ydHNJbnRlcmZhY2UoYnl0ZXM0KSB2aWV3IHJldHVybnMgKGJvb2wpXCIsXHJcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcmVzb2x2ZShieXRlcywgYnl0ZXMpIHZpZXcgcmV0dXJucyAoYnl0ZXMpXCIsXHJcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gYWRkcihieXRlczMyKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCIsXHJcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gYWRkcihieXRlczMyLCB1aW50KSB2aWV3IHJldHVybnMgKGJ5dGVzKVwiLFxyXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHRleHQoYnl0ZXMzMiwgc3RyaW5nKSB2aWV3IHJldHVybnMgKHN0cmluZylcIixcclxuICAgICAgICAgICAgXCJmdW5jdGlvbiBjb250ZW50aGFzaChieXRlczMyKSB2aWV3IHJldHVybnMgKGJ5dGVzKVwiLFxyXG4gICAgICAgIF0sIHByb3ZpZGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIHRvIHRydWUgaWYgdGhlIHJlc29sdmVyIHN1cHBvcnRzIHdpbGRjYXJkIHJlc29sdXRpb24uXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHN1cHBvcnRzV2lsZGNhcmQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuI3N1cHBvcnRzMjU0NCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuI3N1cHBvcnRzMjU0NCA9IChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNyZXNvbHZlci5zdXBwb3J0c0ludGVyZmFjZShcIjB4OTA2MWI5MjNcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXaWxkY2FyZCByZXNvbHZlcnMgbXVzdCB1bmRlcnN0YW5kIHN1cHBvcnRzSW50ZXJmYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHJldHVybiB0cnVlLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTGV0IGZ1dHVyZSBhdHRlbXB0cyB0cnkgYWdhaW4uLi5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNzdXBwb3J0czI1NDQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jc3VwcG9ydHMyNTQ0O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgI2ZldGNoKGZ1bmNOYW1lLCBwYXJhbXMpIHtcclxuICAgICAgICBwYXJhbXMgPSAocGFyYW1zIHx8IFtdKS5zbGljZSgpO1xyXG4gICAgICAgIGNvbnN0IGlmYWNlID0gdGhpcy4jcmVzb2x2ZXIuaW50ZXJmYWNlO1xyXG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJhbWV0ZXJzIGlzIGFsd2F5cyB0aGUgbm9kZWhhc2hcclxuICAgICAgICBwYXJhbXMudW5zaGlmdChuYW1laGFzaCh0aGlzLm5hbWUpKTtcclxuICAgICAgICBsZXQgZnJhZ21lbnQgPSBudWxsO1xyXG4gICAgICAgIGlmIChhd2FpdCB0aGlzLnN1cHBvcnRzV2lsZGNhcmQoKSkge1xyXG4gICAgICAgICAgICBmcmFnbWVudCA9IGlmYWNlLmdldEZ1bmN0aW9uKGZ1bmNOYW1lKTtcclxuICAgICAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm1pc3NpbmcgZnJhZ21lbnRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHtcclxuICAgICAgICAgICAgICAgIGluZm86IHsgZnVuY05hbWUgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcGFyYW1zID0gW1xyXG4gICAgICAgICAgICAgICAgZG5zRW5jb2RlKHRoaXMubmFtZSwgMjU1KSxcclxuICAgICAgICAgICAgICAgIGlmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgcGFyYW1zKVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBmdW5jTmFtZSA9IFwicmVzb2x2ZShieXRlcyxieXRlcylcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyYW1zLnB1c2goe1xyXG4gICAgICAgICAgICBlbmFibGVDY2lwUmVhZDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI3Jlc29sdmVyW2Z1bmNOYW1lXSguLi5wYXJhbXMpO1xyXG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpZmFjZS5kZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgcmVzdWx0KVswXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBhZGRyZXNzIGZvciAlJWNvaW5UeXBlJSUgb3IgbnVsbCBpZiB0aGVcclxuICAgICAqICBwcm92aWRlZCAlJWNvaW5UeXBlJSUgaGFzIG5vdCBiZWVuIGNvbmZpZ3VyZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldEFkZHJlc3MoY29pblR5cGUpIHtcclxuICAgICAgICBpZiAoY29pblR5cGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb2luVHlwZSA9IDYwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29pblR5cGUgPT09IDYwKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNmZXRjaChcImFkZHIoYnl0ZXMzMilcIik7XHJcbiAgICAgICAgICAgICAgICAvLyBObyBhZGRyZXNzXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcmVzdWx0ID09PSBaZXJvQWRkcmVzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcnkgZGVjb2RpbmcgaXRzIEVWTSBjYW5vbmljYWwgY2hhaW4gYXMgYW4gRVZNIGNoYWluIGFkZHJlc3MgZmlyc3RcclxuICAgICAgICBpZiAoY29pblR5cGUgPj0gMCAmJiBjb2luVHlwZSA8IDB4ODAwMDAwMDApIHtcclxuICAgICAgICAgICAgbGV0IGV0aENvaW5UeXBlID0gY29pblR5cGUgKyAweDgwMDAwMDAwO1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJhZGRyKGJ5dGVzMzIsdWludClcIiwgW2V0aENvaW5UeXBlXSk7XHJcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhkYXRhLCAyMCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRBZGRyZXNzKGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjb2luUGx1Z2luID0gbnVsbDtcclxuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLnByb3ZpZGVyLnBsdWdpbnMpIHtcclxuICAgICAgICAgICAgaWYgKCEocGx1Z2luIGluc3RhbmNlb2YgTXVsdGljb2luUHJvdmlkZXJQbHVnaW4pKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocGx1Z2luLnN1cHBvcnRzQ29pblR5cGUoY29pblR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb2luUGx1Z2luID0gcGx1Z2luO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvaW5QbHVnaW4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8ga2VjY2FrMjU2KFwiYWRkcihieXRlczMyLHVpbnQyNTZcIilcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJhZGRyKGJ5dGVzMzIsdWludClcIiwgW2NvaW5UeXBlXSk7XHJcbiAgICAgICAgLy8gTm8gYWRkcmVzc1xyXG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb21wdXRlIHRoZSBhZGRyZXNzXHJcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IGNvaW5QbHVnaW4uZGVjb2RlQWRkcmVzcyhjb2luVHlwZSwgZGF0YSk7XHJcbiAgICAgICAgaWYgKGFkZHJlc3MgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgaW52YWxpZCBjb2luIGRhdGFgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogYGdldEFkZHJlc3MoJHtjb2luVHlwZX0pYCxcclxuICAgICAgICAgICAgaW5mbzogeyBjb2luVHlwZSwgZGF0YSB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgRUlQLTYzNCB0ZXh0IHJlY29yZCBmb3IgJSVrZXklJSwgb3IgYGBudWxsYGBcclxuICAgICAqICBpZiB1bmNvbmZpZ3VyZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldFRleHQoa2V5KSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZldGNoKFwidGV4dChieXRlczMyLHN0cmluZylcIiwgW2tleV0pO1xyXG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJzb2x2ZXMgdG8gdGhlIGNvbnRlbnQtaGFzaCBvciBgYG51bGxgYCBpZiB1bmNvbmZpZ3VyZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldENvbnRlbnRIYXNoKCkge1xyXG4gICAgICAgIC8vIGtlY2NhazI1NihcImNvbnRlbnRoYXNoKClcIilcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJjb250ZW50aGFzaChieXRlczMyKVwiKTtcclxuICAgICAgICAvLyBObyBjb250ZW50aGFzaFxyXG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJUEZTIChDSUQ6IDEsIFR5cGU6IDcwPURBRy1QQiwgNzI9bGlicDJwLWtleSlcclxuICAgICAgICBjb25zdCBpcGZzID0gZGF0YS5tYXRjaCgvXjB4KGUzMDEwMTcwfGU1MDEwMTcyKSgoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKSkkLyk7XHJcbiAgICAgICAgaWYgKGlwZnMpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gKGlwZnNbMV0gPT09IFwiZTMwMTAxNzBcIikgPyBcImlwZnNcIiA6IFwiaXBuc1wiO1xyXG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChpcGZzWzRdLCAxNik7XHJcbiAgICAgICAgICAgIGlmIChpcGZzWzVdLmxlbmd0aCA9PT0gbGVuZ3RoICogMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3NjaGVtZX06L1xcLyR7ZW5jb2RlQmFzZTU4KFwiMHhcIiArIGlwZnNbMl0pfWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3dhcm0gKENJRDogMSwgVHlwZTogc3dhcm0tbWFuaWZlc3Q7IGhhc2gvbGVuZ3RoIGhhcmQtY29kZWQgdG8ga2VjY2FrMjU2LzMyKVxyXG4gICAgICAgIGNvbnN0IHN3YXJtID0gZGF0YS5tYXRjaCgvXjB4ZTQwMTAxZmEwMTFiMjAoWzAtOWEtZl0qKSQvKTtcclxuICAgICAgICBpZiAoc3dhcm0gJiYgc3dhcm1bMV0ubGVuZ3RoID09PSA2NCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYGJ6ejovXFwvJHtzd2FybVsxXX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGNvbnRlbnQgaGFzaCBkYXRhYCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0Q29udGVudEhhc2goKVwiLFxyXG4gICAgICAgICAgICBpbmZvOiB7IGRhdGEgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGF2YXRhciB1cmwgb3IgYGBudWxsYGAgaWYgdGhlIGF2YXRhciBpcyBlaXRoZXJcclxuICAgICAqICB1bmNvbmZpZ3VyZWQgb3IgaW5jb3JyZWN0bHkgY29uZmlndXJlZCAoZS5nLiByZWZlcmVuY2VzIGFuIE5GVFxyXG4gICAgICogIG5vdCBvd25lZCBieSB0aGUgYWRkcmVzcykuXHJcbiAgICAgKlxyXG4gICAgICogIElmIGRpYWdub3NpbmcgaXNzdWVzIHdpdGggY29uZmlndXJhdGlvbnMsIHRoZSBbW19nZXRBdmF0YXJdXVxyXG4gICAgICogIG1ldGhvZCBtYXkgYmUgdXNlZnVsLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRBdmF0YXIoKSB7XHJcbiAgICAgICAgY29uc3QgYXZhdGFyID0gYXdhaXQgdGhpcy5fZ2V0QXZhdGFyKCk7XHJcbiAgICAgICAgcmV0dXJuIGF2YXRhci51cmw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBXaGVuIHJlc29sdmluZyBhbiBhdmF0YXIsIHRoZXJlIGFyZSBtYW55IHN0ZXBzIGludm9sdmVkLCBzdWNoXHJcbiAgICAgKiAgZmV0Y2hpbmcgbWV0YWRhdGEgYW5kIHBvc3NpYmx5IHZhbGlkYXRpbmcgb3duZXJzaGlwIG9mIGFuXHJcbiAgICAgKiAgTkZULlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byBleGFtaW5lIGVhY2ggc3RlcCBhbmQgdGhlIHZhbHVlIGl0XHJcbiAgICAgKiAgd2FzIHdvcmtpbmcgZnJvbS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgX2dldEF2YXRhcigpIHtcclxuICAgICAgICBjb25zdCBsaW5rYWdlID0gW3sgdHlwZTogXCJuYW1lXCIsIHZhbHVlOiB0aGlzLm5hbWUgfV07XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gdGVzdCBkYXRhIGZvciByaWNtb28uZXRoXHJcbiAgICAgICAgICAgIC8vY29uc3QgYXZhdGFyID0gXCJlaXAxNTU6MS9lcmM3MjE6MHgyNjUzODVjN2Y0MTMyMjI4QTBkNTRFQjFBOWU3NDYwYjkxYzBjQzY4LzI5MjMzXCI7XHJcbiAgICAgICAgICAgIGNvbnN0IGF2YXRhciA9IGF3YWl0IHRoaXMuZ2V0VGV4dChcImF2YXRhclwiKTtcclxuICAgICAgICAgICAgaWYgKGF2YXRhciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFhdmF0YXJcIiwgdmFsdWU6IFwiXCIgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImF2YXRhclwiLCB2YWx1ZTogYXZhdGFyIH0pO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGF2YXRhci5tYXRjaChtYXRjaGVyc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2NoZW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImh0dHBzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgdmFsdWU6IGF2YXRhciB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBhdmF0YXIgfTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaXBmc1wiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGdldElwZnNMaW5rKGF2YXRhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiaXBmc1wiLCB2YWx1ZTogYXZhdGFyIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCB2YWx1ZTogdXJsIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmwgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzcyMVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcmMxMTU1XCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBFUkMgdHlwZSwgdXNlIHRva2VuVVJJKHVpbnQyNTYpIG9yIHVybCh1aW50MjU2KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IChzY2hlbWUgPT09IFwiZXJjNzIxXCIpID8gXCJ0b2tlblVSSSh1aW50MjU2KVwiIDogXCJ1cmkodWludDI1NilcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogc2NoZW1lLCB2YWx1ZTogYXZhdGFyIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3duZXIgb2YgdGhpcyBuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG93bmVyID0gYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFvd25lclwiLCB2YWx1ZTogXCJcIiB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBzID0gKG1hdGNoWzJdIHx8IFwiXCIpLnNwbGl0KFwiL1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogYCEke3NjaGVtZX1jYWlwYCwgdmFsdWU6IChtYXRjaFsyXSB8fCBcIlwiKSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuSWQgPSBjb21wc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoY29tcHNbMF0sIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVSQy03MjFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gdG9rZW5VUkkodWludCkgdmlldyByZXR1cm5zIChzdHJpbmcpXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIG93bmVyT2YodWludCkgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTExNTVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gdXJpKHVpbnQpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiBiYWxhbmNlT2YoYWRkcmVzcywgdWludDI1NikgdmlldyByZXR1cm5zICh1aW50KVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sIHRoaXMucHJvdmlkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoaXMgYWNjb3VudCBvd25zIHRoZSB0b2tlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1lID09PSBcImVyYzcyMVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbk93bmVyID0gYXdhaXQgY29udHJhY3Qub3duZXJPZih0b2tlbklkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lciAhPT0gdG9rZW5Pd25lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW93bmVyXCIsIHZhbHVlOiB0b2tlbk93bmVyIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJvd25lclwiLCB2YWx1ZTogdG9rZW5Pd25lciB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgY29udHJhY3QuYmFsYW5jZU9mKG93bmVyLCB0b2tlbklkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmFsYW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWJhbGFuY2VcIiwgdmFsdWU6IFwiMFwiIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJiYWxhbmNlXCIsIHZhbHVlOiBiYWxhbmNlLnRvU3RyaW5nKCkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgdG9rZW4gY29udHJhY3QgZm9yIHRoZSBtZXRhZGF0YSBVUkxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhVXJsID0gYXdhaXQgY29udHJhY3Rbc2VsZWN0b3JdKHRva2VuSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFVcmwgPT0gbnVsbCB8fCBtZXRhZGF0YVVybCA9PT0gXCIweFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YS11cmxcIiwgdmFsdWU6IFwiXCIgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybC1iYXNlXCIsIHZhbHVlOiBtZXRhZGF0YVVybCB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTExNTUgYWxsb3dzIGEgZ2VuZXJpYyB7aWR9IGluIHRoZSBVUkxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJlcmMxMTU1XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhVXJsID0gbWV0YWRhdGFVcmwucmVwbGFjZShcIntpZH1cIiwgdG9CZUhleCh0b2tlbklkLCAzMikuc3Vic3RyaW5nKDIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsLWV4cGFuZGVkXCIsIHZhbHVlOiBtZXRhZGF0YVVybCB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gSVBGUyBtZXRhZGF0YSBsaW5rc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFVcmwubWF0Y2goL15pcGZzOi9pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBnZXRJcGZzTGluayhtZXRhZGF0YVVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmxcIiwgdmFsdWU6IG1ldGFkYXRhVXJsIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRva2VuIG1ldGFkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IChuZXcgRmV0Y2hSZXF1ZXN0KG1ldGFkYXRhVXJsKSkuc2VuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5hc3NlcnRPaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSByZXNwb25zZS5ib2R5SnNvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGFcIiwgdmFsdWU6IHJlc3BvbnNlLmJvZHlUZXh0IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSByZXNwb25zZS5ib2R5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YVwiLCB2YWx1ZTogaGV4bGlmeShieXRlcykgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGFcIiwgdmFsdWU6IFwiXCIgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhXCIsIHZhbHVlOiBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1bGwgdGhlIGltYWdlIFVSTCBvdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltYWdlVXJsID0gbWV0YWRhdGEuaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGltYWdlVXJsKSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhaW1hZ2VVcmxcIiwgdmFsdWU6IFwiXCIgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VVcmwubWF0Y2goL14oaHR0cHM6XFwvXFwvfGRhdGE6KS9pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBJUEZTIGxpbmsgdG8gZ2F0ZXdheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXBmcyA9IGltYWdlVXJsLm1hdGNoKG1hdGNoZXJJcGZzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcGZzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFpbWFnZVVybC1pcGZzXCIsIHZhbHVlOiBpbWFnZVVybCB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiaW1hZ2VVcmwtaXBmc1wiLCB2YWx1ZTogaW1hZ2VVcmwgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVVybCA9IGdldElwZnNMaW5rKGltYWdlVXJsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCB2YWx1ZTogaW1hZ2VVcmwgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogaW1hZ2VVcmwgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IG51bGwgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBnZXRFbnNBZGRyZXNzKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHByb3ZpZGVyLmdldE5ldHdvcmsoKTtcclxuICAgICAgICBjb25zdCBlbnNQbHVnaW4gPSBuZXR3b3JrLmdldFBsdWdpbihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkVuc1wiKTtcclxuICAgICAgICAvLyBObyBFTlMuLi5cclxuICAgICAgICBhc3NlcnQoZW5zUGx1Z2luLCBcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFTlNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0RW5zQWRkcmVzc1wiLCBpbmZvOiB7IG5ldHdvcmsgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBlbnNQbHVnaW4uYWRkcmVzcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyAjZ2V0UmVzb2x2ZXIocHJvdmlkZXIsIG5hbWUpIHtcclxuICAgICAgICBjb25zdCBlbnNBZGRyID0gYXdhaXQgRW5zUmVzb2x2ZXIuZ2V0RW5zQWRkcmVzcyhwcm92aWRlcik7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoZW5zQWRkciwgW1xyXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbiByZXNvbHZlcihieXRlczMyKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCJcclxuICAgICAgICAgICAgXSwgcHJvdmlkZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBhZGRyID0gYXdhaXQgY29udHJhY3QucmVzb2x2ZXIobmFtZWhhc2gobmFtZSksIHtcclxuICAgICAgICAgICAgICAgIGVuYWJsZUNjaXBSZWFkOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoYWRkciA9PT0gWmVyb0FkZHJlc3MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhZGRyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgLy8gRU5TIHJlZ2lzdHJ5IGNhbm5vdCB0aHJvdyBlcnJvcnMgb24gcmVzb2x2ZXIoYnl0ZXMzMiksXHJcbiAgICAgICAgICAgIC8vIHNvIHByb2JhYmx5IGEgbGluayBlcnJvclxyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlIHRvIHRoZSBFTlMgcmVzb2x2ZXIgZm9yICUlbmFtZSUlIHVzaW5nICUlcHJvdmlkZXIlJSBvclxyXG4gICAgICogIGBgbnVsbGBgIGlmIHVuY29uZmlndXJlZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFzeW5jIGZyb21OYW1lKHByb3ZpZGVyLCBuYW1lKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnROYW1lID0gbmFtZTtcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudE5hbWUgPT09IFwiXCIgfHwgY3VycmVudE5hbWUgPT09IFwiLlwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBPcHRpbWl6YXRpb24gc2luY2UgdGhlIGV0aCBub2RlIGNhbm5vdCBjaGFuZ2UgYW5kIGRvZXNcclxuICAgICAgICAgICAgLy8gbm90IGhhdmUgYSB3aWxkY2FyZCByZXNvbHZlclxyXG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gXCJldGhcIiAmJiBjdXJyZW50TmFtZSA9PT0gXCJldGhcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGN1cnJlbnQgbm9kZSBmb3IgYSByZXNvbHZlclxyXG4gICAgICAgICAgICBjb25zdCBhZGRyID0gYXdhaXQgRW5zUmVzb2x2ZXIuI2dldFJlc29sdmVyKHByb3ZpZGVyLCBjdXJyZW50TmFtZSk7XHJcbiAgICAgICAgICAgIC8vIEZvdW5kIGEgcmVzb2x2ZXIhXHJcbiAgICAgICAgICAgIGlmIChhZGRyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gbmV3IEVuc1Jlc29sdmVyKHByb3ZpZGVyLCBhZGRyLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgIC8vIExlZ2FjeSByZXNvbHZlciBmb3VuZCwgdXNpbmcgRUlQLTI1NDQgc28gaXQgaXNuJ3Qgc2FmZSB0byB1c2VcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TmFtZSAhPT0gbmFtZSAmJiAhKGF3YWl0IHJlc29sdmVyLnN1cHBvcnRzV2lsZGNhcmQoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHBhcmVudCBub2RlXHJcbiAgICAgICAgICAgIGN1cnJlbnROYW1lID0gY3VycmVudE5hbWUuc3BsaXQoXCIuXCIpLnNsaWNlKDEpLmpvaW4oXCIuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnMtcmVzb2x2ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/ens-resolver.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/format.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/format.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allowNull: () => (/* binding */ allowNull),\n/* harmony export */   arrayOf: () => (/* binding */ arrayOf),\n/* harmony export */   formatBlock: () => (/* binding */ formatBlock),\n/* harmony export */   formatBoolean: () => (/* binding */ formatBoolean),\n/* harmony export */   formatData: () => (/* binding */ formatData),\n/* harmony export */   formatHash: () => (/* binding */ formatHash),\n/* harmony export */   formatLog: () => (/* binding */ formatLog),\n/* harmony export */   formatReceiptLog: () => (/* binding */ formatReceiptLog),\n/* harmony export */   formatTransactionReceipt: () => (/* binding */ formatTransactionReceipt),\n/* harmony export */   formatTransactionResponse: () => (/* binding */ formatTransactionResponse),\n/* harmony export */   formatUint256: () => (/* binding */ formatUint256),\n/* harmony export */   object: () => (/* binding */ object)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../crypto/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transaction/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/**\r\n *  @_ignore\r\n */\r\n\r\n\r\n\r\n\r\nconst BN_0 = BigInt(0);\r\nfunction allowNull(format, nullValue) {\r\n    return (function (value) {\r\n        if (value == null) {\r\n            return nullValue;\r\n        }\r\n        return format(value);\r\n    });\r\n}\r\nfunction arrayOf(format, allowNull) {\r\n    return ((array) => {\r\n        if (allowNull && array == null) {\r\n            return null;\r\n        }\r\n        if (!Array.isArray(array)) {\r\n            throw new Error(\"not an array\");\r\n        }\r\n        return array.map((i) => format(i));\r\n    });\r\n}\r\n// Requires an object which matches a fleet of other formatters\r\n// Any FormatFunc may return `undefined` to have the value omitted\r\n// from the result object. Calls preserve `this`.\r\nfunction object(format, altNames) {\r\n    return ((value) => {\r\n        const result = {};\r\n        for (const key in format) {\r\n            let srcKey = key;\r\n            if (altNames && key in altNames && !(srcKey in value)) {\r\n                for (const altKey of altNames[key]) {\r\n                    if (altKey in value) {\r\n                        srcKey = altKey;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            try {\r\n                const nv = format[key](value[srcKey]);\r\n                if (nv !== undefined) {\r\n                    result[key] = nv;\r\n                }\r\n            }\r\n            catch (error) {\r\n                const message = (error instanceof Error) ? error.message : \"not-an-error\";\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid value for value.${key} (${message})`, \"BAD_DATA\", { value });\r\n            }\r\n        }\r\n        return result;\r\n    });\r\n}\r\nfunction formatBoolean(value) {\r\n    switch (value) {\r\n        case true:\r\n        case \"true\":\r\n            return true;\r\n        case false:\r\n        case \"false\":\r\n            return false;\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid boolean; ${JSON.stringify(value)}`, \"value\", value);\r\n}\r\nfunction formatData(value) {\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value, true), \"invalid data\", \"value\", value);\r\n    return value;\r\n}\r\nfunction formatHash(value) {\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value, 32), \"invalid hash\", \"value\", value);\r\n    return value;\r\n}\r\nfunction formatUint256(value) {\r\n    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value)) {\r\n        throw new Error(\"invalid uint256\");\r\n    }\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(value, 32);\r\n}\r\nconst _formatLog = object({\r\n    address: _address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress,\r\n    blockHash: formatHash,\r\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\r\n    data: formatData,\r\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\r\n    removed: allowNull(formatBoolean, false),\r\n    topics: arrayOf(formatHash),\r\n    transactionHash: formatHash,\r\n    transactionIndex: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\r\n}, {\r\n    index: [\"logIndex\"]\r\n});\r\nfunction formatLog(value) {\r\n    return _formatLog(value);\r\n}\r\nconst _formatBlock = object({\r\n    hash: allowNull(formatHash),\r\n    parentHash: formatHash,\r\n    parentBeaconBlockRoot: allowNull(formatHash, null),\r\n    number: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\r\n    timestamp: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\r\n    nonce: allowNull(formatData),\r\n    difficulty: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt,\r\n    gasLimit: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt,\r\n    gasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt,\r\n    stateRoot: allowNull(formatHash, null),\r\n    receiptsRoot: allowNull(formatHash, null),\r\n    blobGasUsed: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt, null),\r\n    excessBlobGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt, null),\r\n    miner: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress),\r\n    prevRandao: allowNull(formatHash, null),\r\n    extraData: formatData,\r\n    baseFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)\r\n}, {\r\n    prevRandao: [\"mixHash\"]\r\n});\r\nfunction formatBlock(value) {\r\n    const result = _formatBlock(value);\r\n    result.transactions = value.transactions.map((tx) => {\r\n        if (typeof (tx) === \"string\") {\r\n            return tx;\r\n        }\r\n        return formatTransactionResponse(tx);\r\n    });\r\n    return result;\r\n}\r\nconst _formatReceiptLog = object({\r\n    transactionIndex: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\r\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\r\n    transactionHash: formatHash,\r\n    address: _address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress,\r\n    topics: arrayOf(formatHash),\r\n    data: formatData,\r\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\r\n    blockHash: formatHash,\r\n}, {\r\n    index: [\"logIndex\"]\r\n});\r\nfunction formatReceiptLog(value) {\r\n    return _formatReceiptLog(value);\r\n}\r\nconst _formatTransactionReceipt = object({\r\n    to: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress, null),\r\n    from: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress, null),\r\n    contractAddress: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress, null),\r\n    // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\r\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\r\n    root: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify),\r\n    gasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt,\r\n    blobGasUsed: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt, null),\r\n    logsBloom: allowNull(formatData),\r\n    blockHash: formatHash,\r\n    hash: formatHash,\r\n    logs: arrayOf(formatReceiptLog),\r\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\r\n    //confirmations: allowNull(getNumber, null),\r\n    cumulativeGasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt,\r\n    effectiveGasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt),\r\n    blobGasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt, null),\r\n    status: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber),\r\n    type: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber, 0)\r\n}, {\r\n    effectiveGasPrice: [\"gasPrice\"],\r\n    hash: [\"transactionHash\"],\r\n    index: [\"transactionIndex\"],\r\n});\r\nfunction formatTransactionReceipt(value) {\r\n    return _formatTransactionReceipt(value);\r\n}\r\nfunction formatTransactionResponse(value) {\r\n    // Some clients (TestRPC) do strange things like return 0x0 for the\r\n    // 0 address; correct this to be a real address\r\n    if (value.to && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value.to) === BN_0) {\r\n        value.to = \"0x0000000000000000000000000000000000000000\";\r\n    }\r\n    const result = object({\r\n        hash: formatHash,\r\n        // Some nodes do not return this, usually test nodes (like Ganache)\r\n        index: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber, undefined),\r\n        type: (value) => {\r\n            if (value === \"0x\" || value == null) {\r\n                return 0;\r\n            }\r\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(value);\r\n        },\r\n        accessList: allowNull(_transaction_index_js__WEBPACK_IMPORTED_MODULE_2__.accessListify, null),\r\n        blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),\r\n        authorizationList: allowNull(arrayOf((v) => {\r\n            let sig;\r\n            if (v.signature) {\r\n                sig = v.signature;\r\n            }\r\n            else {\r\n                let yParity = v.yParity;\r\n                if (yParity === \"0x1b\") {\r\n                    yParity = 0;\r\n                }\r\n                else if (yParity === \"0x1c\") {\r\n                    yParity = 1;\r\n                }\r\n                sig = Object.assign({}, v, { yParity });\r\n            }\r\n            return {\r\n                address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(v.address),\r\n                chainId: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(v.chainId),\r\n                nonce: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(v.nonce),\r\n                signature: _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.Signature.from(sig)\r\n            };\r\n        }, false), null),\r\n        blockHash: allowNull(formatHash, null),\r\n        blockNumber: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber, null),\r\n        transactionIndex: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber, null),\r\n        from: _address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress,\r\n        // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set\r\n        gasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt),\r\n        maxPriorityFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt),\r\n        maxFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt),\r\n        maxFeePerBlobGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt, null),\r\n        gasLimit: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt,\r\n        to: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress, null),\r\n        value: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt,\r\n        nonce: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\r\n        data: formatData,\r\n        creates: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress, null),\r\n        chainId: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt, null)\r\n    }, {\r\n        data: [\"input\"],\r\n        gasLimit: [\"gas\"],\r\n        index: [\"transactionIndex\"]\r\n    })(value);\r\n    // If to and creates are empty, populate the creates from the value\r\n    if (result.to == null && result.creates == null) {\r\n        result.creates = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getCreateAddress)(result);\r\n    }\r\n    // @TODO: Check fee data\r\n    // Add an access list to supported transaction types\r\n    if ((value.type === 1 || value.type === 2) && value.accessList == null) {\r\n        result.accessList = [];\r\n    }\r\n    // Compute the signature\r\n    if (value.signature) {\r\n        result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.Signature.from(value.signature);\r\n    }\r\n    else {\r\n        result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.Signature.from(value);\r\n    }\r\n    // Some backends omit ChainId on legacy transactions, but we can compute it\r\n    if (result.chainId == null) {\r\n        const chainId = result.signature.legacyChainId;\r\n        if (chainId != null) {\r\n            result.chainId = chainId;\r\n        }\r\n    }\r\n    // @TODO: check chainID\r\n    /*\r\n    if (value.chainId != null) {\r\n        let chainId = value.chainId;\r\n\r\n        if (isHexString(chainId)) {\r\n            chainId = BigNumber.from(chainId).toNumber();\r\n        }\r\n\r\n        result.chainId = chainId;\r\n\r\n    } else {\r\n        let chainId = value.networkId;\r\n\r\n        // geth-etc returns chainId\r\n        if (chainId == null && result.v == null) {\r\n            chainId = value.chainId;\r\n        }\r\n\r\n        if (isHexString(chainId)) {\r\n            chainId = BigNumber.from(chainId).toNumber();\r\n        }\r\n\r\n        if (typeof(chainId) !== \"number\" && result.v != null) {\r\n            chainId = (result.v - 35) / 2;\r\n            if (chainId < 0) { chainId = 0; }\r\n            chainId = parseInt(chainId);\r\n        }\r\n\r\n        if (typeof(chainId) !== \"number\") { chainId = 0; }\r\n\r\n        result.chainId = chainId;\r\n    }\r\n    */\r\n    // 0x0000... should actually be null\r\n    if (result.blockHash && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(result.blockHash) === BN_0) {\r\n        result.blockHash = null;\r\n    }\r\n    return result;\r\n}\r\n//# sourceMappingURL=format.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvZm9ybWF0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDbUU7QUFDcEI7QUFDUztBQUM2RDtBQUNySDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1REFBTSxtQ0FBbUMsS0FBSyxHQUFHLFFBQVEsa0JBQWtCLE9BQU87QUFDbEc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrREFBYywwQkFBMEIsRUFBRSxzQkFBc0I7QUFDcEU7QUFDTztBQUNQLElBQUksK0RBQWMsQ0FBQyw0REFBVztBQUM5QjtBQUNBO0FBQ087QUFDUCxJQUFJLCtEQUFjLENBQUMsNERBQVc7QUFDOUI7QUFDQTtBQUNPO0FBQ1AsU0FBUyw0REFBVztBQUNwQjtBQUNBO0FBQ0EsV0FBVyw2REFBWTtBQUN2QjtBQUNBO0FBQ0EsYUFBYSx5REFBVTtBQUN2QjtBQUNBLGlCQUFpQixzREFBUztBQUMxQjtBQUNBLFdBQVcsc0RBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFTO0FBQy9CLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQVM7QUFDckIsZUFBZSxzREFBUztBQUN4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bW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxwcm92aWRlcnNcXGZvcm1hdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIEBfaWdub3JlXHJcbiAqL1xyXG5pbXBvcnQgeyBnZXRBZGRyZXNzLCBnZXRDcmVhdGVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGdldEJpZ0ludCwgZ2V0TnVtYmVyLCBoZXhsaWZ5LCBpc0hleFN0cmluZywgemVyb1BhZFZhbHVlLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XHJcbmV4cG9ydCBmdW5jdGlvbiBhbGxvd051bGwoZm9ybWF0LCBudWxsVmFsdWUpIHtcclxuICAgIHJldHVybiAoZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGxWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlPZihmb3JtYXQsIGFsbG93TnVsbCkge1xyXG4gICAgcmV0dXJuICgoYXJyYXkpID0+IHtcclxuICAgICAgICBpZiAoYWxsb3dOdWxsICYmIGFycmF5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGFuIGFycmF5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyYXkubWFwKChpKSA9PiBmb3JtYXQoaSkpO1xyXG4gICAgfSk7XHJcbn1cclxuLy8gUmVxdWlyZXMgYW4gb2JqZWN0IHdoaWNoIG1hdGNoZXMgYSBmbGVldCBvZiBvdGhlciBmb3JtYXR0ZXJzXHJcbi8vIEFueSBGb3JtYXRGdW5jIG1heSByZXR1cm4gYHVuZGVmaW5lZGAgdG8gaGF2ZSB0aGUgdmFsdWUgb21pdHRlZFxyXG4vLyBmcm9tIHRoZSByZXN1bHQgb2JqZWN0LiBDYWxscyBwcmVzZXJ2ZSBgdGhpc2AuXHJcbmV4cG9ydCBmdW5jdGlvbiBvYmplY3QoZm9ybWF0LCBhbHROYW1lcykge1xyXG4gICAgcmV0dXJuICgodmFsdWUpID0+IHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBmb3JtYXQpIHtcclxuICAgICAgICAgICAgbGV0IHNyY0tleSA9IGtleTtcclxuICAgICAgICAgICAgaWYgKGFsdE5hbWVzICYmIGtleSBpbiBhbHROYW1lcyAmJiAhKHNyY0tleSBpbiB2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWx0S2V5IG9mIGFsdE5hbWVzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWx0S2V5IGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY0tleSA9IGFsdEtleTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBudiA9IGZvcm1hdFtrZXldKHZhbHVlW3NyY0tleV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKG52ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IG52O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSA/IGVycm9yLm1lc3NhZ2UgOiBcIm5vdC1hbi1lcnJvclwiO1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgaW52YWxpZCB2YWx1ZSBmb3IgdmFsdWUuJHtrZXl9ICgke21lc3NhZ2V9KWAsIFwiQkFEX0RBVEFcIiwgeyB2YWx1ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEJvb2xlYW4odmFsdWUpIHtcclxuICAgIHN3aXRjaCAodmFsdWUpIHtcclxuICAgICAgICBjYXNlIHRydWU6XHJcbiAgICAgICAgY2FzZSBcInRydWVcIjpcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgY2FzZSBmYWxzZTpcclxuICAgICAgICBjYXNlIFwiZmFsc2VcIjpcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIGJvb2xlYW47ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRhKHZhbHVlKSB7XHJcbiAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh2YWx1ZSwgdHJ1ZSksIFwiaW52YWxpZCBkYXRhXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRIYXNoKHZhbHVlKSB7XHJcbiAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh2YWx1ZSwgMzIpLCBcImludmFsaWQgaGFzaFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VWludDI1Nih2YWx1ZSkge1xyXG4gICAgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHVpbnQyNTZcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gemVyb1BhZFZhbHVlKHZhbHVlLCAzMik7XHJcbn1cclxuY29uc3QgX2Zvcm1hdExvZyA9IG9iamVjdCh7XHJcbiAgICBhZGRyZXNzOiBnZXRBZGRyZXNzLFxyXG4gICAgYmxvY2tIYXNoOiBmb3JtYXRIYXNoLFxyXG4gICAgYmxvY2tOdW1iZXI6IGdldE51bWJlcixcclxuICAgIGRhdGE6IGZvcm1hdERhdGEsXHJcbiAgICBpbmRleDogZ2V0TnVtYmVyLFxyXG4gICAgcmVtb3ZlZDogYWxsb3dOdWxsKGZvcm1hdEJvb2xlYW4sIGZhbHNlKSxcclxuICAgIHRvcGljczogYXJyYXlPZihmb3JtYXRIYXNoKSxcclxuICAgIHRyYW5zYWN0aW9uSGFzaDogZm9ybWF0SGFzaCxcclxuICAgIHRyYW5zYWN0aW9uSW5kZXg6IGdldE51bWJlcixcclxufSwge1xyXG4gICAgaW5kZXg6IFtcImxvZ0luZGV4XCJdXHJcbn0pO1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TG9nKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gX2Zvcm1hdExvZyh2YWx1ZSk7XHJcbn1cclxuY29uc3QgX2Zvcm1hdEJsb2NrID0gb2JqZWN0KHtcclxuICAgIGhhc2g6IGFsbG93TnVsbChmb3JtYXRIYXNoKSxcclxuICAgIHBhcmVudEhhc2g6IGZvcm1hdEhhc2gsXHJcbiAgICBwYXJlbnRCZWFjb25CbG9ja1Jvb3Q6IGFsbG93TnVsbChmb3JtYXRIYXNoLCBudWxsKSxcclxuICAgIG51bWJlcjogZ2V0TnVtYmVyLFxyXG4gICAgdGltZXN0YW1wOiBnZXROdW1iZXIsXHJcbiAgICBub25jZTogYWxsb3dOdWxsKGZvcm1hdERhdGEpLFxyXG4gICAgZGlmZmljdWx0eTogZ2V0QmlnSW50LFxyXG4gICAgZ2FzTGltaXQ6IGdldEJpZ0ludCxcclxuICAgIGdhc1VzZWQ6IGdldEJpZ0ludCxcclxuICAgIHN0YXRlUm9vdDogYWxsb3dOdWxsKGZvcm1hdEhhc2gsIG51bGwpLFxyXG4gICAgcmVjZWlwdHNSb290OiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXHJcbiAgICBibG9iR2FzVXNlZDogYWxsb3dOdWxsKGdldEJpZ0ludCwgbnVsbCksXHJcbiAgICBleGNlc3NCbG9iR2FzOiBhbGxvd051bGwoZ2V0QmlnSW50LCBudWxsKSxcclxuICAgIG1pbmVyOiBhbGxvd051bGwoZ2V0QWRkcmVzcyksXHJcbiAgICBwcmV2UmFuZGFvOiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXHJcbiAgICBleHRyYURhdGE6IGZvcm1hdERhdGEsXHJcbiAgICBiYXNlRmVlUGVyR2FzOiBhbGxvd051bGwoZ2V0QmlnSW50KVxyXG59LCB7XHJcbiAgICBwcmV2UmFuZGFvOiBbXCJtaXhIYXNoXCJdXHJcbn0pO1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0QmxvY2sodmFsdWUpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IF9mb3JtYXRCbG9jayh2YWx1ZSk7XHJcbiAgICByZXN1bHQudHJhbnNhY3Rpb25zID0gdmFsdWUudHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHtcclxuICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR4O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSh0eCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuY29uc3QgX2Zvcm1hdFJlY2VpcHRMb2cgPSBvYmplY3Qoe1xyXG4gICAgdHJhbnNhY3Rpb25JbmRleDogZ2V0TnVtYmVyLFxyXG4gICAgYmxvY2tOdW1iZXI6IGdldE51bWJlcixcclxuICAgIHRyYW5zYWN0aW9uSGFzaDogZm9ybWF0SGFzaCxcclxuICAgIGFkZHJlc3M6IGdldEFkZHJlc3MsXHJcbiAgICB0b3BpY3M6IGFycmF5T2YoZm9ybWF0SGFzaCksXHJcbiAgICBkYXRhOiBmb3JtYXREYXRhLFxyXG4gICAgaW5kZXg6IGdldE51bWJlcixcclxuICAgIGJsb2NrSGFzaDogZm9ybWF0SGFzaCxcclxufSwge1xyXG4gICAgaW5kZXg6IFtcImxvZ0luZGV4XCJdXHJcbn0pO1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0UmVjZWlwdExvZyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIF9mb3JtYXRSZWNlaXB0TG9nKHZhbHVlKTtcclxufVxyXG5jb25zdCBfZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0ID0gb2JqZWN0KHtcclxuICAgIHRvOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXHJcbiAgICBmcm9tOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXHJcbiAgICBjb250cmFjdEFkZHJlc3M6IGFsbG93TnVsbChnZXRBZGRyZXNzLCBudWxsKSxcclxuICAgIC8vIHNob3VsZCBiZSBhbGxvd051bGwoaGFzaCksIGJ1dCBicm9rZW4tRUlQLTY1OCBzdXBwb3J0IGlzIGhhbmRsZWQgaW4gcmVjZWlwdFxyXG4gICAgaW5kZXg6IGdldE51bWJlcixcclxuICAgIHJvb3Q6IGFsbG93TnVsbChoZXhsaWZ5KSxcclxuICAgIGdhc1VzZWQ6IGdldEJpZ0ludCxcclxuICAgIGJsb2JHYXNVc2VkOiBhbGxvd051bGwoZ2V0QmlnSW50LCBudWxsKSxcclxuICAgIGxvZ3NCbG9vbTogYWxsb3dOdWxsKGZvcm1hdERhdGEpLFxyXG4gICAgYmxvY2tIYXNoOiBmb3JtYXRIYXNoLFxyXG4gICAgaGFzaDogZm9ybWF0SGFzaCxcclxuICAgIGxvZ3M6IGFycmF5T2YoZm9ybWF0UmVjZWlwdExvZyksXHJcbiAgICBibG9ja051bWJlcjogZ2V0TnVtYmVyLFxyXG4gICAgLy9jb25maXJtYXRpb25zOiBhbGxvd051bGwoZ2V0TnVtYmVyLCBudWxsKSxcclxuICAgIGN1bXVsYXRpdmVHYXNVc2VkOiBnZXRCaWdJbnQsXHJcbiAgICBlZmZlY3RpdmVHYXNQcmljZTogYWxsb3dOdWxsKGdldEJpZ0ludCksXHJcbiAgICBibG9iR2FzUHJpY2U6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpLFxyXG4gICAgc3RhdHVzOiBhbGxvd051bGwoZ2V0TnVtYmVyKSxcclxuICAgIHR5cGU6IGFsbG93TnVsbChnZXROdW1iZXIsIDApXHJcbn0sIHtcclxuICAgIGVmZmVjdGl2ZUdhc1ByaWNlOiBbXCJnYXNQcmljZVwiXSxcclxuICAgIGhhc2g6IFtcInRyYW5zYWN0aW9uSGFzaFwiXSxcclxuICAgIGluZGV4OiBbXCJ0cmFuc2FjdGlvbkluZGV4XCJdLFxyXG59KTtcclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIF9mb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlKHZhbHVlKSB7XHJcbiAgICAvLyBTb21lIGNsaWVudHMgKFRlc3RSUEMpIGRvIHN0cmFuZ2UgdGhpbmdzIGxpa2UgcmV0dXJuIDB4MCBmb3IgdGhlXHJcbiAgICAvLyAwIGFkZHJlc3M7IGNvcnJlY3QgdGhpcyB0byBiZSBhIHJlYWwgYWRkcmVzc1xyXG4gICAgaWYgKHZhbHVlLnRvICYmIGdldEJpZ0ludCh2YWx1ZS50bykgPT09IEJOXzApIHtcclxuICAgICAgICB2YWx1ZS50byA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXN1bHQgPSBvYmplY3Qoe1xyXG4gICAgICAgIGhhc2g6IGZvcm1hdEhhc2gsXHJcbiAgICAgICAgLy8gU29tZSBub2RlcyBkbyBub3QgcmV0dXJuIHRoaXMsIHVzdWFsbHkgdGVzdCBub2RlcyAobGlrZSBHYW5hY2hlKVxyXG4gICAgICAgIGluZGV4OiBhbGxvd051bGwoZ2V0TnVtYmVyLCB1bmRlZmluZWQpLFxyXG4gICAgICAgIHR5cGU6ICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiMHhcIiB8fCB2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0TnVtYmVyKHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGFsbG93TnVsbChhY2Nlc3NMaXN0aWZ5LCBudWxsKSxcclxuICAgICAgICBibG9iVmVyc2lvbmVkSGFzaGVzOiBhbGxvd051bGwoYXJyYXlPZihmb3JtYXRIYXNoLCB0cnVlKSwgbnVsbCksXHJcbiAgICAgICAgYXV0aG9yaXphdGlvbkxpc3Q6IGFsbG93TnVsbChhcnJheU9mKCh2KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzaWc7XHJcbiAgICAgICAgICAgIGlmICh2LnNpZ25hdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgc2lnID0gdi5zaWduYXR1cmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeVBhcml0eSA9IHYueVBhcml0eTtcclxuICAgICAgICAgICAgICAgIGlmICh5UGFyaXR5ID09PSBcIjB4MWJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHlQYXJpdHkgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeVBhcml0eSA9PT0gXCIweDFjXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB5UGFyaXR5ID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNpZyA9IE9iamVjdC5hc3NpZ24oe30sIHYsIHsgeVBhcml0eSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgYWRkcmVzczogZ2V0QWRkcmVzcyh2LmFkZHJlc3MpLFxyXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogZ2V0QmlnSW50KHYuY2hhaW5JZCksXHJcbiAgICAgICAgICAgICAgICBub25jZTogZ2V0QmlnSW50KHYubm9uY2UpLFxyXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBTaWduYXR1cmUuZnJvbShzaWcpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSwgZmFsc2UpLCBudWxsKSxcclxuICAgICAgICBibG9ja0hhc2g6IGFsbG93TnVsbChmb3JtYXRIYXNoLCBudWxsKSxcclxuICAgICAgICBibG9ja051bWJlcjogYWxsb3dOdWxsKGdldE51bWJlciwgbnVsbCksXHJcbiAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogYWxsb3dOdWxsKGdldE51bWJlciwgbnVsbCksXHJcbiAgICAgICAgZnJvbTogZ2V0QWRkcmVzcyxcclxuICAgICAgICAvLyBlaXRoZXIgKGdhc1ByaWNlKSBvciAobWF4UHJpb3JpdHlGZWVQZXJHYXMgKyBtYXhGZWVQZXJHYXMpIG11c3QgYmUgc2V0XHJcbiAgICAgICAgZ2FzUHJpY2U6IGFsbG93TnVsbChnZXRCaWdJbnQpLFxyXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBhbGxvd051bGwoZ2V0QmlnSW50KSxcclxuICAgICAgICBtYXhGZWVQZXJHYXM6IGFsbG93TnVsbChnZXRCaWdJbnQpLFxyXG4gICAgICAgIG1heEZlZVBlckJsb2JHYXM6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpLFxyXG4gICAgICAgIGdhc0xpbWl0OiBnZXRCaWdJbnQsXHJcbiAgICAgICAgdG86IGFsbG93TnVsbChnZXRBZGRyZXNzLCBudWxsKSxcclxuICAgICAgICB2YWx1ZTogZ2V0QmlnSW50LFxyXG4gICAgICAgIG5vbmNlOiBnZXROdW1iZXIsXHJcbiAgICAgICAgZGF0YTogZm9ybWF0RGF0YSxcclxuICAgICAgICBjcmVhdGVzOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXHJcbiAgICAgICAgY2hhaW5JZDogYWxsb3dOdWxsKGdldEJpZ0ludCwgbnVsbClcclxuICAgIH0sIHtcclxuICAgICAgICBkYXRhOiBbXCJpbnB1dFwiXSxcclxuICAgICAgICBnYXNMaW1pdDogW1wiZ2FzXCJdLFxyXG4gICAgICAgIGluZGV4OiBbXCJ0cmFuc2FjdGlvbkluZGV4XCJdXHJcbiAgICB9KSh2YWx1ZSk7XHJcbiAgICAvLyBJZiB0byBhbmQgY3JlYXRlcyBhcmUgZW1wdHksIHBvcHVsYXRlIHRoZSBjcmVhdGVzIGZyb20gdGhlIHZhbHVlXHJcbiAgICBpZiAocmVzdWx0LnRvID09IG51bGwgJiYgcmVzdWx0LmNyZWF0ZXMgPT0gbnVsbCkge1xyXG4gICAgICAgIHJlc3VsdC5jcmVhdGVzID0gZ2V0Q3JlYXRlQWRkcmVzcyhyZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgLy8gQFRPRE86IENoZWNrIGZlZSBkYXRhXHJcbiAgICAvLyBBZGQgYW4gYWNjZXNzIGxpc3QgdG8gc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGVzXHJcbiAgICBpZiAoKHZhbHVlLnR5cGUgPT09IDEgfHwgdmFsdWUudHlwZSA9PT0gMikgJiYgdmFsdWUuYWNjZXNzTGlzdCA9PSBudWxsKSB7XHJcbiAgICAgICAgcmVzdWx0LmFjY2Vzc0xpc3QgPSBbXTtcclxuICAgIH1cclxuICAgIC8vIENvbXB1dGUgdGhlIHNpZ25hdHVyZVxyXG4gICAgaWYgKHZhbHVlLnNpZ25hdHVyZSkge1xyXG4gICAgICAgIHJlc3VsdC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh2YWx1ZS5zaWduYXR1cmUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0LnNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8vIFNvbWUgYmFja2VuZHMgb21pdCBDaGFpbklkIG9uIGxlZ2FjeSB0cmFuc2FjdGlvbnMsIGJ1dCB3ZSBjYW4gY29tcHV0ZSBpdFxyXG4gICAgaWYgKHJlc3VsdC5jaGFpbklkID09IG51bGwpIHtcclxuICAgICAgICBjb25zdCBjaGFpbklkID0gcmVzdWx0LnNpZ25hdHVyZS5sZWdhY3lDaGFpbklkO1xyXG4gICAgICAgIGlmIChjaGFpbklkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIEBUT0RPOiBjaGVjayBjaGFpbklEXHJcbiAgICAvKlxyXG4gICAgaWYgKHZhbHVlLmNoYWluSWQgIT0gbnVsbCkge1xyXG4gICAgICAgIGxldCBjaGFpbklkID0gdmFsdWUuY2hhaW5JZDtcclxuXHJcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGNoYWluSWQpKSB7XHJcbiAgICAgICAgICAgIGNoYWluSWQgPSBCaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IGNoYWluSWQgPSB2YWx1ZS5uZXR3b3JrSWQ7XHJcblxyXG4gICAgICAgIC8vIGdldGgtZXRjIHJldHVybnMgY2hhaW5JZFxyXG4gICAgICAgIGlmIChjaGFpbklkID09IG51bGwgJiYgcmVzdWx0LnYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjaGFpbklkID0gdmFsdWUuY2hhaW5JZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhjaGFpbklkKSkge1xyXG4gICAgICAgICAgICBjaGFpbklkID0gQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIgJiYgcmVzdWx0LnYgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjaGFpbklkID0gKHJlc3VsdC52IC0gMzUpIC8gMjtcclxuICAgICAgICAgICAgaWYgKGNoYWluSWQgPCAwKSB7IGNoYWluSWQgPSAwOyB9XHJcbiAgICAgICAgICAgIGNoYWluSWQgPSBwYXJzZUludChjaGFpbklkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHsgY2hhaW5JZCA9IDA7IH1cclxuXHJcbiAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xyXG4gICAgfVxyXG4gICAgKi9cclxuICAgIC8vIDB4MDAwMC4uLiBzaG91bGQgYWN0dWFsbHkgYmUgbnVsbFxyXG4gICAgaWYgKHJlc3VsdC5ibG9ja0hhc2ggJiYgZ2V0QmlnSW50KHJlc3VsdC5ibG9ja0hhc2gpID09PSBCTl8wKSB7XHJcbiAgICAgICAgcmVzdWx0LmJsb2NrSGFzaCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/format.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractProvider: () => (/* reexport safe */ _abstract_provider_js__WEBPACK_IMPORTED_MODULE_0__.AbstractProvider),\n/* harmony export */   AbstractSigner: () => (/* reexport safe */ _abstract_signer_js__WEBPACK_IMPORTED_MODULE_1__.AbstractSigner),\n/* harmony export */   AlchemyProvider: () => (/* reexport safe */ _provider_alchemy_js__WEBPACK_IMPORTED_MODULE_12__.AlchemyProvider),\n/* harmony export */   AnkrProvider: () => (/* reexport safe */ _provider_ankr_js__WEBPACK_IMPORTED_MODULE_14__.AnkrProvider),\n/* harmony export */   Block: () => (/* reexport safe */ _provider_js__WEBPACK_IMPORTED_MODULE_8__.Block),\n/* harmony export */   BlockscoutProvider: () => (/* reexport safe */ _provider_blockscout_js__WEBPACK_IMPORTED_MODULE_13__.BlockscoutProvider),\n/* harmony export */   BrowserProvider: () => (/* reexport safe */ _provider_browser_js__WEBPACK_IMPORTED_MODULE_11__.BrowserProvider),\n/* harmony export */   ChainstackProvider: () => (/* reexport safe */ _provider_chainstack_js__WEBPACK_IMPORTED_MODULE_16__.ChainstackProvider),\n/* harmony export */   CloudflareProvider: () => (/* reexport safe */ _provider_cloudflare_js__WEBPACK_IMPORTED_MODULE_15__.CloudflareProvider),\n/* harmony export */   EnsPlugin: () => (/* reexport safe */ _plugins_network_js__WEBPACK_IMPORTED_MODULE_7__.EnsPlugin),\n/* harmony export */   EnsResolver: () => (/* reexport safe */ _ens_resolver_js__WEBPACK_IMPORTED_MODULE_4__.EnsResolver),\n/* harmony export */   EtherscanPlugin: () => (/* reexport safe */ _provider_etherscan_js__WEBPACK_IMPORTED_MODULE_17__.EtherscanPlugin),\n/* harmony export */   EtherscanProvider: () => (/* reexport safe */ _provider_etherscan_js__WEBPACK_IMPORTED_MODULE_17__.EtherscanProvider),\n/* harmony export */   FallbackProvider: () => (/* reexport safe */ _provider_fallback_js__WEBPACK_IMPORTED_MODULE_9__.FallbackProvider),\n/* harmony export */   FeeData: () => (/* reexport safe */ _provider_js__WEBPACK_IMPORTED_MODULE_8__.FeeData),\n/* harmony export */   FeeDataNetworkPlugin: () => (/* reexport safe */ _plugins_network_js__WEBPACK_IMPORTED_MODULE_7__.FeeDataNetworkPlugin),\n/* harmony export */   FetchUrlFeeDataNetworkPlugin: () => (/* reexport safe */ _plugins_network_js__WEBPACK_IMPORTED_MODULE_7__.FetchUrlFeeDataNetworkPlugin),\n/* harmony export */   GasCostPlugin: () => (/* reexport safe */ _plugins_network_js__WEBPACK_IMPORTED_MODULE_7__.GasCostPlugin),\n/* harmony export */   InfuraProvider: () => (/* reexport safe */ _provider_infura_js__WEBPACK_IMPORTED_MODULE_18__.InfuraProvider),\n/* harmony export */   InfuraWebSocketProvider: () => (/* reexport safe */ _provider_infura_js__WEBPACK_IMPORTED_MODULE_18__.InfuraWebSocketProvider),\n/* harmony export */   IpcSocketProvider: () => (/* reexport safe */ _provider_ipcsocket_js__WEBPACK_IMPORTED_MODULE_21__.IpcSocketProvider),\n/* harmony export */   JsonRpcApiProvider: () => (/* reexport safe */ _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_10__.JsonRpcApiProvider),\n/* harmony export */   JsonRpcProvider: () => (/* reexport safe */ _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_10__.JsonRpcProvider),\n/* harmony export */   JsonRpcSigner: () => (/* reexport safe */ _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_10__.JsonRpcSigner),\n/* harmony export */   Log: () => (/* reexport safe */ _provider_js__WEBPACK_IMPORTED_MODULE_8__.Log),\n/* harmony export */   MulticoinProviderPlugin: () => (/* reexport safe */ _ens_resolver_js__WEBPACK_IMPORTED_MODULE_4__.MulticoinProviderPlugin),\n/* harmony export */   Network: () => (/* reexport safe */ _network_js__WEBPACK_IMPORTED_MODULE_5__.Network),\n/* harmony export */   NetworkPlugin: () => (/* reexport safe */ _plugins_network_js__WEBPACK_IMPORTED_MODULE_7__.NetworkPlugin),\n/* harmony export */   NonceManager: () => (/* reexport safe */ _signer_noncemanager_js__WEBPACK_IMPORTED_MODULE_6__.NonceManager),\n/* harmony export */   PocketProvider: () => (/* reexport safe */ _provider_pocket_js__WEBPACK_IMPORTED_MODULE_19__.PocketProvider),\n/* harmony export */   QuickNodeProvider: () => (/* reexport safe */ _provider_quicknode_js__WEBPACK_IMPORTED_MODULE_20__.QuickNodeProvider),\n/* harmony export */   SocketBlockSubscriber: () => (/* reexport safe */ _provider_socket_js__WEBPACK_IMPORTED_MODULE_22__.SocketBlockSubscriber),\n/* harmony export */   SocketEventSubscriber: () => (/* reexport safe */ _provider_socket_js__WEBPACK_IMPORTED_MODULE_22__.SocketEventSubscriber),\n/* harmony export */   SocketPendingSubscriber: () => (/* reexport safe */ _provider_socket_js__WEBPACK_IMPORTED_MODULE_22__.SocketPendingSubscriber),\n/* harmony export */   SocketProvider: () => (/* reexport safe */ _provider_socket_js__WEBPACK_IMPORTED_MODULE_22__.SocketProvider),\n/* harmony export */   SocketSubscriber: () => (/* reexport safe */ _provider_socket_js__WEBPACK_IMPORTED_MODULE_22__.SocketSubscriber),\n/* harmony export */   TransactionReceipt: () => (/* reexport safe */ _provider_js__WEBPACK_IMPORTED_MODULE_8__.TransactionReceipt),\n/* harmony export */   TransactionResponse: () => (/* reexport safe */ _provider_js__WEBPACK_IMPORTED_MODULE_8__.TransactionResponse),\n/* harmony export */   UnmanagedSubscriber: () => (/* reexport safe */ _abstract_provider_js__WEBPACK_IMPORTED_MODULE_0__.UnmanagedSubscriber),\n/* harmony export */   VoidSigner: () => (/* reexport safe */ _abstract_signer_js__WEBPACK_IMPORTED_MODULE_1__.VoidSigner),\n/* harmony export */   WebSocketProvider: () => (/* reexport safe */ _provider_websocket_js__WEBPACK_IMPORTED_MODULE_23__.WebSocketProvider),\n/* harmony export */   copyRequest: () => (/* reexport safe */ _provider_js__WEBPACK_IMPORTED_MODULE_8__.copyRequest),\n/* harmony export */   getDefaultProvider: () => (/* reexport safe */ _default_provider_js__WEBPACK_IMPORTED_MODULE_3__.getDefaultProvider),\n/* harmony export */   showThrottleMessage: () => (/* reexport safe */ _community_js__WEBPACK_IMPORTED_MODULE_2__.showThrottleMessage)\n/* harmony export */ });\n/* harmony import */ var _abstract_provider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-provider.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/abstract-provider.js\");\n/* harmony import */ var _abstract_signer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract-signer.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/abstract-signer.js\");\n/* harmony import */ var _community_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./community.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/community.js\");\n/* harmony import */ var _default_provider_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./default-provider.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/default-provider.js\");\n/* harmony import */ var _ens_resolver_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ens-resolver.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/ens-resolver.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./network.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _signer_noncemanager_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./signer-noncemanager.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/signer-noncemanager.js\");\n/* harmony import */ var _plugins_network_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plugins-network.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/plugins-network.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./provider.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _provider_fallback_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./provider-fallback.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-fallback.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var _provider_browser_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./provider-browser.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-browser.js\");\n/* harmony import */ var _provider_alchemy_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./provider-alchemy.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-alchemy.js\");\n/* harmony import */ var _provider_blockscout_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./provider-blockscout.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-blockscout.js\");\n/* harmony import */ var _provider_ankr_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./provider-ankr.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-ankr.js\");\n/* harmony import */ var _provider_cloudflare_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./provider-cloudflare.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-cloudflare.js\");\n/* harmony import */ var _provider_chainstack_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./provider-chainstack.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-chainstack.js\");\n/* harmony import */ var _provider_etherscan_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./provider-etherscan.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-etherscan.js\");\n/* harmony import */ var _provider_infura_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./provider-infura.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-infura.js\");\n/* harmony import */ var _provider_pocket_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./provider-pocket.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-pocket.js\");\n/* harmony import */ var _provider_quicknode_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./provider-quicknode.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-quicknode.js\");\n/* harmony import */ var _provider_ipcsocket_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./provider-ipcsocket.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-ipcsocket-browser.js\");\n/* harmony import */ var _provider_socket_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./provider-socket.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-socket.js\");\n/* harmony import */ var _provider_websocket_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./provider-websocket.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-websocket.js\");\n/**\r\n *  A **Provider** provides a connection to the blockchain, whch can be\r\n *  used to query its current state, simulate execution and send transactions\r\n *  to update the state.\r\n *\r\n *  It is one of the most fundamental components of interacting with a\r\n *  blockchain application, and there are many ways to connect, such as over\r\n *  HTTP, WebSockets or injected providers such as [MetaMask](link-metamask).\r\n *\r\n *  @_section: api/providers:Providers  [about-providers]\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n /*-browser*/\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQytFO0FBQ1o7QUFDZDtBQUNNO0FBQ2M7QUFDbEM7QUFDaUI7QUFDNEU7QUFHNUc7QUFDa0M7QUFDaUM7QUFDbkM7QUFDQTtBQUNNO0FBQ1o7QUFDWTtBQUNBO0FBQ2U7QUFDRTtBQUN6QjtBQUNNO0FBQ0EsQ0FBQztBQUNoQztBQUN5QjtBQUNNO0FBQ21FO0FBQy9IIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHByb3ZpZGVyc1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqICBBICoqUHJvdmlkZXIqKiBwcm92aWRlcyBhIGNvbm5lY3Rpb24gdG8gdGhlIGJsb2NrY2hhaW4sIHdoY2ggY2FuIGJlXHJcbiAqICB1c2VkIHRvIHF1ZXJ5IGl0cyBjdXJyZW50IHN0YXRlLCBzaW11bGF0ZSBleGVjdXRpb24gYW5kIHNlbmQgdHJhbnNhY3Rpb25zXHJcbiAqICB0byB1cGRhdGUgdGhlIHN0YXRlLlxyXG4gKlxyXG4gKiAgSXQgaXMgb25lIG9mIHRoZSBtb3N0IGZ1bmRhbWVudGFsIGNvbXBvbmVudHMgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhXHJcbiAqICBibG9ja2NoYWluIGFwcGxpY2F0aW9uLCBhbmQgdGhlcmUgYXJlIG1hbnkgd2F5cyB0byBjb25uZWN0LCBzdWNoIGFzIG92ZXJcclxuICogIEhUVFAsIFdlYlNvY2tldHMgb3IgaW5qZWN0ZWQgcHJvdmlkZXJzIHN1Y2ggYXMgW01ldGFNYXNrXShsaW5rLW1ldGFtYXNrKS5cclxuICpcclxuICogIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVyczpQcm92aWRlcnMgIFthYm91dC1wcm92aWRlcnNdXHJcbiAqL1xyXG5leHBvcnQgeyBBYnN0cmFjdFByb3ZpZGVyLCBVbm1hbmFnZWRTdWJzY3JpYmVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtcHJvdmlkZXIuanNcIjtcclxuZXhwb3J0IHsgQWJzdHJhY3RTaWduZXIsIFZvaWRTaWduZXIsIH0gZnJvbSBcIi4vYWJzdHJhY3Qtc2lnbmVyLmpzXCI7XHJcbmV4cG9ydCB7IHNob3dUaHJvdHRsZU1lc3NhZ2UgfSBmcm9tIFwiLi9jb21tdW5pdHkuanNcIjtcclxuZXhwb3J0IHsgZ2V0RGVmYXVsdFByb3ZpZGVyIH0gZnJvbSBcIi4vZGVmYXVsdC1wcm92aWRlci5qc1wiO1xyXG5leHBvcnQgeyBFbnNSZXNvbHZlciwgTXVsdGljb2luUHJvdmlkZXJQbHVnaW4gfSBmcm9tIFwiLi9lbnMtcmVzb2x2ZXIuanNcIjtcclxuZXhwb3J0IHsgTmV0d29yayB9IGZyb20gXCIuL25ldHdvcmsuanNcIjtcclxuZXhwb3J0IHsgTm9uY2VNYW5hZ2VyIH0gZnJvbSBcIi4vc2lnbmVyLW5vbmNlbWFuYWdlci5qc1wiO1xyXG5leHBvcnQgeyBOZXR3b3JrUGx1Z2luLCBHYXNDb3N0UGx1Z2luLCBFbnNQbHVnaW4sIEZlZURhdGFOZXR3b3JrUGx1Z2luLCBGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luLCB9IGZyb20gXCIuL3BsdWdpbnMtbmV0d29yay5qc1wiO1xyXG5leHBvcnQgeyBCbG9jaywgRmVlRGF0YSwgTG9nLCBUcmFuc2FjdGlvblJlY2VpcHQsIFRyYW5zYWN0aW9uUmVzcG9uc2UsIGNvcHlSZXF1ZXN0LFxyXG4vL3Jlc29sdmVUcmFuc2FjdGlvblJlcXVlc3QsXHJcbiB9IGZyb20gXCIuL3Byb3ZpZGVyLmpzXCI7XHJcbmV4cG9ydCB7IEZhbGxiYWNrUHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1mYWxsYmFjay5qc1wiO1xyXG5leHBvcnQgeyBKc29uUnBjQXBpUHJvdmlkZXIsIEpzb25ScGNQcm92aWRlciwgSnNvblJwY1NpZ25lciB9IGZyb20gXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIjtcclxuZXhwb3J0IHsgQnJvd3NlclByb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItYnJvd3Nlci5qc1wiO1xyXG5leHBvcnQgeyBBbGNoZW15UHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1hbGNoZW15LmpzXCI7XHJcbmV4cG9ydCB7IEJsb2Nrc2NvdXRQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWJsb2Nrc2NvdXQuanNcIjtcclxuZXhwb3J0IHsgQW5rclByb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItYW5rci5qc1wiO1xyXG5leHBvcnQgeyBDbG91ZGZsYXJlUHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1jbG91ZGZsYXJlLmpzXCI7XHJcbmV4cG9ydCB7IENoYWluc3RhY2tQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWNoYWluc3RhY2suanNcIjtcclxuZXhwb3J0IHsgRXRoZXJzY2FuUHJvdmlkZXIsIEV0aGVyc2NhblBsdWdpbiB9IGZyb20gXCIuL3Byb3ZpZGVyLWV0aGVyc2Nhbi5qc1wiO1xyXG5leHBvcnQgeyBJbmZ1cmFQcm92aWRlciwgSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1pbmZ1cmEuanNcIjtcclxuZXhwb3J0IHsgUG9ja2V0UHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1wb2NrZXQuanNcIjtcclxuZXhwb3J0IHsgUXVpY2tOb2RlUHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1xdWlja25vZGUuanNcIjtcclxuaW1wb3J0IHsgSXBjU29ja2V0UHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1pcGNzb2NrZXQuanNcIjsgLyotYnJvd3NlciovXHJcbmV4cG9ydCB7IElwY1NvY2tldFByb3ZpZGVyIH07XHJcbmV4cG9ydCB7IFNvY2tldFByb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItc29ja2V0LmpzXCI7XHJcbmV4cG9ydCB7IFdlYlNvY2tldFByb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItd2Vic29ja2V0LmpzXCI7XHJcbmV4cG9ydCB7IFNvY2tldFN1YnNjcmliZXIsIFNvY2tldEJsb2NrU3Vic2NyaWJlciwgU29ja2V0UGVuZGluZ1N1YnNjcmliZXIsIFNvY2tldEV2ZW50U3Vic2NyaWJlciB9IGZyb20gXCIuL3Byb3ZpZGVyLXNvY2tldC5qc1wiO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/network.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/network.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Network: () => (/* binding */ Network)\n/* harmony export */ });\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transaction/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins-network.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/plugins-network.js\");\n/**\r\n *  A **Network** encapsulates the various properties required to\r\n *  interact with a specific chain.\r\n *\r\n *  @_subsection: api/providers:Networks  [networks]\r\n */\r\n\r\n\r\n\r\n/* * * *\r\n// Networks which operation against an L2 can use this plugin to\r\n// specify how to access L1, for the purpose of resolving ENS,\r\n// for example.\r\nexport class LayerOneConnectionPlugin extends NetworkPlugin {\r\n    readonly provider!: Provider;\r\n// @TODO: Rename to ChainAccess and allow for connecting to any chain\r\n    constructor(provider: Provider) {\r\n        super(\"org.ethers.plugins.layer-one-connection\");\r\n        defineProperties<LayerOneConnectionPlugin>(this, { provider });\r\n    }\r\n\r\n    clone(): LayerOneConnectionPlugin {\r\n        return new LayerOneConnectionPlugin(this.provider);\r\n    }\r\n}\r\n*/\r\nconst Networks = new Map();\r\n/**\r\n *  A **Network** provides access to a chain's properties and allows\r\n *  for plug-ins to extend functionality.\r\n */\r\nclass Network {\r\n    #name;\r\n    #chainId;\r\n    #plugins;\r\n    /**\r\n     *  Creates a new **Network** for %%name%% and %%chainId%%.\r\n     */\r\n    constructor(name, chainId) {\r\n        this.#name = name;\r\n        this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(chainId);\r\n        this.#plugins = new Map();\r\n    }\r\n    /**\r\n     *  Returns a JSON-compatible representation of a Network.\r\n     */\r\n    toJSON() {\r\n        return { name: this.name, chainId: String(this.chainId) };\r\n    }\r\n    /**\r\n     *  The network common name.\r\n     *\r\n     *  This is the canonical name, as networks migh have multiple\r\n     *  names.\r\n     */\r\n    get name() { return this.#name; }\r\n    set name(value) { this.#name = value; }\r\n    /**\r\n     *  The network chain ID.\r\n     */\r\n    get chainId() { return this.#chainId; }\r\n    set chainId(value) { this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"chainId\"); }\r\n    /**\r\n     *  Returns true if %%other%% matches this network. Any chain ID\r\n     *  must match, and if no chain ID is present, the name must match.\r\n     *\r\n     *  This method does not currently check for additional properties,\r\n     *  such as ENS address or plug-in compatibility.\r\n     */\r\n    matches(other) {\r\n        if (other == null) {\r\n            return false;\r\n        }\r\n        if (typeof (other) === \"string\") {\r\n            try {\r\n                return (this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other));\r\n            }\r\n            catch (error) { }\r\n            return (this.name === other);\r\n        }\r\n        if (typeof (other) === \"number\" || typeof (other) === \"bigint\") {\r\n            try {\r\n                return (this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other));\r\n            }\r\n            catch (error) { }\r\n            return false;\r\n        }\r\n        if (typeof (other) === \"object\") {\r\n            if (other.chainId != null) {\r\n                try {\r\n                    return (this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other.chainId));\r\n                }\r\n                catch (error) { }\r\n                return false;\r\n            }\r\n            if (other.name != null) {\r\n                return (this.name === other.name);\r\n            }\r\n            return false;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     *  Returns the list of plugins currently attached to this Network.\r\n     */\r\n    get plugins() {\r\n        return Array.from(this.#plugins.values());\r\n    }\r\n    /**\r\n     *  Attach a new %%plugin%% to this Network. The network name\r\n     *  must be unique, excluding any fragment.\r\n     */\r\n    attachPlugin(plugin) {\r\n        if (this.#plugins.get(plugin.name)) {\r\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\r\n        }\r\n        this.#plugins.set(plugin.name, plugin.clone());\r\n        return this;\r\n    }\r\n    /**\r\n     *  Return the plugin, if any, matching %%name%% exactly. Plugins\r\n     *  with fragments will not be returned unless %%name%% includes\r\n     *  a fragment.\r\n     */\r\n    getPlugin(name) {\r\n        return (this.#plugins.get(name)) || null;\r\n    }\r\n    /**\r\n     *  Gets a list of all plugins that match %%name%%, with otr without\r\n     *  a fragment.\r\n     */\r\n    getPlugins(basename) {\r\n        return (this.plugins.filter((p) => (p.name.split(\"#\")[0] === basename)));\r\n    }\r\n    /**\r\n     *  Create a copy of this Network.\r\n     */\r\n    clone() {\r\n        const clone = new Network(this.name, this.chainId);\r\n        this.plugins.forEach((plugin) => {\r\n            clone.attachPlugin(plugin.clone());\r\n        });\r\n        return clone;\r\n    }\r\n    /**\r\n     *  Compute the intrinsic gas required for a transaction.\r\n     *\r\n     *  A GasCostPlugin can be attached to override the default\r\n     *  values.\r\n     */\r\n    computeIntrinsicGas(tx) {\r\n        const costs = this.getPlugin(\"org.ethers.plugins.network.GasCost\") || (new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.GasCostPlugin());\r\n        let gas = costs.txBase;\r\n        if (tx.to == null) {\r\n            gas += costs.txCreate;\r\n        }\r\n        if (tx.data) {\r\n            for (let i = 2; i < tx.data.length; i += 2) {\r\n                if (tx.data.substring(i, i + 2) === \"00\") {\r\n                    gas += costs.txDataZero;\r\n                }\r\n                else {\r\n                    gas += costs.txDataNonzero;\r\n                }\r\n            }\r\n        }\r\n        if (tx.accessList) {\r\n            const accessList = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_2__.accessListify)(tx.accessList);\r\n            for (const addr in accessList) {\r\n                gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;\r\n            }\r\n        }\r\n        return gas;\r\n    }\r\n    /**\r\n     *  Returns a new Network for the %%network%% name or chainId.\r\n     */\r\n    static from(network) {\r\n        injectCommonNetworks();\r\n        // Default network\r\n        if (network == null) {\r\n            return Network.from(\"mainnet\");\r\n        }\r\n        // Canonical name or chain ID\r\n        if (typeof (network) === \"number\") {\r\n            network = BigInt(network);\r\n        }\r\n        if (typeof (network) === \"string\" || typeof (network) === \"bigint\") {\r\n            const networkFunc = Networks.get(network);\r\n            if (networkFunc) {\r\n                return networkFunc();\r\n            }\r\n            if (typeof (network) === \"bigint\") {\r\n                return new Network(\"unknown\", network);\r\n            }\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unknown network\", \"network\", network);\r\n        }\r\n        // Clonable with network-like abilities\r\n        if (typeof (network.clone) === \"function\") {\r\n            const clone = network.clone();\r\n            //if (typeof(network.name) !== \"string\" || typeof(network.chainId) !== \"number\") {\r\n            //}\r\n            return clone;\r\n        }\r\n        // Networkish\r\n        if (typeof (network) === \"object\") {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (network.name) === \"string\" && typeof (network.chainId) === \"number\", \"invalid network object name or chainId\", \"network\", network);\r\n            const custom = new Network((network.name), (network.chainId));\r\n            if (network.ensAddress || network.ensNetwork != null) {\r\n                custom.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.EnsPlugin(network.ensAddress, network.ensNetwork));\r\n            }\r\n            //if ((<any>network).layerOneConnection) {\r\n            //    custom.attachPlugin(new LayerOneConnectionPlugin((<any>network).layerOneConnection));\r\n            //}\r\n            return custom;\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid network\", \"network\", network);\r\n    }\r\n    /**\r\n     *  Register %%nameOrChainId%% with a function which returns\r\n     *  an instance of a Network representing that chain.\r\n     */\r\n    static register(nameOrChainId, networkFunc) {\r\n        if (typeof (nameOrChainId) === \"number\") {\r\n            nameOrChainId = BigInt(nameOrChainId);\r\n        }\r\n        const existing = Networks.get(nameOrChainId);\r\n        if (existing) {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `conflicting network for ${JSON.stringify(existing.name)}`, \"nameOrChainId\", nameOrChainId);\r\n        }\r\n        Networks.set(nameOrChainId, networkFunc);\r\n    }\r\n}\r\n// We don't want to bring in formatUnits because it is backed by\r\n// FixedNumber and we want to keep Networks tiny. The values\r\n// included by the Gas Stations are also IEEE 754 with lots of\r\n// rounding issues and exceed the strict checks formatUnits has.\r\nfunction parseUnits(_value, decimals) {\r\n    const value = String(_value);\r\n    if (!value.match(/^[0-9.]+$/)) {\r\n        throw new Error(`invalid gwei value: ${_value}`);\r\n    }\r\n    // Break into [ whole, fraction ]\r\n    const comps = value.split(\".\");\r\n    if (comps.length === 1) {\r\n        comps.push(\"\");\r\n    }\r\n    // More than 1 decimal point or too many fractional positions\r\n    if (comps.length !== 2) {\r\n        throw new Error(`invalid gwei value: ${_value}`);\r\n    }\r\n    // Pad the fraction to 9 decimalplaces\r\n    while (comps[1].length < decimals) {\r\n        comps[1] += \"0\";\r\n    }\r\n    // Too many decimals and some non-zero ending, take the ceiling\r\n    if (comps[1].length > 9) {\r\n        let frac = BigInt(comps[1].substring(0, 9));\r\n        if (!comps[1].substring(9).match(/^0+$/)) {\r\n            frac++;\r\n        }\r\n        comps[1] = frac.toString();\r\n    }\r\n    return BigInt(comps[0] + comps[1]);\r\n}\r\n// Used by Polygon to use a gas station for fee data\r\nfunction getGasStationPlugin(url) {\r\n    return new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {\r\n        // Prevent Cloudflare from blocking our request in node.js\r\n        request.setHeader(\"User-Agent\", \"ethers\");\r\n        let response;\r\n        try {\r\n            const [_response, _feeData] = await Promise.all([\r\n                request.send(), fetchFeeData()\r\n            ]);\r\n            response = _response;\r\n            const payload = response.bodyJson.standard;\r\n            const feeData = {\r\n                gasPrice: _feeData.gasPrice,\r\n                maxFeePerGas: parseUnits(payload.maxFee, 9),\r\n                maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9),\r\n            };\r\n            return feeData;\r\n        }\r\n        catch (error) {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, \"SERVER_ERROR\", { request, response, error });\r\n        }\r\n    });\r\n}\r\n// See: https://chainlist.org\r\nlet injected = false;\r\nfunction injectCommonNetworks() {\r\n    if (injected) {\r\n        return;\r\n    }\r\n    injected = true;\r\n    /// Register popular Ethereum networks\r\n    function registerEth(name, chainId, options) {\r\n        const func = function () {\r\n            const network = new Network(name, chainId);\r\n            // We use 0 to disable ENS\r\n            if (options.ensNetwork != null) {\r\n                network.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.EnsPlugin(null, options.ensNetwork));\r\n            }\r\n            network.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.GasCostPlugin());\r\n            (options.plugins || []).forEach((plugin) => {\r\n                network.attachPlugin(plugin);\r\n            });\r\n            return network;\r\n        };\r\n        // Register the network by name and chain ID\r\n        Network.register(name, func);\r\n        Network.register(chainId, func);\r\n        if (options.altNames) {\r\n            options.altNames.forEach((name) => {\r\n                Network.register(name, func);\r\n            });\r\n        }\r\n    }\r\n    registerEth(\"mainnet\", 1, { ensNetwork: 1, altNames: [\"homestead\"] });\r\n    registerEth(\"ropsten\", 3, { ensNetwork: 3 });\r\n    registerEth(\"rinkeby\", 4, { ensNetwork: 4 });\r\n    registerEth(\"goerli\", 5, { ensNetwork: 5 });\r\n    registerEth(\"kovan\", 42, { ensNetwork: 42 });\r\n    registerEth(\"sepolia\", 11155111, { ensNetwork: 11155111 });\r\n    registerEth(\"holesky\", 17000, { ensNetwork: 17000 });\r\n    registerEth(\"classic\", 61, {});\r\n    registerEth(\"classicKotti\", 6, {});\r\n    registerEth(\"arbitrum\", 42161, {\r\n        ensNetwork: 1,\r\n    });\r\n    registerEth(\"arbitrum-goerli\", 421613, {});\r\n    registerEth(\"arbitrum-sepolia\", 421614, {});\r\n    registerEth(\"base\", 8453, { ensNetwork: 1 });\r\n    registerEth(\"base-goerli\", 84531, {});\r\n    registerEth(\"base-sepolia\", 84532, {});\r\n    registerEth(\"bnb\", 56, { ensNetwork: 1 });\r\n    registerEth(\"bnbt\", 97, {});\r\n    registerEth(\"linea\", 59144, { ensNetwork: 1 });\r\n    registerEth(\"linea-goerli\", 59140, {});\r\n    registerEth(\"linea-sepolia\", 59141, {});\r\n    registerEth(\"matic\", 137, {\r\n        ensNetwork: 1,\r\n        plugins: [\r\n            getGasStationPlugin(\"https:/\\/gasstation.polygon.technology/v2\")\r\n        ]\r\n    });\r\n    registerEth(\"matic-amoy\", 80002, {});\r\n    registerEth(\"matic-mumbai\", 80001, {\r\n        altNames: [\"maticMumbai\", \"maticmum\"],\r\n        plugins: [\r\n            getGasStationPlugin(\"https:/\\/gasstation-testnet.polygon.technology/v2\")\r\n        ]\r\n    });\r\n    registerEth(\"optimism\", 10, {\r\n        ensNetwork: 1,\r\n        plugins: []\r\n    });\r\n    registerEth(\"optimism-goerli\", 420, {});\r\n    registerEth(\"optimism-sepolia\", 11155420, {});\r\n    registerEth(\"xdai\", 100, { ensNetwork: 1 });\r\n}\r\n//# sourceMappingURL=network.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvbmV0d29yay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3dEO0FBQ2M7QUFDd0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFVBQVU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBEQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHlCQUF5QixnQkFBZ0IsMERBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMERBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDBEQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDBEQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsYUFBYTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRiw4REFBYTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0VBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQWM7QUFDMUI7QUFDQTtBQUNBLHdDQUF3QywwREFBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUFjLG1DQUFtQyw4QkFBOEI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2RUFBNEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQU0sdURBQXVELDRCQUE0QixzQkFBc0IsMEJBQTBCO0FBQ3JKO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMERBQVM7QUFDbEQ7QUFDQSxxQ0FBcUMsOERBQWE7QUFDbEQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnQ0FBZ0Msd0NBQXdDO0FBQ3hFLGdDQUFnQyxlQUFlO0FBQy9DLGdDQUFnQyxlQUFlO0FBQy9DLCtCQUErQixlQUFlO0FBQzlDLCtCQUErQixnQkFBZ0I7QUFDL0MsdUNBQXVDLHNCQUFzQjtBQUM3RCxvQ0FBb0MsbUJBQW1CO0FBQ3ZELGlDQUFpQztBQUNqQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTCw2Q0FBNkM7QUFDN0MsOENBQThDO0FBQzlDLGdDQUFnQyxlQUFlO0FBQy9DLHdDQUF3QztBQUN4Qyx5Q0FBeUM7QUFDekMsNkJBQTZCLGVBQWU7QUFDNUMsOEJBQThCO0FBQzlCLGtDQUFrQyxlQUFlO0FBQ2pELHlDQUF5QztBQUN6QywwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMENBQTBDO0FBQzFDLGdEQUFnRDtBQUNoRCwrQkFBK0IsZUFBZTtBQUM5QztBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHByb3ZpZGVyc1xcbmV0d29yay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIEEgKipOZXR3b3JrKiogZW5jYXBzdWxhdGVzIHRoZSB2YXJpb3VzIHByb3BlcnRpZXMgcmVxdWlyZWQgdG9cclxuICogIGludGVyYWN0IHdpdGggYSBzcGVjaWZpYyBjaGFpbi5cclxuICpcclxuICogIEBfc3Vic2VjdGlvbjogYXBpL3Byb3ZpZGVyczpOZXR3b3JrcyAgW25ldHdvcmtzXVxyXG4gKi9cclxuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBnZXRCaWdJbnQsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgRW5zUGx1Z2luLCBGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luLCBHYXNDb3N0UGx1Z2luIH0gZnJvbSBcIi4vcGx1Z2lucy1uZXR3b3JrLmpzXCI7XHJcbi8qICogKiAqXHJcbi8vIE5ldHdvcmtzIHdoaWNoIG9wZXJhdGlvbiBhZ2FpbnN0IGFuIEwyIGNhbiB1c2UgdGhpcyBwbHVnaW4gdG9cclxuLy8gc3BlY2lmeSBob3cgdG8gYWNjZXNzIEwxLCBmb3IgdGhlIHB1cnBvc2Ugb2YgcmVzb2x2aW5nIEVOUyxcclxuLy8gZm9yIGV4YW1wbGUuXHJcbmV4cG9ydCBjbGFzcyBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcclxuICAgIHJlYWRvbmx5IHByb3ZpZGVyITogUHJvdmlkZXI7XHJcbi8vIEBUT0RPOiBSZW5hbWUgdG8gQ2hhaW5BY2Nlc3MgYW5kIGFsbG93IGZvciBjb25uZWN0aW5nIHRvIGFueSBjaGFpblxyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXI6IFByb3ZpZGVyKSB7XHJcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubGF5ZXItb25lLWNvbm5lY3Rpb25cIik7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllczxMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4+KHRoaXMsIHsgcHJvdmlkZXIgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xvbmUoKTogTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luIHtcclxuICAgICAgICByZXR1cm4gbmV3IExheWVyT25lQ29ubmVjdGlvblBsdWdpbih0aGlzLnByb3ZpZGVyKTtcclxuICAgIH1cclxufVxyXG4qL1xyXG5jb25zdCBOZXR3b3JrcyA9IG5ldyBNYXAoKTtcclxuLyoqXHJcbiAqICBBICoqTmV0d29yayoqIHByb3ZpZGVzIGFjY2VzcyB0byBhIGNoYWluJ3MgcHJvcGVydGllcyBhbmQgYWxsb3dzXHJcbiAqICBmb3IgcGx1Zy1pbnMgdG8gZXh0ZW5kIGZ1bmN0aW9uYWxpdHkuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTmV0d29yayB7XHJcbiAgICAjbmFtZTtcclxuICAgICNjaGFpbklkO1xyXG4gICAgI3BsdWdpbnM7XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqTmV0d29yayoqIGZvciAlJW5hbWUlJSBhbmQgJSVjaGFpbklkJSUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGNoYWluSWQpIHtcclxuICAgICAgICB0aGlzLiNuYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLiNjaGFpbklkID0gZ2V0QmlnSW50KGNoYWluSWQpO1xyXG4gICAgICAgIHRoaXMuI3BsdWdpbnMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1jb21wYXRpYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgTmV0d29yay5cclxuICAgICAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7IG5hbWU6IHRoaXMubmFtZSwgY2hhaW5JZDogU3RyaW5nKHRoaXMuY2hhaW5JZCkgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBuZXR3b3JrIGNvbW1vbiBuYW1lLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIHRoZSBjYW5vbmljYWwgbmFtZSwgYXMgbmV0d29ya3MgbWlnaCBoYXZlIG11bHRpcGxlXHJcbiAgICAgKiAgbmFtZXMuXHJcbiAgICAgKi9cclxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy4jbmFtZTsgfVxyXG4gICAgc2V0IG5hbWUodmFsdWUpIHsgdGhpcy4jbmFtZSA9IHZhbHVlOyB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbmV0d29yayBjaGFpbiBJRC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGNoYWluSWQoKSB7IHJldHVybiB0aGlzLiNjaGFpbklkOyB9XHJcbiAgICBzZXQgY2hhaW5JZCh2YWx1ZSkgeyB0aGlzLiNjaGFpbklkID0gZ2V0QmlnSW50KHZhbHVlLCBcImNoYWluSWRcIik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgbWF0Y2hlcyB0aGlzIG5ldHdvcmsuIEFueSBjaGFpbiBJRFxyXG4gICAgICogIG11c3QgbWF0Y2gsIGFuZCBpZiBubyBjaGFpbiBJRCBpcyBwcmVzZW50LCB0aGUgbmFtZSBtdXN0IG1hdGNoLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIG1ldGhvZCBkb2VzIG5vdCBjdXJyZW50bHkgY2hlY2sgZm9yIGFkZGl0aW9uYWwgcHJvcGVydGllcyxcclxuICAgICAqICBzdWNoIGFzIEVOUyBhZGRyZXNzIG9yIHBsdWctaW4gY29tcGF0aWJpbGl0eS5cclxuICAgICAqL1xyXG4gICAgbWF0Y2hlcyhvdGhlcikge1xyXG4gICAgICAgIGlmIChvdGhlciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiAob3RoZXIpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhaW5JZCA9PT0gZ2V0QmlnSW50KG90aGVyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLm5hbWUgPT09IG90aGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiAob3RoZXIpID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiAob3RoZXIpID09PSBcImJpZ2ludFwiKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhaW5JZCA9PT0gZ2V0QmlnSW50KG90aGVyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIChvdGhlcikgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgaWYgKG90aGVyLmNoYWluSWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhaW5JZCA9PT0gZ2V0QmlnSW50KG90aGVyLmNoYWluSWQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG90aGVyLm5hbWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLm5hbWUgPT09IG90aGVyLm5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgbGlzdCBvZiBwbHVnaW5zIGN1cnJlbnRseSBhdHRhY2hlZCB0byB0aGlzIE5ldHdvcmsuXHJcbiAgICAgKi9cclxuICAgIGdldCBwbHVnaW5zKCkge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuI3BsdWdpbnMudmFsdWVzKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQXR0YWNoIGEgbmV3ICUlcGx1Z2luJSUgdG8gdGhpcyBOZXR3b3JrLiBUaGUgbmV0d29yayBuYW1lXHJcbiAgICAgKiAgbXVzdCBiZSB1bmlxdWUsIGV4Y2x1ZGluZyBhbnkgZnJhZ21lbnQuXHJcbiAgICAgKi9cclxuICAgIGF0dGFjaFBsdWdpbihwbHVnaW4pIHtcclxuICAgICAgICBpZiAodGhpcy4jcGx1Z2lucy5nZXQocGx1Z2luLm5hbWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlcGxhY2UgZXhpc3RpbmcgcGx1Z2luOiAke3BsdWdpbi5uYW1lfSBgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jcGx1Z2lucy5zZXQocGx1Z2luLm5hbWUsIHBsdWdpbi5jbG9uZSgpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiB0aGUgcGx1Z2luLCBpZiBhbnksIG1hdGNoaW5nICUlbmFtZSUlIGV4YWN0bHkuIFBsdWdpbnNcclxuICAgICAqICB3aXRoIGZyYWdtZW50cyB3aWxsIG5vdCBiZSByZXR1cm5lZCB1bmxlc3MgJSVuYW1lJSUgaW5jbHVkZXNcclxuICAgICAqICBhIGZyYWdtZW50LlxyXG4gICAgICovXHJcbiAgICBnZXRQbHVnaW4obmFtZSkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy4jcGx1Z2lucy5nZXQobmFtZSkpIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBHZXRzIGEgbGlzdCBvZiBhbGwgcGx1Z2lucyB0aGF0IG1hdGNoICUlbmFtZSUlLCB3aXRoIG90ciB3aXRob3V0XHJcbiAgICAgKiAgYSBmcmFnbWVudC5cclxuICAgICAqL1xyXG4gICAgZ2V0UGx1Z2lucyhiYXNlbmFtZSkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5wbHVnaW5zLmZpbHRlcigocCkgPT4gKHAubmFtZS5zcGxpdChcIiNcIilbMF0gPT09IGJhc2VuYW1lKSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIE5ldHdvcmsuXHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IE5ldHdvcmsodGhpcy5uYW1lLCB0aGlzLmNoYWluSWQpO1xyXG4gICAgICAgIHRoaXMucGx1Z2lucy5mb3JFYWNoKChwbHVnaW4pID0+IHtcclxuICAgICAgICAgICAgY2xvbmUuYXR0YWNoUGx1Z2luKHBsdWdpbi5jbG9uZSgpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDb21wdXRlIHRoZSBpbnRyaW5zaWMgZ2FzIHJlcXVpcmVkIGZvciBhIHRyYW5zYWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqICBBIEdhc0Nvc3RQbHVnaW4gY2FuIGJlIGF0dGFjaGVkIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0XHJcbiAgICAgKiAgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBjb21wdXRlSW50cmluc2ljR2FzKHR4KSB7XHJcbiAgICAgICAgY29uc3QgY29zdHMgPSB0aGlzLmdldFBsdWdpbihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkdhc0Nvc3RcIikgfHwgKG5ldyBHYXNDb3N0UGx1Z2luKCkpO1xyXG4gICAgICAgIGxldCBnYXMgPSBjb3N0cy50eEJhc2U7XHJcbiAgICAgICAgaWYgKHR4LnRvID09IG51bGwpIHtcclxuICAgICAgICAgICAgZ2FzICs9IGNvc3RzLnR4Q3JlYXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHguZGF0YSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IHR4LmRhdGEubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eC5kYXRhLnN1YnN0cmluZyhpLCBpICsgMikgPT09IFwiMDBcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eERhdGFaZXJvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FzICs9IGNvc3RzLnR4RGF0YU5vbnplcm87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR4LmFjY2Vzc0xpc3QpIHtcclxuICAgICAgICAgICAgY29uc3QgYWNjZXNzTGlzdCA9IGFjY2Vzc0xpc3RpZnkodHguYWNjZXNzTGlzdCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWRkciBpbiBhY2Nlc3NMaXN0KSB7XHJcbiAgICAgICAgICAgICAgICBnYXMgKz0gY29zdHMudHhBY2Nlc3NMaXN0QWRkcmVzcyArIGNvc3RzLnR4QWNjZXNzTGlzdFN0b3JhZ2VLZXkgKiBhY2Nlc3NMaXN0W2FkZHJdLnN0b3JhZ2VLZXlzLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ2FzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBOZXR3b3JrIGZvciB0aGUgJSVuZXR3b3JrJSUgbmFtZSBvciBjaGFpbklkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbShuZXR3b3JrKSB7XHJcbiAgICAgICAgaW5qZWN0Q29tbW9uTmV0d29ya3MoKTtcclxuICAgICAgICAvLyBEZWZhdWx0IG5ldHdvcmtcclxuICAgICAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOZXR3b3JrLmZyb20oXCJtYWlubmV0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDYW5vbmljYWwgbmFtZSBvciBjaGFpbiBJRFxyXG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIG5ldHdvcmsgPSBCaWdJbnQobmV0d29yayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiAobmV0d29yaykgPT09IFwiYmlnaW50XCIpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV0d29ya0Z1bmMgPSBOZXR3b3Jrcy5nZXQobmV0d29yayk7XHJcbiAgICAgICAgICAgIGlmIChuZXR3b3JrRnVuYykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcmtGdW5jKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwiYmlnaW50XCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmV0d29yayhcInVua25vd25cIiwgbmV0d29yayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5rbm93biBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2xvbmFibGUgd2l0aCBuZXR3b3JrLWxpa2UgYWJpbGl0aWVzXHJcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yay5jbG9uZSkgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICBjb25zdCBjbG9uZSA9IG5ldHdvcmsuY2xvbmUoKTtcclxuICAgICAgICAgICAgLy9pZiAodHlwZW9mKG5ldHdvcmsubmFtZSkgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mKG5ldHdvcmsuY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgLy99XHJcbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTmV0d29ya2lzaFxyXG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAobmV0d29yay5uYW1lKSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgKG5ldHdvcmsuY2hhaW5JZCkgPT09IFwibnVtYmVyXCIsIFwiaW52YWxpZCBuZXR3b3JrIG9iamVjdCBuYW1lIG9yIGNoYWluSWRcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xyXG4gICAgICAgICAgICBjb25zdCBjdXN0b20gPSBuZXcgTmV0d29yaygobmV0d29yay5uYW1lKSwgKG5ldHdvcmsuY2hhaW5JZCkpO1xyXG4gICAgICAgICAgICBpZiAobmV0d29yay5lbnNBZGRyZXNzIHx8IG5ldHdvcmsuZW5zTmV0d29yayAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjdXN0b20uYXR0YWNoUGx1Z2luKG5ldyBFbnNQbHVnaW4obmV0d29yay5lbnNBZGRyZXNzLCBuZXR3b3JrLmVuc05ldHdvcmspKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2lmICgoPGFueT5uZXR3b3JrKS5sYXllck9uZUNvbm5lY3Rpb24pIHtcclxuICAgICAgICAgICAgLy8gICAgY3VzdG9tLmF0dGFjaFBsdWdpbihuZXcgTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luKCg8YW55Pm5ldHdvcmspLmxheWVyT25lQ29ubmVjdGlvbikpO1xyXG4gICAgICAgICAgICAvL31cclxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlZ2lzdGVyICUlbmFtZU9yQ2hhaW5JZCUlIHdpdGggYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zXHJcbiAgICAgKiAgYW4gaW5zdGFuY2Ugb2YgYSBOZXR3b3JrIHJlcHJlc2VudGluZyB0aGF0IGNoYWluLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcmVnaXN0ZXIobmFtZU9yQ2hhaW5JZCwgbmV0d29ya0Z1bmMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIChuYW1lT3JDaGFpbklkKSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBuYW1lT3JDaGFpbklkID0gQmlnSW50KG5hbWVPckNoYWluSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBleGlzdGluZyA9IE5ldHdvcmtzLmdldChuYW1lT3JDaGFpbklkKTtcclxuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBjb25mbGljdGluZyBuZXR3b3JrIGZvciAke0pTT04uc3RyaW5naWZ5KGV4aXN0aW5nLm5hbWUpfWAsIFwibmFtZU9yQ2hhaW5JZFwiLCBuYW1lT3JDaGFpbklkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgTmV0d29ya3Muc2V0KG5hbWVPckNoYWluSWQsIG5ldHdvcmtGdW5jKTtcclxuICAgIH1cclxufVxyXG4vLyBXZSBkb24ndCB3YW50IHRvIGJyaW5nIGluIGZvcm1hdFVuaXRzIGJlY2F1c2UgaXQgaXMgYmFja2VkIGJ5XHJcbi8vIEZpeGVkTnVtYmVyIGFuZCB3ZSB3YW50IHRvIGtlZXAgTmV0d29ya3MgdGlueS4gVGhlIHZhbHVlc1xyXG4vLyBpbmNsdWRlZCBieSB0aGUgR2FzIFN0YXRpb25zIGFyZSBhbHNvIElFRUUgNzU0IHdpdGggbG90cyBvZlxyXG4vLyByb3VuZGluZyBpc3N1ZXMgYW5kIGV4Y2VlZCB0aGUgc3RyaWN0IGNoZWNrcyBmb3JtYXRVbml0cyBoYXMuXHJcbmZ1bmN0aW9uIHBhcnNlVW5pdHMoX3ZhbHVlLCBkZWNpbWFscykge1xyXG4gICAgY29uc3QgdmFsdWUgPSBTdHJpbmcoX3ZhbHVlKTtcclxuICAgIGlmICghdmFsdWUubWF0Y2goL15bMC05Ll0rJC8pKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGd3ZWkgdmFsdWU6ICR7X3ZhbHVlfWApO1xyXG4gICAgfVxyXG4gICAgLy8gQnJlYWsgaW50byBbIHdob2xlLCBmcmFjdGlvbiBdXHJcbiAgICBjb25zdCBjb21wcyA9IHZhbHVlLnNwbGl0KFwiLlwiKTtcclxuICAgIGlmIChjb21wcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBjb21wcy5wdXNoKFwiXCIpO1xyXG4gICAgfVxyXG4gICAgLy8gTW9yZSB0aGFuIDEgZGVjaW1hbCBwb2ludCBvciB0b28gbWFueSBmcmFjdGlvbmFsIHBvc2l0aW9uc1xyXG4gICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gMikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBnd2VpIHZhbHVlOiAke192YWx1ZX1gKTtcclxuICAgIH1cclxuICAgIC8vIFBhZCB0aGUgZnJhY3Rpb24gdG8gOSBkZWNpbWFscGxhY2VzXHJcbiAgICB3aGlsZSAoY29tcHNbMV0ubGVuZ3RoIDwgZGVjaW1hbHMpIHtcclxuICAgICAgICBjb21wc1sxXSArPSBcIjBcIjtcclxuICAgIH1cclxuICAgIC8vIFRvbyBtYW55IGRlY2ltYWxzIGFuZCBzb21lIG5vbi16ZXJvIGVuZGluZywgdGFrZSB0aGUgY2VpbGluZ1xyXG4gICAgaWYgKGNvbXBzWzFdLmxlbmd0aCA+IDkpIHtcclxuICAgICAgICBsZXQgZnJhYyA9IEJpZ0ludChjb21wc1sxXS5zdWJzdHJpbmcoMCwgOSkpO1xyXG4gICAgICAgIGlmICghY29tcHNbMV0uc3Vic3RyaW5nKDkpLm1hdGNoKC9eMCskLykpIHtcclxuICAgICAgICAgICAgZnJhYysrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wc1sxXSA9IGZyYWMudG9TdHJpbmcoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBCaWdJbnQoY29tcHNbMF0gKyBjb21wc1sxXSk7XHJcbn1cclxuLy8gVXNlZCBieSBQb2x5Z29uIHRvIHVzZSBhIGdhcyBzdGF0aW9uIGZvciBmZWUgZGF0YVxyXG5mdW5jdGlvbiBnZXRHYXNTdGF0aW9uUGx1Z2luKHVybCkge1xyXG4gICAgcmV0dXJuIG5ldyBGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luKHVybCwgYXN5bmMgKGZldGNoRmVlRGF0YSwgcHJvdmlkZXIsIHJlcXVlc3QpID0+IHtcclxuICAgICAgICAvLyBQcmV2ZW50IENsb3VkZmxhcmUgZnJvbSBibG9ja2luZyBvdXIgcmVxdWVzdCBpbiBub2RlLmpzXHJcbiAgICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoXCJVc2VyLUFnZW50XCIsIFwiZXRoZXJzXCIpO1xyXG4gICAgICAgIGxldCByZXNwb25zZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBbX3Jlc3BvbnNlLCBfZmVlRGF0YV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnNlbmQoKSwgZmV0Y2hGZWVEYXRhKClcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIHJlc3BvbnNlID0gX3Jlc3BvbnNlO1xyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gcmVzcG9uc2UuYm9keUpzb24uc3RhbmRhcmQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogX2ZlZURhdGEuZ2FzUHJpY2UsXHJcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHBhcnNlVW5pdHMocGF5bG9hZC5tYXhGZWUsIDkpLFxyXG4gICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHBhcnNlVW5pdHMocGF5bG9hZC5tYXhQcmlvcml0eUZlZSwgOSksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBmZWVEYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgZXJyb3IgZW5jb3VudGVyZWQgd2l0aCBwb2x5Z29uIGdhcyBzdGF0aW9uICgke0pTT04uc3RyaW5naWZ5KHJlcXVlc3QudXJsKX0pYCwgXCJTRVJWRVJfRVJST1JcIiwgeyByZXF1ZXN0LCByZXNwb25zZSwgZXJyb3IgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuLy8gU2VlOiBodHRwczovL2NoYWlubGlzdC5vcmdcclxubGV0IGluamVjdGVkID0gZmFsc2U7XHJcbmZ1bmN0aW9uIGluamVjdENvbW1vbk5ldHdvcmtzKCkge1xyXG4gICAgaWYgKGluamVjdGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaW5qZWN0ZWQgPSB0cnVlO1xyXG4gICAgLy8vIFJlZ2lzdGVyIHBvcHVsYXIgRXRoZXJldW0gbmV0d29ya3NcclxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRXRoKG5hbWUsIGNoYWluSWQsIG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBmdW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV3IE5ldHdvcmsobmFtZSwgY2hhaW5JZCk7XHJcbiAgICAgICAgICAgIC8vIFdlIHVzZSAwIHRvIGRpc2FibGUgRU5TXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVuc05ldHdvcmsgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbmV0d29yay5hdHRhY2hQbHVnaW4obmV3IEVuc1BsdWdpbihudWxsLCBvcHRpb25zLmVuc05ldHdvcmspKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXR3b3JrLmF0dGFjaFBsdWdpbihuZXcgR2FzQ29zdFBsdWdpbigpKTtcclxuICAgICAgICAgICAgKG9wdGlvbnMucGx1Z2lucyB8fCBbXSkuZm9yRWFjaCgocGx1Z2luKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBuZXR3b3JrLmF0dGFjaFBsdWdpbihwbHVnaW4pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBSZWdpc3RlciB0aGUgbmV0d29yayBieSBuYW1lIGFuZCBjaGFpbiBJRFxyXG4gICAgICAgIE5ldHdvcmsucmVnaXN0ZXIobmFtZSwgZnVuYyk7XHJcbiAgICAgICAgTmV0d29yay5yZWdpc3RlcihjaGFpbklkLCBmdW5jKTtcclxuICAgICAgICBpZiAob3B0aW9ucy5hbHROYW1lcykge1xyXG4gICAgICAgICAgICBvcHRpb25zLmFsdE5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcclxuICAgICAgICAgICAgICAgIE5ldHdvcmsucmVnaXN0ZXIobmFtZSwgZnVuYyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZ2lzdGVyRXRoKFwibWFpbm5ldFwiLCAxLCB7IGVuc05ldHdvcms6IDEsIGFsdE5hbWVzOiBbXCJob21lc3RlYWRcIl0gfSk7XHJcbiAgICByZWdpc3RlckV0aChcInJvcHN0ZW5cIiwgMywgeyBlbnNOZXR3b3JrOiAzIH0pO1xyXG4gICAgcmVnaXN0ZXJFdGgoXCJyaW5rZWJ5XCIsIDQsIHsgZW5zTmV0d29yazogNCB9KTtcclxuICAgIHJlZ2lzdGVyRXRoKFwiZ29lcmxpXCIsIDUsIHsgZW5zTmV0d29yazogNSB9KTtcclxuICAgIHJlZ2lzdGVyRXRoKFwia292YW5cIiwgNDIsIHsgZW5zTmV0d29yazogNDIgfSk7XHJcbiAgICByZWdpc3RlckV0aChcInNlcG9saWFcIiwgMTExNTUxMTEsIHsgZW5zTmV0d29yazogMTExNTUxMTEgfSk7XHJcbiAgICByZWdpc3RlckV0aChcImhvbGVza3lcIiwgMTcwMDAsIHsgZW5zTmV0d29yazogMTcwMDAgfSk7XHJcbiAgICByZWdpc3RlckV0aChcImNsYXNzaWNcIiwgNjEsIHt9KTtcclxuICAgIHJlZ2lzdGVyRXRoKFwiY2xhc3NpY0tvdHRpXCIsIDYsIHt9KTtcclxuICAgIHJlZ2lzdGVyRXRoKFwiYXJiaXRydW1cIiwgNDIxNjEsIHtcclxuICAgICAgICBlbnNOZXR3b3JrOiAxLFxyXG4gICAgfSk7XHJcbiAgICByZWdpc3RlckV0aChcImFyYml0cnVtLWdvZXJsaVwiLCA0MjE2MTMsIHt9KTtcclxuICAgIHJlZ2lzdGVyRXRoKFwiYXJiaXRydW0tc2Vwb2xpYVwiLCA0MjE2MTQsIHt9KTtcclxuICAgIHJlZ2lzdGVyRXRoKFwiYmFzZVwiLCA4NDUzLCB7IGVuc05ldHdvcms6IDEgfSk7XHJcbiAgICByZWdpc3RlckV0aChcImJhc2UtZ29lcmxpXCIsIDg0NTMxLCB7fSk7XHJcbiAgICByZWdpc3RlckV0aChcImJhc2Utc2Vwb2xpYVwiLCA4NDUzMiwge30pO1xyXG4gICAgcmVnaXN0ZXJFdGgoXCJibmJcIiwgNTYsIHsgZW5zTmV0d29yazogMSB9KTtcclxuICAgIHJlZ2lzdGVyRXRoKFwiYm5idFwiLCA5Nywge30pO1xyXG4gICAgcmVnaXN0ZXJFdGgoXCJsaW5lYVwiLCA1OTE0NCwgeyBlbnNOZXR3b3JrOiAxIH0pO1xyXG4gICAgcmVnaXN0ZXJFdGgoXCJsaW5lYS1nb2VybGlcIiwgNTkxNDAsIHt9KTtcclxuICAgIHJlZ2lzdGVyRXRoKFwibGluZWEtc2Vwb2xpYVwiLCA1OTE0MSwge30pO1xyXG4gICAgcmVnaXN0ZXJFdGgoXCJtYXRpY1wiLCAxMzcsIHtcclxuICAgICAgICBlbnNOZXR3b3JrOiAxLFxyXG4gICAgICAgIHBsdWdpbnM6IFtcclxuICAgICAgICAgICAgZ2V0R2FzU3RhdGlvblBsdWdpbihcImh0dHBzOi9cXC9nYXNzdGF0aW9uLnBvbHlnb24udGVjaG5vbG9neS92MlwiKVxyXG4gICAgICAgIF1cclxuICAgIH0pO1xyXG4gICAgcmVnaXN0ZXJFdGgoXCJtYXRpYy1hbW95XCIsIDgwMDAyLCB7fSk7XHJcbiAgICByZWdpc3RlckV0aChcIm1hdGljLW11bWJhaVwiLCA4MDAwMSwge1xyXG4gICAgICAgIGFsdE5hbWVzOiBbXCJtYXRpY011bWJhaVwiLCBcIm1hdGljbXVtXCJdLFxyXG4gICAgICAgIHBsdWdpbnM6IFtcclxuICAgICAgICAgICAgZ2V0R2FzU3RhdGlvblBsdWdpbihcImh0dHBzOi9cXC9nYXNzdGF0aW9uLXRlc3RuZXQucG9seWdvbi50ZWNobm9sb2d5L3YyXCIpXHJcbiAgICAgICAgXVxyXG4gICAgfSk7XHJcbiAgICByZWdpc3RlckV0aChcIm9wdGltaXNtXCIsIDEwLCB7XHJcbiAgICAgICAgZW5zTmV0d29yazogMSxcclxuICAgICAgICBwbHVnaW5zOiBbXVxyXG4gICAgfSk7XHJcbiAgICByZWdpc3RlckV0aChcIm9wdGltaXNtLWdvZXJsaVwiLCA0MjAsIHt9KTtcclxuICAgIHJlZ2lzdGVyRXRoKFwib3B0aW1pc20tc2Vwb2xpYVwiLCAxMTE1NTQyMCwge30pO1xyXG4gICAgcmVnaXN0ZXJFdGgoXCJ4ZGFpXCIsIDEwMCwgeyBlbnNOZXR3b3JrOiAxIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmsuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/network.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/plugins-network.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/plugins-network.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnsPlugin: () => (/* binding */ EnsPlugin),\n/* harmony export */   FeeDataNetworkPlugin: () => (/* binding */ FeeDataNetworkPlugin),\n/* harmony export */   FetchUrlFeeDataNetworkPlugin: () => (/* binding */ FetchUrlFeeDataNetworkPlugin),\n/* harmony export */   GasCostPlugin: () => (/* binding */ GasCostPlugin),\n/* harmony export */   NetworkPlugin: () => (/* binding */ NetworkPlugin)\n/* harmony export */ });\n/* harmony import */ var _utils_properties_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/properties.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n\r\n\r\nconst EnsAddress = \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\";\r\n/**\r\n *  A **NetworkPlugin** provides additional functionality on a [[Network]].\r\n */\r\nclass NetworkPlugin {\r\n    /**\r\n     *  The name of the plugin.\r\n     *\r\n     *  It is recommended to use reverse-domain-notation, which permits\r\n     *  unique names with a known authority as well as hierarchal entries.\r\n     */\r\n    name;\r\n    /**\r\n     *  Creates a new **NetworkPlugin**.\r\n     */\r\n    constructor(name) {\r\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { name });\r\n    }\r\n    /**\r\n     *  Creates a copy of this plugin.\r\n     */\r\n    clone() {\r\n        return new NetworkPlugin(this.name);\r\n    }\r\n}\r\n/**\r\n *  A **GasCostPlugin** allows a network to provide alternative values when\r\n *  computing the intrinsic gas required for a transaction.\r\n */\r\nclass GasCostPlugin extends NetworkPlugin {\r\n    /**\r\n     *  The block number to treat these values as valid from.\r\n     *\r\n     *  This allows a hardfork to have updated values included as well as\r\n     *  mulutiple hardforks to be supported.\r\n     */\r\n    effectiveBlock;\r\n    /**\r\n     *  The transactions base fee.\r\n     */\r\n    txBase;\r\n    /**\r\n     *  The fee for creating a new account.\r\n     */\r\n    txCreate;\r\n    /**\r\n     *  The fee per zero-byte in the data.\r\n     */\r\n    txDataZero;\r\n    /**\r\n     *  The fee per non-zero-byte in the data.\r\n     */\r\n    txDataNonzero;\r\n    /**\r\n     *  The fee per storage key in the [[link-eip-2930]] access list.\r\n     */\r\n    txAccessListStorageKey;\r\n    /**\r\n     *  The fee per address in the [[link-eip-2930]] access list.\r\n     */\r\n    txAccessListAddress;\r\n    /**\r\n     *  Creates a new GasCostPlugin from %%effectiveBlock%% until the\r\n     *  latest block or another GasCostPlugin supercedes that block number,\r\n     *  with the associated %%costs%%.\r\n     */\r\n    constructor(effectiveBlock, costs) {\r\n        if (effectiveBlock == null) {\r\n            effectiveBlock = 0;\r\n        }\r\n        super(`org.ethers.network.plugins.GasCost#${(effectiveBlock || 0)}`);\r\n        const props = { effectiveBlock };\r\n        function set(name, nullish) {\r\n            let value = (costs || {})[name];\r\n            if (value == null) {\r\n                value = nullish;\r\n            }\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof (value) === \"number\", `invalud value for ${name}`, \"costs\", costs);\r\n            props[name] = value;\r\n        }\r\n        set(\"txBase\", 21000);\r\n        set(\"txCreate\", 32000);\r\n        set(\"txDataZero\", 4);\r\n        set(\"txDataNonzero\", 16);\r\n        set(\"txAccessListStorageKey\", 1900);\r\n        set(\"txAccessListAddress\", 2400);\r\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, props);\r\n    }\r\n    clone() {\r\n        return new GasCostPlugin(this.effectiveBlock, this);\r\n    }\r\n}\r\n/**\r\n *  An **EnsPlugin** allows a [[Network]] to specify the ENS Registry\r\n *  Contract address and the target network to use when using that\r\n *  contract.\r\n *\r\n *  Various testnets have their own instance of the contract to use, but\r\n *  in general, the mainnet instance supports multi-chain addresses and\r\n *  should be used.\r\n */\r\nclass EnsPlugin extends NetworkPlugin {\r\n    /**\r\n     *  The ENS Registrty Contract address.\r\n     */\r\n    address;\r\n    /**\r\n     *  The chain ID that the ENS contract lives on.\r\n     */\r\n    targetNetwork;\r\n    /**\r\n     *  Creates a new **EnsPlugin** connected to %%address%% on the\r\n     *  %%targetNetwork%%. The default ENS address and mainnet is used\r\n     *  if unspecified.\r\n     */\r\n    constructor(address, targetNetwork) {\r\n        super(\"org.ethers.plugins.network.Ens\");\r\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\r\n            address: (address || EnsAddress),\r\n            targetNetwork: ((targetNetwork == null) ? 1 : targetNetwork)\r\n        });\r\n    }\r\n    clone() {\r\n        return new EnsPlugin(this.address, this.targetNetwork);\r\n    }\r\n}\r\n/**\r\n *  A **FeeDataNetworkPlugin** allows a network to provide and alternate\r\n *  means to specify its fee data.\r\n *\r\n *  For example, a network which does not support [[link-eip-1559]] may\r\n *  choose to use a Gas Station site to approximate the gas price.\r\n */\r\nclass FeeDataNetworkPlugin extends NetworkPlugin {\r\n    #feeDataFunc;\r\n    /**\r\n     *  The fee data function provided to the constructor.\r\n     */\r\n    get feeDataFunc() {\r\n        return this.#feeDataFunc;\r\n    }\r\n    /**\r\n     *  Creates a new **FeeDataNetworkPlugin**.\r\n     */\r\n    constructor(feeDataFunc) {\r\n        super(\"org.ethers.plugins.network.FeeData\");\r\n        this.#feeDataFunc = feeDataFunc;\r\n    }\r\n    /**\r\n     *  Resolves to the fee data.\r\n     */\r\n    async getFeeData(provider) {\r\n        return await this.#feeDataFunc(provider);\r\n    }\r\n    clone() {\r\n        return new FeeDataNetworkPlugin(this.#feeDataFunc);\r\n    }\r\n}\r\nclass FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {\r\n    #url;\r\n    #processFunc;\r\n    /**\r\n     *  The URL to initialize the FetchRequest with in %%processFunc%%.\r\n     */\r\n    get url() { return this.#url; }\r\n    /**\r\n     *  The callback to use when computing the FeeData.\r\n     */\r\n    get processFunc() { return this.#processFunc; }\r\n    /**\r\n     *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will\r\n     *  be used when computing the fee data for the network.\r\n     */\r\n    constructor(url, processFunc) {\r\n        super(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\r\n        this.#url = url;\r\n        this.#processFunc = processFunc;\r\n    }\r\n    // We are immutable, so we can serve as our own clone\r\n    clone() { return this; }\r\n}\r\n/*\r\nexport class CustomBlockNetworkPlugin extends NetworkPlugin {\r\n    readonly #blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>;\r\n    readonly #blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>;\r\n\r\n    constructor(blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>, blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>) {\r\n        super(\"org.ethers.network-plugins.custom-block\");\r\n        this.#blockFunc = blockFunc;\r\n        this.#blockWithTxsFunc = blockWithTxsFunc;\r\n    }\r\n\r\n    async getBlock(provider: Provider, block: BlockParams<string>): Promise<Block<string>> {\r\n        return await this.#blockFunc(provider, block);\r\n    }\r\n\r\n    async getBlockions(provider: Provider, block: BlockParams<TransactionResponseParams>): Promise<Block<TransactionResponse>> {\r\n        return await this.#blockWithTxsFunc(provider, block);\r\n    }\r\n\r\n    clone(): CustomBlockNetworkPlugin {\r\n        return new CustomBlockNetworkPlugin(this.#blockFunc, this.#blockWithTxsFunc);\r\n    }\r\n}\r\n*/\r\n//# sourceMappingURL=plugins-network.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcGx1Z2lucy1uZXR3b3JrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMEQ7QUFDUDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0VBQWdCLFNBQVMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHNCQUFzQjtBQUMxRSx3QkFBd0I7QUFDeEI7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBYyxtREFBbUQsS0FBSztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzRUFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzRUFBZ0I7QUFDeEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxwcm92aWRlcnNcXHBsdWdpbnMtbmV0d29yay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uL3V0aWxzL3Byb3BlcnRpZXMuanNcIjtcclxuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuY29uc3QgRW5zQWRkcmVzcyA9IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCI7XHJcbi8qKlxyXG4gKiAgQSAqKk5ldHdvcmtQbHVnaW4qKiBwcm92aWRlcyBhZGRpdGlvbmFsIGZ1bmN0aW9uYWxpdHkgb24gYSBbW05ldHdvcmtdXS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBOZXR3b3JrUGx1Z2luIHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4uXHJcbiAgICAgKlxyXG4gICAgICogIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSByZXZlcnNlLWRvbWFpbi1ub3RhdGlvbiwgd2hpY2ggcGVybWl0c1xyXG4gICAgICogIHVuaXF1ZSBuYW1lcyB3aXRoIGEga25vd24gYXV0aG9yaXR5IGFzIHdlbGwgYXMgaGllcmFyY2hhbCBlbnRyaWVzLlxyXG4gICAgICovXHJcbiAgICBuYW1lO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk5ldHdvcmtQbHVnaW4qKi5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBwbHVnaW4uXHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTmV0d29ya1BsdWdpbih0aGlzLm5hbWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgQSAqKkdhc0Nvc3RQbHVnaW4qKiBhbGxvd3MgYSBuZXR3b3JrIHRvIHByb3ZpZGUgYWx0ZXJuYXRpdmUgdmFsdWVzIHdoZW5cclxuICogIGNvbXB1dGluZyB0aGUgaW50cmluc2ljIGdhcyByZXF1aXJlZCBmb3IgYSB0cmFuc2FjdGlvbi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBHYXNDb3N0UGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIHRvIHRyZWF0IHRoZXNlIHZhbHVlcyBhcyB2YWxpZCBmcm9tLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGFsbG93cyBhIGhhcmRmb3JrIHRvIGhhdmUgdXBkYXRlZCB2YWx1ZXMgaW5jbHVkZWQgYXMgd2VsbCBhc1xyXG4gICAgICogIG11bHV0aXBsZSBoYXJkZm9ya3MgdG8gYmUgc3VwcG9ydGVkLlxyXG4gICAgICovXHJcbiAgICBlZmZlY3RpdmVCbG9jaztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbnMgYmFzZSBmZWUuXHJcbiAgICAgKi9cclxuICAgIHR4QmFzZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBmZWUgZm9yIGNyZWF0aW5nIGEgbmV3IGFjY291bnQuXHJcbiAgICAgKi9cclxuICAgIHR4Q3JlYXRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGZlZSBwZXIgemVyby1ieXRlIGluIHRoZSBkYXRhLlxyXG4gICAgICovXHJcbiAgICB0eERhdGFaZXJvO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGZlZSBwZXIgbm9uLXplcm8tYnl0ZSBpbiB0aGUgZGF0YS5cclxuICAgICAqL1xyXG4gICAgdHhEYXRhTm9uemVybztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBmZWUgcGVyIHN0b3JhZ2Uga2V5IGluIHRoZSBbW2xpbmstZWlwLTI5MzBdXSBhY2Nlc3MgbGlzdC5cclxuICAgICAqL1xyXG4gICAgdHhBY2Nlc3NMaXN0U3RvcmFnZUtleTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBmZWUgcGVyIGFkZHJlc3MgaW4gdGhlIFtbbGluay1laXAtMjkzMF1dIGFjY2VzcyBsaXN0LlxyXG4gICAgICovXHJcbiAgICB0eEFjY2Vzc0xpc3RBZGRyZXNzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBHYXNDb3N0UGx1Z2luIGZyb20gJSVlZmZlY3RpdmVCbG9jayUlIHVudGlsIHRoZVxyXG4gICAgICogIGxhdGVzdCBibG9jayBvciBhbm90aGVyIEdhc0Nvc3RQbHVnaW4gc3VwZXJjZWRlcyB0aGF0IGJsb2NrIG51bWJlcixcclxuICAgICAqICB3aXRoIHRoZSBhc3NvY2lhdGVkICUlY29zdHMlJS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZWZmZWN0aXZlQmxvY2ssIGNvc3RzKSB7XHJcbiAgICAgICAgaWYgKGVmZmVjdGl2ZUJsb2NrID09IG51bGwpIHtcclxuICAgICAgICAgICAgZWZmZWN0aXZlQmxvY2sgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlcihgb3JnLmV0aGVycy5uZXR3b3JrLnBsdWdpbnMuR2FzQ29zdCMkeyhlZmZlY3RpdmVCbG9jayB8fCAwKX1gKTtcclxuICAgICAgICBjb25zdCBwcm9wcyA9IHsgZWZmZWN0aXZlQmxvY2sgfTtcclxuICAgICAgICBmdW5jdGlvbiBzZXQobmFtZSwgbnVsbGlzaCkge1xyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAoY29zdHMgfHwge30pW25hbWVdO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsaXNoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiLCBgaW52YWx1ZCB2YWx1ZSBmb3IgJHtuYW1lfWAsIFwiY29zdHNcIiwgY29zdHMpO1xyXG4gICAgICAgICAgICBwcm9wc1tuYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXQoXCJ0eEJhc2VcIiwgMjEwMDApO1xyXG4gICAgICAgIHNldChcInR4Q3JlYXRlXCIsIDMyMDAwKTtcclxuICAgICAgICBzZXQoXCJ0eERhdGFaZXJvXCIsIDQpO1xyXG4gICAgICAgIHNldChcInR4RGF0YU5vbnplcm9cIiwgMTYpO1xyXG4gICAgICAgIHNldChcInR4QWNjZXNzTGlzdFN0b3JhZ2VLZXlcIiwgMTkwMCk7XHJcbiAgICAgICAgc2V0KFwidHhBY2Nlc3NMaXN0QWRkcmVzc1wiLCAyNDAwKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHByb3BzKTtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgR2FzQ29zdFBsdWdpbih0aGlzLmVmZmVjdGl2ZUJsb2NrLCB0aGlzKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEFuICoqRW5zUGx1Z2luKiogYWxsb3dzIGEgW1tOZXR3b3JrXV0gdG8gc3BlY2lmeSB0aGUgRU5TIFJlZ2lzdHJ5XHJcbiAqICBDb250cmFjdCBhZGRyZXNzIGFuZCB0aGUgdGFyZ2V0IG5ldHdvcmsgdG8gdXNlIHdoZW4gdXNpbmcgdGhhdFxyXG4gKiAgY29udHJhY3QuXHJcbiAqXHJcbiAqICBWYXJpb3VzIHRlc3RuZXRzIGhhdmUgdGhlaXIgb3duIGluc3RhbmNlIG9mIHRoZSBjb250cmFjdCB0byB1c2UsIGJ1dFxyXG4gKiAgaW4gZ2VuZXJhbCwgdGhlIG1haW5uZXQgaW5zdGFuY2Ugc3VwcG9ydHMgbXVsdGktY2hhaW4gYWRkcmVzc2VzIGFuZFxyXG4gKiAgc2hvdWxkIGJlIHVzZWQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRW5zUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgRU5TIFJlZ2lzdHJ0eSBDb250cmFjdCBhZGRyZXNzLlxyXG4gICAgICovXHJcbiAgICBhZGRyZXNzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGNoYWluIElEIHRoYXQgdGhlIEVOUyBjb250cmFjdCBsaXZlcyBvbi5cclxuICAgICAqL1xyXG4gICAgdGFyZ2V0TmV0d29yaztcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipFbnNQbHVnaW4qKiBjb25uZWN0ZWQgdG8gJSVhZGRyZXNzJSUgb24gdGhlXHJcbiAgICAgKiAgJSV0YXJnZXROZXR3b3JrJSUuIFRoZSBkZWZhdWx0IEVOUyBhZGRyZXNzIGFuZCBtYWlubmV0IGlzIHVzZWRcclxuICAgICAqICBpZiB1bnNwZWNpZmllZC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgdGFyZ2V0TmV0d29yaykge1xyXG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRW5zXCIpO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xyXG4gICAgICAgICAgICBhZGRyZXNzOiAoYWRkcmVzcyB8fCBFbnNBZGRyZXNzKSxcclxuICAgICAgICAgICAgdGFyZ2V0TmV0d29yazogKCh0YXJnZXROZXR3b3JrID09IG51bGwpID8gMSA6IHRhcmdldE5ldHdvcmspXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEVuc1BsdWdpbih0aGlzLmFkZHJlc3MsIHRoaXMudGFyZ2V0TmV0d29yayk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBBICoqRmVlRGF0YU5ldHdvcmtQbHVnaW4qKiBhbGxvd3MgYSBuZXR3b3JrIHRvIHByb3ZpZGUgYW5kIGFsdGVybmF0ZVxyXG4gKiAgbWVhbnMgdG8gc3BlY2lmeSBpdHMgZmVlIGRhdGEuXHJcbiAqXHJcbiAqICBGb3IgZXhhbXBsZSwgYSBuZXR3b3JrIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgW1tsaW5rLWVpcC0xNTU5XV0gbWF5XHJcbiAqICBjaG9vc2UgdG8gdXNlIGEgR2FzIFN0YXRpb24gc2l0ZSB0byBhcHByb3hpbWF0ZSB0aGUgZ2FzIHByaWNlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEZlZURhdGFOZXR3b3JrUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XHJcbiAgICAjZmVlRGF0YUZ1bmM7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZmVlIGRhdGEgZnVuY3Rpb24gcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxyXG4gICAgICovXHJcbiAgICBnZXQgZmVlRGF0YUZ1bmMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZlZURhdGFGdW5jO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZlZURhdGFOZXR3b3JrUGx1Z2luKiouXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGZlZURhdGFGdW5jKSB7XHJcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5GZWVEYXRhXCIpO1xyXG4gICAgICAgIHRoaXMuI2ZlZURhdGFGdW5jID0gZmVlRGF0YUZ1bmM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgZmVlIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldEZlZURhdGEocHJvdmlkZXIpIHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jZmVlRGF0YUZ1bmMocHJvdmlkZXIpO1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGZWVEYXRhTmV0d29ya1BsdWdpbih0aGlzLiNmZWVEYXRhRnVuYyk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIEZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcclxuICAgICN1cmw7XHJcbiAgICAjcHJvY2Vzc0Z1bmM7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgVVJMIHRvIGluaXRpYWxpemUgdGhlIEZldGNoUmVxdWVzdCB3aXRoIGluICUlcHJvY2Vzc0Z1bmMlJS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHVybCgpIHsgcmV0dXJuIHRoaXMuI3VybDsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGNhbGxiYWNrIHRvIHVzZSB3aGVuIGNvbXB1dGluZyB0aGUgRmVlRGF0YS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHByb2Nlc3NGdW5jKCkgeyByZXR1cm4gdGhpcy4jcHJvY2Vzc0Z1bmM7IH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luKiogd2hpY2ggd2lsbFxyXG4gICAgICogIGJlIHVzZWQgd2hlbiBjb21wdXRpbmcgdGhlIGZlZSBkYXRhIGZvciB0aGUgbmV0d29yay5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodXJsLCBwcm9jZXNzRnVuYykge1xyXG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRmV0Y2hVcmxGZWVEYXRhUGx1Z2luXCIpO1xyXG4gICAgICAgIHRoaXMuI3VybCA9IHVybDtcclxuICAgICAgICB0aGlzLiNwcm9jZXNzRnVuYyA9IHByb2Nlc3NGdW5jO1xyXG4gICAgfVxyXG4gICAgLy8gV2UgYXJlIGltbXV0YWJsZSwgc28gd2UgY2FuIHNlcnZlIGFzIG91ciBvd24gY2xvbmVcclxuICAgIGNsb25lKCkgeyByZXR1cm4gdGhpczsgfVxyXG59XHJcbi8qXHJcbmV4cG9ydCBjbGFzcyBDdXN0b21CbG9ja05ldHdvcmtQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcclxuICAgIHJlYWRvbmx5ICNibG9ja0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxzdHJpbmc+KSA9PiBCbG9jazxzdHJpbmc+O1xyXG4gICAgcmVhZG9ubHkgI2Jsb2NrV2l0aFR4c0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxUcmFuc2FjdGlvblJlc3BvbnNlUGFyYW1zPikgPT4gQmxvY2s8VHJhbnNhY3Rpb25SZXNwb25zZT47XHJcblxyXG4gICAgY29uc3RydWN0b3IoYmxvY2tGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8c3RyaW5nPikgPT4gQmxvY2s8c3RyaW5nPiwgYmxvY2tXaXRoVHhzRnVuYzogKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPFRyYW5zYWN0aW9uUmVzcG9uc2VQYXJhbXM+KSA9PiBCbG9jazxUcmFuc2FjdGlvblJlc3BvbnNlPikge1xyXG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5uZXR3b3JrLXBsdWdpbnMuY3VzdG9tLWJsb2NrXCIpO1xyXG4gICAgICAgIHRoaXMuI2Jsb2NrRnVuYyA9IGJsb2NrRnVuYztcclxuICAgICAgICB0aGlzLiNibG9ja1dpdGhUeHNGdW5jID0gYmxvY2tXaXRoVHhzRnVuYztcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBnZXRCbG9jayhwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxzdHJpbmc+KTogUHJvbWlzZTxCbG9jazxzdHJpbmc+PiB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jsb2NrRnVuYyhwcm92aWRlciwgYmxvY2spO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGdldEJsb2NraW9ucyhwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxUcmFuc2FjdGlvblJlc3BvbnNlUGFyYW1zPik6IFByb21pc2U8QmxvY2s8VHJhbnNhY3Rpb25SZXNwb25zZT4+IHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jYmxvY2tXaXRoVHhzRnVuYyhwcm92aWRlciwgYmxvY2spO1xyXG4gICAgfVxyXG5cclxuICAgIGNsb25lKCk6IEN1c3RvbUJsb2NrTmV0d29ya1BsdWdpbiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21CbG9ja05ldHdvcmtQbHVnaW4odGhpcy4jYmxvY2tGdW5jLCB0aGlzLiNibG9ja1dpdGhUeHNGdW5jKTtcclxuICAgIH1cclxufVxyXG4qL1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnaW5zLW5ldHdvcmsuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/plugins-network.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-alchemy.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-alchemy.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlchemyProvider: () => (/* binding */ AlchemyProvider)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _community_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./community.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/community.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/**\r\n *  [[link-alchemy]] provides a third-party service for connecting to\r\n *  various blockchains over JSON-RPC.\r\n *\r\n *  **Supported Networks**\r\n *\r\n *  - Ethereum Mainnet (``mainnet``)\r\n *  - Goerli Testnet (``goerli``)\r\n *  - Sepolia Testnet (``sepolia``)\r\n *  - Arbitrum (``arbitrum``)\r\n *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)\r\n *  - Arbitrum Sepolia Testnet (``arbitrum-sepolia``)\r\n *  - Base (``base``)\r\n *  - Base Goerlia Testnet (``base-goerli``)\r\n *  - Base Sepolia Testnet (``base-sepolia``)\r\n *  - Optimism (``optimism``)\r\n *  - Optimism Goerli Testnet (``optimism-goerli``)\r\n *  - Optimism Sepolia Testnet (``optimism-sepolia``)\r\n *  - Polygon (``matic``)\r\n *  - Polygon Amoy Testnet (``matic-amoy``)\r\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\r\n *\r\n *  @_subsection: api/providers/thirdparty:Alchemy  [providers-alchemy]\r\n */\r\n\r\n\r\n\r\n\r\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";\r\nfunction getHost(name) {\r\n    switch (name) {\r\n        case \"mainnet\":\r\n            return \"eth-mainnet.alchemyapi.io\";\r\n        case \"goerli\":\r\n            return \"eth-goerli.g.alchemy.com\";\r\n        case \"sepolia\":\r\n            return \"eth-sepolia.g.alchemy.com\";\r\n        case \"arbitrum\":\r\n            return \"arb-mainnet.g.alchemy.com\";\r\n        case \"arbitrum-goerli\":\r\n            return \"arb-goerli.g.alchemy.com\";\r\n        case \"arbitrum-sepolia\":\r\n            return \"arb-sepolia.g.alchemy.com\";\r\n        case \"base\":\r\n            return \"base-mainnet.g.alchemy.com\";\r\n        case \"base-goerli\":\r\n            return \"base-goerli.g.alchemy.com\";\r\n        case \"base-sepolia\":\r\n            return \"base-sepolia.g.alchemy.com\";\r\n        case \"matic\":\r\n            return \"polygon-mainnet.g.alchemy.com\";\r\n        case \"matic-amoy\":\r\n            return \"polygon-amoy.g.alchemy.com\";\r\n        case \"matic-mumbai\":\r\n            return \"polygon-mumbai.g.alchemy.com\";\r\n        case \"optimism\":\r\n            return \"opt-mainnet.g.alchemy.com\";\r\n        case \"optimism-goerli\":\r\n            return \"opt-goerli.g.alchemy.com\";\r\n        case \"optimism-sepolia\":\r\n            return \"opt-sepolia.g.alchemy.com\";\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported network\", \"network\", name);\r\n}\r\n/**\r\n *  The **AlchemyProvider** connects to the [[link-alchemy]]\r\n *  JSON-RPC end-points.\r\n *\r\n *  By default, a highly-throttled API key is used, which is\r\n *  appropriate for quick prototypes and simple scripts. To\r\n *  gain access to an increased rate-limit, it is highly\r\n *  recommended to [sign up here](link-alchemy-signup).\r\n *\r\n *  @_docloc: api/providers/thirdparty\r\n */\r\nclass AlchemyProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__.JsonRpcProvider {\r\n    apiKey;\r\n    constructor(_network, apiKey) {\r\n        if (_network == null) {\r\n            _network = \"mainnet\";\r\n        }\r\n        const network = _network_js__WEBPACK_IMPORTED_MODULE_2__.Network.from(_network);\r\n        if (apiKey == null) {\r\n            apiKey = defaultApiKey;\r\n        }\r\n        const request = AlchemyProvider.getRequest(network, apiKey);\r\n        super(request, network, { staticNetwork: network });\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { apiKey });\r\n    }\r\n    _getProvider(chainId) {\r\n        try {\r\n            return new AlchemyProvider(chainId, this.apiKey);\r\n        }\r\n        catch (error) { }\r\n        return super._getProvider(chainId);\r\n    }\r\n    async _perform(req) {\r\n        // https://docs.alchemy.com/reference/trace-transaction\r\n        if (req.method === \"getTransactionResult\") {\r\n            const { trace, tx } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\r\n                trace: this.send(\"trace_transaction\", [req.hash]),\r\n                tx: this.getTransaction(req.hash)\r\n            });\r\n            if (trace == null || tx == null) {\r\n                return null;\r\n            }\r\n            let data;\r\n            let error = false;\r\n            try {\r\n                data = trace[0].result.output;\r\n                error = (trace[0].error === \"Reverted\");\r\n            }\r\n            catch (error) { }\r\n            if (data) {\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!error, \"an error occurred during transaction executions\", \"CALL_EXCEPTION\", {\r\n                    action: \"getTransactionResult\",\r\n                    data,\r\n                    reason: null,\r\n                    transaction: tx,\r\n                    invocation: null,\r\n                    revert: null // @TODO\r\n                });\r\n                return data;\r\n            }\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"could not parse trace result\", \"BAD_DATA\", { value: trace });\r\n        }\r\n        return await super._perform(req);\r\n    }\r\n    isCommunityResource() {\r\n        return (this.apiKey === defaultApiKey);\r\n    }\r\n    static getRequest(network, apiKey) {\r\n        if (apiKey == null) {\r\n            apiKey = defaultApiKey;\r\n        }\r\n        const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(`https:/\\/${getHost(network.name)}/v2/${apiKey}`);\r\n        request.allowGzip = true;\r\n        if (apiKey === defaultApiKey) {\r\n            request.retryFunc = async (request, response, attempt) => {\r\n                (0,_community_js__WEBPACK_IMPORTED_MODULE_3__.showThrottleMessage)(\"alchemy\");\r\n                return true;\r\n            };\r\n        }\r\n        return request;\r\n    }\r\n}\r\n//# sourceMappingURL=provider-alchemy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItYWxjaGVteS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4RztBQUN6RDtBQUNkO0FBQ2lCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw4QkFBOEIsaUVBQWU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnREFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQsUUFBUSxpRUFBZ0IsU0FBUyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWSxRQUFRLGtFQUFpQjtBQUN6RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxZQUFZLHVEQUFNLHNEQUFzRCxjQUFjO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlEQUFZLGFBQWEsc0JBQXNCLE1BQU0sT0FBTztBQUN4RjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHByb3ZpZGVyc1xccHJvdmlkZXItYWxjaGVteS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIFtbbGluay1hbGNoZW15XV0gcHJvdmlkZXMgYSB0aGlyZC1wYXJ0eSBzZXJ2aWNlIGZvciBjb25uZWN0aW5nIHRvXHJcbiAqICB2YXJpb3VzIGJsb2NrY2hhaW5zIG92ZXIgSlNPTi1SUEMuXHJcbiAqXHJcbiAqICAqKlN1cHBvcnRlZCBOZXR3b3JrcyoqXHJcbiAqXHJcbiAqICAtIEV0aGVyZXVtIE1haW5uZXQgKGBgbWFpbm5ldGBgKVxyXG4gKiAgLSBHb2VybGkgVGVzdG5ldCAoYGBnb2VybGlgYClcclxuICogIC0gU2Vwb2xpYSBUZXN0bmV0IChgYHNlcG9saWFgYClcclxuICogIC0gQXJiaXRydW0gKGBgYXJiaXRydW1gYClcclxuICogIC0gQXJiaXRydW0gR29lcmxpIFRlc3RuZXQgKGBgYXJiaXRydW0tZ29lcmxpYGApXHJcbiAqICAtIEFyYml0cnVtIFNlcG9saWEgVGVzdG5ldCAoYGBhcmJpdHJ1bS1zZXBvbGlhYGApXHJcbiAqICAtIEJhc2UgKGBgYmFzZWBgKVxyXG4gKiAgLSBCYXNlIEdvZXJsaWEgVGVzdG5ldCAoYGBiYXNlLWdvZXJsaWBgKVxyXG4gKiAgLSBCYXNlIFNlcG9saWEgVGVzdG5ldCAoYGBiYXNlLXNlcG9saWFgYClcclxuICogIC0gT3B0aW1pc20gKGBgb3B0aW1pc21gYClcclxuICogIC0gT3B0aW1pc20gR29lcmxpIFRlc3RuZXQgKGBgb3B0aW1pc20tZ29lcmxpYGApXHJcbiAqICAtIE9wdGltaXNtIFNlcG9saWEgVGVzdG5ldCAoYGBvcHRpbWlzbS1zZXBvbGlhYGApXHJcbiAqICAtIFBvbHlnb24gKGBgbWF0aWNgYClcclxuICogIC0gUG9seWdvbiBBbW95IFRlc3RuZXQgKGBgbWF0aWMtYW1veWBgKVxyXG4gKiAgLSBQb2x5Z29uIE11bWJhaSBUZXN0bmV0IChgYG1hdGljLW11bWJhaWBgKVxyXG4gKlxyXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHk6QWxjaGVteSAgW3Byb3ZpZGVycy1hbGNoZW15XVxyXG4gKi9cclxuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgcmVzb2x2ZVByb3BlcnRpZXMsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIEZldGNoUmVxdWVzdCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBzaG93VGhyb3R0bGVNZXNzYWdlIH0gZnJvbSBcIi4vY29tbXVuaXR5LmpzXCI7XHJcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XHJcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIjtcclxuY29uc3QgZGVmYXVsdEFwaUtleSA9IFwiX2dnN3dTU2kwS01Cc2RLbkdWZkhEdWVxNnhNQjlFa0NcIjtcclxuZnVuY3Rpb24gZ2V0SG9zdChuYW1lKSB7XHJcbiAgICBzd2l0Y2ggKG5hbWUpIHtcclxuICAgICAgICBjYXNlIFwibWFpbm5ldFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJldGgtbWFpbm5ldC5hbGNoZW15YXBpLmlvXCI7XHJcbiAgICAgICAgY2FzZSBcImdvZXJsaVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJldGgtZ29lcmxpLmcuYWxjaGVteS5jb21cIjtcclxuICAgICAgICBjYXNlIFwic2Vwb2xpYVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJldGgtc2Vwb2xpYS5nLmFsY2hlbXkuY29tXCI7XHJcbiAgICAgICAgY2FzZSBcImFyYml0cnVtXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImFyYi1tYWlubmV0LmcuYWxjaGVteS5jb21cIjtcclxuICAgICAgICBjYXNlIFwiYXJiaXRydW0tZ29lcmxpXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImFyYi1nb2VybGkuZy5hbGNoZW15LmNvbVwiO1xyXG4gICAgICAgIGNhc2UgXCJhcmJpdHJ1bS1zZXBvbGlhXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImFyYi1zZXBvbGlhLmcuYWxjaGVteS5jb21cIjtcclxuICAgICAgICBjYXNlIFwiYmFzZVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJiYXNlLW1haW5uZXQuZy5hbGNoZW15LmNvbVwiO1xyXG4gICAgICAgIGNhc2UgXCJiYXNlLWdvZXJsaVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJiYXNlLWdvZXJsaS5nLmFsY2hlbXkuY29tXCI7XHJcbiAgICAgICAgY2FzZSBcImJhc2Utc2Vwb2xpYVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJiYXNlLXNlcG9saWEuZy5hbGNoZW15LmNvbVwiO1xyXG4gICAgICAgIGNhc2UgXCJtYXRpY1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJwb2x5Z29uLW1haW5uZXQuZy5hbGNoZW15LmNvbVwiO1xyXG4gICAgICAgIGNhc2UgXCJtYXRpYy1hbW95XCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcInBvbHlnb24tYW1veS5nLmFsY2hlbXkuY29tXCI7XHJcbiAgICAgICAgY2FzZSBcIm1hdGljLW11bWJhaVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJwb2x5Z29uLW11bWJhaS5nLmFsY2hlbXkuY29tXCI7XHJcbiAgICAgICAgY2FzZSBcIm9wdGltaXNtXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcIm9wdC1tYWlubmV0LmcuYWxjaGVteS5jb21cIjtcclxuICAgICAgICBjYXNlIFwib3B0aW1pc20tZ29lcmxpXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcIm9wdC1nb2VybGkuZy5hbGNoZW15LmNvbVwiO1xyXG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbS1zZXBvbGlhXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcIm9wdC1zZXBvbGlhLmcuYWxjaGVteS5jb21cIjtcclxuICAgIH1cclxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5hbWUpO1xyXG59XHJcbi8qKlxyXG4gKiAgVGhlICoqQWxjaGVteVByb3ZpZGVyKiogY29ubmVjdHMgdG8gdGhlIFtbbGluay1hbGNoZW15XV1cclxuICogIEpTT04tUlBDIGVuZC1wb2ludHMuXHJcbiAqXHJcbiAqICBCeSBkZWZhdWx0LCBhIGhpZ2hseS10aHJvdHRsZWQgQVBJIGtleSBpcyB1c2VkLCB3aGljaCBpc1xyXG4gKiAgYXBwcm9wcmlhdGUgZm9yIHF1aWNrIHByb3RvdHlwZXMgYW5kIHNpbXBsZSBzY3JpcHRzLiBUb1xyXG4gKiAgZ2FpbiBhY2Nlc3MgdG8gYW4gaW5jcmVhc2VkIHJhdGUtbGltaXQsIGl0IGlzIGhpZ2hseVxyXG4gKiAgcmVjb21tZW5kZWQgdG8gW3NpZ24gdXAgaGVyZV0obGluay1hbGNoZW15LXNpZ251cCkuXHJcbiAqXHJcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy90aGlyZHBhcnR5XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQWxjaGVteVByb3ZpZGVyIGV4dGVuZHMgSnNvblJwY1Byb3ZpZGVyIHtcclxuICAgIGFwaUtleTtcclxuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCBhcGlLZXkpIHtcclxuICAgICAgICBpZiAoX25ldHdvcmsgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBfbmV0d29yayA9IFwibWFpbm5ldFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXR3b3JrID0gTmV0d29yay5mcm9tKF9uZXR3b3JrKTtcclxuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgYXBpS2V5ID0gZGVmYXVsdEFwaUtleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IEFsY2hlbXlQcm92aWRlci5nZXRSZXF1ZXN0KG5ldHdvcmssIGFwaUtleSk7XHJcbiAgICAgICAgc3VwZXIocmVxdWVzdCwgbmV0d29yaywgeyBzdGF0aWNOZXR3b3JrOiBuZXR3b3JrIH0pO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhcGlLZXkgfSk7XHJcbiAgICB9XHJcbiAgICBfZ2V0UHJvdmlkZXIoY2hhaW5JZCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxjaGVteVByb3ZpZGVyKGNoYWluSWQsIHRoaXMuYXBpS2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFByb3ZpZGVyKGNoYWluSWQpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgX3BlcmZvcm0ocmVxKSB7XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9kb2NzLmFsY2hlbXkuY29tL3JlZmVyZW5jZS90cmFjZS10cmFuc2FjdGlvblxyXG4gICAgICAgIGlmIChyZXEubWV0aG9kID09PSBcImdldFRyYW5zYWN0aW9uUmVzdWx0XCIpIHtcclxuICAgICAgICAgICAgY29uc3QgeyB0cmFjZSwgdHggfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgICAgIHRyYWNlOiB0aGlzLnNlbmQoXCJ0cmFjZV90cmFuc2FjdGlvblwiLCBbcmVxLmhhc2hdKSxcclxuICAgICAgICAgICAgICAgIHR4OiB0aGlzLmdldFRyYW5zYWN0aW9uKHJlcS5oYXNoKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHRyYWNlID09IG51bGwgfHwgdHggPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGRhdGE7XHJcbiAgICAgICAgICAgIGxldCBlcnJvciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHRyYWNlWzBdLnJlc3VsdC5vdXRwdXQ7XHJcbiAgICAgICAgICAgICAgICBlcnJvciA9ICh0cmFjZVswXS5lcnJvciA9PT0gXCJSZXZlcnRlZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KCFlcnJvciwgXCJhbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdHJhbnNhY3Rpb24gZXhlY3V0aW9uc1wiLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZ2V0VHJhbnNhY3Rpb25SZXN1bHRcIixcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHgsXHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2NhdGlvbjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICByZXZlcnQ6IG51bGwgLy8gQFRPRE9cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNvdWxkIG5vdCBwYXJzZSB0cmFjZSByZXN1bHRcIiwgXCJCQURfREFUQVwiLCB7IHZhbHVlOiB0cmFjZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHN1cGVyLl9wZXJmb3JtKHJlcSk7XHJcbiAgICB9XHJcbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5hcGlLZXkgPT09IGRlZmF1bHRBcGlLZXkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFJlcXVlc3QobmV0d29yaywgYXBpS2V5KSB7XHJcbiAgICAgICAgaWYgKGFwaUtleSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGFwaUtleSA9IGRlZmF1bHRBcGlLZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgRmV0Y2hSZXF1ZXN0KGBodHRwczovXFwvJHtnZXRIb3N0KG5ldHdvcmsubmFtZSl9L3YyLyR7YXBpS2V5fWApO1xyXG4gICAgICAgIHJlcXVlc3QuYWxsb3dHemlwID0gdHJ1ZTtcclxuICAgICAgICBpZiAoYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3QucmV0cnlGdW5jID0gYXN5bmMgKHJlcXVlc3QsIHJlc3BvbnNlLCBhdHRlbXB0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzaG93VGhyb3R0bGVNZXNzYWdlKFwiYWxjaGVteVwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1hbGNoZW15LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-alchemy.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-ankr.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-ankr.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnkrProvider: () => (/* binding */ AnkrProvider)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _community_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./community.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/community.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/**\r\n *  [[link-ankr]] provides a third-party service for connecting to\r\n *  various blockchains over JSON-RPC.\r\n *\r\n *  **Supported Networks**\r\n *\r\n *  - Ethereum Mainnet (``mainnet``)\r\n *  - Goerli Testnet (``goerli``)\r\n *  - Sepolia Testnet (``sepolia``)\r\n *  - Arbitrum (``arbitrum``)\r\n *  - Base (``base``)\r\n *  - Base Goerlia Testnet (``base-goerli``)\r\n *  - Base Sepolia Testnet (``base-sepolia``)\r\n *  - BNB (``bnb``)\r\n *  - BNB Testnet (``bnbt``)\r\n *  - Optimism (``optimism``)\r\n *  - Optimism Goerli Testnet (``optimism-goerli``)\r\n *  - Optimism Sepolia Testnet (``optimism-sepolia``)\r\n *  - Polygon (``matic``)\r\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\r\n *\r\n *  @_subsection: api/providers/thirdparty:Ankr  [providers-ankr]\r\n */\r\n\r\n\r\n\r\n\r\nconst defaultApiKey = \"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\";\r\nfunction getHost(name) {\r\n    switch (name) {\r\n        case \"mainnet\":\r\n            return \"rpc.ankr.com/eth\";\r\n        case \"goerli\":\r\n            return \"rpc.ankr.com/eth_goerli\";\r\n        case \"sepolia\":\r\n            return \"rpc.ankr.com/eth_sepolia\";\r\n        case \"arbitrum\":\r\n            return \"rpc.ankr.com/arbitrum\";\r\n        case \"base\":\r\n            return \"rpc.ankr.com/base\";\r\n        case \"base-goerli\":\r\n            return \"rpc.ankr.com/base_goerli\";\r\n        case \"base-sepolia\":\r\n            return \"rpc.ankr.com/base_sepolia\";\r\n        case \"bnb\":\r\n            return \"rpc.ankr.com/bsc\";\r\n        case \"bnbt\":\r\n            return \"rpc.ankr.com/bsc_testnet_chapel\";\r\n        case \"matic\":\r\n            return \"rpc.ankr.com/polygon\";\r\n        case \"matic-mumbai\":\r\n            return \"rpc.ankr.com/polygon_mumbai\";\r\n        case \"optimism\":\r\n            return \"rpc.ankr.com/optimism\";\r\n        case \"optimism-goerli\":\r\n            return \"rpc.ankr.com/optimism_testnet\";\r\n        case \"optimism-sepolia\":\r\n            return \"rpc.ankr.com/optimism_sepolia\";\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported network\", \"network\", name);\r\n}\r\n/**\r\n *  The **AnkrProvider** connects to the [[link-ankr]]\r\n *  JSON-RPC end-points.\r\n *\r\n *  By default, a highly-throttled API key is used, which is\r\n *  appropriate for quick prototypes and simple scripts. To\r\n *  gain access to an increased rate-limit, it is highly\r\n *  recommended to [sign up here](link-ankr-signup).\r\n */\r\nclass AnkrProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__.JsonRpcProvider {\r\n    /**\r\n     *  The API key for the Ankr connection.\r\n     */\r\n    apiKey;\r\n    /**\r\n     *  Create a new **AnkrProvider**.\r\n     *\r\n     *  By default connecting to ``mainnet`` with a highly throttled\r\n     *  API key.\r\n     */\r\n    constructor(_network, apiKey) {\r\n        if (_network == null) {\r\n            _network = \"mainnet\";\r\n        }\r\n        const network = _network_js__WEBPACK_IMPORTED_MODULE_2__.Network.from(_network);\r\n        if (apiKey == null) {\r\n            apiKey = defaultApiKey;\r\n        }\r\n        // Ankr does not support filterId, so we force polling\r\n        const options = { polling: true, staticNetwork: network };\r\n        const request = AnkrProvider.getRequest(network, apiKey);\r\n        super(request, network, options);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { apiKey });\r\n    }\r\n    _getProvider(chainId) {\r\n        try {\r\n            return new AnkrProvider(chainId, this.apiKey);\r\n        }\r\n        catch (error) { }\r\n        return super._getProvider(chainId);\r\n    }\r\n    /**\r\n     *  Returns a prepared request for connecting to %%network%% with\r\n     *  %%apiKey%%.\r\n     */\r\n    static getRequest(network, apiKey) {\r\n        if (apiKey == null) {\r\n            apiKey = defaultApiKey;\r\n        }\r\n        const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(`https:/\\/${getHost(network.name)}/${apiKey}`);\r\n        request.allowGzip = true;\r\n        if (apiKey === defaultApiKey) {\r\n            request.retryFunc = async (request, response, attempt) => {\r\n                (0,_community_js__WEBPACK_IMPORTED_MODULE_3__.showThrottleMessage)(\"AnkrProvider\");\r\n                return true;\r\n            };\r\n        }\r\n        return request;\r\n    }\r\n    getRpcError(payload, error) {\r\n        if (payload.method === \"eth_sendRawTransaction\") {\r\n            if (error && error.error && error.error.message === \"INTERNAL_ERROR: could not replace existing tx\") {\r\n                error.error.message = \"replacement transaction underpriced\";\r\n            }\r\n        }\r\n        return super.getRpcError(payload, error);\r\n    }\r\n    isCommunityResource() {\r\n        return (this.apiKey === defaultApiKey);\r\n    }\r\n}\r\n//# sourceMappingURL=provider-ankr.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItYW5rci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDbUY7QUFDOUI7QUFDZDtBQUNpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDJCQUEyQixpRUFBZTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdEQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxRQUFRLGlFQUFnQixTQUFTLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseURBQVksYUFBYSxzQkFBc0IsR0FBRyxPQUFPO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrRUFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHByb3ZpZGVyc1xccHJvdmlkZXItYW5rci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIFtbbGluay1hbmtyXV0gcHJvdmlkZXMgYSB0aGlyZC1wYXJ0eSBzZXJ2aWNlIGZvciBjb25uZWN0aW5nIHRvXHJcbiAqICB2YXJpb3VzIGJsb2NrY2hhaW5zIG92ZXIgSlNPTi1SUEMuXHJcbiAqXHJcbiAqICAqKlN1cHBvcnRlZCBOZXR3b3JrcyoqXHJcbiAqXHJcbiAqICAtIEV0aGVyZXVtIE1haW5uZXQgKGBgbWFpbm5ldGBgKVxyXG4gKiAgLSBHb2VybGkgVGVzdG5ldCAoYGBnb2VybGlgYClcclxuICogIC0gU2Vwb2xpYSBUZXN0bmV0IChgYHNlcG9saWFgYClcclxuICogIC0gQXJiaXRydW0gKGBgYXJiaXRydW1gYClcclxuICogIC0gQmFzZSAoYGBiYXNlYGApXHJcbiAqICAtIEJhc2UgR29lcmxpYSBUZXN0bmV0IChgYGJhc2UtZ29lcmxpYGApXHJcbiAqICAtIEJhc2UgU2Vwb2xpYSBUZXN0bmV0IChgYGJhc2Utc2Vwb2xpYWBgKVxyXG4gKiAgLSBCTkIgKGBgYm5iYGApXHJcbiAqICAtIEJOQiBUZXN0bmV0IChgYGJuYnRgYClcclxuICogIC0gT3B0aW1pc20gKGBgb3B0aW1pc21gYClcclxuICogIC0gT3B0aW1pc20gR29lcmxpIFRlc3RuZXQgKGBgb3B0aW1pc20tZ29lcmxpYGApXHJcbiAqICAtIE9wdGltaXNtIFNlcG9saWEgVGVzdG5ldCAoYGBvcHRpbWlzbS1zZXBvbGlhYGApXHJcbiAqICAtIFBvbHlnb24gKGBgbWF0aWNgYClcclxuICogIC0gUG9seWdvbiBNdW1iYWkgVGVzdG5ldCAoYGBtYXRpYy1tdW1iYWlgYClcclxuICpcclxuICogIEBfc3Vic2VjdGlvbjogYXBpL3Byb3ZpZGVycy90aGlyZHBhcnR5OkFua3IgIFtwcm92aWRlcnMtYW5rcl1cclxuICovXHJcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIEZldGNoUmVxdWVzdCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgc2hvd1Rocm90dGxlTWVzc2FnZSB9IGZyb20gXCIuL2NvbW11bml0eS5qc1wiO1xyXG5pbXBvcnQgeyBOZXR3b3JrIH0gZnJvbSBcIi4vbmV0d29yay5qc1wiO1xyXG5pbXBvcnQgeyBKc29uUnBjUHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1qc29ucnBjLmpzXCI7XHJcbmNvbnN0IGRlZmF1bHRBcGlLZXkgPSBcIjlmN2Q5MjliMDE4Y2RmZmIzMzg1MTdlZmEwNmY1ODM1OWU4NmZmMWZmZDM1MGJjODg5NzM4NTIzNjU5ZTc5NzJcIjtcclxuZnVuY3Rpb24gZ2V0SG9zdChuYW1lKSB7XHJcbiAgICBzd2l0Y2ggKG5hbWUpIHtcclxuICAgICAgICBjYXNlIFwibWFpbm5ldFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vZXRoXCI7XHJcbiAgICAgICAgY2FzZSBcImdvZXJsaVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vZXRoX2dvZXJsaVwiO1xyXG4gICAgICAgIGNhc2UgXCJzZXBvbGlhXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9ldGhfc2Vwb2xpYVwiO1xyXG4gICAgICAgIGNhc2UgXCJhcmJpdHJ1bVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vYXJiaXRydW1cIjtcclxuICAgICAgICBjYXNlIFwiYmFzZVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vYmFzZVwiO1xyXG4gICAgICAgIGNhc2UgXCJiYXNlLWdvZXJsaVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vYmFzZV9nb2VybGlcIjtcclxuICAgICAgICBjYXNlIFwiYmFzZS1zZXBvbGlhXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9iYXNlX3NlcG9saWFcIjtcclxuICAgICAgICBjYXNlIFwiYm5iXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9ic2NcIjtcclxuICAgICAgICBjYXNlIFwiYm5idFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vYnNjX3Rlc3RuZXRfY2hhcGVsXCI7XHJcbiAgICAgICAgY2FzZSBcIm1hdGljXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9wb2x5Z29uXCI7XHJcbiAgICAgICAgY2FzZSBcIm1hdGljLW11bWJhaVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vcG9seWdvbl9tdW1iYWlcIjtcclxuICAgICAgICBjYXNlIFwib3B0aW1pc21cIjpcclxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL29wdGltaXNtXCI7XHJcbiAgICAgICAgY2FzZSBcIm9wdGltaXNtLWdvZXJsaVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vb3B0aW1pc21fdGVzdG5ldFwiO1xyXG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbS1zZXBvbGlhXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9vcHRpbWlzbV9zZXBvbGlhXCI7XHJcbiAgICB9XHJcbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuYW1lKTtcclxufVxyXG4vKipcclxuICogIFRoZSAqKkFua3JQcm92aWRlcioqIGNvbm5lY3RzIHRvIHRoZSBbW2xpbmstYW5rcl1dXHJcbiAqICBKU09OLVJQQyBlbmQtcG9pbnRzLlxyXG4gKlxyXG4gKiAgQnkgZGVmYXVsdCwgYSBoaWdobHktdGhyb3R0bGVkIEFQSSBrZXkgaXMgdXNlZCwgd2hpY2ggaXNcclxuICogIGFwcHJvcHJpYXRlIGZvciBxdWljayBwcm90b3R5cGVzIGFuZCBzaW1wbGUgc2NyaXB0cy4gVG9cclxuICogIGdhaW4gYWNjZXNzIHRvIGFuIGluY3JlYXNlZCByYXRlLWxpbWl0LCBpdCBpcyBoaWdobHlcclxuICogIHJlY29tbWVuZGVkIHRvIFtzaWduIHVwIGhlcmVdKGxpbmstYW5rci1zaWdudXApLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFua3JQcm92aWRlciBleHRlbmRzIEpzb25ScGNQcm92aWRlciB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgQVBJIGtleSBmb3IgdGhlIEFua3IgY29ubmVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgYXBpS2V5O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqQW5rclByb3ZpZGVyKiouXHJcbiAgICAgKlxyXG4gICAgICogIEJ5IGRlZmF1bHQgY29ubmVjdGluZyB0byBgYG1haW5uZXRgYCB3aXRoIGEgaGlnaGx5IHRocm90dGxlZFxyXG4gICAgICogIEFQSSBrZXkuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCBhcGlLZXkpIHtcclxuICAgICAgICBpZiAoX25ldHdvcmsgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBfbmV0d29yayA9IFwibWFpbm5ldFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXR3b3JrID0gTmV0d29yay5mcm9tKF9uZXR3b3JrKTtcclxuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgYXBpS2V5ID0gZGVmYXVsdEFwaUtleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQW5rciBkb2VzIG5vdCBzdXBwb3J0IGZpbHRlcklkLCBzbyB3ZSBmb3JjZSBwb2xsaW5nXHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgcG9sbGluZzogdHJ1ZSwgc3RhdGljTmV0d29yazogbmV0d29yayB9O1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBBbmtyUHJvdmlkZXIuZ2V0UmVxdWVzdChuZXR3b3JrLCBhcGlLZXkpO1xyXG4gICAgICAgIHN1cGVyKHJlcXVlc3QsIG5ldHdvcmssIG9wdGlvbnMpO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhcGlLZXkgfSk7XHJcbiAgICB9XHJcbiAgICBfZ2V0UHJvdmlkZXIoY2hhaW5JZCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW5rclByb3ZpZGVyKGNoYWluSWQsIHRoaXMuYXBpS2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFByb3ZpZGVyKGNoYWluSWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIHByZXBhcmVkIHJlcXVlc3QgZm9yIGNvbm5lY3RpbmcgdG8gJSVuZXR3b3JrJSUgd2l0aFxyXG4gICAgICogICUlYXBpS2V5JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRSZXF1ZXN0KG5ldHdvcmssIGFwaUtleSkge1xyXG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBhcGlLZXkgPSBkZWZhdWx0QXBpS2V5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IEZldGNoUmVxdWVzdChgaHR0cHM6L1xcLyR7Z2V0SG9zdChuZXR3b3JrLm5hbWUpfS8ke2FwaUtleX1gKTtcclxuICAgICAgICByZXF1ZXN0LmFsbG93R3ppcCA9IHRydWU7XHJcbiAgICAgICAgaWYgKGFwaUtleSA9PT0gZGVmYXVsdEFwaUtleSkge1xyXG4gICAgICAgICAgICByZXF1ZXN0LnJldHJ5RnVuYyA9IGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSwgYXR0ZW1wdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2hvd1Rocm90dGxlTWVzc2FnZShcIkFua3JQcm92aWRlclwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcclxuICAgIH1cclxuICAgIGdldFJwY0Vycm9yKHBheWxvYWQsIGVycm9yKSB7XHJcbiAgICAgICAgaWYgKHBheWxvYWQubWV0aG9kID09PSBcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIikge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IuZXJyb3IgJiYgZXJyb3IuZXJyb3IubWVzc2FnZSA9PT0gXCJJTlRFUk5BTF9FUlJPUjogY291bGQgbm90IHJlcGxhY2UgZXhpc3RpbmcgdHhcIikge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IuZXJyb3IubWVzc2FnZSA9IFwicmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0UnBjRXJyb3IocGF5bG9hZCwgZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1hbmtyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-ankr.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-blockscout.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-blockscout.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockscoutProvider: () => (/* binding */ BlockscoutProvider)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/**\r\n *  [[link-blockscout]] provides a third-party service for connecting to\r\n *  various blockchains over JSON-RPC.\r\n *\r\n *  **Supported Networks**\r\n *\r\n *  - Ethereum Mainnet (``mainnet``)\r\n *  - Sepolia Testnet (``sepolia``)\r\n *  - Holesky Testnet (``holesky``)\r\n *  - Ethereum Classic (``classic``)\r\n *  - Arbitrum (``arbitrum``)\r\n *  - Base (``base``)\r\n *  - Base Sepolia Testnet (``base-sepolia``)\r\n *  - Gnosis (``xdai``)\r\n *  - Optimism (``optimism``)\r\n *  - Optimism Sepolia Testnet (``optimism-sepolia``)\r\n *  - Polygon (``matic``)\r\n *\r\n *  @_subsection: api/providers/thirdparty:Blockscout  [providers-blockscout]\r\n */\r\n\r\n\r\n\r\nfunction getUrl(name) {\r\n    switch (name) {\r\n        case \"mainnet\":\r\n            return \"https:/\\/eth.blockscout.com/api/eth-rpc\";\r\n        case \"sepolia\":\r\n            return \"https:/\\/eth-sepolia.blockscout.com/api/eth-rpc\";\r\n        case \"holesky\":\r\n            return \"https:/\\/eth-holesky.blockscout.com/api/eth-rpc\";\r\n        case \"classic\":\r\n            return \"https:/\\/etc.blockscout.com/api/eth-rpc\";\r\n        case \"arbitrum\":\r\n            return \"https:/\\/arbitrum.blockscout.com/api/eth-rpc\";\r\n        case \"base\":\r\n            return \"https:/\\/base.blockscout.com/api/eth-rpc\";\r\n        case \"base-sepolia\":\r\n            return \"https:/\\/base-sepolia.blockscout.com/api/eth-rpc\";\r\n        case \"matic\":\r\n            return \"https:/\\/polygon.blockscout.com/api/eth-rpc\";\r\n        case \"optimism\":\r\n            return \"https:/\\/optimism.blockscout.com/api/eth-rpc\";\r\n        case \"optimism-sepolia\":\r\n            return \"https:/\\/optimism-sepolia.blockscout.com/api/eth-rpc\";\r\n        case \"xdai\":\r\n            return \"https:/\\/gnosis.blockscout.com/api/eth-rpc\";\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported network\", \"network\", name);\r\n}\r\n/**\r\n *  The **BlockscoutProvider** connects to the [[link-blockscout]]\r\n *  JSON-RPC end-points.\r\n *\r\n *  By default, a highly-throttled API key is used, which is\r\n *  appropriate for quick prototypes and simple scripts. To\r\n *  gain access to an increased rate-limit, it is highly\r\n *  recommended to [sign up here](link-blockscout).\r\n */\r\nclass BlockscoutProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__.JsonRpcProvider {\r\n    /**\r\n     *  The API key.\r\n     */\r\n    apiKey;\r\n    /**\r\n     *  Creates a new **BlockscoutProvider**.\r\n     */\r\n    constructor(_network, apiKey) {\r\n        if (_network == null) {\r\n            _network = \"mainnet\";\r\n        }\r\n        const network = _network_js__WEBPACK_IMPORTED_MODULE_2__.Network.from(_network);\r\n        if (apiKey == null) {\r\n            apiKey = null;\r\n        }\r\n        const request = BlockscoutProvider.getRequest(network);\r\n        super(request, network, { staticNetwork: network });\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { apiKey });\r\n    }\r\n    _getProvider(chainId) {\r\n        try {\r\n            return new BlockscoutProvider(chainId, this.apiKey);\r\n        }\r\n        catch (error) { }\r\n        return super._getProvider(chainId);\r\n    }\r\n    isCommunityResource() {\r\n        return (this.apiKey === null);\r\n    }\r\n    getRpcRequest(req) {\r\n        // Blockscout enforces the TAG argument for estimateGas\r\n        const resp = super.getRpcRequest(req);\r\n        if (resp && resp.method === \"eth_estimateGas\" && resp.args.length == 1) {\r\n            resp.args = resp.args.slice();\r\n            resp.args.push(\"latest\");\r\n        }\r\n        return resp;\r\n    }\r\n    getRpcError(payload, _error) {\r\n        const error = _error ? _error.error : null;\r\n        // Blockscout currently drops the VM result and replaces it with a\r\n        // human-readable string, so we need to make it machine-readable.\r\n        if (error && error.code === -32015 && !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(error.data || \"\", true)) {\r\n            const panicCodes = {\r\n                \"assert(false)\": \"01\",\r\n                \"arithmetic underflow or overflow\": \"11\",\r\n                \"division or modulo by zero\": \"12\",\r\n                \"out-of-bounds array access; popping on an empty array\": \"31\",\r\n                \"out-of-bounds access of an array or bytesN\": \"32\"\r\n            };\r\n            let panicCode = \"\";\r\n            if (error.message === \"VM execution error.\") {\r\n                // eth_call passes this message\r\n                panicCode = panicCodes[error.data] || \"\";\r\n            }\r\n            else if (panicCodes[error.message || \"\"]) {\r\n                panicCode = panicCodes[error.message || \"\"];\r\n            }\r\n            if (panicCode) {\r\n                error.message += ` (reverted: ${error.data})`;\r\n                error.data = \"0x4e487b7100000000000000000000000000000000000000000000000000000000000000\" + panicCode;\r\n            }\r\n        }\r\n        else if (error && error.code === -32000) {\r\n            if (error.message === \"wrong transaction nonce\") {\r\n                error.message += \" (nonce too low)\";\r\n            }\r\n        }\r\n        return super.getRpcError(payload, _error);\r\n    }\r\n    /**\r\n     *  Returns a prepared request for connecting to %%network%%\r\n     *  with %%apiKey%%.\r\n     */\r\n    static getRequest(network) {\r\n        const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(getUrl(network.name));\r\n        request.allowGzip = true;\r\n        return request;\r\n    }\r\n}\r\n//# sourceMappingURL=provider-blockscout.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItYmxvY2tzY291dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnRztBQUN6RDtBQUNpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0RBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUMsaUVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnREFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQsUUFBUSxpRUFBZ0IsU0FBUyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw0REFBVztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlEQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxccHJvdmlkZXJzXFxwcm92aWRlci1ibG9ja3Njb3V0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgW1tsaW5rLWJsb2Nrc2NvdXRdXSBwcm92aWRlcyBhIHRoaXJkLXBhcnR5IHNlcnZpY2UgZm9yIGNvbm5lY3RpbmcgdG9cclxuICogIHZhcmlvdXMgYmxvY2tjaGFpbnMgb3ZlciBKU09OLVJQQy5cclxuICpcclxuICogICoqU3VwcG9ydGVkIE5ldHdvcmtzKipcclxuICpcclxuICogIC0gRXRoZXJldW0gTWFpbm5ldCAoYGBtYWlubmV0YGApXHJcbiAqICAtIFNlcG9saWEgVGVzdG5ldCAoYGBzZXBvbGlhYGApXHJcbiAqICAtIEhvbGVza3kgVGVzdG5ldCAoYGBob2xlc2t5YGApXHJcbiAqICAtIEV0aGVyZXVtIENsYXNzaWMgKGBgY2xhc3NpY2BgKVxyXG4gKiAgLSBBcmJpdHJ1bSAoYGBhcmJpdHJ1bWBgKVxyXG4gKiAgLSBCYXNlIChgYGJhc2VgYClcclxuICogIC0gQmFzZSBTZXBvbGlhIFRlc3RuZXQgKGBgYmFzZS1zZXBvbGlhYGApXHJcbiAqICAtIEdub3NpcyAoYGB4ZGFpYGApXHJcbiAqICAtIE9wdGltaXNtIChgYG9wdGltaXNtYGApXHJcbiAqICAtIE9wdGltaXNtIFNlcG9saWEgVGVzdG5ldCAoYGBvcHRpbWlzbS1zZXBvbGlhYGApXHJcbiAqICAtIFBvbHlnb24gKGBgbWF0aWNgYClcclxuICpcclxuICogIEBfc3Vic2VjdGlvbjogYXBpL3Byb3ZpZGVycy90aGlyZHBhcnR5OkJsb2Nrc2NvdXQgIFtwcm92aWRlcnMtYmxvY2tzY291dF1cclxuICovXHJcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50LCBkZWZpbmVQcm9wZXJ0aWVzLCBGZXRjaFJlcXVlc3QsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XHJcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIjtcclxuZnVuY3Rpb24gZ2V0VXJsKG5hbWUpIHtcclxuICAgIHN3aXRjaCAobmFtZSkge1xyXG4gICAgICAgIGNhc2UgXCJtYWlubmV0XCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9ldGguYmxvY2tzY291dC5jb20vYXBpL2V0aC1ycGNcIjtcclxuICAgICAgICBjYXNlIFwic2Vwb2xpYVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvZXRoLXNlcG9saWEuYmxvY2tzY291dC5jb20vYXBpL2V0aC1ycGNcIjtcclxuICAgICAgICBjYXNlIFwiaG9sZXNreVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvZXRoLWhvbGVza3kuYmxvY2tzY291dC5jb20vYXBpL2V0aC1ycGNcIjtcclxuICAgICAgICBjYXNlIFwiY2xhc3NpY1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvZXRjLmJsb2Nrc2NvdXQuY29tL2FwaS9ldGgtcnBjXCI7XHJcbiAgICAgICAgY2FzZSBcImFyYml0cnVtXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcmJpdHJ1bS5ibG9ja3Njb3V0LmNvbS9hcGkvZXRoLXJwY1wiO1xyXG4gICAgICAgIGNhc2UgXCJiYXNlXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9iYXNlLmJsb2Nrc2NvdXQuY29tL2FwaS9ldGgtcnBjXCI7XHJcbiAgICAgICAgY2FzZSBcImJhc2Utc2Vwb2xpYVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYmFzZS1zZXBvbGlhLmJsb2Nrc2NvdXQuY29tL2FwaS9ldGgtcnBjXCI7XHJcbiAgICAgICAgY2FzZSBcIm1hdGljXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9wb2x5Z29uLmJsb2Nrc2NvdXQuY29tL2FwaS9ldGgtcnBjXCI7XHJcbiAgICAgICAgY2FzZSBcIm9wdGltaXNtXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9vcHRpbWlzbS5ibG9ja3Njb3V0LmNvbS9hcGkvZXRoLXJwY1wiO1xyXG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbS1zZXBvbGlhXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9vcHRpbWlzbS1zZXBvbGlhLmJsb2Nrc2NvdXQuY29tL2FwaS9ldGgtcnBjXCI7XHJcbiAgICAgICAgY2FzZSBcInhkYWlcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2dub3Npcy5ibG9ja3Njb3V0LmNvbS9hcGkvZXRoLXJwY1wiO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmFtZSk7XHJcbn1cclxuLyoqXHJcbiAqICBUaGUgKipCbG9ja3Njb3V0UHJvdmlkZXIqKiBjb25uZWN0cyB0byB0aGUgW1tsaW5rLWJsb2Nrc2NvdXRdXVxyXG4gKiAgSlNPTi1SUEMgZW5kLXBvaW50cy5cclxuICpcclxuICogIEJ5IGRlZmF1bHQsIGEgaGlnaGx5LXRocm90dGxlZCBBUEkga2V5IGlzIHVzZWQsIHdoaWNoIGlzXHJcbiAqICBhcHByb3ByaWF0ZSBmb3IgcXVpY2sgcHJvdG90eXBlcyBhbmQgc2ltcGxlIHNjcmlwdHMuIFRvXHJcbiAqICBnYWluIGFjY2VzcyB0byBhbiBpbmNyZWFzZWQgcmF0ZS1saW1pdCwgaXQgaXMgaGlnaGx5XHJcbiAqICByZWNvbW1lbmRlZCB0byBbc2lnbiB1cCBoZXJlXShsaW5rLWJsb2Nrc2NvdXQpLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJsb2Nrc2NvdXRQcm92aWRlciBleHRlbmRzIEpzb25ScGNQcm92aWRlciB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgQVBJIGtleS5cclxuICAgICAqL1xyXG4gICAgYXBpS2V5O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkJsb2Nrc2NvdXRQcm92aWRlcioqLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihfbmV0d29yaywgYXBpS2V5KSB7XHJcbiAgICAgICAgaWYgKF9uZXR3b3JrID09IG51bGwpIHtcclxuICAgICAgICAgICAgX25ldHdvcmsgPSBcIm1haW5uZXRcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV0d29yayA9IE5ldHdvcmsuZnJvbShfbmV0d29yayk7XHJcbiAgICAgICAgaWYgKGFwaUtleSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGFwaUtleSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBCbG9ja3Njb3V0UHJvdmlkZXIuZ2V0UmVxdWVzdChuZXR3b3JrKTtcclxuICAgICAgICBzdXBlcihyZXF1ZXN0LCBuZXR3b3JrLCB7IHN0YXRpY05ldHdvcms6IG5ldHdvcmsgfSk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFwaUtleSB9KTtcclxuICAgIH1cclxuICAgIF9nZXRQcm92aWRlcihjaGFpbklkKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja3Njb3V0UHJvdmlkZXIoY2hhaW5JZCwgdGhpcy5hcGlLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgICAgIHJldHVybiBzdXBlci5fZ2V0UHJvdmlkZXIoY2hhaW5JZCk7XHJcbiAgICB9XHJcbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5hcGlLZXkgPT09IG51bGwpO1xyXG4gICAgfVxyXG4gICAgZ2V0UnBjUmVxdWVzdChyZXEpIHtcclxuICAgICAgICAvLyBCbG9ja3Njb3V0IGVuZm9yY2VzIHRoZSBUQUcgYXJndW1lbnQgZm9yIGVzdGltYXRlR2FzXHJcbiAgICAgICAgY29uc3QgcmVzcCA9IHN1cGVyLmdldFJwY1JlcXVlc3QocmVxKTtcclxuICAgICAgICBpZiAocmVzcCAmJiByZXNwLm1ldGhvZCA9PT0gXCJldGhfZXN0aW1hdGVHYXNcIiAmJiByZXNwLmFyZ3MubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgcmVzcC5hcmdzID0gcmVzcC5hcmdzLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIHJlc3AuYXJncy5wdXNoKFwibGF0ZXN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzcDtcclxuICAgIH1cclxuICAgIGdldFJwY0Vycm9yKHBheWxvYWQsIF9lcnJvcikge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gX2Vycm9yID8gX2Vycm9yLmVycm9yIDogbnVsbDtcclxuICAgICAgICAvLyBCbG9ja3Njb3V0IGN1cnJlbnRseSBkcm9wcyB0aGUgVk0gcmVzdWx0IGFuZCByZXBsYWNlcyBpdCB3aXRoIGFcclxuICAgICAgICAvLyBodW1hbi1yZWFkYWJsZSBzdHJpbmcsIHNvIHdlIG5lZWQgdG8gbWFrZSBpdCBtYWNoaW5lLXJlYWRhYmxlLlxyXG4gICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5jb2RlID09PSAtMzIwMTUgJiYgIWlzSGV4U3RyaW5nKGVycm9yLmRhdGEgfHwgXCJcIiwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgY29uc3QgcGFuaWNDb2RlcyA9IHtcclxuICAgICAgICAgICAgICAgIFwiYXNzZXJ0KGZhbHNlKVwiOiBcIjAxXCIsXHJcbiAgICAgICAgICAgICAgICBcImFyaXRobWV0aWMgdW5kZXJmbG93IG9yIG92ZXJmbG93XCI6IFwiMTFcIixcclxuICAgICAgICAgICAgICAgIFwiZGl2aXNpb24gb3IgbW9kdWxvIGJ5IHplcm9cIjogXCIxMlwiLFxyXG4gICAgICAgICAgICAgICAgXCJvdXQtb2YtYm91bmRzIGFycmF5IGFjY2VzczsgcG9wcGluZyBvbiBhbiBlbXB0eSBhcnJheVwiOiBcIjMxXCIsXHJcbiAgICAgICAgICAgICAgICBcIm91dC1vZi1ib3VuZHMgYWNjZXNzIG9mIGFuIGFycmF5IG9yIGJ5dGVzTlwiOiBcIjMyXCJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbGV0IHBhbmljQ29kZSA9IFwiXCI7XHJcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSBcIlZNIGV4ZWN1dGlvbiBlcnJvci5cIikge1xyXG4gICAgICAgICAgICAgICAgLy8gZXRoX2NhbGwgcGFzc2VzIHRoaXMgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgcGFuaWNDb2RlID0gcGFuaWNDb2Rlc1tlcnJvci5kYXRhXSB8fCBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhbmljQ29kZXNbZXJyb3IubWVzc2FnZSB8fCBcIlwiXSkge1xyXG4gICAgICAgICAgICAgICAgcGFuaWNDb2RlID0gcGFuaWNDb2Rlc1tlcnJvci5tZXNzYWdlIHx8IFwiXCJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYW5pY0NvZGUpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgKz0gYCAocmV2ZXJ0ZWQ6ICR7ZXJyb3IuZGF0YX0pYDtcclxuICAgICAgICAgICAgICAgIGVycm9yLmRhdGEgPSBcIjB4NGU0ODdiNzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiICsgcGFuaWNDb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGVycm9yICYmIGVycm9yLmNvZGUgPT09IC0zMjAwMCkge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSA9PT0gXCJ3cm9uZyB0cmFuc2FjdGlvbiBub25jZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlICs9IFwiIChub25jZSB0b28gbG93KVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdXBlci5nZXRScGNFcnJvcihwYXlsb2FkLCBfZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIHByZXBhcmVkIHJlcXVlc3QgZm9yIGNvbm5lY3RpbmcgdG8gJSVuZXR3b3JrJSVcclxuICAgICAqICB3aXRoICUlYXBpS2V5JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRSZXF1ZXN0KG5ldHdvcmspIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IEZldGNoUmVxdWVzdChnZXRVcmwobmV0d29yay5uYW1lKSk7XHJcbiAgICAgICAgcmVxdWVzdC5hbGxvd0d6aXAgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWJsb2Nrc2NvdXQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-blockscout.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-browser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-browser.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BrowserProvider: () => (/* binding */ BrowserProvider)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n\r\n\r\n;\r\n/**\r\n *  A **BrowserProvider** is intended to wrap an injected provider which\r\n *  adheres to the [[link-eip-1193]] standard, which most (if not all)\r\n *  currently do.\r\n */\r\nclass BrowserProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpcApiPollingProvider {\r\n    #request;\r\n    #providerInfo;\r\n    /**\r\n     *  Connect to the %%ethereum%% provider, optionally forcing the\r\n     *  %%network%%.\r\n     */\r\n    constructor(ethereum, network, _options) {\r\n        // Copy the options\r\n        const options = Object.assign({}, ((_options != null) ? _options : {}), { batchMaxCount: 1 });\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(ethereum && ethereum.request, \"invalid EIP-1193 provider\", \"ethereum\", ethereum);\r\n        super(network, options);\r\n        this.#providerInfo = null;\r\n        if (_options && _options.providerInfo) {\r\n            this.#providerInfo = _options.providerInfo;\r\n        }\r\n        this.#request = async (method, params) => {\r\n            const payload = { method, params };\r\n            this.emit(\"debug\", { action: \"sendEip1193Request\", payload });\r\n            try {\r\n                const result = await ethereum.request(payload);\r\n                this.emit(\"debug\", { action: \"receiveEip1193Result\", result });\r\n                return result;\r\n            }\r\n            catch (e) {\r\n                const error = new Error(e.message);\r\n                error.code = e.code;\r\n                error.data = e.data;\r\n                error.payload = payload;\r\n                this.emit(\"debug\", { action: \"receiveEip1193Error\", error });\r\n                throw error;\r\n            }\r\n        };\r\n    }\r\n    get providerInfo() {\r\n        return this.#providerInfo;\r\n    }\r\n    async send(method, params) {\r\n        await this._start();\r\n        return await super.send(method, params);\r\n    }\r\n    async _send(payload) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(!Array.isArray(payload), \"EIP-1193 does not support batch request\", \"payload\", payload);\r\n        try {\r\n            const result = await this.#request(payload.method, payload.params || []);\r\n            return [{ id: payload.id, result }];\r\n        }\r\n        catch (e) {\r\n            return [{\r\n                    id: payload.id,\r\n                    error: { code: e.code, data: e.data, message: e.message }\r\n                }];\r\n        }\r\n    }\r\n    getRpcError(payload, error) {\r\n        error = JSON.parse(JSON.stringify(error));\r\n        // EIP-1193 gives us some machine-readable error codes, so rewrite\r\n        // them into Ethers standard errors.\r\n        switch (error.error.code || -1) {\r\n            case 4001:\r\n                error.error.message = `ethers-user-denied: ${error.error.message}`;\r\n                break;\r\n            case 4200:\r\n                error.error.message = `ethers-unsupported: ${error.error.message}`;\r\n                break;\r\n        }\r\n        return super.getRpcError(payload, error);\r\n    }\r\n    /**\r\n     *  Resolves to ``true`` if the provider manages the %%address%%.\r\n     */\r\n    async hasSigner(address) {\r\n        if (address == null) {\r\n            address = 0;\r\n        }\r\n        const accounts = await this.send(\"eth_accounts\", []);\r\n        if (typeof (address) === \"number\") {\r\n            return (accounts.length > address);\r\n        }\r\n        address = address.toLowerCase();\r\n        return accounts.filter((a) => (a.toLowerCase() === address)).length !== 0;\r\n    }\r\n    async getSigner(address) {\r\n        if (address == null) {\r\n            address = 0;\r\n        }\r\n        if (!(await this.hasSigner(address))) {\r\n            try {\r\n                await this.#request(\"eth_requestAccounts\", []);\r\n            }\r\n            catch (error) {\r\n                const payload = error.payload;\r\n                throw this.getRpcError(payload, { id: payload.id, error });\r\n            }\r\n        }\r\n        return await super.getSigner(address);\r\n    }\r\n    /**\r\n     *  Discover and connect to a Provider in the Browser using the\r\n     *  [[link-eip-6963]] discovery mechanism. If no providers are\r\n     *  present, ``null`` is resolved.\r\n     */\r\n    static async discover(options) {\r\n        if (options == null) {\r\n            options = {};\r\n        }\r\n        if (options.provider) {\r\n            return new BrowserProvider(options.provider);\r\n        }\r\n        const context = options.window ? options.window :\r\n            (typeof (window) !== \"undefined\") ? window : null;\r\n        if (context == null) {\r\n            return null;\r\n        }\r\n        const anyProvider = options.anyProvider;\r\n        if (anyProvider && context.ethereum) {\r\n            return new BrowserProvider(context.ethereum);\r\n        }\r\n        if (!(\"addEventListener\" in context && \"dispatchEvent\" in context\r\n            && \"removeEventListener\" in context)) {\r\n            return null;\r\n        }\r\n        const timeout = options.timeout ? options.timeout : 300;\r\n        if (timeout === 0) {\r\n            return null;\r\n        }\r\n        return await (new Promise((resolve, reject) => {\r\n            let found = [];\r\n            const addProvider = (event) => {\r\n                found.push(event.detail);\r\n                if (anyProvider) {\r\n                    finalize();\r\n                }\r\n            };\r\n            const finalize = () => {\r\n                clearTimeout(timer);\r\n                if (found.length) {\r\n                    // If filtering is provided:\r\n                    if (options && options.filter) {\r\n                        // Call filter, with a copies of found provider infos\r\n                        const filtered = options.filter(found.map(i => Object.assign({}, (i.info))));\r\n                        if (filtered == null) {\r\n                            // No provider selected\r\n                            resolve(null);\r\n                        }\r\n                        else if (filtered instanceof BrowserProvider) {\r\n                            // Custom provider created\r\n                            resolve(filtered);\r\n                        }\r\n                        else {\r\n                            // Find the matching provider\r\n                            let match = null;\r\n                            if (filtered.uuid) {\r\n                                const matches = found.filter(f => (filtered.uuid === f.info.uuid));\r\n                                // @TODO: What should happen if multiple values\r\n                                //        for the same UUID?\r\n                                match = matches[0];\r\n                            }\r\n                            if (match) {\r\n                                const { provider, info } = match;\r\n                                resolve(new BrowserProvider(provider, undefined, {\r\n                                    providerInfo: info\r\n                                }));\r\n                            }\r\n                            else {\r\n                                reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.makeError)(\"filter returned unknown info\", \"UNSUPPORTED_OPERATION\", {\r\n                                    value: filtered\r\n                                }));\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        // Pick the first found provider\r\n                        const { provider, info } = found[0];\r\n                        resolve(new BrowserProvider(provider, undefined, {\r\n                            providerInfo: info\r\n                        }));\r\n                    }\r\n                }\r\n                else {\r\n                    // Nothing found\r\n                    resolve(null);\r\n                }\r\n                context.removeEventListener(\"eip6963:announceProvider\", addProvider);\r\n            };\r\n            const timer = setTimeout(() => { finalize(); }, timeout);\r\n            context.addEventListener(\"eip6963:announceProvider\", addProvider);\r\n            context.dispatchEvent(new Event(\"eip6963:requestProvider\"));\r\n        }));\r\n    }\r\n}\r\n//# sourceMappingURL=provider-browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEQ7QUFDSTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw4QkFBOEIsMkVBQXlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MscUNBQXFDLEtBQUssa0JBQWtCO0FBQ3BHLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGlDQUFpQyx1Q0FBdUM7QUFDeEU7QUFDQTtBQUNBLHFDQUFxQyx3Q0FBd0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0NBQXNDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsb0JBQW9CO0FBQ2pGO0FBQ0E7QUFDQSw2REFBNkQsb0JBQW9CO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHVCQUF1QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsdUNBQXVDLDBEQUFTO0FBQ2hEO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHByb3ZpZGVyc1xccHJvdmlkZXItYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NlcnRBcmd1bWVudCwgbWFrZUVycm9yIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1qc29ucnBjLmpzXCI7XHJcbjtcclxuLyoqXHJcbiAqICBBICoqQnJvd3NlclByb3ZpZGVyKiogaXMgaW50ZW5kZWQgdG8gd3JhcCBhbiBpbmplY3RlZCBwcm92aWRlciB3aGljaFxyXG4gKiAgYWRoZXJlcyB0byB0aGUgW1tsaW5rLWVpcC0xMTkzXV0gc3RhbmRhcmQsIHdoaWNoIG1vc3QgKGlmIG5vdCBhbGwpXHJcbiAqICBjdXJyZW50bHkgZG8uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQnJvd3NlclByb3ZpZGVyIGV4dGVuZHMgSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciB7XHJcbiAgICAjcmVxdWVzdDtcclxuICAgICNwcm92aWRlckluZm87XHJcbiAgICAvKipcclxuICAgICAqICBDb25uZWN0IHRvIHRoZSAlJWV0aGVyZXVtJSUgcHJvdmlkZXIsIG9wdGlvbmFsbHkgZm9yY2luZyB0aGVcclxuICAgICAqICAlJW5ldHdvcmslJS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZXRoZXJldW0sIG5ldHdvcmssIF9vcHRpb25zKSB7XHJcbiAgICAgICAgLy8gQ29weSB0aGUgb3B0aW9uc1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCAoKF9vcHRpb25zICE9IG51bGwpID8gX29wdGlvbnMgOiB7fSksIHsgYmF0Y2hNYXhDb3VudDogMSB9KTtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChldGhlcmV1bSAmJiBldGhlcmV1bS5yZXF1ZXN0LCBcImludmFsaWQgRUlQLTExOTMgcHJvdmlkZXJcIiwgXCJldGhlcmV1bVwiLCBldGhlcmV1bSk7XHJcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy4jcHJvdmlkZXJJbmZvID0gbnVsbDtcclxuICAgICAgICBpZiAoX29wdGlvbnMgJiYgX29wdGlvbnMucHJvdmlkZXJJbmZvKSB7XHJcbiAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVySW5mbyA9IF9vcHRpb25zLnByb3ZpZGVySW5mbztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jcmVxdWVzdCA9IGFzeW5jIChtZXRob2QsIHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0geyBtZXRob2QsIHBhcmFtcyB9O1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kRWlwMTE5M1JlcXVlc3RcIiwgcGF5bG9hZCB9KTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV0aGVyZXVtLnJlcXVlc3QocGF5bG9hZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlRWlwMTE5M1Jlc3VsdFwiLCByZXN1bHQgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihlLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IGUuY29kZTtcclxuICAgICAgICAgICAgICAgIGVycm9yLmRhdGEgPSBlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICBlcnJvci5wYXlsb2FkID0gcGF5bG9hZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFaXAxMTkzRXJyb3JcIiwgZXJyb3IgfSk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBnZXQgcHJvdmlkZXJJbmZvKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNwcm92aWRlckluZm87XHJcbiAgICB9XHJcbiAgICBhc3luYyBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnQoKTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuc2VuZChtZXRob2QsIHBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfc2VuZChwYXlsb2FkKSB7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIUFycmF5LmlzQXJyYXkocGF5bG9hZCksIFwiRUlQLTExOTMgZG9lcyBub3Qgc3VwcG9ydCBiYXRjaCByZXF1ZXN0XCIsIFwicGF5bG9hZFwiLCBwYXlsb2FkKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNyZXF1ZXN0KHBheWxvYWQubWV0aG9kLCBwYXlsb2FkLnBhcmFtcyB8fCBbXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBbeyBpZDogcGF5bG9hZC5pZCwgcmVzdWx0IH1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3tcclxuICAgICAgICAgICAgICAgICAgICBpZDogcGF5bG9hZC5pZCxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogeyBjb2RlOiBlLmNvZGUsIGRhdGE6IGUuZGF0YSwgbWVzc2FnZTogZS5tZXNzYWdlIH1cclxuICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldFJwY0Vycm9yKHBheWxvYWQsIGVycm9yKSB7XHJcbiAgICAgICAgZXJyb3IgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XHJcbiAgICAgICAgLy8gRUlQLTExOTMgZ2l2ZXMgdXMgc29tZSBtYWNoaW5lLXJlYWRhYmxlIGVycm9yIGNvZGVzLCBzbyByZXdyaXRlXHJcbiAgICAgICAgLy8gdGhlbSBpbnRvIEV0aGVycyBzdGFuZGFyZCBlcnJvcnMuXHJcbiAgICAgICAgc3dpdGNoIChlcnJvci5lcnJvci5jb2RlIHx8IC0xKSB7XHJcbiAgICAgICAgICAgIGNhc2UgNDAwMTpcclxuICAgICAgICAgICAgICAgIGVycm9yLmVycm9yLm1lc3NhZ2UgPSBgZXRoZXJzLXVzZXItZGVuaWVkOiAke2Vycm9yLmVycm9yLm1lc3NhZ2V9YDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDQyMDA6XHJcbiAgICAgICAgICAgICAgICBlcnJvci5lcnJvci5tZXNzYWdlID0gYGV0aGVycy11bnN1cHBvcnRlZDogJHtlcnJvci5lcnJvci5tZXNzYWdlfWA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldFJwY0Vycm9yKHBheWxvYWQsIGVycm9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIHRvIGBgdHJ1ZWBgIGlmIHRoZSBwcm92aWRlciBtYW5hZ2VzIHRoZSAlJWFkZHJlc3MlJS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgaGFzU2lnbmVyKGFkZHJlc3MpIHtcclxuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGFkZHJlc3MgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMuc2VuZChcImV0aF9hY2NvdW50c1wiLCBbXSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoYWRkcmVzcykgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChhY2NvdW50cy5sZW5ndGggPiBhZGRyZXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICByZXR1cm4gYWNjb3VudHMuZmlsdGVyKChhKSA9PiAoYS50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzKSkubGVuZ3RoICE9PSAwO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0U2lnbmVyKGFkZHJlc3MpIHtcclxuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGFkZHJlc3MgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLmhhc1NpZ25lcihhZGRyZXNzKSkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI3JlcXVlc3QoXCJldGhfcmVxdWVzdEFjY291bnRzXCIsIFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBlcnJvci5wYXlsb2FkO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5nZXRScGNFcnJvcihwYXlsb2FkLCB7IGlkOiBwYXlsb2FkLmlkLCBlcnJvciB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuZ2V0U2lnbmVyKGFkZHJlc3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgRGlzY292ZXIgYW5kIGNvbm5lY3QgdG8gYSBQcm92aWRlciBpbiB0aGUgQnJvd3NlciB1c2luZyB0aGVcclxuICAgICAqICBbW2xpbmstZWlwLTY5NjNdXSBkaXNjb3ZlcnkgbWVjaGFuaXNtLiBJZiBubyBwcm92aWRlcnMgYXJlXHJcbiAgICAgKiAgcHJlc2VudCwgYGBudWxsYGAgaXMgcmVzb2x2ZWQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhc3luYyBkaXNjb3ZlcihvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLnByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnJvd3NlclByb3ZpZGVyKG9wdGlvbnMucHJvdmlkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gb3B0aW9ucy53aW5kb3cgPyBvcHRpb25zLndpbmRvdyA6XHJcbiAgICAgICAgICAgICh0eXBlb2YgKHdpbmRvdykgIT09IFwidW5kZWZpbmVkXCIpID8gd2luZG93IDogbnVsbDtcclxuICAgICAgICBpZiAoY29udGV4dCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhbnlQcm92aWRlciA9IG9wdGlvbnMuYW55UHJvdmlkZXI7XHJcbiAgICAgICAgaWYgKGFueVByb3ZpZGVyICYmIGNvbnRleHQuZXRoZXJldW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCcm93c2VyUHJvdmlkZXIoY29udGV4dC5ldGhlcmV1bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKFwiYWRkRXZlbnRMaXN0ZW5lclwiIGluIGNvbnRleHQgJiYgXCJkaXNwYXRjaEV2ZW50XCIgaW4gY29udGV4dFxyXG4gICAgICAgICAgICAmJiBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIiBpbiBjb250ZXh0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGltZW91dCA9IG9wdGlvbnMudGltZW91dCA/IG9wdGlvbnMudGltZW91dCA6IDMwMDtcclxuICAgICAgICBpZiAodGltZW91dCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IChuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCBhZGRQcm92aWRlciA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZm91bmQucHVzaChldmVudC5kZXRhaWwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFueVByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgZmluYWxpemUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGZpbHRlcmluZyBpcyBwcm92aWRlZDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGZpbHRlciwgd2l0aCBhIGNvcGllcyBvZiBmb3VuZCBwcm92aWRlciBpbmZvc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IG9wdGlvbnMuZmlsdGVyKGZvdW5kLm1hcChpID0+IE9iamVjdC5hc3NpZ24oe30sIChpLmluZm8pKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gcHJvdmlkZXIgc2VsZWN0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmlsdGVyZWQgaW5zdGFuY2VvZiBCcm93c2VyUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEN1c3RvbSBwcm92aWRlciBjcmVhdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZpbHRlcmVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1hdGNoaW5nIHByb3ZpZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcmVkLnV1aWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gZm91bmQuZmlsdGVyKGYgPT4gKGZpbHRlcmVkLnV1aWQgPT09IGYuaW5mby51dWlkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IFdoYXQgc2hvdWxkIGhhcHBlbiBpZiBtdWx0aXBsZSB2YWx1ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgZm9yIHRoZSBzYW1lIFVVSUQ/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwcm92aWRlciwgaW5mbyB9ID0gbWF0Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgQnJvd3NlclByb3ZpZGVyKHByb3ZpZGVyLCB1bmRlZmluZWQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJJbmZvOiBpbmZvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcImZpbHRlciByZXR1cm5lZCB1bmtub3duIGluZm9cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmlsdGVyZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBpY2sgdGhlIGZpcnN0IGZvdW5kIHByb3ZpZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvdmlkZXIsIGluZm8gfSA9IGZvdW5kWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG5ldyBCcm93c2VyUHJvdmlkZXIocHJvdmlkZXIsIHVuZGVmaW5lZCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJJbmZvOiBpbmZvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIGZvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVpcDY5NjM6YW5ub3VuY2VQcm92aWRlclwiLCBhZGRQcm92aWRlcik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7IGZpbmFsaXplKCk7IH0sIHRpbWVvdXQpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJlaXA2OTYzOmFubm91bmNlUHJvdmlkZXJcIiwgYWRkUHJvdmlkZXIpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiZWlwNjk2MzpyZXF1ZXN0UHJvdmlkZXJcIikpO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1icm93c2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-browser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-chainstack.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-chainstack.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChainstackProvider: () => (/* binding */ ChainstackProvider)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _community_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./community.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/community.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/**\r\n *  [[link-chainstack]] provides a third-party service for connecting to\r\n *  various blockchains over JSON-RPC.\r\n *\r\n *  **Supported Networks**\r\n *\r\n *  - Ethereum Mainnet (``mainnet``)\r\n *  - Arbitrum (``arbitrum``)\r\n *  - BNB Smart Chain Mainnet (``bnb``)\r\n *  - Polygon (``matic``)\r\n *\r\n *  @_subsection: api/providers/thirdparty:Chainstack  [providers-chainstack]\r\n */\r\n\r\n\r\n\r\n\r\nfunction getApiKey(name) {\r\n    switch (name) {\r\n        case \"mainnet\": return \"39f1d67cedf8b7831010a665328c9197\";\r\n        case \"arbitrum\": return \"0550c209db33c3abf4cc927e1e18cea1\";\r\n        case \"bnb\": return \"98b5a77e531614387366f6fc5da097f8\";\r\n        case \"matic\": return \"cd9d4d70377471aa7c142ec4a4205249\";\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported network\", \"network\", name);\r\n}\r\nfunction getHost(name) {\r\n    switch (name) {\r\n        case \"mainnet\":\r\n            return \"ethereum-mainnet.core.chainstack.com\";\r\n        case \"arbitrum\":\r\n            return \"arbitrum-mainnet.core.chainstack.com\";\r\n        case \"bnb\":\r\n            return \"bsc-mainnet.core.chainstack.com\";\r\n        case \"matic\":\r\n            return \"polygon-mainnet.core.chainstack.com\";\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported network\", \"network\", name);\r\n}\r\n/**\r\n *  The **ChainstackProvider** connects to the [[link-chainstack]]\r\n *  JSON-RPC end-points.\r\n *\r\n *  By default, a highly-throttled API key is used, which is\r\n *  appropriate for quick prototypes and simple scripts. To\r\n *  gain access to an increased rate-limit, it is highly\r\n *  recommended to [sign up here](link-chainstack).\r\n */\r\nclass ChainstackProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__.JsonRpcProvider {\r\n    /**\r\n     *  The API key for the Chainstack connection.\r\n     */\r\n    apiKey;\r\n    /**\r\n     *  Creates a new **ChainstackProvider**.\r\n     */\r\n    constructor(_network, apiKey) {\r\n        if (_network == null) {\r\n            _network = \"mainnet\";\r\n        }\r\n        const network = _network_js__WEBPACK_IMPORTED_MODULE_2__.Network.from(_network);\r\n        if (apiKey == null) {\r\n            apiKey = getApiKey(network.name);\r\n        }\r\n        const request = ChainstackProvider.getRequest(network, apiKey);\r\n        super(request, network, { staticNetwork: network });\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { apiKey });\r\n    }\r\n    _getProvider(chainId) {\r\n        try {\r\n            return new ChainstackProvider(chainId, this.apiKey);\r\n        }\r\n        catch (error) { }\r\n        return super._getProvider(chainId);\r\n    }\r\n    isCommunityResource() {\r\n        return (this.apiKey === getApiKey(this._network.name));\r\n    }\r\n    /**\r\n     *  Returns a prepared request for connecting to %%network%%\r\n     *  with %%apiKey%% and %%projectSecret%%.\r\n     */\r\n    static getRequest(network, apiKey) {\r\n        if (apiKey == null) {\r\n            apiKey = getApiKey(network.name);\r\n        }\r\n        const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(`https:/\\/${getHost(network.name)}/${apiKey}`);\r\n        request.allowGzip = true;\r\n        if (apiKey === getApiKey(network.name)) {\r\n            request.retryFunc = async (request, response, attempt) => {\r\n                (0,_community_js__WEBPACK_IMPORTED_MODULE_3__.showThrottleMessage)(\"ChainstackProvider\");\r\n                return true;\r\n            };\r\n        }\r\n        return request;\r\n    }\r\n}\r\n//# sourceMappingURL=provider-chainstack.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItY2hhaW5zdGFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ21GO0FBQzlCO0FBQ2Q7QUFDaUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0RBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUMsaUVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnREFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQsUUFBUSxpRUFBZ0IsU0FBUyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlEQUFZLGFBQWEsc0JBQXNCLEdBQUcsT0FBTztBQUNyRjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHByb3ZpZGVyc1xccHJvdmlkZXItY2hhaW5zdGFjay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIFtbbGluay1jaGFpbnN0YWNrXV0gcHJvdmlkZXMgYSB0aGlyZC1wYXJ0eSBzZXJ2aWNlIGZvciBjb25uZWN0aW5nIHRvXHJcbiAqICB2YXJpb3VzIGJsb2NrY2hhaW5zIG92ZXIgSlNPTi1SUEMuXHJcbiAqXHJcbiAqICAqKlN1cHBvcnRlZCBOZXR3b3JrcyoqXHJcbiAqXHJcbiAqICAtIEV0aGVyZXVtIE1haW5uZXQgKGBgbWFpbm5ldGBgKVxyXG4gKiAgLSBBcmJpdHJ1bSAoYGBhcmJpdHJ1bWBgKVxyXG4gKiAgLSBCTkIgU21hcnQgQ2hhaW4gTWFpbm5ldCAoYGBibmJgYClcclxuICogIC0gUG9seWdvbiAoYGBtYXRpY2BgKVxyXG4gKlxyXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHk6Q2hhaW5zdGFjayAgW3Byb3ZpZGVycy1jaGFpbnN0YWNrXVxyXG4gKi9cclxuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgRmV0Y2hSZXF1ZXN0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBzaG93VGhyb3R0bGVNZXNzYWdlIH0gZnJvbSBcIi4vY29tbXVuaXR5LmpzXCI7XHJcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XHJcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIjtcclxuZnVuY3Rpb24gZ2V0QXBpS2V5KG5hbWUpIHtcclxuICAgIHN3aXRjaCAobmFtZSkge1xyXG4gICAgICAgIGNhc2UgXCJtYWlubmV0XCI6IHJldHVybiBcIjM5ZjFkNjdjZWRmOGI3ODMxMDEwYTY2NTMyOGM5MTk3XCI7XHJcbiAgICAgICAgY2FzZSBcImFyYml0cnVtXCI6IHJldHVybiBcIjA1NTBjMjA5ZGIzM2MzYWJmNGNjOTI3ZTFlMThjZWExXCI7XHJcbiAgICAgICAgY2FzZSBcImJuYlwiOiByZXR1cm4gXCI5OGI1YTc3ZTUzMTYxNDM4NzM2NmY2ZmM1ZGEwOTdmOFwiO1xyXG4gICAgICAgIGNhc2UgXCJtYXRpY1wiOiByZXR1cm4gXCJjZDlkNGQ3MDM3NzQ3MWFhN2MxNDJlYzRhNDIwNTI0OVwiO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmFtZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0SG9zdChuYW1lKSB7XHJcbiAgICBzd2l0Y2ggKG5hbWUpIHtcclxuICAgICAgICBjYXNlIFwibWFpbm5ldFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcmV1bS1tYWlubmV0LmNvcmUuY2hhaW5zdGFjay5jb21cIjtcclxuICAgICAgICBjYXNlIFwiYXJiaXRydW1cIjpcclxuICAgICAgICAgICAgcmV0dXJuIFwiYXJiaXRydW0tbWFpbm5ldC5jb3JlLmNoYWluc3RhY2suY29tXCI7XHJcbiAgICAgICAgY2FzZSBcImJuYlwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJic2MtbWFpbm5ldC5jb3JlLmNoYWluc3RhY2suY29tXCI7XHJcbiAgICAgICAgY2FzZSBcIm1hdGljXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcInBvbHlnb24tbWFpbm5ldC5jb3JlLmNoYWluc3RhY2suY29tXCI7XHJcbiAgICB9XHJcbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuYW1lKTtcclxufVxyXG4vKipcclxuICogIFRoZSAqKkNoYWluc3RhY2tQcm92aWRlcioqIGNvbm5lY3RzIHRvIHRoZSBbW2xpbmstY2hhaW5zdGFja11dXHJcbiAqICBKU09OLVJQQyBlbmQtcG9pbnRzLlxyXG4gKlxyXG4gKiAgQnkgZGVmYXVsdCwgYSBoaWdobHktdGhyb3R0bGVkIEFQSSBrZXkgaXMgdXNlZCwgd2hpY2ggaXNcclxuICogIGFwcHJvcHJpYXRlIGZvciBxdWljayBwcm90b3R5cGVzIGFuZCBzaW1wbGUgc2NyaXB0cy4gVG9cclxuICogIGdhaW4gYWNjZXNzIHRvIGFuIGluY3JlYXNlZCByYXRlLWxpbWl0LCBpdCBpcyBoaWdobHlcclxuICogIHJlY29tbWVuZGVkIHRvIFtzaWduIHVwIGhlcmVdKGxpbmstY2hhaW5zdGFjaykuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2hhaW5zdGFja1Byb3ZpZGVyIGV4dGVuZHMgSnNvblJwY1Byb3ZpZGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBBUEkga2V5IGZvciB0aGUgQ2hhaW5zdGFjayBjb25uZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBhcGlLZXk7XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqQ2hhaW5zdGFja1Byb3ZpZGVyKiouXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCBhcGlLZXkpIHtcclxuICAgICAgICBpZiAoX25ldHdvcmsgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBfbmV0d29yayA9IFwibWFpbm5ldFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXR3b3JrID0gTmV0d29yay5mcm9tKF9uZXR3b3JrKTtcclxuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgYXBpS2V5ID0gZ2V0QXBpS2V5KG5ldHdvcmsubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBDaGFpbnN0YWNrUHJvdmlkZXIuZ2V0UmVxdWVzdChuZXR3b3JrLCBhcGlLZXkpO1xyXG4gICAgICAgIHN1cGVyKHJlcXVlc3QsIG5ldHdvcmssIHsgc3RhdGljTmV0d29yazogbmV0d29yayB9KTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYXBpS2V5IH0pO1xyXG4gICAgfVxyXG4gICAgX2dldFByb3ZpZGVyKGNoYWluSWQpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYWluc3RhY2tQcm92aWRlcihjaGFpbklkLCB0aGlzLmFwaUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9nZXRQcm92aWRlcihjaGFpbklkKTtcclxuICAgIH1cclxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmFwaUtleSA9PT0gZ2V0QXBpS2V5KHRoaXMuX25ldHdvcmsubmFtZSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIHByZXBhcmVkIHJlcXVlc3QgZm9yIGNvbm5lY3RpbmcgdG8gJSVuZXR3b3JrJSVcclxuICAgICAqICB3aXRoICUlYXBpS2V5JSUgYW5kICUlcHJvamVjdFNlY3JldCUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0UmVxdWVzdChuZXR3b3JrLCBhcGlLZXkpIHtcclxuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgYXBpS2V5ID0gZ2V0QXBpS2V5KG5ldHdvcmsubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgRmV0Y2hSZXF1ZXN0KGBodHRwczovXFwvJHtnZXRIb3N0KG5ldHdvcmsubmFtZSl9LyR7YXBpS2V5fWApO1xyXG4gICAgICAgIHJlcXVlc3QuYWxsb3dHemlwID0gdHJ1ZTtcclxuICAgICAgICBpZiAoYXBpS2V5ID09PSBnZXRBcGlLZXkobmV0d29yay5uYW1lKSkge1xyXG4gICAgICAgICAgICByZXF1ZXN0LnJldHJ5RnVuYyA9IGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSwgYXR0ZW1wdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2hvd1Rocm90dGxlTWVzc2FnZShcIkNoYWluc3RhY2tQcm92aWRlclwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1jaGFpbnN0YWNrLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-chainstack.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-cloudflare.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-cloudflare.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CloudflareProvider: () => (/* binding */ CloudflareProvider)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./network.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/**\r\n *  About Cloudflare\r\n *\r\n *  @_subsection: api/providers/thirdparty:Cloudflare  [providers-cloudflare]\r\n */\r\n\r\n\r\n\r\n/**\r\n *  About Cloudflare...\r\n */\r\nclass CloudflareProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpcProvider {\r\n    constructor(_network) {\r\n        if (_network == null) {\r\n            _network = \"mainnet\";\r\n        }\r\n        const network = _network_js__WEBPACK_IMPORTED_MODULE_1__.Network.from(_network);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(network.name === \"mainnet\", \"unsupported network\", \"network\", _network);\r\n        super(\"https:/\\/cloudflare-eth.com/\", network, { staticNetwork: network });\r\n    }\r\n}\r\n//# sourceMappingURL=provider-cloudflare.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItY2xvdWRmbGFyZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNtRDtBQUNaO0FBQ2lCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPLGlDQUFpQyxpRUFBZTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnREFBTztBQUMvQixRQUFRLCtEQUFjO0FBQ3RCLHlEQUF5RCx3QkFBd0I7QUFDakY7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHByb3ZpZGVyc1xccHJvdmlkZXItY2xvdWRmbGFyZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIEFib3V0IENsb3VkZmxhcmVcclxuICpcclxuICogIEBfc3Vic2VjdGlvbjogYXBpL3Byb3ZpZGVycy90aGlyZHBhcnR5OkNsb3VkZmxhcmUgIFtwcm92aWRlcnMtY2xvdWRmbGFyZV1cclxuICovXHJcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XHJcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIjtcclxuLyoqXHJcbiAqICBBYm91dCBDbG91ZGZsYXJlLi4uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2xvdWRmbGFyZVByb3ZpZGVyIGV4dGVuZHMgSnNvblJwY1Byb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrKSB7XHJcbiAgICAgICAgaWYgKF9uZXR3b3JrID09IG51bGwpIHtcclxuICAgICAgICAgICAgX25ldHdvcmsgPSBcIm1haW5uZXRcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV0d29yayA9IE5ldHdvcmsuZnJvbShfbmV0d29yayk7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQobmV0d29yay5uYW1lID09PSBcIm1haW5uZXRcIiwgXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBfbmV0d29yayk7XHJcbiAgICAgICAgc3VwZXIoXCJodHRwczovXFwvY2xvdWRmbGFyZS1ldGguY29tL1wiLCBuZXR3b3JrLCB7IHN0YXRpY05ldHdvcms6IG5ldHdvcmsgfSk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItY2xvdWRmbGFyZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-cloudflare.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-etherscan.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-etherscan.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EtherscanPlugin: () => (/* binding */ EtherscanPlugin),\n/* harmony export */   EtherscanProvider: () => (/* binding */ EtherscanProvider)\n/* harmony export */ });\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../abi/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/index.js\");\n/* harmony import */ var _contract_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../contract/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/contract/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../transaction/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _abstract_provider_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-provider.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/abstract-provider.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./network.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _plugins_network_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugins-network.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/plugins-network.js\");\n/* harmony import */ var _community_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./community.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/community.js\");\n/**\r\n *  [[link-etherscan]] provides a third-party service for connecting to\r\n *  various blockchains over a combination of JSON-RPC and custom API\r\n *  endpoints.\r\n *\r\n *  **Supported Networks**\r\n *\r\n *  - Ethereum Mainnet (``mainnet``)\r\n *  - Goerli Testnet (``goerli``)\r\n *  - Sepolia Testnet (``sepolia``)\r\n *  - Holesky Testnet (``holesky``)\r\n *  - Arbitrum (``arbitrum``)\r\n *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)\r\n *  - Base (``base``)\r\n *  - Base Sepolia Testnet (``base-sepolia``)\r\n *  - BNB Smart Chain Mainnet (``bnb``)\r\n *  - BNB Smart Chain Testnet (``bnbt``)\r\n *  - Optimism (``optimism``)\r\n *  - Optimism Goerli Testnet (``optimism-goerli``)\r\n *  - Polygon (``matic``)\r\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\r\n *  - Polygon Amoy Testnet (``matic-amoy``)\r\n *\r\n *  @_subsection api/providers/thirdparty:Etherscan  [providers-etherscan]\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst THROTTLE = 2000;\r\nfunction isPromise(value) {\r\n    return (value && typeof (value.then) === \"function\");\r\n}\r\nconst EtherscanPluginId = \"org.ethers.plugins.provider.Etherscan\";\r\n/**\r\n *  A Network can include an **EtherscanPlugin** to provide\r\n *  a custom base URL.\r\n *\r\n *  @_docloc: api/providers/thirdparty:Etherscan\r\n */\r\nclass EtherscanPlugin extends _plugins_network_js__WEBPACK_IMPORTED_MODULE_0__.NetworkPlugin {\r\n    /**\r\n     *  The Etherscan API base URL.\r\n     */\r\n    baseUrl;\r\n    /**\r\n     *  Creates a new **EtherscanProvider** which will use\r\n     *  %%baseUrl%%.\r\n     */\r\n    constructor(baseUrl) {\r\n        super(EtherscanPluginId);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { baseUrl });\r\n    }\r\n    clone() {\r\n        return new EtherscanPlugin(this.baseUrl);\r\n    }\r\n}\r\nconst skipKeys = [\"enableCcipRead\"];\r\nlet nextId = 1;\r\n/**\r\n *  The **EtherscanBaseProvider** is the super-class of\r\n *  [[EtherscanProvider]], which should generally be used instead.\r\n *\r\n *  Since the **EtherscanProvider** includes additional code for\r\n *  [[Contract]] access, in //rare cases// that contracts are not\r\n *  used, this class can reduce code size.\r\n *\r\n *  @_docloc: api/providers/thirdparty:Etherscan\r\n */\r\nclass EtherscanProvider extends _abstract_provider_js__WEBPACK_IMPORTED_MODULE_2__.AbstractProvider {\r\n    /**\r\n     *  The connected network.\r\n     */\r\n    network;\r\n    /**\r\n     *  The API key or null if using the community provided bandwidth.\r\n     */\r\n    apiKey;\r\n    #plugin;\r\n    /**\r\n     *  Creates a new **EtherscanBaseProvider**.\r\n     */\r\n    constructor(_network, _apiKey) {\r\n        const apiKey = (_apiKey != null) ? _apiKey : null;\r\n        super();\r\n        const network = _network_js__WEBPACK_IMPORTED_MODULE_3__.Network.from(_network);\r\n        this.#plugin = network.getPlugin(EtherscanPluginId);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { apiKey, network });\r\n    }\r\n    /**\r\n     *  Returns the base URL.\r\n     *\r\n     *  If an [[EtherscanPlugin]] is configured on the\r\n     *  [[EtherscanBaseProvider_network]], returns the plugin's\r\n     *  baseUrl.\r\n     *\r\n     *  Deprecated; for Etherscan v2 the base is no longer a simply\r\n     *  host, but instead a URL including a chainId parameter. Changing\r\n     *  this to return a URL prefix could break some libraries, so it\r\n     *  is left intact but will be removed in the future as it is unused.\r\n     */\r\n    getBaseUrl() {\r\n        if (this.#plugin) {\r\n            return this.#plugin.baseUrl;\r\n        }\r\n        switch (this.network.name) {\r\n            case \"mainnet\":\r\n                return \"https:/\\/api.etherscan.io\";\r\n            case \"goerli\":\r\n                return \"https:/\\/api-goerli.etherscan.io\";\r\n            case \"sepolia\":\r\n                return \"https:/\\/api-sepolia.etherscan.io\";\r\n            case \"holesky\":\r\n                return \"https:/\\/api-holesky.etherscan.io\";\r\n            case \"arbitrum\":\r\n                return \"https:/\\/api.arbiscan.io\";\r\n            case \"arbitrum-goerli\":\r\n                return \"https:/\\/api-goerli.arbiscan.io\";\r\n            case \"base\":\r\n                return \"https:/\\/api.basescan.org\";\r\n            case \"base-sepolia\":\r\n                return \"https:/\\/api-sepolia.basescan.org\";\r\n            case \"bnb\":\r\n                return \"https:/\\/api.bscscan.com\";\r\n            case \"bnbt\":\r\n                return \"https:/\\/api-testnet.bscscan.com\";\r\n            case \"matic\":\r\n                return \"https:/\\/api.polygonscan.com\";\r\n            case \"matic-amoy\":\r\n                return \"https:/\\/api-amoy.polygonscan.com\";\r\n            case \"matic-mumbai\":\r\n                return \"https:/\\/api-testnet.polygonscan.com\";\r\n            case \"optimism\":\r\n                return \"https:/\\/api-optimistic.etherscan.io\";\r\n            case \"optimism-goerli\":\r\n                return \"https:/\\/api-goerli-optimistic.etherscan.io\";\r\n            default:\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported network\", \"network\", this.network);\r\n    }\r\n    /**\r\n     *  Returns the URL for the %%module%% and %%params%%.\r\n     */\r\n    getUrl(module, params) {\r\n        let query = Object.keys(params).reduce((accum, key) => {\r\n            const value = params[key];\r\n            if (value != null) {\r\n                accum += `&${key}=${value}`;\r\n            }\r\n            return accum;\r\n        }, \"\");\r\n        if (this.apiKey) {\r\n            query += `&apikey=${this.apiKey}`;\r\n        }\r\n        return `https:/\\/api.etherscan.io/v2/api?chainid=${this.network.chainId}&module=${module}${query}`;\r\n    }\r\n    /**\r\n     *  Returns the URL for using POST requests.\r\n     */\r\n    getPostUrl() {\r\n        return `https:/\\/api.etherscan.io/v2/api?chainid=${this.network.chainId}`;\r\n    }\r\n    /**\r\n     *  Returns the parameters for using POST requests.\r\n     */\r\n    getPostData(module, params) {\r\n        params.module = module;\r\n        params.apikey = this.apiKey;\r\n        params.chainid = this.network.chainId;\r\n        return params;\r\n    }\r\n    async detectNetwork() {\r\n        return this.network;\r\n    }\r\n    /**\r\n     *  Resolves to the result of calling %%module%% with %%params%%.\r\n     *\r\n     *  If %%post%%, the request is made as a POST request.\r\n     */\r\n    async fetch(module, params, post) {\r\n        const id = nextId++;\r\n        const url = (post ? this.getPostUrl() : this.getUrl(module, params));\r\n        const payload = (post ? this.getPostData(module, params) : null);\r\n        this.emit(\"debug\", { action: \"sendRequest\", id, url, payload: payload });\r\n        const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_1__.FetchRequest(url);\r\n        request.setThrottleParams({ slotInterval: 1000 });\r\n        request.retryFunc = (req, resp, attempt) => {\r\n            if (this.isCommunityResource()) {\r\n                (0,_community_js__WEBPACK_IMPORTED_MODULE_4__.showThrottleMessage)(\"Etherscan\");\r\n            }\r\n            return Promise.resolve(true);\r\n        };\r\n        request.processFunc = async (request, response) => {\r\n            const result = response.hasBody() ? JSON.parse((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(response.body)) : {};\r\n            const throttle = ((typeof (result.result) === \"string\") ? result.result : \"\").toLowerCase().indexOf(\"rate limit\") >= 0;\r\n            if (module === \"proxy\") {\r\n                // This JSON response indicates we are being throttled\r\n                if (result && result.status == 0 && result.message == \"NOTOK\" && throttle) {\r\n                    this.emit(\"debug\", { action: \"receiveError\", id, reason: \"proxy-NOTOK\", error: result });\r\n                    response.throwThrottleError(result.result, THROTTLE);\r\n                }\r\n            }\r\n            else {\r\n                if (throttle) {\r\n                    this.emit(\"debug\", { action: \"receiveError\", id, reason: \"null result\", error: result.result });\r\n                    response.throwThrottleError(result.result, THROTTLE);\r\n                }\r\n            }\r\n            return response;\r\n        };\r\n        if (payload) {\r\n            request.setHeader(\"content-type\", \"application/x-www-form-urlencoded; charset=UTF-8\");\r\n            request.body = Object.keys(payload).map((k) => `${k}=${payload[k]}`).join(\"&\");\r\n        }\r\n        const response = await request.send();\r\n        try {\r\n            response.assertOk();\r\n        }\r\n        catch (error) {\r\n            this.emit(\"debug\", { action: \"receiveError\", id, error, reason: \"assertOk\" });\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"response error\", \"SERVER_ERROR\", { request, response });\r\n        }\r\n        if (!response.hasBody()) {\r\n            this.emit(\"debug\", { action: \"receiveError\", id, error: \"missing body\", reason: \"null body\" });\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"missing response\", \"SERVER_ERROR\", { request, response });\r\n        }\r\n        const result = JSON.parse((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(response.body));\r\n        if (module === \"proxy\") {\r\n            if (result.jsonrpc != \"2.0\") {\r\n                this.emit(\"debug\", { action: \"receiveError\", id, result, reason: \"invalid JSON-RPC\" });\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"invalid JSON-RPC response (missing jsonrpc='2.0')\", \"SERVER_ERROR\", { request, response, info: { result } });\r\n            }\r\n            if (result.error) {\r\n                this.emit(\"debug\", { action: \"receiveError\", id, result, reason: \"JSON-RPC error\" });\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"error response\", \"SERVER_ERROR\", { request, response, info: { result } });\r\n            }\r\n            this.emit(\"debug\", { action: \"receiveRequest\", id, result });\r\n            return result.result;\r\n        }\r\n        else {\r\n            // getLogs, getHistory have weird success responses\r\n            if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\r\n                this.emit(\"debug\", { action: \"receiveRequest\", id, result });\r\n                return result.result;\r\n            }\r\n            if (result.status != 1 || (typeof (result.message) === \"string\" && !result.message.match(/^OK/))) {\r\n                this.emit(\"debug\", { action: \"receiveError\", id, result });\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"error response\", \"SERVER_ERROR\", { request, response, info: { result } });\r\n            }\r\n            this.emit(\"debug\", { action: \"receiveRequest\", id, result });\r\n            return result.result;\r\n        }\r\n    }\r\n    /**\r\n     *  Returns %%transaction%% normalized for the Etherscan API.\r\n     */\r\n    _getTransactionPostData(transaction) {\r\n        const result = {};\r\n        for (let key in transaction) {\r\n            if (skipKeys.indexOf(key) >= 0) {\r\n                continue;\r\n            }\r\n            if (transaction[key] == null) {\r\n                continue;\r\n            }\r\n            let value = transaction[key];\r\n            if (key === \"type\" && value === 0) {\r\n                continue;\r\n            }\r\n            if (key === \"blockTag\" && value === \"latest\") {\r\n                continue;\r\n            }\r\n            // Quantity-types require no leading zero, unless 0\r\n            if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {\r\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toQuantity)(value);\r\n            }\r\n            else if (key === \"accessList\") {\r\n                value = \"[\" + (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_5__.accessListify)(value).map((set) => {\r\n                    return `{address:\"${set.address}\",storageKeys:[\"${set.storageKeys.join('\",\"')}\"]}`;\r\n                }).join(\",\") + \"]\";\r\n            }\r\n            else if (key === \"blobVersionedHashes\") {\r\n                if (value.length === 0) {\r\n                    continue;\r\n                }\r\n                // @TODO: update this once the API supports blobs\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"Etherscan API does not support blobVersionedHashes\", \"UNSUPPORTED_OPERATION\", {\r\n                    operation: \"_getTransactionPostData\",\r\n                    info: { transaction }\r\n                });\r\n            }\r\n            else {\r\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(value);\r\n            }\r\n            result[key] = value;\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     *  Throws the normalized Etherscan error.\r\n     */\r\n    _checkError(req, error, transaction) {\r\n        // Pull any message out if, possible\r\n        let message = \"\";\r\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isError)(error, \"SERVER_ERROR\")) {\r\n            // Check for an error emitted by a proxy call\r\n            try {\r\n                message = error.info.result.error.message;\r\n            }\r\n            catch (e) { }\r\n            if (!message) {\r\n                try {\r\n                    message = error.info.message;\r\n                }\r\n                catch (e) { }\r\n            }\r\n        }\r\n        if (req.method === \"estimateGas\") {\r\n            if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\r\n                    transaction: req.transaction\r\n                });\r\n            }\r\n        }\r\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\r\n            if (message.match(/execution reverted/i)) {\r\n                let data = \"\";\r\n                try {\r\n                    data = error.info.result.error.data;\r\n                }\r\n                catch (error) { }\r\n                const e = _abi_index_js__WEBPACK_IMPORTED_MODULE_6__.AbiCoder.getBuiltinCallException(req.method, req.transaction, data);\r\n                e.info = { request: req, error };\r\n                throw e;\r\n            }\r\n        }\r\n        if (message) {\r\n            if (req.method === \"broadcastTransaction\") {\r\n                const transaction = _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__.Transaction.from(req.signedTransaction);\r\n                if (message.match(/replacement/i) && message.match(/underpriced/i)) {\r\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", {\r\n                        transaction\r\n                    });\r\n                }\r\n                if (message.match(/insufficient funds/)) {\r\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\r\n                        transaction\r\n                    });\r\n                }\r\n                if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\r\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"nonce has already been used\", \"NONCE_EXPIRED\", {\r\n                        transaction\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        // Something we could not process\r\n        throw error;\r\n    }\r\n    async _detectNetwork() {\r\n        return this.network;\r\n    }\r\n    async _perform(req) {\r\n        switch (req.method) {\r\n            case \"chainId\":\r\n                return this.network.chainId;\r\n            case \"getBlockNumber\":\r\n                return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\r\n            case \"getGasPrice\":\r\n                return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\r\n            case \"getPriorityFee\":\r\n                // This is temporary until Etherscan completes support\r\n                if (this.network.name === \"mainnet\") {\r\n                    return \"1000000000\";\r\n                }\r\n                else if (this.network.name === \"optimism\") {\r\n                    return \"1000000\";\r\n                }\r\n                else {\r\n                    throw new Error(\"fallback onto the AbstractProvider default\");\r\n                }\r\n            /* Working with Etherscan to get this added:\r\n            try {\r\n                const test = await this.fetch(\"proxy\", {\r\n                    action: \"eth_maxPriorityFeePerGas\"\r\n                });\r\n                console.log(test);\r\n                return test;\r\n            } catch (e) {\r\n                console.log(\"DEBUG\", e);\r\n                throw e;\r\n            }\r\n            */\r\n            /* This might be safe; but due to rounding neither myself\r\n               or Etherscan are necessarily comfortable with this. :)\r\n            try {\r\n                const result = await this.fetch(\"gastracker\", { action: \"gasoracle\" });\r\n                console.log(result);\r\n                const gasPrice = parseUnits(result.SafeGasPrice, \"gwei\");\r\n                const baseFee = parseUnits(result.suggestBaseFee, \"gwei\");\r\n                const priorityFee = gasPrice - baseFee;\r\n                if (priorityFee < 0) { throw new Error(\"negative priority fee; defer to abstract provider default\"); }\r\n                return priorityFee;\r\n            } catch (error) {\r\n                console.log(\"DEBUG\", error);\r\n                throw error;\r\n            }\r\n            */\r\n            case \"getBalance\":\r\n                // Returns base-10 result\r\n                return this.fetch(\"account\", {\r\n                    action: \"balance\",\r\n                    address: req.address,\r\n                    tag: req.blockTag\r\n                });\r\n            case \"getTransactionCount\":\r\n                return this.fetch(\"proxy\", {\r\n                    action: \"eth_getTransactionCount\",\r\n                    address: req.address,\r\n                    tag: req.blockTag\r\n                });\r\n            case \"getCode\":\r\n                return this.fetch(\"proxy\", {\r\n                    action: \"eth_getCode\",\r\n                    address: req.address,\r\n                    tag: req.blockTag\r\n                });\r\n            case \"getStorage\":\r\n                return this.fetch(\"proxy\", {\r\n                    action: \"eth_getStorageAt\",\r\n                    address: req.address,\r\n                    position: req.position,\r\n                    tag: req.blockTag\r\n                });\r\n            case \"broadcastTransaction\":\r\n                return this.fetch(\"proxy\", {\r\n                    action: \"eth_sendRawTransaction\",\r\n                    hex: req.signedTransaction\r\n                }, true).catch((error) => {\r\n                    return this._checkError(req, error, req.signedTransaction);\r\n                });\r\n            case \"getBlock\":\r\n                if (\"blockTag\" in req) {\r\n                    return this.fetch(\"proxy\", {\r\n                        action: \"eth_getBlockByNumber\",\r\n                        tag: req.blockTag,\r\n                        boolean: (req.includeTransactions ? \"true\" : \"false\")\r\n                    });\r\n                }\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"getBlock by blockHash not supported by Etherscan\", \"UNSUPPORTED_OPERATION\", {\r\n                    operation: \"getBlock(blockHash)\"\r\n                });\r\n            case \"getTransaction\":\r\n                return this.fetch(\"proxy\", {\r\n                    action: \"eth_getTransactionByHash\",\r\n                    txhash: req.hash\r\n                });\r\n            case \"getTransactionReceipt\":\r\n                return this.fetch(\"proxy\", {\r\n                    action: \"eth_getTransactionReceipt\",\r\n                    txhash: req.hash\r\n                });\r\n            case \"call\": {\r\n                if (req.blockTag !== \"latest\") {\r\n                    throw new Error(\"EtherscanProvider does not support blockTag for call\");\r\n                }\r\n                const postData = this._getTransactionPostData(req.transaction);\r\n                postData.module = \"proxy\";\r\n                postData.action = \"eth_call\";\r\n                try {\r\n                    return await this.fetch(\"proxy\", postData, true);\r\n                }\r\n                catch (error) {\r\n                    return this._checkError(req, error, req.transaction);\r\n                }\r\n            }\r\n            case \"estimateGas\": {\r\n                const postData = this._getTransactionPostData(req.transaction);\r\n                postData.module = \"proxy\";\r\n                postData.action = \"eth_estimateGas\";\r\n                try {\r\n                    return await this.fetch(\"proxy\", postData, true);\r\n                }\r\n                catch (error) {\r\n                    return this._checkError(req, error, req.transaction);\r\n                }\r\n            }\r\n            /*\r\n                        case \"getLogs\": {\r\n                            // Needs to complain if more than one address is passed in\r\n                            const args: Record<string, any> = { action: \"getLogs\" }\r\n            \r\n                            if (params.filter.fromBlock) {\r\n                                args.fromBlock = checkLogTag(params.filter.fromBlock);\r\n                            }\r\n            \r\n                            if (params.filter.toBlock) {\r\n                                args.toBlock = checkLogTag(params.filter.toBlock);\r\n                            }\r\n            \r\n                            if (params.filter.address) {\r\n                                args.address = params.filter.address;\r\n                            }\r\n            \r\n                            // @TODO: We can handle slightly more complicated logs using the logs API\r\n                            if (params.filter.topics && params.filter.topics.length > 0) {\r\n                                if (params.filter.topics.length > 1) {\r\n                                    logger.throwError(\"unsupported topic count\", Logger.Errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\r\n                                }\r\n                                if (params.filter.topics.length === 1) {\r\n                                    const topic0 = params.filter.topics[0];\r\n                                    if (typeof(topic0) !== \"string\" || topic0.length !== 66) {\r\n                                        logger.throwError(\"unsupported topic format\", Logger.Errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\r\n                                    }\r\n                                    args.topic0 = topic0;\r\n                                }\r\n                            }\r\n            \r\n                            const logs: Array<any> = await this.fetch(\"logs\", args);\r\n            \r\n                            // Cache txHash => blockHash\r\n                            let blocks: { [tag: string]: string } = {};\r\n            \r\n                            // Add any missing blockHash to the logs\r\n                            for (let i = 0; i < logs.length; i++) {\r\n                                const log = logs[i];\r\n                                if (log.blockHash != null) { continue; }\r\n                                if (blocks[log.blockNumber] == null) {\r\n                                    const block = await this.getBlock(log.blockNumber);\r\n                                    if (block) {\r\n                                        blocks[log.blockNumber] = block.hash;\r\n                                    }\r\n                                }\r\n            \r\n                                log.blockHash = blocks[log.blockNumber];\r\n                            }\r\n            \r\n                            return logs;\r\n                        }\r\n            */\r\n            default:\r\n                break;\r\n        }\r\n        return super._perform(req);\r\n    }\r\n    async getNetwork() {\r\n        return this.network;\r\n    }\r\n    /**\r\n     *  Resolves to the current price of ether.\r\n     *\r\n     *  This returns ``0`` on any network other than ``mainnet``.\r\n     */\r\n    async getEtherPrice() {\r\n        if (this.network.name !== \"mainnet\") {\r\n            return 0.0;\r\n        }\r\n        return parseFloat((await this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\r\n    }\r\n    /**\r\n     *  Resolves to a [Contract]] for %%address%%, using the\r\n     *  Etherscan API to retreive the Contract ABI.\r\n     */\r\n    async getContract(_address) {\r\n        let address = this._getAddress(_address);\r\n        if (isPromise(address)) {\r\n            address = await address;\r\n        }\r\n        try {\r\n            const resp = await this.fetch(\"contract\", {\r\n                action: \"getabi\", address\r\n            });\r\n            const abi = JSON.parse(resp);\r\n            return new _contract_index_js__WEBPACK_IMPORTED_MODULE_7__.Contract(address, abi, this);\r\n        }\r\n        catch (error) {\r\n            return null;\r\n        }\r\n    }\r\n    isCommunityResource() {\r\n        return (this.apiKey == null);\r\n    }\r\n}\r\n//# sourceMappingURL=provider-etherscan.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItZXRoZXJzY2FuLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMyQztBQUNLO0FBQ3FCO0FBRzdCO0FBQ2tCO0FBQ25CO0FBQ2M7QUFDQTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sOEJBQThCLDhEQUFhO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0IsU0FBUyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQ0FBZ0MsbUVBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnREFBTztBQUMvQjtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixJQUFJLEdBQUcsTUFBTTtBQUMxQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQSwyREFBMkQscUJBQXFCLFVBQVUsT0FBTyxFQUFFLE1BQU07QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxxQkFBcUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0RBQWtEO0FBQy9FLDRCQUE0Qix5REFBWTtBQUN4QyxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELDZEQUFZO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGtFQUFrRTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlFQUF5RTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEYsOERBQThELEVBQUUsR0FBRyxXQUFXO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1REFBdUQ7QUFDeEYsWUFBWSx1REFBTSw0Q0FBNEMsbUJBQW1CO0FBQ2pGO0FBQ0E7QUFDQSxpQ0FBaUMsd0VBQXdFO0FBQ3pHLFlBQVksdURBQU0sOENBQThDLG1CQUFtQjtBQUNuRjtBQUNBLGtDQUFrQyw2REFBWTtBQUM5QztBQUNBO0FBQ0EscUNBQXFDLGdFQUFnRTtBQUNyRyxnQkFBZ0IsdURBQU0sK0VBQStFLDJCQUEyQixVQUFVO0FBQzFJO0FBQ0E7QUFDQSxxQ0FBcUMsOERBQThEO0FBQ25HLGdCQUFnQix1REFBTSw0Q0FBNEMsMkJBQTJCLFVBQVU7QUFDdkc7QUFDQSxpQ0FBaUMsc0NBQXNDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0NBQXNDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxvQ0FBb0M7QUFDekUsZ0JBQWdCLHVEQUFNLDRDQUE0QywyQkFBMkIsVUFBVTtBQUN2RztBQUNBLGlDQUFpQyxzQ0FBc0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxSEFBcUg7QUFDdkksd0JBQXdCLDJEQUFVO0FBQ2xDO0FBQ0E7QUFDQSw4QkFBOEIsb0VBQWE7QUFDM0MsNkJBQTZCLFdBQVcsWUFBWSxrQkFBa0IsNEJBQTRCLEdBQUc7QUFDckcsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1REFBTTtBQUN0QjtBQUNBLDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHdCQUF3Qix3REFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVEQUFNO0FBQ3RCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtREFBUTtBQUNsQywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw4REFBVztBQUMvQztBQUNBLG9CQUFvQix1REFBTTtBQUMxQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esb0JBQW9CLHVEQUFNO0FBQzFCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxvQkFBb0IsdURBQU07QUFDMUI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywyQkFBMkI7QUFDeEU7QUFDQSw2Q0FBNkMsd0JBQXdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxnRUFBZ0UscUJBQXFCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHdDQUF3QztBQUMvRTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGdCQUFnQix1REFBTTtBQUN0QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SCw4QkFBOEI7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SEFBNkgsZ0JBQWdCO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0JBQXdCO0FBQ2xFO0FBQ0E7QUFDQSw0Q0FBNEMsaUJBQWlCO0FBQzdEO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxvQkFBb0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1QkFBdUIsd0RBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxccHJvdmlkZXJzXFxwcm92aWRlci1ldGhlcnNjYW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqICBbW2xpbmstZXRoZXJzY2FuXV0gcHJvdmlkZXMgYSB0aGlyZC1wYXJ0eSBzZXJ2aWNlIGZvciBjb25uZWN0aW5nIHRvXHJcbiAqICB2YXJpb3VzIGJsb2NrY2hhaW5zIG92ZXIgYSBjb21iaW5hdGlvbiBvZiBKU09OLVJQQyBhbmQgY3VzdG9tIEFQSVxyXG4gKiAgZW5kcG9pbnRzLlxyXG4gKlxyXG4gKiAgKipTdXBwb3J0ZWQgTmV0d29ya3MqKlxyXG4gKlxyXG4gKiAgLSBFdGhlcmV1bSBNYWlubmV0IChgYG1haW5uZXRgYClcclxuICogIC0gR29lcmxpIFRlc3RuZXQgKGBgZ29lcmxpYGApXHJcbiAqICAtIFNlcG9saWEgVGVzdG5ldCAoYGBzZXBvbGlhYGApXHJcbiAqICAtIEhvbGVza3kgVGVzdG5ldCAoYGBob2xlc2t5YGApXHJcbiAqICAtIEFyYml0cnVtIChgYGFyYml0cnVtYGApXHJcbiAqICAtIEFyYml0cnVtIEdvZXJsaSBUZXN0bmV0IChgYGFyYml0cnVtLWdvZXJsaWBgKVxyXG4gKiAgLSBCYXNlIChgYGJhc2VgYClcclxuICogIC0gQmFzZSBTZXBvbGlhIFRlc3RuZXQgKGBgYmFzZS1zZXBvbGlhYGApXHJcbiAqICAtIEJOQiBTbWFydCBDaGFpbiBNYWlubmV0IChgYGJuYmBgKVxyXG4gKiAgLSBCTkIgU21hcnQgQ2hhaW4gVGVzdG5ldCAoYGBibmJ0YGApXHJcbiAqICAtIE9wdGltaXNtIChgYG9wdGltaXNtYGApXHJcbiAqICAtIE9wdGltaXNtIEdvZXJsaSBUZXN0bmV0IChgYG9wdGltaXNtLWdvZXJsaWBgKVxyXG4gKiAgLSBQb2x5Z29uIChgYG1hdGljYGApXHJcbiAqICAtIFBvbHlnb24gTXVtYmFpIFRlc3RuZXQgKGBgbWF0aWMtbXVtYmFpYGApXHJcbiAqICAtIFBvbHlnb24gQW1veSBUZXN0bmV0IChgYG1hdGljLWFtb3lgYClcclxuICpcclxuICogIEBfc3Vic2VjdGlvbiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHk6RXRoZXJzY2FuICBbcHJvdmlkZXJzLWV0aGVyc2Nhbl1cclxuICovXHJcbmltcG9ydCB7IEFiaUNvZGVyIH0gZnJvbSBcIi4uL2FiaS9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBDb250cmFjdCB9IGZyb20gXCIuLi9jb250cmFjdC9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5LCBUcmFuc2FjdGlvbiB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBoZXhsaWZ5LCB0b1F1YW50aXR5LCBGZXRjaFJlcXVlc3QsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGlzRXJyb3IsIFxyXG4vLyAgICBwYXJzZVVuaXRzLFxyXG50b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgQWJzdHJhY3RQcm92aWRlciB9IGZyb20gXCIuL2Fic3RyYWN0LXByb3ZpZGVyLmpzXCI7XHJcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XHJcbmltcG9ydCB7IE5ldHdvcmtQbHVnaW4gfSBmcm9tIFwiLi9wbHVnaW5zLW5ldHdvcmsuanNcIjtcclxuaW1wb3J0IHsgc2hvd1Rocm90dGxlTWVzc2FnZSB9IGZyb20gXCIuL2NvbW11bml0eS5qc1wiO1xyXG5jb25zdCBUSFJPVFRMRSA9IDIwMDA7XHJcbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnRoZW4pID09PSBcImZ1bmN0aW9uXCIpO1xyXG59XHJcbmNvbnN0IEV0aGVyc2NhblBsdWdpbklkID0gXCJvcmcuZXRoZXJzLnBsdWdpbnMucHJvdmlkZXIuRXRoZXJzY2FuXCI7XHJcbi8qKlxyXG4gKiAgQSBOZXR3b3JrIGNhbiBpbmNsdWRlIGFuICoqRXRoZXJzY2FuUGx1Z2luKiogdG8gcHJvdmlkZVxyXG4gKiAgYSBjdXN0b20gYmFzZSBVUkwuXHJcbiAqXHJcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy90aGlyZHBhcnR5OkV0aGVyc2NhblxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEV0aGVyc2NhblBsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIEV0aGVyc2NhbiBBUEkgYmFzZSBVUkwuXHJcbiAgICAgKi9cclxuICAgIGJhc2VVcmw7XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRXRoZXJzY2FuUHJvdmlkZXIqKiB3aGljaCB3aWxsIHVzZVxyXG4gICAgICogICUlYmFzZVVybCUlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihiYXNlVXJsKSB7XHJcbiAgICAgICAgc3VwZXIoRXRoZXJzY2FuUGx1Z2luSWQpO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBiYXNlVXJsIH0pO1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdGhlcnNjYW5QbHVnaW4odGhpcy5iYXNlVXJsKTtcclxuICAgIH1cclxufVxyXG5jb25zdCBza2lwS2V5cyA9IFtcImVuYWJsZUNjaXBSZWFkXCJdO1xyXG5sZXQgbmV4dElkID0gMTtcclxuLyoqXHJcbiAqICBUaGUgKipFdGhlcnNjYW5CYXNlUHJvdmlkZXIqKiBpcyB0aGUgc3VwZXItY2xhc3Mgb2ZcclxuICogIFtbRXRoZXJzY2FuUHJvdmlkZXJdXSwgd2hpY2ggc2hvdWxkIGdlbmVyYWxseSBiZSB1c2VkIGluc3RlYWQuXHJcbiAqXHJcbiAqICBTaW5jZSB0aGUgKipFdGhlcnNjYW5Qcm92aWRlcioqIGluY2x1ZGVzIGFkZGl0aW9uYWwgY29kZSBmb3JcclxuICogIFtbQ29udHJhY3RdXSBhY2Nlc3MsIGluIC8vcmFyZSBjYXNlcy8vIHRoYXQgY29udHJhY3RzIGFyZSBub3RcclxuICogIHVzZWQsIHRoaXMgY2xhc3MgY2FuIHJlZHVjZSBjb2RlIHNpemUuXHJcbiAqXHJcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy90aGlyZHBhcnR5OkV0aGVyc2NhblxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEV0aGVyc2NhblByb3ZpZGVyIGV4dGVuZHMgQWJzdHJhY3RQcm92aWRlciB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgY29ubmVjdGVkIG5ldHdvcmsuXHJcbiAgICAgKi9cclxuICAgIG5ldHdvcms7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgQVBJIGtleSBvciBudWxsIGlmIHVzaW5nIHRoZSBjb21tdW5pdHkgcHJvdmlkZWQgYmFuZHdpZHRoLlxyXG4gICAgICovXHJcbiAgICBhcGlLZXk7XHJcbiAgICAjcGx1Z2luO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkV0aGVyc2NhbkJhc2VQcm92aWRlcioqLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihfbmV0d29yaywgX2FwaUtleSkge1xyXG4gICAgICAgIGNvbnN0IGFwaUtleSA9IChfYXBpS2V5ICE9IG51bGwpID8gX2FwaUtleSA6IG51bGw7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICBjb25zdCBuZXR3b3JrID0gTmV0d29yay5mcm9tKF9uZXR3b3JrKTtcclxuICAgICAgICB0aGlzLiNwbHVnaW4gPSBuZXR3b3JrLmdldFBsdWdpbihFdGhlcnNjYW5QbHVnaW5JZCk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFwaUtleSwgbmV0d29yayB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIGJhc2UgVVJMLlxyXG4gICAgICpcclxuICAgICAqICBJZiBhbiBbW0V0aGVyc2NhblBsdWdpbl1dIGlzIGNvbmZpZ3VyZWQgb24gdGhlXHJcbiAgICAgKiAgW1tFdGhlcnNjYW5CYXNlUHJvdmlkZXJfbmV0d29ya11dLCByZXR1cm5zIHRoZSBwbHVnaW4nc1xyXG4gICAgICogIGJhc2VVcmwuXHJcbiAgICAgKlxyXG4gICAgICogIERlcHJlY2F0ZWQ7IGZvciBFdGhlcnNjYW4gdjIgdGhlIGJhc2UgaXMgbm8gbG9uZ2VyIGEgc2ltcGx5XHJcbiAgICAgKiAgaG9zdCwgYnV0IGluc3RlYWQgYSBVUkwgaW5jbHVkaW5nIGEgY2hhaW5JZCBwYXJhbWV0ZXIuIENoYW5naW5nXHJcbiAgICAgKiAgdGhpcyB0byByZXR1cm4gYSBVUkwgcHJlZml4IGNvdWxkIGJyZWFrIHNvbWUgbGlicmFyaWVzLCBzbyBpdFxyXG4gICAgICogIGlzIGxlZnQgaW50YWN0IGJ1dCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZSBhcyBpdCBpcyB1bnVzZWQuXHJcbiAgICAgKi9cclxuICAgIGdldEJhc2VVcmwoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuI3BsdWdpbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcGx1Z2luLmJhc2VVcmw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAodGhpcy5uZXR3b3JrLm5hbWUpIHtcclxuICAgICAgICAgICAgY2FzZSBcIm1haW5uZXRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGkuZXRoZXJzY2FuLmlvXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJnb2VybGlcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktZ29lcmxpLmV0aGVyc2Nhbi5pb1wiO1xyXG4gICAgICAgICAgICBjYXNlIFwic2Vwb2xpYVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS1zZXBvbGlhLmV0aGVyc2Nhbi5pb1wiO1xyXG4gICAgICAgICAgICBjYXNlIFwiaG9sZXNreVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS1ob2xlc2t5LmV0aGVyc2Nhbi5pb1wiO1xyXG4gICAgICAgICAgICBjYXNlIFwiYXJiaXRydW1cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGkuYXJiaXNjYW4uaW9cIjtcclxuICAgICAgICAgICAgY2FzZSBcImFyYml0cnVtLWdvZXJsaVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS1nb2VybGkuYXJiaXNjYW4uaW9cIjtcclxuICAgICAgICAgICAgY2FzZSBcImJhc2VcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGkuYmFzZXNjYW4ub3JnXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJiYXNlLXNlcG9saWFcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktc2Vwb2xpYS5iYXNlc2Nhbi5vcmdcIjtcclxuICAgICAgICAgICAgY2FzZSBcImJuYlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS5ic2NzY2FuLmNvbVwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiYm5idFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS10ZXN0bmV0LmJzY3NjYW4uY29tXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJtYXRpY1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS5wb2x5Z29uc2Nhbi5jb21cIjtcclxuICAgICAgICAgICAgY2FzZSBcIm1hdGljLWFtb3lcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktYW1veS5wb2x5Z29uc2Nhbi5jb21cIjtcclxuICAgICAgICAgICAgY2FzZSBcIm1hdGljLW11bWJhaVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS10ZXN0bmV0LnBvbHlnb25zY2FuLmNvbVwiO1xyXG4gICAgICAgICAgICBjYXNlIFwib3B0aW1pc21cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktb3B0aW1pc3RpYy5ldGhlcnNjYW4uaW9cIjtcclxuICAgICAgICAgICAgY2FzZSBcIm9wdGltaXNtLWdvZXJsaVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS1nb2VybGktb3B0aW1pc3RpYy5ldGhlcnNjYW4uaW9cIjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgdGhpcy5uZXR3b3JrKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIFVSTCBmb3IgdGhlICUlbW9kdWxlJSUgYW5kICUlcGFyYW1zJSUuXHJcbiAgICAgKi9cclxuICAgIGdldFVybChtb2R1bGUsIHBhcmFtcykge1xyXG4gICAgICAgIGxldCBxdWVyeSA9IE9iamVjdC5rZXlzKHBhcmFtcykucmVkdWNlKChhY2N1bSwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zW2tleV07XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBhY2N1bSArPSBgJiR7a2V5fT0ke3ZhbHVlfWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xyXG4gICAgICAgIH0sIFwiXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLmFwaUtleSkge1xyXG4gICAgICAgICAgICBxdWVyeSArPSBgJmFwaWtleT0ke3RoaXMuYXBpS2V5fWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBgaHR0cHM6L1xcL2FwaS5ldGhlcnNjYW4uaW8vdjIvYXBpP2NoYWluaWQ9JHt0aGlzLm5ldHdvcmsuY2hhaW5JZH0mbW9kdWxlPSR7bW9kdWxlfSR7cXVlcnl9YDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIFVSTCBmb3IgdXNpbmcgUE9TVCByZXF1ZXN0cy5cclxuICAgICAqL1xyXG4gICAgZ2V0UG9zdFVybCgpIHtcclxuICAgICAgICByZXR1cm4gYGh0dHBzOi9cXC9hcGkuZXRoZXJzY2FuLmlvL3YyL2FwaT9jaGFpbmlkPSR7dGhpcy5uZXR3b3JrLmNoYWluSWR9YDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIHBhcmFtZXRlcnMgZm9yIHVzaW5nIFBPU1QgcmVxdWVzdHMuXHJcbiAgICAgKi9cclxuICAgIGdldFBvc3REYXRhKG1vZHVsZSwgcGFyYW1zKSB7XHJcbiAgICAgICAgcGFyYW1zLm1vZHVsZSA9IG1vZHVsZTtcclxuICAgICAgICBwYXJhbXMuYXBpa2V5ID0gdGhpcy5hcGlLZXk7XHJcbiAgICAgICAgcGFyYW1zLmNoYWluaWQgPSB0aGlzLm5ldHdvcmsuY2hhaW5JZDtcclxuICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZGV0ZWN0TmV0d29yaygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5uZXR3b3JrO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHJlc3VsdCBvZiBjYWxsaW5nICUlbW9kdWxlJSUgd2l0aCAlJXBhcmFtcyUlLlxyXG4gICAgICpcclxuICAgICAqICBJZiAlJXBvc3QlJSwgdGhlIHJlcXVlc3QgaXMgbWFkZSBhcyBhIFBPU1QgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZmV0Y2gobW9kdWxlLCBwYXJhbXMsIHBvc3QpIHtcclxuICAgICAgICBjb25zdCBpZCA9IG5leHRJZCsrO1xyXG4gICAgICAgIGNvbnN0IHVybCA9IChwb3N0ID8gdGhpcy5nZXRQb3N0VXJsKCkgOiB0aGlzLmdldFVybChtb2R1bGUsIHBhcmFtcykpO1xyXG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSAocG9zdCA/IHRoaXMuZ2V0UG9zdERhdGEobW9kdWxlLCBwYXJhbXMpIDogbnVsbCk7XHJcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZFJlcXVlc3RcIiwgaWQsIHVybCwgcGF5bG9hZDogcGF5bG9hZCB9KTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IEZldGNoUmVxdWVzdCh1cmwpO1xyXG4gICAgICAgIHJlcXVlc3Quc2V0VGhyb3R0bGVQYXJhbXMoeyBzbG90SW50ZXJ2YWw6IDEwMDAgfSk7XHJcbiAgICAgICAgcmVxdWVzdC5yZXRyeUZ1bmMgPSAocmVxLCByZXNwLCBhdHRlbXB0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tbXVuaXR5UmVzb3VyY2UoKSkge1xyXG4gICAgICAgICAgICAgICAgc2hvd1Rocm90dGxlTWVzc2FnZShcIkV0aGVyc2NhblwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmVxdWVzdC5wcm9jZXNzRnVuYyA9IGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXNwb25zZS5oYXNCb2R5KCkgPyBKU09OLnBhcnNlKHRvVXRmOFN0cmluZyhyZXNwb25zZS5ib2R5KSkgOiB7fTtcclxuICAgICAgICAgICAgY29uc3QgdGhyb3R0bGUgPSAoKHR5cGVvZiAocmVzdWx0LnJlc3VsdCkgPT09IFwic3RyaW5nXCIpID8gcmVzdWx0LnJlc3VsdCA6IFwiXCIpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcInJhdGUgbGltaXRcIikgPj0gMDtcclxuICAgICAgICAgICAgaWYgKG1vZHVsZSA9PT0gXCJwcm94eVwiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIEpTT04gcmVzcG9uc2UgaW5kaWNhdGVzIHdlIGFyZSBiZWluZyB0aHJvdHRsZWRcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnN0YXR1cyA9PSAwICYmIHJlc3VsdC5tZXNzYWdlID09IFwiTk9UT0tcIiAmJiB0aHJvdHRsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFcnJvclwiLCBpZCwgcmVhc29uOiBcInByb3h5LU5PVE9LXCIsIGVycm9yOiByZXN1bHQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UudGhyb3dUaHJvdHRsZUVycm9yKHJlc3VsdC5yZXN1bHQsIFRIUk9UVExFKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aHJvdHRsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFcnJvclwiLCBpZCwgcmVhc29uOiBcIm51bGwgcmVzdWx0XCIsIGVycm9yOiByZXN1bHQucmVzdWx0IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnRocm93VGhyb3R0bGVFcnJvcihyZXN1bHQucmVzdWx0LCBUSFJPVFRMRSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHBheWxvYWQpIHtcclxuICAgICAgICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoXCJjb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIik7XHJcbiAgICAgICAgICAgIHJlcXVlc3QuYm9keSA9IE9iamVjdC5rZXlzKHBheWxvYWQpLm1hcCgoaykgPT4gYCR7a309JHtwYXlsb2FkW2tdfWApLmpvaW4oXCImXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3Quc2VuZCgpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3BvbnNlLmFzc2VydE9rKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlRXJyb3JcIiwgaWQsIGVycm9yLCByZWFzb246IFwiYXNzZXJ0T2tcIiB9KTtcclxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInJlc3BvbnNlIGVycm9yXCIsIFwiU0VSVkVSX0VSUk9SXCIsIHsgcmVxdWVzdCwgcmVzcG9uc2UgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcmVzcG9uc2UuaGFzQm9keSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFcnJvclwiLCBpZCwgZXJyb3I6IFwibWlzc2luZyBib2R5XCIsIHJlYXNvbjogXCJudWxsIGJvZHlcIiB9KTtcclxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcIm1pc3NpbmcgcmVzcG9uc2VcIiwgXCJTRVJWRVJfRVJST1JcIiwgeyByZXF1ZXN0LCByZXNwb25zZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZSh0b1V0ZjhTdHJpbmcocmVzcG9uc2UuYm9keSkpO1xyXG4gICAgICAgIGlmIChtb2R1bGUgPT09IFwicHJveHlcIikge1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0Lmpzb25ycGMgIT0gXCIyLjBcIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUVycm9yXCIsIGlkLCByZXN1bHQsIHJlYXNvbjogXCJpbnZhbGlkIEpTT04tUlBDXCIgfSk7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwiaW52YWxpZCBKU09OLVJQQyByZXNwb25zZSAobWlzc2luZyBqc29ucnBjPScyLjAnKVwiLCBcIlNFUlZFUl9FUlJPUlwiLCB7IHJlcXVlc3QsIHJlc3BvbnNlLCBpbmZvOiB7IHJlc3VsdCB9IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFcnJvclwiLCBpZCwgcmVzdWx0LCByZWFzb246IFwiSlNPTi1SUEMgZXJyb3JcIiB9KTtcclxuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJlcnJvciByZXNwb25zZVwiLCBcIlNFUlZFUl9FUlJPUlwiLCB7IHJlcXVlc3QsIHJlc3BvbnNlLCBpbmZvOiB7IHJlc3VsdCB9IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVSZXF1ZXN0XCIsIGlkLCByZXN1bHQgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZ2V0TG9ncywgZ2V0SGlzdG9yeSBoYXZlIHdlaXJkIHN1Y2Nlc3MgcmVzcG9uc2VzXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09IDAgJiYgKHJlc3VsdC5tZXNzYWdlID09PSBcIk5vIHJlY29yZHMgZm91bmRcIiB8fCByZXN1bHQubWVzc2FnZSA9PT0gXCJObyB0cmFuc2FjdGlvbnMgZm91bmRcIikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVSZXF1ZXN0XCIsIGlkLCByZXN1bHQgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPSAxIHx8ICh0eXBlb2YgKHJlc3VsdC5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiAhcmVzdWx0Lm1lc3NhZ2UubWF0Y2goL15PSy8pKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUVycm9yXCIsIGlkLCByZXN1bHQgfSk7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwiZXJyb3IgcmVzcG9uc2VcIiwgXCJTRVJWRVJfRVJST1JcIiwgeyByZXF1ZXN0LCByZXNwb25zZSwgaW5mbzogeyByZXN1bHQgfSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUmVxdWVzdFwiLCBpZCwgcmVzdWx0IH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zICUldHJhbnNhY3Rpb24lJSBub3JtYWxpemVkIGZvciB0aGUgRXRoZXJzY2FuIEFQSS5cclxuICAgICAqL1xyXG4gICAgX2dldFRyYW5zYWN0aW9uUG9zdERhdGEodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdHJhbnNhY3Rpb24pIHtcclxuICAgICAgICAgICAgaWYgKHNraXBLZXlzLmluZGV4T2Yoa2V5KSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25ba2V5XSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0cmFuc2FjdGlvbltrZXldO1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcInR5cGVcIiAmJiB2YWx1ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJibG9ja1RhZ1wiICYmIHZhbHVlID09PSBcImxhdGVzdFwiKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBRdWFudGl0eS10eXBlcyByZXF1aXJlIG5vIGxlYWRpbmcgemVybywgdW5sZXNzIDBcclxuICAgICAgICAgICAgaWYgKHsgdHlwZTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBtYXhGZWVQZXJHczogdHJ1ZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRydWUsIG5vbmNlOiB0cnVlLCB2YWx1ZTogdHJ1ZSB9W2tleV0pIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9RdWFudGl0eSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImFjY2Vzc0xpc3RcIikge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIltcIiArIGFjY2Vzc0xpc3RpZnkodmFsdWUpLm1hcCgoc2V0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGB7YWRkcmVzczpcIiR7c2V0LmFkZHJlc3N9XCIsc3RvcmFnZUtleXM6W1wiJHtzZXQuc3RvcmFnZUtleXMuam9pbignXCIsXCInKX1cIl19YDtcclxuICAgICAgICAgICAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCJdXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImJsb2JWZXJzaW9uZWRIYXNoZXNcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQFRPRE86IHVwZGF0ZSB0aGlzIG9uY2UgdGhlIEFQSSBzdXBwb3J0cyBibG9ic1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcIkV0aGVyc2NhbiBBUEkgZG9lcyBub3Qgc3VwcG9ydCBibG9iVmVyc2lvbmVkSGFzaGVzXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiX2dldFRyYW5zYWN0aW9uUG9zdERhdGFcIixcclxuICAgICAgICAgICAgICAgICAgICBpbmZvOiB7IHRyYW5zYWN0aW9uIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBoZXhsaWZ5KHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhyb3dzIHRoZSBub3JtYWxpemVkIEV0aGVyc2NhbiBlcnJvci5cclxuICAgICAqL1xyXG4gICAgX2NoZWNrRXJyb3IocmVxLCBlcnJvciwgdHJhbnNhY3Rpb24pIHtcclxuICAgICAgICAvLyBQdWxsIGFueSBtZXNzYWdlIG91dCBpZiwgcG9zc2libGVcclxuICAgICAgICBsZXQgbWVzc2FnZSA9IFwiXCI7XHJcbiAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiU0VSVkVSX0VSUk9SXCIpKSB7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBhbiBlcnJvciBlbWl0dGVkIGJ5IGEgcHJveHkgY2FsbFxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLmluZm8ucmVzdWx0LmVycm9yLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLmluZm8ubWVzc2FnZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVxLm1ldGhvZCA9PT0gXCJlc3RpbWF0ZUdhc1wiKSB7XHJcbiAgICAgICAgICAgIGlmICghbWVzc2FnZS5tYXRjaCgvcmV2ZXJ0L2kpICYmIG1lc3NhZ2UubWF0Y2goL2luc3VmZmljaWVudCBmdW5kcy9pKSkge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImluc3VmZmljaWVudCBmdW5kc1wiLCBcIklOU1VGRklDSUVOVF9GVU5EU1wiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHJlcS50cmFuc2FjdGlvblxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlcS5tZXRob2QgPT09IFwiY2FsbFwiIHx8IHJlcS5tZXRob2QgPT09IFwiZXN0aW1hdGVHYXNcIikge1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvZXhlY3V0aW9uIHJldmVydGVkL2kpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBlcnJvci5pbmZvLnJlc3VsdC5lcnJvci5kYXRhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBBYmlDb2Rlci5nZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihyZXEubWV0aG9kLCByZXEudHJhbnNhY3Rpb24sIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgZS5pbmZvID0geyByZXF1ZXN0OiByZXEsIGVycm9yIH07XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXEubWV0aG9kID09PSBcImJyb2FkY2FzdFRyYW5zYWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb24uZnJvbShyZXEuc2lnbmVkVHJhbnNhY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL3JlcGxhY2VtZW50L2kpICYmIG1lc3NhZ2UubWF0Y2goL3VuZGVycHJpY2VkL2kpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIFwiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL2luc3VmZmljaWVudCBmdW5kcy8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImluc3VmZmljaWVudCBmdW5kcyBmb3IgaW50cmluc2ljIHRyYW5zYWN0aW9uIGNvc3RcIiwgXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL3NhbWUgaGFzaCB3YXMgYWxyZWFkeSBpbXBvcnRlZHx0cmFuc2FjdGlvbiBub25jZSBpcyB0b28gbG93fG5vbmNlIHRvbyBsb3cvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgXCJOT05DRV9FWFBJUkVEXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTb21ldGhpbmcgd2UgY291bGQgbm90IHByb2Nlc3NcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICAgIGFzeW5jIF9kZXRlY3ROZXR3b3JrKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5ldHdvcms7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfcGVyZm9ybShyZXEpIHtcclxuICAgICAgICBzd2l0Y2ggKHJlcS5tZXRob2QpIHtcclxuICAgICAgICAgICAgY2FzZSBcImNoYWluSWRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5ldHdvcmsuY2hhaW5JZDtcclxuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHsgYWN0aW9uOiBcImV0aF9ibG9ja051bWJlclwiIH0pO1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwgeyBhY3Rpb246IFwiZXRoX2dhc1ByaWNlXCIgfSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJnZXRQcmlvcml0eUZlZVwiOlxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0ZW1wb3JhcnkgdW50aWwgRXRoZXJzY2FuIGNvbXBsZXRlcyBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXR3b3JrLm5hbWUgPT09IFwibWFpbm5ldFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiMTAwMDAwMDAwMFwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXR3b3JrLm5hbWUgPT09IFwib3B0aW1pc21cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIjEwMDAwMDBcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZhbGxiYWNrIG9udG8gdGhlIEFic3RyYWN0UHJvdmlkZXIgZGVmYXVsdFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyogV29ya2luZyB3aXRoIEV0aGVyc2NhbiB0byBnZXQgdGhpcyBhZGRlZDpcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3QgPSBhd2FpdCB0aGlzLmZldGNoKFwicHJveHlcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfbWF4UHJpb3JpdHlGZWVQZXJHYXNcIlxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh0ZXN0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXN0O1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRFQlVHXCIsIGUpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAvKiBUaGlzIG1pZ2h0IGJlIHNhZmU7IGJ1dCBkdWUgdG8gcm91bmRpbmcgbmVpdGhlciBteXNlbGZcclxuICAgICAgICAgICAgICAgb3IgRXRoZXJzY2FuIGFyZSBuZWNlc3NhcmlseSBjb21mb3J0YWJsZSB3aXRoIHRoaXMuIDopXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmZldGNoKFwiZ2FzdHJhY2tlclwiLCB7IGFjdGlvbjogXCJnYXNvcmFjbGVcIiB9KTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBnYXNQcmljZSA9IHBhcnNlVW5pdHMocmVzdWx0LlNhZmVHYXNQcmljZSwgXCJnd2VpXCIpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUZlZSA9IHBhcnNlVW5pdHMocmVzdWx0LnN1Z2dlc3RCYXNlRmVlLCBcImd3ZWlcIik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmlvcml0eUZlZSA9IGdhc1ByaWNlIC0gYmFzZUZlZTtcclxuICAgICAgICAgICAgICAgIGlmIChwcmlvcml0eUZlZSA8IDApIHsgdGhyb3cgbmV3IEVycm9yKFwibmVnYXRpdmUgcHJpb3JpdHkgZmVlOyBkZWZlciB0byBhYnN0cmFjdCBwcm92aWRlciBkZWZhdWx0XCIpOyB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJpb3JpdHlGZWU7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRFQlVHXCIsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XHJcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm5zIGJhc2UtMTAgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcImFjY291bnRcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJiYWxhbmNlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcmVxLmFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgdGFnOiByZXEuYmxvY2tUYWdcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRUcmFuc2FjdGlvbkNvdW50XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcmVxLmFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgdGFnOiByZXEuYmxvY2tUYWdcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRDb2RlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcmVxLmFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgdGFnOiByZXEuYmxvY2tUYWdcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRTdG9yYWdlQXRcIixcclxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiByZXEuYWRkcmVzcyxcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcmVxLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhZzogcmVxLmJsb2NrVGFnXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY2FzZSBcImJyb2FkY2FzdFRyYW5zYWN0aW9uXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGhleDogcmVxLnNpZ25lZFRyYW5zYWN0aW9uXHJcbiAgICAgICAgICAgICAgICB9LCB0cnVlKS5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tFcnJvcihyZXEsIGVycm9yLCByZXEuc2lnbmVkVHJhbnNhY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOlxyXG4gICAgICAgICAgICAgICAgaWYgKFwiYmxvY2tUYWdcIiBpbiByZXEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRCbG9ja0J5TnVtYmVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogcmVxLmJsb2NrVGFnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib29sZWFuOiAocmVxLmluY2x1ZGVUcmFuc2FjdGlvbnMgPyBcInRydWVcIiA6IFwiZmFsc2VcIilcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJnZXRCbG9jayBieSBibG9ja0hhc2ggbm90IHN1cHBvcnRlZCBieSBFdGhlcnNjYW5cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRCbG9jayhibG9ja0hhc2gpXCJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIixcclxuICAgICAgICAgICAgICAgICAgICB0eGhhc2g6IHJlcS5oYXNoXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIixcclxuICAgICAgICAgICAgICAgICAgICB0eGhhc2g6IHJlcS5oYXNoXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY2FzZSBcImNhbGxcIjoge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcS5ibG9ja1RhZyAhPT0gXCJsYXRlc3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV0aGVyc2NhblByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgYmxvY2tUYWcgZm9yIGNhbGxcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb3N0RGF0YSA9IHRoaXMuX2dldFRyYW5zYWN0aW9uUG9zdERhdGEocmVxLnRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIHBvc3REYXRhLm1vZHVsZSA9IFwicHJveHlcIjtcclxuICAgICAgICAgICAgICAgIHBvc3REYXRhLmFjdGlvbiA9IFwiZXRoX2NhbGxcIjtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2goXCJwcm94eVwiLCBwb3N0RGF0YSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tFcnJvcihyZXEsIGVycm9yLCByZXEudHJhbnNhY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb3N0RGF0YSA9IHRoaXMuX2dldFRyYW5zYWN0aW9uUG9zdERhdGEocmVxLnRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIHBvc3REYXRhLm1vZHVsZSA9IFwicHJveHlcIjtcclxuICAgICAgICAgICAgICAgIHBvc3REYXRhLmFjdGlvbiA9IFwiZXRoX2VzdGltYXRlR2FzXCI7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoKFwicHJveHlcIiwgcG9zdERhdGEsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrRXJyb3IocmVxLCBlcnJvciwgcmVxLnRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkcyB0byBjb21wbGFpbiBpZiBtb3JlIHRoYW4gb25lIGFkZHJlc3MgaXMgcGFzc2VkIGluXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0geyBhY3Rpb246IFwiZ2V0TG9nc1wiIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci5mcm9tQmxvY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLmZyb21CbG9jayA9IGNoZWNrTG9nVGFnKHBhcmFtcy5maWx0ZXIuZnJvbUJsb2NrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b0Jsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy50b0Jsb2NrID0gY2hlY2tMb2dUYWcocGFyYW1zLmZpbHRlci50b0Jsb2NrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci5hZGRyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5hZGRyZXNzID0gcGFyYW1zLmZpbHRlci5hZGRyZXNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBXZSBjYW4gaGFuZGxlIHNsaWdodGx5IG1vcmUgY29tcGxpY2F0ZWQgbG9ncyB1c2luZyB0aGUgbG9ncyBBUElcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLnRvcGljcyAmJiBwYXJhbXMuZmlsdGVyLnRvcGljcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIudG9waWNzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCB0b3BpYyBjb3VudFwiLCBMb2dnZXIuRXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyB0b3BpY3M6IHBhcmFtcy5maWx0ZXIudG9waWNzIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvcGljMCA9IHBhcmFtcy5maWx0ZXIudG9waWNzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHRvcGljMCkgIT09IFwic3RyaW5nXCIgfHwgdG9waWMwLmxlbmd0aCAhPT0gNjYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgdG9waWMgZm9ybWF0XCIsIExvZ2dlci5FcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IHRvcGljMDogdG9waWMwIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MudG9waWMwID0gdG9waWMwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dzOiBBcnJheTxhbnk+ID0gYXdhaXQgdGhpcy5mZXRjaChcImxvZ3NcIiwgYXJncyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdHhIYXNoID0+IGJsb2NrSGFzaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJsb2NrczogeyBbdGFnOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBhbnkgbWlzc2luZyBibG9ja0hhc2ggdG8gdGhlIGxvZ3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9ncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZyA9IGxvZ3NbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZy5ibG9ja0hhc2ggIT0gbnVsbCkgeyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja3NbbG9nLmJsb2NrTnVtYmVyXSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5nZXRCbG9jayhsb2cuYmxvY2tOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tsb2cuYmxvY2tOdW1iZXJdID0gYmxvY2suaGFzaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmJsb2NrSGFzaCA9IGJsb2Nrc1tsb2cuYmxvY2tOdW1iZXJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2dzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9wZXJmb3JtKHJlcSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXROZXR3b3JrKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5ldHdvcms7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgY3VycmVudCBwcmljZSBvZiBldGhlci5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyByZXR1cm5zIGBgMGBgIG9uIGFueSBuZXR3b3JrIG90aGVyIHRoYW4gYGBtYWlubmV0YGAuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldEV0aGVyUHJpY2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubmV0d29yay5uYW1lICE9PSBcIm1haW5uZXRcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gMC4wO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCgoYXdhaXQgdGhpcy5mZXRjaChcInN0YXRzXCIsIHsgYWN0aW9uOiBcImV0aHByaWNlXCIgfSkpLmV0aHVzZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlcyB0byBhIFtDb250cmFjdF1dIGZvciAlJWFkZHJlc3MlJSwgdXNpbmcgdGhlXHJcbiAgICAgKiAgRXRoZXJzY2FuIEFQSSB0byByZXRyZWl2ZSB0aGUgQ29udHJhY3QgQUJJLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRDb250cmFjdChfYWRkcmVzcykge1xyXG4gICAgICAgIGxldCBhZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhfYWRkcmVzcyk7XHJcbiAgICAgICAgaWYgKGlzUHJvbWlzZShhZGRyZXNzKSkge1xyXG4gICAgICAgICAgICBhZGRyZXNzID0gYXdhaXQgYWRkcmVzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuZmV0Y2goXCJjb250cmFjdFwiLCB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwiZ2V0YWJpXCIsIGFkZHJlc3NcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFiaSA9IEpTT04ucGFyc2UocmVzcCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29udHJhY3QoYWRkcmVzcywgYWJpLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmFwaUtleSA9PSBudWxsKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1ldGhlcnNjYW4uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-etherscan.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-fallback.js":
/*!********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-fallback.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FallbackProvider: () => (/* binding */ FallbackProvider)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _abstract_provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract-provider.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/abstract-provider.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/network.js\");\n/**\r\n *  A **FallbackProvider** provides resilience, security and performance\r\n *  in a way that is customizable and configurable.\r\n *\r\n *  @_section: api/providers/fallback-provider:Fallback Provider [about-fallback-provider]\r\n */\r\n\r\n\r\n\r\nconst BN_1 = BigInt(\"1\");\r\nconst BN_2 = BigInt(\"2\");\r\nfunction shuffle(array) {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        const tmp = array[i];\r\n        array[i] = array[j];\r\n        array[j] = tmp;\r\n    }\r\n}\r\nfunction stall(duration) {\r\n    return new Promise((resolve) => { setTimeout(resolve, duration); });\r\n}\r\nfunction getTime() { return (new Date()).getTime(); }\r\nfunction stringify(value) {\r\n    return JSON.stringify(value, (key, value) => {\r\n        if (typeof (value) === \"bigint\") {\r\n            return { type: \"bigint\", value: value.toString() };\r\n        }\r\n        return value;\r\n    });\r\n}\r\n;\r\nconst defaultConfig = { stallTimeout: 400, priority: 1, weight: 1 };\r\nconst defaultState = {\r\n    blockNumber: -2, requests: 0, lateResponses: 0, errorResponses: 0,\r\n    outOfSync: -1, unsupportedEvents: 0, rollingDuration: 0, score: 0,\r\n    _network: null, _updateNumber: null, _totalTime: 0,\r\n    _lastFatalError: null, _lastFatalErrorTimestamp: 0\r\n};\r\nasync function waitForSync(config, blockNumber) {\r\n    while (config.blockNumber < 0 || config.blockNumber < blockNumber) {\r\n        if (!config._updateNumber) {\r\n            config._updateNumber = (async () => {\r\n                try {\r\n                    const blockNumber = await config.provider.getBlockNumber();\r\n                    if (blockNumber > config.blockNumber) {\r\n                        config.blockNumber = blockNumber;\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    config.blockNumber = -2;\r\n                    config._lastFatalError = error;\r\n                    config._lastFatalErrorTimestamp = getTime();\r\n                }\r\n                config._updateNumber = null;\r\n            })();\r\n        }\r\n        await config._updateNumber;\r\n        config.outOfSync++;\r\n        if (config._lastFatalError) {\r\n            break;\r\n        }\r\n    }\r\n}\r\nfunction _normalize(value) {\r\n    if (value == null) {\r\n        return \"null\";\r\n    }\r\n    if (Array.isArray(value)) {\r\n        return \"[\" + (value.map(_normalize)).join(\",\") + \"]\";\r\n    }\r\n    if (typeof (value) === \"object\" && typeof (value.toJSON) === \"function\") {\r\n        return _normalize(value.toJSON());\r\n    }\r\n    switch (typeof (value)) {\r\n        case \"boolean\":\r\n        case \"symbol\":\r\n            return value.toString();\r\n        case \"bigint\":\r\n        case \"number\":\r\n            return BigInt(value).toString();\r\n        case \"string\":\r\n            return JSON.stringify(value);\r\n        case \"object\": {\r\n            const keys = Object.keys(value);\r\n            keys.sort();\r\n            return \"{\" + keys.map((k) => `${JSON.stringify(k)}:${_normalize(value[k])}`).join(\",\") + \"}\";\r\n        }\r\n    }\r\n    console.log(\"Could not serialize\", value);\r\n    throw new Error(\"Hmm...\");\r\n}\r\nfunction normalizeResult(method, value) {\r\n    if (\"error\" in value) {\r\n        const error = value.error;\r\n        let tag;\r\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\r\n            tag = _normalize(Object.assign({}, error, {\r\n                shortMessage: undefined, reason: undefined, info: undefined\r\n            }));\r\n        }\r\n        else {\r\n            tag = _normalize(error);\r\n        }\r\n        return { tag, value: error };\r\n    }\r\n    const result = value.result;\r\n    return { tag: _normalize(result), value: result };\r\n}\r\n// This strategy picks the highest weight result, as long as the weight is\r\n// equal to or greater than quorum\r\nfunction checkQuorum(quorum, results) {\r\n    const tally = new Map();\r\n    for (const { value, tag, weight } of results) {\r\n        const t = tally.get(tag) || { value, weight: 0 };\r\n        t.weight += weight;\r\n        tally.set(tag, t);\r\n    }\r\n    let best = null;\r\n    for (const r of tally.values()) {\r\n        if (r.weight >= quorum && (!best || r.weight > best.weight)) {\r\n            best = r;\r\n        }\r\n    }\r\n    if (best) {\r\n        return best.value;\r\n    }\r\n    return undefined;\r\n}\r\nfunction getMedian(quorum, results) {\r\n    let resultWeight = 0;\r\n    const errorMap = new Map();\r\n    let bestError = null;\r\n    const values = [];\r\n    for (const { value, tag, weight } of results) {\r\n        if (value instanceof Error) {\r\n            const e = errorMap.get(tag) || { value, weight: 0 };\r\n            e.weight += weight;\r\n            errorMap.set(tag, e);\r\n            if (bestError == null || e.weight > bestError.weight) {\r\n                bestError = e;\r\n            }\r\n        }\r\n        else {\r\n            values.push(BigInt(value));\r\n            resultWeight += weight;\r\n        }\r\n    }\r\n    if (resultWeight < quorum) {\r\n        // We have quorum for an error\r\n        if (bestError && bestError.weight >= quorum) {\r\n            return bestError.value;\r\n        }\r\n        // We do not have quorum for a result\r\n        return undefined;\r\n    }\r\n    // Get the sorted values\r\n    values.sort((a, b) => ((a < b) ? -1 : (b > a) ? 1 : 0));\r\n    const mid = Math.floor(values.length / 2);\r\n    // Odd-length; take the middle value\r\n    if (values.length % 2) {\r\n        return values[mid];\r\n    }\r\n    // Even length; take the ceiling of the mean of the center two values\r\n    return (values[mid - 1] + values[mid] + BN_1) / BN_2;\r\n}\r\nfunction getAnyResult(quorum, results) {\r\n    // If any value or error meets quorum, that is our preferred result\r\n    const result = checkQuorum(quorum, results);\r\n    if (result !== undefined) {\r\n        return result;\r\n    }\r\n    // Otherwise, do we have any result?\r\n    for (const r of results) {\r\n        if (r.value) {\r\n            return r.value;\r\n        }\r\n    }\r\n    // Nope!\r\n    return undefined;\r\n}\r\nfunction getFuzzyMode(quorum, results) {\r\n    if (quorum === 1) {\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(getMedian(quorum, results), \"%internal\");\r\n    }\r\n    const tally = new Map();\r\n    const add = (result, weight) => {\r\n        const t = tally.get(result) || { result, weight: 0 };\r\n        t.weight += weight;\r\n        tally.set(result, t);\r\n    };\r\n    for (const { weight, value } of results) {\r\n        const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(value);\r\n        add(r - 1, weight);\r\n        add(r, weight);\r\n        add(r + 1, weight);\r\n    }\r\n    let bestWeight = 0;\r\n    let bestResult = undefined;\r\n    for (const { weight, result } of tally.values()) {\r\n        // Use this result, if this result meets quorum and has either:\r\n        // - a better weight\r\n        // - or equal weight, but the result is larger\r\n        if (weight >= quorum && (weight > bestWeight || (bestResult != null && weight === bestWeight && result > bestResult))) {\r\n            bestWeight = weight;\r\n            bestResult = result;\r\n        }\r\n    }\r\n    return bestResult;\r\n}\r\n/**\r\n *  A **FallbackProvider** manages several [[Providers]] providing\r\n *  resilience by switching between slow or misbehaving nodes, security\r\n *  by requiring multiple backends to aggree and performance by allowing\r\n *  faster backends to respond earlier.\r\n *\r\n */\r\nclass FallbackProvider extends _abstract_provider_js__WEBPACK_IMPORTED_MODULE_1__.AbstractProvider {\r\n    /**\r\n     *  The number of backends that must agree on a value before it is\r\n     *  accpeted.\r\n     */\r\n    quorum;\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    eventQuorum;\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    eventWorkers;\r\n    #configs;\r\n    #height;\r\n    #initialSyncPromise;\r\n    /**\r\n     *  Creates a new **FallbackProvider** with %%providers%% connected to\r\n     *  %%network%%.\r\n     *\r\n     *  If a [[Provider]] is included in %%providers%%, defaults are used\r\n     *  for the configuration.\r\n     */\r\n    constructor(providers, network, options) {\r\n        super(network, options);\r\n        this.#configs = providers.map((p) => {\r\n            if (p instanceof _abstract_provider_js__WEBPACK_IMPORTED_MODULE_1__.AbstractProvider) {\r\n                return Object.assign({ provider: p }, defaultConfig, defaultState);\r\n            }\r\n            else {\r\n                return Object.assign({}, defaultConfig, p, defaultState);\r\n            }\r\n        });\r\n        this.#height = -2;\r\n        this.#initialSyncPromise = null;\r\n        if (options && options.quorum != null) {\r\n            this.quorum = options.quorum;\r\n        }\r\n        else {\r\n            this.quorum = Math.ceil(this.#configs.reduce((accum, config) => {\r\n                accum += config.weight;\r\n                return accum;\r\n            }, 0) / 2);\r\n        }\r\n        this.eventQuorum = 1;\r\n        this.eventWorkers = 1;\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(this.quorum <= this.#configs.reduce((a, c) => (a + c.weight), 0), \"quorum exceed provider weight\", \"quorum\", this.quorum);\r\n    }\r\n    get providerConfigs() {\r\n        return this.#configs.map((c) => {\r\n            const result = Object.assign({}, c);\r\n            for (const key in result) {\r\n                if (key[0] === \"_\") {\r\n                    delete result[key];\r\n                }\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    async _detectNetwork() {\r\n        return _network_js__WEBPACK_IMPORTED_MODULE_2__.Network.from((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(await this._perform({ method: \"chainId\" })));\r\n    }\r\n    // @TODO: Add support to select providers to be the event subscriber\r\n    //_getSubscriber(sub: Subscription): Subscriber {\r\n    //    throw new Error(\"@TODO\");\r\n    //}\r\n    /**\r\n     *  Transforms a %%req%% into the correct method call on %%provider%%.\r\n     */\r\n    async _translatePerform(provider, req) {\r\n        switch (req.method) {\r\n            case \"broadcastTransaction\":\r\n                return await provider.broadcastTransaction(req.signedTransaction);\r\n            case \"call\":\r\n                return await provider.call(Object.assign({}, req.transaction, { blockTag: req.blockTag }));\r\n            case \"chainId\":\r\n                return (await provider.getNetwork()).chainId;\r\n            case \"estimateGas\":\r\n                return await provider.estimateGas(req.transaction);\r\n            case \"getBalance\":\r\n                return await provider.getBalance(req.address, req.blockTag);\r\n            case \"getBlock\": {\r\n                const block = (\"blockHash\" in req) ? req.blockHash : req.blockTag;\r\n                return await provider.getBlock(block, req.includeTransactions);\r\n            }\r\n            case \"getBlockNumber\":\r\n                return await provider.getBlockNumber();\r\n            case \"getCode\":\r\n                return await provider.getCode(req.address, req.blockTag);\r\n            case \"getGasPrice\":\r\n                return (await provider.getFeeData()).gasPrice;\r\n            case \"getPriorityFee\":\r\n                return (await provider.getFeeData()).maxPriorityFeePerGas;\r\n            case \"getLogs\":\r\n                return await provider.getLogs(req.filter);\r\n            case \"getStorage\":\r\n                return await provider.getStorage(req.address, req.position, req.blockTag);\r\n            case \"getTransaction\":\r\n                return await provider.getTransaction(req.hash);\r\n            case \"getTransactionCount\":\r\n                return await provider.getTransactionCount(req.address, req.blockTag);\r\n            case \"getTransactionReceipt\":\r\n                return await provider.getTransactionReceipt(req.hash);\r\n            case \"getTransactionResult\":\r\n                return await provider.getTransactionResult(req.hash);\r\n        }\r\n    }\r\n    // Grab the next (random) config that is not already part of\r\n    // the running set\r\n    #getNextConfig(running) {\r\n        // @TODO: Maybe do a check here to favour (heavily) providers that\r\n        //        do not require waitForSync and disfavour providers that\r\n        //        seem down-ish or are behaving slowly\r\n        const configs = Array.from(running).map((r) => r.config);\r\n        // Shuffle the states, sorted by priority\r\n        const allConfigs = this.#configs.slice();\r\n        shuffle(allConfigs);\r\n        allConfigs.sort((a, b) => (a.priority - b.priority));\r\n        for (const config of allConfigs) {\r\n            if (config._lastFatalError) {\r\n                continue;\r\n            }\r\n            if (configs.indexOf(config) === -1) {\r\n                return config;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    // Adds a new runner (if available) to running.\r\n    #addRunner(running, req) {\r\n        const config = this.#getNextConfig(running);\r\n        // No runners available\r\n        if (config == null) {\r\n            return null;\r\n        }\r\n        // Create a new runner\r\n        const runner = {\r\n            config, result: null, didBump: false,\r\n            perform: null, staller: null\r\n        };\r\n        const now = getTime();\r\n        // Start performing this operation\r\n        runner.perform = (async () => {\r\n            try {\r\n                config.requests++;\r\n                const result = await this._translatePerform(config.provider, req);\r\n                runner.result = { result };\r\n            }\r\n            catch (error) {\r\n                config.errorResponses++;\r\n                runner.result = { error };\r\n            }\r\n            const dt = (getTime() - now);\r\n            config._totalTime += dt;\r\n            config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt;\r\n            runner.perform = null;\r\n        })();\r\n        // Start a staller; when this times out, it's time to force\r\n        // kicking off another runner because we are taking too long\r\n        runner.staller = (async () => {\r\n            await stall(config.stallTimeout);\r\n            runner.staller = null;\r\n        })();\r\n        running.add(runner);\r\n        return runner;\r\n    }\r\n    // Initializes the blockNumber and network for each runner and\r\n    // blocks until initialized\r\n    async #initialSync() {\r\n        let initialSync = this.#initialSyncPromise;\r\n        if (!initialSync) {\r\n            const promises = [];\r\n            this.#configs.forEach((config) => {\r\n                promises.push((async () => {\r\n                    await waitForSync(config, 0);\r\n                    if (!config._lastFatalError) {\r\n                        config._network = await config.provider.getNetwork();\r\n                    }\r\n                })());\r\n            });\r\n            this.#initialSyncPromise = initialSync = (async () => {\r\n                // Wait for all providers to have a block number and network\r\n                await Promise.all(promises);\r\n                // Check all the networks match\r\n                let chainId = null;\r\n                for (const config of this.#configs) {\r\n                    if (config._lastFatalError) {\r\n                        continue;\r\n                    }\r\n                    const network = (config._network);\r\n                    if (chainId == null) {\r\n                        chainId = network.chainId;\r\n                    }\r\n                    else if (network.chainId !== chainId) {\r\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"cannot mix providers on different networks\", \"UNSUPPORTED_OPERATION\", {\r\n                            operation: \"new FallbackProvider\"\r\n                        });\r\n                    }\r\n                }\r\n            })();\r\n        }\r\n        await initialSync;\r\n    }\r\n    async #checkQuorum(running, req) {\r\n        // Get all the result objects\r\n        const results = [];\r\n        for (const runner of running) {\r\n            if (runner.result != null) {\r\n                const { tag, value } = normalizeResult(req.method, runner.result);\r\n                results.push({ tag, value, weight: runner.config.weight });\r\n            }\r\n        }\r\n        // Are there enough results to event meet quorum?\r\n        if (results.reduce((a, r) => (a + r.weight), 0) < this.quorum) {\r\n            return undefined;\r\n        }\r\n        switch (req.method) {\r\n            case \"getBlockNumber\": {\r\n                // We need to get the bootstrap block height\r\n                if (this.#height === -2) {\r\n                    this.#height = Math.ceil((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(getMedian(this.quorum, this.#configs.filter((c) => (!c._lastFatalError)).map((c) => ({\r\n                        value: c.blockNumber,\r\n                        tag: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(c.blockNumber).toString(),\r\n                        weight: c.weight\r\n                    })))));\r\n                }\r\n                // Find the mode across all the providers, allowing for\r\n                // a little drift between block heights\r\n                const mode = getFuzzyMode(this.quorum, results);\r\n                if (mode === undefined) {\r\n                    return undefined;\r\n                }\r\n                if (mode > this.#height) {\r\n                    this.#height = mode;\r\n                }\r\n                return this.#height;\r\n            }\r\n            case \"getGasPrice\":\r\n            case \"getPriorityFee\":\r\n            case \"estimateGas\":\r\n                return getMedian(this.quorum, results);\r\n            case \"getBlock\":\r\n                // Pending blocks are in the mempool and already\r\n                // quite untrustworthy; just grab anything\r\n                if (\"blockTag\" in req && req.blockTag === \"pending\") {\r\n                    return getAnyResult(this.quorum, results);\r\n                }\r\n                return checkQuorum(this.quorum, results);\r\n            case \"call\":\r\n            case \"chainId\":\r\n            case \"getBalance\":\r\n            case \"getTransactionCount\":\r\n            case \"getCode\":\r\n            case \"getStorage\":\r\n            case \"getTransaction\":\r\n            case \"getTransactionReceipt\":\r\n            case \"getLogs\":\r\n                return checkQuorum(this.quorum, results);\r\n            case \"broadcastTransaction\":\r\n                return getAnyResult(this.quorum, results);\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"unsupported method\", \"UNSUPPORTED_OPERATION\", {\r\n            operation: `_perform(${stringify(req.method)})`\r\n        });\r\n    }\r\n    async #waitForQuorum(running, req) {\r\n        if (running.size === 0) {\r\n            throw new Error(\"no runners?!\");\r\n        }\r\n        // Any promises that are interesting to watch for; an expired stall\r\n        // or a successful perform\r\n        const interesting = [];\r\n        let newRunners = 0;\r\n        for (const runner of running) {\r\n            // No responses, yet; keep an eye on it\r\n            if (runner.perform) {\r\n                interesting.push(runner.perform);\r\n            }\r\n            // Still stalling...\r\n            if (runner.staller) {\r\n                interesting.push(runner.staller);\r\n                continue;\r\n            }\r\n            // This runner has already triggered another runner\r\n            if (runner.didBump) {\r\n                continue;\r\n            }\r\n            // Got a response (result or error) or stalled; kick off another runner\r\n            runner.didBump = true;\r\n            newRunners++;\r\n        }\r\n        // Check if we have reached quorum on a result (or error)\r\n        const value = await this.#checkQuorum(running, req);\r\n        if (value !== undefined) {\r\n            if (value instanceof Error) {\r\n                throw value;\r\n            }\r\n            return value;\r\n        }\r\n        // Add any new runners, because a staller timed out or a result\r\n        // or error response came in.\r\n        for (let i = 0; i < newRunners; i++) {\r\n            this.#addRunner(running, req);\r\n        }\r\n        // All providers have returned, and we have no result\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(interesting.length > 0, \"quorum not met\", \"SERVER_ERROR\", {\r\n            request: \"%sub-requests\",\r\n            info: { request: req, results: Array.from(running).map((r) => stringify(r.result)) }\r\n        });\r\n        // Wait for someone to either complete its perform or stall out\r\n        await Promise.race(interesting);\r\n        // This is recursive, but at worst case the depth is 2x the\r\n        // number of providers (each has a perform and a staller)\r\n        return await this.#waitForQuorum(running, req);\r\n    }\r\n    async _perform(req) {\r\n        // Broadcasting a transaction is rare (ish) and already incurs\r\n        // a cost on the user, so spamming is safe-ish. Just send it to\r\n        // every backend.\r\n        if (req.method === \"broadcastTransaction\") {\r\n            // Once any broadcast provides a positive result, use it. No\r\n            // need to wait for anyone else\r\n            const results = this.#configs.map((c) => null);\r\n            const broadcasts = this.#configs.map(async ({ provider, weight }, index) => {\r\n                try {\r\n                    const result = await provider._perform(req);\r\n                    results[index] = Object.assign(normalizeResult(req.method, { result }), { weight });\r\n                }\r\n                catch (error) {\r\n                    results[index] = Object.assign(normalizeResult(req.method, { error }), { weight });\r\n                }\r\n            });\r\n            // As each promise finishes...\r\n            while (true) {\r\n                // Check for a valid broadcast result\r\n                const done = results.filter((r) => (r != null));\r\n                for (const { value } of done) {\r\n                    if (!(value instanceof Error)) {\r\n                        return value;\r\n                    }\r\n                }\r\n                // Check for a legit broadcast error (one which we cannot\r\n                // recover from; some nodes may return the following red\r\n                // herring events:\r\n                // - alredy seend (UNKNOWN_ERROR)\r\n                // - NONCE_EXPIRED\r\n                // - REPLACEMENT_UNDERPRICED\r\n                const result = checkQuorum(this.quorum, results.filter((r) => (r != null)));\r\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(result, \"INSUFFICIENT_FUNDS\")) {\r\n                    throw result;\r\n                }\r\n                // Kick off the next provider (if any)\r\n                const waiting = broadcasts.filter((b, i) => (results[i] == null));\r\n                if (waiting.length === 0) {\r\n                    break;\r\n                }\r\n                await Promise.race(waiting);\r\n            }\r\n            // Use standard quorum results; any result was returned above,\r\n            // so this will find any error that met quorum if any\r\n            const result = getAnyResult(this.quorum, results);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(result !== undefined, \"problem multi-broadcasting\", \"SERVER_ERROR\", {\r\n                request: \"%sub-requests\",\r\n                info: { request: req, results: results.map(stringify) }\r\n            });\r\n            if (result instanceof Error) {\r\n                throw result;\r\n            }\r\n            return result;\r\n        }\r\n        await this.#initialSync();\r\n        // Bootstrap enough runners to meet quorum\r\n        const running = new Set();\r\n        let inflightQuorum = 0;\r\n        while (true) {\r\n            const runner = this.#addRunner(running, req);\r\n            if (runner == null) {\r\n                break;\r\n            }\r\n            inflightQuorum += runner.config.weight;\r\n            if (inflightQuorum >= this.quorum) {\r\n                break;\r\n            }\r\n        }\r\n        const result = await this.#waitForQuorum(running, req);\r\n        // Track requests sent to a provider that are still\r\n        // outstanding after quorum has been otherwise found\r\n        for (const runner of running) {\r\n            if (runner.perform && runner.result == null) {\r\n                runner.config.lateResponses++;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    async destroy() {\r\n        for (const { provider } of this.#configs) {\r\n            provider.destroy();\r\n        }\r\n        super.destroy();\r\n    }\r\n}\r\n//# sourceMappingURL=provider-fallback.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItZmFsbGJhY2suanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMwRjtBQUNoQztBQUNuQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQ0FBZ0M7QUFDdEU7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCLGtCQUFrQixHQUFHLHFCQUFxQixpQkFBaUI7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBTztBQUNuQiw2Q0FBNkM7QUFDN0M7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLFlBQVksdURBQU07QUFDbEI7QUFDQSx3QkFBd0I7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxwcm92aWRlcnNcXHByb3ZpZGVyLWZhbGxiYWNrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgQSAqKkZhbGxiYWNrUHJvdmlkZXIqKiBwcm92aWRlcyByZXNpbGllbmNlLCBzZWN1cml0eSBhbmQgcGVyZm9ybWFuY2VcclxuICogIGluIGEgd2F5IHRoYXQgaXMgY3VzdG9taXphYmxlIGFuZCBjb25maWd1cmFibGUuXHJcbiAqXHJcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvZmFsbGJhY2stcHJvdmlkZXI6RmFsbGJhY2sgUHJvdmlkZXIgW2Fib3V0LWZhbGxiYWNrLXByb3ZpZGVyXVxyXG4gKi9cclxuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGlzRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgQWJzdHJhY3RQcm92aWRlciB9IGZyb20gXCIuL2Fic3RyYWN0LXByb3ZpZGVyLmpzXCI7XHJcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XHJcbmNvbnN0IEJOXzEgPSBCaWdJbnQoXCIxXCIpO1xyXG5jb25zdCBCTl8yID0gQmlnSW50KFwiMlwiKTtcclxuZnVuY3Rpb24gc2h1ZmZsZShhcnJheSkge1xyXG4gICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcclxuICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XHJcbiAgICAgICAgY29uc3QgdG1wID0gYXJyYXlbaV07XHJcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtqXTtcclxuICAgICAgICBhcnJheVtqXSA9IHRtcDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzdGFsbChkdXJhdGlvbikge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7IHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pOyB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRUaW1lKCkgeyByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTsgfVxyXG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUpIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwiYmlnaW50XCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJiaWdpbnRcIiwgdmFsdWU6IHZhbHVlLnRvU3RyaW5nKCkgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfSk7XHJcbn1cclxuO1xyXG5jb25zdCBkZWZhdWx0Q29uZmlnID0geyBzdGFsbFRpbWVvdXQ6IDQwMCwgcHJpb3JpdHk6IDEsIHdlaWdodDogMSB9O1xyXG5jb25zdCBkZWZhdWx0U3RhdGUgPSB7XHJcbiAgICBibG9ja051bWJlcjogLTIsIHJlcXVlc3RzOiAwLCBsYXRlUmVzcG9uc2VzOiAwLCBlcnJvclJlc3BvbnNlczogMCxcclxuICAgIG91dE9mU3luYzogLTEsIHVuc3VwcG9ydGVkRXZlbnRzOiAwLCByb2xsaW5nRHVyYXRpb246IDAsIHNjb3JlOiAwLFxyXG4gICAgX25ldHdvcms6IG51bGwsIF91cGRhdGVOdW1iZXI6IG51bGwsIF90b3RhbFRpbWU6IDAsXHJcbiAgICBfbGFzdEZhdGFsRXJyb3I6IG51bGwsIF9sYXN0RmF0YWxFcnJvclRpbWVzdGFtcDogMFxyXG59O1xyXG5hc3luYyBmdW5jdGlvbiB3YWl0Rm9yU3luYyhjb25maWcsIGJsb2NrTnVtYmVyKSB7XHJcbiAgICB3aGlsZSAoY29uZmlnLmJsb2NrTnVtYmVyIDwgMCB8fCBjb25maWcuYmxvY2tOdW1iZXIgPCBibG9ja051bWJlcikge1xyXG4gICAgICAgIGlmICghY29uZmlnLl91cGRhdGVOdW1iZXIpIHtcclxuICAgICAgICAgICAgY29uZmlnLl91cGRhdGVOdW1iZXIgPSAoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IGNvbmZpZy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA+IGNvbmZpZy5ibG9ja051bWJlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuYmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25maWcuYmxvY2tOdW1iZXIgPSAtMjtcclxuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2xhc3RGYXRhbEVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9sYXN0RmF0YWxFcnJvclRpbWVzdGFtcCA9IGdldFRpbWUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbmZpZy5fdXBkYXRlTnVtYmVyID0gbnVsbDtcclxuICAgICAgICAgICAgfSkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXdhaXQgY29uZmlnLl91cGRhdGVOdW1iZXI7XHJcbiAgICAgICAgY29uZmlnLm91dE9mU3luYysrO1xyXG4gICAgICAgIGlmIChjb25maWcuX2xhc3RGYXRhbEVycm9yKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBfbm9ybWFsaXplKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcclxuICAgIH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBcIltcIiArICh2YWx1ZS5tYXAoX25vcm1hbGl6ZSkpLmpvaW4oXCIsXCIpICsgXCJdXCI7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mICh2YWx1ZS50b0pTT04pID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICByZXR1cm4gX25vcm1hbGl6ZSh2YWx1ZS50b0pTT04oKSk7XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XHJcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcclxuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcclxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xyXG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xyXG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xyXG4gICAgICAgICAgICBrZXlzLnNvcnQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIFwie1wiICsga2V5cy5tYXAoKGspID0+IGAke0pTT04uc3RyaW5naWZ5KGspfToke19ub3JtYWxpemUodmFsdWVba10pfWApLmpvaW4oXCIsXCIpICsgXCJ9XCI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coXCJDb3VsZCBub3Qgc2VyaWFsaXplXCIsIHZhbHVlKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkhtbS4uLlwiKTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVSZXN1bHQobWV0aG9kLCB2YWx1ZSkge1xyXG4gICAgaWYgKFwiZXJyb3JcIiBpbiB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gdmFsdWUuZXJyb3I7XHJcbiAgICAgICAgbGV0IHRhZztcclxuICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xyXG4gICAgICAgICAgICB0YWcgPSBfbm9ybWFsaXplKE9iamVjdC5hc3NpZ24oe30sIGVycm9yLCB7XHJcbiAgICAgICAgICAgICAgICBzaG9ydE1lc3NhZ2U6IHVuZGVmaW5lZCwgcmVhc29uOiB1bmRlZmluZWQsIGluZm86IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0YWcgPSBfbm9ybWFsaXplKGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgdGFnLCB2YWx1ZTogZXJyb3IgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLnJlc3VsdDtcclxuICAgIHJldHVybiB7IHRhZzogX25vcm1hbGl6ZShyZXN1bHQpLCB2YWx1ZTogcmVzdWx0IH07XHJcbn1cclxuLy8gVGhpcyBzdHJhdGVneSBwaWNrcyB0aGUgaGlnaGVzdCB3ZWlnaHQgcmVzdWx0LCBhcyBsb25nIGFzIHRoZSB3ZWlnaHQgaXNcclxuLy8gZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIHF1b3J1bVxyXG5mdW5jdGlvbiBjaGVja1F1b3J1bShxdW9ydW0sIHJlc3VsdHMpIHtcclxuICAgIGNvbnN0IHRhbGx5ID0gbmV3IE1hcCgpO1xyXG4gICAgZm9yIChjb25zdCB7IHZhbHVlLCB0YWcsIHdlaWdodCB9IG9mIHJlc3VsdHMpIHtcclxuICAgICAgICBjb25zdCB0ID0gdGFsbHkuZ2V0KHRhZykgfHwgeyB2YWx1ZSwgd2VpZ2h0OiAwIH07XHJcbiAgICAgICAgdC53ZWlnaHQgKz0gd2VpZ2h0O1xyXG4gICAgICAgIHRhbGx5LnNldCh0YWcsIHQpO1xyXG4gICAgfVxyXG4gICAgbGV0IGJlc3QgPSBudWxsO1xyXG4gICAgZm9yIChjb25zdCByIG9mIHRhbGx5LnZhbHVlcygpKSB7XHJcbiAgICAgICAgaWYgKHIud2VpZ2h0ID49IHF1b3J1bSAmJiAoIWJlc3QgfHwgci53ZWlnaHQgPiBiZXN0LndlaWdodCkpIHtcclxuICAgICAgICAgICAgYmVzdCA9IHI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGJlc3QpIHtcclxuICAgICAgICByZXR1cm4gYmVzdC52YWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TWVkaWFuKHF1b3J1bSwgcmVzdWx0cykge1xyXG4gICAgbGV0IHJlc3VsdFdlaWdodCA9IDA7XHJcbiAgICBjb25zdCBlcnJvck1hcCA9IG5ldyBNYXAoKTtcclxuICAgIGxldCBiZXN0RXJyb3IgPSBudWxsO1xyXG4gICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICBmb3IgKGNvbnN0IHsgdmFsdWUsIHRhZywgd2VpZ2h0IH0gb2YgcmVzdWx0cykge1xyXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlcnJvck1hcC5nZXQodGFnKSB8fCB7IHZhbHVlLCB3ZWlnaHQ6IDAgfTtcclxuICAgICAgICAgICAgZS53ZWlnaHQgKz0gd2VpZ2h0O1xyXG4gICAgICAgICAgICBlcnJvck1hcC5zZXQodGFnLCBlKTtcclxuICAgICAgICAgICAgaWYgKGJlc3RFcnJvciA9PSBudWxsIHx8IGUud2VpZ2h0ID4gYmVzdEVycm9yLndlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgYmVzdEVycm9yID0gZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFsdWVzLnB1c2goQmlnSW50KHZhbHVlKSk7XHJcbiAgICAgICAgICAgIHJlc3VsdFdlaWdodCArPSB3ZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHJlc3VsdFdlaWdodCA8IHF1b3J1bSkge1xyXG4gICAgICAgIC8vIFdlIGhhdmUgcXVvcnVtIGZvciBhbiBlcnJvclxyXG4gICAgICAgIGlmIChiZXN0RXJyb3IgJiYgYmVzdEVycm9yLndlaWdodCA+PSBxdW9ydW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJlc3RFcnJvci52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2UgZG8gbm90IGhhdmUgcXVvcnVtIGZvciBhIHJlc3VsdFxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvLyBHZXQgdGhlIHNvcnRlZCB2YWx1ZXNcclxuICAgIHZhbHVlcy5zb3J0KChhLCBiKSA9PiAoKGEgPCBiKSA/IC0xIDogKGIgPiBhKSA/IDEgOiAwKSk7XHJcbiAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAyKTtcclxuICAgIC8vIE9kZC1sZW5ndGg7IHRha2UgdGhlIG1pZGRsZSB2YWx1ZVxyXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggJSAyKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlc1ttaWRdO1xyXG4gICAgfVxyXG4gICAgLy8gRXZlbiBsZW5ndGg7IHRha2UgdGhlIGNlaWxpbmcgb2YgdGhlIG1lYW4gb2YgdGhlIGNlbnRlciB0d28gdmFsdWVzXHJcbiAgICByZXR1cm4gKHZhbHVlc1ttaWQgLSAxXSArIHZhbHVlc1ttaWRdICsgQk5fMSkgLyBCTl8yO1xyXG59XHJcbmZ1bmN0aW9uIGdldEFueVJlc3VsdChxdW9ydW0sIHJlc3VsdHMpIHtcclxuICAgIC8vIElmIGFueSB2YWx1ZSBvciBlcnJvciBtZWV0cyBxdW9ydW0sIHRoYXQgaXMgb3VyIHByZWZlcnJlZCByZXN1bHRcclxuICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrUXVvcnVtKHF1b3J1bSwgcmVzdWx0cyk7XHJcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLy8gT3RoZXJ3aXNlLCBkbyB3ZSBoYXZlIGFueSByZXN1bHQ/XHJcbiAgICBmb3IgKGNvbnN0IHIgb2YgcmVzdWx0cykge1xyXG4gICAgICAgIGlmIChyLnZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIE5vcGUhXHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmZ1bmN0aW9uIGdldEZ1enp5TW9kZShxdW9ydW0sIHJlc3VsdHMpIHtcclxuICAgIGlmIChxdW9ydW0gPT09IDEpIHtcclxuICAgICAgICByZXR1cm4gZ2V0TnVtYmVyKGdldE1lZGlhbihxdW9ydW0sIHJlc3VsdHMpLCBcIiVpbnRlcm5hbFwiKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHRhbGx5ID0gbmV3IE1hcCgpO1xyXG4gICAgY29uc3QgYWRkID0gKHJlc3VsdCwgd2VpZ2h0KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdCA9IHRhbGx5LmdldChyZXN1bHQpIHx8IHsgcmVzdWx0LCB3ZWlnaHQ6IDAgfTtcclxuICAgICAgICB0LndlaWdodCArPSB3ZWlnaHQ7XHJcbiAgICAgICAgdGFsbHkuc2V0KHJlc3VsdCwgdCk7XHJcbiAgICB9O1xyXG4gICAgZm9yIChjb25zdCB7IHdlaWdodCwgdmFsdWUgfSBvZiByZXN1bHRzKSB7XHJcbiAgICAgICAgY29uc3QgciA9IGdldE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgYWRkKHIgLSAxLCB3ZWlnaHQpO1xyXG4gICAgICAgIGFkZChyLCB3ZWlnaHQpO1xyXG4gICAgICAgIGFkZChyICsgMSwgd2VpZ2h0KTtcclxuICAgIH1cclxuICAgIGxldCBiZXN0V2VpZ2h0ID0gMDtcclxuICAgIGxldCBiZXN0UmVzdWx0ID0gdW5kZWZpbmVkO1xyXG4gICAgZm9yIChjb25zdCB7IHdlaWdodCwgcmVzdWx0IH0gb2YgdGFsbHkudmFsdWVzKCkpIHtcclxuICAgICAgICAvLyBVc2UgdGhpcyByZXN1bHQsIGlmIHRoaXMgcmVzdWx0IG1lZXRzIHF1b3J1bSBhbmQgaGFzIGVpdGhlcjpcclxuICAgICAgICAvLyAtIGEgYmV0dGVyIHdlaWdodFxyXG4gICAgICAgIC8vIC0gb3IgZXF1YWwgd2VpZ2h0LCBidXQgdGhlIHJlc3VsdCBpcyBsYXJnZXJcclxuICAgICAgICBpZiAod2VpZ2h0ID49IHF1b3J1bSAmJiAod2VpZ2h0ID4gYmVzdFdlaWdodCB8fCAoYmVzdFJlc3VsdCAhPSBudWxsICYmIHdlaWdodCA9PT0gYmVzdFdlaWdodCAmJiByZXN1bHQgPiBiZXN0UmVzdWx0KSkpIHtcclxuICAgICAgICAgICAgYmVzdFdlaWdodCA9IHdlaWdodDtcclxuICAgICAgICAgICAgYmVzdFJlc3VsdCA9IHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYmVzdFJlc3VsdDtcclxufVxyXG4vKipcclxuICogIEEgKipGYWxsYmFja1Byb3ZpZGVyKiogbWFuYWdlcyBzZXZlcmFsIFtbUHJvdmlkZXJzXV0gcHJvdmlkaW5nXHJcbiAqICByZXNpbGllbmNlIGJ5IHN3aXRjaGluZyBiZXR3ZWVuIHNsb3cgb3IgbWlzYmVoYXZpbmcgbm9kZXMsIHNlY3VyaXR5XHJcbiAqICBieSByZXF1aXJpbmcgbXVsdGlwbGUgYmFja2VuZHMgdG8gYWdncmVlIGFuZCBwZXJmb3JtYW5jZSBieSBhbGxvd2luZ1xyXG4gKiAgZmFzdGVyIGJhY2tlbmRzIHRvIHJlc3BvbmQgZWFybGllci5cclxuICpcclxuICovXHJcbmV4cG9ydCBjbGFzcyBGYWxsYmFja1Byb3ZpZGVyIGV4dGVuZHMgQWJzdHJhY3RQcm92aWRlciB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbnVtYmVyIG9mIGJhY2tlbmRzIHRoYXQgbXVzdCBhZ3JlZSBvbiBhIHZhbHVlIGJlZm9yZSBpdCBpc1xyXG4gICAgICogIGFjY3BldGVkLlxyXG4gICAgICovXHJcbiAgICBxdW9ydW07XHJcbiAgICAvKipcclxuICAgICAqICBAX2lnbm9yZTpcclxuICAgICAqL1xyXG4gICAgZXZlbnRRdW9ydW07XHJcbiAgICAvKipcclxuICAgICAqICBAX2lnbm9yZTpcclxuICAgICAqL1xyXG4gICAgZXZlbnRXb3JrZXJzO1xyXG4gICAgI2NvbmZpZ3M7XHJcbiAgICAjaGVpZ2h0O1xyXG4gICAgI2luaXRpYWxTeW5jUHJvbWlzZTtcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGYWxsYmFja1Byb3ZpZGVyKiogd2l0aCAlJXByb3ZpZGVycyUlIGNvbm5lY3RlZCB0b1xyXG4gICAgICogICUlbmV0d29yayUlLlxyXG4gICAgICpcclxuICAgICAqICBJZiBhIFtbUHJvdmlkZXJdXSBpcyBpbmNsdWRlZCBpbiAlJXByb3ZpZGVycyUlLCBkZWZhdWx0cyBhcmUgdXNlZFxyXG4gICAgICogIGZvciB0aGUgY29uZmlndXJhdGlvbi5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXJzLCBuZXR3b3JrLCBvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy4jY29uZmlncyA9IHByb3ZpZGVycy5tYXAoKHApID0+IHtcclxuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBYnN0cmFjdFByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHByb3ZpZGVyOiBwIH0sIGRlZmF1bHRDb25maWcsIGRlZmF1bHRTdGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdENvbmZpZywgcCwgZGVmYXVsdFN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuI2hlaWdodCA9IC0yO1xyXG4gICAgICAgIHRoaXMuI2luaXRpYWxTeW5jUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5xdW9ydW0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnF1b3J1bSA9IG9wdGlvbnMucXVvcnVtO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5xdW9ydW0gPSBNYXRoLmNlaWwodGhpcy4jY29uZmlncy5yZWR1Y2UoKGFjY3VtLCBjb25maWcpID0+IHtcclxuICAgICAgICAgICAgICAgIGFjY3VtICs9IGNvbmZpZy53ZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XHJcbiAgICAgICAgICAgIH0sIDApIC8gMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZXZlbnRRdW9ydW0gPSAxO1xyXG4gICAgICAgIHRoaXMuZXZlbnRXb3JrZXJzID0gMTtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudCh0aGlzLnF1b3J1bSA8PSB0aGlzLiNjb25maWdzLnJlZHVjZSgoYSwgYykgPT4gKGEgKyBjLndlaWdodCksIDApLCBcInF1b3J1bSBleGNlZWQgcHJvdmlkZXIgd2VpZ2h0XCIsIFwicXVvcnVtXCIsIHRoaXMucXVvcnVtKTtcclxuICAgIH1cclxuICAgIGdldCBwcm92aWRlckNvbmZpZ3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NvbmZpZ3MubWFwKChjKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIGMpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXlbMF0gPT09IFwiX1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdFtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfZGV0ZWN0TmV0d29yaygpIHtcclxuICAgICAgICByZXR1cm4gTmV0d29yay5mcm9tKGdldEJpZ0ludChhd2FpdCB0aGlzLl9wZXJmb3JtKHsgbWV0aG9kOiBcImNoYWluSWRcIiB9KSkpO1xyXG4gICAgfVxyXG4gICAgLy8gQFRPRE86IEFkZCBzdXBwb3J0IHRvIHNlbGVjdCBwcm92aWRlcnMgdG8gYmUgdGhlIGV2ZW50IHN1YnNjcmliZXJcclxuICAgIC8vX2dldFN1YnNjcmliZXIoc3ViOiBTdWJzY3JpcHRpb24pOiBTdWJzY3JpYmVyIHtcclxuICAgIC8vICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xyXG4gICAgLy99XHJcbiAgICAvKipcclxuICAgICAqICBUcmFuc2Zvcm1zIGEgJSVyZXElJSBpbnRvIHRoZSBjb3JyZWN0IG1ldGhvZCBjYWxsIG9uICUlcHJvdmlkZXIlJS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgX3RyYW5zbGF0ZVBlcmZvcm0ocHJvdmlkZXIsIHJlcSkge1xyXG4gICAgICAgIHN3aXRjaCAocmVxLm1ldGhvZCkge1xyXG4gICAgICAgICAgICBjYXNlIFwiYnJvYWRjYXN0VHJhbnNhY3Rpb25cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5icm9hZGNhc3RUcmFuc2FjdGlvbihyZXEuc2lnbmVkVHJhbnNhY3Rpb24pO1xyXG4gICAgICAgICAgICBjYXNlIFwiY2FsbFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmNhbGwoT2JqZWN0LmFzc2lnbih7fSwgcmVxLnRyYW5zYWN0aW9uLCB7IGJsb2NrVGFnOiByZXEuYmxvY2tUYWcgfSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiY2hhaW5JZFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChhd2FpdCBwcm92aWRlci5nZXROZXR3b3JrKCkpLmNoYWluSWQ7XHJcbiAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmVzdGltYXRlR2FzKHJlcS50cmFuc2FjdGlvbik7XHJcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuZ2V0QmFsYW5jZShyZXEuYWRkcmVzcywgcmVxLmJsb2NrVGFnKTtcclxuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gKFwiYmxvY2tIYXNoXCIgaW4gcmVxKSA/IHJlcS5ibG9ja0hhc2ggOiByZXEuYmxvY2tUYWc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuZ2V0QmxvY2soYmxvY2ssIHJlcS5pbmNsdWRlVHJhbnNhY3Rpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmdldENvZGUocmVxLmFkZHJlc3MsIHJlcS5ibG9ja1RhZyk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCkpLmdhc1ByaWNlO1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0UHJpb3JpdHlGZWVcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiAoYXdhaXQgcHJvdmlkZXIuZ2V0RmVlRGF0YSgpKS5tYXhQcmlvcml0eUZlZVBlckdhcztcclxuICAgICAgICAgICAgY2FzZSBcImdldExvZ3NcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRMb2dzKHJlcS5maWx0ZXIpO1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmdldFN0b3JhZ2UocmVxLmFkZHJlc3MsIHJlcS5wb3NpdGlvbiwgcmVxLmJsb2NrVGFnKTtcclxuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24ocmVxLmhhc2gpO1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQocmVxLmFkZHJlc3MsIHJlcS5ibG9ja1RhZyk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQocmVxLmhhc2gpO1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZXN1bHRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlc3VsdChyZXEuaGFzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gR3JhYiB0aGUgbmV4dCAocmFuZG9tKSBjb25maWcgdGhhdCBpcyBub3QgYWxyZWFkeSBwYXJ0IG9mXHJcbiAgICAvLyB0aGUgcnVubmluZyBzZXRcclxuICAgICNnZXROZXh0Q29uZmlnKHJ1bm5pbmcpIHtcclxuICAgICAgICAvLyBAVE9ETzogTWF5YmUgZG8gYSBjaGVjayBoZXJlIHRvIGZhdm91ciAoaGVhdmlseSkgcHJvdmlkZXJzIHRoYXRcclxuICAgICAgICAvLyAgICAgICAgZG8gbm90IHJlcXVpcmUgd2FpdEZvclN5bmMgYW5kIGRpc2Zhdm91ciBwcm92aWRlcnMgdGhhdFxyXG4gICAgICAgIC8vICAgICAgICBzZWVtIGRvd24taXNoIG9yIGFyZSBiZWhhdmluZyBzbG93bHlcclxuICAgICAgICBjb25zdCBjb25maWdzID0gQXJyYXkuZnJvbShydW5uaW5nKS5tYXAoKHIpID0+IHIuY29uZmlnKTtcclxuICAgICAgICAvLyBTaHVmZmxlIHRoZSBzdGF0ZXMsIHNvcnRlZCBieSBwcmlvcml0eVxyXG4gICAgICAgIGNvbnN0IGFsbENvbmZpZ3MgPSB0aGlzLiNjb25maWdzLnNsaWNlKCk7XHJcbiAgICAgICAgc2h1ZmZsZShhbGxDb25maWdzKTtcclxuICAgICAgICBhbGxDb25maWdzLnNvcnQoKGEsIGIpID0+IChhLnByaW9yaXR5IC0gYi5wcmlvcml0eSkpO1xyXG4gICAgICAgIGZvciAoY29uc3QgY29uZmlnIG9mIGFsbENvbmZpZ3MpIHtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5fbGFzdEZhdGFsRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb25maWdzLmluZGV4T2YoY29uZmlnKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb25maWc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyBBZGRzIGEgbmV3IHJ1bm5lciAoaWYgYXZhaWxhYmxlKSB0byBydW5uaW5nLlxyXG4gICAgI2FkZFJ1bm5lcihydW5uaW5nLCByZXEpIHtcclxuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLiNnZXROZXh0Q29uZmlnKHJ1bm5pbmcpO1xyXG4gICAgICAgIC8vIE5vIHJ1bm5lcnMgYXZhaWxhYmxlXHJcbiAgICAgICAgaWYgKGNvbmZpZyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgcnVubmVyXHJcbiAgICAgICAgY29uc3QgcnVubmVyID0ge1xyXG4gICAgICAgICAgICBjb25maWcsIHJlc3VsdDogbnVsbCwgZGlkQnVtcDogZmFsc2UsXHJcbiAgICAgICAgICAgIHBlcmZvcm06IG51bGwsIHN0YWxsZXI6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IG5vdyA9IGdldFRpbWUoKTtcclxuICAgICAgICAvLyBTdGFydCBwZXJmb3JtaW5nIHRoaXMgb3BlcmF0aW9uXHJcbiAgICAgICAgcnVubmVyLnBlcmZvcm0gPSAoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLnJlcXVlc3RzKys7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl90cmFuc2xhdGVQZXJmb3JtKGNvbmZpZy5wcm92aWRlciwgcmVxKTtcclxuICAgICAgICAgICAgICAgIHJ1bm5lci5yZXN1bHQgPSB7IHJlc3VsdCB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLmVycm9yUmVzcG9uc2VzKys7XHJcbiAgICAgICAgICAgICAgICBydW5uZXIucmVzdWx0ID0geyBlcnJvciB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGR0ID0gKGdldFRpbWUoKSAtIG5vdyk7XHJcbiAgICAgICAgICAgIGNvbmZpZy5fdG90YWxUaW1lICs9IGR0O1xyXG4gICAgICAgICAgICBjb25maWcucm9sbGluZ0R1cmF0aW9uID0gMC45NSAqIGNvbmZpZy5yb2xsaW5nRHVyYXRpb24gKyAwLjA1ICogZHQ7XHJcbiAgICAgICAgICAgIHJ1bm5lci5wZXJmb3JtID0gbnVsbDtcclxuICAgICAgICB9KSgpO1xyXG4gICAgICAgIC8vIFN0YXJ0IGEgc3RhbGxlcjsgd2hlbiB0aGlzIHRpbWVzIG91dCwgaXQncyB0aW1lIHRvIGZvcmNlXHJcbiAgICAgICAgLy8ga2lja2luZyBvZmYgYW5vdGhlciBydW5uZXIgYmVjYXVzZSB3ZSBhcmUgdGFraW5nIHRvbyBsb25nXHJcbiAgICAgICAgcnVubmVyLnN0YWxsZXIgPSAoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBhd2FpdCBzdGFsbChjb25maWcuc3RhbGxUaW1lb3V0KTtcclxuICAgICAgICAgICAgcnVubmVyLnN0YWxsZXIgPSBudWxsO1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICAgICAgcnVubmluZy5hZGQocnVubmVyKTtcclxuICAgICAgICByZXR1cm4gcnVubmVyO1xyXG4gICAgfVxyXG4gICAgLy8gSW5pdGlhbGl6ZXMgdGhlIGJsb2NrTnVtYmVyIGFuZCBuZXR3b3JrIGZvciBlYWNoIHJ1bm5lciBhbmRcclxuICAgIC8vIGJsb2NrcyB1bnRpbCBpbml0aWFsaXplZFxyXG4gICAgYXN5bmMgI2luaXRpYWxTeW5jKCkge1xyXG4gICAgICAgIGxldCBpbml0aWFsU3luYyA9IHRoaXMuI2luaXRpYWxTeW5jUHJvbWlzZTtcclxuICAgICAgICBpZiAoIWluaXRpYWxTeW5jKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuI2NvbmZpZ3MuZm9yRWFjaCgoY29uZmlnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgd2FpdEZvclN5bmMoY29uZmlnLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbmZpZy5fbGFzdEZhdGFsRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9uZXR3b3JrID0gYXdhaXQgY29uZmlnLnByb3ZpZGVyLmdldE5ldHdvcmsoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KSgpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuI2luaXRpYWxTeW5jUHJvbWlzZSA9IGluaXRpYWxTeW5jID0gKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFdhaXQgZm9yIGFsbCBwcm92aWRlcnMgdG8gaGF2ZSBhIGJsb2NrIG51bWJlciBhbmQgbmV0d29ya1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWxsIHRoZSBuZXR3b3JrcyBtYXRjaFxyXG4gICAgICAgICAgICAgICAgbGV0IGNoYWluSWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb25maWcgb2YgdGhpcy4jY29uZmlncykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcuX2xhc3RGYXRhbEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gKGNvbmZpZy5fbmV0d29yayk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYWluSWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkID0gbmV0d29yay5jaGFpbklkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXR3b3JrLmNoYWluSWQgIT09IGNoYWluSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNhbm5vdCBtaXggcHJvdmlkZXJzIG9uIGRpZmZlcmVudCBuZXR3b3Jrc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IEZhbGxiYWNrUHJvdmlkZXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IGluaXRpYWxTeW5jO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgI2NoZWNrUXVvcnVtKHJ1bm5pbmcsIHJlcSkge1xyXG4gICAgICAgIC8vIEdldCBhbGwgdGhlIHJlc3VsdCBvYmplY3RzXHJcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgcnVubmVyIG9mIHJ1bm5pbmcpIHtcclxuICAgICAgICAgICAgaWYgKHJ1bm5lci5yZXN1bHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB0YWcsIHZhbHVlIH0gPSBub3JtYWxpemVSZXN1bHQocmVxLm1ldGhvZCwgcnVubmVyLnJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeyB0YWcsIHZhbHVlLCB3ZWlnaHQ6IHJ1bm5lci5jb25maWcud2VpZ2h0IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFyZSB0aGVyZSBlbm91Z2ggcmVzdWx0cyB0byBldmVudCBtZWV0IHF1b3J1bT9cclxuICAgICAgICBpZiAocmVzdWx0cy5yZWR1Y2UoKGEsIHIpID0+IChhICsgci53ZWlnaHQpLCAwKSA8IHRoaXMucXVvcnVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAocmVxLm1ldGhvZCkge1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjoge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBnZXQgdGhlIGJvb3RzdHJhcCBibG9jayBoZWlnaHRcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoZWlnaHQgPT09IC0yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jaGVpZ2h0ID0gTWF0aC5jZWlsKGdldE51bWJlcihnZXRNZWRpYW4odGhpcy5xdW9ydW0sIHRoaXMuI2NvbmZpZ3MuZmlsdGVyKChjKSA9PiAoIWMuX2xhc3RGYXRhbEVycm9yKSkubWFwKChjKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYy5ibG9ja051bWJlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiBnZXROdW1iZXIoYy5ibG9ja051bWJlcikudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0OiBjLndlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1vZGUgYWNyb3NzIGFsbCB0aGUgcHJvdmlkZXJzLCBhbGxvd2luZyBmb3JcclxuICAgICAgICAgICAgICAgIC8vIGEgbGl0dGxlIGRyaWZ0IGJldHdlZW4gYmxvY2sgaGVpZ2h0c1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZSA9IGdldEZ1enp5TW9kZSh0aGlzLnF1b3J1bSwgcmVzdWx0cyk7XHJcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtb2RlID4gdGhpcy4jaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jaGVpZ2h0ID0gbW9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiNoZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJnZXRQcmlvcml0eUZlZVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRNZWRpYW4odGhpcy5xdW9ydW0sIHJlc3VsdHMpO1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjpcclxuICAgICAgICAgICAgICAgIC8vIFBlbmRpbmcgYmxvY2tzIGFyZSBpbiB0aGUgbWVtcG9vbCBhbmQgYWxyZWFkeVxyXG4gICAgICAgICAgICAgICAgLy8gcXVpdGUgdW50cnVzdHdvcnRoeTsganVzdCBncmFiIGFueXRoaW5nXHJcbiAgICAgICAgICAgICAgICBpZiAoXCJibG9ja1RhZ1wiIGluIHJlcSAmJiByZXEuYmxvY2tUYWcgPT09IFwicGVuZGluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEFueVJlc3VsdCh0aGlzLnF1b3J1bSwgcmVzdWx0cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tRdW9ydW0odGhpcy5xdW9ydW0sIHJlc3VsdHMpO1xyXG4gICAgICAgICAgICBjYXNlIFwiY2FsbFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiY2hhaW5JZFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcclxuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUXVvcnVtKHRoaXMucXVvcnVtLCByZXN1bHRzKTtcclxuICAgICAgICAgICAgY2FzZSBcImJyb2FkY2FzdFRyYW5zYWN0aW9uXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QW55UmVzdWx0KHRoaXMucXVvcnVtLCByZXN1bHRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIG1ldGhvZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogYF9wZXJmb3JtKCR7c3RyaW5naWZ5KHJlcS5tZXRob2QpfSlgXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyAjd2FpdEZvclF1b3J1bShydW5uaW5nLCByZXEpIHtcclxuICAgICAgICBpZiAocnVubmluZy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIHJ1bm5lcnM/IVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQW55IHByb21pc2VzIHRoYXQgYXJlIGludGVyZXN0aW5nIHRvIHdhdGNoIGZvcjsgYW4gZXhwaXJlZCBzdGFsbFxyXG4gICAgICAgIC8vIG9yIGEgc3VjY2Vzc2Z1bCBwZXJmb3JtXHJcbiAgICAgICAgY29uc3QgaW50ZXJlc3RpbmcgPSBbXTtcclxuICAgICAgICBsZXQgbmV3UnVubmVycyA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBydW5uZXIgb2YgcnVubmluZykge1xyXG4gICAgICAgICAgICAvLyBObyByZXNwb25zZXMsIHlldDsga2VlcCBhbiBleWUgb24gaXRcclxuICAgICAgICAgICAgaWYgKHJ1bm5lci5wZXJmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICBpbnRlcmVzdGluZy5wdXNoKHJ1bm5lci5wZXJmb3JtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTdGlsbCBzdGFsbGluZy4uLlxyXG4gICAgICAgICAgICBpZiAocnVubmVyLnN0YWxsZXIpIHtcclxuICAgICAgICAgICAgICAgIGludGVyZXN0aW5nLnB1c2gocnVubmVyLnN0YWxsZXIpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVGhpcyBydW5uZXIgaGFzIGFscmVhZHkgdHJpZ2dlcmVkIGFub3RoZXIgcnVubmVyXHJcbiAgICAgICAgICAgIGlmIChydW5uZXIuZGlkQnVtcCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gR290IGEgcmVzcG9uc2UgKHJlc3VsdCBvciBlcnJvcikgb3Igc3RhbGxlZDsga2ljayBvZmYgYW5vdGhlciBydW5uZXJcclxuICAgICAgICAgICAgcnVubmVyLmRpZEJ1bXAgPSB0cnVlO1xyXG4gICAgICAgICAgICBuZXdSdW5uZXJzKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgcmVhY2hlZCBxdW9ydW0gb24gYSByZXN1bHQgKG9yIGVycm9yKVxyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy4jY2hlY2tRdW9ydW0ocnVubmluZywgcmVxKTtcclxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgYW55IG5ldyBydW5uZXJzLCBiZWNhdXNlIGEgc3RhbGxlciB0aW1lZCBvdXQgb3IgYSByZXN1bHRcclxuICAgICAgICAvLyBvciBlcnJvciByZXNwb25zZSBjYW1lIGluLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3UnVubmVyczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuI2FkZFJ1bm5lcihydW5uaW5nLCByZXEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBbGwgcHJvdmlkZXJzIGhhdmUgcmV0dXJuZWQsIGFuZCB3ZSBoYXZlIG5vIHJlc3VsdFxyXG4gICAgICAgIGFzc2VydChpbnRlcmVzdGluZy5sZW5ndGggPiAwLCBcInF1b3J1bSBub3QgbWV0XCIsIFwiU0VSVkVSX0VSUk9SXCIsIHtcclxuICAgICAgICAgICAgcmVxdWVzdDogXCIlc3ViLXJlcXVlc3RzXCIsXHJcbiAgICAgICAgICAgIGluZm86IHsgcmVxdWVzdDogcmVxLCByZXN1bHRzOiBBcnJheS5mcm9tKHJ1bm5pbmcpLm1hcCgocikgPT4gc3RyaW5naWZ5KHIucmVzdWx0KSkgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFdhaXQgZm9yIHNvbWVvbmUgdG8gZWl0aGVyIGNvbXBsZXRlIGl0cyBwZXJmb3JtIG9yIHN0YWxsIG91dFxyXG4gICAgICAgIGF3YWl0IFByb21pc2UucmFjZShpbnRlcmVzdGluZyk7XHJcbiAgICAgICAgLy8gVGhpcyBpcyByZWN1cnNpdmUsIGJ1dCBhdCB3b3JzdCBjYXNlIHRoZSBkZXB0aCBpcyAyeCB0aGVcclxuICAgICAgICAvLyBudW1iZXIgb2YgcHJvdmlkZXJzIChlYWNoIGhhcyBhIHBlcmZvcm0gYW5kIGEgc3RhbGxlcilcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jd2FpdEZvclF1b3J1bShydW5uaW5nLCByZXEpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgX3BlcmZvcm0ocmVxKSB7XHJcbiAgICAgICAgLy8gQnJvYWRjYXN0aW5nIGEgdHJhbnNhY3Rpb24gaXMgcmFyZSAoaXNoKSBhbmQgYWxyZWFkeSBpbmN1cnNcclxuICAgICAgICAvLyBhIGNvc3Qgb24gdGhlIHVzZXIsIHNvIHNwYW1taW5nIGlzIHNhZmUtaXNoLiBKdXN0IHNlbmQgaXQgdG9cclxuICAgICAgICAvLyBldmVyeSBiYWNrZW5kLlxyXG4gICAgICAgIGlmIChyZXEubWV0aG9kID09PSBcImJyb2FkY2FzdFRyYW5zYWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgLy8gT25jZSBhbnkgYnJvYWRjYXN0IHByb3ZpZGVzIGEgcG9zaXRpdmUgcmVzdWx0LCB1c2UgaXQuIE5vXHJcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gd2FpdCBmb3IgYW55b25lIGVsc2VcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IHRoaXMuI2NvbmZpZ3MubWFwKChjKSA9PiBudWxsKTtcclxuICAgICAgICAgICAgY29uc3QgYnJvYWRjYXN0cyA9IHRoaXMuI2NvbmZpZ3MubWFwKGFzeW5jICh7IHByb3ZpZGVyLCB3ZWlnaHQgfSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvdmlkZXIuX3BlcmZvcm0ocmVxKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IE9iamVjdC5hc3NpZ24obm9ybWFsaXplUmVzdWx0KHJlcS5tZXRob2QsIHsgcmVzdWx0IH0pLCB7IHdlaWdodCB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gT2JqZWN0LmFzc2lnbihub3JtYWxpemVSZXN1bHQocmVxLm1ldGhvZCwgeyBlcnJvciB9KSwgeyB3ZWlnaHQgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBBcyBlYWNoIHByb21pc2UgZmluaXNoZXMuLi5cclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIHZhbGlkIGJyb2FkY2FzdCByZXN1bHRcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvbmUgPSByZXN1bHRzLmZpbHRlcigocikgPT4gKHIgIT0gbnVsbCkpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHZhbHVlIH0gb2YgZG9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgYSBsZWdpdCBicm9hZGNhc3QgZXJyb3IgKG9uZSB3aGljaCB3ZSBjYW5ub3RcclxuICAgICAgICAgICAgICAgIC8vIHJlY292ZXIgZnJvbTsgc29tZSBub2RlcyBtYXkgcmV0dXJuIHRoZSBmb2xsb3dpbmcgcmVkXHJcbiAgICAgICAgICAgICAgICAvLyBoZXJyaW5nIGV2ZW50czpcclxuICAgICAgICAgICAgICAgIC8vIC0gYWxyZWR5IHNlZW5kIChVTktOT1dOX0VSUk9SKVxyXG4gICAgICAgICAgICAgICAgLy8gLSBOT05DRV9FWFBJUkVEXHJcbiAgICAgICAgICAgICAgICAvLyAtIFJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjaGVja1F1b3J1bSh0aGlzLnF1b3J1bSwgcmVzdWx0cy5maWx0ZXIoKHIpID0+IChyICE9IG51bGwpKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihyZXN1bHQsIFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gS2ljayBvZmYgdGhlIG5leHQgcHJvdmlkZXIgKGlmIGFueSlcclxuICAgICAgICAgICAgICAgIGNvbnN0IHdhaXRpbmcgPSBicm9hZGNhc3RzLmZpbHRlcigoYiwgaSkgPT4gKHJlc3VsdHNbaV0gPT0gbnVsbCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHdhaXRpbmcubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2Uod2FpdGluZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVXNlIHN0YW5kYXJkIHF1b3J1bSByZXN1bHRzOyBhbnkgcmVzdWx0IHdhcyByZXR1cm5lZCBhYm92ZSxcclxuICAgICAgICAgICAgLy8gc28gdGhpcyB3aWxsIGZpbmQgYW55IGVycm9yIHRoYXQgbWV0IHF1b3J1bSBpZiBhbnlcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0QW55UmVzdWx0KHRoaXMucXVvcnVtLCByZXN1bHRzKTtcclxuICAgICAgICAgICAgYXNzZXJ0KHJlc3VsdCAhPT0gdW5kZWZpbmVkLCBcInByb2JsZW0gbXVsdGktYnJvYWRjYXN0aW5nXCIsIFwiU0VSVkVSX0VSUk9SXCIsIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IFwiJXN1Yi1yZXF1ZXN0c1wiLFxyXG4gICAgICAgICAgICAgICAgaW5mbzogeyByZXF1ZXN0OiByZXEsIHJlc3VsdHM6IHJlc3VsdHMubWFwKHN0cmluZ2lmeSkgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXdhaXQgdGhpcy4jaW5pdGlhbFN5bmMoKTtcclxuICAgICAgICAvLyBCb290c3RyYXAgZW5vdWdoIHJ1bm5lcnMgdG8gbWVldCBxdW9ydW1cclxuICAgICAgICBjb25zdCBydW5uaW5nID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGxldCBpbmZsaWdodFF1b3J1bSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgY29uc3QgcnVubmVyID0gdGhpcy4jYWRkUnVubmVyKHJ1bm5pbmcsIHJlcSk7XHJcbiAgICAgICAgICAgIGlmIChydW5uZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW5mbGlnaHRRdW9ydW0gKz0gcnVubmVyLmNvbmZpZy53ZWlnaHQ7XHJcbiAgICAgICAgICAgIGlmIChpbmZsaWdodFF1b3J1bSA+PSB0aGlzLnF1b3J1bSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jd2FpdEZvclF1b3J1bShydW5uaW5nLCByZXEpO1xyXG4gICAgICAgIC8vIFRyYWNrIHJlcXVlc3RzIHNlbnQgdG8gYSBwcm92aWRlciB0aGF0IGFyZSBzdGlsbFxyXG4gICAgICAgIC8vIG91dHN0YW5kaW5nIGFmdGVyIHF1b3J1bSBoYXMgYmVlbiBvdGhlcndpc2UgZm91bmRcclxuICAgICAgICBmb3IgKGNvbnN0IHJ1bm5lciBvZiBydW5uaW5nKSB7XHJcbiAgICAgICAgICAgIGlmIChydW5uZXIucGVyZm9ybSAmJiBydW5uZXIucmVzdWx0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJ1bm5lci5jb25maWcubGF0ZVJlc3BvbnNlcysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBhc3luYyBkZXN0cm95KCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgeyBwcm92aWRlciB9IG9mIHRoaXMuI2NvbmZpZ3MpIHtcclxuICAgICAgICAgICAgcHJvdmlkZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItZmFsbGJhY2suanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-fallback.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-infura.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-infura.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InfuraProvider: () => (/* binding */ InfuraProvider),\n/* harmony export */   InfuraWebSocketProvider: () => (/* binding */ InfuraWebSocketProvider)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _community_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./community.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/community.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./network.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var _provider_websocket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider-websocket.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-websocket.js\");\n/**\r\n *  [[link-infura]] provides a third-party service for connecting to\r\n *  various blockchains over JSON-RPC.\r\n *\r\n *  **Supported Networks**\r\n *\r\n *  - Ethereum Mainnet (``mainnet``)\r\n *  - Goerli Testnet (``goerli``)\r\n *  - Sepolia Testnet (``sepolia``)\r\n *  - Arbitrum (``arbitrum``)\r\n *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)\r\n *  - Arbitrum Sepolia Testnet (``arbitrum-sepolia``)\r\n *  - Base (``base``)\r\n *  - Base Goerlia Testnet (``base-goerli``)\r\n *  - Base Sepolia Testnet (``base-sepolia``)\r\n *  - BNB Smart Chain Mainnet (``bnb``)\r\n *  - BNB Smart Chain Testnet (``bnbt``)\r\n *  - Linea (``linea``)\r\n *  - Linea Goerli Testnet (``linea-goerli``)\r\n *  - Linea Sepolia Testnet (``linea-sepolia``)\r\n *  - Optimism (``optimism``)\r\n *  - Optimism Goerli Testnet (``optimism-goerli``)\r\n *  - Optimism Sepolia Testnet (``optimism-sepolia``)\r\n *  - Polygon (``matic``)\r\n *  - Polygon Amoy Testnet (``matic-amoy``)\r\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\r\n *\r\n *  @_subsection: api/providers/thirdparty:INFURA  [providers-infura]\r\n */\r\n\r\n\r\n\r\n\r\n\r\nconst defaultProjectId = \"84842078b09946638c03157f83405213\";\r\nfunction getHost(name) {\r\n    switch (name) {\r\n        case \"mainnet\":\r\n            return \"mainnet.infura.io\";\r\n        case \"goerli\":\r\n            return \"goerli.infura.io\";\r\n        case \"sepolia\":\r\n            return \"sepolia.infura.io\";\r\n        case \"arbitrum\":\r\n            return \"arbitrum-mainnet.infura.io\";\r\n        case \"arbitrum-goerli\":\r\n            return \"arbitrum-goerli.infura.io\";\r\n        case \"arbitrum-sepolia\":\r\n            return \"arbitrum-sepolia.infura.io\";\r\n        case \"base\":\r\n            return \"base-mainnet.infura.io\";\r\n        case \"base-goerlia\": // @TODO: Remove this typo in the future!\r\n        case \"base-goerli\":\r\n            return \"base-goerli.infura.io\";\r\n        case \"base-sepolia\":\r\n            return \"base-sepolia.infura.io\";\r\n        case \"bnb\":\r\n            return \"bsc-mainnet.infura.io\";\r\n        case \"bnbt\":\r\n            return \"bsc-testnet.infura.io\";\r\n        case \"linea\":\r\n            return \"linea-mainnet.infura.io\";\r\n        case \"linea-goerli\":\r\n            return \"linea-goerli.infura.io\";\r\n        case \"linea-sepolia\":\r\n            return \"linea-sepolia.infura.io\";\r\n        case \"matic\":\r\n            return \"polygon-mainnet.infura.io\";\r\n        case \"matic-amoy\":\r\n            return \"polygon-amoy.infura.io\";\r\n        case \"matic-mumbai\":\r\n            return \"polygon-mumbai.infura.io\";\r\n        case \"optimism\":\r\n            return \"optimism-mainnet.infura.io\";\r\n        case \"optimism-goerli\":\r\n            return \"optimism-goerli.infura.io\";\r\n        case \"optimism-sepolia\":\r\n            return \"optimism-sepolia.infura.io\";\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported network\", \"network\", name);\r\n}\r\n/**\r\n *  The **InfuraWebSocketProvider** connects to the [[link-infura]]\r\n *  WebSocket end-points.\r\n *\r\n *  By default, a highly-throttled API key is used, which is\r\n *  appropriate for quick prototypes and simple scripts. To\r\n *  gain access to an increased rate-limit, it is highly\r\n *  recommended to [sign up here](link-infura-signup).\r\n */\r\nclass InfuraWebSocketProvider extends _provider_websocket_js__WEBPACK_IMPORTED_MODULE_1__.WebSocketProvider {\r\n    /**\r\n     *  The Project ID for the INFURA connection.\r\n     */\r\n    projectId;\r\n    /**\r\n     *  The Project Secret.\r\n     *\r\n     *  If null, no authenticated requests are made. This should not\r\n     *  be used outside of private contexts.\r\n     */\r\n    projectSecret;\r\n    /**\r\n     *  Creates a new **InfuraWebSocketProvider**.\r\n     */\r\n    constructor(network, projectId) {\r\n        const provider = new InfuraProvider(network, projectId);\r\n        const req = provider._getConnection();\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!req.credentials, \"INFURA WebSocket project secrets unsupported\", \"UNSUPPORTED_OPERATION\", { operation: \"InfuraProvider.getWebSocketProvider()\" });\r\n        const url = req.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\r\n        super(url, provider._network);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\r\n            projectId: provider.projectId,\r\n            projectSecret: provider.projectSecret\r\n        });\r\n    }\r\n    isCommunityResource() {\r\n        return (this.projectId === defaultProjectId);\r\n    }\r\n}\r\n/**\r\n *  The **InfuraProvider** connects to the [[link-infura]]\r\n *  JSON-RPC end-points.\r\n *\r\n *  By default, a highly-throttled API key is used, which is\r\n *  appropriate for quick prototypes and simple scripts. To\r\n *  gain access to an increased rate-limit, it is highly\r\n *  recommended to [sign up here](link-infura-signup).\r\n */\r\nclass InfuraProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider {\r\n    /**\r\n     *  The Project ID for the INFURA connection.\r\n     */\r\n    projectId;\r\n    /**\r\n     *  The Project Secret.\r\n     *\r\n     *  If null, no authenticated requests are made. This should not\r\n     *  be used outside of private contexts.\r\n     */\r\n    projectSecret;\r\n    /**\r\n     *  Creates a new **InfuraProvider**.\r\n     */\r\n    constructor(_network, projectId, projectSecret) {\r\n        if (_network == null) {\r\n            _network = \"mainnet\";\r\n        }\r\n        const network = _network_js__WEBPACK_IMPORTED_MODULE_3__.Network.from(_network);\r\n        if (projectId == null) {\r\n            projectId = defaultProjectId;\r\n        }\r\n        if (projectSecret == null) {\r\n            projectSecret = null;\r\n        }\r\n        const request = InfuraProvider.getRequest(network, projectId, projectSecret);\r\n        super(request, network, { staticNetwork: network });\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { projectId, projectSecret });\r\n    }\r\n    _getProvider(chainId) {\r\n        try {\r\n            return new InfuraProvider(chainId, this.projectId, this.projectSecret);\r\n        }\r\n        catch (error) { }\r\n        return super._getProvider(chainId);\r\n    }\r\n    isCommunityResource() {\r\n        return (this.projectId === defaultProjectId);\r\n    }\r\n    /**\r\n     *  Creates a new **InfuraWebSocketProvider**.\r\n     */\r\n    static getWebSocketProvider(network, projectId) {\r\n        return new InfuraWebSocketProvider(network, projectId);\r\n    }\r\n    /**\r\n     *  Returns a prepared request for connecting to %%network%%\r\n     *  with %%projectId%% and %%projectSecret%%.\r\n     */\r\n    static getRequest(network, projectId, projectSecret) {\r\n        if (projectId == null) {\r\n            projectId = defaultProjectId;\r\n        }\r\n        if (projectSecret == null) {\r\n            projectSecret = null;\r\n        }\r\n        const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(`https:/\\/${getHost(network.name)}/v3/${projectId}`);\r\n        request.allowGzip = true;\r\n        if (projectSecret) {\r\n            request.setCredentials(\"\", projectSecret);\r\n        }\r\n        if (projectId === defaultProjectId) {\r\n            request.retryFunc = async (request, response, attempt) => {\r\n                (0,_community_js__WEBPACK_IMPORTED_MODULE_4__.showThrottleMessage)(\"InfuraProvider\");\r\n                return true;\r\n            };\r\n        }\r\n        return request;\r\n    }\r\n}\r\n//# sourceMappingURL=provider-infura.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItaW5mdXJhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzJGO0FBQ3RDO0FBQ2Q7QUFDaUI7QUFDSTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sc0NBQXNDLHFFQUFpQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBTSw4RkFBOEYsb0RBQW9EO0FBQ2hLO0FBQ0E7QUFDQSxRQUFRLGlFQUFnQjtBQUN4QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw2QkFBNkIsaUVBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdEQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdCQUF3QjtBQUMxRCxRQUFRLGlFQUFnQixTQUFTLDBCQUEwQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5REFBWSxhQUFhLHNCQUFzQixNQUFNLFVBQVU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtFQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxwcm92aWRlcnNcXHByb3ZpZGVyLWluZnVyYS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIFtbbGluay1pbmZ1cmFdXSBwcm92aWRlcyBhIHRoaXJkLXBhcnR5IHNlcnZpY2UgZm9yIGNvbm5lY3RpbmcgdG9cclxuICogIHZhcmlvdXMgYmxvY2tjaGFpbnMgb3ZlciBKU09OLVJQQy5cclxuICpcclxuICogICoqU3VwcG9ydGVkIE5ldHdvcmtzKipcclxuICpcclxuICogIC0gRXRoZXJldW0gTWFpbm5ldCAoYGBtYWlubmV0YGApXHJcbiAqICAtIEdvZXJsaSBUZXN0bmV0IChgYGdvZXJsaWBgKVxyXG4gKiAgLSBTZXBvbGlhIFRlc3RuZXQgKGBgc2Vwb2xpYWBgKVxyXG4gKiAgLSBBcmJpdHJ1bSAoYGBhcmJpdHJ1bWBgKVxyXG4gKiAgLSBBcmJpdHJ1bSBHb2VybGkgVGVzdG5ldCAoYGBhcmJpdHJ1bS1nb2VybGlgYClcclxuICogIC0gQXJiaXRydW0gU2Vwb2xpYSBUZXN0bmV0IChgYGFyYml0cnVtLXNlcG9saWFgYClcclxuICogIC0gQmFzZSAoYGBiYXNlYGApXHJcbiAqICAtIEJhc2UgR29lcmxpYSBUZXN0bmV0IChgYGJhc2UtZ29lcmxpYGApXHJcbiAqICAtIEJhc2UgU2Vwb2xpYSBUZXN0bmV0IChgYGJhc2Utc2Vwb2xpYWBgKVxyXG4gKiAgLSBCTkIgU21hcnQgQ2hhaW4gTWFpbm5ldCAoYGBibmJgYClcclxuICogIC0gQk5CIFNtYXJ0IENoYWluIFRlc3RuZXQgKGBgYm5idGBgKVxyXG4gKiAgLSBMaW5lYSAoYGBsaW5lYWBgKVxyXG4gKiAgLSBMaW5lYSBHb2VybGkgVGVzdG5ldCAoYGBsaW5lYS1nb2VybGlgYClcclxuICogIC0gTGluZWEgU2Vwb2xpYSBUZXN0bmV0IChgYGxpbmVhLXNlcG9saWFgYClcclxuICogIC0gT3B0aW1pc20gKGBgb3B0aW1pc21gYClcclxuICogIC0gT3B0aW1pc20gR29lcmxpIFRlc3RuZXQgKGBgb3B0aW1pc20tZ29lcmxpYGApXHJcbiAqICAtIE9wdGltaXNtIFNlcG9saWEgVGVzdG5ldCAoYGBvcHRpbWlzbS1zZXBvbGlhYGApXHJcbiAqICAtIFBvbHlnb24gKGBgbWF0aWNgYClcclxuICogIC0gUG9seWdvbiBBbW95IFRlc3RuZXQgKGBgbWF0aWMtYW1veWBgKVxyXG4gKiAgLSBQb2x5Z29uIE11bWJhaSBUZXN0bmV0IChgYG1hdGljLW11bWJhaWBgKVxyXG4gKlxyXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHk6SU5GVVJBICBbcHJvdmlkZXJzLWluZnVyYV1cclxuICovXHJcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIEZldGNoUmVxdWVzdCwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBzaG93VGhyb3R0bGVNZXNzYWdlIH0gZnJvbSBcIi4vY29tbXVuaXR5LmpzXCI7XHJcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XHJcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIjtcclxuaW1wb3J0IHsgV2ViU29ja2V0UHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci13ZWJzb2NrZXQuanNcIjtcclxuY29uc3QgZGVmYXVsdFByb2plY3RJZCA9IFwiODQ4NDIwNzhiMDk5NDY2MzhjMDMxNTdmODM0MDUyMTNcIjtcclxuZnVuY3Rpb24gZ2V0SG9zdChuYW1lKSB7XHJcbiAgICBzd2l0Y2ggKG5hbWUpIHtcclxuICAgICAgICBjYXNlIFwibWFpbm5ldFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJtYWlubmV0LmluZnVyYS5pb1wiO1xyXG4gICAgICAgIGNhc2UgXCJnb2VybGlcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFwiZ29lcmxpLmluZnVyYS5pb1wiO1xyXG4gICAgICAgIGNhc2UgXCJzZXBvbGlhXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcInNlcG9saWEuaW5mdXJhLmlvXCI7XHJcbiAgICAgICAgY2FzZSBcImFyYml0cnVtXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImFyYml0cnVtLW1haW5uZXQuaW5mdXJhLmlvXCI7XHJcbiAgICAgICAgY2FzZSBcImFyYml0cnVtLWdvZXJsaVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJhcmJpdHJ1bS1nb2VybGkuaW5mdXJhLmlvXCI7XHJcbiAgICAgICAgY2FzZSBcImFyYml0cnVtLXNlcG9saWFcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFwiYXJiaXRydW0tc2Vwb2xpYS5pbmZ1cmEuaW9cIjtcclxuICAgICAgICBjYXNlIFwiYmFzZVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJiYXNlLW1haW5uZXQuaW5mdXJhLmlvXCI7XHJcbiAgICAgICAgY2FzZSBcImJhc2UtZ29lcmxpYVwiOiAvLyBAVE9ETzogUmVtb3ZlIHRoaXMgdHlwbyBpbiB0aGUgZnV0dXJlIVxyXG4gICAgICAgIGNhc2UgXCJiYXNlLWdvZXJsaVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJiYXNlLWdvZXJsaS5pbmZ1cmEuaW9cIjtcclxuICAgICAgICBjYXNlIFwiYmFzZS1zZXBvbGlhXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImJhc2Utc2Vwb2xpYS5pbmZ1cmEuaW9cIjtcclxuICAgICAgICBjYXNlIFwiYm5iXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImJzYy1tYWlubmV0LmluZnVyYS5pb1wiO1xyXG4gICAgICAgIGNhc2UgXCJibmJ0XCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImJzYy10ZXN0bmV0LmluZnVyYS5pb1wiO1xyXG4gICAgICAgIGNhc2UgXCJsaW5lYVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJsaW5lYS1tYWlubmV0LmluZnVyYS5pb1wiO1xyXG4gICAgICAgIGNhc2UgXCJsaW5lYS1nb2VybGlcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFwibGluZWEtZ29lcmxpLmluZnVyYS5pb1wiO1xyXG4gICAgICAgIGNhc2UgXCJsaW5lYS1zZXBvbGlhXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImxpbmVhLXNlcG9saWEuaW5mdXJhLmlvXCI7XHJcbiAgICAgICAgY2FzZSBcIm1hdGljXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcInBvbHlnb24tbWFpbm5ldC5pbmZ1cmEuaW9cIjtcclxuICAgICAgICBjYXNlIFwibWF0aWMtYW1veVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJwb2x5Z29uLWFtb3kuaW5mdXJhLmlvXCI7XHJcbiAgICAgICAgY2FzZSBcIm1hdGljLW11bWJhaVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJwb2x5Z29uLW11bWJhaS5pbmZ1cmEuaW9cIjtcclxuICAgICAgICBjYXNlIFwib3B0aW1pc21cIjpcclxuICAgICAgICAgICAgcmV0dXJuIFwib3B0aW1pc20tbWFpbm5ldC5pbmZ1cmEuaW9cIjtcclxuICAgICAgICBjYXNlIFwib3B0aW1pc20tZ29lcmxpXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcIm9wdGltaXNtLWdvZXJsaS5pbmZ1cmEuaW9cIjtcclxuICAgICAgICBjYXNlIFwib3B0aW1pc20tc2Vwb2xpYVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJvcHRpbWlzbS1zZXBvbGlhLmluZnVyYS5pb1wiO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmFtZSk7XHJcbn1cclxuLyoqXHJcbiAqICBUaGUgKipJbmZ1cmFXZWJTb2NrZXRQcm92aWRlcioqIGNvbm5lY3RzIHRvIHRoZSBbW2xpbmstaW5mdXJhXV1cclxuICogIFdlYlNvY2tldCBlbmQtcG9pbnRzLlxyXG4gKlxyXG4gKiAgQnkgZGVmYXVsdCwgYSBoaWdobHktdGhyb3R0bGVkIEFQSSBrZXkgaXMgdXNlZCwgd2hpY2ggaXNcclxuICogIGFwcHJvcHJpYXRlIGZvciBxdWljayBwcm90b3R5cGVzIGFuZCBzaW1wbGUgc2NyaXB0cy4gVG9cclxuICogIGdhaW4gYWNjZXNzIHRvIGFuIGluY3JlYXNlZCByYXRlLWxpbWl0LCBpdCBpcyBoaWdobHlcclxuICogIHJlY29tbWVuZGVkIHRvIFtzaWduIHVwIGhlcmVdKGxpbmstaW5mdXJhLXNpZ251cCkuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIgZXh0ZW5kcyBXZWJTb2NrZXRQcm92aWRlciB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgUHJvamVjdCBJRCBmb3IgdGhlIElORlVSQSBjb25uZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBwcm9qZWN0SWQ7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgUHJvamVjdCBTZWNyZXQuXHJcbiAgICAgKlxyXG4gICAgICogIElmIG51bGwsIG5vIGF1dGhlbnRpY2F0ZWQgcmVxdWVzdHMgYXJlIG1hZGUuIFRoaXMgc2hvdWxkIG5vdFxyXG4gICAgICogIGJlIHVzZWQgb3V0c2lkZSBvZiBwcml2YXRlIGNvbnRleHRzLlxyXG4gICAgICovXHJcbiAgICBwcm9qZWN0U2VjcmV0O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkluZnVyYVdlYlNvY2tldFByb3ZpZGVyKiouXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmssIHByb2plY3RJZCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IEluZnVyYVByb3ZpZGVyKG5ldHdvcmssIHByb2plY3RJZCk7XHJcbiAgICAgICAgY29uc3QgcmVxID0gcHJvdmlkZXIuX2dldENvbm5lY3Rpb24oKTtcclxuICAgICAgICBhc3NlcnQoIXJlcS5jcmVkZW50aWFscywgXCJJTkZVUkEgV2ViU29ja2V0IHByb2plY3Qgc2VjcmV0cyB1bnN1cHBvcnRlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJJbmZ1cmFQcm92aWRlci5nZXRXZWJTb2NrZXRQcm92aWRlcigpXCIgfSk7XHJcbiAgICAgICAgY29uc3QgdXJsID0gcmVxLnVybC5yZXBsYWNlKC9eaHR0cC9pLCBcIndzXCIpLnJlcGxhY2UoXCIvdjMvXCIsIFwiL3dzL3YzL1wiKTtcclxuICAgICAgICBzdXBlcih1cmwsIHByb3ZpZGVyLl9uZXR3b3JrKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgICAgICAgICAgcHJvamVjdElkOiBwcm92aWRlci5wcm9qZWN0SWQsXHJcbiAgICAgICAgICAgIHByb2plY3RTZWNyZXQ6IHByb3ZpZGVyLnByb2plY3RTZWNyZXRcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnByb2plY3RJZCA9PT0gZGVmYXVsdFByb2plY3RJZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBUaGUgKipJbmZ1cmFQcm92aWRlcioqIGNvbm5lY3RzIHRvIHRoZSBbW2xpbmstaW5mdXJhXV1cclxuICogIEpTT04tUlBDIGVuZC1wb2ludHMuXHJcbiAqXHJcbiAqICBCeSBkZWZhdWx0LCBhIGhpZ2hseS10aHJvdHRsZWQgQVBJIGtleSBpcyB1c2VkLCB3aGljaCBpc1xyXG4gKiAgYXBwcm9wcmlhdGUgZm9yIHF1aWNrIHByb3RvdHlwZXMgYW5kIHNpbXBsZSBzY3JpcHRzLiBUb1xyXG4gKiAgZ2FpbiBhY2Nlc3MgdG8gYW4gaW5jcmVhc2VkIHJhdGUtbGltaXQsIGl0IGlzIGhpZ2hseVxyXG4gKiAgcmVjb21tZW5kZWQgdG8gW3NpZ24gdXAgaGVyZV0obGluay1pbmZ1cmEtc2lnbnVwKS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBJbmZ1cmFQcm92aWRlciBleHRlbmRzIEpzb25ScGNQcm92aWRlciB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgUHJvamVjdCBJRCBmb3IgdGhlIElORlVSQSBjb25uZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBwcm9qZWN0SWQ7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgUHJvamVjdCBTZWNyZXQuXHJcbiAgICAgKlxyXG4gICAgICogIElmIG51bGwsIG5vIGF1dGhlbnRpY2F0ZWQgcmVxdWVzdHMgYXJlIG1hZGUuIFRoaXMgc2hvdWxkIG5vdFxyXG4gICAgICogIGJlIHVzZWQgb3V0c2lkZSBvZiBwcml2YXRlIGNvbnRleHRzLlxyXG4gICAgICovXHJcbiAgICBwcm9qZWN0U2VjcmV0O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkluZnVyYVByb3ZpZGVyKiouXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCBwcm9qZWN0SWQsIHByb2plY3RTZWNyZXQpIHtcclxuICAgICAgICBpZiAoX25ldHdvcmsgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBfbmV0d29yayA9IFwibWFpbm5ldFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXR3b3JrID0gTmV0d29yay5mcm9tKF9uZXR3b3JrKTtcclxuICAgICAgICBpZiAocHJvamVjdElkID09IG51bGwpIHtcclxuICAgICAgICAgICAgcHJvamVjdElkID0gZGVmYXVsdFByb2plY3RJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb2plY3RTZWNyZXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwcm9qZWN0U2VjcmV0ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IEluZnVyYVByb3ZpZGVyLmdldFJlcXVlc3QobmV0d29yaywgcHJvamVjdElkLCBwcm9qZWN0U2VjcmV0KTtcclxuICAgICAgICBzdXBlcihyZXF1ZXN0LCBuZXR3b3JrLCB7IHN0YXRpY05ldHdvcms6IG5ldHdvcmsgfSk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHByb2plY3RJZCwgcHJvamVjdFNlY3JldCB9KTtcclxuICAgIH1cclxuICAgIF9nZXRQcm92aWRlcihjaGFpbklkKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmZ1cmFQcm92aWRlcihjaGFpbklkLCB0aGlzLnByb2plY3RJZCwgdGhpcy5wcm9qZWN0U2VjcmV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFByb3ZpZGVyKGNoYWluSWQpO1xyXG4gICAgfVxyXG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMucHJvamVjdElkID09PSBkZWZhdWx0UHJvamVjdElkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipJbmZ1cmFXZWJTb2NrZXRQcm92aWRlcioqLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0V2ViU29ja2V0UHJvdmlkZXIobmV0d29yaywgcHJvamVjdElkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrLCBwcm9qZWN0SWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIHByZXBhcmVkIHJlcXVlc3QgZm9yIGNvbm5lY3RpbmcgdG8gJSVuZXR3b3JrJSVcclxuICAgICAqICB3aXRoICUlcHJvamVjdElkJSUgYW5kICUlcHJvamVjdFNlY3JldCUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0UmVxdWVzdChuZXR3b3JrLCBwcm9qZWN0SWQsIHByb2plY3RTZWNyZXQpIHtcclxuICAgICAgICBpZiAocHJvamVjdElkID09IG51bGwpIHtcclxuICAgICAgICAgICAgcHJvamVjdElkID0gZGVmYXVsdFByb2plY3RJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb2plY3RTZWNyZXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwcm9qZWN0U2VjcmV0ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBGZXRjaFJlcXVlc3QoYGh0dHBzOi9cXC8ke2dldEhvc3QobmV0d29yay5uYW1lKX0vdjMvJHtwcm9qZWN0SWR9YCk7XHJcbiAgICAgICAgcmVxdWVzdC5hbGxvd0d6aXAgPSB0cnVlO1xyXG4gICAgICAgIGlmIChwcm9qZWN0U2VjcmV0KSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3Quc2V0Q3JlZGVudGlhbHMoXCJcIiwgcHJvamVjdFNlY3JldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9qZWN0SWQgPT09IGRlZmF1bHRQcm9qZWN0SWQpIHtcclxuICAgICAgICAgICAgcmVxdWVzdC5yZXRyeUZ1bmMgPSBhc3luYyAocmVxdWVzdCwgcmVzcG9uc2UsIGF0dGVtcHQpID0+IHtcclxuICAgICAgICAgICAgICAgIHNob3dUaHJvdHRsZU1lc3NhZ2UoXCJJbmZ1cmFQcm92aWRlclwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1pbmZ1cmEuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-infura.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-ipcsocket-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-ipcsocket-browser.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IpcSocketProvider: () => (/* binding */ IpcSocketProvider)\n/* harmony export */ });\nconst IpcSocketProvider = undefined;\r\n\r\n//# sourceMappingURL=provider-ipcsocket-browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItaXBjc29ja2V0LWJyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQzZCO0FBQzdCIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHByb3ZpZGVyc1xccHJvdmlkZXItaXBjc29ja2V0LWJyb3dzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgSXBjU29ja2V0UHJvdmlkZXIgPSB1bmRlZmluZWQ7XHJcbmV4cG9ydCB7IElwY1NvY2tldFByb3ZpZGVyIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWlwY3NvY2tldC1icm93c2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-ipcsocket-browser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonRpcApiPollingProvider: () => (/* binding */ JsonRpcApiPollingProvider),\n/* harmony export */   JsonRpcApiProvider: () => (/* binding */ JsonRpcApiProvider),\n/* harmony export */   JsonRpcProvider: () => (/* binding */ JsonRpcProvider),\n/* harmony export */   JsonRpcSigner: () => (/* binding */ JsonRpcSigner)\n/* harmony export */ });\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../abi/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/abi/index.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../hash/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../transaction/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _abstract_provider_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract-provider.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/abstract-provider.js\");\n/* harmony import */ var _abstract_signer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-signer.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/abstract-signer.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./network.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./subscriber-filterid.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/subscriber-filterid.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n/**\r\n *  One of the most common ways to interact with the blockchain is\r\n *  by a node running a JSON-RPC interface which can be connected to,\r\n *  based on the transport, using:\r\n *\r\n *  - HTTP or HTTPS - [[JsonRpcProvider]]\r\n *  - WebSocket - [[WebSocketProvider]]\r\n *  - IPC - [[IpcSocketProvider]]\r\n *\r\n * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]\r\n */\r\n// @TODO:\r\n// - Add the batching API\r\n// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst Primitive = \"bigint,boolean,function,number,string,symbol\".split(/,/g);\r\n//const Methods = \"getAddress,then\".split(/,/g);\r\nfunction deepCopy(value) {\r\n    if (value == null || Primitive.indexOf(typeof (value)) >= 0) {\r\n        return value;\r\n    }\r\n    // Keep any Addressable\r\n    if (typeof (value.getAddress) === \"function\") {\r\n        return value;\r\n    }\r\n    if (Array.isArray(value)) {\r\n        return (value.map(deepCopy));\r\n    }\r\n    if (typeof (value) === \"object\") {\r\n        return Object.keys(value).reduce((accum, key) => {\r\n            accum[key] = value[key];\r\n            return accum;\r\n        }, {});\r\n    }\r\n    throw new Error(`should not happen: ${value} (${typeof (value)})`);\r\n}\r\nfunction stall(duration) {\r\n    return new Promise((resolve) => { setTimeout(resolve, duration); });\r\n}\r\nfunction getLowerCase(value) {\r\n    if (value) {\r\n        return value.toLowerCase();\r\n    }\r\n    return value;\r\n}\r\nfunction isPollable(value) {\r\n    return (value && typeof (value.pollingInterval) === \"number\");\r\n}\r\nconst defaultOptions = {\r\n    polling: false,\r\n    staticNetwork: null,\r\n    batchStallTime: 10,\r\n    batchMaxSize: (1 << 20),\r\n    batchMaxCount: 100,\r\n    cacheTimeout: 250,\r\n    pollingInterval: 4000\r\n};\r\n// @TODO: Unchecked Signers\r\nclass JsonRpcSigner extends _abstract_signer_js__WEBPACK_IMPORTED_MODULE_0__.AbstractSigner {\r\n    address;\r\n    constructor(provider, address) {\r\n        super(provider);\r\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, { address });\r\n    }\r\n    connect(provider) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"cannot reconnect JsonRpcSigner\", \"UNSUPPORTED_OPERATION\", {\r\n            operation: \"signer.connect\"\r\n        });\r\n    }\r\n    async getAddress() {\r\n        return this.address;\r\n    }\r\n    // JSON-RPC will automatially fill in nonce, etc. so we just check from\r\n    async populateTransaction(tx) {\r\n        return await this.populateCall(tx);\r\n    }\r\n    // Returns just the hash of the transaction after sent, which is what\r\n    // the bare JSON-RPC API does;\r\n    async sendUncheckedTransaction(_tx) {\r\n        const tx = deepCopy(_tx);\r\n        const promises = [];\r\n        // Make sure the from matches the sender\r\n        if (tx.from) {\r\n            const _from = tx.from;\r\n            promises.push((async () => {\r\n                const from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(_from, this.provider);\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\r\n                tx.from = from;\r\n            })());\r\n        }\r\n        else {\r\n            tx.from = this.address;\r\n        }\r\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\r\n        // wishes to use this, it is easy to specify explicitly, otherwise\r\n        // we look it up for them.\r\n        if (tx.gasLimit == null) {\r\n            promises.push((async () => {\r\n                tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });\r\n            })());\r\n        }\r\n        // The address may be an ENS name or Addressable\r\n        if (tx.to != null) {\r\n            const _to = tx.to;\r\n            promises.push((async () => {\r\n                tx.to = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(_to, this.provider);\r\n            })());\r\n        }\r\n        // Wait until all of our properties are filled in\r\n        if (promises.length) {\r\n            await Promise.all(promises);\r\n        }\r\n        const hexTx = this.provider.getRpcTransaction(tx);\r\n        return this.provider.send(\"eth_sendTransaction\", [hexTx]);\r\n    }\r\n    async sendTransaction(tx) {\r\n        // This cannot be mined any earlier than any recent block\r\n        const blockNumber = await this.provider.getBlockNumber();\r\n        // Send the transaction\r\n        const hash = await this.sendUncheckedTransaction(tx);\r\n        // Unfortunately, JSON-RPC only provides and opaque transaction hash\r\n        // for a response, and we need the actual transaction, so we poll\r\n        // for it; it should show up very quickly\r\n        return await (new Promise((resolve, reject) => {\r\n            const timeouts = [1000, 100];\r\n            let invalids = 0;\r\n            const checkTx = async () => {\r\n                try {\r\n                    // Try getting the transaction\r\n                    const tx = await this.provider.getTransaction(hash);\r\n                    if (tx != null) {\r\n                        resolve(tx.replaceableTransaction(blockNumber));\r\n                        return;\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    // If we were cancelled: stop polling.\r\n                    // If the data is bad: the node returns bad transactions\r\n                    // If the network changed: calling again will also fail\r\n                    // If unsupported: likely destroyed\r\n                    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.isError)(error, \"CANCELLED\") || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.isError)(error, \"BAD_DATA\") ||\r\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.isError)(error, \"NETWORK_ERROR\") || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.isError)(error, \"UNSUPPORTED_OPERATION\")) {\r\n                        if (error.info == null) {\r\n                            error.info = {};\r\n                        }\r\n                        error.info.sendTransactionHash = hash;\r\n                        reject(error);\r\n                        return;\r\n                    }\r\n                    // Stop-gap for misbehaving backends; see #4513\r\n                    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.isError)(error, \"INVALID_ARGUMENT\")) {\r\n                        invalids++;\r\n                        if (error.info == null) {\r\n                            error.info = {};\r\n                        }\r\n                        error.info.sendTransactionHash = hash;\r\n                        if (invalids > 10) {\r\n                            reject(error);\r\n                            return;\r\n                        }\r\n                    }\r\n                    // Notify anyone that cares; but we will try again, since\r\n                    // it is likely an intermittent service error\r\n                    this.provider.emit(\"error\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"failed to fetch transation after sending (will try again)\", \"UNKNOWN_ERROR\", { error }));\r\n                }\r\n                // Wait another 4 seconds\r\n                this.provider._setTimeout(() => { checkTx(); }, timeouts.pop() || 4000);\r\n            };\r\n            checkTx();\r\n        }));\r\n    }\r\n    async signTransaction(_tx) {\r\n        const tx = deepCopy(_tx);\r\n        // Make sure the from matches the sender\r\n        if (tx.from) {\r\n            const from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(tx.from, this.provider);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\r\n            tx.from = from;\r\n        }\r\n        else {\r\n            tx.from = this.address;\r\n        }\r\n        const hexTx = this.provider.getRpcTransaction(tx);\r\n        return await this.provider.send(\"eth_signTransaction\", [hexTx]);\r\n    }\r\n    async signMessage(_message) {\r\n        const message = ((typeof (_message) === \"string\") ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toUtf8Bytes)(_message) : _message);\r\n        return await this.provider.send(\"personal_sign\", [\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(message), this.address.toLowerCase()\r\n        ]);\r\n    }\r\n    async signTypedData(domain, types, _value) {\r\n        const value = deepCopy(_value);\r\n        // Populate any ENS names (in-place)\r\n        const populated = await _hash_index_js__WEBPACK_IMPORTED_MODULE_3__.TypedDataEncoder.resolveNames(domain, types, value, async (value) => {\r\n            const address = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(value);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(address != null, \"TypedData does not support null address\", \"value\", value);\r\n            return address;\r\n        });\r\n        return await this.provider.send(\"eth_signTypedData_v4\", [\r\n            this.address.toLowerCase(),\r\n            JSON.stringify(_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.TypedDataEncoder.getPayload(populated.domain, types, populated.value))\r\n        ]);\r\n    }\r\n    async unlock(password) {\r\n        return this.provider.send(\"personal_unlockAccount\", [\r\n            this.address.toLowerCase(), password, null\r\n        ]);\r\n    }\r\n    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\r\n    async _legacySignMessage(_message) {\r\n        const message = ((typeof (_message) === \"string\") ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toUtf8Bytes)(_message) : _message);\r\n        return await this.provider.send(\"eth_sign\", [\r\n            this.address.toLowerCase(), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(message)\r\n        ]);\r\n    }\r\n}\r\n/**\r\n *  The JsonRpcApiProvider is an abstract class and **MUST** be\r\n *  sub-classed.\r\n *\r\n *  It provides the base for all JSON-RPC-based Provider interaction.\r\n *\r\n *  Sub-classing Notes:\r\n *  - a sub-class MUST override _send\r\n *  - a sub-class MUST call the `_start()` method once connected\r\n */\r\nclass JsonRpcApiProvider extends _abstract_provider_js__WEBPACK_IMPORTED_MODULE_4__.AbstractProvider {\r\n    #options;\r\n    // The next ID to use for the JSON-RPC ID field\r\n    #nextId;\r\n    // Payloads are queued and triggered in batches using the drainTimer\r\n    #payloads;\r\n    #drainTimer;\r\n    #notReady;\r\n    #network;\r\n    #pendingDetectNetwork;\r\n    #scheduleDrain() {\r\n        if (this.#drainTimer) {\r\n            return;\r\n        }\r\n        // If we aren't using batching, no harm in sending it immediately\r\n        const stallTime = (this._getOption(\"batchMaxCount\") === 1) ? 0 : this._getOption(\"batchStallTime\");\r\n        this.#drainTimer = setTimeout(() => {\r\n            this.#drainTimer = null;\r\n            const payloads = this.#payloads;\r\n            this.#payloads = [];\r\n            while (payloads.length) {\r\n                // Create payload batches that satisfy our batch constraints\r\n                const batch = [(payloads.shift())];\r\n                while (payloads.length) {\r\n                    if (batch.length === this.#options.batchMaxCount) {\r\n                        break;\r\n                    }\r\n                    batch.push((payloads.shift()));\r\n                    const bytes = JSON.stringify(batch.map((p) => p.payload));\r\n                    if (bytes.length > this.#options.batchMaxSize) {\r\n                        payloads.unshift((batch.pop()));\r\n                        break;\r\n                    }\r\n                }\r\n                // Process the result to each payload\r\n                (async () => {\r\n                    const payload = ((batch.length === 1) ? batch[0].payload : batch.map((p) => p.payload));\r\n                    this.emit(\"debug\", { action: \"sendRpcPayload\", payload });\r\n                    try {\r\n                        const result = await this._send(payload);\r\n                        this.emit(\"debug\", { action: \"receiveRpcResult\", result });\r\n                        // Process results in batch order\r\n                        for (const { resolve, reject, payload } of batch) {\r\n                            if (this.destroyed) {\r\n                                reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: payload.method }));\r\n                                continue;\r\n                            }\r\n                            // Find the matching result\r\n                            const resp = result.filter((r) => (r.id === payload.id))[0];\r\n                            // No result; the node failed us in unexpected ways\r\n                            if (resp == null) {\r\n                                const error = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"missing response for request\", \"BAD_DATA\", {\r\n                                    value: result, info: { payload }\r\n                                });\r\n                                this.emit(\"error\", error);\r\n                                reject(error);\r\n                                continue;\r\n                            }\r\n                            // The response is an error\r\n                            if (\"error\" in resp) {\r\n                                reject(this.getRpcError(payload, resp));\r\n                                continue;\r\n                            }\r\n                            // All good; send the result\r\n                            resolve(resp.result);\r\n                        }\r\n                    }\r\n                    catch (error) {\r\n                        this.emit(\"debug\", { action: \"receiveRpcError\", error });\r\n                        for (const { reject } of batch) {\r\n                            // @TODO: augment the error with the payload\r\n                            reject(error);\r\n                        }\r\n                    }\r\n                })();\r\n            }\r\n        }, stallTime);\r\n    }\r\n    constructor(network, options) {\r\n        super(network, options);\r\n        this.#nextId = 1;\r\n        this.#options = Object.assign({}, defaultOptions, options || {});\r\n        this.#payloads = [];\r\n        this.#drainTimer = null;\r\n        this.#network = null;\r\n        this.#pendingDetectNetwork = null;\r\n        {\r\n            let resolve = null;\r\n            const promise = new Promise((_resolve) => {\r\n                resolve = _resolve;\r\n            });\r\n            this.#notReady = { promise, resolve };\r\n        }\r\n        const staticNetwork = this._getOption(\"staticNetwork\");\r\n        if (typeof (staticNetwork) === \"boolean\") {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!staticNetwork || network !== \"any\", \"staticNetwork cannot be used on special network 'any'\", \"options\", options);\r\n            if (staticNetwork && network != null) {\r\n                this.#network = _network_js__WEBPACK_IMPORTED_MODULE_5__.Network.from(network);\r\n            }\r\n        }\r\n        else if (staticNetwork) {\r\n            // Make sure any static network is compatbile with the provided netwrok\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(network == null || staticNetwork.matches(network), \"staticNetwork MUST match network object\", \"options\", options);\r\n            this.#network = staticNetwork;\r\n        }\r\n    }\r\n    /**\r\n     *  Returns the value associated with the option %%key%%.\r\n     *\r\n     *  Sub-classes can use this to inquire about configuration options.\r\n     */\r\n    _getOption(key) {\r\n        return this.#options[key];\r\n    }\r\n    /**\r\n     *  Gets the [[Network]] this provider has committed to. On each call, the network\r\n     *  is detected, and if it has changed, the call will reject.\r\n     */\r\n    get _network() {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.#network, \"network is not available yet\", \"NETWORK_ERROR\");\r\n        return this.#network;\r\n    }\r\n    /**\r\n     *  Resolves to the non-normalized value by performing %%req%%.\r\n     *\r\n     *  Sub-classes may override this to modify behavior of actions,\r\n     *  and should generally call ``super._perform`` as a fallback.\r\n     */\r\n    async _perform(req) {\r\n        // Legacy networks do not like the type field being passed along (which\r\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\r\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\r\n            let tx = req.transaction;\r\n            if (tx && tx.type != null && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(tx.type)) {\r\n                // If there are no EIP-1559 or newer properties, it might be pre-EIP-1559\r\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\r\n                    const feeData = await this.getFeeData();\r\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\r\n                        // Network doesn't know about EIP-1559 (and hence type)\r\n                        req = Object.assign({}, req, {\r\n                            transaction: Object.assign({}, tx, { type: undefined })\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        const request = this.getRpcRequest(req);\r\n        if (request != null) {\r\n            return await this.send(request.method, request.args);\r\n        }\r\n        return super._perform(req);\r\n    }\r\n    /**\r\n     *  Sub-classes may override this; it detects the *actual* network that\r\n     *  we are **currently** connected to.\r\n     *\r\n     *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the\r\n     *  _send primitive must be used instead.\r\n     */\r\n    async _detectNetwork() {\r\n        const network = this._getOption(\"staticNetwork\");\r\n        if (network) {\r\n            if (network === true) {\r\n                if (this.#network) {\r\n                    return this.#network;\r\n                }\r\n            }\r\n            else {\r\n                return network;\r\n            }\r\n        }\r\n        if (this.#pendingDetectNetwork) {\r\n            return await this.#pendingDetectNetwork;\r\n        }\r\n        // If we are ready, use ``send``, which enabled requests to be batched\r\n        if (this.ready) {\r\n            this.#pendingDetectNetwork = (async () => {\r\n                try {\r\n                    const result = _network_js__WEBPACK_IMPORTED_MODULE_5__.Network.from((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(await this.send(\"eth_chainId\", [])));\r\n                    this.#pendingDetectNetwork = null;\r\n                    return result;\r\n                }\r\n                catch (error) {\r\n                    this.#pendingDetectNetwork = null;\r\n                    throw error;\r\n                }\r\n            })();\r\n            return await this.#pendingDetectNetwork;\r\n        }\r\n        // We are not ready yet; use the primitive _send\r\n        this.#pendingDetectNetwork = (async () => {\r\n            const payload = {\r\n                id: this.#nextId++, method: \"eth_chainId\", params: [], jsonrpc: \"2.0\"\r\n            };\r\n            this.emit(\"debug\", { action: \"sendRpcPayload\", payload });\r\n            let result;\r\n            try {\r\n                result = (await this._send(payload))[0];\r\n                this.#pendingDetectNetwork = null;\r\n            }\r\n            catch (error) {\r\n                this.#pendingDetectNetwork = null;\r\n                this.emit(\"debug\", { action: \"receiveRpcError\", error });\r\n                throw error;\r\n            }\r\n            this.emit(\"debug\", { action: \"receiveRpcResult\", result });\r\n            if (\"result\" in result) {\r\n                return _network_js__WEBPACK_IMPORTED_MODULE_5__.Network.from((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(result.result));\r\n            }\r\n            throw this.getRpcError(payload, result);\r\n        })();\r\n        return await this.#pendingDetectNetwork;\r\n    }\r\n    /**\r\n     *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls\r\n     *  will be passed to [[_send]] from [[send]]. If it is overridden, then\r\n     *  ``super._start()`` **MUST** be called.\r\n     *\r\n     *  Calling it multiple times is safe and has no effect.\r\n     */\r\n    _start() {\r\n        if (this.#notReady == null || this.#notReady.resolve == null) {\r\n            return;\r\n        }\r\n        this.#notReady.resolve();\r\n        this.#notReady = null;\r\n        (async () => {\r\n            // Bootstrap the network\r\n            while (this.#network == null && !this.destroyed) {\r\n                try {\r\n                    this.#network = await this._detectNetwork();\r\n                }\r\n                catch (error) {\r\n                    if (this.destroyed) {\r\n                        break;\r\n                    }\r\n                    console.log(\"JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)\");\r\n                    this.emit(\"error\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"failed to bootstrap network detection\", \"NETWORK_ERROR\", { event: \"initial-network-discovery\", info: { error } }));\r\n                    await stall(1000);\r\n                }\r\n            }\r\n            // Start dispatching requests\r\n            this.#scheduleDrain();\r\n        })();\r\n    }\r\n    /**\r\n     *  Resolves once the [[_start]] has been called. This can be used in\r\n     *  sub-classes to defer sending data until the connection has been\r\n     *  established.\r\n     */\r\n    async _waitUntilReady() {\r\n        if (this.#notReady == null) {\r\n            return;\r\n        }\r\n        return await this.#notReady.promise;\r\n    }\r\n    /**\r\n     *  Return a Subscriber that will manage the %%sub%%.\r\n     *\r\n     *  Sub-classes may override this to modify the behavior of\r\n     *  subscription management.\r\n     */\r\n    _getSubscriber(sub) {\r\n        // Pending Filters aren't availble via polling\r\n        if (sub.type === \"pending\") {\r\n            return new _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_6__.FilterIdPendingSubscriber(this);\r\n        }\r\n        if (sub.type === \"event\") {\r\n            if (this._getOption(\"polling\")) {\r\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_7__.PollingEventSubscriber(this, sub.filter);\r\n            }\r\n            return new _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_6__.FilterIdEventSubscriber(this, sub.filter);\r\n        }\r\n        // Orphaned Logs are handled automatically, by the filter, since\r\n        // logs with removed are emitted by it\r\n        if (sub.type === \"orphan\" && sub.filter.orphan === \"drop-log\") {\r\n            return new _abstract_provider_js__WEBPACK_IMPORTED_MODULE_4__.UnmanagedSubscriber(\"orphan\");\r\n        }\r\n        return super._getSubscriber(sub);\r\n    }\r\n    /**\r\n     *  Returns true only if the [[_start]] has been called.\r\n     */\r\n    get ready() { return this.#notReady == null; }\r\n    /**\r\n     *  Returns %%tx%% as a normalized JSON-RPC transaction request,\r\n     *  which has all values hexlified and any numeric values converted\r\n     *  to Quantity values.\r\n     */\r\n    getRpcTransaction(tx) {\r\n        const result = {};\r\n        // JSON-RPC now requires numeric values to be \"quantity\" values\r\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach((key) => {\r\n            if (tx[key] == null) {\r\n                return;\r\n            }\r\n            let dstKey = key;\r\n            if (key === \"gasLimit\") {\r\n                dstKey = \"gas\";\r\n            }\r\n            result[dstKey] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toQuantity)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(tx[key], `tx.${key}`));\r\n        });\r\n        // Make sure addresses and data are lowercase\r\n        [\"from\", \"to\", \"data\"].forEach((key) => {\r\n            if (tx[key] == null) {\r\n                return;\r\n            }\r\n            result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(tx[key]);\r\n        });\r\n        // Normalize the access list object\r\n        if (tx.accessList) {\r\n            result[\"accessList\"] = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_8__.accessListify)(tx.accessList);\r\n        }\r\n        if (tx.blobVersionedHashes) {\r\n            // @TODO: Remove this <any> case once EIP-4844 added to prepared tx\r\n            result[\"blobVersionedHashes\"] = tx.blobVersionedHashes.map(h => h.toLowerCase());\r\n        }\r\n        if (tx.authorizationList) {\r\n            result[\"authorizationList\"] = tx.authorizationList.map((_a) => {\r\n                const a = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_8__.authorizationify)(_a);\r\n                return {\r\n                    address: a.address,\r\n                    nonce: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toQuantity)(a.nonce),\r\n                    chainId: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toQuantity)(a.chainId),\r\n                    yParity: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toQuantity)(a.signature.yParity),\r\n                    r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toQuantity)(a.signature.r),\r\n                    s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toQuantity)(a.signature.s),\r\n                };\r\n            });\r\n        }\r\n        // @TODO: blobs should probably also be copied over, optionally\r\n        // accounting for the kzg property to backfill blobVersionedHashes\r\n        // using the commitment. Or should that be left as an exercise to\r\n        // the caller?\r\n        return result;\r\n    }\r\n    /**\r\n     *  Returns the request method and arguments required to perform\r\n     *  %%req%%.\r\n     */\r\n    getRpcRequest(req) {\r\n        switch (req.method) {\r\n            case \"chainId\":\r\n                return { method: \"eth_chainId\", args: [] };\r\n            case \"getBlockNumber\":\r\n                return { method: \"eth_blockNumber\", args: [] };\r\n            case \"getGasPrice\":\r\n                return { method: \"eth_gasPrice\", args: [] };\r\n            case \"getPriorityFee\":\r\n                return { method: \"eth_maxPriorityFeePerGas\", args: [] };\r\n            case \"getBalance\":\r\n                return {\r\n                    method: \"eth_getBalance\",\r\n                    args: [getLowerCase(req.address), req.blockTag]\r\n                };\r\n            case \"getTransactionCount\":\r\n                return {\r\n                    method: \"eth_getTransactionCount\",\r\n                    args: [getLowerCase(req.address), req.blockTag]\r\n                };\r\n            case \"getCode\":\r\n                return {\r\n                    method: \"eth_getCode\",\r\n                    args: [getLowerCase(req.address), req.blockTag]\r\n                };\r\n            case \"getStorage\":\r\n                return {\r\n                    method: \"eth_getStorageAt\",\r\n                    args: [\r\n                        getLowerCase(req.address),\r\n                        (\"0x\" + req.position.toString(16)),\r\n                        req.blockTag\r\n                    ]\r\n                };\r\n            case \"broadcastTransaction\":\r\n                return {\r\n                    method: \"eth_sendRawTransaction\",\r\n                    args: [req.signedTransaction]\r\n                };\r\n            case \"getBlock\":\r\n                if (\"blockTag\" in req) {\r\n                    return {\r\n                        method: \"eth_getBlockByNumber\",\r\n                        args: [req.blockTag, !!req.includeTransactions]\r\n                    };\r\n                }\r\n                else if (\"blockHash\" in req) {\r\n                    return {\r\n                        method: \"eth_getBlockByHash\",\r\n                        args: [req.blockHash, !!req.includeTransactions]\r\n                    };\r\n                }\r\n                break;\r\n            case \"getTransaction\":\r\n                return {\r\n                    method: \"eth_getTransactionByHash\",\r\n                    args: [req.hash]\r\n                };\r\n            case \"getTransactionReceipt\":\r\n                return {\r\n                    method: \"eth_getTransactionReceipt\",\r\n                    args: [req.hash]\r\n                };\r\n            case \"call\":\r\n                return {\r\n                    method: \"eth_call\",\r\n                    args: [this.getRpcTransaction(req.transaction), req.blockTag]\r\n                };\r\n            case \"estimateGas\": {\r\n                return {\r\n                    method: \"eth_estimateGas\",\r\n                    args: [this.getRpcTransaction(req.transaction)]\r\n                };\r\n            }\r\n            case \"getLogs\":\r\n                if (req.filter && req.filter.address != null) {\r\n                    if (Array.isArray(req.filter.address)) {\r\n                        req.filter.address = req.filter.address.map(getLowerCase);\r\n                    }\r\n                    else {\r\n                        req.filter.address = getLowerCase(req.filter.address);\r\n                    }\r\n                }\r\n                return { method: \"eth_getLogs\", args: [req.filter] };\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     *  Returns an ethers-style Error for the given JSON-RPC error\r\n     *  %%payload%%, coalescing the various strings and error shapes\r\n     *  that different nodes return, coercing them into a machine-readable\r\n     *  standardized error.\r\n     */\r\n    getRpcError(payload, _error) {\r\n        const { method } = payload;\r\n        const { error } = _error;\r\n        if (method === \"eth_estimateGas\" && error.message) {\r\n            const msg = error.message;\r\n            if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {\r\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\r\n                    transaction: (payload.params[0]),\r\n                    info: { payload, error }\r\n                });\r\n            }\r\n            else if (msg.match(/nonce/i) && msg.match(/too low/i)) {\r\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"nonce has already been used\", \"NONCE_EXPIRED\", {\r\n                    transaction: (payload.params[0]),\r\n                    info: { payload, error }\r\n                });\r\n            }\r\n        }\r\n        if (method === \"eth_call\" || method === \"eth_estimateGas\") {\r\n            const result = spelunkData(error);\r\n            const e = _abi_index_js__WEBPACK_IMPORTED_MODULE_9__.AbiCoder.getBuiltinCallException((method === \"eth_call\") ? \"call\" : \"estimateGas\", (payload.params[0]), (result ? result.data : null));\r\n            e.info = { error, payload };\r\n            return e;\r\n        }\r\n        // Only estimateGas and call can return arbitrary contract-defined text, so now we\r\n        // we can process text safely.\r\n        const message = JSON.stringify(spelunkMessage(error));\r\n        if (typeof (error.message) === \"string\" && error.message.match(/user denied|ethers-user-denied/i)) {\r\n            const actionMap = {\r\n                eth_sign: \"signMessage\",\r\n                personal_sign: \"signMessage\",\r\n                eth_signTypedData_v4: \"signTypedData\",\r\n                eth_signTransaction: \"signTransaction\",\r\n                eth_sendTransaction: \"sendTransaction\",\r\n                eth_requestAccounts: \"requestAccess\",\r\n                wallet_requestAccounts: \"requestAccess\",\r\n            };\r\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(`user rejected action`, \"ACTION_REJECTED\", {\r\n                action: (actionMap[method] || \"unknown\"),\r\n                reason: \"rejected\",\r\n                info: { payload, error }\r\n            });\r\n        }\r\n        if (method === \"eth_sendRawTransaction\" || method === \"eth_sendTransaction\") {\r\n            const transaction = (payload.params[0]);\r\n            if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\r\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\r\n                    transaction, info: { error }\r\n                });\r\n            }\r\n            if (message.match(/nonce/i) && message.match(/too low/i)) {\r\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"nonce has already been used\", \"NONCE_EXPIRED\", { transaction, info: { error } });\r\n            }\r\n            // \"replacement transaction underpriced\"\r\n            if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {\r\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", { transaction, info: { error } });\r\n            }\r\n            if (message.match(/only replay-protected/i)) {\r\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"legacy pre-eip-155 transactions not supported\", \"UNSUPPORTED_OPERATION\", {\r\n                    operation: method, info: { transaction, info: { error } }\r\n                });\r\n            }\r\n        }\r\n        let unsupported = !!message.match(/the method .* does not exist/i);\r\n        if (!unsupported) {\r\n            if (error && error.details && error.details.startsWith(\"Unauthorized method:\")) {\r\n                unsupported = true;\r\n            }\r\n        }\r\n        if (unsupported) {\r\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"unsupported operation\", \"UNSUPPORTED_OPERATION\", {\r\n                operation: payload.method, info: { error, payload }\r\n            });\r\n        }\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"could not coalesce error\", \"UNKNOWN_ERROR\", { error, payload });\r\n    }\r\n    /**\r\n     *  Requests the %%method%% with %%params%% via the JSON-RPC protocol\r\n     *  over the underlying channel. This can be used to call methods\r\n     *  on the backend that do not have a high-level API within the Provider\r\n     *  API.\r\n     *\r\n     *  This method queues requests according to the batch constraints\r\n     *  in the options, assigns the request a unique ID.\r\n     *\r\n     *  **Do NOT override** this method in sub-classes; instead\r\n     *  override [[_send]] or force the options values in the\r\n     *  call to the constructor to modify this method's behavior.\r\n     */\r\n    send(method, params) {\r\n        // @TODO: cache chainId?? purge on switch_networks\r\n        // We have been destroyed; no operations are supported anymore\r\n        if (this.destroyed) {\r\n            return Promise.reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: method }));\r\n        }\r\n        const id = this.#nextId++;\r\n        const promise = new Promise((resolve, reject) => {\r\n            this.#payloads.push({\r\n                resolve, reject,\r\n                payload: { method, params, id, jsonrpc: \"2.0\" }\r\n            });\r\n        });\r\n        // If there is not a pending drainTimer, set one\r\n        this.#scheduleDrain();\r\n        return promise;\r\n    }\r\n    /**\r\n     *  Resolves to the [[Signer]] account for  %%address%% managed by\r\n     *  the client.\r\n     *\r\n     *  If the %%address%% is a number, it is used as an index in the\r\n     *  the accounts from [[listAccounts]].\r\n     *\r\n     *  This can only be used on clients which manage accounts (such as\r\n     *  Geth with imported account or MetaMask).\r\n     *\r\n     *  Throws if the account doesn't exist.\r\n     */\r\n    async getSigner(address) {\r\n        if (address == null) {\r\n            address = 0;\r\n        }\r\n        const accountsPromise = this.send(\"eth_accounts\", []);\r\n        // Account index\r\n        if (typeof (address) === \"number\") {\r\n            const accounts = (await accountsPromise);\r\n            if (address >= accounts.length) {\r\n                throw new Error(\"no such account\");\r\n            }\r\n            return new JsonRpcSigner(this, accounts[address]);\r\n        }\r\n        const { accounts } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)({\r\n            network: this.getNetwork(),\r\n            accounts: accountsPromise\r\n        });\r\n        // Account address\r\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address);\r\n        for (const account of accounts) {\r\n            if ((0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(account) === address) {\r\n                return new JsonRpcSigner(this, address);\r\n            }\r\n        }\r\n        throw new Error(\"invalid account\");\r\n    }\r\n    async listAccounts() {\r\n        const accounts = await this.send(\"eth_accounts\", []);\r\n        return accounts.map((a) => new JsonRpcSigner(this, a));\r\n    }\r\n    destroy() {\r\n        // Stop processing requests\r\n        if (this.#drainTimer) {\r\n            clearTimeout(this.#drainTimer);\r\n            this.#drainTimer = null;\r\n        }\r\n        // Cancel all pending requests\r\n        for (const { payload, reject } of this.#payloads) {\r\n            reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: payload.method }));\r\n        }\r\n        this.#payloads = [];\r\n        // Parent clean-up\r\n        super.destroy();\r\n    }\r\n}\r\n// @TODO: remove this in v7, it is not exported because this functionality\r\n// is exposed in the JsonRpcApiProvider by setting polling to true. It should\r\n// be safe to remove regardless, because it isn't reachable, but just in case.\r\n/**\r\n *  @_ignore:\r\n */\r\nclass JsonRpcApiPollingProvider extends JsonRpcApiProvider {\r\n    #pollingInterval;\r\n    constructor(network, options) {\r\n        super(network, options);\r\n        let pollingInterval = this._getOption(\"pollingInterval\");\r\n        if (pollingInterval == null) {\r\n            pollingInterval = defaultOptions.pollingInterval;\r\n        }\r\n        this.#pollingInterval = pollingInterval;\r\n    }\r\n    _getSubscriber(sub) {\r\n        const subscriber = super._getSubscriber(sub);\r\n        if (isPollable(subscriber)) {\r\n            subscriber.pollingInterval = this.#pollingInterval;\r\n        }\r\n        return subscriber;\r\n    }\r\n    /**\r\n     *  The polling interval (default: 4000 ms)\r\n     */\r\n    get pollingInterval() { return this.#pollingInterval; }\r\n    set pollingInterval(value) {\r\n        if (!Number.isInteger(value) || value < 0) {\r\n            throw new Error(\"invalid interval\");\r\n        }\r\n        this.#pollingInterval = value;\r\n        this._forEachSubscriber((sub) => {\r\n            if (isPollable(sub)) {\r\n                sub.pollingInterval = this.#pollingInterval;\r\n            }\r\n        });\r\n    }\r\n}\r\n/**\r\n *  The JsonRpcProvider is one of the most common Providers,\r\n *  which performs all operations over HTTP (or HTTPS) requests.\r\n *\r\n *  Events are processed by polling the backend for the current block\r\n *  number; when it advances, all block-base events are then checked\r\n *  for updates.\r\n */\r\nclass JsonRpcProvider extends JsonRpcApiPollingProvider {\r\n    #connect;\r\n    constructor(url, network, options) {\r\n        if (url == null) {\r\n            url = \"http:/\\/localhost:8545\";\r\n        }\r\n        super(network, options);\r\n        if (typeof (url) === \"string\") {\r\n            this.#connect = new _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.FetchRequest(url);\r\n        }\r\n        else {\r\n            this.#connect = url.clone();\r\n        }\r\n    }\r\n    _getConnection() {\r\n        return this.#connect.clone();\r\n    }\r\n    async send(method, params) {\r\n        // All requests are over HTTP, so we can just start handling requests\r\n        // We do this here rather than the constructor so that we don't send any\r\n        // requests to the network (i.e. eth_chainId) until we absolutely have to.\r\n        await this._start();\r\n        return await super.send(method, params);\r\n    }\r\n    async _send(payload) {\r\n        // Configure a POST connection for the requested method\r\n        const request = this._getConnection();\r\n        request.body = JSON.stringify(payload);\r\n        request.setHeader(\"content-type\", \"application/json\");\r\n        const response = await request.send();\r\n        response.assertOk();\r\n        let resp = response.bodyJson;\r\n        if (!Array.isArray(resp)) {\r\n            resp = [resp];\r\n        }\r\n        return resp;\r\n    }\r\n}\r\nfunction spelunkData(value) {\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    // These *are* the droids we're looking for.\r\n    if (typeof (value.message) === \"string\" && value.message.match(/revert/i) && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.isHexString)(value.data)) {\r\n        return { message: value.message, data: value.data };\r\n    }\r\n    // Spelunk further...\r\n    if (typeof (value) === \"object\") {\r\n        for (const key in value) {\r\n            const result = spelunkData(value[key]);\r\n            if (result) {\r\n                return result;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    // Might be a JSON string we can further descend...\r\n    if (typeof (value) === \"string\") {\r\n        try {\r\n            return spelunkData(JSON.parse(value));\r\n        }\r\n        catch (error) { }\r\n    }\r\n    return null;\r\n}\r\nfunction _spelunkMessage(value, result) {\r\n    if (value == null) {\r\n        return;\r\n    }\r\n    // These *are* the droids we're looking for.\r\n    if (typeof (value.message) === \"string\") {\r\n        result.push(value.message);\r\n    }\r\n    // Spelunk further...\r\n    if (typeof (value) === \"object\") {\r\n        for (const key in value) {\r\n            _spelunkMessage(value[key], result);\r\n        }\r\n    }\r\n    // Might be a JSON string we can further descend...\r\n    if (typeof (value) === \"string\") {\r\n        try {\r\n            return _spelunkMessage(JSON.parse(value), result);\r\n        }\r\n        catch (error) { }\r\n    }\r\n}\r\nfunction spelunkMessage(value) {\r\n    const result = [];\r\n    _spelunkMessage(value, result);\r\n    return result;\r\n}\r\n//# sourceMappingURL=provider-jsonrpc.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItanNvbnJwYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMkM7QUFDc0I7QUFDYjtBQUNzQjtBQUNrSDtBQUM3RztBQUN6QjtBQUNmO0FBQ3VEO0FBQzdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBLDBDQUEwQyxPQUFPLEdBQUcsZUFBZTtBQUNuRTtBQUNBO0FBQ0Esc0NBQXNDLGdDQUFnQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNEJBQTRCLCtEQUFjO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2REFBVTtBQUM1QixRQUFRLGlFQUFnQixTQUFTLFNBQVM7QUFDMUM7QUFDQTtBQUNBLFFBQVEsdURBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlFQUFjO0FBQ2pELGdCQUFnQiwrREFBYztBQUM5QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwyQkFBMkI7QUFDM0YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5REFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRiw0REFBVztBQUM1RixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHByb3ZpZGVyc1xccHJvdmlkZXItanNvbnJwYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIE9uZSBvZiB0aGUgbW9zdCBjb21tb24gd2F5cyB0byBpbnRlcmFjdCB3aXRoIHRoZSBibG9ja2NoYWluIGlzXHJcbiAqICBieSBhIG5vZGUgcnVubmluZyBhIEpTT04tUlBDIGludGVyZmFjZSB3aGljaCBjYW4gYmUgY29ubmVjdGVkIHRvLFxyXG4gKiAgYmFzZWQgb24gdGhlIHRyYW5zcG9ydCwgdXNpbmc6XHJcbiAqXHJcbiAqICAtIEhUVFAgb3IgSFRUUFMgLSBbW0pzb25ScGNQcm92aWRlcl1dXHJcbiAqICAtIFdlYlNvY2tldCAtIFtbV2ViU29ja2V0UHJvdmlkZXJdXVxyXG4gKiAgLSBJUEMgLSBbW0lwY1NvY2tldFByb3ZpZGVyXV1cclxuICpcclxuICogQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2pzb25ycGM6SlNPTi1SUEMgUHJvdmlkZXIgIFthYm91dC1qc29ucnBjUHJvdmlkZXJdXHJcbiAqL1xyXG4vLyBAVE9ETzpcclxuLy8gLSBBZGQgdGhlIGJhdGNoaW5nIEFQSVxyXG4vLyBodHRwczovL3BsYXlncm91bmQub3Blbi1ycGMub3JnLz9zY2hlbWFVcmw9aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2V0aGVyZXVtL2V0aDEuMC1hcGlzL2Fzc2VtYmxlZC1zcGVjL29wZW5ycGMuanNvbiZ1aVNjaGVtYSU1QmFwcEJhciU1RCU1QnVpOnNwbGl0VmlldyU1RD10cnVlJnVpU2NoZW1hJTVCYXBwQmFyJTVEJTVCdWk6aW5wdXQlNUQ9ZmFsc2UmdWlTY2hlbWElNUJhcHBCYXIlNUQlNUJ1aTpleGFtcGxlc0Ryb3Bkb3duJTVEPWZhbHNlXHJcbmltcG9ydCB7IEFiaUNvZGVyIH0gZnJvbSBcIi4uL2FiaS9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBnZXRBZGRyZXNzLCByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IFR5cGVkRGF0YUVuY29kZXIgfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5LCBhdXRob3JpemF0aW9uaWZ5IH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIHRvUXVhbnRpdHksIHRvVXRmOEJ5dGVzLCBpc0Vycm9yLCBtYWtlRXJyb3IsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIEZldGNoUmVxdWVzdCwgcmVzb2x2ZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgQWJzdHJhY3RQcm92aWRlciwgVW5tYW5hZ2VkU3Vic2NyaWJlciB9IGZyb20gXCIuL2Fic3RyYWN0LXByb3ZpZGVyLmpzXCI7XHJcbmltcG9ydCB7IEFic3RyYWN0U2lnbmVyIH0gZnJvbSBcIi4vYWJzdHJhY3Qtc2lnbmVyLmpzXCI7XHJcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XHJcbmltcG9ydCB7IEZpbHRlcklkRXZlbnRTdWJzY3JpYmVyLCBGaWx0ZXJJZFBlbmRpbmdTdWJzY3JpYmVyIH0gZnJvbSBcIi4vc3Vic2NyaWJlci1maWx0ZXJpZC5qc1wiO1xyXG5pbXBvcnQgeyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyIH0gZnJvbSBcIi4vc3Vic2NyaWJlci1wb2xsaW5nLmpzXCI7XHJcbmNvbnN0IFByaW1pdGl2ZSA9IFwiYmlnaW50LGJvb2xlYW4sZnVuY3Rpb24sbnVtYmVyLHN0cmluZyxzeW1ib2xcIi5zcGxpdCgvLC9nKTtcclxuLy9jb25zdCBNZXRob2RzID0gXCJnZXRBZGRyZXNzLHRoZW5cIi5zcGxpdCgvLC9nKTtcclxuZnVuY3Rpb24gZGVlcENvcHkodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IFByaW1pdGl2ZS5pbmRleE9mKHR5cGVvZiAodmFsdWUpKSA+PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLy8gS2VlcCBhbnkgQWRkcmVzc2FibGVcclxuICAgIGlmICh0eXBlb2YgKHZhbHVlLmdldEFkZHJlc3MpID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gKHZhbHVlLm1hcChkZWVwQ29weSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5yZWR1Y2UoKGFjY3VtLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgYWNjdW1ba2V5XSA9IHZhbHVlW2tleV07XHJcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcclxuICAgICAgICB9LCB7fSk7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHNob3VsZCBub3QgaGFwcGVuOiAke3ZhbHVlfSAoJHt0eXBlb2YgKHZhbHVlKX0pYCk7XHJcbn1cclxuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4geyBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKTsgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TG93ZXJDYXNlKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBpc1BvbGxhYmxlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUucG9sbGluZ0ludGVydmFsKSA9PT0gXCJudW1iZXJcIik7XHJcbn1cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICBwb2xsaW5nOiBmYWxzZSxcclxuICAgIHN0YXRpY05ldHdvcms6IG51bGwsXHJcbiAgICBiYXRjaFN0YWxsVGltZTogMTAsXHJcbiAgICBiYXRjaE1heFNpemU6ICgxIDw8IDIwKSxcclxuICAgIGJhdGNoTWF4Q291bnQ6IDEwMCxcclxuICAgIGNhY2hlVGltZW91dDogMjUwLFxyXG4gICAgcG9sbGluZ0ludGVydmFsOiA0MDAwXHJcbn07XHJcbi8vIEBUT0RPOiBVbmNoZWNrZWQgU2lnbmVyc1xyXG5leHBvcnQgY2xhc3MgSnNvblJwY1NpZ25lciBleHRlbmRzIEFic3RyYWN0U2lnbmVyIHtcclxuICAgIGFkZHJlc3M7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgYWRkcmVzcykge1xyXG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcclxuICAgICAgICBhZGRyZXNzID0gZ2V0QWRkcmVzcyhhZGRyZXNzKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYWRkcmVzcyB9KTtcclxuICAgIH1cclxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcclxuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY2Fubm90IHJlY29ubmVjdCBKc29uUnBjU2lnbmVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25lci5jb25uZWN0XCJcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkcmVzcztcclxuICAgIH1cclxuICAgIC8vIEpTT04tUlBDIHdpbGwgYXV0b21hdGlhbGx5IGZpbGwgaW4gbm9uY2UsIGV0Yy4gc28gd2UganVzdCBjaGVjayBmcm9tXHJcbiAgICBhc3luYyBwb3B1bGF0ZVRyYW5zYWN0aW9uKHR4KSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9wdWxhdGVDYWxsKHR4KTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMganVzdCB0aGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gYWZ0ZXIgc2VudCwgd2hpY2ggaXMgd2hhdFxyXG4gICAgLy8gdGhlIGJhcmUgSlNPTi1SUEMgQVBJIGRvZXM7XHJcbiAgICBhc3luYyBzZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24oX3R4KSB7XHJcbiAgICAgICAgY29uc3QgdHggPSBkZWVwQ29weShfdHgpO1xyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBmcm9tIG1hdGNoZXMgdGhlIHNlbmRlclxyXG4gICAgICAgIGlmICh0eC5mcm9tKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IF9mcm9tID0gdHguZnJvbTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbSA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKF9mcm9tLCB0aGlzLnByb3ZpZGVyKTtcclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZyb20gIT0gbnVsbCAmJiBmcm9tLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIF90eCk7XHJcbiAgICAgICAgICAgICAgICB0eC5mcm9tID0gZnJvbTtcclxuICAgICAgICAgICAgfSkoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0eC5mcm9tID0gdGhpcy5hZGRyZXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaGUgSlNPTi1SUEMgZm9yIGV0aF9zZW5kVHJhbnNhY3Rpb24gdXNlcyA5MDAwMCBnYXM7IGlmIHRoZSB1c2VyXHJcbiAgICAgICAgLy8gd2lzaGVzIHRvIHVzZSB0aGlzLCBpdCBpcyBlYXN5IHRvIHNwZWNpZnkgZXhwbGljaXRseSwgb3RoZXJ3aXNlXHJcbiAgICAgICAgLy8gd2UgbG9vayBpdCB1cCBmb3IgdGhlbS5cclxuICAgICAgICBpZiAodHguZ2FzTGltaXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0eC5nYXNMaW1pdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZXN0aW1hdGVHYXMoeyAuLi50eCwgZnJvbTogdGhpcy5hZGRyZXNzIH0pO1xyXG4gICAgICAgICAgICB9KSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhlIGFkZHJlc3MgbWF5IGJlIGFuIEVOUyBuYW1lIG9yIEFkZHJlc3NhYmxlXHJcbiAgICAgICAgaWYgKHR4LnRvICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgX3RvID0gdHgudG87XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHR4LnRvID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3MoX3RvLCB0aGlzLnByb3ZpZGVyKTtcclxuICAgICAgICAgICAgfSkoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdhaXQgdW50aWwgYWxsIG9mIG91ciBwcm9wZXJ0aWVzIGFyZSBmaWxsZWQgaW5cclxuICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaGV4VHggPSB0aGlzLnByb3ZpZGVyLmdldFJwY1RyYW5zYWN0aW9uKHR4KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiLCBbaGV4VHhdKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0eCkge1xyXG4gICAgICAgIC8vIFRoaXMgY2Fubm90IGJlIG1pbmVkIGFueSBlYXJsaWVyIHRoYW4gYW55IHJlY2VudCBibG9ja1xyXG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xyXG4gICAgICAgIC8vIFNlbmQgdGhlIHRyYW5zYWN0aW9uXHJcbiAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHR4KTtcclxuICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCBKU09OLVJQQyBvbmx5IHByb3ZpZGVzIGFuZCBvcGFxdWUgdHJhbnNhY3Rpb24gaGFzaFxyXG4gICAgICAgIC8vIGZvciBhIHJlc3BvbnNlLCBhbmQgd2UgbmVlZCB0aGUgYWN0dWFsIHRyYW5zYWN0aW9uLCBzbyB3ZSBwb2xsXHJcbiAgICAgICAgLy8gZm9yIGl0OyBpdCBzaG91bGQgc2hvdyB1cCB2ZXJ5IHF1aWNrbHlcclxuICAgICAgICByZXR1cm4gYXdhaXQgKG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdGltZW91dHMgPSBbMTAwMCwgMTAwXTtcclxuICAgICAgICAgICAgbGV0IGludmFsaWRzID0gMDtcclxuICAgICAgICAgICAgY29uc3QgY2hlY2tUeCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIHRyYW5zYWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKGhhc2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHgucmVwbGFjZWFibGVUcmFuc2FjdGlvbihibG9ja051bWJlcikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2Ugd2VyZSBjYW5jZWxsZWQ6IHN0b3AgcG9sbGluZy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGF0YSBpcyBiYWQ6IHRoZSBub2RlIHJldHVybnMgYmFkIHRyYW5zYWN0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZXR3b3JrIGNoYW5nZWQ6IGNhbGxpbmcgYWdhaW4gd2lsbCBhbHNvIGZhaWxcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB1bnN1cHBvcnRlZDogbGlrZWx5IGRlc3Ryb3llZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkNBTkNFTExFRFwiKSB8fCBpc0Vycm9yKGVycm9yLCBcIkJBRF9EQVRBXCIpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRXJyb3IoZXJyb3IsIFwiTkVUV09SS19FUlJPUlwiKSB8fCBpc0Vycm9yKGVycm9yLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuaW5mbyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5pbmZvID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuaW5mby5zZW5kVHJhbnNhY3Rpb25IYXNoID0gaGFzaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBTdG9wLWdhcCBmb3IgbWlzYmVoYXZpbmcgYmFja2VuZHM7IHNlZSAjNDUxM1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIklOVkFMSURfQVJHVU1FTlRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZHMrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmluZm8gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuaW5mbyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmluZm8uc2VuZFRyYW5zYWN0aW9uSGFzaCA9IGhhc2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnZhbGlkcyA+IDEwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBhbnlvbmUgdGhhdCBjYXJlczsgYnV0IHdlIHdpbGwgdHJ5IGFnYWluLCBzaW5jZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IGlzIGxpa2VseSBhbiBpbnRlcm1pdHRlbnQgc2VydmljZSBlcnJvclxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIuZW1pdChcImVycm9yXCIsIG1ha2VFcnJvcihcImZhaWxlZCB0byBmZXRjaCB0cmFuc2F0aW9uIGFmdGVyIHNlbmRpbmcgKHdpbGwgdHJ5IGFnYWluKVwiLCBcIlVOS05PV05fRVJST1JcIiwgeyBlcnJvciB9KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBXYWl0IGFub3RoZXIgNCBzZWNvbmRzXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLl9zZXRUaW1lb3V0KCgpID0+IHsgY2hlY2tUeCgpOyB9LCB0aW1lb3V0cy5wb3AoKSB8fCA0MDAwKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY2hlY2tUeCgpO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihfdHgpIHtcclxuICAgICAgICBjb25zdCB0eCA9IGRlZXBDb3B5KF90eCk7XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBmcm9tIG1hdGNoZXMgdGhlIHNlbmRlclxyXG4gICAgICAgIGlmICh0eC5mcm9tKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBhd2FpdCByZXNvbHZlQWRkcmVzcyh0eC5mcm9tLCB0aGlzLnByb3ZpZGVyKTtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJvbSAhPSBudWxsICYmIGZyb20udG9Mb3dlckNhc2UoKSA9PT0gdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIFwiZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHJhbnNhY3Rpb25cIiwgX3R4KTtcclxuICAgICAgICAgICAgdHguZnJvbSA9IGZyb207XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0eC5mcm9tID0gdGhpcy5hZGRyZXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBoZXhUeCA9IHRoaXMucHJvdmlkZXIuZ2V0UnBjVHJhbnNhY3Rpb24odHgpO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblRyYW5zYWN0aW9uXCIsIFtoZXhUeF0pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2lnbk1lc3NhZ2UoX21lc3NhZ2UpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gKCh0eXBlb2YgKF9tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikgPyB0b1V0ZjhCeXRlcyhfbWVzc2FnZSkgOiBfbWVzc2FnZSk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIuc2VuZChcInBlcnNvbmFsX3NpZ25cIiwgW1xyXG4gICAgICAgICAgICBoZXhsaWZ5KG1lc3NhZ2UpLCB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCBfdmFsdWUpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGRlZXBDb3B5KF92YWx1ZSk7XHJcbiAgICAgICAgLy8gUG9wdWxhdGUgYW55IEVOUyBuYW1lcyAoaW4tcGxhY2UpXHJcbiAgICAgICAgY29uc3QgcG9wdWxhdGVkID0gYXdhaXQgVHlwZWREYXRhRW5jb2Rlci5yZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3ModmFsdWUpO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhZGRyZXNzICE9IG51bGwsIFwiVHlwZWREYXRhIGRvZXMgbm90IHN1cHBvcnQgbnVsbCBhZGRyZXNzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25UeXBlZERhdGFfdjRcIiwgW1xyXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSxcclxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoVHlwZWREYXRhRW5jb2Rlci5nZXRQYXlsb2FkKHBvcHVsYXRlZC5kb21haW4sIHR5cGVzLCBwb3B1bGF0ZWQudmFsdWUpKVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgdW5sb2NrKHBhc3N3b3JkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZChcInBlcnNvbmFsX3VubG9ja0FjY291bnRcIiwgW1xyXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSwgcGFzc3dvcmQsIG51bGxcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvSlNPTi1SUEMjZXRoX3NpZ25cclxuICAgIGFzeW5jIF9sZWdhY3lTaWduTWVzc2FnZShfbWVzc2FnZSkge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoKHR5cGVvZiAoX21lc3NhZ2UpID09PSBcInN0cmluZ1wiKSA/IHRvVXRmOEJ5dGVzKF9tZXNzYWdlKSA6IF9tZXNzYWdlKTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25cIiwgW1xyXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSwgaGV4bGlmeShtZXNzYWdlKVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgVGhlIEpzb25ScGNBcGlQcm92aWRlciBpcyBhbiBhYnN0cmFjdCBjbGFzcyBhbmQgKipNVVNUKiogYmVcclxuICogIHN1Yi1jbGFzc2VkLlxyXG4gKlxyXG4gKiAgSXQgcHJvdmlkZXMgdGhlIGJhc2UgZm9yIGFsbCBKU09OLVJQQy1iYXNlZCBQcm92aWRlciBpbnRlcmFjdGlvbi5cclxuICpcclxuICogIFN1Yi1jbGFzc2luZyBOb3RlczpcclxuICogIC0gYSBzdWItY2xhc3MgTVVTVCBvdmVycmlkZSBfc2VuZFxyXG4gKiAgLSBhIHN1Yi1jbGFzcyBNVVNUIGNhbGwgdGhlIGBfc3RhcnQoKWAgbWV0aG9kIG9uY2UgY29ubmVjdGVkXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSnNvblJwY0FwaVByb3ZpZGVyIGV4dGVuZHMgQWJzdHJhY3RQcm92aWRlciB7XHJcbiAgICAjb3B0aW9ucztcclxuICAgIC8vIFRoZSBuZXh0IElEIHRvIHVzZSBmb3IgdGhlIEpTT04tUlBDIElEIGZpZWxkXHJcbiAgICAjbmV4dElkO1xyXG4gICAgLy8gUGF5bG9hZHMgYXJlIHF1ZXVlZCBhbmQgdHJpZ2dlcmVkIGluIGJhdGNoZXMgdXNpbmcgdGhlIGRyYWluVGltZXJcclxuICAgICNwYXlsb2FkcztcclxuICAgICNkcmFpblRpbWVyO1xyXG4gICAgI25vdFJlYWR5O1xyXG4gICAgI25ldHdvcms7XHJcbiAgICAjcGVuZGluZ0RldGVjdE5ldHdvcms7XHJcbiAgICAjc2NoZWR1bGVEcmFpbigpIHtcclxuICAgICAgICBpZiAodGhpcy4jZHJhaW5UaW1lcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHdlIGFyZW4ndCB1c2luZyBiYXRjaGluZywgbm8gaGFybSBpbiBzZW5kaW5nIGl0IGltbWVkaWF0ZWx5XHJcbiAgICAgICAgY29uc3Qgc3RhbGxUaW1lID0gKHRoaXMuX2dldE9wdGlvbihcImJhdGNoTWF4Q291bnRcIikgPT09IDEpID8gMCA6IHRoaXMuX2dldE9wdGlvbihcImJhdGNoU3RhbGxUaW1lXCIpO1xyXG4gICAgICAgIHRoaXMuI2RyYWluVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy4jZHJhaW5UaW1lciA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWRzID0gdGhpcy4jcGF5bG9hZHM7XHJcbiAgICAgICAgICAgIHRoaXMuI3BheWxvYWRzID0gW107XHJcbiAgICAgICAgICAgIHdoaWxlIChwYXlsb2Fkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBwYXlsb2FkIGJhdGNoZXMgdGhhdCBzYXRpc2Z5IG91ciBiYXRjaCBjb25zdHJhaW50c1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBbKHBheWxvYWRzLnNoaWZ0KCkpXTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChwYXlsb2Fkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoID09PSB0aGlzLiNvcHRpb25zLmJhdGNoTWF4Q291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoLnB1c2goKHBheWxvYWRzLnNoaWZ0KCkpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IEpTT04uc3RyaW5naWZ5KGJhdGNoLm1hcCgocCkgPT4gcC5wYXlsb2FkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IHRoaXMuI29wdGlvbnMuYmF0Y2hNYXhTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRzLnVuc2hpZnQoKGJhdGNoLnBvcCgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIHJlc3VsdCB0byBlYWNoIHBheWxvYWRcclxuICAgICAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9ICgoYmF0Y2gubGVuZ3RoID09PSAxKSA/IGJhdGNoWzBdLnBheWxvYWQgOiBiYXRjaC5tYXAoKHApID0+IHAucGF5bG9hZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRScGNQYXlsb2FkXCIsIHBheWxvYWQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fc2VuZChwYXlsb2FkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY1Jlc3VsdFwiLCByZXN1bHQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgcmVzdWx0cyBpbiBiYXRjaCBvcmRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0LCBwYXlsb2FkIH0gb2YgYmF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJwcm92aWRlciBkZXN0cm95ZWQ7IGNhbmNlbGxlZCByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBwYXlsb2FkLm1ldGhvZCB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBtYXRjaGluZyByZXN1bHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSByZXN1bHQuZmlsdGVyKChyKSA9PiAoci5pZCA9PT0gcGF5bG9hZC5pZCkpWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gcmVzdWx0OyB0aGUgbm9kZSBmYWlsZWQgdXMgaW4gdW5leHBlY3RlZCB3YXlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBtYWtlRXJyb3IoXCJtaXNzaW5nIHJlc3BvbnNlIGZvciByZXF1ZXN0XCIsIFwiQkFEX0RBVEFcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LCBpbmZvOiB7IHBheWxvYWQgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlc3BvbnNlIGlzIGFuIGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJlcnJvclwiIGluIHJlc3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QodGhpcy5nZXRScGNFcnJvcihwYXlsb2FkLCByZXNwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgZ29vZDsgc2VuZCB0aGUgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3AucmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY0Vycm9yXCIsIGVycm9yIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVqZWN0IH0gb2YgYmF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBhdWdtZW50IHRoZSBlcnJvciB3aXRoIHRoZSBwYXlsb2FkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHN0YWxsVGltZSk7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy4jbmV4dElkID0gMTtcclxuICAgICAgICB0aGlzLiNvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgfHwge30pO1xyXG4gICAgICAgIHRoaXMuI3BheWxvYWRzID0gW107XHJcbiAgICAgICAgdGhpcy4jZHJhaW5UaW1lciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy4jbmV0d29yayA9IG51bGw7XHJcbiAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSBudWxsO1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGV0IHJlc29sdmUgPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKF9yZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlID0gX3Jlc29sdmU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLiNub3RSZWFkeSA9IHsgcHJvbWlzZSwgcmVzb2x2ZSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdGF0aWNOZXR3b3JrID0gdGhpcy5fZ2V0T3B0aW9uKFwic3RhdGljTmV0d29ya1wiKTtcclxuICAgICAgICBpZiAodHlwZW9mIChzdGF0aWNOZXR3b3JrKSA9PT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIXN0YXRpY05ldHdvcmsgfHwgbmV0d29yayAhPT0gXCJhbnlcIiwgXCJzdGF0aWNOZXR3b3JrIGNhbm5vdCBiZSB1c2VkIG9uIHNwZWNpYWwgbmV0d29yayAnYW55J1wiLCBcIm9wdGlvbnNcIiwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGlmIChzdGF0aWNOZXR3b3JrICYmIG5ldHdvcmsgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4jbmV0d29yayA9IE5ldHdvcmsuZnJvbShuZXR3b3JrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzdGF0aWNOZXR3b3JrKSB7XHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBhbnkgc3RhdGljIG5ldHdvcmsgaXMgY29tcGF0YmlsZSB3aXRoIHRoZSBwcm92aWRlZCBuZXR3cm9rXHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KG5ldHdvcmsgPT0gbnVsbCB8fCBzdGF0aWNOZXR3b3JrLm1hdGNoZXMobmV0d29yayksIFwic3RhdGljTmV0d29yayBNVVNUIG1hdGNoIG5ldHdvcmsgb2JqZWN0XCIsIFwib3B0aW9uc1wiLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgdGhpcy4jbmV0d29yayA9IHN0YXRpY05ldHdvcms7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBvcHRpb24gJSVrZXklJS5cclxuICAgICAqXHJcbiAgICAgKiAgU3ViLWNsYXNzZXMgY2FuIHVzZSB0aGlzIHRvIGlucXVpcmUgYWJvdXQgY29uZmlndXJhdGlvbiBvcHRpb25zLlxyXG4gICAgICovXHJcbiAgICBfZ2V0T3B0aW9uKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNvcHRpb25zW2tleV07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBHZXRzIHRoZSBbW05ldHdvcmtdXSB0aGlzIHByb3ZpZGVyIGhhcyBjb21taXR0ZWQgdG8uIE9uIGVhY2ggY2FsbCwgdGhlIG5ldHdvcmtcclxuICAgICAqICBpcyBkZXRlY3RlZCwgYW5kIGlmIGl0IGhhcyBjaGFuZ2VkLCB0aGUgY2FsbCB3aWxsIHJlamVjdC5cclxuICAgICAqL1xyXG4gICAgZ2V0IF9uZXR3b3JrKCkge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLiNuZXR3b3JrLCBcIm5ldHdvcmsgaXMgbm90IGF2YWlsYWJsZSB5ZXRcIiwgXCJORVRXT1JLX0VSUk9SXCIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNuZXR3b3JrO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIG5vbi1ub3JtYWxpemVkIHZhbHVlIGJ5IHBlcmZvcm1pbmcgJSVyZXElJS5cclxuICAgICAqXHJcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gbW9kaWZ5IGJlaGF2aW9yIG9mIGFjdGlvbnMsXHJcbiAgICAgKiAgYW5kIHNob3VsZCBnZW5lcmFsbHkgY2FsbCBgYHN1cGVyLl9wZXJmb3JtYGAgYXMgYSBmYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgX3BlcmZvcm0ocmVxKSB7XHJcbiAgICAgICAgLy8gTGVnYWN5IG5ldHdvcmtzIGRvIG5vdCBsaWtlIHRoZSB0eXBlIGZpZWxkIGJlaW5nIHBhc3NlZCBhbG9uZyAod2hpY2hcclxuICAgICAgICAvLyBpcyBmYWlyKSwgc28gd2UgZGVsZXRlIHR5cGUgaWYgaXQgaXMgMCBhbmQgYSBub24tRUlQLTE1NTkgbmV0d29ya1xyXG4gICAgICAgIGlmIChyZXEubWV0aG9kID09PSBcImNhbGxcIiB8fCByZXEubWV0aG9kID09PSBcImVzdGltYXRlR2FzXCIpIHtcclxuICAgICAgICAgICAgbGV0IHR4ID0gcmVxLnRyYW5zYWN0aW9uO1xyXG4gICAgICAgICAgICBpZiAodHggJiYgdHgudHlwZSAhPSBudWxsICYmIGdldEJpZ0ludCh0eC50eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIEVJUC0xNTU5IG9yIG5ld2VyIHByb3BlcnRpZXMsIGl0IG1pZ2h0IGJlIHByZS1FSVAtMTU1OVxyXG4gICAgICAgICAgICAgICAgaWYgKHR4Lm1heEZlZVBlckdhcyA9PSBudWxsICYmIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZWVEYXRhID0gYXdhaXQgdGhpcy5nZXRGZWVEYXRhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlZURhdGEubWF4RmVlUGVyR2FzID09IG51bGwgJiYgZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBrbm93IGFib3V0IEVJUC0xNTU5IChhbmQgaGVuY2UgdHlwZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbih7fSwgdHgsIHsgdHlwZTogdW5kZWZpbmVkIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5nZXRScGNSZXF1ZXN0KHJlcSk7XHJcbiAgICAgICAgaWYgKHJlcXVlc3QgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VwZXIuX3BlcmZvcm0ocmVxKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzOyBpdCBkZXRlY3RzIHRoZSAqYWN0dWFsKiBuZXR3b3JrIHRoYXRcclxuICAgICAqICB3ZSBhcmUgKipjdXJyZW50bHkqKiBjb25uZWN0ZWQgdG8uXHJcbiAgICAgKlxyXG4gICAgICogIEtlZXAgaW4gbWluZCB0aGF0IFtbc2VuZF1dIG1heSBvbmx5IGJlIHVzZWQgb25jZSBbW3JlYWR5XV0sIG90aGVyd2lzZSB0aGVcclxuICAgICAqICBfc2VuZCBwcmltaXRpdmUgbXVzdCBiZSB1c2VkIGluc3RlYWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIF9kZXRlY3ROZXR3b3JrKCkge1xyXG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSB0aGlzLl9nZXRPcHRpb24oXCJzdGF0aWNOZXR3b3JrXCIpO1xyXG4gICAgICAgIGlmIChuZXR3b3JrKSB7XHJcbiAgICAgICAgICAgIGlmIChuZXR3b3JrID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jbmV0d29yaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiNuZXR3b3JrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgd2UgYXJlIHJlYWR5LCB1c2UgYGBzZW5kYGAsIHdoaWNoIGVuYWJsZWQgcmVxdWVzdHMgdG8gYmUgYmF0Y2hlZFxyXG4gICAgICAgIGlmICh0aGlzLnJlYWR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gTmV0d29yay5mcm9tKGdldEJpZ0ludChhd2FpdCB0aGlzLnNlbmQoXCJldGhfY2hhaW5JZFwiLCBbXSkpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZSBhcmUgbm90IHJlYWR5IHlldDsgdXNlIHRoZSBwcmltaXRpdmUgX3NlbmRcclxuICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XHJcbiAgICAgICAgICAgICAgICBpZDogdGhpcy4jbmV4dElkKyssIG1ldGhvZDogXCJldGhfY2hhaW5JZFwiLCBwYXJhbXM6IFtdLCBqc29ucnBjOiBcIjIuMFwiXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRScGNQYXlsb2FkXCIsIHBheWxvYWQgfSk7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAoYXdhaXQgdGhpcy5fc2VuZChwYXlsb2FkKSlbMF07XHJcbiAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUnBjRXJyb3JcIiwgZXJyb3IgfSk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUnBjUmVzdWx0XCIsIHJlc3VsdCB9KTtcclxuICAgICAgICAgICAgaWYgKFwicmVzdWx0XCIgaW4gcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTmV0d29yay5mcm9tKGdldEJpZ0ludChyZXN1bHQucmVzdWx0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgdGhpcy5nZXRScGNFcnJvcihwYXlsb2FkLCByZXN1bHQpO1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgU3ViLWNsYXNzZXMgKipNVVNUKiogY2FsbCB0aGlzLiBVbnRpbCBbW19zdGFydF1dIGhhcyBiZWVuIGNhbGxlZCwgbm8gY2FsbHNcclxuICAgICAqICB3aWxsIGJlIHBhc3NlZCB0byBbW19zZW5kXV0gZnJvbSBbW3NlbmRdXS4gSWYgaXQgaXMgb3ZlcnJpZGRlbiwgdGhlblxyXG4gICAgICogIGBgc3VwZXIuX3N0YXJ0KClgYCAqKk1VU1QqKiBiZSBjYWxsZWQuXHJcbiAgICAgKlxyXG4gICAgICogIENhbGxpbmcgaXQgbXVsdGlwbGUgdGltZXMgaXMgc2FmZSBhbmQgaGFzIG5vIGVmZmVjdC5cclxuICAgICAqL1xyXG4gICAgX3N0YXJ0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLiNub3RSZWFkeSA9PSBudWxsIHx8IHRoaXMuI25vdFJlYWR5LnJlc29sdmUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuI25vdFJlYWR5LnJlc29sdmUoKTtcclxuICAgICAgICB0aGlzLiNub3RSZWFkeSA9IG51bGw7XHJcbiAgICAgICAgKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgLy8gQm9vdHN0cmFwIHRoZSBuZXR3b3JrXHJcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLiNuZXR3b3JrID09IG51bGwgJiYgIXRoaXMuZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBhd2FpdCB0aGlzLl9kZXRlY3ROZXR3b3JrKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSnNvblJwY1Byb3ZpZGVyIGZhaWxlZCB0byBkZXRlY3QgbmV0d29yayBhbmQgY2Fubm90IHN0YXJ0IHVwOyByZXRyeSBpbiAxcyAocGVyaGFwcyB0aGUgVVJMIGlzIHdyb25nIG9yIHRoZSBub2RlIGlzIG5vdCBzdGFydGVkKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBtYWtlRXJyb3IoXCJmYWlsZWQgdG8gYm9vdHN0cmFwIG5ldHdvcmsgZGV0ZWN0aW9uXCIsIFwiTkVUV09SS19FUlJPUlwiLCB7IGV2ZW50OiBcImluaXRpYWwtbmV0d29yay1kaXNjb3ZlcnlcIiwgaW5mbzogeyBlcnJvciB9IH0pKTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzdGFsbCgxMDAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTdGFydCBkaXNwYXRjaGluZyByZXF1ZXN0c1xyXG4gICAgICAgICAgICB0aGlzLiNzY2hlZHVsZURyYWluKCk7XHJcbiAgICAgICAgfSkoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhlIFtbX3N0YXJ0XV0gaGFzIGJlZW4gY2FsbGVkLiBUaGlzIGNhbiBiZSB1c2VkIGluXHJcbiAgICAgKiAgc3ViLWNsYXNzZXMgdG8gZGVmZXIgc2VuZGluZyBkYXRhIHVudGlsIHRoZSBjb25uZWN0aW9uIGhhcyBiZWVuXHJcbiAgICAgKiAgZXN0YWJsaXNoZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIF93YWl0VW50aWxSZWFkeSgpIHtcclxuICAgICAgICBpZiAodGhpcy4jbm90UmVhZHkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNub3RSZWFkeS5wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgU3Vic2NyaWJlciB0aGF0IHdpbGwgbWFuYWdlIHRoZSAlJXN1YiUlLlxyXG4gICAgICpcclxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyB0byBtb2RpZnkgdGhlIGJlaGF2aW9yIG9mXHJcbiAgICAgKiAgc3Vic2NyaXB0aW9uIG1hbmFnZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIF9nZXRTdWJzY3JpYmVyKHN1Yikge1xyXG4gICAgICAgIC8vIFBlbmRpbmcgRmlsdGVycyBhcmVuJ3QgYXZhaWxibGUgdmlhIHBvbGxpbmdcclxuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwicGVuZGluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlcih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcImV2ZW50XCIpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2dldE9wdGlvbihcInBvbGxpbmdcIikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9sbGluZ0V2ZW50U3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpbHRlcklkRXZlbnRTdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPcnBoYW5lZCBMb2dzIGFyZSBoYW5kbGVkIGF1dG9tYXRpY2FsbHksIGJ5IHRoZSBmaWx0ZXIsIHNpbmNlXHJcbiAgICAgICAgLy8gbG9ncyB3aXRoIHJlbW92ZWQgYXJlIGVtaXR0ZWQgYnkgaXRcclxuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwib3JwaGFuXCIgJiYgc3ViLmZpbHRlci5vcnBoYW4gPT09IFwiZHJvcC1sb2dcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVubWFuYWdlZFN1YnNjcmliZXIoXCJvcnBoYW5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdXBlci5fZ2V0U3Vic2NyaWJlcihzdWIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIG9ubHkgaWYgdGhlIFtbX3N0YXJ0XV0gaGFzIGJlZW4gY2FsbGVkLlxyXG4gICAgICovXHJcbiAgICBnZXQgcmVhZHkoKSB7IHJldHVybiB0aGlzLiNub3RSZWFkeSA9PSBudWxsOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zICUldHglJSBhcyBhIG5vcm1hbGl6ZWQgSlNPTi1SUEMgdHJhbnNhY3Rpb24gcmVxdWVzdCxcclxuICAgICAqICB3aGljaCBoYXMgYWxsIHZhbHVlcyBoZXhsaWZpZWQgYW5kIGFueSBudW1lcmljIHZhbHVlcyBjb252ZXJ0ZWRcclxuICAgICAqICB0byBRdWFudGl0eSB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIGdldFJwY1RyYW5zYWN0aW9uKHR4KSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XHJcbiAgICAgICAgLy8gSlNPTi1SUEMgbm93IHJlcXVpcmVzIG51bWVyaWMgdmFsdWVzIHRvIGJlIFwicXVhbnRpdHlcIiB2YWx1ZXNcclxuICAgICAgICBbXCJjaGFpbklkXCIsIFwiZ2FzTGltaXRcIiwgXCJnYXNQcmljZVwiLCBcInR5cGVcIiwgXCJtYXhGZWVQZXJHYXNcIiwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcIm5vbmNlXCIsIFwidmFsdWVcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0eFtrZXldID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgZHN0S2V5ID0ga2V5O1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImdhc0xpbWl0XCIpIHtcclxuICAgICAgICAgICAgICAgIGRzdEtleSA9IFwiZ2FzXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0W2RzdEtleV0gPSB0b1F1YW50aXR5KGdldEJpZ0ludCh0eFtrZXldLCBgdHguJHtrZXl9YCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhZGRyZXNzZXMgYW5kIGRhdGEgYXJlIGxvd2VyY2FzZVxyXG4gICAgICAgIFtcImZyb21cIiwgXCJ0b1wiLCBcImRhdGFcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0eFtrZXldID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGhleGxpZnkodHhba2V5XSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBhY2Nlc3MgbGlzdCBvYmplY3RcclxuICAgICAgICBpZiAodHguYWNjZXNzTGlzdCkge1xyXG4gICAgICAgICAgICByZXN1bHRbXCJhY2Nlc3NMaXN0XCJdID0gYWNjZXNzTGlzdGlmeSh0eC5hY2Nlc3NMaXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMpIHtcclxuICAgICAgICAgICAgLy8gQFRPRE86IFJlbW92ZSB0aGlzIDxhbnk+IGNhc2Ugb25jZSBFSVAtNDg0NCBhZGRlZCB0byBwcmVwYXJlZCB0eFxyXG4gICAgICAgICAgICByZXN1bHRbXCJibG9iVmVyc2lvbmVkSGFzaGVzXCJdID0gdHguYmxvYlZlcnNpb25lZEhhc2hlcy5tYXAoaCA9PiBoLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHguYXV0aG9yaXphdGlvbkxpc3QpIHtcclxuICAgICAgICAgICAgcmVzdWx0W1wiYXV0aG9yaXphdGlvbkxpc3RcIl0gPSB0eC5hdXRob3JpemF0aW9uTGlzdC5tYXAoKF9hKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gYXV0aG9yaXphdGlvbmlmeShfYSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGEuYWRkcmVzcyxcclxuICAgICAgICAgICAgICAgICAgICBub25jZTogdG9RdWFudGl0eShhLm5vbmNlKSxcclxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiB0b1F1YW50aXR5KGEuY2hhaW5JZCksXHJcbiAgICAgICAgICAgICAgICAgICAgeVBhcml0eTogdG9RdWFudGl0eShhLnNpZ25hdHVyZS55UGFyaXR5KSxcclxuICAgICAgICAgICAgICAgICAgICByOiB0b1F1YW50aXR5KGEuc2lnbmF0dXJlLnIpLFxyXG4gICAgICAgICAgICAgICAgICAgIHM6IHRvUXVhbnRpdHkoYS5zaWduYXR1cmUucyksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQFRPRE86IGJsb2JzIHNob3VsZCBwcm9iYWJseSBhbHNvIGJlIGNvcGllZCBvdmVyLCBvcHRpb25hbGx5XHJcbiAgICAgICAgLy8gYWNjb3VudGluZyBmb3IgdGhlIGt6ZyBwcm9wZXJ0eSB0byBiYWNrZmlsbCBibG9iVmVyc2lvbmVkSGFzaGVzXHJcbiAgICAgICAgLy8gdXNpbmcgdGhlIGNvbW1pdG1lbnQuIE9yIHNob3VsZCB0aGF0IGJlIGxlZnQgYXMgYW4gZXhlcmNpc2UgdG9cclxuICAgICAgICAvLyB0aGUgY2FsbGVyP1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRoZSByZXF1ZXN0IG1ldGhvZCBhbmQgYXJndW1lbnRzIHJlcXVpcmVkIHRvIHBlcmZvcm1cclxuICAgICAqICAlJXJlcSUlLlxyXG4gICAgICovXHJcbiAgICBnZXRScGNSZXF1ZXN0KHJlcSkge1xyXG4gICAgICAgIHN3aXRjaCAocmVxLm1ldGhvZCkge1xyXG4gICAgICAgICAgICBjYXNlIFwiY2hhaW5JZFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9jaGFpbklkXCIsIGFyZ3M6IFtdIH07XHJcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9ibG9ja051bWJlclwiLCBhcmdzOiBbXSB9O1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfZ2FzUHJpY2VcIiwgYXJnczogW10gfTtcclxuICAgICAgICAgICAgY2FzZSBcImdldFByaW9yaXR5RmVlXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX21heFByaW9yaXR5RmVlUGVyR2FzXCIsIGFyZ3M6IFtdIH07XHJcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmFsYW5jZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtnZXRMb3dlckNhc2UocmVxLmFkZHJlc3MpLCByZXEuYmxvY2tUYWddXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFRyYW5zYWN0aW9uQ291bnRcIixcclxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSwgcmVxLmJsb2NrVGFnXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY2FzZSBcImdldENvZGVcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRDb2RlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2dldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksIHJlcS5ibG9ja1RhZ11cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0U3RvcmFnZUF0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRMb3dlckNhc2UocmVxLmFkZHJlc3MpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCIweFwiICsgcmVxLnBvc2l0aW9uLnRvU3RyaW5nKDE2KSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5ibG9ja1RhZ1xyXG4gICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNhc2UgXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuc2lnbmVkVHJhbnNhY3Rpb25dXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjpcclxuICAgICAgICAgICAgICAgIGlmIChcImJsb2NrVGFnXCIgaW4gcmVxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRCbG9ja0J5TnVtYmVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuYmxvY2tUYWcsICEhcmVxLmluY2x1ZGVUcmFuc2FjdGlvbnNdXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiYmxvY2tIYXNoXCIgaW4gcmVxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRCbG9ja0J5SGFzaFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmJsb2NrSGFzaCwgISFyZXEuaW5jbHVkZVRyYW5zYWN0aW9uc11cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5oYXNoXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuaGFzaF1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfY2FsbFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt0aGlzLmdldFJwY1RyYW5zYWN0aW9uKHJlcS50cmFuc2FjdGlvbiksIHJlcS5ibG9ja1RhZ11cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZXN0aW1hdGVHYXNcIixcclxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbdGhpcy5nZXRScGNUcmFuc2FjdGlvbihyZXEudHJhbnNhY3Rpb24pXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOlxyXG4gICAgICAgICAgICAgICAgaWYgKHJlcS5maWx0ZXIgJiYgcmVxLmZpbHRlci5hZGRyZXNzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXEuZmlsdGVyLmFkZHJlc3MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5maWx0ZXIuYWRkcmVzcyA9IHJlcS5maWx0ZXIuYWRkcmVzcy5tYXAoZ2V0TG93ZXJDYXNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5maWx0ZXIuYWRkcmVzcyA9IGdldExvd2VyQ2FzZShyZXEuZmlsdGVyLmFkZHJlc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfZ2V0TG9nc1wiLCBhcmdzOiBbcmVxLmZpbHRlcl0gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGFuIGV0aGVycy1zdHlsZSBFcnJvciBmb3IgdGhlIGdpdmVuIEpTT04tUlBDIGVycm9yXHJcbiAgICAgKiAgJSVwYXlsb2FkJSUsIGNvYWxlc2NpbmcgdGhlIHZhcmlvdXMgc3RyaW5ncyBhbmQgZXJyb3Igc2hhcGVzXHJcbiAgICAgKiAgdGhhdCBkaWZmZXJlbnQgbm9kZXMgcmV0dXJuLCBjb2VyY2luZyB0aGVtIGludG8gYSBtYWNoaW5lLXJlYWRhYmxlXHJcbiAgICAgKiAgc3RhbmRhcmRpemVkIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBnZXRScGNFcnJvcihwYXlsb2FkLCBfZXJyb3IpIHtcclxuICAgICAgICBjb25zdCB7IG1ldGhvZCB9ID0gcGF5bG9hZDtcclxuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBfZXJyb3I7XHJcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJldGhfZXN0aW1hdGVHYXNcIiAmJiBlcnJvci5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGVycm9yLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgIGlmICghbXNnLm1hdGNoKC9yZXZlcnQvaSkgJiYgbXNnLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHMvaSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHNcIiwgXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiAocGF5bG9hZC5wYXJhbXNbMF0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZm86IHsgcGF5bG9hZCwgZXJyb3IgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobXNnLm1hdGNoKC9ub25jZS9pKSAmJiBtc2cubWF0Y2goL3RvbyBsb3cvaSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgXCJOT05DRV9FWFBJUkVEXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogKHBheWxvYWQucGFyYW1zWzBdKSxcclxuICAgICAgICAgICAgICAgICAgICBpbmZvOiB7IHBheWxvYWQsIGVycm9yIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiZXRoX2NhbGxcIiB8fCBtZXRob2QgPT09IFwiZXRoX2VzdGltYXRlR2FzXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3BlbHVua0RhdGEoZXJyb3IpO1xyXG4gICAgICAgICAgICBjb25zdCBlID0gQWJpQ29kZXIuZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oKG1ldGhvZCA9PT0gXCJldGhfY2FsbFwiKSA/IFwiY2FsbFwiIDogXCJlc3RpbWF0ZUdhc1wiLCAocGF5bG9hZC5wYXJhbXNbMF0pLCAocmVzdWx0ID8gcmVzdWx0LmRhdGEgOiBudWxsKSk7XHJcbiAgICAgICAgICAgIGUuaW5mbyA9IHsgZXJyb3IsIHBheWxvYWQgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE9ubHkgZXN0aW1hdGVHYXMgYW5kIGNhbGwgY2FuIHJldHVybiBhcmJpdHJhcnkgY29udHJhY3QtZGVmaW5lZCB0ZXh0LCBzbyBub3cgd2VcclxuICAgICAgICAvLyB3ZSBjYW4gcHJvY2VzcyB0ZXh0IHNhZmVseS5cclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoc3BlbHVua01lc3NhZ2UoZXJyb3IpKTtcclxuICAgICAgICBpZiAodHlwZW9mIChlcnJvci5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiBlcnJvci5tZXNzYWdlLm1hdGNoKC91c2VyIGRlbmllZHxldGhlcnMtdXNlci1kZW5pZWQvaSkpIHtcclxuICAgICAgICAgICAgY29uc3QgYWN0aW9uTWFwID0ge1xyXG4gICAgICAgICAgICAgICAgZXRoX3NpZ246IFwic2lnbk1lc3NhZ2VcIixcclxuICAgICAgICAgICAgICAgIHBlcnNvbmFsX3NpZ246IFwic2lnbk1lc3NhZ2VcIixcclxuICAgICAgICAgICAgICAgIGV0aF9zaWduVHlwZWREYXRhX3Y0OiBcInNpZ25UeXBlZERhdGFcIixcclxuICAgICAgICAgICAgICAgIGV0aF9zaWduVHJhbnNhY3Rpb246IFwic2lnblRyYW5zYWN0aW9uXCIsXHJcbiAgICAgICAgICAgICAgICBldGhfc2VuZFRyYW5zYWN0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgZXRoX3JlcXVlc3RBY2NvdW50czogXCJyZXF1ZXN0QWNjZXNzXCIsXHJcbiAgICAgICAgICAgICAgICB3YWxsZXRfcmVxdWVzdEFjY291bnRzOiBcInJlcXVlc3RBY2Nlc3NcIixcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihgdXNlciByZWplY3RlZCBhY3Rpb25gLCBcIkFDVElPTl9SRUpFQ1RFRFwiLCB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb246IChhY3Rpb25NYXBbbWV0aG9kXSB8fCBcInVua25vd25cIiksXHJcbiAgICAgICAgICAgICAgICByZWFzb246IFwicmVqZWN0ZWRcIixcclxuICAgICAgICAgICAgICAgIGluZm86IHsgcGF5bG9hZCwgZXJyb3IgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCIgfHwgbWV0aG9kID09PSBcImV0aF9zZW5kVHJhbnNhY3Rpb25cIikge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IChwYXlsb2FkLnBhcmFtc1swXSk7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHN8YmFzZSBmZWUgZXhjZWVkcyBnYXMgbGltaXQvaSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGludHJpbnNpYyB0cmFuc2FjdGlvbiBjb3N0XCIsIFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvbm9uY2UvaSkgJiYgbWVzc2FnZS5tYXRjaCgvdG9vIGxvdy9pKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcIm5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFwiLCBcIk5PTkNFX0VYUElSRURcIiwgeyB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFwicmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWRcIlxyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvcmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24vaSkgJiYgbWVzc2FnZS5tYXRjaCgvdW5kZXJwcmljZWQvaSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJyZXBsYWNlbWVudCBmZWUgdG9vIGxvd1wiLCBcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCIsIHsgdHJhbnNhY3Rpb24sIGluZm86IHsgZXJyb3IgfSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvb25seSByZXBsYXktcHJvdGVjdGVkL2kpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwibGVnYWN5IHByZS1laXAtMTU1IHRyYW5zYWN0aW9ucyBub3Qgc3VwcG9ydGVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IG1ldGhvZCwgaW5mbzogeyB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9IH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB1bnN1cHBvcnRlZCA9ICEhbWVzc2FnZS5tYXRjaCgvdGhlIG1ldGhvZCAuKiBkb2VzIG5vdCBleGlzdC9pKTtcclxuICAgICAgICBpZiAoIXVuc3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5kZXRhaWxzICYmIGVycm9yLmRldGFpbHMuc3RhcnRzV2l0aChcIlVuYXV0aG9yaXplZCBtZXRob2Q6XCIpKSB7XHJcbiAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVuc3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJ1bnN1cHBvcnRlZCBvcGVyYXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBwYXlsb2FkLm1ldGhvZCwgaW5mbzogeyBlcnJvciwgcGF5bG9hZCB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwiY291bGQgbm90IGNvYWxlc2NlIGVycm9yXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7IGVycm9yLCBwYXlsb2FkIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVxdWVzdHMgdGhlICUlbWV0aG9kJSUgd2l0aCAlJXBhcmFtcyUlIHZpYSB0aGUgSlNPTi1SUEMgcHJvdG9jb2xcclxuICAgICAqICBvdmVyIHRoZSB1bmRlcmx5aW5nIGNoYW5uZWwuIFRoaXMgY2FuIGJlIHVzZWQgdG8gY2FsbCBtZXRob2RzXHJcbiAgICAgKiAgb24gdGhlIGJhY2tlbmQgdGhhdCBkbyBub3QgaGF2ZSBhIGhpZ2gtbGV2ZWwgQVBJIHdpdGhpbiB0aGUgUHJvdmlkZXJcclxuICAgICAqICBBUEkuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgbWV0aG9kIHF1ZXVlcyByZXF1ZXN0cyBhY2NvcmRpbmcgdG8gdGhlIGJhdGNoIGNvbnN0cmFpbnRzXHJcbiAgICAgKiAgaW4gdGhlIG9wdGlvbnMsIGFzc2lnbnMgdGhlIHJlcXVlc3QgYSB1bmlxdWUgSUQuXHJcbiAgICAgKlxyXG4gICAgICogICoqRG8gTk9UIG92ZXJyaWRlKiogdGhpcyBtZXRob2QgaW4gc3ViLWNsYXNzZXM7IGluc3RlYWRcclxuICAgICAqICBvdmVycmlkZSBbW19zZW5kXV0gb3IgZm9yY2UgdGhlIG9wdGlvbnMgdmFsdWVzIGluIHRoZVxyXG4gICAgICogIGNhbGwgdG8gdGhlIGNvbnN0cnVjdG9yIHRvIG1vZGlmeSB0aGlzIG1ldGhvZCdzIGJlaGF2aW9yLlxyXG4gICAgICovXHJcbiAgICBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XHJcbiAgICAgICAgLy8gQFRPRE86IGNhY2hlIGNoYWluSWQ/PyBwdXJnZSBvbiBzd2l0Y2hfbmV0d29ya3NcclxuICAgICAgICAvLyBXZSBoYXZlIGJlZW4gZGVzdHJveWVkOyBubyBvcGVyYXRpb25zIGFyZSBzdXBwb3J0ZWQgYW55bW9yZVxyXG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobWFrZUVycm9yKFwicHJvdmlkZXIgZGVzdHJveWVkOyBjYW5jZWxsZWQgcmVxdWVzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogbWV0aG9kIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLiNuZXh0SWQrKztcclxuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLiNwYXlsb2Fkcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUsIHJlamVjdCxcclxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHsgbWV0aG9kLCBwYXJhbXMsIGlkLCBqc29ucnBjOiBcIjIuMFwiIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm90IGEgcGVuZGluZyBkcmFpblRpbWVyLCBzZXQgb25lXHJcbiAgICAgICAgdGhpcy4jc2NoZWR1bGVEcmFpbigpO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIFtbU2lnbmVyXV0gYWNjb3VudCBmb3IgICUlYWRkcmVzcyUlIG1hbmFnZWQgYnlcclxuICAgICAqICB0aGUgY2xpZW50LlxyXG4gICAgICpcclxuICAgICAqICBJZiB0aGUgJSVhZGRyZXNzJSUgaXMgYSBudW1iZXIsIGl0IGlzIHVzZWQgYXMgYW4gaW5kZXggaW4gdGhlXHJcbiAgICAgKiAgdGhlIGFjY291bnRzIGZyb20gW1tsaXN0QWNjb3VudHNdXS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBjYW4gb25seSBiZSB1c2VkIG9uIGNsaWVudHMgd2hpY2ggbWFuYWdlIGFjY291bnRzIChzdWNoIGFzXHJcbiAgICAgKiAgR2V0aCB3aXRoIGltcG9ydGVkIGFjY291bnQgb3IgTWV0YU1hc2spLlxyXG4gICAgICpcclxuICAgICAqICBUaHJvd3MgaWYgdGhlIGFjY291bnQgZG9lc24ndCBleGlzdC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0U2lnbmVyKGFkZHJlc3MpIHtcclxuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGFkZHJlc3MgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhY2NvdW50c1Byb21pc2UgPSB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pO1xyXG4gICAgICAgIC8vIEFjY291bnQgaW5kZXhcclxuICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzKSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IChhd2FpdCBhY2NvdW50c1Byb21pc2UpO1xyXG4gICAgICAgICAgICBpZiAoYWRkcmVzcyA+PSBhY2NvdW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIHN1Y2ggYWNjb3VudFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEpzb25ScGNTaWduZXIodGhpcywgYWNjb3VudHNbYWRkcmVzc10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IGFjY291bnRzIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XHJcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxyXG4gICAgICAgICAgICBhY2NvdW50czogYWNjb3VudHNQcm9taXNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gQWNjb3VudCBhZGRyZXNzXHJcbiAgICAgICAgYWRkcmVzcyA9IGdldEFkZHJlc3MoYWRkcmVzcyk7XHJcbiAgICAgICAgZm9yIChjb25zdCBhY2NvdW50IG9mIGFjY291bnRzKSB7XHJcbiAgICAgICAgICAgIGlmIChnZXRBZGRyZXNzKGFjY291bnQpID09PSBhZGRyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEpzb25ScGNTaWduZXIodGhpcywgYWRkcmVzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhY2NvdW50XCIpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgbGlzdEFjY291bnRzKCkge1xyXG4gICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKTtcclxuICAgICAgICByZXR1cm4gYWNjb3VudHMubWFwKChhKSA9PiBuZXcgSnNvblJwY1NpZ25lcih0aGlzLCBhKSk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIC8vIFN0b3AgcHJvY2Vzc2luZyByZXF1ZXN0c1xyXG4gICAgICAgIGlmICh0aGlzLiNkcmFpblRpbWVyKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNkcmFpblRpbWVyKTtcclxuICAgICAgICAgICAgdGhpcy4jZHJhaW5UaW1lciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbmNlbCBhbGwgcGVuZGluZyByZXF1ZXN0c1xyXG4gICAgICAgIGZvciAoY29uc3QgeyBwYXlsb2FkLCByZWplY3QgfSBvZiB0aGlzLiNwYXlsb2Fkcykge1xyXG4gICAgICAgICAgICByZWplY3QobWFrZUVycm9yKFwicHJvdmlkZXIgZGVzdHJveWVkOyBjYW5jZWxsZWQgcmVxdWVzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogcGF5bG9hZC5tZXRob2QgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xyXG4gICAgICAgIC8vIFBhcmVudCBjbGVhbi11cFxyXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxufVxyXG4vLyBAVE9ETzogcmVtb3ZlIHRoaXMgaW4gdjcsIGl0IGlzIG5vdCBleHBvcnRlZCBiZWNhdXNlIHRoaXMgZnVuY3Rpb25hbGl0eVxyXG4vLyBpcyBleHBvc2VkIGluIHRoZSBKc29uUnBjQXBpUHJvdmlkZXIgYnkgc2V0dGluZyBwb2xsaW5nIHRvIHRydWUuIEl0IHNob3VsZFxyXG4vLyBiZSBzYWZlIHRvIHJlbW92ZSByZWdhcmRsZXNzLCBiZWNhdXNlIGl0IGlzbid0IHJlYWNoYWJsZSwgYnV0IGp1c3QgaW4gY2FzZS5cclxuLyoqXHJcbiAqICBAX2lnbm9yZTpcclxuICovXHJcbmV4cG9ydCBjbGFzcyBKc29uUnBjQXBpUG9sbGluZ1Byb3ZpZGVyIGV4dGVuZHMgSnNvblJwY0FwaVByb3ZpZGVyIHtcclxuICAgICNwb2xsaW5nSW50ZXJ2YWw7XHJcbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XHJcbiAgICAgICAgbGV0IHBvbGxpbmdJbnRlcnZhbCA9IHRoaXMuX2dldE9wdGlvbihcInBvbGxpbmdJbnRlcnZhbFwiKTtcclxuICAgICAgICBpZiAocG9sbGluZ0ludGVydmFsID09IG51bGwpIHtcclxuICAgICAgICAgICAgcG9sbGluZ0ludGVydmFsID0gZGVmYXVsdE9wdGlvbnMucG9sbGluZ0ludGVydmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiNwb2xsaW5nSW50ZXJ2YWwgPSBwb2xsaW5nSW50ZXJ2YWw7XHJcbiAgICB9XHJcbiAgICBfZ2V0U3Vic2NyaWJlcihzdWIpIHtcclxuICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gc3VwZXIuX2dldFN1YnNjcmliZXIoc3ViKTtcclxuICAgICAgICBpZiAoaXNQb2xsYWJsZShzdWJzY3JpYmVyKSkge1xyXG4gICAgICAgICAgICBzdWJzY3JpYmVyLnBvbGxpbmdJbnRlcnZhbCA9IHRoaXMuI3BvbGxpbmdJbnRlcnZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgcG9sbGluZyBpbnRlcnZhbCAoZGVmYXVsdDogNDAwMCBtcylcclxuICAgICAqL1xyXG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHsgcmV0dXJuIHRoaXMuI3BvbGxpbmdJbnRlcnZhbDsgfVxyXG4gICAgc2V0IHBvbGxpbmdJbnRlcnZhbCh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgdmFsdWUgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50ZXJ2YWxcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuI3BvbGxpbmdJbnRlcnZhbCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzdWIpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzUG9sbGFibGUoc3ViKSkge1xyXG4gICAgICAgICAgICAgICAgc3ViLnBvbGxpbmdJbnRlcnZhbCA9IHRoaXMuI3BvbGxpbmdJbnRlcnZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgVGhlIEpzb25ScGNQcm92aWRlciBpcyBvbmUgb2YgdGhlIG1vc3QgY29tbW9uIFByb3ZpZGVycyxcclxuICogIHdoaWNoIHBlcmZvcm1zIGFsbCBvcGVyYXRpb25zIG92ZXIgSFRUUCAob3IgSFRUUFMpIHJlcXVlc3RzLlxyXG4gKlxyXG4gKiAgRXZlbnRzIGFyZSBwcm9jZXNzZWQgYnkgcG9sbGluZyB0aGUgYmFja2VuZCBmb3IgdGhlIGN1cnJlbnQgYmxvY2tcclxuICogIG51bWJlcjsgd2hlbiBpdCBhZHZhbmNlcywgYWxsIGJsb2NrLWJhc2UgZXZlbnRzIGFyZSB0aGVuIGNoZWNrZWRcclxuICogIGZvciB1cGRhdGVzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEpzb25ScGNQcm92aWRlciBleHRlbmRzIEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIge1xyXG4gICAgI2Nvbm5lY3Q7XHJcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG5ldHdvcmssIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAodXJsID09IG51bGwpIHtcclxuICAgICAgICAgICAgdXJsID0gXCJodHRwOi9cXC9sb2NhbGhvc3Q6ODU0NVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcclxuICAgICAgICBpZiAodHlwZW9mICh1cmwpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QgPSBuZXcgRmV0Y2hSZXF1ZXN0KHVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLiNjb25uZWN0ID0gdXJsLmNsb25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2dldENvbm5lY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Nvbm5lY3QuY2xvbmUoKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcclxuICAgICAgICAvLyBBbGwgcmVxdWVzdHMgYXJlIG92ZXIgSFRUUCwgc28gd2UgY2FuIGp1c3Qgc3RhcnQgaGFuZGxpbmcgcmVxdWVzdHNcclxuICAgICAgICAvLyBXZSBkbyB0aGlzIGhlcmUgcmF0aGVyIHRoYW4gdGhlIGNvbnN0cnVjdG9yIHNvIHRoYXQgd2UgZG9uJ3Qgc2VuZCBhbnlcclxuICAgICAgICAvLyByZXF1ZXN0cyB0byB0aGUgbmV0d29yayAoaS5lLiBldGhfY2hhaW5JZCkgdW50aWwgd2UgYWJzb2x1dGVseSBoYXZlIHRvLlxyXG4gICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0KCk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHN1cGVyLnNlbmQobWV0aG9kLCBwYXJhbXMpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgX3NlbmQocGF5bG9hZCkge1xyXG4gICAgICAgIC8vIENvbmZpZ3VyZSBhIFBPU1QgY29ubmVjdGlvbiBmb3IgdGhlIHJlcXVlc3RlZCBtZXRob2RcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fZ2V0Q29ubmVjdGlvbigpO1xyXG4gICAgICAgIHJlcXVlc3QuYm9keSA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xyXG4gICAgICAgIHJlcXVlc3Quc2V0SGVhZGVyKFwiY29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3Quc2VuZCgpO1xyXG4gICAgICAgIHJlc3BvbnNlLmFzc2VydE9rKCk7XHJcbiAgICAgICAgbGV0IHJlc3AgPSByZXNwb25zZS5ib2R5SnNvbjtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzcCkpIHtcclxuICAgICAgICAgICAgcmVzcCA9IFtyZXNwXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3A7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc3BlbHVua0RhdGEodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyBUaGVzZSAqYXJlKiB0aGUgZHJvaWRzIHdlJ3JlIGxvb2tpbmcgZm9yLlxyXG4gICAgaWYgKHR5cGVvZiAodmFsdWUubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubWVzc2FnZS5tYXRjaCgvcmV2ZXJ0L2kpICYmIGlzSGV4U3RyaW5nKHZhbHVlLmRhdGEpKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogdmFsdWUubWVzc2FnZSwgZGF0YTogdmFsdWUuZGF0YSB9O1xyXG4gICAgfVxyXG4gICAgLy8gU3BlbHVuayBmdXJ0aGVyLi4uXHJcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzcGVsdW5rRGF0YSh2YWx1ZVtrZXldKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8vIE1pZ2h0IGJlIGEgSlNPTiBzdHJpbmcgd2UgY2FuIGZ1cnRoZXIgZGVzY2VuZC4uLlxyXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIHNwZWx1bmtEYXRhKEpTT04ucGFyc2UodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIF9zcGVsdW5rTWVzc2FnZSh2YWx1ZSwgcmVzdWx0KSB7XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIFRoZXNlICphcmUqIHRoZSBkcm9pZHMgd2UncmUgbG9va2luZyBmb3IuXHJcbiAgICBpZiAodHlwZW9mICh2YWx1ZS5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlLm1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgLy8gU3BlbHVuayBmdXJ0aGVyLi4uXHJcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xyXG4gICAgICAgICAgICBfc3BlbHVua01lc3NhZ2UodmFsdWVba2V5XSwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBNaWdodCBiZSBhIEpTT04gc3RyaW5nIHdlIGNhbiBmdXJ0aGVyIGRlc2NlbmQuLi5cclxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3BlbHVua01lc3NhZ2UoSlNPTi5wYXJzZSh2YWx1ZSksIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc3BlbHVua01lc3NhZ2UodmFsdWUpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgX3NwZWx1bmtNZXNzYWdlKHZhbHVlLCByZXN1bHQpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1qc29ucnBjLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-pocket.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-pocket.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PocketProvider: () => (/* binding */ PocketProvider)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _community_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./community.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/community.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/**\r\n *  [[link-pocket]] provides a third-party service for connecting to\r\n *  various blockchains over JSON-RPC.\r\n *\r\n *  **Supported Networks**\r\n *\r\n *  - Ethereum Mainnet (``mainnet``)\r\n *  - Goerli Testnet (``goerli``)\r\n *  - Polygon (``matic``)\r\n *  - Arbitrum (``arbitrum``)\r\n *\r\n *  @_subsection: api/providers/thirdparty:Pocket  [providers-pocket]\r\n */\r\n\r\n\r\n\r\n\r\nconst defaultApplicationId = \"62e1ad51b37b8e00394bda3b\";\r\nfunction getHost(name) {\r\n    switch (name) {\r\n        case \"mainnet\":\r\n            return \"eth-mainnet.gateway.pokt.network\";\r\n        case \"goerli\":\r\n            return \"eth-goerli.gateway.pokt.network\";\r\n        case \"matic\":\r\n            return \"poly-mainnet.gateway.pokt.network\";\r\n        case \"matic-mumbai\":\r\n            return \"polygon-mumbai-rpc.gateway.pokt.network\";\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported network\", \"network\", name);\r\n}\r\n/**\r\n *  The **PocketProvider** connects to the [[link-pocket]]\r\n *  JSON-RPC end-points.\r\n *\r\n *  By default, a highly-throttled API key is used, which is\r\n *  appropriate for quick prototypes and simple scripts. To\r\n *  gain access to an increased rate-limit, it is highly\r\n *  recommended to [sign up here](link-pocket-signup).\r\n */\r\nclass PocketProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__.JsonRpcProvider {\r\n    /**\r\n     *  The Application ID for the Pocket connection.\r\n     */\r\n    applicationId;\r\n    /**\r\n     *  The Application Secret for making authenticated requests\r\n     *  to the Pocket connection.\r\n     */\r\n    applicationSecret;\r\n    /**\r\n     *  Create a new **PocketProvider**.\r\n     *\r\n     *  By default connecting to ``mainnet`` with a highly throttled\r\n     *  API key.\r\n     */\r\n    constructor(_network, applicationId, applicationSecret) {\r\n        if (_network == null) {\r\n            _network = \"mainnet\";\r\n        }\r\n        const network = _network_js__WEBPACK_IMPORTED_MODULE_2__.Network.from(_network);\r\n        if (applicationId == null) {\r\n            applicationId = defaultApplicationId;\r\n        }\r\n        if (applicationSecret == null) {\r\n            applicationSecret = null;\r\n        }\r\n        const options = { staticNetwork: network };\r\n        const request = PocketProvider.getRequest(network, applicationId, applicationSecret);\r\n        super(request, network, options);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { applicationId, applicationSecret });\r\n    }\r\n    _getProvider(chainId) {\r\n        try {\r\n            return new PocketProvider(chainId, this.applicationId, this.applicationSecret);\r\n        }\r\n        catch (error) { }\r\n        return super._getProvider(chainId);\r\n    }\r\n    /**\r\n     *  Returns a prepared request for connecting to %%network%% with\r\n     *  %%applicationId%%.\r\n     */\r\n    static getRequest(network, applicationId, applicationSecret) {\r\n        if (applicationId == null) {\r\n            applicationId = defaultApplicationId;\r\n        }\r\n        const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(`https:/\\/${getHost(network.name)}/v1/lb/${applicationId}`);\r\n        request.allowGzip = true;\r\n        if (applicationSecret) {\r\n            request.setCredentials(\"\", applicationSecret);\r\n        }\r\n        if (applicationId === defaultApplicationId) {\r\n            request.retryFunc = async (request, response, attempt) => {\r\n                (0,_community_js__WEBPACK_IMPORTED_MODULE_3__.showThrottleMessage)(\"PocketProvider\");\r\n                return true;\r\n            };\r\n        }\r\n        return request;\r\n    }\r\n    isCommunityResource() {\r\n        return (this.applicationId === defaultApplicationId);\r\n    }\r\n}\r\n//# sourceMappingURL=provider-pocket.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItcG9ja2V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDbUY7QUFDOUI7QUFDZDtBQUNpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNkJBQTZCLGlFQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdEQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0IsU0FBUyxrQ0FBa0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseURBQVksYUFBYSxzQkFBc0IsU0FBUyxjQUFjO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrRUFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxccHJvdmlkZXJzXFxwcm92aWRlci1wb2NrZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqICBbW2xpbmstcG9ja2V0XV0gcHJvdmlkZXMgYSB0aGlyZC1wYXJ0eSBzZXJ2aWNlIGZvciBjb25uZWN0aW5nIHRvXHJcbiAqICB2YXJpb3VzIGJsb2NrY2hhaW5zIG92ZXIgSlNPTi1SUEMuXHJcbiAqXHJcbiAqICAqKlN1cHBvcnRlZCBOZXR3b3JrcyoqXHJcbiAqXHJcbiAqICAtIEV0aGVyZXVtIE1haW5uZXQgKGBgbWFpbm5ldGBgKVxyXG4gKiAgLSBHb2VybGkgVGVzdG5ldCAoYGBnb2VybGlgYClcclxuICogIC0gUG9seWdvbiAoYGBtYXRpY2BgKVxyXG4gKiAgLSBBcmJpdHJ1bSAoYGBhcmJpdHJ1bWBgKVxyXG4gKlxyXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHk6UG9ja2V0ICBbcHJvdmlkZXJzLXBvY2tldF1cclxuICovXHJcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIEZldGNoUmVxdWVzdCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgc2hvd1Rocm90dGxlTWVzc2FnZSB9IGZyb20gXCIuL2NvbW11bml0eS5qc1wiO1xyXG5pbXBvcnQgeyBOZXR3b3JrIH0gZnJvbSBcIi4vbmV0d29yay5qc1wiO1xyXG5pbXBvcnQgeyBKc29uUnBjUHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1qc29ucnBjLmpzXCI7XHJcbmNvbnN0IGRlZmF1bHRBcHBsaWNhdGlvbklkID0gXCI2MmUxYWQ1MWIzN2I4ZTAwMzk0YmRhM2JcIjtcclxuZnVuY3Rpb24gZ2V0SG9zdChuYW1lKSB7XHJcbiAgICBzd2l0Y2ggKG5hbWUpIHtcclxuICAgICAgICBjYXNlIFwibWFpbm5ldFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJldGgtbWFpbm5ldC5nYXRld2F5LnBva3QubmV0d29ya1wiO1xyXG4gICAgICAgIGNhc2UgXCJnb2VybGlcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoLWdvZXJsaS5nYXRld2F5LnBva3QubmV0d29ya1wiO1xyXG4gICAgICAgIGNhc2UgXCJtYXRpY1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJwb2x5LW1haW5uZXQuZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcclxuICAgICAgICBjYXNlIFwibWF0aWMtbXVtYmFpXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcInBvbHlnb24tbXVtYmFpLXJwYy5nYXRld2F5LnBva3QubmV0d29ya1wiO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmFtZSk7XHJcbn1cclxuLyoqXHJcbiAqICBUaGUgKipQb2NrZXRQcm92aWRlcioqIGNvbm5lY3RzIHRvIHRoZSBbW2xpbmstcG9ja2V0XV1cclxuICogIEpTT04tUlBDIGVuZC1wb2ludHMuXHJcbiAqXHJcbiAqICBCeSBkZWZhdWx0LCBhIGhpZ2hseS10aHJvdHRsZWQgQVBJIGtleSBpcyB1c2VkLCB3aGljaCBpc1xyXG4gKiAgYXBwcm9wcmlhdGUgZm9yIHF1aWNrIHByb3RvdHlwZXMgYW5kIHNpbXBsZSBzY3JpcHRzLiBUb1xyXG4gKiAgZ2FpbiBhY2Nlc3MgdG8gYW4gaW5jcmVhc2VkIHJhdGUtbGltaXQsIGl0IGlzIGhpZ2hseVxyXG4gKiAgcmVjb21tZW5kZWQgdG8gW3NpZ24gdXAgaGVyZV0obGluay1wb2NrZXQtc2lnbnVwKS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQb2NrZXRQcm92aWRlciBleHRlbmRzIEpzb25ScGNQcm92aWRlciB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgQXBwbGljYXRpb24gSUQgZm9yIHRoZSBQb2NrZXQgY29ubmVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgYXBwbGljYXRpb25JZDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBBcHBsaWNhdGlvbiBTZWNyZXQgZm9yIG1ha2luZyBhdXRoZW50aWNhdGVkIHJlcXVlc3RzXHJcbiAgICAgKiAgdG8gdGhlIFBvY2tldCBjb25uZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBhcHBsaWNhdGlvblNlY3JldDtcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlBvY2tldFByb3ZpZGVyKiouXHJcbiAgICAgKlxyXG4gICAgICogIEJ5IGRlZmF1bHQgY29ubmVjdGluZyB0byBgYG1haW5uZXRgYCB3aXRoIGEgaGlnaGx5IHRocm90dGxlZFxyXG4gICAgICogIEFQSSBrZXkuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCBhcHBsaWNhdGlvbklkLCBhcHBsaWNhdGlvblNlY3JldCkge1xyXG4gICAgICAgIGlmIChfbmV0d29yayA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIF9uZXR3b3JrID0gXCJtYWlubmV0XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBOZXR3b3JrLmZyb20oX25ldHdvcmspO1xyXG4gICAgICAgIGlmIChhcHBsaWNhdGlvbklkID09IG51bGwpIHtcclxuICAgICAgICAgICAgYXBwbGljYXRpb25JZCA9IGRlZmF1bHRBcHBsaWNhdGlvbklkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXBwbGljYXRpb25TZWNyZXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBhcHBsaWNhdGlvblNlY3JldCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IHN0YXRpY05ldHdvcms6IG5ldHdvcmsgfTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gUG9ja2V0UHJvdmlkZXIuZ2V0UmVxdWVzdChuZXR3b3JrLCBhcHBsaWNhdGlvbklkLCBhcHBsaWNhdGlvblNlY3JldCk7XHJcbiAgICAgICAgc3VwZXIocmVxdWVzdCwgbmV0d29yaywgb3B0aW9ucyk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFwcGxpY2F0aW9uSWQsIGFwcGxpY2F0aW9uU2VjcmV0IH0pO1xyXG4gICAgfVxyXG4gICAgX2dldFByb3ZpZGVyKGNoYWluSWQpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvY2tldFByb3ZpZGVyKGNoYWluSWQsIHRoaXMuYXBwbGljYXRpb25JZCwgdGhpcy5hcHBsaWNhdGlvblNlY3JldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9nZXRQcm92aWRlcihjaGFpbklkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBwcmVwYXJlZCByZXF1ZXN0IGZvciBjb25uZWN0aW5nIHRvICUlbmV0d29yayUlIHdpdGhcclxuICAgICAqICAlJWFwcGxpY2F0aW9uSWQlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldFJlcXVlc3QobmV0d29yaywgYXBwbGljYXRpb25JZCwgYXBwbGljYXRpb25TZWNyZXQpIHtcclxuICAgICAgICBpZiAoYXBwbGljYXRpb25JZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uSWQgPSBkZWZhdWx0QXBwbGljYXRpb25JZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBGZXRjaFJlcXVlc3QoYGh0dHBzOi9cXC8ke2dldEhvc3QobmV0d29yay5uYW1lKX0vdjEvbGIvJHthcHBsaWNhdGlvbklkfWApO1xyXG4gICAgICAgIHJlcXVlc3QuYWxsb3dHemlwID0gdHJ1ZTtcclxuICAgICAgICBpZiAoYXBwbGljYXRpb25TZWNyZXQpIHtcclxuICAgICAgICAgICAgcmVxdWVzdC5zZXRDcmVkZW50aWFscyhcIlwiLCBhcHBsaWNhdGlvblNlY3JldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcHBsaWNhdGlvbklkID09PSBkZWZhdWx0QXBwbGljYXRpb25JZCkge1xyXG4gICAgICAgICAgICByZXF1ZXN0LnJldHJ5RnVuYyA9IGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSwgYXR0ZW1wdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2hvd1Rocm90dGxlTWVzc2FnZShcIlBvY2tldFByb3ZpZGVyXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xyXG4gICAgfVxyXG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuYXBwbGljYXRpb25JZCA9PT0gZGVmYXVsdEFwcGxpY2F0aW9uSWQpO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLXBvY2tldC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-pocket.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-quicknode.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-quicknode.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QuickNodeProvider: () => (/* binding */ QuickNodeProvider)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _community_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./community.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/community.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/**\r\n *  [[link-quicknode]] provides a third-party service for connecting to\r\n *  various blockchains over JSON-RPC.\r\n *\r\n *  **Supported Networks**\r\n *\r\n *  - Ethereum Mainnet (``mainnet``)\r\n *  - Goerli Testnet (``goerli``)\r\n *  - Sepolia Testnet (``sepolia``)\r\n *  - Holesky Testnet (``holesky``)\r\n *  - Arbitrum (``arbitrum``)\r\n *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)\r\n *  - Arbitrum Sepolia Testnet (``arbitrum-sepolia``)\r\n *  - Base Mainnet (``base``);\r\n *  - Base Goerli Testnet (``base-goerli``);\r\n *  - Base Sepolia Testnet (``base-sepolia``);\r\n *  - BNB Smart Chain Mainnet (``bnb``)\r\n *  - BNB Smart Chain Testnet (``bnbt``)\r\n *  - Optimism (``optimism``)\r\n *  - Optimism Goerli Testnet (``optimism-goerli``)\r\n *  - Optimism Sepolia Testnet (``optimism-sepolia``)\r\n *  - Polygon (``matic``)\r\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\r\n *\r\n *  @_subsection: api/providers/thirdparty:QuickNode  [providers-quicknode]\r\n */\r\n\r\n\r\n\r\n\r\nconst defaultToken = \"919b412a057b5e9c9b6dce193c5a60242d6efadb\";\r\nfunction getHost(name) {\r\n    switch (name) {\r\n        case \"mainnet\":\r\n            return \"ethers.quiknode.pro\";\r\n        case \"goerli\":\r\n            return \"ethers.ethereum-goerli.quiknode.pro\";\r\n        case \"sepolia\":\r\n            return \"ethers.ethereum-sepolia.quiknode.pro\";\r\n        case \"holesky\":\r\n            return \"ethers.ethereum-holesky.quiknode.pro\";\r\n        case \"arbitrum\":\r\n            return \"ethers.arbitrum-mainnet.quiknode.pro\";\r\n        case \"arbitrum-goerli\":\r\n            return \"ethers.arbitrum-goerli.quiknode.pro\";\r\n        case \"arbitrum-sepolia\":\r\n            return \"ethers.arbitrum-sepolia.quiknode.pro\";\r\n        case \"base\":\r\n            return \"ethers.base-mainnet.quiknode.pro\";\r\n        case \"base-goerli\":\r\n            return \"ethers.base-goerli.quiknode.pro\";\r\n        case \"base-spolia\":\r\n            return \"ethers.base-sepolia.quiknode.pro\";\r\n        case \"bnb\":\r\n            return \"ethers.bsc.quiknode.pro\";\r\n        case \"bnbt\":\r\n            return \"ethers.bsc-testnet.quiknode.pro\";\r\n        case \"matic\":\r\n            return \"ethers.matic.quiknode.pro\";\r\n        case \"matic-mumbai\":\r\n            return \"ethers.matic-testnet.quiknode.pro\";\r\n        case \"optimism\":\r\n            return \"ethers.optimism.quiknode.pro\";\r\n        case \"optimism-goerli\":\r\n            return \"ethers.optimism-goerli.quiknode.pro\";\r\n        case \"optimism-sepolia\":\r\n            return \"ethers.optimism-sepolia.quiknode.pro\";\r\n        case \"xdai\":\r\n            return \"ethers.xdai.quiknode.pro\";\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported network\", \"network\", name);\r\n}\r\n/*\r\n@TODO:\r\n  These networks are not currently present in the Network\r\n  default included networks. Research them and ensure they\r\n  are EVM compatible and work with ethers\r\n\r\n  http://ethers.matic-amoy.quiknode.pro\r\n\r\n  http://ethers.avalanche-mainnet.quiknode.pro\r\n  http://ethers.avalanche-testnet.quiknode.pro\r\n  http://ethers.blast-sepolia.quiknode.pro\r\n  http://ethers.celo-mainnet.quiknode.pro\r\n  http://ethers.fantom.quiknode.pro\r\n  http://ethers.imx-demo.quiknode.pro\r\n  http://ethers.imx-mainnet.quiknode.pro\r\n  http://ethers.imx-testnet.quiknode.pro\r\n  http://ethers.near-mainnet.quiknode.pro\r\n  http://ethers.near-testnet.quiknode.pro\r\n  http://ethers.nova-mainnet.quiknode.pro\r\n  http://ethers.scroll-mainnet.quiknode.pro\r\n  http://ethers.scroll-testnet.quiknode.pro\r\n  http://ethers.tron-mainnet.quiknode.pro\r\n  http://ethers.zkevm-mainnet.quiknode.pro\r\n  http://ethers.zkevm-testnet.quiknode.pro\r\n  http://ethers.zksync-mainnet.quiknode.pro\r\n  http://ethers.zksync-testnet.quiknode.pro\r\n*/\r\n/**\r\n *  The **QuickNodeProvider** connects to the [[link-quicknode]]\r\n *  JSON-RPC end-points.\r\n *\r\n *  By default, a highly-throttled API token is used, which is\r\n *  appropriate for quick prototypes and simple scripts. To\r\n *  gain access to an increased rate-limit, it is highly\r\n *  recommended to [sign up here](link-quicknode).\r\n */\r\nclass QuickNodeProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__.JsonRpcProvider {\r\n    /**\r\n     *  The API token.\r\n     */\r\n    token;\r\n    /**\r\n     *  Creates a new **QuickNodeProvider**.\r\n     */\r\n    constructor(_network, token) {\r\n        if (_network == null) {\r\n            _network = \"mainnet\";\r\n        }\r\n        const network = _network_js__WEBPACK_IMPORTED_MODULE_2__.Network.from(_network);\r\n        if (token == null) {\r\n            token = defaultToken;\r\n        }\r\n        const request = QuickNodeProvider.getRequest(network, token);\r\n        super(request, network, { staticNetwork: network });\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { token });\r\n    }\r\n    _getProvider(chainId) {\r\n        try {\r\n            return new QuickNodeProvider(chainId, this.token);\r\n        }\r\n        catch (error) { }\r\n        return super._getProvider(chainId);\r\n    }\r\n    isCommunityResource() {\r\n        return (this.token === defaultToken);\r\n    }\r\n    /**\r\n     *  Returns a new request prepared for %%network%% and the\r\n     *  %%token%%.\r\n     */\r\n    static getRequest(network, token) {\r\n        if (token == null) {\r\n            token = defaultToken;\r\n        }\r\n        const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(`https:/\\/${getHost(network.name)}/${token}`);\r\n        request.allowGzip = true;\r\n        //if (projectSecret) { request.setCredentials(\"\", projectSecret); }\r\n        if (token === defaultToken) {\r\n            request.retryFunc = async (request, response, attempt) => {\r\n                (0,_community_js__WEBPACK_IMPORTED_MODULE_3__.showThrottleMessage)(\"QuickNodeProvider\");\r\n                return true;\r\n            };\r\n        }\r\n        return request;\r\n    }\r\n}\r\n//# sourceMappingURL=provider-quicknode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItcXVpY2tub2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNtRjtBQUM5QjtBQUNkO0FBQ2lCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQyxpRUFBZTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdEQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdCQUF3QjtBQUMxRCxRQUFRLGlFQUFnQixTQUFTLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseURBQVksYUFBYSxzQkFBc0IsR0FBRyxNQUFNO0FBQ3BGO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHByb3ZpZGVyc1xccHJvdmlkZXItcXVpY2tub2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgW1tsaW5rLXF1aWNrbm9kZV1dIHByb3ZpZGVzIGEgdGhpcmQtcGFydHkgc2VydmljZSBmb3IgY29ubmVjdGluZyB0b1xyXG4gKiAgdmFyaW91cyBibG9ja2NoYWlucyBvdmVyIEpTT04tUlBDLlxyXG4gKlxyXG4gKiAgKipTdXBwb3J0ZWQgTmV0d29ya3MqKlxyXG4gKlxyXG4gKiAgLSBFdGhlcmV1bSBNYWlubmV0IChgYG1haW5uZXRgYClcclxuICogIC0gR29lcmxpIFRlc3RuZXQgKGBgZ29lcmxpYGApXHJcbiAqICAtIFNlcG9saWEgVGVzdG5ldCAoYGBzZXBvbGlhYGApXHJcbiAqICAtIEhvbGVza3kgVGVzdG5ldCAoYGBob2xlc2t5YGApXHJcbiAqICAtIEFyYml0cnVtIChgYGFyYml0cnVtYGApXHJcbiAqICAtIEFyYml0cnVtIEdvZXJsaSBUZXN0bmV0IChgYGFyYml0cnVtLWdvZXJsaWBgKVxyXG4gKiAgLSBBcmJpdHJ1bSBTZXBvbGlhIFRlc3RuZXQgKGBgYXJiaXRydW0tc2Vwb2xpYWBgKVxyXG4gKiAgLSBCYXNlIE1haW5uZXQgKGBgYmFzZWBgKTtcclxuICogIC0gQmFzZSBHb2VybGkgVGVzdG5ldCAoYGBiYXNlLWdvZXJsaWBgKTtcclxuICogIC0gQmFzZSBTZXBvbGlhIFRlc3RuZXQgKGBgYmFzZS1zZXBvbGlhYGApO1xyXG4gKiAgLSBCTkIgU21hcnQgQ2hhaW4gTWFpbm5ldCAoYGBibmJgYClcclxuICogIC0gQk5CIFNtYXJ0IENoYWluIFRlc3RuZXQgKGBgYm5idGBgKVxyXG4gKiAgLSBPcHRpbWlzbSAoYGBvcHRpbWlzbWBgKVxyXG4gKiAgLSBPcHRpbWlzbSBHb2VybGkgVGVzdG5ldCAoYGBvcHRpbWlzbS1nb2VybGlgYClcclxuICogIC0gT3B0aW1pc20gU2Vwb2xpYSBUZXN0bmV0IChgYG9wdGltaXNtLXNlcG9saWFgYClcclxuICogIC0gUG9seWdvbiAoYGBtYXRpY2BgKVxyXG4gKiAgLSBQb2x5Z29uIE11bWJhaSBUZXN0bmV0IChgYG1hdGljLW11bWJhaWBgKVxyXG4gKlxyXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHk6UXVpY2tOb2RlICBbcHJvdmlkZXJzLXF1aWNrbm9kZV1cclxuICovXHJcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIEZldGNoUmVxdWVzdCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgc2hvd1Rocm90dGxlTWVzc2FnZSB9IGZyb20gXCIuL2NvbW11bml0eS5qc1wiO1xyXG5pbXBvcnQgeyBOZXR3b3JrIH0gZnJvbSBcIi4vbmV0d29yay5qc1wiO1xyXG5pbXBvcnQgeyBKc29uUnBjUHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1qc29ucnBjLmpzXCI7XHJcbmNvbnN0IGRlZmF1bHRUb2tlbiA9IFwiOTE5YjQxMmEwNTdiNWU5YzliNmRjZTE5M2M1YTYwMjQyZDZlZmFkYlwiO1xyXG5mdW5jdGlvbiBnZXRIb3N0KG5hbWUpIHtcclxuICAgIHN3aXRjaCAobmFtZSkge1xyXG4gICAgICAgIGNhc2UgXCJtYWlubmV0XCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5xdWlrbm9kZS5wcm9cIjtcclxuICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5ldGhlcmV1bS1nb2VybGkucXVpa25vZGUucHJvXCI7XHJcbiAgICAgICAgY2FzZSBcInNlcG9saWFcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLmV0aGVyZXVtLXNlcG9saWEucXVpa25vZGUucHJvXCI7XHJcbiAgICAgICAgY2FzZSBcImhvbGVza3lcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLmV0aGVyZXVtLWhvbGVza3kucXVpa25vZGUucHJvXCI7XHJcbiAgICAgICAgY2FzZSBcImFyYml0cnVtXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5hcmJpdHJ1bS1tYWlubmV0LnF1aWtub2RlLnByb1wiO1xyXG4gICAgICAgIGNhc2UgXCJhcmJpdHJ1bS1nb2VybGlcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLmFyYml0cnVtLWdvZXJsaS5xdWlrbm9kZS5wcm9cIjtcclxuICAgICAgICBjYXNlIFwiYXJiaXRydW0tc2Vwb2xpYVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMuYXJiaXRydW0tc2Vwb2xpYS5xdWlrbm9kZS5wcm9cIjtcclxuICAgICAgICBjYXNlIFwiYmFzZVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMuYmFzZS1tYWlubmV0LnF1aWtub2RlLnByb1wiO1xyXG4gICAgICAgIGNhc2UgXCJiYXNlLWdvZXJsaVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMuYmFzZS1nb2VybGkucXVpa25vZGUucHJvXCI7XHJcbiAgICAgICAgY2FzZSBcImJhc2Utc3BvbGlhXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5iYXNlLXNlcG9saWEucXVpa25vZGUucHJvXCI7XHJcbiAgICAgICAgY2FzZSBcImJuYlwiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMuYnNjLnF1aWtub2RlLnByb1wiO1xyXG4gICAgICAgIGNhc2UgXCJibmJ0XCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5ic2MtdGVzdG5ldC5xdWlrbm9kZS5wcm9cIjtcclxuICAgICAgICBjYXNlIFwibWF0aWNcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLm1hdGljLnF1aWtub2RlLnByb1wiO1xyXG4gICAgICAgIGNhc2UgXCJtYXRpYy1tdW1iYWlcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLm1hdGljLXRlc3RuZXQucXVpa25vZGUucHJvXCI7XHJcbiAgICAgICAgY2FzZSBcIm9wdGltaXNtXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5vcHRpbWlzbS5xdWlrbm9kZS5wcm9cIjtcclxuICAgICAgICBjYXNlIFwib3B0aW1pc20tZ29lcmxpXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5vcHRpbWlzbS1nb2VybGkucXVpa25vZGUucHJvXCI7XHJcbiAgICAgICAgY2FzZSBcIm9wdGltaXNtLXNlcG9saWFcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLm9wdGltaXNtLXNlcG9saWEucXVpa25vZGUucHJvXCI7XHJcbiAgICAgICAgY2FzZSBcInhkYWlcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLnhkYWkucXVpa25vZGUucHJvXCI7XHJcbiAgICB9XHJcbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuYW1lKTtcclxufVxyXG4vKlxyXG5AVE9ETzpcclxuICBUaGVzZSBuZXR3b3JrcyBhcmUgbm90IGN1cnJlbnRseSBwcmVzZW50IGluIHRoZSBOZXR3b3JrXHJcbiAgZGVmYXVsdCBpbmNsdWRlZCBuZXR3b3Jrcy4gUmVzZWFyY2ggdGhlbSBhbmQgZW5zdXJlIHRoZXlcclxuICBhcmUgRVZNIGNvbXBhdGlibGUgYW5kIHdvcmsgd2l0aCBldGhlcnNcclxuXHJcbiAgaHR0cDovL2V0aGVycy5tYXRpYy1hbW95LnF1aWtub2RlLnByb1xyXG5cclxuICBodHRwOi8vZXRoZXJzLmF2YWxhbmNoZS1tYWlubmV0LnF1aWtub2RlLnByb1xyXG4gIGh0dHA6Ly9ldGhlcnMuYXZhbGFuY2hlLXRlc3RuZXQucXVpa25vZGUucHJvXHJcbiAgaHR0cDovL2V0aGVycy5ibGFzdC1zZXBvbGlhLnF1aWtub2RlLnByb1xyXG4gIGh0dHA6Ly9ldGhlcnMuY2Vsby1tYWlubmV0LnF1aWtub2RlLnByb1xyXG4gIGh0dHA6Ly9ldGhlcnMuZmFudG9tLnF1aWtub2RlLnByb1xyXG4gIGh0dHA6Ly9ldGhlcnMuaW14LWRlbW8ucXVpa25vZGUucHJvXHJcbiAgaHR0cDovL2V0aGVycy5pbXgtbWFpbm5ldC5xdWlrbm9kZS5wcm9cclxuICBodHRwOi8vZXRoZXJzLmlteC10ZXN0bmV0LnF1aWtub2RlLnByb1xyXG4gIGh0dHA6Ly9ldGhlcnMubmVhci1tYWlubmV0LnF1aWtub2RlLnByb1xyXG4gIGh0dHA6Ly9ldGhlcnMubmVhci10ZXN0bmV0LnF1aWtub2RlLnByb1xyXG4gIGh0dHA6Ly9ldGhlcnMubm92YS1tYWlubmV0LnF1aWtub2RlLnByb1xyXG4gIGh0dHA6Ly9ldGhlcnMuc2Nyb2xsLW1haW5uZXQucXVpa25vZGUucHJvXHJcbiAgaHR0cDovL2V0aGVycy5zY3JvbGwtdGVzdG5ldC5xdWlrbm9kZS5wcm9cclxuICBodHRwOi8vZXRoZXJzLnRyb24tbWFpbm5ldC5xdWlrbm9kZS5wcm9cclxuICBodHRwOi8vZXRoZXJzLnprZXZtLW1haW5uZXQucXVpa25vZGUucHJvXHJcbiAgaHR0cDovL2V0aGVycy56a2V2bS10ZXN0bmV0LnF1aWtub2RlLnByb1xyXG4gIGh0dHA6Ly9ldGhlcnMuemtzeW5jLW1haW5uZXQucXVpa25vZGUucHJvXHJcbiAgaHR0cDovL2V0aGVycy56a3N5bmMtdGVzdG5ldC5xdWlrbm9kZS5wcm9cclxuKi9cclxuLyoqXHJcbiAqICBUaGUgKipRdWlja05vZGVQcm92aWRlcioqIGNvbm5lY3RzIHRvIHRoZSBbW2xpbmstcXVpY2tub2RlXV1cclxuICogIEpTT04tUlBDIGVuZC1wb2ludHMuXHJcbiAqXHJcbiAqICBCeSBkZWZhdWx0LCBhIGhpZ2hseS10aHJvdHRsZWQgQVBJIHRva2VuIGlzIHVzZWQsIHdoaWNoIGlzXHJcbiAqICBhcHByb3ByaWF0ZSBmb3IgcXVpY2sgcHJvdG90eXBlcyBhbmQgc2ltcGxlIHNjcmlwdHMuIFRvXHJcbiAqICBnYWluIGFjY2VzcyB0byBhbiBpbmNyZWFzZWQgcmF0ZS1saW1pdCwgaXQgaXMgaGlnaGx5XHJcbiAqICByZWNvbW1lbmRlZCB0byBbc2lnbiB1cCBoZXJlXShsaW5rLXF1aWNrbm9kZSkuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUXVpY2tOb2RlUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjUHJvdmlkZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIEFQSSB0b2tlbi5cclxuICAgICAqL1xyXG4gICAgdG9rZW47XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqUXVpY2tOb2RlUHJvdmlkZXIqKi5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoX25ldHdvcmssIHRva2VuKSB7XHJcbiAgICAgICAgaWYgKF9uZXR3b3JrID09IG51bGwpIHtcclxuICAgICAgICAgICAgX25ldHdvcmsgPSBcIm1haW5uZXRcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV0d29yayA9IE5ldHdvcmsuZnJvbShfbmV0d29yayk7XHJcbiAgICAgICAgaWYgKHRva2VuID09IG51bGwpIHtcclxuICAgICAgICAgICAgdG9rZW4gPSBkZWZhdWx0VG9rZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBRdWlja05vZGVQcm92aWRlci5nZXRSZXF1ZXN0KG5ldHdvcmssIHRva2VuKTtcclxuICAgICAgICBzdXBlcihyZXF1ZXN0LCBuZXR3b3JrLCB7IHN0YXRpY05ldHdvcms6IG5ldHdvcmsgfSk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHRva2VuIH0pO1xyXG4gICAgfVxyXG4gICAgX2dldFByb3ZpZGVyKGNoYWluSWQpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFF1aWNrTm9kZVByb3ZpZGVyKGNoYWluSWQsIHRoaXMudG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgICAgIHJldHVybiBzdXBlci5fZ2V0UHJvdmlkZXIoY2hhaW5JZCk7XHJcbiAgICB9XHJcbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy50b2tlbiA9PT0gZGVmYXVsdFRva2VuKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBuZXcgcmVxdWVzdCBwcmVwYXJlZCBmb3IgJSVuZXR3b3JrJSUgYW5kIHRoZVxyXG4gICAgICogICUldG9rZW4lJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldFJlcXVlc3QobmV0d29yaywgdG9rZW4pIHtcclxuICAgICAgICBpZiAodG9rZW4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0b2tlbiA9IGRlZmF1bHRUb2tlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBGZXRjaFJlcXVlc3QoYGh0dHBzOi9cXC8ke2dldEhvc3QobmV0d29yay5uYW1lKX0vJHt0b2tlbn1gKTtcclxuICAgICAgICByZXF1ZXN0LmFsbG93R3ppcCA9IHRydWU7XHJcbiAgICAgICAgLy9pZiAocHJvamVjdFNlY3JldCkgeyByZXF1ZXN0LnNldENyZWRlbnRpYWxzKFwiXCIsIHByb2plY3RTZWNyZXQpOyB9XHJcbiAgICAgICAgaWYgKHRva2VuID09PSBkZWZhdWx0VG9rZW4pIHtcclxuICAgICAgICAgICAgcmVxdWVzdC5yZXRyeUZ1bmMgPSBhc3luYyAocmVxdWVzdCwgcmVzcG9uc2UsIGF0dGVtcHQpID0+IHtcclxuICAgICAgICAgICAgICAgIHNob3dUaHJvdHRsZU1lc3NhZ2UoXCJRdWlja05vZGVQcm92aWRlclwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1xdWlja25vZGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-quicknode.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-socket.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-socket.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SocketBlockSubscriber: () => (/* binding */ SocketBlockSubscriber),\n/* harmony export */   SocketEventSubscriber: () => (/* binding */ SocketEventSubscriber),\n/* harmony export */   SocketPendingSubscriber: () => (/* binding */ SocketPendingSubscriber),\n/* harmony export */   SocketProvider: () => (/* binding */ SocketProvider),\n/* harmony export */   SocketSubscriber: () => (/* binding */ SocketSubscriber)\n/* harmony export */ });\n/* harmony import */ var _abstract_provider_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-provider.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/abstract-provider.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/**\r\n *  Generic long-lived socket provider.\r\n *\r\n *  Sub-classing notes\r\n *  - a sub-class MUST call the `_start()` method once connected\r\n *  - a sub-class MUST override the `_write(string)` method\r\n *  - a sub-class MUST call `_processMessage(string)` for each message\r\n *\r\n *  @_subsection: api/providers/abstract-provider:Socket Providers  [about-socketProvider]\r\n */\r\n\r\n\r\n\r\n/**\r\n *  A **SocketSubscriber** uses a socket transport to handle events and\r\n *  should use [[_emit]] to manage the events.\r\n */\r\nclass SocketSubscriber {\r\n    #provider;\r\n    #filter;\r\n    /**\r\n     *  The filter.\r\n     */\r\n    get filter() { return JSON.parse(this.#filter); }\r\n    #filterId;\r\n    #paused;\r\n    #emitPromise;\r\n    /**\r\n     *  Creates a new **SocketSubscriber** attached to %%provider%% listening\r\n     *  to %%filter%%.\r\n     */\r\n    constructor(provider, filter) {\r\n        this.#provider = provider;\r\n        this.#filter = JSON.stringify(filter);\r\n        this.#filterId = null;\r\n        this.#paused = null;\r\n        this.#emitPromise = null;\r\n    }\r\n    start() {\r\n        this.#filterId = this.#provider.send(\"eth_subscribe\", this.filter).then((filterId) => {\r\n            ;\r\n            this.#provider._register(filterId, this);\r\n            return filterId;\r\n        });\r\n    }\r\n    stop() {\r\n        (this.#filterId).then((filterId) => {\r\n            if (this.#provider.destroyed) {\r\n                return;\r\n            }\r\n            this.#provider.send(\"eth_unsubscribe\", [filterId]);\r\n        });\r\n        this.#filterId = null;\r\n    }\r\n    // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs\r\n    //        and resume\r\n    pause(dropWhilePaused) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(dropWhilePaused, \"preserve logs while paused not supported by SocketSubscriber yet\", \"UNSUPPORTED_OPERATION\", { operation: \"pause(false)\" });\r\n        this.#paused = !!dropWhilePaused;\r\n    }\r\n    resume() {\r\n        this.#paused = null;\r\n    }\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    _handleMessage(message) {\r\n        if (this.#filterId == null) {\r\n            return;\r\n        }\r\n        if (this.#paused === null) {\r\n            let emitPromise = this.#emitPromise;\r\n            if (emitPromise == null) {\r\n                emitPromise = this._emit(this.#provider, message);\r\n            }\r\n            else {\r\n                emitPromise = emitPromise.then(async () => {\r\n                    await this._emit(this.#provider, message);\r\n                });\r\n            }\r\n            this.#emitPromise = emitPromise.then(() => {\r\n                if (this.#emitPromise === emitPromise) {\r\n                    this.#emitPromise = null;\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     *  Sub-classes **must** override this to emit the events on the\r\n     *  provider.\r\n     */\r\n    async _emit(provider, message) {\r\n        throw new Error(\"sub-classes must implemente this; _emit\");\r\n    }\r\n}\r\n/**\r\n *  A **SocketBlockSubscriber** listens for ``newHeads`` events and emits\r\n *  ``\"block\"`` events.\r\n */\r\nclass SocketBlockSubscriber extends SocketSubscriber {\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    constructor(provider) {\r\n        super(provider, [\"newHeads\"]);\r\n    }\r\n    async _emit(provider, message) {\r\n        provider.emit(\"block\", parseInt(message.number));\r\n    }\r\n}\r\n/**\r\n *  A **SocketPendingSubscriber** listens for pending transacitons and emits\r\n *  ``\"pending\"`` events.\r\n */\r\nclass SocketPendingSubscriber extends SocketSubscriber {\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    constructor(provider) {\r\n        super(provider, [\"newPendingTransactions\"]);\r\n    }\r\n    async _emit(provider, message) {\r\n        provider.emit(\"pending\", message);\r\n    }\r\n}\r\n/**\r\n *  A **SocketEventSubscriber** listens for event logs.\r\n */\r\nclass SocketEventSubscriber extends SocketSubscriber {\r\n    #logFilter;\r\n    /**\r\n     *  The filter.\r\n     */\r\n    get logFilter() { return JSON.parse(this.#logFilter); }\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    constructor(provider, filter) {\r\n        super(provider, [\"logs\", filter]);\r\n        this.#logFilter = JSON.stringify(filter);\r\n    }\r\n    async _emit(provider, message) {\r\n        provider.emit(this.logFilter, provider._wrapLog(message, provider._network));\r\n    }\r\n}\r\n/**\r\n *  A **SocketProvider** is backed by a long-lived connection over a\r\n *  socket, which can subscribe and receive real-time messages over\r\n *  its communication channel.\r\n */\r\nclass SocketProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__.JsonRpcApiProvider {\r\n    #callbacks;\r\n    // Maps each filterId to its subscriber\r\n    #subs;\r\n    // If any events come in before a subscriber has finished\r\n    // registering, queue them\r\n    #pending;\r\n    /**\r\n     *  Creates a new **SocketProvider** connected to %%network%%.\r\n     *\r\n     *  If unspecified, the network will be discovered.\r\n     */\r\n    constructor(network, _options) {\r\n        // Copy the options\r\n        const options = Object.assign({}, (_options != null) ? _options : {});\r\n        // Support for batches is generally not supported for\r\n        // connection-base providers; if this changes in the future\r\n        // the _send should be updated to reflect this\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(options.batchMaxCount == null || options.batchMaxCount === 1, \"sockets-based providers do not support batches\", \"options.batchMaxCount\", _options);\r\n        options.batchMaxCount = 1;\r\n        // Socket-based Providers (generally) cannot change their network,\r\n        // since they have a long-lived connection; but let people override\r\n        // this if they have just cause.\r\n        if (options.staticNetwork == null) {\r\n            options.staticNetwork = true;\r\n        }\r\n        super(network, options);\r\n        this.#callbacks = new Map();\r\n        this.#subs = new Map();\r\n        this.#pending = new Map();\r\n    }\r\n    // This value is only valid after _start has been called\r\n    /*\r\n    get _network(): Network {\r\n        if (this.#network == null) {\r\n            throw new Error(\"this shouldn't happen\");\r\n        }\r\n        return this.#network.clone();\r\n    }\r\n    */\r\n    _getSubscriber(sub) {\r\n        switch (sub.type) {\r\n            case \"close\":\r\n                return new _abstract_provider_js__WEBPACK_IMPORTED_MODULE_2__.UnmanagedSubscriber(\"close\");\r\n            case \"block\":\r\n                return new SocketBlockSubscriber(this);\r\n            case \"pending\":\r\n                return new SocketPendingSubscriber(this);\r\n            case \"event\":\r\n                return new SocketEventSubscriber(this, sub.filter);\r\n            case \"orphan\":\r\n                // Handled auto-matically within AbstractProvider\r\n                // when the log.removed = true\r\n                if (sub.filter.orphan === \"drop-log\") {\r\n                    return new _abstract_provider_js__WEBPACK_IMPORTED_MODULE_2__.UnmanagedSubscriber(\"drop-log\");\r\n                }\r\n        }\r\n        return super._getSubscriber(sub);\r\n    }\r\n    /**\r\n     *  Register a new subscriber. This is used internalled by Subscribers\r\n     *  and generally is unecessary unless extending capabilities.\r\n     */\r\n    _register(filterId, subscriber) {\r\n        this.#subs.set(filterId, subscriber);\r\n        const pending = this.#pending.get(filterId);\r\n        if (pending) {\r\n            for (const message of pending) {\r\n                subscriber._handleMessage(message);\r\n            }\r\n            this.#pending.delete(filterId);\r\n        }\r\n    }\r\n    async _send(payload) {\r\n        // WebSocket provider doesn't accept batches\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(!Array.isArray(payload), \"WebSocket does not support batch send\", \"payload\", payload);\r\n        // @TODO: stringify payloads here and store to prevent mutations\r\n        // Prepare a promise to respond to\r\n        const promise = new Promise((resolve, reject) => {\r\n            this.#callbacks.set(payload.id, { payload, resolve, reject });\r\n        });\r\n        // Wait until the socket is connected before writing to it\r\n        await this._waitUntilReady();\r\n        // Write the request to the socket\r\n        await this._write(JSON.stringify(payload));\r\n        return [await promise];\r\n    }\r\n    // Sub-classes must call this once they are connected\r\n    /*\r\n    async _start(): Promise<void> {\r\n        if (this.#ready) { return; }\r\n\r\n        for (const { payload } of this.#callbacks.values()) {\r\n            await this._write(JSON.stringify(payload));\r\n        }\r\n\r\n        this.#ready = (async function() {\r\n            await super._start();\r\n        })();\r\n    }\r\n    */\r\n    /**\r\n     *  Sub-classes **must** call this with messages received over their\r\n     *  transport to be processed and dispatched.\r\n     */\r\n    async _processMessage(message) {\r\n        const result = (JSON.parse(message));\r\n        if (result && typeof (result) === \"object\" && \"id\" in result) {\r\n            const callback = this.#callbacks.get(result.id);\r\n            if (callback == null) {\r\n                this.emit(\"error\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(\"received result for unknown id\", \"UNKNOWN_ERROR\", {\r\n                    reasonCode: \"UNKNOWN_ID\",\r\n                    result\r\n                }));\r\n                return;\r\n            }\r\n            this.#callbacks.delete(result.id);\r\n            callback.resolve(result);\r\n        }\r\n        else if (result && result.method === \"eth_subscription\") {\r\n            const filterId = result.params.subscription;\r\n            const subscriber = this.#subs.get(filterId);\r\n            if (subscriber) {\r\n                subscriber._handleMessage(result.params.result);\r\n            }\r\n            else {\r\n                let pending = this.#pending.get(filterId);\r\n                if (pending == null) {\r\n                    pending = [];\r\n                    this.#pending.set(filterId, pending);\r\n                }\r\n                pending.push(result.params.result);\r\n            }\r\n        }\r\n        else {\r\n            this.emit(\"error\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(\"received unexpected message\", \"UNKNOWN_ERROR\", {\r\n                reasonCode: \"UNEXPECTED_MESSAGE\",\r\n                result\r\n            }));\r\n            return;\r\n        }\r\n    }\r\n    /**\r\n     *  Sub-classes **must** override this to send %%message%% over their\r\n     *  transport.\r\n     */\r\n    async _write(message) {\r\n        throw new Error(\"sub-classes must override this\");\r\n    }\r\n}\r\n//# sourceMappingURL=provider-socket.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItc29ja2V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkQ7QUFDUztBQUNYO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFNLGlIQUFpSCwyQkFBMkI7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNkJBQTZCLG9FQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvQ0FBb0M7QUFDNUU7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNFQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzRUFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDBCQUEwQjtBQUN4RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBEQUFTO0FBQzVDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBEQUFTO0FBQ3hDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHByb3ZpZGVyc1xccHJvdmlkZXItc29ja2V0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgR2VuZXJpYyBsb25nLWxpdmVkIHNvY2tldCBwcm92aWRlci5cclxuICpcclxuICogIFN1Yi1jbGFzc2luZyBub3Rlc1xyXG4gKiAgLSBhIHN1Yi1jbGFzcyBNVVNUIGNhbGwgdGhlIGBfc3RhcnQoKWAgbWV0aG9kIG9uY2UgY29ubmVjdGVkXHJcbiAqICAtIGEgc3ViLWNsYXNzIE1VU1Qgb3ZlcnJpZGUgdGhlIGBfd3JpdGUoc3RyaW5nKWAgbWV0aG9kXHJcbiAqICAtIGEgc3ViLWNsYXNzIE1VU1QgY2FsbCBgX3Byb2Nlc3NNZXNzYWdlKHN0cmluZylgIGZvciBlYWNoIG1lc3NhZ2VcclxuICpcclxuICogIEBfc3Vic2VjdGlvbjogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlcjpTb2NrZXQgUHJvdmlkZXJzICBbYWJvdXQtc29ja2V0UHJvdmlkZXJdXHJcbiAqL1xyXG5pbXBvcnQgeyBVbm1hbmFnZWRTdWJzY3JpYmVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtcHJvdmlkZXIuanNcIjtcclxuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgbWFrZUVycm9yIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IEpzb25ScGNBcGlQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIjtcclxuLyoqXHJcbiAqICBBICoqU29ja2V0U3Vic2NyaWJlcioqIHVzZXMgYSBzb2NrZXQgdHJhbnNwb3J0IHRvIGhhbmRsZSBldmVudHMgYW5kXHJcbiAqICBzaG91bGQgdXNlIFtbX2VtaXRdXSB0byBtYW5hZ2UgdGhlIGV2ZW50cy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBTb2NrZXRTdWJzY3JpYmVyIHtcclxuICAgICNwcm92aWRlcjtcclxuICAgICNmaWx0ZXI7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZmlsdGVyLlxyXG4gICAgICovXHJcbiAgICBnZXQgZmlsdGVyKCkgeyByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLiNmaWx0ZXIpOyB9XHJcbiAgICAjZmlsdGVySWQ7XHJcbiAgICAjcGF1c2VkO1xyXG4gICAgI2VtaXRQcm9taXNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlNvY2tldFN1YnNjcmliZXIqKiBhdHRhY2hlZCB0byAlJXByb3ZpZGVyJSUgbGlzdGVuaW5nXHJcbiAgICAgKiAgdG8gJSVmaWx0ZXIlJS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xyXG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy4jZmlsdGVyID0gSlNPTi5zdHJpbmdpZnkoZmlsdGVyKTtcclxuICAgICAgICB0aGlzLiNmaWx0ZXJJZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy4jcGF1c2VkID0gbnVsbDtcclxuICAgICAgICB0aGlzLiNlbWl0UHJvbWlzZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICB0aGlzLiNmaWx0ZXJJZCA9IHRoaXMuI3Byb3ZpZGVyLnNlbmQoXCJldGhfc3Vic2NyaWJlXCIsIHRoaXMuZmlsdGVyKS50aGVuKChmaWx0ZXJJZCkgPT4ge1xyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLl9yZWdpc3RlcihmaWx0ZXJJZCwgdGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJJZDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgKHRoaXMuI2ZpbHRlcklkKS50aGVuKChmaWx0ZXJJZCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy4jcHJvdmlkZXIuZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuc2VuZChcImV0aF91bnN1YnNjcmliZVwiLCBbZmlsdGVySWRdKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLiNmaWx0ZXJJZCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyBAVE9ETzogcGF1c2Ugc2hvdWxkIHRyYXAgdGhlIGN1cnJlbnQgYmxvY2tOdW1iZXIsIHVuc3ViLCBhbmQgb24gcmVzdW1lIHVzZSBnZXRMb2dzXHJcbiAgICAvLyAgICAgICAgYW5kIHJlc3VtZVxyXG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XHJcbiAgICAgICAgYXNzZXJ0KGRyb3BXaGlsZVBhdXNlZCwgXCJwcmVzZXJ2ZSBsb2dzIHdoaWxlIHBhdXNlZCBub3Qgc3VwcG9ydGVkIGJ5IFNvY2tldFN1YnNjcmliZXIgeWV0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInBhdXNlKGZhbHNlKVwiIH0pO1xyXG4gICAgICAgIHRoaXMuI3BhdXNlZCA9ICEhZHJvcFdoaWxlUGF1c2VkO1xyXG4gICAgfVxyXG4gICAgcmVzdW1lKCkge1xyXG4gICAgICAgIHRoaXMuI3BhdXNlZCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBAX2lnbm9yZTpcclxuICAgICAqL1xyXG4gICAgX2hhbmRsZU1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIGlmICh0aGlzLiNmaWx0ZXJJZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuI3BhdXNlZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBsZXQgZW1pdFByb21pc2UgPSB0aGlzLiNlbWl0UHJvbWlzZTtcclxuICAgICAgICAgICAgaWYgKGVtaXRQcm9taXNlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGVtaXRQcm9taXNlID0gdGhpcy5fZW1pdCh0aGlzLiNwcm92aWRlciwgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlbWl0UHJvbWlzZSA9IGVtaXRQcm9taXNlLnRoZW4oYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2VtaXQodGhpcy4jcHJvdmlkZXIsIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy4jZW1pdFByb21pc2UgPSBlbWl0UHJvbWlzZS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNlbWl0UHJvbWlzZSA9PT0gZW1pdFByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNlbWl0UHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgdG8gZW1pdCB0aGUgZXZlbnRzIG9uIHRoZVxyXG4gICAgICogIHByb3ZpZGVyLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBfZW1pdChwcm92aWRlciwgbWVzc2FnZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1Yi1jbGFzc2VzIG11c3QgaW1wbGVtZW50ZSB0aGlzOyBfZW1pdFwiKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEEgKipTb2NrZXRCbG9ja1N1YnNjcmliZXIqKiBsaXN0ZW5zIGZvciBgYG5ld0hlYWRzYGAgZXZlbnRzIGFuZCBlbWl0c1xyXG4gKiAgYGBcImJsb2NrXCJgYCBldmVudHMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU29ja2V0QmxvY2tTdWJzY3JpYmVyIGV4dGVuZHMgU29ja2V0U3Vic2NyaWJlciB7XHJcbiAgICAvKipcclxuICAgICAqICBAX2lnbm9yZTpcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcclxuICAgICAgICBzdXBlcihwcm92aWRlciwgW1wibmV3SGVhZHNcIl0pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgX2VtaXQocHJvdmlkZXIsIG1lc3NhZ2UpIHtcclxuICAgICAgICBwcm92aWRlci5lbWl0KFwiYmxvY2tcIiwgcGFyc2VJbnQobWVzc2FnZS5udW1iZXIpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEEgKipTb2NrZXRQZW5kaW5nU3Vic2NyaWJlcioqIGxpc3RlbnMgZm9yIHBlbmRpbmcgdHJhbnNhY2l0b25zIGFuZCBlbWl0c1xyXG4gKiAgYGBcInBlbmRpbmdcImBgIGV2ZW50cy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBTb2NrZXRQZW5kaW5nU3Vic2NyaWJlciBleHRlbmRzIFNvY2tldFN1YnNjcmliZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgc3VwZXIocHJvdmlkZXIsIFtcIm5ld1BlbmRpbmdUcmFuc2FjdGlvbnNcIl0pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgX2VtaXQocHJvdmlkZXIsIG1lc3NhZ2UpIHtcclxuICAgICAgICBwcm92aWRlci5lbWl0KFwicGVuZGluZ1wiLCBtZXNzYWdlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEEgKipTb2NrZXRFdmVudFN1YnNjcmliZXIqKiBsaXN0ZW5zIGZvciBldmVudCBsb2dzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNvY2tldEV2ZW50U3Vic2NyaWJlciBleHRlbmRzIFNvY2tldFN1YnNjcmliZXIge1xyXG4gICAgI2xvZ0ZpbHRlcjtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBmaWx0ZXIuXHJcbiAgICAgKi9cclxuICAgIGdldCBsb2dGaWx0ZXIoKSB7IHJldHVybiBKU09OLnBhcnNlKHRoaXMuI2xvZ0ZpbHRlcik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIEBfaWdub3JlOlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZmlsdGVyKSB7XHJcbiAgICAgICAgc3VwZXIocHJvdmlkZXIsIFtcImxvZ3NcIiwgZmlsdGVyXSk7XHJcbiAgICAgICAgdGhpcy4jbG9nRmlsdGVyID0gSlNPTi5zdHJpbmdpZnkoZmlsdGVyKTtcclxuICAgIH1cclxuICAgIGFzeW5jIF9lbWl0KHByb3ZpZGVyLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcHJvdmlkZXIuZW1pdCh0aGlzLmxvZ0ZpbHRlciwgcHJvdmlkZXIuX3dyYXBMb2cobWVzc2FnZSwgcHJvdmlkZXIuX25ldHdvcmspKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEEgKipTb2NrZXRQcm92aWRlcioqIGlzIGJhY2tlZCBieSBhIGxvbmctbGl2ZWQgY29ubmVjdGlvbiBvdmVyIGFcclxuICogIHNvY2tldCwgd2hpY2ggY2FuIHN1YnNjcmliZSBhbmQgcmVjZWl2ZSByZWFsLXRpbWUgbWVzc2FnZXMgb3ZlclxyXG4gKiAgaXRzIGNvbW11bmljYXRpb24gY2hhbm5lbC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBTb2NrZXRQcm92aWRlciBleHRlbmRzIEpzb25ScGNBcGlQcm92aWRlciB7XHJcbiAgICAjY2FsbGJhY2tzO1xyXG4gICAgLy8gTWFwcyBlYWNoIGZpbHRlcklkIHRvIGl0cyBzdWJzY3JpYmVyXHJcbiAgICAjc3VicztcclxuICAgIC8vIElmIGFueSBldmVudHMgY29tZSBpbiBiZWZvcmUgYSBzdWJzY3JpYmVyIGhhcyBmaW5pc2hlZFxyXG4gICAgLy8gcmVnaXN0ZXJpbmcsIHF1ZXVlIHRoZW1cclxuICAgICNwZW5kaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlNvY2tldFByb3ZpZGVyKiogY29ubmVjdGVkIHRvICUlbmV0d29yayUlLlxyXG4gICAgICpcclxuICAgICAqICBJZiB1bnNwZWNpZmllZCwgdGhlIG5ldHdvcmsgd2lsbCBiZSBkaXNjb3ZlcmVkLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBfb3B0aW9ucykge1xyXG4gICAgICAgIC8vIENvcHkgdGhlIG9wdGlvbnNcclxuICAgICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgKF9vcHRpb25zICE9IG51bGwpID8gX29wdGlvbnMgOiB7fSk7XHJcbiAgICAgICAgLy8gU3VwcG9ydCBmb3IgYmF0Y2hlcyBpcyBnZW5lcmFsbHkgbm90IHN1cHBvcnRlZCBmb3JcclxuICAgICAgICAvLyBjb25uZWN0aW9uLWJhc2UgcHJvdmlkZXJzOyBpZiB0aGlzIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZVxyXG4gICAgICAgIC8vIHRoZSBfc2VuZCBzaG91bGQgYmUgdXBkYXRlZCB0byByZWZsZWN0IHRoaXNcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChvcHRpb25zLmJhdGNoTWF4Q291bnQgPT0gbnVsbCB8fCBvcHRpb25zLmJhdGNoTWF4Q291bnQgPT09IDEsIFwic29ja2V0cy1iYXNlZCBwcm92aWRlcnMgZG8gbm90IHN1cHBvcnQgYmF0Y2hlc1wiLCBcIm9wdGlvbnMuYmF0Y2hNYXhDb3VudFwiLCBfb3B0aW9ucyk7XHJcbiAgICAgICAgb3B0aW9ucy5iYXRjaE1heENvdW50ID0gMTtcclxuICAgICAgICAvLyBTb2NrZXQtYmFzZWQgUHJvdmlkZXJzIChnZW5lcmFsbHkpIGNhbm5vdCBjaGFuZ2UgdGhlaXIgbmV0d29yayxcclxuICAgICAgICAvLyBzaW5jZSB0aGV5IGhhdmUgYSBsb25nLWxpdmVkIGNvbm5lY3Rpb247IGJ1dCBsZXQgcGVvcGxlIG92ZXJyaWRlXHJcbiAgICAgICAgLy8gdGhpcyBpZiB0aGV5IGhhdmUganVzdCBjYXVzZS5cclxuICAgICAgICBpZiAob3B0aW9ucy5zdGF0aWNOZXR3b3JrID09IG51bGwpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5zdGF0aWNOZXR3b3JrID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy4jY2FsbGJhY2tzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuI3N1YnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy4jcGVuZGluZyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIC8vIFRoaXMgdmFsdWUgaXMgb25seSB2YWxpZCBhZnRlciBfc3RhcnQgaGFzIGJlZW4gY2FsbGVkXHJcbiAgICAvKlxyXG4gICAgZ2V0IF9uZXR3b3JrKCk6IE5ldHdvcmsge1xyXG4gICAgICAgIGlmICh0aGlzLiNuZXR3b3JrID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGhpcyBzaG91bGRuJ3QgaGFwcGVuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy4jbmV0d29yay5jbG9uZSgpO1xyXG4gICAgfVxyXG4gICAgKi9cclxuICAgIF9nZXRTdWJzY3JpYmVyKHN1Yikge1xyXG4gICAgICAgIHN3aXRjaCAoc3ViLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcImNsb3NlXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVubWFuYWdlZFN1YnNjcmliZXIoXCJjbG9zZVwiKTtcclxuICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNvY2tldEJsb2NrU3Vic2NyaWJlcih0aGlzKTtcclxuICAgICAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU29ja2V0UGVuZGluZ1N1YnNjcmliZXIodGhpcyk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTb2NrZXRFdmVudFN1YnNjcmliZXIodGhpcywgc3ViLmZpbHRlcik7XHJcbiAgICAgICAgICAgIGNhc2UgXCJvcnBoYW5cIjpcclxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZWQgYXV0by1tYXRpY2FsbHkgd2l0aGluIEFic3RyYWN0UHJvdmlkZXJcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGxvZy5yZW1vdmVkID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgaWYgKHN1Yi5maWx0ZXIub3JwaGFuID09PSBcImRyb3AtbG9nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVubWFuYWdlZFN1YnNjcmliZXIoXCJkcm9wLWxvZ1wiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9nZXRTdWJzY3JpYmVyKHN1Yik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZWdpc3RlciBhIG5ldyBzdWJzY3JpYmVyLiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxsZWQgYnkgU3Vic2NyaWJlcnNcclxuICAgICAqICBhbmQgZ2VuZXJhbGx5IGlzIHVuZWNlc3NhcnkgdW5sZXNzIGV4dGVuZGluZyBjYXBhYmlsaXRpZXMuXHJcbiAgICAgKi9cclxuICAgIF9yZWdpc3RlcihmaWx0ZXJJZCwgc3Vic2NyaWJlcikge1xyXG4gICAgICAgIHRoaXMuI3N1YnMuc2V0KGZpbHRlcklkLCBzdWJzY3JpYmVyKTtcclxuICAgICAgICBjb25zdCBwZW5kaW5nID0gdGhpcy4jcGVuZGluZy5nZXQoZmlsdGVySWQpO1xyXG4gICAgICAgIGlmIChwZW5kaW5nKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLl9oYW5kbGVNZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuI3BlbmRpbmcuZGVsZXRlKGZpbHRlcklkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyBfc2VuZChwYXlsb2FkKSB7XHJcbiAgICAgICAgLy8gV2ViU29ja2V0IHByb3ZpZGVyIGRvZXNuJ3QgYWNjZXB0IGJhdGNoZXNcclxuICAgICAgICBhc3NlcnRBcmd1bWVudCghQXJyYXkuaXNBcnJheShwYXlsb2FkKSwgXCJXZWJTb2NrZXQgZG9lcyBub3Qgc3VwcG9ydCBiYXRjaCBzZW5kXCIsIFwicGF5bG9hZFwiLCBwYXlsb2FkKTtcclxuICAgICAgICAvLyBAVE9ETzogc3RyaW5naWZ5IHBheWxvYWRzIGhlcmUgYW5kIHN0b3JlIHRvIHByZXZlbnQgbXV0YXRpb25zXHJcbiAgICAgICAgLy8gUHJlcGFyZSBhIHByb21pc2UgdG8gcmVzcG9uZCB0b1xyXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuI2NhbGxiYWNrcy5zZXQocGF5bG9hZC5pZCwgeyBwYXlsb2FkLCByZXNvbHZlLCByZWplY3QgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gV2FpdCB1bnRpbCB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZCBiZWZvcmUgd3JpdGluZyB0byBpdFxyXG4gICAgICAgIGF3YWl0IHRoaXMuX3dhaXRVbnRpbFJlYWR5KCk7XHJcbiAgICAgICAgLy8gV3JpdGUgdGhlIHJlcXVlc3QgdG8gdGhlIHNvY2tldFxyXG4gICAgICAgIGF3YWl0IHRoaXMuX3dyaXRlKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcclxuICAgICAgICByZXR1cm4gW2F3YWl0IHByb21pc2VdO1xyXG4gICAgfVxyXG4gICAgLy8gU3ViLWNsYXNzZXMgbXVzdCBjYWxsIHRoaXMgb25jZSB0aGV5IGFyZSBjb25uZWN0ZWRcclxuICAgIC8qXHJcbiAgICBhc3luYyBfc3RhcnQoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgaWYgKHRoaXMuI3JlYWR5KSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IHsgcGF5bG9hZCB9IG9mIHRoaXMuI2NhbGxiYWNrcy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl93cml0ZShKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLiNyZWFkeSA9IChhc3luYyBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgYXdhaXQgc3VwZXIuX3N0YXJ0KCk7XHJcbiAgICAgICAgfSkoKTtcclxuICAgIH1cclxuICAgICovXHJcbiAgICAvKipcclxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBjYWxsIHRoaXMgd2l0aCBtZXNzYWdlcyByZWNlaXZlZCBvdmVyIHRoZWlyXHJcbiAgICAgKiAgdHJhbnNwb3J0IHRvIGJlIHByb2Nlc3NlZCBhbmQgZGlzcGF0Y2hlZC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgX3Byb2Nlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSAoSlNPTi5wYXJzZShtZXNzYWdlKSk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgKHJlc3VsdCkgPT09IFwib2JqZWN0XCIgJiYgXCJpZFwiIGluIHJlc3VsdCkge1xyXG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuI2NhbGxiYWNrcy5nZXQocmVzdWx0LmlkKTtcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIG1ha2VFcnJvcihcInJlY2VpdmVkIHJlc3VsdCBmb3IgdW5rbm93biBpZFwiLCBcIlVOS05PV05fRVJST1JcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbkNvZGU6IFwiVU5LTk9XTl9JRFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuI2NhbGxiYWNrcy5kZWxldGUocmVzdWx0LmlkKTtcclxuICAgICAgICAgICAgY2FsbGJhY2sucmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZXN1bHQgJiYgcmVzdWx0Lm1ldGhvZCA9PT0gXCJldGhfc3Vic2NyaXB0aW9uXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgZmlsdGVySWQgPSByZXN1bHQucGFyYW1zLnN1YnNjcmlwdGlvbjtcclxuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHRoaXMuI3N1YnMuZ2V0KGZpbHRlcklkKTtcclxuICAgICAgICAgICAgaWYgKHN1YnNjcmliZXIpIHtcclxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuX2hhbmRsZU1lc3NhZ2UocmVzdWx0LnBhcmFtcy5yZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBlbmRpbmcgPSB0aGlzLiNwZW5kaW5nLmdldChmaWx0ZXJJZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3BlbmRpbmcuc2V0KGZpbHRlcklkLCBwZW5kaW5nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBlbmRpbmcucHVzaChyZXN1bHQucGFyYW1zLnJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIG1ha2VFcnJvcihcInJlY2VpdmVkIHVuZXhwZWN0ZWQgbWVzc2FnZVwiLCBcIlVOS05PV05fRVJST1JcIiwge1xyXG4gICAgICAgICAgICAgICAgcmVhc29uQ29kZTogXCJVTkVYUEVDVEVEX01FU1NBR0VcIixcclxuICAgICAgICAgICAgICAgIHJlc3VsdFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzIHRvIHNlbmQgJSVtZXNzYWdlJSUgb3ZlciB0aGVpclxyXG4gICAgICogIHRyYW5zcG9ydC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgX3dyaXRlKG1lc3NhZ2UpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWItY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItc29ja2V0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-socket.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-websocket.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-websocket.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocketProvider: () => (/* binding */ WebSocketProvider)\n/* harmony export */ });\n/* harmony import */ var _ws_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ws.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/ws-browser.js\");\n/* harmony import */ var _provider_socket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./provider-socket.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-socket.js\");\n /*-browser*/\r\n\r\n/**\r\n *  A JSON-RPC provider which is backed by a WebSocket.\r\n *\r\n *  WebSockets are often preferred because they retain a live connection\r\n *  to a server, which permits more instant access to events.\r\n *\r\n *  However, this incurs higher server infrasturture costs, so additional\r\n *  resources may be required to host your own WebSocket nodes and many\r\n *  third-party services charge additional fees for WebSocket endpoints.\r\n */\r\nclass WebSocketProvider extends _provider_socket_js__WEBPACK_IMPORTED_MODULE_0__.SocketProvider {\r\n    #connect;\r\n    #websocket;\r\n    get websocket() {\r\n        if (this.#websocket == null) {\r\n            throw new Error(\"websocket closed\");\r\n        }\r\n        return this.#websocket;\r\n    }\r\n    constructor(url, network, options) {\r\n        super(network, options);\r\n        if (typeof (url) === \"string\") {\r\n            this.#connect = () => { return new _ws_js__WEBPACK_IMPORTED_MODULE_1__.WebSocket(url); };\r\n            this.#websocket = this.#connect();\r\n        }\r\n        else if (typeof (url) === \"function\") {\r\n            this.#connect = url;\r\n            this.#websocket = url();\r\n        }\r\n        else {\r\n            this.#connect = null;\r\n            this.#websocket = url;\r\n        }\r\n        this.websocket.onopen = async () => {\r\n            try {\r\n                await this._start();\r\n                this.resume();\r\n            }\r\n            catch (error) {\r\n                console.log(\"failed to start WebsocketProvider\", error);\r\n                // @TODO: now what? Attempt reconnect?\r\n            }\r\n        };\r\n        this.websocket.onmessage = (message) => {\r\n            this._processMessage(message.data);\r\n        };\r\n        /*\r\n                this.websocket.onclose = (event) => {\r\n                    // @TODO: What event.code should we reconnect on?\r\n                    const reconnect = false;\r\n                    if (reconnect) {\r\n                        this.pause(true);\r\n                        if (this.#connect) {\r\n                            this.#websocket = this.#connect();\r\n                            this.#websocket.onopen = ...\r\n                            // @TODO: this requires the super class to rebroadcast; move it there\r\n                        }\r\n                        this._reconnect();\r\n                    }\r\n                };\r\n        */\r\n    }\r\n    async _write(message) {\r\n        this.websocket.send(message);\r\n    }\r\n    async destroy() {\r\n        if (this.#websocket != null) {\r\n            this.#websocket.close();\r\n            this.#websocket = null;\r\n        }\r\n        super.destroy();\r\n    }\r\n}\r\n//# sourceMappingURL=provider-websocket.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItd2Vic29ja2V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFrRCxDQUFDO0FBQ0c7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQ0FBZ0MsK0RBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxXQUFXLDZDQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHByb3ZpZGVyc1xccHJvdmlkZXItd2Vic29ja2V0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdlYlNvY2tldCBhcyBfV2ViU29ja2V0IH0gZnJvbSBcIi4vd3MuanNcIjsgLyotYnJvd3NlciovXHJcbmltcG9ydCB7IFNvY2tldFByb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItc29ja2V0LmpzXCI7XHJcbi8qKlxyXG4gKiAgQSBKU09OLVJQQyBwcm92aWRlciB3aGljaCBpcyBiYWNrZWQgYnkgYSBXZWJTb2NrZXQuXHJcbiAqXHJcbiAqICBXZWJTb2NrZXRzIGFyZSBvZnRlbiBwcmVmZXJyZWQgYmVjYXVzZSB0aGV5IHJldGFpbiBhIGxpdmUgY29ubmVjdGlvblxyXG4gKiAgdG8gYSBzZXJ2ZXIsIHdoaWNoIHBlcm1pdHMgbW9yZSBpbnN0YW50IGFjY2VzcyB0byBldmVudHMuXHJcbiAqXHJcbiAqICBIb3dldmVyLCB0aGlzIGluY3VycyBoaWdoZXIgc2VydmVyIGluZnJhc3R1cnR1cmUgY29zdHMsIHNvIGFkZGl0aW9uYWxcclxuICogIHJlc291cmNlcyBtYXkgYmUgcmVxdWlyZWQgdG8gaG9zdCB5b3VyIG93biBXZWJTb2NrZXQgbm9kZXMgYW5kIG1hbnlcclxuICogIHRoaXJkLXBhcnR5IHNlcnZpY2VzIGNoYXJnZSBhZGRpdGlvbmFsIGZlZXMgZm9yIFdlYlNvY2tldCBlbmRwb2ludHMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgV2ViU29ja2V0UHJvdmlkZXIgZXh0ZW5kcyBTb2NrZXRQcm92aWRlciB7XHJcbiAgICAjY29ubmVjdDtcclxuICAgICN3ZWJzb2NrZXQ7XHJcbiAgICBnZXQgd2Vic29ja2V0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLiN3ZWJzb2NrZXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3ZWJzb2NrZXQgY2xvc2VkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy4jd2Vic29ja2V0O1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IodXJsLCBuZXR3b3JrLCBvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0aGlzLiNjb25uZWN0ID0gKCkgPT4geyByZXR1cm4gbmV3IF9XZWJTb2NrZXQodXJsKTsgfTtcclxuICAgICAgICAgICAgdGhpcy4jd2Vic29ja2V0ID0gdGhpcy4jY29ubmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKHVybCkgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICB0aGlzLiNjb25uZWN0ID0gdXJsO1xyXG4gICAgICAgICAgICB0aGlzLiN3ZWJzb2NrZXQgPSB1cmwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLiN3ZWJzb2NrZXQgPSB1cmw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMud2Vic29ja2V0Lm9ub3BlbiA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VtZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJmYWlsZWQgdG8gc3RhcnQgV2Vic29ja2V0UHJvdmlkZXJcIiwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgLy8gQFRPRE86IG5vdyB3aGF0PyBBdHRlbXB0IHJlY29ubmVjdD9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQub25tZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc01lc3NhZ2UobWVzc2FnZS5kYXRhKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICB0aGlzLndlYnNvY2tldC5vbmNsb3NlID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IFdoYXQgZXZlbnQuY29kZSBzaG91bGQgd2UgcmVjb25uZWN0IG9uP1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY29ubmVjdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvbm5lY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXVzZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2Nvbm5lY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI3dlYnNvY2tldCA9IHRoaXMuI2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI3dlYnNvY2tldC5vbm9wZW4gPSAuLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiB0aGlzIHJlcXVpcmVzIHRoZSBzdXBlciBjbGFzcyB0byByZWJyb2FkY2FzdDsgbW92ZSBpdCB0aGVyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgKi9cclxuICAgIH1cclxuICAgIGFzeW5jIF93cml0ZShtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQuc2VuZChtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuI3dlYnNvY2tldCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuI3dlYnNvY2tldC5jbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLiN3ZWJzb2NrZXQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItd2Vic29ja2V0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider-websocket.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Block: () => (/* binding */ Block),\n/* harmony export */   FeeData: () => (/* binding */ FeeData),\n/* harmony export */   Log: () => (/* binding */ Log),\n/* harmony export */   TransactionReceipt: () => (/* binding */ TransactionReceipt),\n/* harmony export */   TransactionResponse: () => (/* binding */ TransactionResponse),\n/* harmony export */   copyRequest: () => (/* binding */ copyRequest)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transaction/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/index.js\");\n//import { resolveAddress } from \"@ethersproject/address\";\r\n\r\n\r\nconst BN_0 = BigInt(0);\r\n// -----------------------\r\nfunction getValue(value) {\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    return value;\r\n}\r\nfunction toJson(value) {\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    return value.toString();\r\n}\r\n// @TODO? <T extends FeeData = { }> implements Required<T>\r\n/**\r\n *  A **FeeData** wraps all the fee-related values associated with\r\n *  the network.\r\n */\r\nclass FeeData {\r\n    /**\r\n     *  The gas price for legacy networks.\r\n     */\r\n    gasPrice;\r\n    /**\r\n     *  The maximum fee to pay per gas.\r\n     *\r\n     *  The base fee per gas is defined by the network and based on\r\n     *  congestion, increasing the cost during times of heavy load\r\n     *  and lowering when less busy.\r\n     *\r\n     *  The actual fee per gas will be the base fee for the block\r\n     *  and the priority fee, up to the max fee per gas.\r\n     *\r\n     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))\r\n     */\r\n    maxFeePerGas;\r\n    /**\r\n     *  The additional amout to pay per gas to encourage a validator\r\n     *  to include the transaction.\r\n     *\r\n     *  The purpose of this is to compensate the validator for the\r\n     *  adjusted risk for including a given transaction.\r\n     *\r\n     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))\r\n     */\r\n    maxPriorityFeePerGas;\r\n    /**\r\n     *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and\r\n     *  %%maxPriorityFeePerGas%%.\r\n     */\r\n    constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\r\n            gasPrice: getValue(gasPrice),\r\n            maxFeePerGas: getValue(maxFeePerGas),\r\n            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)\r\n        });\r\n    }\r\n    /**\r\n     *  Returns a JSON-friendly value.\r\n     */\r\n    toJSON() {\r\n        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;\r\n        return {\r\n            _type: \"FeeData\",\r\n            gasPrice: toJson(gasPrice),\r\n            maxFeePerGas: toJson(maxFeePerGas),\r\n            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas),\r\n        };\r\n    }\r\n}\r\n;\r\n/**\r\n *  Returns a copy of %%req%% with all properties coerced to their strict\r\n *  types.\r\n */\r\nfunction copyRequest(req) {\r\n    const result = {};\r\n    // These could be addresses, ENS names or Addressables\r\n    if (req.to) {\r\n        result.to = req.to;\r\n    }\r\n    if (req.from) {\r\n        result.from = req.from;\r\n    }\r\n    if (req.data) {\r\n        result.data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(req.data);\r\n    }\r\n    const bigIntKeys = \"chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value\".split(/,/);\r\n    for (const key of bigIntKeys) {\r\n        if (!(key in req) || req[key] == null) {\r\n            continue;\r\n        }\r\n        result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(req[key], `request.${key}`);\r\n    }\r\n    const numberKeys = \"type,nonce\".split(/,/);\r\n    for (const key of numberKeys) {\r\n        if (!(key in req) || req[key] == null) {\r\n            continue;\r\n        }\r\n        result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(req[key], `request.${key}`);\r\n    }\r\n    if (req.accessList) {\r\n        result.accessList = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_1__.accessListify)(req.accessList);\r\n    }\r\n    if (req.authorizationList) {\r\n        result.authorizationList = req.authorizationList.slice();\r\n    }\r\n    if (\"blockTag\" in req) {\r\n        result.blockTag = req.blockTag;\r\n    }\r\n    if (\"enableCcipRead\" in req) {\r\n        result.enableCcipRead = !!req.enableCcipRead;\r\n    }\r\n    if (\"customData\" in req) {\r\n        result.customData = req.customData;\r\n    }\r\n    if (\"blobVersionedHashes\" in req && req.blobVersionedHashes) {\r\n        result.blobVersionedHashes = req.blobVersionedHashes.slice();\r\n    }\r\n    if (\"kzg\" in req) {\r\n        result.kzg = req.kzg;\r\n    }\r\n    if (\"blobs\" in req && req.blobs) {\r\n        result.blobs = req.blobs.map((b) => {\r\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isBytesLike)(b)) {\r\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(b);\r\n            }\r\n            return Object.assign({}, b);\r\n        });\r\n    }\r\n    return result;\r\n}\r\n/**\r\n *  A **Block** represents the data associated with a full block on\r\n *  Ethereum.\r\n */\r\nclass Block {\r\n    /**\r\n     *  The provider connected to the block used to fetch additional details\r\n     *  if necessary.\r\n     */\r\n    provider;\r\n    /**\r\n     *  The block number, sometimes called the block height. This is a\r\n     *  sequential number that is one higher than the parent block.\r\n     */\r\n    number;\r\n    /**\r\n     *  The block hash.\r\n     *\r\n     *  This hash includes all properties, so can be safely used to identify\r\n     *  an exact set of block properties.\r\n     */\r\n    hash;\r\n    /**\r\n     *  The timestamp for this block, which is the number of seconds since\r\n     *  epoch that this block was included.\r\n     */\r\n    timestamp;\r\n    /**\r\n     *  The block hash of the parent block.\r\n     */\r\n    parentHash;\r\n    /**\r\n     *  The hash tree root of the parent beacon block for the given\r\n     *  execution block. See [[link-eip-4788]].\r\n     */\r\n    parentBeaconBlockRoot;\r\n    /**\r\n     *  The nonce.\r\n     *\r\n     *  On legacy networks, this is the random number inserted which\r\n     *  permitted the difficulty target to be reached.\r\n     */\r\n    nonce;\r\n    /**\r\n     *  The difficulty target.\r\n     *\r\n     *  On legacy networks, this is the proof-of-work target required\r\n     *  for a block to meet the protocol rules to be included.\r\n     *\r\n     *  On modern networks, this is a random number arrived at using\r\n     *  randao.  @TODO: Find links?\r\n     */\r\n    difficulty;\r\n    /**\r\n     *  The total gas limit for this block.\r\n     */\r\n    gasLimit;\r\n    /**\r\n     *  The total gas used in this block.\r\n     */\r\n    gasUsed;\r\n    /**\r\n     *  The root hash for the global state after applying changes\r\n     *  in this block.\r\n     */\r\n    stateRoot;\r\n    /**\r\n     *  The hash of the transaction receipts trie.\r\n     */\r\n    receiptsRoot;\r\n    /**\r\n     *  The total amount of blob gas consumed by the transactions\r\n     *  within the block. See [[link-eip-4844]].\r\n     */\r\n    blobGasUsed;\r\n    /**\r\n     *  The running total of blob gas consumed in excess of the\r\n     *  target, prior to the block. See [[link-eip-4844]].\r\n     */\r\n    excessBlobGas;\r\n    /**\r\n     *  The miner coinbase address, wihch receives any subsidies for\r\n     *  including this block.\r\n     */\r\n    miner;\r\n    /**\r\n     *  The latest RANDAO mix of the post beacon state of\r\n     *  the previous block.\r\n     */\r\n    prevRandao;\r\n    /**\r\n     *  Any extra data the validator wished to include.\r\n     */\r\n    extraData;\r\n    /**\r\n     *  The base fee per gas that all transactions in this block were\r\n     *  charged.\r\n     *\r\n     *  This adjusts after each block, depending on how congested the network\r\n     *  is.\r\n     */\r\n    baseFeePerGas;\r\n    #transactions;\r\n    /**\r\n     *  Create a new **Block** object.\r\n     *\r\n     *  This should generally not be necessary as the unless implementing a\r\n     *  low-level library.\r\n     */\r\n    constructor(block, provider) {\r\n        this.#transactions = block.transactions.map((tx) => {\r\n            if (typeof (tx) !== \"string\") {\r\n                return new TransactionResponse(tx, provider);\r\n            }\r\n            return tx;\r\n        });\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\r\n            provider,\r\n            hash: getValue(block.hash),\r\n            number: block.number,\r\n            timestamp: block.timestamp,\r\n            parentHash: block.parentHash,\r\n            parentBeaconBlockRoot: block.parentBeaconBlockRoot,\r\n            nonce: block.nonce,\r\n            difficulty: block.difficulty,\r\n            gasLimit: block.gasLimit,\r\n            gasUsed: block.gasUsed,\r\n            blobGasUsed: block.blobGasUsed,\r\n            excessBlobGas: block.excessBlobGas,\r\n            miner: block.miner,\r\n            prevRandao: getValue(block.prevRandao),\r\n            extraData: block.extraData,\r\n            baseFeePerGas: getValue(block.baseFeePerGas),\r\n            stateRoot: block.stateRoot,\r\n            receiptsRoot: block.receiptsRoot,\r\n        });\r\n    }\r\n    /**\r\n     *  Returns the list of transaction hashes, in the order\r\n     *  they were executed within the block.\r\n     */\r\n    get transactions() {\r\n        return this.#transactions.map((tx) => {\r\n            if (typeof (tx) === \"string\") {\r\n                return tx;\r\n            }\r\n            return tx.hash;\r\n        });\r\n    }\r\n    /**\r\n     *  Returns the complete transactions, in the order they\r\n     *  were executed within the block.\r\n     *\r\n     *  This is only available for blocks which prefetched\r\n     *  transactions, by passing ``true`` to %%prefetchTxs%%\r\n     *  into [[Provider-getBlock]].\r\n     */\r\n    get prefetchedTransactions() {\r\n        const txs = this.#transactions.slice();\r\n        // Doesn't matter...\r\n        if (txs.length === 0) {\r\n            return [];\r\n        }\r\n        // Make sure we prefetched the transactions\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof (txs[0]) === \"object\", \"transactions were not prefetched with block request\", \"UNSUPPORTED_OPERATION\", {\r\n            operation: \"transactionResponses()\"\r\n        });\r\n        return txs;\r\n    }\r\n    /**\r\n     *  Returns a JSON-friendly value.\r\n     */\r\n    toJSON() {\r\n        const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash, miner, prevRandao, nonce, number, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;\r\n        return {\r\n            _type: \"Block\",\r\n            baseFeePerGas: toJson(baseFeePerGas),\r\n            difficulty: toJson(difficulty),\r\n            extraData,\r\n            gasLimit: toJson(gasLimit),\r\n            gasUsed: toJson(gasUsed),\r\n            blobGasUsed: toJson(this.blobGasUsed),\r\n            excessBlobGas: toJson(this.excessBlobGas),\r\n            hash, miner, prevRandao, nonce, number, parentHash, timestamp,\r\n            parentBeaconBlockRoot, stateRoot, receiptsRoot,\r\n            transactions,\r\n        };\r\n    }\r\n    [Symbol.iterator]() {\r\n        let index = 0;\r\n        const txs = this.transactions;\r\n        return {\r\n            next: () => {\r\n                if (index < this.length) {\r\n                    return {\r\n                        value: txs[index++], done: false\r\n                    };\r\n                }\r\n                return { value: undefined, done: true };\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     *  The number of transactions in this block.\r\n     */\r\n    get length() { return this.#transactions.length; }\r\n    /**\r\n     *  The [[link-js-date]] this block was included at.\r\n     */\r\n    get date() {\r\n        if (this.timestamp == null) {\r\n            return null;\r\n        }\r\n        return new Date(this.timestamp * 1000);\r\n    }\r\n    /**\r\n     *  Get the transaction at %%indexe%% within this block.\r\n     */\r\n    async getTransaction(indexOrHash) {\r\n        // Find the internal value by its index or hash\r\n        let tx = undefined;\r\n        if (typeof (indexOrHash) === \"number\") {\r\n            tx = this.#transactions[indexOrHash];\r\n        }\r\n        else {\r\n            const hash = indexOrHash.toLowerCase();\r\n            for (const v of this.#transactions) {\r\n                if (typeof (v) === \"string\") {\r\n                    if (v !== hash) {\r\n                        continue;\r\n                    }\r\n                    tx = v;\r\n                    break;\r\n                }\r\n                else {\r\n                    if (v.hash !== hash) {\r\n                        continue;\r\n                    }\r\n                    tx = v;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tx == null) {\r\n            throw new Error(\"no such tx\");\r\n        }\r\n        if (typeof (tx) === \"string\") {\r\n            return (await this.provider.getTransaction(tx));\r\n        }\r\n        else {\r\n            return tx;\r\n        }\r\n    }\r\n    /**\r\n     *  If a **Block** was fetched with a request to include the transactions\r\n     *  this will allow synchronous access to those transactions.\r\n     *\r\n     *  If the transactions were not prefetched, this will throw.\r\n     */\r\n    getPrefetchedTransaction(indexOrHash) {\r\n        const txs = this.prefetchedTransactions;\r\n        if (typeof (indexOrHash) === \"number\") {\r\n            return txs[indexOrHash];\r\n        }\r\n        indexOrHash = indexOrHash.toLowerCase();\r\n        for (const tx of txs) {\r\n            if (tx.hash === indexOrHash) {\r\n                return tx;\r\n            }\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"no matching transaction\", \"indexOrHash\", indexOrHash);\r\n    }\r\n    /**\r\n     *  Returns true if this block been mined. This provides a type guard\r\n     *  for all properties on a [[MinedBlock]].\r\n     */\r\n    isMined() { return !!this.hash; }\r\n    /**\r\n     *  Returns true if this block is an [[link-eip-2930]] block.\r\n     */\r\n    isLondon() {\r\n        return !!this.baseFeePerGas;\r\n    }\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    orphanedEvent() {\r\n        if (!this.isMined()) {\r\n            throw new Error(\"\");\r\n        }\r\n        return createOrphanedBlockFilter(this);\r\n    }\r\n}\r\n//////////////////////\r\n// Log\r\n/**\r\n *  A **Log** in Ethereum represents an event that has been included in a\r\n *  transaction using the ``LOG*`` opcodes, which are most commonly used by\r\n *  Solidity's emit for announcing events.\r\n */\r\nclass Log {\r\n    /**\r\n     *  The provider connected to the log used to fetch additional details\r\n     *  if necessary.\r\n     */\r\n    provider;\r\n    /**\r\n     *  The transaction hash of the transaction this log occurred in. Use the\r\n     *  [[Log-getTransaction]] to get the [[TransactionResponse]].\r\n     */\r\n    transactionHash;\r\n    /**\r\n     *  The block hash of the block this log occurred in. Use the\r\n     *  [[Log-getBlock]] to get the [[Block]].\r\n     */\r\n    blockHash;\r\n    /**\r\n     *  The block number of the block this log occurred in. It is preferred\r\n     *  to use the [[Block-hash]] when fetching the related [[Block]],\r\n     *  since in the case of an orphaned block, the block at that height may\r\n     *  have changed.\r\n     */\r\n    blockNumber;\r\n    /**\r\n     *  If the **Log** represents a block that was removed due to an orphaned\r\n     *  block, this will be true.\r\n     *\r\n     *  This can only happen within an orphan event listener.\r\n     */\r\n    removed;\r\n    /**\r\n     *  The address of the contract that emitted this log.\r\n     */\r\n    address;\r\n    /**\r\n     *  The data included in this log when it was emitted.\r\n     */\r\n    data;\r\n    /**\r\n     *  The indexed topics included in this log when it was emitted.\r\n     *\r\n     *  All topics are included in the bloom filters, so they can be\r\n     *  efficiently filtered using the [[Provider-getLogs]] method.\r\n     */\r\n    topics;\r\n    /**\r\n     *  The index within the block this log occurred at. This is generally\r\n     *  not useful to developers, but can be used with the various roots\r\n     *  to proof inclusion within a block.\r\n     */\r\n    index;\r\n    /**\r\n     *  The index within the transaction of this log.\r\n     */\r\n    transactionIndex;\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    constructor(log, provider) {\r\n        this.provider = provider;\r\n        const topics = Object.freeze(log.topics.slice());\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\r\n            transactionHash: log.transactionHash,\r\n            blockHash: log.blockHash,\r\n            blockNumber: log.blockNumber,\r\n            removed: log.removed,\r\n            address: log.address,\r\n            data: log.data,\r\n            topics,\r\n            index: log.index,\r\n            transactionIndex: log.transactionIndex,\r\n        });\r\n    }\r\n    /**\r\n     *  Returns a JSON-compatible object.\r\n     */\r\n    toJSON() {\r\n        const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;\r\n        return {\r\n            _type: \"log\",\r\n            address, blockHash, blockNumber, data, index,\r\n            removed, topics, transactionHash, transactionIndex\r\n        };\r\n    }\r\n    /**\r\n     *  Returns the block that this log occurred in.\r\n     */\r\n    async getBlock() {\r\n        const block = await this.provider.getBlock(this.blockHash);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!!block, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\r\n        return block;\r\n    }\r\n    /**\r\n     *  Returns the transaction that this log occurred in.\r\n     */\r\n    async getTransaction() {\r\n        const tx = await this.provider.getTransaction(this.transactionHash);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!!tx, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\r\n        return tx;\r\n    }\r\n    /**\r\n     *  Returns the transaction receipt fot the transaction that this\r\n     *  log occurred in.\r\n     */\r\n    async getTransactionReceipt() {\r\n        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!!receipt, \"failed to find transaction receipt\", \"UNKNOWN_ERROR\", {});\r\n        return receipt;\r\n    }\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    removedEvent() {\r\n        return createRemovedLogFilter(this);\r\n    }\r\n}\r\n//////////////////////\r\n// Transaction Receipt\r\n/*\r\nexport interface LegacyTransactionReceipt {\r\n    byzantium: false;\r\n    status: null;\r\n    root: string;\r\n}\r\n\r\nexport interface ByzantiumTransactionReceipt {\r\n    byzantium: true;\r\n    status: number;\r\n    root: null;\r\n}\r\n*/\r\n/**\r\n *  A **TransactionReceipt** includes additional information about a\r\n *  transaction that is only available after it has been mined.\r\n */\r\nclass TransactionReceipt {\r\n    /**\r\n     *  The provider connected to the log used to fetch additional details\r\n     *  if necessary.\r\n     */\r\n    provider;\r\n    /**\r\n     *  The address the transaction was sent to.\r\n     */\r\n    to;\r\n    /**\r\n     *  The sender of the transaction.\r\n     */\r\n    from;\r\n    /**\r\n     *  The address of the contract if the transaction was directly\r\n     *  responsible for deploying one.\r\n     *\r\n     *  This is non-null **only** if the ``to`` is empty and the ``data``\r\n     *  was successfully executed as initcode.\r\n     */\r\n    contractAddress;\r\n    /**\r\n     *  The transaction hash.\r\n     */\r\n    hash;\r\n    /**\r\n     *  The index of this transaction within the block transactions.\r\n     */\r\n    index;\r\n    /**\r\n     *  The block hash of the [[Block]] this transaction was included in.\r\n     */\r\n    blockHash;\r\n    /**\r\n     *  The block number of the [[Block]] this transaction was included in.\r\n     */\r\n    blockNumber;\r\n    /**\r\n     *  The bloom filter bytes that represent all logs that occurred within\r\n     *  this transaction. This is generally not useful for most developers,\r\n     *  but can be used to validate the included logs.\r\n     */\r\n    logsBloom;\r\n    /**\r\n     *  The actual amount of gas used by this transaction.\r\n     *\r\n     *  When creating a transaction, the amount of gas that will be used can\r\n     *  only be approximated, but the sender must pay the gas fee for the\r\n     *  entire gas limit. After the transaction, the difference is refunded.\r\n     */\r\n    gasUsed;\r\n    /**\r\n     *  The gas used for BLObs. See [[link-eip-4844]].\r\n     */\r\n    blobGasUsed;\r\n    /**\r\n     *  The amount of gas used by all transactions within the block for this\r\n     *  and all transactions with a lower ``index``.\r\n     *\r\n     *  This is generally not useful for developers but can be used to\r\n     *  validate certain aspects of execution.\r\n     */\r\n    cumulativeGasUsed;\r\n    /**\r\n     *  The actual gas price used during execution.\r\n     *\r\n     *  Due to the complexity of [[link-eip-1559]] this value can only\r\n     *  be caluclated after the transaction has been mined, snce the base\r\n     *  fee is protocol-enforced.\r\n     */\r\n    gasPrice;\r\n    /**\r\n     *  The price paid per BLOB in gas. See [[link-eip-4844]].\r\n     */\r\n    blobGasPrice;\r\n    /**\r\n     *  The [[link-eip-2718]] transaction type.\r\n     */\r\n    type;\r\n    //readonly byzantium!: boolean;\r\n    /**\r\n     *  The status of this transaction, indicating success (i.e. ``1``) or\r\n     *  a revert (i.e. ``0``).\r\n     *\r\n     *  This is available in post-byzantium blocks, but some backends may\r\n     *  backfill this value.\r\n     */\r\n    status;\r\n    /**\r\n     *  The root hash of this transaction.\r\n     *\r\n     *  This is no present and was only included in pre-byzantium blocks, but\r\n     *  could be used to validate certain parts of the receipt.\r\n     */\r\n    root;\r\n    #logs;\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    constructor(tx, provider) {\r\n        this.#logs = Object.freeze(tx.logs.map((log) => {\r\n            return new Log(log, provider);\r\n        }));\r\n        let gasPrice = BN_0;\r\n        if (tx.effectiveGasPrice != null) {\r\n            gasPrice = tx.effectiveGasPrice;\r\n        }\r\n        else if (tx.gasPrice != null) {\r\n            gasPrice = tx.gasPrice;\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\r\n            provider,\r\n            to: tx.to,\r\n            from: tx.from,\r\n            contractAddress: tx.contractAddress,\r\n            hash: tx.hash,\r\n            index: tx.index,\r\n            blockHash: tx.blockHash,\r\n            blockNumber: tx.blockNumber,\r\n            logsBloom: tx.logsBloom,\r\n            gasUsed: tx.gasUsed,\r\n            cumulativeGasUsed: tx.cumulativeGasUsed,\r\n            blobGasUsed: tx.blobGasUsed,\r\n            gasPrice,\r\n            blobGasPrice: tx.blobGasPrice,\r\n            type: tx.type,\r\n            //byzantium: tx.byzantium,\r\n            status: tx.status,\r\n            root: tx.root\r\n        });\r\n    }\r\n    /**\r\n     *  The logs for this transaction.\r\n     */\r\n    get logs() { return this.#logs; }\r\n    /**\r\n     *  Returns a JSON-compatible representation.\r\n     */\r\n    toJSON() {\r\n        const { to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom, logs, //byzantium, \r\n        status, root } = this;\r\n        return {\r\n            _type: \"TransactionReceipt\",\r\n            blockHash, blockNumber,\r\n            //byzantium, \r\n            contractAddress,\r\n            cumulativeGasUsed: toJson(this.cumulativeGasUsed),\r\n            from,\r\n            gasPrice: toJson(this.gasPrice),\r\n            blobGasUsed: toJson(this.blobGasUsed),\r\n            blobGasPrice: toJson(this.blobGasPrice),\r\n            gasUsed: toJson(this.gasUsed),\r\n            hash, index, logs, logsBloom, root, status, to\r\n        };\r\n    }\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    get length() { return this.logs.length; }\r\n    [Symbol.iterator]() {\r\n        let index = 0;\r\n        return {\r\n            next: () => {\r\n                if (index < this.length) {\r\n                    return { value: this.logs[index++], done: false };\r\n                }\r\n                return { value: undefined, done: true };\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     *  The total fee for this transaction, in wei.\r\n     */\r\n    get fee() {\r\n        return this.gasUsed * this.gasPrice;\r\n    }\r\n    /**\r\n     *  Resolves to the block this transaction occurred in.\r\n     */\r\n    async getBlock() {\r\n        const block = await this.provider.getBlock(this.blockHash);\r\n        if (block == null) {\r\n            throw new Error(\"TODO\");\r\n        }\r\n        return block;\r\n    }\r\n    /**\r\n     *  Resolves to the transaction this transaction occurred in.\r\n     */\r\n    async getTransaction() {\r\n        const tx = await this.provider.getTransaction(this.hash);\r\n        if (tx == null) {\r\n            throw new Error(\"TODO\");\r\n        }\r\n        return tx;\r\n    }\r\n    /**\r\n     *  Resolves to the return value of the execution of this transaction.\r\n     *\r\n     *  Support for this feature is limited, as it requires an archive node\r\n     *  with the ``debug_`` or ``trace_`` API enabled.\r\n     */\r\n    async getResult() {\r\n        return (await this.provider.getTransactionResult(this.hash));\r\n    }\r\n    /**\r\n     *  Resolves to the number of confirmations this transaction has.\r\n     */\r\n    async confirmations() {\r\n        return (await this.provider.getBlockNumber()) - this.blockNumber + 1;\r\n    }\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    removedEvent() {\r\n        return createRemovedTransactionFilter(this);\r\n    }\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    reorderedEvent(other) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!other || other.isMined(), \"unmined 'other' transction cannot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"reorderedEvent(other)\" });\r\n        return createReorderedTransactionFilter(this, other);\r\n    }\r\n}\r\n/**\r\n *  A **TransactionResponse** includes all properties about a transaction\r\n *  that was sent to the network, which may or may not be included in a\r\n *  block.\r\n *\r\n *  The [[TransactionResponse-isMined]] can be used to check if the\r\n *  transaction has been mined as well as type guard that the otherwise\r\n *  possibly ``null`` properties are defined.\r\n */\r\nclass TransactionResponse {\r\n    /**\r\n     *  The provider this is connected to, which will influence how its\r\n     *  methods will resolve its async inspection methods.\r\n     */\r\n    provider;\r\n    /**\r\n     *  The block number of the block that this transaction was included in.\r\n     *\r\n     *  This is ``null`` for pending transactions.\r\n     */\r\n    blockNumber;\r\n    /**\r\n     *  The blockHash of the block that this transaction was included in.\r\n     *\r\n     *  This is ``null`` for pending transactions.\r\n     */\r\n    blockHash;\r\n    /**\r\n     *  The index within the block that this transaction resides at.\r\n     */\r\n    index;\r\n    /**\r\n     *  The transaction hash.\r\n     */\r\n    hash;\r\n    /**\r\n     *  The [[link-eip-2718]] transaction envelope type. This is\r\n     *  ``0`` for legacy transactions types.\r\n     */\r\n    type;\r\n    /**\r\n     *  The receiver of this transaction.\r\n     *\r\n     *  If ``null``, then the transaction is an initcode transaction.\r\n     *  This means the result of executing the [[data]] will be deployed\r\n     *  as a new contract on chain (assuming it does not revert) and the\r\n     *  address may be computed using [[getCreateAddress]].\r\n     */\r\n    to;\r\n    /**\r\n     *  The sender of this transaction. It is implicitly computed\r\n     *  from the transaction pre-image hash (as the digest) and the\r\n     *  [[signature]] using ecrecover.\r\n     */\r\n    from;\r\n    /**\r\n     *  The nonce, which is used to prevent replay attacks and offer\r\n     *  a method to ensure transactions from a given sender are explicitly\r\n     *  ordered.\r\n     *\r\n     *  When sending a transaction, this must be equal to the number of\r\n     *  transactions ever sent by [[from]].\r\n     */\r\n    nonce;\r\n    /**\r\n     *  The maximum units of gas this transaction can consume. If execution\r\n     *  exceeds this, the entries transaction is reverted and the sender\r\n     *  is charged for the full amount, despite not state changes being made.\r\n     */\r\n    gasLimit;\r\n    /**\r\n     *  The gas price can have various values, depending on the network.\r\n     *\r\n     *  In modern networks, for transactions that are included this is\r\n     *  the //effective gas price// (the fee per gas that was actually\r\n     *  charged), while for transactions that have not been included yet\r\n     *  is the [[maxFeePerGas]].\r\n     *\r\n     *  For legacy transactions, or transactions on legacy networks, this\r\n     *  is the fee that will be charged per unit of gas the transaction\r\n     *  consumes.\r\n     */\r\n    gasPrice;\r\n    /**\r\n     *  The maximum priority fee (per unit of gas) to allow a\r\n     *  validator to charge the sender. This is inclusive of the\r\n     *  [[maxFeeFeePerGas]].\r\n     */\r\n    maxPriorityFeePerGas;\r\n    /**\r\n     *  The maximum fee (per unit of gas) to allow this transaction\r\n     *  to charge the sender.\r\n     */\r\n    maxFeePerGas;\r\n    /**\r\n     *  The [[link-eip-4844]] max fee per BLOb gas.\r\n     */\r\n    maxFeePerBlobGas;\r\n    /**\r\n     *  The data.\r\n     */\r\n    data;\r\n    /**\r\n     *  The value, in wei. Use [[formatEther]] to format this value\r\n     *  as ether.\r\n     */\r\n    value;\r\n    /**\r\n     *  The chain ID.\r\n     */\r\n    chainId;\r\n    /**\r\n     *  The signature.\r\n     */\r\n    signature;\r\n    /**\r\n     *  The [[link-eip-2930]] access list for transaction types that\r\n     *  support it, otherwise ``null``.\r\n     */\r\n    accessList;\r\n    /**\r\n     *  The [[link-eip-4844]] BLOb versioned hashes.\r\n     */\r\n    blobVersionedHashes;\r\n    /**\r\n     *  The [[link-eip-7702]] authorizations (if any).\r\n     */\r\n    authorizationList;\r\n    #startBlock;\r\n    /**\r\n     *  @_ignore:\r\n     */\r\n    constructor(tx, provider) {\r\n        this.provider = provider;\r\n        this.blockNumber = (tx.blockNumber != null) ? tx.blockNumber : null;\r\n        this.blockHash = (tx.blockHash != null) ? tx.blockHash : null;\r\n        this.hash = tx.hash;\r\n        this.index = tx.index;\r\n        this.type = tx.type;\r\n        this.from = tx.from;\r\n        this.to = tx.to || null;\r\n        this.gasLimit = tx.gasLimit;\r\n        this.nonce = tx.nonce;\r\n        this.data = tx.data;\r\n        this.value = tx.value;\r\n        this.gasPrice = tx.gasPrice;\r\n        this.maxPriorityFeePerGas = (tx.maxPriorityFeePerGas != null) ? tx.maxPriorityFeePerGas : null;\r\n        this.maxFeePerGas = (tx.maxFeePerGas != null) ? tx.maxFeePerGas : null;\r\n        this.maxFeePerBlobGas = (tx.maxFeePerBlobGas != null) ? tx.maxFeePerBlobGas : null;\r\n        this.chainId = tx.chainId;\r\n        this.signature = tx.signature;\r\n        this.accessList = (tx.accessList != null) ? tx.accessList : null;\r\n        this.blobVersionedHashes = (tx.blobVersionedHashes != null) ? tx.blobVersionedHashes : null;\r\n        this.authorizationList = (tx.authorizationList != null) ? tx.authorizationList : null;\r\n        this.#startBlock = -1;\r\n    }\r\n    /**\r\n     *  Returns a JSON-compatible representation of this transaction.\r\n     */\r\n    toJSON() {\r\n        const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList, blobVersionedHashes } = this;\r\n        return {\r\n            _type: \"TransactionResponse\",\r\n            accessList, blockNumber, blockHash,\r\n            blobVersionedHashes,\r\n            chainId: toJson(this.chainId),\r\n            data, from,\r\n            gasLimit: toJson(this.gasLimit),\r\n            gasPrice: toJson(this.gasPrice),\r\n            hash,\r\n            maxFeePerGas: toJson(this.maxFeePerGas),\r\n            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),\r\n            maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),\r\n            nonce, signature, to, index, type,\r\n            value: toJson(this.value),\r\n        };\r\n    }\r\n    /**\r\n     *  Resolves to the Block that this transaction was included in.\r\n     *\r\n     *  This will return null if the transaction has not been included yet.\r\n     */\r\n    async getBlock() {\r\n        let blockNumber = this.blockNumber;\r\n        if (blockNumber == null) {\r\n            const tx = await this.getTransaction();\r\n            if (tx) {\r\n                blockNumber = tx.blockNumber;\r\n            }\r\n        }\r\n        if (blockNumber == null) {\r\n            return null;\r\n        }\r\n        const block = this.provider.getBlock(blockNumber);\r\n        if (block == null) {\r\n            throw new Error(\"TODO\");\r\n        }\r\n        return block;\r\n    }\r\n    /**\r\n     *  Resolves to this transaction being re-requested from the\r\n     *  provider. This can be used if you have an unmined transaction\r\n     *  and wish to get an up-to-date populated instance.\r\n     */\r\n    async getTransaction() {\r\n        return this.provider.getTransaction(this.hash);\r\n    }\r\n    /**\r\n     *  Resolve to the number of confirmations this transaction has.\r\n     */\r\n    async confirmations() {\r\n        if (this.blockNumber == null) {\r\n            const { tx, blockNumber } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\r\n                tx: this.getTransaction(),\r\n                blockNumber: this.provider.getBlockNumber()\r\n            });\r\n            // Not mined yet...\r\n            if (tx == null || tx.blockNumber == null) {\r\n                return 0;\r\n            }\r\n            return blockNumber - tx.blockNumber + 1;\r\n        }\r\n        const blockNumber = await this.provider.getBlockNumber();\r\n        return blockNumber - this.blockNumber + 1;\r\n    }\r\n    /**\r\n     *  Resolves once this transaction has been mined and has\r\n     *  %%confirms%% blocks including it (default: ``1``) with an\r\n     *  optional %%timeout%%.\r\n     *\r\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\r\n     *  and the transaction has not been mined, otherwise this will\r\n     *  wait until enough confirmations have completed.\r\n     */\r\n    async wait(_confirms, _timeout) {\r\n        const confirms = (_confirms == null) ? 1 : _confirms;\r\n        const timeout = (_timeout == null) ? 0 : _timeout;\r\n        let startBlock = this.#startBlock;\r\n        let nextScan = -1;\r\n        let stopScanning = (startBlock === -1) ? true : false;\r\n        const checkReplacement = async () => {\r\n            // Get the current transaction count for this sender\r\n            if (stopScanning) {\r\n                return null;\r\n            }\r\n            const { blockNumber, nonce } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\r\n                blockNumber: this.provider.getBlockNumber(),\r\n                nonce: this.provider.getTransactionCount(this.from)\r\n            });\r\n            // No transaction or our nonce has not been mined yet; but we\r\n            // can start scanning later when we do start\r\n            if (nonce < this.nonce) {\r\n                startBlock = blockNumber;\r\n                return;\r\n            }\r\n            // We were mined; no replacement\r\n            if (stopScanning) {\r\n                return null;\r\n            }\r\n            const mined = await this.getTransaction();\r\n            if (mined && mined.blockNumber != null) {\r\n                return;\r\n            }\r\n            // We were replaced; start scanning for that transaction\r\n            // Starting to scan; look back a few extra blocks for safety\r\n            if (nextScan === -1) {\r\n                nextScan = startBlock - 3;\r\n                if (nextScan < this.#startBlock) {\r\n                    nextScan = this.#startBlock;\r\n                }\r\n            }\r\n            while (nextScan <= blockNumber) {\r\n                // Get the next block to scan\r\n                if (stopScanning) {\r\n                    return null;\r\n                }\r\n                const block = await this.provider.getBlock(nextScan, true);\r\n                // This should not happen; but we'll try again shortly\r\n                if (block == null) {\r\n                    return;\r\n                }\r\n                // We were mined; no replacement\r\n                for (const hash of block) {\r\n                    if (hash === this.hash) {\r\n                        return;\r\n                    }\r\n                }\r\n                // Search for the transaction that replaced us\r\n                for (let i = 0; i < block.length; i++) {\r\n                    const tx = await block.getTransaction(i);\r\n                    if (tx.from === this.from && tx.nonce === this.nonce) {\r\n                        // Get the receipt\r\n                        if (stopScanning) {\r\n                            return null;\r\n                        }\r\n                        const receipt = await this.provider.getTransactionReceipt(tx.hash);\r\n                        // This should not happen; but we'll try again shortly\r\n                        if (receipt == null) {\r\n                            return;\r\n                        }\r\n                        // We will retry this on the next block (this case could be optimized)\r\n                        if ((blockNumber - receipt.blockNumber + 1) < confirms) {\r\n                            return;\r\n                        }\r\n                        // The reason we were replaced\r\n                        let reason = \"replaced\";\r\n                        if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {\r\n                            reason = \"repriced\";\r\n                        }\r\n                        else if (tx.data === \"0x\" && tx.from === tx.to && tx.value === BN_0) {\r\n                            reason = \"cancelled\";\r\n                        }\r\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"transaction was replaced\", \"TRANSACTION_REPLACED\", {\r\n                            cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\r\n                            reason,\r\n                            replacement: tx.replaceableTransaction(startBlock),\r\n                            hash: tx.hash,\r\n                            receipt\r\n                        });\r\n                    }\r\n                }\r\n                nextScan++;\r\n            }\r\n            return;\r\n        };\r\n        const checkReceipt = (receipt) => {\r\n            if (receipt == null || receipt.status !== 0) {\r\n                return receipt;\r\n            }\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"transaction execution reverted\", \"CALL_EXCEPTION\", {\r\n                action: \"sendTransaction\",\r\n                data: null, reason: null, invocation: null, revert: null,\r\n                transaction: {\r\n                    to: receipt.to,\r\n                    from: receipt.from,\r\n                    data: \"\" // @TODO: in v7, split out sendTransaction properties\r\n                }, receipt\r\n            });\r\n        };\r\n        const receipt = await this.provider.getTransactionReceipt(this.hash);\r\n        if (confirms === 0) {\r\n            return checkReceipt(receipt);\r\n        }\r\n        if (receipt) {\r\n            if (confirms === 1 || (await receipt.confirmations()) >= confirms) {\r\n                return checkReceipt(receipt);\r\n            }\r\n        }\r\n        else {\r\n            // Check for a replacement; throws if a replacement was found\r\n            await checkReplacement();\r\n            // Allow null only when the confirms is 0\r\n            if (confirms === 0) {\r\n                return null;\r\n            }\r\n        }\r\n        const waiter = new Promise((resolve, reject) => {\r\n            // List of things to cancel when we have a result (one way or the other)\r\n            const cancellers = [];\r\n            const cancel = () => { cancellers.forEach((c) => c()); };\r\n            // On cancel, stop scanning for replacements\r\n            cancellers.push(() => { stopScanning = true; });\r\n            // Set up any timeout requested\r\n            if (timeout > 0) {\r\n                const timer = setTimeout(() => {\r\n                    cancel();\r\n                    reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(\"wait for transaction timeout\", \"TIMEOUT\"));\r\n                }, timeout);\r\n                cancellers.push(() => { clearTimeout(timer); });\r\n            }\r\n            const txListener = async (receipt) => {\r\n                // Done; return it!\r\n                if ((await receipt.confirmations()) >= confirms) {\r\n                    cancel();\r\n                    try {\r\n                        resolve(checkReceipt(receipt));\r\n                    }\r\n                    catch (error) {\r\n                        reject(error);\r\n                    }\r\n                }\r\n            };\r\n            cancellers.push(() => { this.provider.off(this.hash, txListener); });\r\n            this.provider.on(this.hash, txListener);\r\n            // We support replacement detection; start checking\r\n            if (startBlock >= 0) {\r\n                const replaceListener = async () => {\r\n                    try {\r\n                        // Check for a replacement; this throws only if one is found\r\n                        await checkReplacement();\r\n                    }\r\n                    catch (error) {\r\n                        // We were replaced (with enough confirms); re-throw the error\r\n                        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"TRANSACTION_REPLACED\")) {\r\n                            cancel();\r\n                            reject(error);\r\n                            return;\r\n                        }\r\n                    }\r\n                    // Rescheudle a check on the next block\r\n                    if (!stopScanning) {\r\n                        this.provider.once(\"block\", replaceListener);\r\n                    }\r\n                };\r\n                cancellers.push(() => { this.provider.off(\"block\", replaceListener); });\r\n                this.provider.once(\"block\", replaceListener);\r\n            }\r\n        });\r\n        return await waiter;\r\n    }\r\n    /**\r\n     *  Returns ``true`` if this transaction has been included.\r\n     *\r\n     *  This is effective only as of the time the TransactionResponse\r\n     *  was instantiated. To get up-to-date information, use\r\n     *  [[getTransaction]].\r\n     *\r\n     *  This provides a Type Guard that this transaction will have\r\n     *  non-null property values for properties that are null for\r\n     *  unmined transactions.\r\n     */\r\n    isMined() {\r\n        return (this.blockHash != null);\r\n    }\r\n    /**\r\n     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)\r\n     *  transaction.\r\n     *\r\n     *  This provides a Type Guard that this transaction will have\r\n     *  the ``null``-ness for hardfork-specific properties set correctly.\r\n     */\r\n    isLegacy() {\r\n        return (this.type === 0);\r\n    }\r\n    /**\r\n     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)\r\n     *  transaction. See [[link-eip-2070]].\r\n     *\r\n     *  This provides a Type Guard that this transaction will have\r\n     *  the ``null``-ness for hardfork-specific properties set correctly.\r\n     */\r\n    isBerlin() {\r\n        return (this.type === 1);\r\n    }\r\n    /**\r\n     *  Returns true if the transaction is a London (i.e. ``type == 2``)\r\n     *  transaction. See [[link-eip-1559]].\r\n     *\r\n     *  This provides a Type Guard that this transaction will have\r\n     *  the ``null``-ness for hardfork-specific properties set correctly.\r\n     */\r\n    isLondon() {\r\n        return (this.type === 2);\r\n    }\r\n    /**\r\n     *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)\r\n     *  transaction. See [[link-eip-4844]].\r\n     */\r\n    isCancun() {\r\n        return (this.type === 3);\r\n    }\r\n    /**\r\n     *  Returns a filter which can be used to listen for orphan events\r\n     *  that evict this transaction.\r\n     */\r\n    removedEvent() {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\r\n        return createRemovedTransactionFilter(this);\r\n    }\r\n    /**\r\n     *  Returns a filter which can be used to listen for orphan events\r\n     *  that re-order this event against %%other%%.\r\n     */\r\n    reorderedEvent(other) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!other || other.isMined(), \"unmined 'other' transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\r\n        return createReorderedTransactionFilter(this, other);\r\n    }\r\n    /**\r\n     *  Returns a new TransactionResponse instance which has the ability to\r\n     *  detect (and throw an error) if the transaction is replaced, which\r\n     *  will begin scanning at %%startBlock%%.\r\n     *\r\n     *  This should generally not be used by developers and is intended\r\n     *  primarily for internal use. Setting an incorrect %%startBlock%% can\r\n     *  have devastating performance consequences if used incorrectly.\r\n     */\r\n    replaceableTransaction(startBlock) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(startBlock) && startBlock >= 0, \"invalid startBlock\", \"startBlock\", startBlock);\r\n        const tx = new TransactionResponse(this, this.provider);\r\n        tx.#startBlock = startBlock;\r\n        return tx;\r\n    }\r\n}\r\nfunction createOrphanedBlockFilter(block) {\r\n    return { orphan: \"drop-block\", hash: block.hash, number: block.number };\r\n}\r\nfunction createReorderedTransactionFilter(tx, other) {\r\n    return { orphan: \"reorder-transaction\", tx, other };\r\n}\r\nfunction createRemovedTransactionFilter(tx) {\r\n    return { orphan: \"drop-transaction\", tx };\r\n}\r\nfunction createRemovedLogFilter(log) {\r\n    return { orphan: \"drop-log\", log: {\r\n            transactionHash: log.transactionHash,\r\n            blockHash: log.blockHash,\r\n            blockNumber: log.blockNumber,\r\n            address: log.address,\r\n            data: log.data,\r\n            topics: Object.freeze(log.topics.slice()),\r\n            index: log.index\r\n        } };\r\n}\r\n//# sourceMappingURL=provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxXQUFXLGlCQUFpQjtBQUNvSTtBQUN4RztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQStDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBEQUFTLHNCQUFzQixJQUFJO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwREFBUyxzQkFBc0IsSUFBSTtBQUN6RDtBQUNBO0FBQ0EsNEJBQTRCLG9FQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBVztBQUMzQix1QkFBdUIsd0RBQU87QUFDOUI7QUFDQSxtQ0FBbUM7QUFDbkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVEsaUVBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBTTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1TEFBdUw7QUFDdk07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtR0FBbUc7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQU0sMkRBQTJEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBTSx3REFBd0Q7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQU0scUVBQXFFO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFNLHdHQUF3RyxvQ0FBb0M7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0dBQStHO0FBQy9IO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBTSxxRkFBcUYsNEJBQTRCO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBTSxxRkFBcUYsNEJBQTRCO0FBQy9ILFFBQVEsdURBQU0sd0dBQXdHLDRCQUE0QjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxwcm92aWRlcnNcXHByb3ZpZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vaW1wb3J0IHsgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xyXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGdldE51bWJlciwgaGV4bGlmeSwgaXNCeXRlc0xpa2UsIHJlc29sdmVQcm9wZXJ0aWVzLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBpc0Vycm9yLCBtYWtlRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xyXG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5mdW5jdGlvbiBnZXRWYWx1ZSh2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiB0b0pzb24odmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcclxufVxyXG4vLyBAVE9ETz8gPFQgZXh0ZW5kcyBGZWVEYXRhID0geyB9PiBpbXBsZW1lbnRzIFJlcXVpcmVkPFQ+XHJcbi8qKlxyXG4gKiAgQSAqKkZlZURhdGEqKiB3cmFwcyBhbGwgdGhlIGZlZS1yZWxhdGVkIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGhcclxuICogIHRoZSBuZXR3b3JrLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEZlZURhdGEge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGdhcyBwcmljZSBmb3IgbGVnYWN5IG5ldHdvcmtzLlxyXG4gICAgICovXHJcbiAgICBnYXNQcmljZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBtYXhpbXVtIGZlZSB0byBwYXkgcGVyIGdhcy5cclxuICAgICAqXHJcbiAgICAgKiAgVGhlIGJhc2UgZmVlIHBlciBnYXMgaXMgZGVmaW5lZCBieSB0aGUgbmV0d29yayBhbmQgYmFzZWQgb25cclxuICAgICAqICBjb25nZXN0aW9uLCBpbmNyZWFzaW5nIHRoZSBjb3N0IGR1cmluZyB0aW1lcyBvZiBoZWF2eSBsb2FkXHJcbiAgICAgKiAgYW5kIGxvd2VyaW5nIHdoZW4gbGVzcyBidXN5LlxyXG4gICAgICpcclxuICAgICAqICBUaGUgYWN0dWFsIGZlZSBwZXIgZ2FzIHdpbGwgYmUgdGhlIGJhc2UgZmVlIGZvciB0aGUgYmxvY2tcclxuICAgICAqICBhbmQgdGhlIHByaW9yaXR5IGZlZSwgdXAgdG8gdGhlIG1heCBmZWUgcGVyIGdhcy5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyB3aWxsIGJlIGBgbnVsbGBgIG9uIGxlZ2FjeSBuZXR3b3JrcyAoaS5lLiBbcHJlLUVJUC0xNTU5XShsaW5rLWVpcC0xNTU5KSlcclxuICAgICAqL1xyXG4gICAgbWF4RmVlUGVyR2FzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGFkZGl0aW9uYWwgYW1vdXQgdG8gcGF5IHBlciBnYXMgdG8gZW5jb3VyYWdlIGEgdmFsaWRhdG9yXHJcbiAgICAgKiAgdG8gaW5jbHVkZSB0aGUgdHJhbnNhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogIFRoZSBwdXJwb3NlIG9mIHRoaXMgaXMgdG8gY29tcGVuc2F0ZSB0aGUgdmFsaWRhdG9yIGZvciB0aGVcclxuICAgICAqICBhZGp1c3RlZCByaXNrIGZvciBpbmNsdWRpbmcgYSBnaXZlbiB0cmFuc2FjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyB3aWxsIGJlIGBgbnVsbGBgIG9uIGxlZ2FjeSBuZXR3b3JrcyAoaS5lLiBbcHJlLUVJUC0xNTU5XShsaW5rLWVpcC0xNTU5KSlcclxuICAgICAqL1xyXG4gICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM7XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgbmV3IEZlZURhdGEgZm9yICUlZ2FzUHJpY2UlJSwgJSVtYXhGZWVQZXJHYXMlJSBhbmRcclxuICAgICAqICAlJW1heFByaW9yaXR5RmVlUGVyR2FzJSUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGdhc1ByaWNlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzKSB7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XHJcbiAgICAgICAgICAgIGdhc1ByaWNlOiBnZXRWYWx1ZShnYXNQcmljZSksXHJcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogZ2V0VmFsdWUobWF4RmVlUGVyR2FzKSxcclxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGdldFZhbHVlKG1heFByaW9yaXR5RmVlUGVyR2FzKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tZnJpZW5kbHkgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCB7IGdhc1ByaWNlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzIH0gPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIF90eXBlOiBcIkZlZURhdGFcIixcclxuICAgICAgICAgICAgZ2FzUHJpY2U6IHRvSnNvbihnYXNQcmljZSksXHJcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogdG9Kc29uKG1heEZlZVBlckdhcyksXHJcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0b0pzb24obWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuO1xyXG4vKipcclxuICogIFJldHVybnMgYSBjb3B5IG9mICUlcmVxJSUgd2l0aCBhbGwgcHJvcGVydGllcyBjb2VyY2VkIHRvIHRoZWlyIHN0cmljdFxyXG4gKiAgdHlwZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29weVJlcXVlc3QocmVxKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuICAgIC8vIFRoZXNlIGNvdWxkIGJlIGFkZHJlc3NlcywgRU5TIG5hbWVzIG9yIEFkZHJlc3NhYmxlc1xyXG4gICAgaWYgKHJlcS50bykge1xyXG4gICAgICAgIHJlc3VsdC50byA9IHJlcS50bztcclxuICAgIH1cclxuICAgIGlmIChyZXEuZnJvbSkge1xyXG4gICAgICAgIHJlc3VsdC5mcm9tID0gcmVxLmZyb207XHJcbiAgICB9XHJcbiAgICBpZiAocmVxLmRhdGEpIHtcclxuICAgICAgICByZXN1bHQuZGF0YSA9IGhleGxpZnkocmVxLmRhdGEpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYmlnSW50S2V5cyA9IFwiY2hhaW5JZCxnYXNMaW1pdCxnYXNQcmljZSxtYXhGZWVQZXJCbG9iR2FzLG1heEZlZVBlckdhcyxtYXhQcmlvcml0eUZlZVBlckdhcyx2YWx1ZVwiLnNwbGl0KC8sLyk7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBiaWdJbnRLZXlzKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIHJlcSkgfHwgcmVxW2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0W2tleV0gPSBnZXRCaWdJbnQocmVxW2tleV0sIGByZXF1ZXN0LiR7a2V5fWApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbnVtYmVyS2V5cyA9IFwidHlwZSxub25jZVwiLnNwbGl0KC8sLyk7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBudW1iZXJLZXlzKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIHJlcSkgfHwgcmVxW2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0W2tleV0gPSBnZXROdW1iZXIocmVxW2tleV0sIGByZXF1ZXN0LiR7a2V5fWApO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlcS5hY2Nlc3NMaXN0KSB7XHJcbiAgICAgICAgcmVzdWx0LmFjY2Vzc0xpc3QgPSBhY2Nlc3NMaXN0aWZ5KHJlcS5hY2Nlc3NMaXN0KTtcclxuICAgIH1cclxuICAgIGlmIChyZXEuYXV0aG9yaXphdGlvbkxpc3QpIHtcclxuICAgICAgICByZXN1bHQuYXV0aG9yaXphdGlvbkxpc3QgPSByZXEuYXV0aG9yaXphdGlvbkxpc3Quc2xpY2UoKTtcclxuICAgIH1cclxuICAgIGlmIChcImJsb2NrVGFnXCIgaW4gcmVxKSB7XHJcbiAgICAgICAgcmVzdWx0LmJsb2NrVGFnID0gcmVxLmJsb2NrVGFnO1xyXG4gICAgfVxyXG4gICAgaWYgKFwiZW5hYmxlQ2NpcFJlYWRcIiBpbiByZXEpIHtcclxuICAgICAgICByZXN1bHQuZW5hYmxlQ2NpcFJlYWQgPSAhIXJlcS5lbmFibGVDY2lwUmVhZDtcclxuICAgIH1cclxuICAgIGlmIChcImN1c3RvbURhdGFcIiBpbiByZXEpIHtcclxuICAgICAgICByZXN1bHQuY3VzdG9tRGF0YSA9IHJlcS5jdXN0b21EYXRhO1xyXG4gICAgfVxyXG4gICAgaWYgKFwiYmxvYlZlcnNpb25lZEhhc2hlc1wiIGluIHJlcSAmJiByZXEuYmxvYlZlcnNpb25lZEhhc2hlcykge1xyXG4gICAgICAgIHJlc3VsdC5ibG9iVmVyc2lvbmVkSGFzaGVzID0gcmVxLmJsb2JWZXJzaW9uZWRIYXNoZXMuc2xpY2UoKTtcclxuICAgIH1cclxuICAgIGlmIChcImt6Z1wiIGluIHJlcSkge1xyXG4gICAgICAgIHJlc3VsdC5remcgPSByZXEua3pnO1xyXG4gICAgfVxyXG4gICAgaWYgKFwiYmxvYnNcIiBpbiByZXEgJiYgcmVxLmJsb2JzKSB7XHJcbiAgICAgICAgcmVzdWx0LmJsb2JzID0gcmVxLmJsb2JzLm1hcCgoYikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNCeXRlc0xpa2UoYikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBiKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqICBBICoqQmxvY2sqKiByZXByZXNlbnRzIHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCBhIGZ1bGwgYmxvY2sgb25cclxuICogIEV0aGVyZXVtLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJsb2NrIHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBwcm92aWRlciBjb25uZWN0ZWQgdG8gdGhlIGJsb2NrIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXHJcbiAgICAgKiAgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICovXHJcbiAgICBwcm92aWRlcjtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBibG9jayBudW1iZXIsIHNvbWV0aW1lcyBjYWxsZWQgdGhlIGJsb2NrIGhlaWdodC4gVGhpcyBpcyBhXHJcbiAgICAgKiAgc2VxdWVudGlhbCBudW1iZXIgdGhhdCBpcyBvbmUgaGlnaGVyIHRoYW4gdGhlIHBhcmVudCBibG9jay5cclxuICAgICAqL1xyXG4gICAgbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2guXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgaGFzaCBpbmNsdWRlcyBhbGwgcHJvcGVydGllcywgc28gY2FuIGJlIHNhZmVseSB1c2VkIHRvIGlkZW50aWZ5XHJcbiAgICAgKiAgYW4gZXhhY3Qgc2V0IG9mIGJsb2NrIHByb3BlcnRpZXMuXHJcbiAgICAgKi9cclxuICAgIGhhc2g7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdGltZXN0YW1wIGZvciB0aGlzIGJsb2NrLCB3aGljaCBpcyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2VcclxuICAgICAqICBlcG9jaCB0aGF0IHRoaXMgYmxvY2sgd2FzIGluY2x1ZGVkLlxyXG4gICAgICovXHJcbiAgICB0aW1lc3RhbXA7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYmxvY2sgaGFzaCBvZiB0aGUgcGFyZW50IGJsb2NrLlxyXG4gICAgICovXHJcbiAgICBwYXJlbnRIYXNoO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGhhc2ggdHJlZSByb290IG9mIHRoZSBwYXJlbnQgYmVhY29uIGJsb2NrIGZvciB0aGUgZ2l2ZW5cclxuICAgICAqICBleGVjdXRpb24gYmxvY2suIFNlZSBbW2xpbmstZWlwLTQ3ODhdXS5cclxuICAgICAqL1xyXG4gICAgcGFyZW50QmVhY29uQmxvY2tSb290O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG5vbmNlLlxyXG4gICAgICpcclxuICAgICAqICBPbiBsZWdhY3kgbmV0d29ya3MsIHRoaXMgaXMgdGhlIHJhbmRvbSBudW1iZXIgaW5zZXJ0ZWQgd2hpY2hcclxuICAgICAqICBwZXJtaXR0ZWQgdGhlIGRpZmZpY3VsdHkgdGFyZ2V0IHRvIGJlIHJlYWNoZWQuXHJcbiAgICAgKi9cclxuICAgIG5vbmNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGRpZmZpY3VsdHkgdGFyZ2V0LlxyXG4gICAgICpcclxuICAgICAqICBPbiBsZWdhY3kgbmV0d29ya3MsIHRoaXMgaXMgdGhlIHByb29mLW9mLXdvcmsgdGFyZ2V0IHJlcXVpcmVkXHJcbiAgICAgKiAgZm9yIGEgYmxvY2sgdG8gbWVldCB0aGUgcHJvdG9jb2wgcnVsZXMgdG8gYmUgaW5jbHVkZWQuXHJcbiAgICAgKlxyXG4gICAgICogIE9uIG1vZGVybiBuZXR3b3JrcywgdGhpcyBpcyBhIHJhbmRvbSBudW1iZXIgYXJyaXZlZCBhdCB1c2luZ1xyXG4gICAgICogIHJhbmRhby4gIEBUT0RPOiBGaW5kIGxpbmtzP1xyXG4gICAgICovXHJcbiAgICBkaWZmaWN1bHR5O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHRvdGFsIGdhcyBsaW1pdCBmb3IgdGhpcyBibG9jay5cclxuICAgICAqL1xyXG4gICAgZ2FzTGltaXQ7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdG90YWwgZ2FzIHVzZWQgaW4gdGhpcyBibG9jay5cclxuICAgICAqL1xyXG4gICAgZ2FzVXNlZDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSByb290IGhhc2ggZm9yIHRoZSBnbG9iYWwgc3RhdGUgYWZ0ZXIgYXBwbHlpbmcgY2hhbmdlc1xyXG4gICAgICogIGluIHRoaXMgYmxvY2suXHJcbiAgICAgKi9cclxuICAgIHN0YXRlUm9vdDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0cyB0cmllLlxyXG4gICAgICovXHJcbiAgICByZWNlaXB0c1Jvb3Q7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdG90YWwgYW1vdW50IG9mIGJsb2IgZ2FzIGNvbnN1bWVkIGJ5IHRoZSB0cmFuc2FjdGlvbnNcclxuICAgICAqICB3aXRoaW4gdGhlIGJsb2NrLiBTZWUgW1tsaW5rLWVpcC00ODQ0XV0uXHJcbiAgICAgKi9cclxuICAgIGJsb2JHYXNVc2VkO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHJ1bm5pbmcgdG90YWwgb2YgYmxvYiBnYXMgY29uc3VtZWQgaW4gZXhjZXNzIG9mIHRoZVxyXG4gICAgICogIHRhcmdldCwgcHJpb3IgdG8gdGhlIGJsb2NrLiBTZWUgW1tsaW5rLWVpcC00ODQ0XV0uXHJcbiAgICAgKi9cclxuICAgIGV4Y2Vzc0Jsb2JHYXM7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbWluZXIgY29pbmJhc2UgYWRkcmVzcywgd2loY2ggcmVjZWl2ZXMgYW55IHN1YnNpZGllcyBmb3JcclxuICAgICAqICBpbmNsdWRpbmcgdGhpcyBibG9jay5cclxuICAgICAqL1xyXG4gICAgbWluZXI7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbGF0ZXN0IFJBTkRBTyBtaXggb2YgdGhlIHBvc3QgYmVhY29uIHN0YXRlIG9mXHJcbiAgICAgKiAgdGhlIHByZXZpb3VzIGJsb2NrLlxyXG4gICAgICovXHJcbiAgICBwcmV2UmFuZGFvO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQW55IGV4dHJhIGRhdGEgdGhlIHZhbGlkYXRvciB3aXNoZWQgdG8gaW5jbHVkZS5cclxuICAgICAqL1xyXG4gICAgZXh0cmFEYXRhO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGJhc2UgZmVlIHBlciBnYXMgdGhhdCBhbGwgdHJhbnNhY3Rpb25zIGluIHRoaXMgYmxvY2sgd2VyZVxyXG4gICAgICogIGNoYXJnZWQuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgYWRqdXN0cyBhZnRlciBlYWNoIGJsb2NrLCBkZXBlbmRpbmcgb24gaG93IGNvbmdlc3RlZCB0aGUgbmV0d29ya1xyXG4gICAgICogIGlzLlxyXG4gICAgICovXHJcbiAgICBiYXNlRmVlUGVyR2FzO1xyXG4gICAgI3RyYW5zYWN0aW9ucztcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkJsb2NrKiogb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIG5lY2Vzc2FyeSBhcyB0aGUgdW5sZXNzIGltcGxlbWVudGluZyBhXHJcbiAgICAgKiAgbG93LWxldmVsIGxpYnJhcnkuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGJsb2NrLCBwcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMuI3RyYW5zYWN0aW9ucyA9IGJsb2NrLnRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHR4KSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvblJlc3BvbnNlKHR4LCBwcm92aWRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHR4O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xyXG4gICAgICAgICAgICBwcm92aWRlcixcclxuICAgICAgICAgICAgaGFzaDogZ2V0VmFsdWUoYmxvY2suaGFzaCksXHJcbiAgICAgICAgICAgIG51bWJlcjogYmxvY2subnVtYmVyLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGJsb2NrLnRpbWVzdGFtcCxcclxuICAgICAgICAgICAgcGFyZW50SGFzaDogYmxvY2sucGFyZW50SGFzaCxcclxuICAgICAgICAgICAgcGFyZW50QmVhY29uQmxvY2tSb290OiBibG9jay5wYXJlbnRCZWFjb25CbG9ja1Jvb3QsXHJcbiAgICAgICAgICAgIG5vbmNlOiBibG9jay5ub25jZSxcclxuICAgICAgICAgICAgZGlmZmljdWx0eTogYmxvY2suZGlmZmljdWx0eSxcclxuICAgICAgICAgICAgZ2FzTGltaXQ6IGJsb2NrLmdhc0xpbWl0LFxyXG4gICAgICAgICAgICBnYXNVc2VkOiBibG9jay5nYXNVc2VkLFxyXG4gICAgICAgICAgICBibG9iR2FzVXNlZDogYmxvY2suYmxvYkdhc1VzZWQsXHJcbiAgICAgICAgICAgIGV4Y2Vzc0Jsb2JHYXM6IGJsb2NrLmV4Y2Vzc0Jsb2JHYXMsXHJcbiAgICAgICAgICAgIG1pbmVyOiBibG9jay5taW5lcixcclxuICAgICAgICAgICAgcHJldlJhbmRhbzogZ2V0VmFsdWUoYmxvY2sucHJldlJhbmRhbyksXHJcbiAgICAgICAgICAgIGV4dHJhRGF0YTogYmxvY2suZXh0cmFEYXRhLFxyXG4gICAgICAgICAgICBiYXNlRmVlUGVyR2FzOiBnZXRWYWx1ZShibG9jay5iYXNlRmVlUGVyR2FzKSxcclxuICAgICAgICAgICAgc3RhdGVSb290OiBibG9jay5zdGF0ZVJvb3QsXHJcbiAgICAgICAgICAgIHJlY2VpcHRzUm9vdDogYmxvY2sucmVjZWlwdHNSb290LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgbGlzdCBvZiB0cmFuc2FjdGlvbiBoYXNoZXMsIGluIHRoZSBvcmRlclxyXG4gICAgICogIHRoZXkgd2VyZSBleGVjdXRlZCB3aXRoaW4gdGhlIGJsb2NrLlxyXG4gICAgICovXHJcbiAgICBnZXQgdHJhbnNhY3Rpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiN0cmFuc2FjdGlvbnMubWFwKCh0eCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0eDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHguaGFzaDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIGNvbXBsZXRlIHRyYW5zYWN0aW9ucywgaW4gdGhlIG9yZGVyIHRoZXlcclxuICAgICAqICB3ZXJlIGV4ZWN1dGVkIHdpdGhpbiB0aGUgYmxvY2suXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgaXMgb25seSBhdmFpbGFibGUgZm9yIGJsb2NrcyB3aGljaCBwcmVmZXRjaGVkXHJcbiAgICAgKiAgdHJhbnNhY3Rpb25zLCBieSBwYXNzaW5nIGBgdHJ1ZWBgIHRvICUlcHJlZmV0Y2hUeHMlJVxyXG4gICAgICogIGludG8gW1tQcm92aWRlci1nZXRCbG9ja11dLlxyXG4gICAgICovXHJcbiAgICBnZXQgcHJlZmV0Y2hlZFRyYW5zYWN0aW9ucygpIHtcclxuICAgICAgICBjb25zdCB0eHMgPSB0aGlzLiN0cmFuc2FjdGlvbnMuc2xpY2UoKTtcclxuICAgICAgICAvLyBEb2Vzbid0IG1hdHRlci4uLlxyXG4gICAgICAgIGlmICh0eHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHByZWZldGNoZWQgdGhlIHRyYW5zYWN0aW9uc1xyXG4gICAgICAgIGFzc2VydCh0eXBlb2YgKHR4c1swXSkgPT09IFwib2JqZWN0XCIsIFwidHJhbnNhY3Rpb25zIHdlcmUgbm90IHByZWZldGNoZWQgd2l0aCBibG9jayByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRyYW5zYWN0aW9uUmVzcG9uc2VzKClcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0eHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1mcmllbmRseSB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGNvbnN0IHsgYmFzZUZlZVBlckdhcywgZGlmZmljdWx0eSwgZXh0cmFEYXRhLCBnYXNMaW1pdCwgZ2FzVXNlZCwgaGFzaCwgbWluZXIsIHByZXZSYW5kYW8sIG5vbmNlLCBudW1iZXIsIHBhcmVudEhhc2gsIHBhcmVudEJlYWNvbkJsb2NrUm9vdCwgc3RhdGVSb290LCByZWNlaXB0c1Jvb3QsIHRpbWVzdGFtcCwgdHJhbnNhY3Rpb25zIH0gPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIF90eXBlOiBcIkJsb2NrXCIsXHJcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IHRvSnNvbihiYXNlRmVlUGVyR2FzKSxcclxuICAgICAgICAgICAgZGlmZmljdWx0eTogdG9Kc29uKGRpZmZpY3VsdHkpLFxyXG4gICAgICAgICAgICBleHRyYURhdGEsXHJcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0b0pzb24oZ2FzTGltaXQpLFxyXG4gICAgICAgICAgICBnYXNVc2VkOiB0b0pzb24oZ2FzVXNlZCksXHJcbiAgICAgICAgICAgIGJsb2JHYXNVc2VkOiB0b0pzb24odGhpcy5ibG9iR2FzVXNlZCksXHJcbiAgICAgICAgICAgIGV4Y2Vzc0Jsb2JHYXM6IHRvSnNvbih0aGlzLmV4Y2Vzc0Jsb2JHYXMpLFxyXG4gICAgICAgICAgICBoYXNoLCBtaW5lciwgcHJldlJhbmRhbywgbm9uY2UsIG51bWJlciwgcGFyZW50SGFzaCwgdGltZXN0YW1wLFxyXG4gICAgICAgICAgICBwYXJlbnRCZWFjb25CbG9ja1Jvb3QsIHN0YXRlUm9vdCwgcmVjZWlwdHNSb290LFxyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbnMsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgY29uc3QgdHhzID0gdGhpcy50cmFuc2FjdGlvbnM7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHhzW2luZGV4KytdLCBkb25lOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG51bWJlciBvZiB0cmFuc2FjdGlvbnMgaW4gdGhpcyBibG9jay5cclxuICAgICAqL1xyXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI3RyYW5zYWN0aW9ucy5sZW5ndGg7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBbW2xpbmstanMtZGF0ZV1dIHRoaXMgYmxvY2sgd2FzIGluY2x1ZGVkIGF0LlxyXG4gICAgICovXHJcbiAgICBnZXQgZGF0ZSgpIHtcclxuICAgICAgICBpZiAodGhpcy50aW1lc3RhbXAgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudGltZXN0YW1wICogMTAwMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBHZXQgdGhlIHRyYW5zYWN0aW9uIGF0ICUlaW5kZXhlJSUgd2l0aGluIHRoaXMgYmxvY2suXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKGluZGV4T3JIYXNoKSB7XHJcbiAgICAgICAgLy8gRmluZCB0aGUgaW50ZXJuYWwgdmFsdWUgYnkgaXRzIGluZGV4IG9yIGhhc2hcclxuICAgICAgICBsZXQgdHggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoaW5kZXhPckhhc2gpID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIHR4ID0gdGhpcy4jdHJhbnNhY3Rpb25zW2luZGV4T3JIYXNoXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBpbmRleE9ySGFzaC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGhpcy4jdHJhbnNhY3Rpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSBoYXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0eCA9IHY7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodi5oYXNoICE9PSBoYXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0eCA9IHY7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gc3VjaCB0eFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiAodHgpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0eCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIElmIGEgKipCbG9jayoqIHdhcyBmZXRjaGVkIHdpdGggYSByZXF1ZXN0IHRvIGluY2x1ZGUgdGhlIHRyYW5zYWN0aW9uc1xyXG4gICAgICogIHRoaXMgd2lsbCBhbGxvdyBzeW5jaHJvbm91cyBhY2Nlc3MgdG8gdGhvc2UgdHJhbnNhY3Rpb25zLlxyXG4gICAgICpcclxuICAgICAqICBJZiB0aGUgdHJhbnNhY3Rpb25zIHdlcmUgbm90IHByZWZldGNoZWQsIHRoaXMgd2lsbCB0aHJvdy5cclxuICAgICAqL1xyXG4gICAgZ2V0UHJlZmV0Y2hlZFRyYW5zYWN0aW9uKGluZGV4T3JIYXNoKSB7XHJcbiAgICAgICAgY29uc3QgdHhzID0gdGhpcy5wcmVmZXRjaGVkVHJhbnNhY3Rpb25zO1xyXG4gICAgICAgIGlmICh0eXBlb2YgKGluZGV4T3JIYXNoKSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHhzW2luZGV4T3JIYXNoXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5kZXhPckhhc2ggPSBpbmRleE9ySGFzaC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgdHggb2YgdHhzKSB7XHJcbiAgICAgICAgICAgIGlmICh0eC5oYXNoID09PSBpbmRleE9ySGFzaCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcIm5vIG1hdGNoaW5nIHRyYW5zYWN0aW9uXCIsIFwiaW5kZXhPckhhc2hcIiwgaW5kZXhPckhhc2gpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgYmxvY2sgYmVlbiBtaW5lZC4gVGhpcyBwcm92aWRlcyBhIHR5cGUgZ3VhcmRcclxuICAgICAqICBmb3IgYWxsIHByb3BlcnRpZXMgb24gYSBbW01pbmVkQmxvY2tdXS5cclxuICAgICAqL1xyXG4gICAgaXNNaW5lZCgpIHsgcmV0dXJuICEhdGhpcy5oYXNoOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyBibG9jayBpcyBhbiBbW2xpbmstZWlwLTI5MzBdXSBibG9jay5cclxuICAgICAqL1xyXG4gICAgaXNMb25kb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5iYXNlRmVlUGVyR2FzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIG9ycGhhbmVkRXZlbnQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzTWluZWQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjcmVhdGVPcnBoYW5lZEJsb2NrRmlsdGVyKHRoaXMpO1xyXG4gICAgfVxyXG59XHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gTG9nXHJcbi8qKlxyXG4gKiAgQSAqKkxvZyoqIGluIEV0aGVyZXVtIHJlcHJlc2VudHMgYW4gZXZlbnQgdGhhdCBoYXMgYmVlbiBpbmNsdWRlZCBpbiBhXHJcbiAqICB0cmFuc2FjdGlvbiB1c2luZyB0aGUgYGBMT0cqYGAgb3Bjb2Rlcywgd2hpY2ggYXJlIG1vc3QgY29tbW9ubHkgdXNlZCBieVxyXG4gKiAgU29saWRpdHkncyBlbWl0IGZvciBhbm5vdW5jaW5nIGV2ZW50cy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBMb2cge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHByb3ZpZGVyIGNvbm5lY3RlZCB0byB0aGUgbG9nIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXHJcbiAgICAgKiAgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICovXHJcbiAgICBwcm92aWRlcjtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiB0aGlzIGxvZyBvY2N1cnJlZCBpbi4gVXNlIHRoZVxyXG4gICAgICogIFtbTG9nLWdldFRyYW5zYWN0aW9uXV0gdG8gZ2V0IHRoZSBbW1RyYW5zYWN0aW9uUmVzcG9uc2VdXS5cclxuICAgICAqL1xyXG4gICAgdHJhbnNhY3Rpb25IYXNoO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2ggb2YgdGhlIGJsb2NrIHRoaXMgbG9nIG9jY3VycmVkIGluLiBVc2UgdGhlXHJcbiAgICAgKiAgW1tMb2ctZ2V0QmxvY2tdXSB0byBnZXQgdGhlIFtbQmxvY2tdXS5cclxuICAgICAqL1xyXG4gICAgYmxvY2tIYXNoO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciBvZiB0aGUgYmxvY2sgdGhpcyBsb2cgb2NjdXJyZWQgaW4uIEl0IGlzIHByZWZlcnJlZFxyXG4gICAgICogIHRvIHVzZSB0aGUgW1tCbG9jay1oYXNoXV0gd2hlbiBmZXRjaGluZyB0aGUgcmVsYXRlZCBbW0Jsb2NrXV0sXHJcbiAgICAgKiAgc2luY2UgaW4gdGhlIGNhc2Ugb2YgYW4gb3JwaGFuZWQgYmxvY2ssIHRoZSBibG9jayBhdCB0aGF0IGhlaWdodCBtYXlcclxuICAgICAqICBoYXZlIGNoYW5nZWQuXHJcbiAgICAgKi9cclxuICAgIGJsb2NrTnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgSWYgdGhlICoqTG9nKiogcmVwcmVzZW50cyBhIGJsb2NrIHRoYXQgd2FzIHJlbW92ZWQgZHVlIHRvIGFuIG9ycGhhbmVkXHJcbiAgICAgKiAgYmxvY2ssIHRoaXMgd2lsbCBiZSB0cnVlLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGNhbiBvbmx5IGhhcHBlbiB3aXRoaW4gYW4gb3JwaGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVkO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IHRoYXQgZW1pdHRlZCB0aGlzIGxvZy5cclxuICAgICAqL1xyXG4gICAgYWRkcmVzcztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoaXMgbG9nIHdoZW4gaXQgd2FzIGVtaXR0ZWQuXHJcbiAgICAgKi9cclxuICAgIGRhdGE7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgaW5kZXhlZCB0b3BpY3MgaW5jbHVkZWQgaW4gdGhpcyBsb2cgd2hlbiBpdCB3YXMgZW1pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiAgQWxsIHRvcGljcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGJsb29tIGZpbHRlcnMsIHNvIHRoZXkgY2FuIGJlXHJcbiAgICAgKiAgZWZmaWNpZW50bHkgZmlsdGVyZWQgdXNpbmcgdGhlIFtbUHJvdmlkZXItZ2V0TG9nc11dIG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgdG9waWNzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGluZGV4IHdpdGhpbiB0aGUgYmxvY2sgdGhpcyBsb2cgb2NjdXJyZWQgYXQuIFRoaXMgaXMgZ2VuZXJhbGx5XHJcbiAgICAgKiAgbm90IHVzZWZ1bCB0byBkZXZlbG9wZXJzLCBidXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUgdmFyaW91cyByb290c1xyXG4gICAgICogIHRvIHByb29mIGluY2x1c2lvbiB3aXRoaW4gYSBibG9jay5cclxuICAgICAqL1xyXG4gICAgaW5kZXg7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgaW5kZXggd2l0aGluIHRoZSB0cmFuc2FjdGlvbiBvZiB0aGlzIGxvZy5cclxuICAgICAqL1xyXG4gICAgdHJhbnNhY3Rpb25JbmRleDtcclxuICAgIC8qKlxyXG4gICAgICogIEBfaWdub3JlOlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihsb2csIHByb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xyXG4gICAgICAgIGNvbnN0IHRvcGljcyA9IE9iamVjdC5mcmVlemUobG9nLnRvcGljcy5zbGljZSgpKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBsb2cudHJhbnNhY3Rpb25IYXNoLFxyXG4gICAgICAgICAgICBibG9ja0hhc2g6IGxvZy5ibG9ja0hhc2gsXHJcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBsb2cuYmxvY2tOdW1iZXIsXHJcbiAgICAgICAgICAgIHJlbW92ZWQ6IGxvZy5yZW1vdmVkLFxyXG4gICAgICAgICAgICBhZGRyZXNzOiBsb2cuYWRkcmVzcyxcclxuICAgICAgICAgICAgZGF0YTogbG9nLmRhdGEsXHJcbiAgICAgICAgICAgIHRvcGljcyxcclxuICAgICAgICAgICAgaW5kZXg6IGxvZy5pbmRleCxcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbG9nLnRyYW5zYWN0aW9uSW5kZXgsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGNvbnN0IHsgYWRkcmVzcywgYmxvY2tIYXNoLCBibG9ja051bWJlciwgZGF0YSwgaW5kZXgsIHJlbW92ZWQsIHRvcGljcywgdHJhbnNhY3Rpb25IYXNoLCB0cmFuc2FjdGlvbkluZGV4IH0gPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIF90eXBlOiBcImxvZ1wiLFxyXG4gICAgICAgICAgICBhZGRyZXNzLCBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBkYXRhLCBpbmRleCxcclxuICAgICAgICAgICAgcmVtb3ZlZCwgdG9waWNzLCB0cmFuc2FjdGlvbkhhc2gsIHRyYW5zYWN0aW9uSW5kZXhcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgYmxvY2sgdGhhdCB0aGlzIGxvZyBvY2N1cnJlZCBpbi5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XHJcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKHRoaXMuYmxvY2tIYXNoKTtcclxuICAgICAgICBhc3NlcnQoISFibG9jaywgXCJmYWlsZWQgdG8gZmluZCB0cmFuc2FjdGlvblwiLCBcIlVOS05PV05fRVJST1JcIiwge30pO1xyXG4gICAgICAgIHJldHVybiBibG9jaztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uIHRoYXQgdGhpcyBsb2cgb2NjdXJyZWQgaW4uXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xyXG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLnRyYW5zYWN0aW9uSGFzaCk7XHJcbiAgICAgICAgYXNzZXJ0KCEhdHgsIFwiZmFpbGVkIHRvIGZpbmQgdHJhbnNhY3Rpb25cIiwgXCJVTktOT1dOX0VSUk9SXCIsIHt9KTtcclxuICAgICAgICByZXR1cm4gdHg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0IGZvdCB0aGUgdHJhbnNhY3Rpb24gdGhhdCB0aGlzXHJcbiAgICAgKiAgbG9nIG9jY3VycmVkIGluLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoKSB7XHJcbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMudHJhbnNhY3Rpb25IYXNoKTtcclxuICAgICAgICBhc3NlcnQoISFyZWNlaXB0LCBcImZhaWxlZCB0byBmaW5kIHRyYW5zYWN0aW9uIHJlY2VpcHRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHt9KTtcclxuICAgICAgICByZXR1cm4gcmVjZWlwdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEBfaWdub3JlOlxyXG4gICAgICovXHJcbiAgICByZW1vdmVkRXZlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRMb2dGaWx0ZXIodGhpcyk7XHJcbiAgICB9XHJcbn1cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyBUcmFuc2FjdGlvbiBSZWNlaXB0XHJcbi8qXHJcbmV4cG9ydCBpbnRlcmZhY2UgTGVnYWN5VHJhbnNhY3Rpb25SZWNlaXB0IHtcclxuICAgIGJ5emFudGl1bTogZmFsc2U7XHJcbiAgICBzdGF0dXM6IG51bGw7XHJcbiAgICByb290OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQnl6YW50aXVtVHJhbnNhY3Rpb25SZWNlaXB0IHtcclxuICAgIGJ5emFudGl1bTogdHJ1ZTtcclxuICAgIHN0YXR1czogbnVtYmVyO1xyXG4gICAgcm9vdDogbnVsbDtcclxufVxyXG4qL1xyXG4vKipcclxuICogIEEgKipUcmFuc2FjdGlvblJlY2VpcHQqKiBpbmNsdWRlcyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IGFcclxuICogIHRyYW5zYWN0aW9uIHRoYXQgaXMgb25seSBhdmFpbGFibGUgYWZ0ZXIgaXQgaGFzIGJlZW4gbWluZWQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25SZWNlaXB0IHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBwcm92aWRlciBjb25uZWN0ZWQgdG8gdGhlIGxvZyB1c2VkIHRvIGZldGNoIGFkZGl0aW9uYWwgZGV0YWlsc1xyXG4gICAgICogIGlmIG5lY2Vzc2FyeS5cclxuICAgICAqL1xyXG4gICAgcHJvdmlkZXI7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYWRkcmVzcyB0aGUgdHJhbnNhY3Rpb24gd2FzIHNlbnQgdG8uXHJcbiAgICAgKi9cclxuICAgIHRvO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHNlbmRlciBvZiB0aGUgdHJhbnNhY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZyb207XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QgaWYgdGhlIHRyYW5zYWN0aW9uIHdhcyBkaXJlY3RseVxyXG4gICAgICogIHJlc3BvbnNpYmxlIGZvciBkZXBsb3lpbmcgb25lLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIG5vbi1udWxsICoqb25seSoqIGlmIHRoZSBgYHRvYGAgaXMgZW1wdHkgYW5kIHRoZSBgYGRhdGFgYFxyXG4gICAgICogIHdhcyBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQgYXMgaW5pdGNvZGUuXHJcbiAgICAgKi9cclxuICAgIGNvbnRyYWN0QWRkcmVzcztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoLlxyXG4gICAgICovXHJcbiAgICBoYXNoO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGluZGV4IG9mIHRoaXMgdHJhbnNhY3Rpb24gd2l0aGluIHRoZSBibG9jayB0cmFuc2FjdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIGluZGV4O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2ggb2YgdGhlIFtbQmxvY2tdXSB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cclxuICAgICAqL1xyXG4gICAgYmxvY2tIYXNoO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciBvZiB0aGUgW1tCbG9ja11dIHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxyXG4gICAgICovXHJcbiAgICBibG9ja051bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBibG9vbSBmaWx0ZXIgYnl0ZXMgdGhhdCByZXByZXNlbnQgYWxsIGxvZ3MgdGhhdCBvY2N1cnJlZCB3aXRoaW5cclxuICAgICAqICB0aGlzIHRyYW5zYWN0aW9uLiBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZnVsIGZvciBtb3N0IGRldmVsb3BlcnMsXHJcbiAgICAgKiAgYnV0IGNhbiBiZSB1c2VkIHRvIHZhbGlkYXRlIHRoZSBpbmNsdWRlZCBsb2dzLlxyXG4gICAgICovXHJcbiAgICBsb2dzQmxvb207XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYWN0dWFsIGFtb3VudCBvZiBnYXMgdXNlZCBieSB0aGlzIHRyYW5zYWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqICBXaGVuIGNyZWF0aW5nIGEgdHJhbnNhY3Rpb24sIHRoZSBhbW91bnQgb2YgZ2FzIHRoYXQgd2lsbCBiZSB1c2VkIGNhblxyXG4gICAgICogIG9ubHkgYmUgYXBwcm94aW1hdGVkLCBidXQgdGhlIHNlbmRlciBtdXN0IHBheSB0aGUgZ2FzIGZlZSBmb3IgdGhlXHJcbiAgICAgKiAgZW50aXJlIGdhcyBsaW1pdC4gQWZ0ZXIgdGhlIHRyYW5zYWN0aW9uLCB0aGUgZGlmZmVyZW5jZSBpcyByZWZ1bmRlZC5cclxuICAgICAqL1xyXG4gICAgZ2FzVXNlZDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBnYXMgdXNlZCBmb3IgQkxPYnMuIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cclxuICAgICAqL1xyXG4gICAgYmxvYkdhc1VzZWQ7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYW1vdW50IG9mIGdhcyB1c2VkIGJ5IGFsbCB0cmFuc2FjdGlvbnMgd2l0aGluIHRoZSBibG9jayBmb3IgdGhpc1xyXG4gICAgICogIGFuZCBhbGwgdHJhbnNhY3Rpb25zIHdpdGggYSBsb3dlciBgYGluZGV4YGAuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwgZm9yIGRldmVsb3BlcnMgYnV0IGNhbiBiZSB1c2VkIHRvXHJcbiAgICAgKiAgdmFsaWRhdGUgY2VydGFpbiBhc3BlY3RzIG9mIGV4ZWN1dGlvbi5cclxuICAgICAqL1xyXG4gICAgY3VtdWxhdGl2ZUdhc1VzZWQ7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYWN0dWFsIGdhcyBwcmljZSB1c2VkIGR1cmluZyBleGVjdXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogIER1ZSB0byB0aGUgY29tcGxleGl0eSBvZiBbW2xpbmstZWlwLTE1NTldXSB0aGlzIHZhbHVlIGNhbiBvbmx5XHJcbiAgICAgKiAgYmUgY2FsdWNsYXRlZCBhZnRlciB0aGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQsIHNuY2UgdGhlIGJhc2VcclxuICAgICAqICBmZWUgaXMgcHJvdG9jb2wtZW5mb3JjZWQuXHJcbiAgICAgKi9cclxuICAgIGdhc1ByaWNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHByaWNlIHBhaWQgcGVyIEJMT0IgaW4gZ2FzLiBTZWUgW1tsaW5rLWVpcC00ODQ0XV0uXHJcbiAgICAgKi9cclxuICAgIGJsb2JHYXNQcmljZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTI3MThdXSB0cmFuc2FjdGlvbiB0eXBlLlxyXG4gICAgICovXHJcbiAgICB0eXBlO1xyXG4gICAgLy9yZWFkb25seSBieXphbnRpdW0hOiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHN0YXR1cyBvZiB0aGlzIHRyYW5zYWN0aW9uLCBpbmRpY2F0aW5nIHN1Y2Nlc3MgKGkuZS4gYGAxYGApIG9yXHJcbiAgICAgKiAgYSByZXZlcnQgKGkuZS4gYGAwYGApLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIGF2YWlsYWJsZSBpbiBwb3N0LWJ5emFudGl1bSBibG9ja3MsIGJ1dCBzb21lIGJhY2tlbmRzIG1heVxyXG4gICAgICogIGJhY2tmaWxsIHRoaXMgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIHN0YXR1cztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSByb290IGhhc2ggb2YgdGhpcyB0cmFuc2FjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBpcyBubyBwcmVzZW50IGFuZCB3YXMgb25seSBpbmNsdWRlZCBpbiBwcmUtYnl6YW50aXVtIGJsb2NrcywgYnV0XHJcbiAgICAgKiAgY291bGQgYmUgdXNlZCB0byB2YWxpZGF0ZSBjZXJ0YWluIHBhcnRzIG9mIHRoZSByZWNlaXB0LlxyXG4gICAgICovXHJcbiAgICByb290O1xyXG4gICAgI2xvZ3M7XHJcbiAgICAvKipcclxuICAgICAqICBAX2lnbm9yZTpcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodHgsIHByb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy4jbG9ncyA9IE9iamVjdC5mcmVlemUodHgubG9ncy5tYXAoKGxvZykgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZyhsb2csIHByb3ZpZGVyKTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgbGV0IGdhc1ByaWNlID0gQk5fMDtcclxuICAgICAgICBpZiAodHguZWZmZWN0aXZlR2FzUHJpY2UgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBnYXNQcmljZSA9IHR4LmVmZmVjdGl2ZUdhc1ByaWNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eC5nYXNQcmljZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGdhc1ByaWNlID0gdHguZ2FzUHJpY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xyXG4gICAgICAgICAgICBwcm92aWRlcixcclxuICAgICAgICAgICAgdG86IHR4LnRvLFxyXG4gICAgICAgICAgICBmcm9tOiB0eC5mcm9tLFxyXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IHR4LmNvbnRyYWN0QWRkcmVzcyxcclxuICAgICAgICAgICAgaGFzaDogdHguaGFzaCxcclxuICAgICAgICAgICAgaW5kZXg6IHR4LmluZGV4LFxyXG4gICAgICAgICAgICBibG9ja0hhc2g6IHR4LmJsb2NrSGFzaCxcclxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHR4LmJsb2NrTnVtYmVyLFxyXG4gICAgICAgICAgICBsb2dzQmxvb206IHR4LmxvZ3NCbG9vbSxcclxuICAgICAgICAgICAgZ2FzVXNlZDogdHguZ2FzVXNlZCxcclxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IHR4LmN1bXVsYXRpdmVHYXNVc2VkLFxyXG4gICAgICAgICAgICBibG9iR2FzVXNlZDogdHguYmxvYkdhc1VzZWQsXHJcbiAgICAgICAgICAgIGdhc1ByaWNlLFxyXG4gICAgICAgICAgICBibG9iR2FzUHJpY2U6IHR4LmJsb2JHYXNQcmljZSxcclxuICAgICAgICAgICAgdHlwZTogdHgudHlwZSxcclxuICAgICAgICAgICAgLy9ieXphbnRpdW06IHR4LmJ5emFudGl1bSxcclxuICAgICAgICAgICAgc3RhdHVzOiB0eC5zdGF0dXMsXHJcbiAgICAgICAgICAgIHJvb3Q6IHR4LnJvb3RcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBsb2dzIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXQgbG9ncygpIHsgcmV0dXJuIHRoaXMuI2xvZ3M7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgcmVwcmVzZW50YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCB7IHRvLCBmcm9tLCBjb250cmFjdEFkZHJlc3MsIGhhc2gsIGluZGV4LCBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBsb2dzQmxvb20sIGxvZ3MsIC8vYnl6YW50aXVtLCBcclxuICAgICAgICBzdGF0dXMsIHJvb3QgfSA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgX3R5cGU6IFwiVHJhbnNhY3Rpb25SZWNlaXB0XCIsXHJcbiAgICAgICAgICAgIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsXHJcbiAgICAgICAgICAgIC8vYnl6YW50aXVtLCBcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzLFxyXG4gICAgICAgICAgICBjdW11bGF0aXZlR2FzVXNlZDogdG9Kc29uKHRoaXMuY3VtdWxhdGl2ZUdhc1VzZWQpLFxyXG4gICAgICAgICAgICBmcm9tLFxyXG4gICAgICAgICAgICBnYXNQcmljZTogdG9Kc29uKHRoaXMuZ2FzUHJpY2UpLFxyXG4gICAgICAgICAgICBibG9iR2FzVXNlZDogdG9Kc29uKHRoaXMuYmxvYkdhc1VzZWQpLFxyXG4gICAgICAgICAgICBibG9iR2FzUHJpY2U6IHRvSnNvbih0aGlzLmJsb2JHYXNQcmljZSksXHJcbiAgICAgICAgICAgIGdhc1VzZWQ6IHRvSnNvbih0aGlzLmdhc1VzZWQpLFxyXG4gICAgICAgICAgICBoYXNoLCBpbmRleCwgbG9ncywgbG9nc0Jsb29tLCByb290LCBzdGF0dXMsIHRvXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEBfaWdub3JlOlxyXG4gICAgICovXHJcbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5sb2dzLmxlbmd0aDsgfVxyXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB0aGlzLmxvZ3NbaW5kZXgrK10sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHRvdGFsIGZlZSBmb3IgdGhpcyB0cmFuc2FjdGlvbiwgaW4gd2VpLlxyXG4gICAgICovXHJcbiAgICBnZXQgZmVlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdhc1VzZWQgKiB0aGlzLmdhc1ByaWNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGJsb2NrIHRoaXMgdHJhbnNhY3Rpb24gb2NjdXJyZWQgaW4uXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldEJsb2NrKCkge1xyXG4gICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9jayh0aGlzLmJsb2NrSGFzaCk7XHJcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJsb2NrO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRoaXMgdHJhbnNhY3Rpb24gb2NjdXJyZWQgaW4uXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xyXG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xyXG4gICAgICAgIGlmICh0eCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0eDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGV4ZWN1dGlvbiBvZiB0aGlzIHRyYW5zYWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqICBTdXBwb3J0IGZvciB0aGlzIGZlYXR1cmUgaXMgbGltaXRlZCwgYXMgaXQgcmVxdWlyZXMgYW4gYXJjaGl2ZSBub2RlXHJcbiAgICAgKiAgd2l0aCB0aGUgYGBkZWJ1Z19gYCBvciBgYHRyYWNlX2BgIEFQSSBlbmFibGVkLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRSZXN1bHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVzdWx0KHRoaXMuaGFzaCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIG51bWJlciBvZiBjb25maXJtYXRpb25zIHRoaXMgdHJhbnNhY3Rpb24gaGFzLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBjb25maXJtYXRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpKSAtIHRoaXMuYmxvY2tOdW1iZXIgKyAxO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZWRFdmVudCgpIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlUmVtb3ZlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIHJlb3JkZXJlZEV2ZW50KG90aGVyKSB7XHJcbiAgICAgICAgYXNzZXJ0KCFvdGhlciB8fCBvdGhlci5pc01pbmVkKCksIFwidW5taW5lZCAnb3RoZXInIHRyYW5zY3Rpb24gY2Fubm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlb3JkZXJlZEV2ZW50KG90aGVyKVwiIH0pO1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVSZW9yZGVyZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzLCBvdGhlcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBBICoqVHJhbnNhY3Rpb25SZXNwb25zZSoqIGluY2x1ZGVzIGFsbCBwcm9wZXJ0aWVzIGFib3V0IGEgdHJhbnNhY3Rpb25cclxuICogIHRoYXQgd2FzIHNlbnQgdG8gdGhlIG5ldHdvcmssIHdoaWNoIG1heSBvciBtYXkgbm90IGJlIGluY2x1ZGVkIGluIGFcclxuICogIGJsb2NrLlxyXG4gKlxyXG4gKiAgVGhlIFtbVHJhbnNhY3Rpb25SZXNwb25zZS1pc01pbmVkXV0gY2FuIGJlIHVzZWQgdG8gY2hlY2sgaWYgdGhlXHJcbiAqICB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhcyB3ZWxsIGFzIHR5cGUgZ3VhcmQgdGhhdCB0aGUgb3RoZXJ3aXNlXHJcbiAqICBwb3NzaWJseSBgYG51bGxgYCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uUmVzcG9uc2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHByb3ZpZGVyIHRoaXMgaXMgY29ubmVjdGVkIHRvLCB3aGljaCB3aWxsIGluZmx1ZW5jZSBob3cgaXRzXHJcbiAgICAgKiAgbWV0aG9kcyB3aWxsIHJlc29sdmUgaXRzIGFzeW5jIGluc3BlY3Rpb24gbWV0aG9kcy5cclxuICAgICAqL1xyXG4gICAgcHJvdmlkZXI7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIGBgbnVsbGBgIGZvciBwZW5kaW5nIHRyYW5zYWN0aW9ucy5cclxuICAgICAqL1xyXG4gICAgYmxvY2tOdW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYmxvY2tIYXNoIG9mIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIGBgbnVsbGBgIGZvciBwZW5kaW5nIHRyYW5zYWN0aW9ucy5cclxuICAgICAqL1xyXG4gICAgYmxvY2tIYXNoO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGluZGV4IHdpdGhpbiB0aGUgYmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHJlc2lkZXMgYXQuXHJcbiAgICAgKi9cclxuICAgIGluZGV4O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2guXHJcbiAgICAgKi9cclxuICAgIGhhc2g7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yNzE4XV0gdHJhbnNhY3Rpb24gZW52ZWxvcGUgdHlwZS4gVGhpcyBpc1xyXG4gICAgICogIGBgMGBgIGZvciBsZWdhY3kgdHJhbnNhY3Rpb25zIHR5cGVzLlxyXG4gICAgICovXHJcbiAgICB0eXBlO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHJlY2VpdmVyIG9mIHRoaXMgdHJhbnNhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogIElmIGBgbnVsbGBgLCB0aGVuIHRoZSB0cmFuc2FjdGlvbiBpcyBhbiBpbml0Y29kZSB0cmFuc2FjdGlvbi5cclxuICAgICAqICBUaGlzIG1lYW5zIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIHRoZSBbW2RhdGFdXSB3aWxsIGJlIGRlcGxveWVkXHJcbiAgICAgKiAgYXMgYSBuZXcgY29udHJhY3Qgb24gY2hhaW4gKGFzc3VtaW5nIGl0IGRvZXMgbm90IHJldmVydCkgYW5kIHRoZVxyXG4gICAgICogIGFkZHJlc3MgbWF5IGJlIGNvbXB1dGVkIHVzaW5nIFtbZ2V0Q3JlYXRlQWRkcmVzc11dLlxyXG4gICAgICovXHJcbiAgICB0bztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBzZW5kZXIgb2YgdGhpcyB0cmFuc2FjdGlvbi4gSXQgaXMgaW1wbGljaXRseSBjb21wdXRlZFxyXG4gICAgICogIGZyb20gdGhlIHRyYW5zYWN0aW9uIHByZS1pbWFnZSBoYXNoIChhcyB0aGUgZGlnZXN0KSBhbmQgdGhlXHJcbiAgICAgKiAgW1tzaWduYXR1cmVdXSB1c2luZyBlY3JlY292ZXIuXHJcbiAgICAgKi9cclxuICAgIGZyb207XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbm9uY2UsIHdoaWNoIGlzIHVzZWQgdG8gcHJldmVudCByZXBsYXkgYXR0YWNrcyBhbmQgb2ZmZXJcclxuICAgICAqICBhIG1ldGhvZCB0byBlbnN1cmUgdHJhbnNhY3Rpb25zIGZyb20gYSBnaXZlbiBzZW5kZXIgYXJlIGV4cGxpY2l0bHlcclxuICAgICAqICBvcmRlcmVkLlxyXG4gICAgICpcclxuICAgICAqICBXaGVuIHNlbmRpbmcgYSB0cmFuc2FjdGlvbiwgdGhpcyBtdXN0IGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2ZcclxuICAgICAqICB0cmFuc2FjdGlvbnMgZXZlciBzZW50IGJ5IFtbZnJvbV1dLlxyXG4gICAgICovXHJcbiAgICBub25jZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBtYXhpbXVtIHVuaXRzIG9mIGdhcyB0aGlzIHRyYW5zYWN0aW9uIGNhbiBjb25zdW1lLiBJZiBleGVjdXRpb25cclxuICAgICAqICBleGNlZWRzIHRoaXMsIHRoZSBlbnRyaWVzIHRyYW5zYWN0aW9uIGlzIHJldmVydGVkIGFuZCB0aGUgc2VuZGVyXHJcbiAgICAgKiAgaXMgY2hhcmdlZCBmb3IgdGhlIGZ1bGwgYW1vdW50LCBkZXNwaXRlIG5vdCBzdGF0ZSBjaGFuZ2VzIGJlaW5nIG1hZGUuXHJcbiAgICAgKi9cclxuICAgIGdhc0xpbWl0O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGdhcyBwcmljZSBjYW4gaGF2ZSB2YXJpb3VzIHZhbHVlcywgZGVwZW5kaW5nIG9uIHRoZSBuZXR3b3JrLlxyXG4gICAgICpcclxuICAgICAqICBJbiBtb2Rlcm4gbmV0d29ya3MsIGZvciB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgaW5jbHVkZWQgdGhpcyBpc1xyXG4gICAgICogIHRoZSAvL2VmZmVjdGl2ZSBnYXMgcHJpY2UvLyAodGhlIGZlZSBwZXIgZ2FzIHRoYXQgd2FzIGFjdHVhbGx5XHJcbiAgICAgKiAgY2hhcmdlZCksIHdoaWxlIGZvciB0cmFuc2FjdGlvbnMgdGhhdCBoYXZlIG5vdCBiZWVuIGluY2x1ZGVkIHlldFxyXG4gICAgICogIGlzIHRoZSBbW21heEZlZVBlckdhc11dLlxyXG4gICAgICpcclxuICAgICAqICBGb3IgbGVnYWN5IHRyYW5zYWN0aW9ucywgb3IgdHJhbnNhY3Rpb25zIG9uIGxlZ2FjeSBuZXR3b3JrcywgdGhpc1xyXG4gICAgICogIGlzIHRoZSBmZWUgdGhhdCB3aWxsIGJlIGNoYXJnZWQgcGVyIHVuaXQgb2YgZ2FzIHRoZSB0cmFuc2FjdGlvblxyXG4gICAgICogIGNvbnN1bWVzLlxyXG4gICAgICovXHJcbiAgICBnYXNQcmljZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBtYXhpbXVtIHByaW9yaXR5IGZlZSAocGVyIHVuaXQgb2YgZ2FzKSB0byBhbGxvdyBhXHJcbiAgICAgKiAgdmFsaWRhdG9yIHRvIGNoYXJnZSB0aGUgc2VuZGVyLiBUaGlzIGlzIGluY2x1c2l2ZSBvZiB0aGVcclxuICAgICAqICBbW21heEZlZUZlZVBlckdhc11dLlxyXG4gICAgICovXHJcbiAgICBtYXhQcmlvcml0eUZlZVBlckdhcztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBtYXhpbXVtIGZlZSAocGVyIHVuaXQgb2YgZ2FzKSB0byBhbGxvdyB0aGlzIHRyYW5zYWN0aW9uXHJcbiAgICAgKiAgdG8gY2hhcmdlIHRoZSBzZW5kZXIuXHJcbiAgICAgKi9cclxuICAgIG1heEZlZVBlckdhcztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTQ4NDRdXSBtYXggZmVlIHBlciBCTE9iIGdhcy5cclxuICAgICAqL1xyXG4gICAgbWF4RmVlUGVyQmxvYkdhcztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBkYXRhLlxyXG4gICAgICovXHJcbiAgICBkYXRhO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHZhbHVlLCBpbiB3ZWkuIFVzZSBbW2Zvcm1hdEV0aGVyXV0gdG8gZm9ybWF0IHRoaXMgdmFsdWVcclxuICAgICAqICBhcyBldGhlci5cclxuICAgICAqL1xyXG4gICAgdmFsdWU7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgY2hhaW4gSUQuXHJcbiAgICAgKi9cclxuICAgIGNoYWluSWQ7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgc2lnbmF0dXJlLlxyXG4gICAgICovXHJcbiAgICBzaWduYXR1cmU7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QgZm9yIHRyYW5zYWN0aW9uIHR5cGVzIHRoYXRcclxuICAgICAqICBzdXBwb3J0IGl0LCBvdGhlcndpc2UgYGBudWxsYGAuXHJcbiAgICAgKi9cclxuICAgIGFjY2Vzc0xpc3Q7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgW1tsaW5rLWVpcC00ODQ0XV0gQkxPYiB2ZXJzaW9uZWQgaGFzaGVzLlxyXG4gICAgICovXHJcbiAgICBibG9iVmVyc2lvbmVkSGFzaGVzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIFtbbGluay1laXAtNzcwMl1dIGF1dGhvcml6YXRpb25zIChpZiBhbnkpLlxyXG4gICAgICovXHJcbiAgICBhdXRob3JpemF0aW9uTGlzdDtcclxuICAgICNzdGFydEJsb2NrO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHR4LCBwcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcclxuICAgICAgICB0aGlzLmJsb2NrTnVtYmVyID0gKHR4LmJsb2NrTnVtYmVyICE9IG51bGwpID8gdHguYmxvY2tOdW1iZXIgOiBudWxsO1xyXG4gICAgICAgIHRoaXMuYmxvY2tIYXNoID0gKHR4LmJsb2NrSGFzaCAhPSBudWxsKSA/IHR4LmJsb2NrSGFzaCA6IG51bGw7XHJcbiAgICAgICAgdGhpcy5oYXNoID0gdHguaGFzaDtcclxuICAgICAgICB0aGlzLmluZGV4ID0gdHguaW5kZXg7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHgudHlwZTtcclxuICAgICAgICB0aGlzLmZyb20gPSB0eC5mcm9tO1xyXG4gICAgICAgIHRoaXMudG8gPSB0eC50byB8fCBudWxsO1xyXG4gICAgICAgIHRoaXMuZ2FzTGltaXQgPSB0eC5nYXNMaW1pdDtcclxuICAgICAgICB0aGlzLm5vbmNlID0gdHgubm9uY2U7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gdHguZGF0YTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdHgudmFsdWU7XHJcbiAgICAgICAgdGhpcy5nYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xyXG4gICAgICAgIHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkgPyB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA6IG51bGw7XHJcbiAgICAgICAgdGhpcy5tYXhGZWVQZXJHYXMgPSAodHgubWF4RmVlUGVyR2FzICE9IG51bGwpID8gdHgubWF4RmVlUGVyR2FzIDogbnVsbDtcclxuICAgICAgICB0aGlzLm1heEZlZVBlckJsb2JHYXMgPSAodHgubWF4RmVlUGVyQmxvYkdhcyAhPSBudWxsKSA/IHR4Lm1heEZlZVBlckJsb2JHYXMgOiBudWxsO1xyXG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IHR4LmNoYWluSWQ7XHJcbiAgICAgICAgdGhpcy5zaWduYXR1cmUgPSB0eC5zaWduYXR1cmU7XHJcbiAgICAgICAgdGhpcy5hY2Nlc3NMaXN0ID0gKHR4LmFjY2Vzc0xpc3QgIT0gbnVsbCkgPyB0eC5hY2Nlc3NMaXN0IDogbnVsbDtcclxuICAgICAgICB0aGlzLmJsb2JWZXJzaW9uZWRIYXNoZXMgPSAodHguYmxvYlZlcnNpb25lZEhhc2hlcyAhPSBudWxsKSA/IHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMgOiBudWxsO1xyXG4gICAgICAgIHRoaXMuYXV0aG9yaXphdGlvbkxpc3QgPSAodHguYXV0aG9yaXphdGlvbkxpc3QgIT0gbnVsbCkgPyB0eC5hdXRob3JpemF0aW9uTGlzdCA6IG51bGw7XHJcbiAgICAgICAgdGhpcy4jc3RhcnRCbG9jayA9IC0xO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHRyYW5zYWN0aW9uLlxyXG4gICAgICovXHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgYmxvY2tIYXNoLCBpbmRleCwgaGFzaCwgdHlwZSwgdG8sIGZyb20sIG5vbmNlLCBkYXRhLCBzaWduYXR1cmUsIGFjY2Vzc0xpc3QsIGJsb2JWZXJzaW9uZWRIYXNoZXMgfSA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgX3R5cGU6IFwiVHJhbnNhY3Rpb25SZXNwb25zZVwiLFxyXG4gICAgICAgICAgICBhY2Nlc3NMaXN0LCBibG9ja051bWJlciwgYmxvY2tIYXNoLFxyXG4gICAgICAgICAgICBibG9iVmVyc2lvbmVkSGFzaGVzLFxyXG4gICAgICAgICAgICBjaGFpbklkOiB0b0pzb24odGhpcy5jaGFpbklkKSxcclxuICAgICAgICAgICAgZGF0YSwgZnJvbSxcclxuICAgICAgICAgICAgZ2FzTGltaXQ6IHRvSnNvbih0aGlzLmdhc0xpbWl0KSxcclxuICAgICAgICAgICAgZ2FzUHJpY2U6IHRvSnNvbih0aGlzLmdhc1ByaWNlKSxcclxuICAgICAgICAgICAgaGFzaCxcclxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiB0b0pzb24odGhpcy5tYXhGZWVQZXJHYXMpLFxyXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogdG9Kc29uKHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxyXG4gICAgICAgICAgICBtYXhGZWVQZXJCbG9iR2FzOiB0b0pzb24odGhpcy5tYXhGZWVQZXJCbG9iR2FzKSxcclxuICAgICAgICAgICAgbm9uY2UsIHNpZ25hdHVyZSwgdG8sIGluZGV4LCB0eXBlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdG9Kc29uKHRoaXMudmFsdWUpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgQmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyB3aWxsIHJldHVybiBudWxsIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gaW5jbHVkZWQgeWV0LlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRCbG9jaygpIHtcclxuICAgICAgICBsZXQgYmxvY2tOdW1iZXIgPSB0aGlzLmJsb2NrTnVtYmVyO1xyXG4gICAgICAgIGlmIChibG9ja051bWJlciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvbigpO1xyXG4gICAgICAgICAgICBpZiAodHgpIHtcclxuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gdHguYmxvY2tOdW1iZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5wcm92aWRlci5nZXRCbG9jayhibG9ja051bWJlcik7XHJcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJsb2NrO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhpcyB0cmFuc2FjdGlvbiBiZWluZyByZS1yZXF1ZXN0ZWQgZnJvbSB0aGVcclxuICAgICAqICBwcm92aWRlci4gVGhpcyBjYW4gYmUgdXNlZCBpZiB5b3UgaGF2ZSBhbiB1bm1pbmVkIHRyYW5zYWN0aW9uXHJcbiAgICAgKiAgYW5kIHdpc2ggdG8gZ2V0IGFuIHVwLXRvLWRhdGUgcG9wdWxhdGVkIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZSB0byB0aGUgbnVtYmVyIG9mIGNvbmZpcm1hdGlvbnMgdGhpcyB0cmFuc2FjdGlvbiBoYXMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGNvbmZpcm1hdGlvbnMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHR4LCBibG9ja051bWJlciB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICAgICAgdHg6IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKSxcclxuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIE5vdCBtaW5lZCB5ZXQuLi5cclxuICAgICAgICAgICAgaWYgKHR4ID09IG51bGwgfHwgdHguYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyIC0gdHguYmxvY2tOdW1iZXIgKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcclxuICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXIgLSB0aGlzLmJsb2NrTnVtYmVyICsgMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhbmQgaGFzXHJcbiAgICAgKiAgJSVjb25maXJtcyUlIGJsb2NrcyBpbmNsdWRpbmcgaXQgKGRlZmF1bHQ6IGBgMWBgKSB3aXRoIGFuXHJcbiAgICAgKiAgb3B0aW9uYWwgJSV0aW1lb3V0JSUuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgY2FuIHJlc29sdmUgdG8gYGBudWxsYGAgb25seSBpZiAlJWNvbmZpcm1zJSUgaXMgYGAwYGBcclxuICAgICAqICBhbmQgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBtaW5lZCwgb3RoZXJ3aXNlIHRoaXMgd2lsbFxyXG4gICAgICogIHdhaXQgdW50aWwgZW5vdWdoIGNvbmZpcm1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHdhaXQoX2NvbmZpcm1zLCBfdGltZW91dCkge1xyXG4gICAgICAgIGNvbnN0IGNvbmZpcm1zID0gKF9jb25maXJtcyA9PSBudWxsKSA/IDEgOiBfY29uZmlybXM7XHJcbiAgICAgICAgY29uc3QgdGltZW91dCA9IChfdGltZW91dCA9PSBudWxsKSA/IDAgOiBfdGltZW91dDtcclxuICAgICAgICBsZXQgc3RhcnRCbG9jayA9IHRoaXMuI3N0YXJ0QmxvY2s7XHJcbiAgICAgICAgbGV0IG5leHRTY2FuID0gLTE7XHJcbiAgICAgICAgbGV0IHN0b3BTY2FubmluZyA9IChzdGFydEJsb2NrID09PSAtMSkgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgY29uc3QgY2hlY2tSZXBsYWNlbWVudCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIGNvdW50IGZvciB0aGlzIHNlbmRlclxyXG4gICAgICAgICAgICBpZiAoc3RvcFNjYW5uaW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB7IGJsb2NrTnVtYmVyLCBub25jZSB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKSxcclxuICAgICAgICAgICAgICAgIG5vbmNlOiB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5mcm9tKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gTm8gdHJhbnNhY3Rpb24gb3Igb3VyIG5vbmNlIGhhcyBub3QgYmVlbiBtaW5lZCB5ZXQ7IGJ1dCB3ZVxyXG4gICAgICAgICAgICAvLyBjYW4gc3RhcnQgc2Nhbm5pbmcgbGF0ZXIgd2hlbiB3ZSBkbyBzdGFydFxyXG4gICAgICAgICAgICBpZiAobm9uY2UgPCB0aGlzLm5vbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydEJsb2NrID0gYmxvY2tOdW1iZXI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gV2Ugd2VyZSBtaW5lZDsgbm8gcmVwbGFjZW1lbnRcclxuICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbWluZWQgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uKCk7XHJcbiAgICAgICAgICAgIGlmIChtaW5lZCAmJiBtaW5lZC5ibG9ja051bWJlciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gV2Ugd2VyZSByZXBsYWNlZDsgc3RhcnQgc2Nhbm5pbmcgZm9yIHRoYXQgdHJhbnNhY3Rpb25cclxuICAgICAgICAgICAgLy8gU3RhcnRpbmcgdG8gc2NhbjsgbG9vayBiYWNrIGEgZmV3IGV4dHJhIGJsb2NrcyBmb3Igc2FmZXR5XHJcbiAgICAgICAgICAgIGlmIChuZXh0U2NhbiA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIG5leHRTY2FuID0gc3RhcnRCbG9jayAtIDM7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dFNjYW4gPCB0aGlzLiNzdGFydEJsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNjYW4gPSB0aGlzLiNzdGFydEJsb2NrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlIChuZXh0U2NhbiA8PSBibG9ja051bWJlcikge1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBuZXh0IGJsb2NrIHRvIHNjYW5cclxuICAgICAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9jayhuZXh0U2NhbiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuOyBidXQgd2UnbGwgdHJ5IGFnYWluIHNob3J0bHlcclxuICAgICAgICAgICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSBtaW5lZDsgbm8gcmVwbGFjZW1lbnRcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaGFzaCBvZiBibG9jaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNoID09PSB0aGlzLmhhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRoYXQgcmVwbGFjZWQgdXNcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2subGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IGJsb2NrLmdldFRyYW5zYWN0aW9uKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eC5mcm9tID09PSB0aGlzLmZyb20gJiYgdHgubm9uY2UgPT09IHRoaXMubm9uY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSByZWNlaXB0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eC5oYXNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbjsgYnV0IHdlJ2xsIHRyeSBhZ2FpbiBzaG9ydGx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB3aWxsIHJldHJ5IHRoaXMgb24gdGhlIG5leHQgYmxvY2sgKHRoaXMgY2FzZSBjb3VsZCBiZSBvcHRpbWl6ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyICsgMSkgPCBjb25maXJtcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWFzb24gd2Ugd2VyZSByZXBsYWNlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVhc29uID0gXCJyZXBsYWNlZFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZGF0YSA9PT0gdGhpcy5kYXRhICYmIHR4LnRvID09PSB0aGlzLnRvICYmIHR4LnZhbHVlID09PSB0aGlzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcInJlcHJpY2VkXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHguZGF0YSA9PT0gXCIweFwiICYmIHR4LmZyb20gPT09IHR4LnRvICYmIHR4LnZhbHVlID09PSBCTl8wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcImNhbmNlbGxlZFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJ0cmFuc2FjdGlvbiB3YXMgcmVwbGFjZWRcIiwgXCJUUkFOU0FDVElPTl9SRVBMQUNFRFwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxsZWQ6IChyZWFzb24gPT09IFwicmVwbGFjZWRcIiB8fCByZWFzb24gPT09IFwiY2FuY2VsbGVkXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQ6IHR4LnJlcGxhY2VhYmxlVHJhbnNhY3Rpb24oc3RhcnRCbG9jayksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiB0eC5oYXNoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXh0U2NhbisrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGNoZWNrUmVjZWlwdCA9IChyZWNlaXB0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwgfHwgcmVjZWlwdC5zdGF0dXMgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXB0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJ0cmFuc2FjdGlvbiBleGVjdXRpb24gcmV2ZXJ0ZWRcIiwgXCJDQUxMX0VYQ0VQVElPTlwiLCB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwic2VuZFRyYW5zYWN0aW9uXCIsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLCByZWFzb246IG51bGwsIGludm9jYXRpb246IG51bGwsIHJldmVydDogbnVsbCxcclxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG86IHJlY2VpcHQudG8sXHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogcmVjZWlwdC5mcm9tLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IFwiXCIgLy8gQFRPRE86IGluIHY3LCBzcGxpdCBvdXQgc2VuZFRyYW5zYWN0aW9uIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgIH0sIHJlY2VpcHRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodGhpcy5oYXNoKTtcclxuICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNoZWNrUmVjZWlwdChyZWNlaXB0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlY2VpcHQpIHtcclxuICAgICAgICAgICAgaWYgKGNvbmZpcm1zID09PSAxIHx8IChhd2FpdCByZWNlaXB0LmNvbmZpcm1hdGlvbnMoKSkgPj0gY29uZmlybXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1JlY2VpcHQocmVjZWlwdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIHJlcGxhY2VtZW50OyB0aHJvd3MgaWYgYSByZXBsYWNlbWVudCB3YXMgZm91bmRcclxuICAgICAgICAgICAgYXdhaXQgY2hlY2tSZXBsYWNlbWVudCgpO1xyXG4gICAgICAgICAgICAvLyBBbGxvdyBudWxsIG9ubHkgd2hlbiB0aGUgY29uZmlybXMgaXMgMFxyXG4gICAgICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHdhaXRlciA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgLy8gTGlzdCBvZiB0aGluZ3MgdG8gY2FuY2VsIHdoZW4gd2UgaGF2ZSBhIHJlc3VsdCAob25lIHdheSBvciB0aGUgb3RoZXIpXHJcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxlcnMgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgY2FuY2VsID0gKCkgPT4geyBjYW5jZWxsZXJzLmZvckVhY2goKGMpID0+IGMoKSk7IH07XHJcbiAgICAgICAgICAgIC8vIE9uIGNhbmNlbCwgc3RvcCBzY2FubmluZyBmb3IgcmVwbGFjZW1lbnRzXHJcbiAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHN0b3BTY2FubmluZyA9IHRydWU7IH0pO1xyXG4gICAgICAgICAgICAvLyBTZXQgdXAgYW55IHRpbWVvdXQgcmVxdWVzdGVkXHJcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobWFrZUVycm9yKFwid2FpdCBmb3IgdHJhbnNhY3Rpb24gdGltZW91dFwiLCBcIlRJTUVPVVRcIikpO1xyXG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICBjYW5jZWxsZXJzLnB1c2goKCkgPT4geyBjbGVhclRpbWVvdXQodGltZXIpOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0eExpc3RlbmVyID0gYXN5bmMgKHJlY2VpcHQpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIERvbmU7IHJldHVybiBpdCFcclxuICAgICAgICAgICAgICAgIGlmICgoYXdhaXQgcmVjZWlwdC5jb25maXJtYXRpb25zKCkpID49IGNvbmZpcm1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjaGVja1JlY2VpcHQocmVjZWlwdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHRoaXMucHJvdmlkZXIub2ZmKHRoaXMuaGFzaCwgdHhMaXN0ZW5lcik7IH0pO1xyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKHRoaXMuaGFzaCwgdHhMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIC8vIFdlIHN1cHBvcnQgcmVwbGFjZW1lbnQgZGV0ZWN0aW9uOyBzdGFydCBjaGVja2luZ1xyXG4gICAgICAgICAgICBpZiAoc3RhcnRCbG9jayA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlTGlzdGVuZXIgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGEgcmVwbGFjZW1lbnQ7IHRoaXMgdGhyb3dzIG9ubHkgaWYgb25lIGlzIGZvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNoZWNrUmVwbGFjZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHdlcmUgcmVwbGFjZWQgKHdpdGggZW5vdWdoIGNvbmZpcm1zKTsgcmUtdGhyb3cgdGhlIGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzY2hldWRsZSBhIGNoZWNrIG9uIHRoZSBuZXh0IGJsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wU2Nhbm5pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgdGhpcy5wcm92aWRlci5vZmYoXCJibG9ja1wiLCByZXBsYWNlTGlzdGVuZXIpOyB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub25jZShcImJsb2NrXCIsIHJlcGxhY2VMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgd2FpdGVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBpZiB0aGlzIHRyYW5zYWN0aW9uIGhhcyBiZWVuIGluY2x1ZGVkLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIGVmZmVjdGl2ZSBvbmx5IGFzIG9mIHRoZSB0aW1lIHRoZSBUcmFuc2FjdGlvblJlc3BvbnNlXHJcbiAgICAgKiAgd2FzIGluc3RhbnRpYXRlZC4gVG8gZ2V0IHVwLXRvLWRhdGUgaW5mb3JtYXRpb24sIHVzZVxyXG4gICAgICogIFtbZ2V0VHJhbnNhY3Rpb25dXS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdpbGwgaGF2ZVxyXG4gICAgICogIG5vbi1udWxsIHByb3BlcnR5IHZhbHVlcyBmb3IgcHJvcGVydGllcyB0aGF0IGFyZSBudWxsIGZvclxyXG4gICAgICogIHVubWluZWQgdHJhbnNhY3Rpb25zLlxyXG4gICAgICovXHJcbiAgICBpc01pbmVkKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5ibG9ja0hhc2ggIT0gbnVsbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGEgbGVnYWN5IChpLmUuIGBgdHlwZSA9PSAwYGApXHJcbiAgICAgKiAgdHJhbnNhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGhhdmVcclxuICAgICAqICB0aGUgYGBudWxsYGAtbmVzcyBmb3IgaGFyZGZvcmstc3BlY2lmaWMgcHJvcGVydGllcyBzZXQgY29ycmVjdGx5LlxyXG4gICAgICovXHJcbiAgICBpc0xlZ2FjeSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGEgQmVybGluIChpLmUuIGBgdHlwZSA9PSAxYGApXHJcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTIwNzBdXS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdpbGwgaGF2ZVxyXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXHJcbiAgICAgKi9cclxuICAgIGlzQmVybGluKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAxKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBMb25kb24gKGkuZS4gYGB0eXBlID09IDJgYClcclxuICAgICAqICB0cmFuc2FjdGlvbi4gU2VlIFtbbGluay1laXAtMTU1OV1dLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXHJcbiAgICAgKiAgdGhlIGBgbnVsbGBgLW5lc3MgZm9yIGhhcmRmb3JrLXNwZWNpZmljIHByb3BlcnRpZXMgc2V0IGNvcnJlY3RseS5cclxuICAgICAqL1xyXG4gICAgaXNMb25kb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIGh0ZSB0cmFuc2FjdGlvbiBpcyBhIENhbmN1biAoaS5lLiBgYHR5cGUgPT0gM2BgKVxyXG4gICAgICogIHRyYW5zYWN0aW9uLiBTZWUgW1tsaW5rLWVpcC00ODQ0XV0uXHJcbiAgICAgKi9cclxuICAgIGlzQ2FuY3VuKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBmaWx0ZXIgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBvcnBoYW4gZXZlbnRzXHJcbiAgICAgKiAgdGhhdCBldmljdCB0aGlzIHRyYW5zYWN0aW9uLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVkRXZlbnQoKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMuaXNNaW5lZCgpLCBcInVubWluZWQgdHJhbnNhY3Rpb24gY2Fub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVtb3ZlRXZlbnQoKVwiIH0pO1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVSZW1vdmVkVHJhbnNhY3Rpb25GaWx0ZXIodGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgZmlsdGVyIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGxpc3RlbiBmb3Igb3JwaGFuIGV2ZW50c1xyXG4gICAgICogIHRoYXQgcmUtb3JkZXIgdGhpcyBldmVudCBhZ2FpbnN0ICUlb3RoZXIlJS5cclxuICAgICAqL1xyXG4gICAgcmVvcmRlcmVkRXZlbnQob3RoZXIpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5pc01pbmVkKCksIFwidW5taW5lZCB0cmFuc2FjdGlvbiBjYW5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW1vdmVFdmVudCgpXCIgfSk7XHJcbiAgICAgICAgYXNzZXJ0KCFvdGhlciB8fCBvdGhlci5pc01pbmVkKCksIFwidW5taW5lZCAnb3RoZXInIHRyYW5zYWN0aW9uIGNhbm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlbW92ZUV2ZW50KClcIiB9KTtcclxuICAgICAgICByZXR1cm4gY3JlYXRlUmVvcmRlcmVkVHJhbnNhY3Rpb25GaWx0ZXIodGhpcywgb3RoZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBUcmFuc2FjdGlvblJlc3BvbnNlIGluc3RhbmNlIHdoaWNoIGhhcyB0aGUgYWJpbGl0eSB0b1xyXG4gICAgICogIGRldGVjdCAoYW5kIHRocm93IGFuIGVycm9yKSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgcmVwbGFjZWQsIHdoaWNoXHJcbiAgICAgKiAgd2lsbCBiZWdpbiBzY2FubmluZyBhdCAlJXN0YXJ0QmxvY2slJS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBzaG91bGQgZ2VuZXJhbGx5IG5vdCBiZSB1c2VkIGJ5IGRldmVsb3BlcnMgYW5kIGlzIGludGVuZGVkXHJcbiAgICAgKiAgcHJpbWFyaWx5IGZvciBpbnRlcm5hbCB1c2UuIFNldHRpbmcgYW4gaW5jb3JyZWN0ICUlc3RhcnRCbG9jayUlIGNhblxyXG4gICAgICogIGhhdmUgZGV2YXN0YXRpbmcgcGVyZm9ybWFuY2UgY29uc2VxdWVuY2VzIGlmIHVzZWQgaW5jb3JyZWN0bHkuXHJcbiAgICAgKi9cclxuICAgIHJlcGxhY2VhYmxlVHJhbnNhY3Rpb24oc3RhcnRCbG9jaykge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIoc3RhcnRCbG9jaykgJiYgc3RhcnRCbG9jayA+PSAwLCBcImludmFsaWQgc3RhcnRCbG9ja1wiLCBcInN0YXJ0QmxvY2tcIiwgc3RhcnRCbG9jayk7XHJcbiAgICAgICAgY29uc3QgdHggPSBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZSh0aGlzLCB0aGlzLnByb3ZpZGVyKTtcclxuICAgICAgICB0eC4jc3RhcnRCbG9jayA9IHN0YXJ0QmxvY2s7XHJcbiAgICAgICAgcmV0dXJuIHR4O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZU9ycGhhbmVkQmxvY2tGaWx0ZXIoYmxvY2spIHtcclxuICAgIHJldHVybiB7IG9ycGhhbjogXCJkcm9wLWJsb2NrXCIsIGhhc2g6IGJsb2NrLmhhc2gsIG51bWJlcjogYmxvY2subnVtYmVyIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVvcmRlcmVkVHJhbnNhY3Rpb25GaWx0ZXIodHgsIG90aGVyKSB7XHJcbiAgICByZXR1cm4geyBvcnBoYW46IFwicmVvcmRlci10cmFuc2FjdGlvblwiLCB0eCwgb3RoZXIgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZW1vdmVkVHJhbnNhY3Rpb25GaWx0ZXIodHgpIHtcclxuICAgIHJldHVybiB7IG9ycGhhbjogXCJkcm9wLXRyYW5zYWN0aW9uXCIsIHR4IH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVtb3ZlZExvZ0ZpbHRlcihsb2cpIHtcclxuICAgIHJldHVybiB7IG9ycGhhbjogXCJkcm9wLWxvZ1wiLCBsb2c6IHtcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBsb2cudHJhbnNhY3Rpb25IYXNoLFxyXG4gICAgICAgICAgICBibG9ja0hhc2g6IGxvZy5ibG9ja0hhc2gsXHJcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBsb2cuYmxvY2tOdW1iZXIsXHJcbiAgICAgICAgICAgIGFkZHJlc3M6IGxvZy5hZGRyZXNzLFxyXG4gICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcclxuICAgICAgICAgICAgdG9waWNzOiBPYmplY3QuZnJlZXplKGxvZy50b3BpY3Muc2xpY2UoKSksXHJcbiAgICAgICAgICAgIGluZGV4OiBsb2cuaW5kZXhcclxuICAgICAgICB9IH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/provider.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/signer-noncemanager.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/signer-noncemanager.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NonceManager: () => (/* binding */ NonceManager)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _abstract_signer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-signer.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/abstract-signer.js\");\n\r\n\r\n/**\r\n *  A **NonceManager** wraps another [[Signer]] and automatically manages\r\n *  the nonce, ensuring serialized and sequential nonces are used during\r\n *  transaction.\r\n */\r\nclass NonceManager extends _abstract_signer_js__WEBPACK_IMPORTED_MODULE_0__.AbstractSigner {\r\n    /**\r\n     *  The Signer being managed.\r\n     */\r\n    signer;\r\n    #noncePromise;\r\n    #delta;\r\n    /**\r\n     *  Creates a new **NonceManager** to manage %%signer%%.\r\n     */\r\n    constructor(signer) {\r\n        super(signer.provider);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { signer });\r\n        this.#noncePromise = null;\r\n        this.#delta = 0;\r\n    }\r\n    async getAddress() {\r\n        return this.signer.getAddress();\r\n    }\r\n    connect(provider) {\r\n        return new NonceManager(this.signer.connect(provider));\r\n    }\r\n    async getNonce(blockTag) {\r\n        if (blockTag === \"pending\") {\r\n            if (this.#noncePromise == null) {\r\n                this.#noncePromise = super.getNonce(\"pending\");\r\n            }\r\n            const delta = this.#delta;\r\n            return (await this.#noncePromise) + delta;\r\n        }\r\n        return super.getNonce(blockTag);\r\n    }\r\n    /**\r\n     *  Manually increment the nonce. This may be useful when managng\r\n     *  offline transactions.\r\n     */\r\n    increment() {\r\n        this.#delta++;\r\n    }\r\n    /**\r\n     *  Resets the nonce, causing the **NonceManager** to reload the current\r\n     *  nonce from the blockchain on the next transaction.\r\n     */\r\n    reset() {\r\n        this.#delta = 0;\r\n        this.#noncePromise = null;\r\n    }\r\n    async sendTransaction(tx) {\r\n        const noncePromise = this.getNonce(\"pending\");\r\n        this.increment();\r\n        tx = await this.signer.populateTransaction(tx);\r\n        tx.nonce = await noncePromise;\r\n        // @TODO: Maybe handle interesting/recoverable errors?\r\n        // Like don't increment if the tx was certainly not sent\r\n        return await this.signer.sendTransaction(tx);\r\n    }\r\n    signTransaction(tx) {\r\n        return this.signer.signTransaction(tx);\r\n    }\r\n    signMessage(message) {\r\n        return this.signer.signMessage(message);\r\n    }\r\n    signTypedData(domain, types, value) {\r\n        return this.signer.signTypedData(domain, types, value);\r\n    }\r\n}\r\n//# sourceMappingURL=signer-noncemanager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvc2lnbmVyLW5vbmNlbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUQ7QUFDQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkJBQTJCLCtEQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFnQixTQUFTLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHByb3ZpZGVyc1xcc2lnbmVyLW5vbmNlbWFuYWdlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IEFic3RyYWN0U2lnbmVyIH0gZnJvbSBcIi4vYWJzdHJhY3Qtc2lnbmVyLmpzXCI7XHJcbi8qKlxyXG4gKiAgQSAqKk5vbmNlTWFuYWdlcioqIHdyYXBzIGFub3RoZXIgW1tTaWduZXJdXSBhbmQgYXV0b21hdGljYWxseSBtYW5hZ2VzXHJcbiAqICB0aGUgbm9uY2UsIGVuc3VyaW5nIHNlcmlhbGl6ZWQgYW5kIHNlcXVlbnRpYWwgbm9uY2VzIGFyZSB1c2VkIGR1cmluZ1xyXG4gKiAgdHJhbnNhY3Rpb24uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTm9uY2VNYW5hZ2VyIGV4dGVuZHMgQWJzdHJhY3RTaWduZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIFNpZ25lciBiZWluZyBtYW5hZ2VkLlxyXG4gICAgICovXHJcbiAgICBzaWduZXI7XHJcbiAgICAjbm9uY2VQcm9taXNlO1xyXG4gICAgI2RlbHRhO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk5vbmNlTWFuYWdlcioqIHRvIG1hbmFnZSAlJXNpZ25lciUlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihzaWduZXIpIHtcclxuICAgICAgICBzdXBlcihzaWduZXIucHJvdmlkZXIpO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBzaWduZXIgfSk7XHJcbiAgICAgICAgdGhpcy4jbm9uY2VQcm9taXNlID0gbnVsbDtcclxuICAgICAgICB0aGlzLiNkZWx0YSA9IDA7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRBZGRyZXNzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25lci5nZXRBZGRyZXNzKCk7XHJcbiAgICB9XHJcbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOb25jZU1hbmFnZXIodGhpcy5zaWduZXIuY29ubmVjdChwcm92aWRlcikpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0Tm9uY2UoYmxvY2tUYWcpIHtcclxuICAgICAgICBpZiAoYmxvY2tUYWcgPT09IFwicGVuZGluZ1wiKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLiNub25jZVByb21pc2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4jbm9uY2VQcm9taXNlID0gc3VwZXIuZ2V0Tm9uY2UoXCJwZW5kaW5nXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy4jZGVsdGE7XHJcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy4jbm9uY2VQcm9taXNlKSArIGRlbHRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0Tm9uY2UoYmxvY2tUYWcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgTWFudWFsbHkgaW5jcmVtZW50IHRoZSBub25jZS4gVGhpcyBtYXkgYmUgdXNlZnVsIHdoZW4gbWFuYWduZ1xyXG4gICAgICogIG9mZmxpbmUgdHJhbnNhY3Rpb25zLlxyXG4gICAgICovXHJcbiAgICBpbmNyZW1lbnQoKSB7XHJcbiAgICAgICAgdGhpcy4jZGVsdGErKztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc2V0cyB0aGUgbm9uY2UsIGNhdXNpbmcgdGhlICoqTm9uY2VNYW5hZ2VyKiogdG8gcmVsb2FkIHRoZSBjdXJyZW50XHJcbiAgICAgKiAgbm9uY2UgZnJvbSB0aGUgYmxvY2tjaGFpbiBvbiB0aGUgbmV4dCB0cmFuc2FjdGlvbi5cclxuICAgICAqL1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy4jZGVsdGEgPSAwO1xyXG4gICAgICAgIHRoaXMuI25vbmNlUHJvbWlzZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHgpIHtcclxuICAgICAgICBjb25zdCBub25jZVByb21pc2UgPSB0aGlzLmdldE5vbmNlKFwicGVuZGluZ1wiKTtcclxuICAgICAgICB0aGlzLmluY3JlbWVudCgpO1xyXG4gICAgICAgIHR4ID0gYXdhaXQgdGhpcy5zaWduZXIucG9wdWxhdGVUcmFuc2FjdGlvbih0eCk7XHJcbiAgICAgICAgdHgubm9uY2UgPSBhd2FpdCBub25jZVByb21pc2U7XHJcbiAgICAgICAgLy8gQFRPRE86IE1heWJlIGhhbmRsZSBpbnRlcmVzdGluZy9yZWNvdmVyYWJsZSBlcnJvcnM/XHJcbiAgICAgICAgLy8gTGlrZSBkb24ndCBpbmNyZW1lbnQgaWYgdGhlIHR4IHdhcyBjZXJ0YWlubHkgbm90IHNlbnRcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zaWduZXIuc2VuZFRyYW5zYWN0aW9uKHR4KTtcclxuICAgIH1cclxuICAgIHNpZ25UcmFuc2FjdGlvbih0eCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25lci5zaWduVHJhbnNhY3Rpb24odHgpO1xyXG4gICAgfVxyXG4gICAgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25lci5zaWduTWVzc2FnZShtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIHNpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zaWduZXIuc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmVyLW5vbmNlbWFuYWdlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/signer-noncemanager.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/subscriber-filterid.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/subscriber-filterid.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FilterIdEventSubscriber: () => (/* binding */ FilterIdEventSubscriber),\n/* harmony export */   FilterIdPendingSubscriber: () => (/* binding */ FilterIdPendingSubscriber),\n/* harmony export */   FilterIdSubscriber: () => (/* binding */ FilterIdSubscriber)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n\r\n\r\nfunction copy(obj) {\r\n    return JSON.parse(JSON.stringify(obj));\r\n}\r\n/**\r\n *  Some backends support subscribing to events using a Filter ID.\r\n *\r\n *  When subscribing with this technique, the node issues a unique\r\n *  //Filter ID//. At this point the node dedicates resources to\r\n *  the filter, so that periodic calls to follow up on the //Filter ID//\r\n *  will receive any events since the last call.\r\n *\r\n *  @_docloc: api/providers/abstract-provider\r\n */\r\nclass FilterIdSubscriber {\r\n    #provider;\r\n    #filterIdPromise;\r\n    #poller;\r\n    #running;\r\n    #network;\r\n    #hault;\r\n    /**\r\n     *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\r\n     *  and [[_emitResults]] to setup the subscription and provide the event\r\n     *  to the %%provider%%.\r\n     */\r\n    constructor(provider) {\r\n        this.#provider = provider;\r\n        this.#filterIdPromise = null;\r\n        this.#poller = this.#poll.bind(this);\r\n        this.#running = false;\r\n        this.#network = null;\r\n        this.#hault = false;\r\n    }\r\n    /**\r\n     *  Sub-classes **must** override this to begin the subscription.\r\n     */\r\n    _subscribe(provider) {\r\n        throw new Error(\"subclasses must override this\");\r\n    }\r\n    /**\r\n     *  Sub-classes **must** override this handle the events.\r\n     */\r\n    _emitResults(provider, result) {\r\n        throw new Error(\"subclasses must override this\");\r\n    }\r\n    /**\r\n     *  Sub-classes **must** override this handle recovery on errors.\r\n     */\r\n    _recover(provider) {\r\n        throw new Error(\"subclasses must override this\");\r\n    }\r\n    async #poll(blockNumber) {\r\n        try {\r\n            // Subscribe if necessary\r\n            if (this.#filterIdPromise == null) {\r\n                this.#filterIdPromise = this._subscribe(this.#provider);\r\n            }\r\n            // Get the Filter ID\r\n            let filterId = null;\r\n            try {\r\n                filterId = await this.#filterIdPromise;\r\n            }\r\n            catch (error) {\r\n                if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\r\n                    throw error;\r\n                }\r\n            }\r\n            // The backend does not support Filter ID; downgrade to\r\n            // polling\r\n            if (filterId == null) {\r\n                this.#filterIdPromise = null;\r\n                this.#provider._recoverSubscriber(this, this._recover(this.#provider));\r\n                return;\r\n            }\r\n            const network = await this.#provider.getNetwork();\r\n            if (!this.#network) {\r\n                this.#network = network;\r\n            }\r\n            if (this.#network.chainId !== network.chainId) {\r\n                throw new Error(\"chaid changed\");\r\n            }\r\n            if (this.#hault) {\r\n                return;\r\n            }\r\n            const result = await this.#provider.send(\"eth_getFilterChanges\", [filterId]);\r\n            await this._emitResults(this.#provider, result);\r\n        }\r\n        catch (error) {\r\n            console.log(\"@TODO\", error);\r\n        }\r\n        this.#provider.once(\"block\", this.#poller);\r\n    }\r\n    #teardown() {\r\n        const filterIdPromise = this.#filterIdPromise;\r\n        if (filterIdPromise) {\r\n            this.#filterIdPromise = null;\r\n            filterIdPromise.then((filterId) => {\r\n                if (this.#provider.destroyed) {\r\n                    return;\r\n                }\r\n                this.#provider.send(\"eth_uninstallFilter\", [filterId]);\r\n            });\r\n        }\r\n    }\r\n    start() {\r\n        if (this.#running) {\r\n            return;\r\n        }\r\n        this.#running = true;\r\n        this.#poll(-2);\r\n    }\r\n    stop() {\r\n        if (!this.#running) {\r\n            return;\r\n        }\r\n        this.#running = false;\r\n        this.#hault = true;\r\n        this.#teardown();\r\n        this.#provider.off(\"block\", this.#poller);\r\n    }\r\n    pause(dropWhilePaused) {\r\n        if (dropWhilePaused) {\r\n            this.#teardown();\r\n        }\r\n        this.#provider.off(\"block\", this.#poller);\r\n    }\r\n    resume() { this.start(); }\r\n}\r\n/**\r\n *  A **FilterIdSubscriber** for receiving contract events.\r\n *\r\n *  @_docloc: api/providers/abstract-provider\r\n */\r\nclass FilterIdEventSubscriber extends FilterIdSubscriber {\r\n    #event;\r\n    /**\r\n     *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\r\n     *  listening for %%filter%%.\r\n     */\r\n    constructor(provider, filter) {\r\n        super(provider);\r\n        this.#event = copy(filter);\r\n    }\r\n    _recover(provider) {\r\n        return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_1__.PollingEventSubscriber(provider, this.#event);\r\n    }\r\n    async _subscribe(provider) {\r\n        const filterId = await provider.send(\"eth_newFilter\", [this.#event]);\r\n        return filterId;\r\n    }\r\n    async _emitResults(provider, results) {\r\n        for (const result of results) {\r\n            provider.emit(this.#event, provider._wrapLog(result, provider._network));\r\n        }\r\n    }\r\n}\r\n/**\r\n *  A **FilterIdSubscriber** for receiving pending transactions events.\r\n *\r\n *  @_docloc: api/providers/abstract-provider\r\n */\r\nclass FilterIdPendingSubscriber extends FilterIdSubscriber {\r\n    async _subscribe(provider) {\r\n        return await provider.send(\"eth_newPendingTransactionFilter\", []);\r\n    }\r\n    async _emitResults(provider, results) {\r\n        for (const result of results) {\r\n            provider.emit(\"pending\", result);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=subscriber-filterid.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvc3Vic2NyaWJlci1maWx0ZXJpZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE0QztBQUNxQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwRUFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHByb3ZpZGVyc1xcc3Vic2NyaWJlci1maWx0ZXJpZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0Vycm9yIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IFBvbGxpbmdFdmVudFN1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLXBvbGxpbmcuanNcIjtcclxuZnVuY3Rpb24gY29weShvYmopIHtcclxuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xyXG59XHJcbi8qKlxyXG4gKiAgU29tZSBiYWNrZW5kcyBzdXBwb3J0IHN1YnNjcmliaW5nIHRvIGV2ZW50cyB1c2luZyBhIEZpbHRlciBJRC5cclxuICpcclxuICogIFdoZW4gc3Vic2NyaWJpbmcgd2l0aCB0aGlzIHRlY2huaXF1ZSwgdGhlIG5vZGUgaXNzdWVzIGEgdW5pcXVlXHJcbiAqICAvL0ZpbHRlciBJRC8vLiBBdCB0aGlzIHBvaW50IHRoZSBub2RlIGRlZGljYXRlcyByZXNvdXJjZXMgdG9cclxuICogIHRoZSBmaWx0ZXIsIHNvIHRoYXQgcGVyaW9kaWMgY2FsbHMgdG8gZm9sbG93IHVwIG9uIHRoZSAvL0ZpbHRlciBJRC8vXHJcbiAqICB3aWxsIHJlY2VpdmUgYW55IGV2ZW50cyBzaW5jZSB0aGUgbGFzdCBjYWxsLlxyXG4gKlxyXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcclxuICovXHJcbmV4cG9ydCBjbGFzcyBGaWx0ZXJJZFN1YnNjcmliZXIge1xyXG4gICAgI3Byb3ZpZGVyO1xyXG4gICAgI2ZpbHRlcklkUHJvbWlzZTtcclxuICAgICNwb2xsZXI7XHJcbiAgICAjcnVubmluZztcclxuICAgICNuZXR3b3JrO1xyXG4gICAgI2hhdWx0O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZpbHRlcklkU3Vic2NyaWJlcioqIHdoaWNoIHdpbGwgdXNlZCBbW19zdWJzY3JpYmVdXVxyXG4gICAgICogIGFuZCBbW19lbWl0UmVzdWx0c11dIHRvIHNldHVwIHRoZSBzdWJzY3JpcHRpb24gYW5kIHByb3ZpZGUgdGhlIGV2ZW50XHJcbiAgICAgKiAgdG8gdGhlICUlcHJvdmlkZXIlJS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy4jcG9sbGVyID0gdGhpcy4jcG9sbC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLiNuZXR3b3JrID0gbnVsbDtcclxuICAgICAgICB0aGlzLiNoYXVsdCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcyB0byBiZWdpbiB0aGUgc3Vic2NyaXB0aW9uLlxyXG4gICAgICovXHJcbiAgICBfc3Vic2NyaWJlKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzIGhhbmRsZSB0aGUgZXZlbnRzLlxyXG4gICAgICovXHJcbiAgICBfZW1pdFJlc3VsdHMocHJvdmlkZXIsIHJlc3VsdCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcyBoYW5kbGUgcmVjb3Zlcnkgb24gZXJyb3JzLlxyXG4gICAgICovXHJcbiAgICBfcmVjb3Zlcihwcm92aWRlcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzXCIpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgI3BvbGwoYmxvY2tOdW1iZXIpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgICAgIGlmICh0aGlzLiNmaWx0ZXJJZFByb21pc2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4jZmlsdGVySWRQcm9taXNlID0gdGhpcy5fc3Vic2NyaWJlKHRoaXMuI3Byb3ZpZGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIEZpbHRlciBJRFxyXG4gICAgICAgICAgICBsZXQgZmlsdGVySWQgPSBudWxsO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVySWQgPSBhd2FpdCB0aGlzLiNmaWx0ZXJJZFByb21pc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRXJyb3IoZXJyb3IsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIpIHx8IGVycm9yLm9wZXJhdGlvbiAhPT0gXCJldGhfbmV3RmlsdGVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUaGUgYmFja2VuZCBkb2VzIG5vdCBzdXBwb3J0IEZpbHRlciBJRDsgZG93bmdyYWRlIHRvXHJcbiAgICAgICAgICAgIC8vIHBvbGxpbmdcclxuICAgICAgICAgICAgaWYgKGZpbHRlcklkID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiNwcm92aWRlci5fcmVjb3ZlclN1YnNjcmliZXIodGhpcywgdGhpcy5fcmVjb3Zlcih0aGlzLiNwcm92aWRlcikpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5nZXROZXR3b3JrKCk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy4jbmV0d29yaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4jbmV0d29yayA9IG5ldHdvcms7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuI25ldHdvcmsuY2hhaW5JZCAhPT0gbmV0d29yay5jaGFpbklkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaGFpZCBjaGFuZ2VkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLiNoYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI3Byb3ZpZGVyLnNlbmQoXCJldGhfZ2V0RmlsdGVyQ2hhbmdlc1wiLCBbZmlsdGVySWRdKTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fZW1pdFJlc3VsdHModGhpcy4jcHJvdmlkZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkBUT0RPXCIsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub25jZShcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XHJcbiAgICB9XHJcbiAgICAjdGVhcmRvd24oKSB7XHJcbiAgICAgICAgY29uc3QgZmlsdGVySWRQcm9taXNlID0gdGhpcy4jZmlsdGVySWRQcm9taXNlO1xyXG4gICAgICAgIGlmIChmaWx0ZXJJZFByb21pc2UpIHtcclxuICAgICAgICAgICAgdGhpcy4jZmlsdGVySWRQcm9taXNlID0gbnVsbDtcclxuICAgICAgICAgICAgZmlsdGVySWRQcm9taXNlLnRoZW4oKGZpbHRlcklkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jcHJvdmlkZXIuZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuc2VuZChcImV0aF91bmluc3RhbGxGaWx0ZXJcIiwgW2ZpbHRlcklkXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLiNydW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy4jcG9sbCgtMik7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIGlmICghdGhpcy4jcnVubmluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLiNoYXVsdCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy4jdGVhcmRvd24oKTtcclxuICAgICAgICB0aGlzLiNwcm92aWRlci5vZmYoXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xyXG4gICAgfVxyXG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XHJcbiAgICAgICAgaWYgKGRyb3BXaGlsZVBhdXNlZCkge1xyXG4gICAgICAgICAgICB0aGlzLiN0ZWFyZG93bigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiNwcm92aWRlci5vZmYoXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xyXG4gICAgfVxyXG4gICAgcmVzdW1lKCkgeyB0aGlzLnN0YXJ0KCk7IH1cclxufVxyXG4vKipcclxuICogIEEgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiBmb3IgcmVjZWl2aW5nIGNvbnRyYWN0IGV2ZW50cy5cclxuICpcclxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRmlsdGVySWRFdmVudFN1YnNjcmliZXIgZXh0ZW5kcyBGaWx0ZXJJZFN1YnNjcmliZXIge1xyXG4gICAgI2V2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZpbHRlcklkRXZlbnRTdWJzY3JpYmVyKiogYXR0YWNoZWQgdG8gJSVwcm92aWRlciUlXHJcbiAgICAgKiAgbGlzdGVuaW5nIGZvciAlJWZpbHRlciUlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZmlsdGVyKSB7XHJcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xyXG4gICAgICAgIHRoaXMuI2V2ZW50ID0gY29weShmaWx0ZXIpO1xyXG4gICAgfVxyXG4gICAgX3JlY292ZXIocHJvdmlkZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdFdmVudFN1YnNjcmliZXIocHJvdmlkZXIsIHRoaXMuI2V2ZW50KTtcclxuICAgIH1cclxuICAgIGFzeW5jIF9zdWJzY3JpYmUocHJvdmlkZXIpIHtcclxuICAgICAgICBjb25zdCBmaWx0ZXJJZCA9IGF3YWl0IHByb3ZpZGVyLnNlbmQoXCJldGhfbmV3RmlsdGVyXCIsIFt0aGlzLiNldmVudF0pO1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXJJZDtcclxuICAgIH1cclxuICAgIGFzeW5jIF9lbWl0UmVzdWx0cyhwcm92aWRlciwgcmVzdWx0cykge1xyXG4gICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdCh0aGlzLiNldmVudCwgcHJvdmlkZXIuX3dyYXBMb2cocmVzdWx0LCBwcm92aWRlci5fbmV0d29yaykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEEgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiBmb3IgcmVjZWl2aW5nIHBlbmRpbmcgdHJhbnNhY3Rpb25zIGV2ZW50cy5cclxuICpcclxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlciBleHRlbmRzIEZpbHRlcklkU3Vic2NyaWJlciB7XHJcbiAgICBhc3luYyBfc3Vic2NyaWJlKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLnNlbmQoXCJldGhfbmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyXCIsIFtdKTtcclxuICAgIH1cclxuICAgIGFzeW5jIF9lbWl0UmVzdWx0cyhwcm92aWRlciwgcmVzdWx0cykge1xyXG4gICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdChcInBlbmRpbmdcIiwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJlci1maWx0ZXJpZC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/subscriber-filterid.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/subscriber-polling.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OnBlockSubscriber: () => (/* binding */ OnBlockSubscriber),\n/* harmony export */   PollingBlockSubscriber: () => (/* binding */ PollingBlockSubscriber),\n/* harmony export */   PollingBlockTagSubscriber: () => (/* binding */ PollingBlockTagSubscriber),\n/* harmony export */   PollingEventSubscriber: () => (/* binding */ PollingEventSubscriber),\n/* harmony export */   PollingOrphanSubscriber: () => (/* binding */ PollingOrphanSubscriber),\n/* harmony export */   PollingTransactionSubscriber: () => (/* binding */ PollingTransactionSubscriber),\n/* harmony export */   getPollingSubscriber: () => (/* binding */ getPollingSubscriber)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n\r\nfunction copy(obj) {\r\n    return JSON.parse(JSON.stringify(obj));\r\n}\r\n/**\r\n *  Return the polling subscriber for common events.\r\n *\r\n *  @_docloc: api/providers/abstract-provider\r\n */\r\nfunction getPollingSubscriber(provider, event) {\r\n    if (event === \"block\") {\r\n        return new PollingBlockSubscriber(provider);\r\n    }\r\n    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(event, 32)) {\r\n        return new PollingTransactionSubscriber(provider, event);\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\r\n        operation: \"getPollingSubscriber\", info: { event }\r\n    });\r\n}\r\n// @TODO: refactor this\r\n/**\r\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\r\n *  in the block number.\r\n *\r\n *  @_docloc: api/providers/abstract-provider\r\n */\r\nclass PollingBlockSubscriber {\r\n    #provider;\r\n    #poller;\r\n    #interval;\r\n    // The most recent block we have scanned for events. The value -2\r\n    // indicates we still need to fetch an initial block number\r\n    #blockNumber;\r\n    /**\r\n     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\r\n     */\r\n    constructor(provider) {\r\n        this.#provider = provider;\r\n        this.#poller = null;\r\n        this.#interval = 4000;\r\n        this.#blockNumber = -2;\r\n    }\r\n    /**\r\n     *  The polling interval.\r\n     */\r\n    get pollingInterval() { return this.#interval; }\r\n    set pollingInterval(value) { this.#interval = value; }\r\n    async #poll() {\r\n        try {\r\n            const blockNumber = await this.#provider.getBlockNumber();\r\n            // Bootstrap poll to setup our initial block number\r\n            if (this.#blockNumber === -2) {\r\n                this.#blockNumber = blockNumber;\r\n                return;\r\n            }\r\n            // @TODO: Put a cap on the maximum number of events per loop?\r\n            if (blockNumber !== this.#blockNumber) {\r\n                for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\r\n                    // We have been stopped\r\n                    if (this.#poller == null) {\r\n                        return;\r\n                    }\r\n                    await this.#provider.emit(\"block\", b);\r\n                }\r\n                this.#blockNumber = blockNumber;\r\n            }\r\n        }\r\n        catch (error) {\r\n            // @TODO: Minor bump, add an \"error\" event to let subscribers\r\n            //        know things went awry.\r\n            //console.log(error);\r\n        }\r\n        // We have been stopped\r\n        if (this.#poller == null) {\r\n            return;\r\n        }\r\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\r\n    }\r\n    start() {\r\n        if (this.#poller) {\r\n            return;\r\n        }\r\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\r\n        this.#poll();\r\n    }\r\n    stop() {\r\n        if (!this.#poller) {\r\n            return;\r\n        }\r\n        this.#provider._clearTimeout(this.#poller);\r\n        this.#poller = null;\r\n    }\r\n    pause(dropWhilePaused) {\r\n        this.stop();\r\n        if (dropWhilePaused) {\r\n            this.#blockNumber = -2;\r\n        }\r\n    }\r\n    resume() {\r\n        this.start();\r\n    }\r\n}\r\n/**\r\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\r\n *  implmentation which will be called on every new block.\r\n *\r\n *  @_docloc: api/providers/abstract-provider\r\n */\r\nclass OnBlockSubscriber {\r\n    #provider;\r\n    #poll;\r\n    #running;\r\n    /**\r\n     *  Create a new **OnBlockSubscriber** attached to %%provider%%.\r\n     */\r\n    constructor(provider) {\r\n        this.#provider = provider;\r\n        this.#running = false;\r\n        this.#poll = (blockNumber) => {\r\n            this._poll(blockNumber, this.#provider);\r\n        };\r\n    }\r\n    /**\r\n     *  Called on every new block.\r\n     */\r\n    async _poll(blockNumber, provider) {\r\n        throw new Error(\"sub-classes must override this\");\r\n    }\r\n    start() {\r\n        if (this.#running) {\r\n            return;\r\n        }\r\n        this.#running = true;\r\n        this.#poll(-2);\r\n        this.#provider.on(\"block\", this.#poll);\r\n    }\r\n    stop() {\r\n        if (!this.#running) {\r\n            return;\r\n        }\r\n        this.#running = false;\r\n        this.#provider.off(\"block\", this.#poll);\r\n    }\r\n    pause(dropWhilePaused) { this.stop(); }\r\n    resume() { this.start(); }\r\n}\r\nclass PollingBlockTagSubscriber extends OnBlockSubscriber {\r\n    #tag;\r\n    #lastBlock;\r\n    constructor(provider, tag) {\r\n        super(provider);\r\n        this.#tag = tag;\r\n        this.#lastBlock = -2;\r\n    }\r\n    pause(dropWhilePaused) {\r\n        if (dropWhilePaused) {\r\n            this.#lastBlock = -2;\r\n        }\r\n        super.pause(dropWhilePaused);\r\n    }\r\n    async _poll(blockNumber, provider) {\r\n        const block = await provider.getBlock(this.#tag);\r\n        if (block == null) {\r\n            return;\r\n        }\r\n        if (this.#lastBlock === -2) {\r\n            this.#lastBlock = block.number;\r\n        }\r\n        else if (block.number > this.#lastBlock) {\r\n            provider.emit(this.#tag, block.number);\r\n            this.#lastBlock = block.number;\r\n        }\r\n    }\r\n}\r\n/**\r\n *  @_ignore:\r\n *\r\n *  @_docloc: api/providers/abstract-provider\r\n */\r\nclass PollingOrphanSubscriber extends OnBlockSubscriber {\r\n    #filter;\r\n    constructor(provider, filter) {\r\n        super(provider);\r\n        this.#filter = copy(filter);\r\n    }\r\n    async _poll(blockNumber, provider) {\r\n        throw new Error(\"@TODO\");\r\n        console.log(this.#filter);\r\n    }\r\n}\r\n/**\r\n *  A **PollingTransactionSubscriber** will poll for a given transaction\r\n *  hash for its receipt.\r\n *\r\n *  @_docloc: api/providers/abstract-provider\r\n */\r\nclass PollingTransactionSubscriber extends OnBlockSubscriber {\r\n    #hash;\r\n    /**\r\n     *  Create a new **PollingTransactionSubscriber** attached to\r\n     *  %%provider%%, listening for %%hash%%.\r\n     */\r\n    constructor(provider, hash) {\r\n        super(provider);\r\n        this.#hash = hash;\r\n    }\r\n    async _poll(blockNumber, provider) {\r\n        const tx = await provider.getTransactionReceipt(this.#hash);\r\n        if (tx) {\r\n            provider.emit(this.#hash, tx);\r\n        }\r\n    }\r\n}\r\n/**\r\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\r\n *\r\n *  @_docloc: api/providers/abstract-provider\r\n */\r\nclass PollingEventSubscriber {\r\n    #provider;\r\n    #filter;\r\n    #poller;\r\n    #running;\r\n    // The most recent block we have scanned for events. The value -2\r\n    // indicates we still need to fetch an initial block number\r\n    #blockNumber;\r\n    /**\r\n     *  Create a new **PollingTransactionSubscriber** attached to\r\n     *  %%provider%%, listening for %%filter%%.\r\n     */\r\n    constructor(provider, filter) {\r\n        this.#provider = provider;\r\n        this.#filter = copy(filter);\r\n        this.#poller = this.#poll.bind(this);\r\n        this.#running = false;\r\n        this.#blockNumber = -2;\r\n    }\r\n    async #poll(blockNumber) {\r\n        // The initial block hasn't been determined yet\r\n        if (this.#blockNumber === -2) {\r\n            return;\r\n        }\r\n        const filter = copy(this.#filter);\r\n        filter.fromBlock = this.#blockNumber + 1;\r\n        filter.toBlock = blockNumber;\r\n        const logs = await this.#provider.getLogs(filter);\r\n        // No logs could just mean the node has not indexed them yet,\r\n        // so we keep a sliding window of 60 blocks to keep scanning\r\n        if (logs.length === 0) {\r\n            if (this.#blockNumber < blockNumber - 60) {\r\n                this.#blockNumber = blockNumber - 60;\r\n            }\r\n            return;\r\n        }\r\n        for (const log of logs) {\r\n            this.#provider.emit(this.#filter, log);\r\n            // Only advance the block number when logs were found to\r\n            // account for networks (like BNB and Polygon) which may\r\n            // sacrifice event consistency for block event speed\r\n            this.#blockNumber = log.blockNumber;\r\n        }\r\n    }\r\n    start() {\r\n        if (this.#running) {\r\n            return;\r\n        }\r\n        this.#running = true;\r\n        if (this.#blockNumber === -2) {\r\n            this.#provider.getBlockNumber().then((blockNumber) => {\r\n                this.#blockNumber = blockNumber;\r\n            });\r\n        }\r\n        this.#provider.on(\"block\", this.#poller);\r\n    }\r\n    stop() {\r\n        if (!this.#running) {\r\n            return;\r\n        }\r\n        this.#running = false;\r\n        this.#provider.off(\"block\", this.#poller);\r\n    }\r\n    pause(dropWhilePaused) {\r\n        this.stop();\r\n        if (dropWhilePaused) {\r\n            this.#blockNumber = -2;\r\n        }\r\n    }\r\n    resume() {\r\n        this.start();\r\n    }\r\n}\r\n//# sourceMappingURL=subscriber-polling.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvc3Vic2NyaWJlci1wb2xsaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQVc7QUFDbkI7QUFDQTtBQUNBLElBQUksdURBQU07QUFDVixtREFBbUQ7QUFDbkQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGVBQWU7QUFDZjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxwcm92aWRlcnNcXHN1YnNjcmliZXItcG9sbGluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NlcnQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmZ1bmN0aW9uIGNvcHkob2JqKSB7XHJcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcclxufVxyXG4vKipcclxuICogIFJldHVybiB0aGUgcG9sbGluZyBzdWJzY3JpYmVyIGZvciBjb21tb24gZXZlbnRzLlxyXG4gKlxyXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQb2xsaW5nU3Vic2NyaWJlcihwcm92aWRlciwgZXZlbnQpIHtcclxuICAgIGlmIChldmVudCA9PT0gXCJibG9ja1wiKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKHByb3ZpZGVyKTtcclxuICAgIH1cclxuICAgIGlmIChpc0hleFN0cmluZyhldmVudCwgMzIpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKHByb3ZpZGVyLCBldmVudCk7XHJcbiAgICB9XHJcbiAgICBhc3NlcnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgcG9sbGluZyBldmVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgb3BlcmF0aW9uOiBcImdldFBvbGxpbmdTdWJzY3JpYmVyXCIsIGluZm86IHsgZXZlbnQgfVxyXG4gICAgfSk7XHJcbn1cclxuLy8gQFRPRE86IHJlZmFjdG9yIHRoaXNcclxuLyoqXHJcbiAqICBBICoqUG9sbGluZ0Jsb2NrU3Vic2NyaWJlcioqIHBvbGxzIGF0IGEgcmVndWxhciBpbnRlcnZhbCBmb3IgYSBjaGFuZ2VcclxuICogIGluIHRoZSBibG9jayBudW1iZXIuXHJcbiAqXHJcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBvbGxpbmdCbG9ja1N1YnNjcmliZXIge1xyXG4gICAgI3Byb3ZpZGVyO1xyXG4gICAgI3BvbGxlcjtcclxuICAgICNpbnRlcnZhbDtcclxuICAgIC8vIFRoZSBtb3N0IHJlY2VudCBibG9jayB3ZSBoYXZlIHNjYW5uZWQgZm9yIGV2ZW50cy4gVGhlIHZhbHVlIC0yXHJcbiAgICAvLyBpbmRpY2F0ZXMgd2Ugc3RpbGwgbmVlZCB0byBmZXRjaCBhbiBpbml0aWFsIGJsb2NrIG51bWJlclxyXG4gICAgI2Jsb2NrTnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqUG9sbGluZ0Jsb2NrU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvICUlcHJvdmlkZXIlJS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuI3BvbGxlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy4jaW50ZXJ2YWwgPSA0MDAwO1xyXG4gICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgcG9sbGluZyBpbnRlcnZhbC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHsgcmV0dXJuIHRoaXMuI2ludGVydmFsOyB9XHJcbiAgICBzZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKSB7IHRoaXMuI2ludGVydmFsID0gdmFsdWU7IH1cclxuICAgIGFzeW5jICNwb2xsKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcclxuICAgICAgICAgICAgLy8gQm9vdHN0cmFwIHBvbGwgdG8gc2V0dXAgb3VyIGluaXRpYWwgYmxvY2sgbnVtYmVyXHJcbiAgICAgICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA9PT0gLTIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQFRPRE86IFB1dCBhIGNhcCBvbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgZXZlbnRzIHBlciBsb29wP1xyXG4gICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgIT09IHRoaXMuI2Jsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiID0gdGhpcy4jYmxvY2tOdW1iZXIgKyAxOyBiIDw9IGJsb2NrTnVtYmVyOyBiKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGJlZW4gc3RvcHBlZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNwb2xsZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Byb3ZpZGVyLmVtaXQoXCJibG9ja1wiLCBiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIC8vIEBUT0RPOiBNaW5vciBidW1wLCBhZGQgYW4gXCJlcnJvclwiIGV2ZW50IHRvIGxldCBzdWJzY3JpYmVyc1xyXG4gICAgICAgICAgICAvLyAgICAgICAga25vdyB0aGluZ3Mgd2VudCBhd3J5LlxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2UgaGF2ZSBiZWVuIHN0b3BwZWRcclxuICAgICAgICBpZiAodGhpcy4jcG9sbGVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwcm92aWRlci5fc2V0VGltZW91dCh0aGlzLiNwb2xsLmJpbmQodGhpcyksIHRoaXMuI2ludGVydmFsKTtcclxuICAgIH1cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLiNwb2xsZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwcm92aWRlci5fc2V0VGltZW91dCh0aGlzLiNwb2xsLmJpbmQodGhpcyksIHRoaXMuI2ludGVydmFsKTtcclxuICAgICAgICB0aGlzLiNwb2xsKCk7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIGlmICghdGhpcy4jcG9sbGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIuX2NsZWFyVGltZW91dCh0aGlzLiNwb2xsZXIpO1xyXG4gICAgICAgIHRoaXMuI3BvbGxlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHtcclxuICAgICAgICB0aGlzLnN0b3AoKTtcclxuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzdW1lKCkge1xyXG4gICAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEFuICoqT25CbG9ja1N1YnNjcmliZXIqKiBjYW4gYmUgc3ViLWNsYXNzZWQsIHdpdGggYSBbW19wb2xsXV1cclxuICogIGltcGxtZW50YXRpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgb24gZXZlcnkgbmV3IGJsb2NrLlxyXG4gKlxyXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcclxuICovXHJcbmV4cG9ydCBjbGFzcyBPbkJsb2NrU3Vic2NyaWJlciB7XHJcbiAgICAjcHJvdmlkZXI7XHJcbiAgICAjcG9sbDtcclxuICAgICNydW5uaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqT25CbG9ja1N1YnNjcmliZXIqKiBhdHRhY2hlZCB0byAlJXByb3ZpZGVyJSUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIgPSBwcm92aWRlcjtcclxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy4jcG9sbCA9IChibG9ja051bWJlcikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9wb2xsKGJsb2NrTnVtYmVyLCB0aGlzLiNwcm92aWRlcik7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENhbGxlZCBvbiBldmVyeSBuZXcgYmxvY2suXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1Yi1jbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcclxuICAgIH1cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLiNydW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy4jcG9sbCgtMik7XHJcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub24oXCJibG9ja1wiLCB0aGlzLiNwb2xsKTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGwpO1xyXG4gICAgfVxyXG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7IHRoaXMuc3RvcCgpOyB9XHJcbiAgICByZXN1bWUoKSB7IHRoaXMuc3RhcnQoKTsgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBQb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyIGV4dGVuZHMgT25CbG9ja1N1YnNjcmliZXIge1xyXG4gICAgI3RhZztcclxuICAgICNsYXN0QmxvY2s7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgdGFnKSB7XHJcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xyXG4gICAgICAgIHRoaXMuI3RhZyA9IHRhZztcclxuICAgICAgICB0aGlzLiNsYXN0QmxvY2sgPSAtMjtcclxuICAgIH1cclxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xyXG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcclxuICAgICAgICAgICAgdGhpcy4jbGFzdEJsb2NrID0gLTI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyLnBhdXNlKGRyb3BXaGlsZVBhdXNlZCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcclxuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHByb3ZpZGVyLmdldEJsb2NrKHRoaXMuI3RhZyk7XHJcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy4jbGFzdEJsb2NrID09PSAtMikge1xyXG4gICAgICAgICAgICB0aGlzLiNsYXN0QmxvY2sgPSBibG9jay5udW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGJsb2NrLm51bWJlciA+IHRoaXMuI2xhc3RCbG9jaykge1xyXG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KHRoaXMuI3RhZywgYmxvY2subnVtYmVyKTtcclxuICAgICAgICAgICAgdGhpcy4jbGFzdEJsb2NrID0gYmxvY2subnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEBfaWdub3JlOlxyXG4gKlxyXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcclxuICovXHJcbmV4cG9ydCBjbGFzcyBQb2xsaW5nT3JwaGFuU3Vic2NyaWJlciBleHRlbmRzIE9uQmxvY2tTdWJzY3JpYmVyIHtcclxuICAgICNmaWx0ZXI7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZmlsdGVyKSB7XHJcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xyXG4gICAgICAgIHRoaXMuI2ZpbHRlciA9IGNvcHkoZmlsdGVyKTtcclxuICAgIH1cclxuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuI2ZpbHRlcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBBICoqUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcioqIHdpbGwgcG9sbCBmb3IgYSBnaXZlbiB0cmFuc2FjdGlvblxyXG4gKiAgaGFzaCBmb3IgaXRzIHJlY2VpcHQuXHJcbiAqXHJcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIgZXh0ZW5kcyBPbkJsb2NrU3Vic2NyaWJlciB7XHJcbiAgICAjaGFzaDtcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIqKiBhdHRhY2hlZCB0b1xyXG4gICAgICogICUlcHJvdmlkZXIlJSwgbGlzdGVuaW5nIGZvciAlJWhhc2glJS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGhhc2gpIHtcclxuICAgICAgICBzdXBlcihwcm92aWRlcik7XHJcbiAgICAgICAgdGhpcy4jaGFzaCA9IGhhc2g7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcclxuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLiNoYXNoKTtcclxuICAgICAgICBpZiAodHgpIHtcclxuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdCh0aGlzLiNoYXNoLCB0eCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgQSAqKlBvbGxpbmdFdmVudFN1YnNjcmliZXIqKiB3aWxsIHBvbGwgZm9yIGEgZ2l2ZW4gZmlsdGVyIGZvciBpdHMgbG9ncy5cclxuICpcclxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUG9sbGluZ0V2ZW50U3Vic2NyaWJlciB7XHJcbiAgICAjcHJvdmlkZXI7XHJcbiAgICAjZmlsdGVyO1xyXG4gICAgI3BvbGxlcjtcclxuICAgICNydW5uaW5nO1xyXG4gICAgLy8gVGhlIG1vc3QgcmVjZW50IGJsb2NrIHdlIGhhdmUgc2Nhbm5lZCBmb3IgZXZlbnRzLiBUaGUgdmFsdWUgLTJcclxuICAgIC8vIGluZGljYXRlcyB3ZSBzdGlsbCBuZWVkIHRvIGZldGNoIGFuIGluaXRpYWwgYmxvY2sgbnVtYmVyXHJcbiAgICAjYmxvY2tOdW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGUgYSBuZXcgKipQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKiogYXR0YWNoZWQgdG9cclxuICAgICAqICAlJXByb3ZpZGVyJSUsIGxpc3RlbmluZyBmb3IgJSVmaWx0ZXIlJS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xyXG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy4jZmlsdGVyID0gY29weShmaWx0ZXIpO1xyXG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3BvbGwuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSAtMjtcclxuICAgIH1cclxuICAgIGFzeW5jICNwb2xsKGJsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgLy8gVGhlIGluaXRpYWwgYmxvY2sgaGFzbid0IGJlZW4gZGV0ZXJtaW5lZCB5ZXRcclxuICAgICAgICBpZiAodGhpcy4jYmxvY2tOdW1iZXIgPT09IC0yKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZmlsdGVyID0gY29weSh0aGlzLiNmaWx0ZXIpO1xyXG4gICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSB0aGlzLiNibG9ja051bWJlciArIDE7XHJcbiAgICAgICAgZmlsdGVyLnRvQmxvY2sgPSBibG9ja051bWJlcjtcclxuICAgICAgICBjb25zdCBsb2dzID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpO1xyXG4gICAgICAgIC8vIE5vIGxvZ3MgY291bGQganVzdCBtZWFuIHRoZSBub2RlIGhhcyBub3QgaW5kZXhlZCB0aGVtIHlldCxcclxuICAgICAgICAvLyBzbyB3ZSBrZWVwIGEgc2xpZGluZyB3aW5kb3cgb2YgNjAgYmxvY2tzIHRvIGtlZXAgc2Nhbm5pbmdcclxuICAgICAgICBpZiAobG9ncy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyIDwgYmxvY2tOdW1iZXIgLSA2MCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlciAtIDYwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgbG9ncykge1xyXG4gICAgICAgICAgICB0aGlzLiNwcm92aWRlci5lbWl0KHRoaXMuI2ZpbHRlciwgbG9nKTtcclxuICAgICAgICAgICAgLy8gT25seSBhZHZhbmNlIHRoZSBibG9jayBudW1iZXIgd2hlbiBsb2dzIHdlcmUgZm91bmQgdG9cclxuICAgICAgICAgICAgLy8gYWNjb3VudCBmb3IgbmV0d29ya3MgKGxpa2UgQk5CIGFuZCBQb2x5Z29uKSB3aGljaCBtYXlcclxuICAgICAgICAgICAgLy8gc2FjcmlmaWNlIGV2ZW50IGNvbnNpc3RlbmN5IGZvciBibG9jayBldmVudCBzcGVlZFxyXG4gICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGxvZy5ibG9ja051bWJlcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICBpZiAodGhpcy4jcnVubmluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA9PT0gLTIpIHtcclxuICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKChibG9ja051bWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9uKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XHJcbiAgICB9XHJcbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHtcclxuICAgICAgICB0aGlzLnN0b3AoKTtcclxuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzdW1lKCkge1xyXG4gICAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmVyLXBvbGxpbmcuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/ws-browser.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/ws-browser.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocket: () => (/* binding */ _WebSocket)\n/* harmony export */ });\nfunction getGlobal() {\r\n    if (typeof self !== 'undefined') {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined') {\r\n        return window;\r\n    }\r\n    if (typeof global !== 'undefined') {\r\n        return global;\r\n    }\r\n    throw new Error('unable to locate global object');\r\n}\r\n;\r\nconst _WebSocket = getGlobal().WebSocket;\r\n\r\n//# sourceMappingURL=ws-browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvd3MtYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNtQztBQUNuQyIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFxwcm92aWRlcnNcXHdzLWJyb3dzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xyXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWw7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdCcpO1xyXG59XHJcbjtcclxuY29uc3QgX1dlYlNvY2tldCA9IGdldEdsb2JhbCgpLldlYlNvY2tldDtcclxuZXhwb3J0IHsgX1dlYlNvY2tldCBhcyBXZWJTb2NrZXQgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3MtYnJvd3Nlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/ws-browser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/accesslist.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/accesslist.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   accessListify: () => (/* binding */ accessListify)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../address/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n\r\n\r\nfunction accessSetify(addr, storageKeys) {\r\n    return {\r\n        address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(addr),\r\n        storageKeys: storageKeys.map((storageKey, index) => {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(storageKey, 32), \"invalid slot\", `storageKeys[${index}]`, storageKey);\r\n            return storageKey.toLowerCase();\r\n        })\r\n    };\r\n}\r\n/**\r\n *  Returns a [[AccessList]] from any ethers-supported access-list structure.\r\n */\r\nfunction accessListify(value) {\r\n    if (Array.isArray(value)) {\r\n        return value.map((set, index) => {\r\n            if (Array.isArray(set)) {\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(set.length === 2, \"invalid slot set\", `value[${index}]`, set);\r\n                return accessSetify(set[0], set[1]);\r\n            }\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(set != null && typeof (set) === \"object\", \"invalid address-slot set\", \"value\", value);\r\n            return accessSetify(set.address, set.storageKeys);\r\n        });\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(value != null && typeof (value) === \"object\", \"invalid access list\", \"value\", value);\r\n    const result = Object.keys(value).map((addr) => {\r\n        const storageKeys = value[addr].reduce((accum, storageKey) => {\r\n            accum[storageKey] = true;\r\n            return accum;\r\n        }, {});\r\n        return accessSetify(addr, Object.keys(storageKeys).sort());\r\n    });\r\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\r\n    return result;\r\n}\r\n//# sourceMappingURL=accesslist.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi9hY2Nlc3NsaXN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpRDtBQUNlO0FBQ2hFO0FBQ0E7QUFDQSxpQkFBaUIsNkRBQVU7QUFDM0I7QUFDQSxZQUFZLCtEQUFjLENBQUMsNERBQVcsaURBQWlELE1BQU07QUFDN0Y7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFjLGdEQUFnRCxNQUFNO0FBQ3BGO0FBQ0E7QUFDQSxZQUFZLCtEQUFjO0FBQzFCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsSUFBSSwrREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHRyYW5zYWN0aW9uXFxhY2Nlc3NsaXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuZnVuY3Rpb24gYWNjZXNzU2V0aWZ5KGFkZHIsIHN0b3JhZ2VLZXlzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFkZHJlc3M6IGdldEFkZHJlc3MoYWRkciksXHJcbiAgICAgICAgc3RvcmFnZUtleXM6IHN0b3JhZ2VLZXlzLm1hcCgoc3RvcmFnZUtleSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcoc3RvcmFnZUtleSwgMzIpLCBcImludmFsaWQgc2xvdFwiLCBgc3RvcmFnZUtleXNbJHtpbmRleH1dYCwgc3RvcmFnZUtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlS2V5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfSlcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm5zIGEgW1tBY2Nlc3NMaXN0XV0gZnJvbSBhbnkgZXRoZXJzLXN1cHBvcnRlZCBhY2Nlc3MtbGlzdCBzdHJ1Y3R1cmUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWNjZXNzTGlzdGlmeSh2YWx1ZSkge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgoc2V0LCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXQpKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzZXQubGVuZ3RoID09PSAyLCBcImludmFsaWQgc2xvdCBzZXRcIiwgYHZhbHVlWyR7aW5kZXh9XWAsIHNldCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KHNldFswXSwgc2V0WzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzZXQgIT0gbnVsbCAmJiB0eXBlb2YgKHNldCkgPT09IFwib2JqZWN0XCIsIFwiaW52YWxpZCBhZGRyZXNzLXNsb3Qgc2V0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KHNldC5hZGRyZXNzLCBzZXQuc3RvcmFnZUtleXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiwgXCJpbnZhbGlkIGFjY2VzcyBsaXN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmtleXModmFsdWUpLm1hcCgoYWRkcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdmFsdWVbYWRkcl0ucmVkdWNlKChhY2N1bSwgc3RvcmFnZUtleSkgPT4ge1xyXG4gICAgICAgICAgICBhY2N1bVtzdG9yYWdlS2V5XSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcclxuICAgICAgICB9LCB7fSk7XHJcbiAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShhZGRyLCBPYmplY3Qua2V5cyhzdG9yYWdlS2V5cykuc29ydCgpKTtcclxuICAgIH0pO1xyXG4gICAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IChhLmFkZHJlc3MubG9jYWxlQ29tcGFyZShiLmFkZHJlc3MpKSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY2Vzc2xpc3QuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/accesslist.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/address.js":
/*!************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/address.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeAddress: () => (/* binding */ computeAddress),\n/* harmony export */   recoverAddress: () => (/* binding */ recoverAddress)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../crypto/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js\");\n\r\n\r\n/**\r\n *  Returns the address for the %%key%%.\r\n *\r\n *  The key may be any standard form of public key or a private key.\r\n */\r\nfunction computeAddress(key) {\r\n    let pubkey;\r\n    if (typeof (key) === \"string\") {\r\n        pubkey = _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.SigningKey.computePublicKey(key, false);\r\n    }\r\n    else {\r\n        pubkey = key.publicKey;\r\n    }\r\n    return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.keccak256)(\"0x\" + pubkey.substring(4)).substring(26));\r\n}\r\n/**\r\n *  Returns the recovered address for the private key that was\r\n *  used to sign %%digest%% that resulted in %%signature%%.\r\n */\r\nfunction recoverAddress(digest, signature) {\r\n    return computeAddress(_crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.SigningKey.recoverPublicKey(digest, signature));\r\n}\r\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUQ7QUFDVTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2REFBVSxDQUFDLDJEQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDBCQUEwQix3REFBVTtBQUNwQztBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHRyYW5zYWN0aW9uXFxhZGRyZXNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBrZWNjYWsyNTYsIFNpZ25pbmdLZXkgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XHJcbi8qKlxyXG4gKiAgUmV0dXJucyB0aGUgYWRkcmVzcyBmb3IgdGhlICUla2V5JSUuXHJcbiAqXHJcbiAqICBUaGUga2V5IG1heSBiZSBhbnkgc3RhbmRhcmQgZm9ybSBvZiBwdWJsaWMga2V5IG9yIGEgcHJpdmF0ZSBrZXkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUFkZHJlc3Moa2V5KSB7XHJcbiAgICBsZXQgcHVia2V5O1xyXG4gICAgaWYgKHR5cGVvZiAoa2V5KSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHB1YmtleSA9IFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShrZXksIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHB1YmtleSA9IGtleS5wdWJsaWNLZXk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhrZWNjYWsyNTYoXCIweFwiICsgcHVia2V5LnN1YnN0cmluZyg0KSkuc3Vic3RyaW5nKDI2KSk7XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm5zIHRoZSByZWNvdmVyZWQgYWRkcmVzcyBmb3IgdGhlIHByaXZhdGUga2V5IHRoYXQgd2FzXHJcbiAqICB1c2VkIHRvIHNpZ24gJSVkaWdlc3QlJSB0aGF0IHJlc3VsdGVkIGluICUlc2lnbmF0dXJlJSUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlckFkZHJlc3MoZGlnZXN0LCBzaWduYXR1cmUpIHtcclxuICAgIHJldHVybiBjb21wdXRlQWRkcmVzcyhTaWduaW5nS2V5LnJlY292ZXJQdWJsaWNLZXkoZGlnZXN0LCBzaWduYXR1cmUpKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/address.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/authorization.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/authorization.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authorizationify: () => (/* binding */ authorizationify)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../address/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n\r\n\r\n\r\nfunction authorizationify(auth) {\r\n    return {\r\n        address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(auth.address),\r\n        nonce: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)((auth.nonce != null) ? auth.nonce : 0),\r\n        chainId: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)((auth.chainId != null) ? auth.chainId : 0),\r\n        signature: _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.Signature.from(auth.signature)\r\n    };\r\n}\r\n//# sourceMappingURL=authorization.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi9hdXRob3JpemF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUQ7QUFDRjtBQUNEO0FBQ3ZDO0FBQ1A7QUFDQSxpQkFBaUIsNkRBQVU7QUFDM0IsZUFBZSwwREFBUztBQUN4QixpQkFBaUIsMERBQVM7QUFDMUIsbUJBQW1CLHVEQUFTO0FBQzVCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFx0cmFuc2FjdGlvblxcYXV0aG9yaXphdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBnZXRCaWdJbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuZXhwb3J0IGZ1bmN0aW9uIGF1dGhvcml6YXRpb25pZnkoYXV0aCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhZGRyZXNzOiBnZXRBZGRyZXNzKGF1dGguYWRkcmVzcyksXHJcbiAgICAgICAgbm9uY2U6IGdldEJpZ0ludCgoYXV0aC5ub25jZSAhPSBudWxsKSA/IGF1dGgubm9uY2UgOiAwKSxcclxuICAgICAgICBjaGFpbklkOiBnZXRCaWdJbnQoKGF1dGguY2hhaW5JZCAhPSBudWxsKSA/IGF1dGguY2hhaW5JZCA6IDApLFxyXG4gICAgICAgIHNpZ25hdHVyZTogU2lnbmF0dXJlLmZyb20oYXV0aC5zaWduYXR1cmUpXHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhvcml6YXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/authorization.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transaction: () => (/* reexport safe */ _transaction_js__WEBPACK_IMPORTED_MODULE_3__.Transaction),\n/* harmony export */   accessListify: () => (/* reexport safe */ _accesslist_js__WEBPACK_IMPORTED_MODULE_0__.accessListify),\n/* harmony export */   authorizationify: () => (/* reexport safe */ _authorization_js__WEBPACK_IMPORTED_MODULE_1__.authorizationify),\n/* harmony export */   computeAddress: () => (/* reexport safe */ _address_js__WEBPACK_IMPORTED_MODULE_2__.computeAddress),\n/* harmony export */   recoverAddress: () => (/* reexport safe */ _address_js__WEBPACK_IMPORTED_MODULE_2__.recoverAddress)\n/* harmony export */ });\n/* harmony import */ var _accesslist_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./accesslist.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _authorization_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./authorization.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/authorization.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./address.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/address.js\");\n/* harmony import */ var _transaction_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transaction.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/transaction.js\");\n/**\r\n *  Each state-changing operation on Ethereum requires a transaction.\r\n *\r\n *  @_section api/transaction:Transactions  [about-transactions]\r\n */\r\nnull;\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZ0Q7QUFDTTtBQUNRO0FBQ2Y7QUFDL0MiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcdHJhbnNhY3Rpb25cXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgRWFjaCBzdGF0ZS1jaGFuZ2luZyBvcGVyYXRpb24gb24gRXRoZXJldW0gcmVxdWlyZXMgYSB0cmFuc2FjdGlvbi5cclxuICpcclxuICogIEBfc2VjdGlvbiBhcGkvdHJhbnNhY3Rpb246VHJhbnNhY3Rpb25zICBbYWJvdXQtdHJhbnNhY3Rpb25zXVxyXG4gKi9cclxubnVsbDtcclxuZXhwb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCIuL2FjY2Vzc2xpc3QuanNcIjtcclxuZXhwb3J0IHsgYXV0aG9yaXphdGlvbmlmeSB9IGZyb20gXCIuL2F1dGhvcml6YXRpb24uanNcIjtcclxuZXhwb3J0IHsgY29tcHV0ZUFkZHJlc3MsIHJlY292ZXJBZGRyZXNzIH0gZnJvbSBcIi4vYWRkcmVzcy5qc1wiO1xyXG5leHBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gXCIuL3RyYW5zYWN0aW9uLmpzXCI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/transaction.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/transaction.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transaction: () => (/* binding */ Transaction)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _constants_addresses_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/addresses.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _accesslist_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./accesslist.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _authorization_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./authorization.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/authorization.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./address.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/address.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst BN_0 = BigInt(0);\r\nconst BN_2 = BigInt(2);\r\nconst BN_27 = BigInt(27);\r\nconst BN_28 = BigInt(28);\r\nconst BN_35 = BigInt(35);\r\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\r\nconst BLOB_SIZE = 4096 * 32;\r\nfunction getKzgLibrary(kzg) {\r\n    const blobToKzgCommitment = (blob) => {\r\n        if (\"computeBlobProof\" in kzg) {\r\n            // micro-ecc-signer; check for computeBlobProof since this API\r\n            // expects a string while the kzg-wasm below expects a Unit8Array\r\n            if (\"blobToKzgCommitment\" in kzg && typeof (kzg.blobToKzgCommitment) === \"function\") {\r\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.blobToKzgCommitment((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob)));\r\n            }\r\n        }\r\n        else if (\"blobToKzgCommitment\" in kzg && typeof (kzg.blobToKzgCommitment) === \"function\") {\r\n            // kzg-wasm <0.5.0; blobToKzgCommitment(Uint8Array) => Uint8Array\r\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.blobToKzgCommitment(blob));\r\n        }\r\n        // kzg-wasm >= 0.5.0; blobToKZGCommitment(string) => string\r\n        if (\"blobToKZGCommitment\" in kzg && typeof (kzg.blobToKZGCommitment) === \"function\") {\r\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.blobToKZGCommitment((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob)));\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported KZG library\", \"kzg\", kzg);\r\n    };\r\n    const computeBlobKzgProof = (blob, commitment) => {\r\n        // micro-ecc-signer\r\n        if (\"computeBlobProof\" in kzg && typeof (kzg.computeBlobProof) === \"function\") {\r\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.computeBlobProof((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(commitment)));\r\n        }\r\n        // kzg-wasm <0.5.0; computeBlobKzgProof(Uint8Array, Uint8Array) => Uint8Array\r\n        if (\"computeBlobKzgProof\" in kzg && typeof (kzg.computeBlobKzgProof) === \"function\") {\r\n            return kzg.computeBlobKzgProof(blob, commitment);\r\n        }\r\n        // kzg-wasm >= 0.5.0; computeBlobKZGProof(string, string) => string\r\n        if (\"computeBlobKZGProof\" in kzg && typeof (kzg.computeBlobKZGProof) === \"function\") {\r\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.computeBlobKZGProof((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(commitment)));\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported KZG library\", \"kzg\", kzg);\r\n    };\r\n    return { blobToKzgCommitment, computeBlobKzgProof };\r\n}\r\nfunction getVersionedHash(version, hash) {\r\n    let versioned = version.toString(16);\r\n    while (versioned.length < 2) {\r\n        versioned = \"0\" + versioned;\r\n    }\r\n    versioned += (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.sha256)(hash).substring(4);\r\n    return \"0x\" + versioned;\r\n}\r\nfunction handleAddress(value) {\r\n    if (value === \"0x\") {\r\n        return null;\r\n    }\r\n    return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)(value);\r\n}\r\nfunction handleAccessList(value, param) {\r\n    try {\r\n        return (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_3__.accessListify)(value);\r\n    }\r\n    catch (error) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, error.message, param, value);\r\n    }\r\n}\r\nfunction handleAuthorizationList(value, param) {\r\n    try {\r\n        if (!Array.isArray(value)) {\r\n            throw new Error(\"authorizationList: invalid array\");\r\n        }\r\n        const result = [];\r\n        for (let i = 0; i < value.length; i++) {\r\n            const auth = value[i];\r\n            if (!Array.isArray(auth)) {\r\n                throw new Error(`authorization[${i}]: invalid array`);\r\n            }\r\n            if (auth.length !== 6) {\r\n                throw new Error(`authorization[${i}]: wrong length`);\r\n            }\r\n            if (!auth[1]) {\r\n                throw new Error(`authorization[${i}]: null address`);\r\n            }\r\n            result.push({\r\n                address: handleAddress(auth[1]),\r\n                nonce: handleUint(auth[2], \"nonce\"),\r\n                chainId: handleUint(auth[0], \"chainId\"),\r\n                signature: _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.Signature.from({\r\n                    yParity: handleNumber(auth[3], \"yParity\"),\r\n                    r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(auth[4], 32),\r\n                    s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(auth[5], 32)\r\n                })\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n    catch (error) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, error.message, param, value);\r\n    }\r\n}\r\nfunction handleNumber(_value, param) {\r\n    if (_value === \"0x\") {\r\n        return 0;\r\n    }\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(_value, param);\r\n}\r\nfunction handleUint(_value, param) {\r\n    if (_value === \"0x\") {\r\n        return BN_0;\r\n    }\r\n    const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(_value, param);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\r\n    return value;\r\n}\r\nfunction formatNumber(_value, name) {\r\n    const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(_value, \"value\");\r\n    const result = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(value);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(result.length <= 32, `value too large`, `tx.${name}`, value);\r\n    return result;\r\n}\r\nfunction formatAccessList(value) {\r\n    return (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_3__.accessListify)(value).map((set) => [set.address, set.storageKeys]);\r\n}\r\nfunction formatAuthorizationList(value) {\r\n    return value.map((a) => {\r\n        return [\r\n            formatNumber(a.chainId, \"chainId\"),\r\n            a.address,\r\n            formatNumber(a.nonce, \"nonce\"),\r\n            formatNumber(a.signature.yParity, \"yParity\"),\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(a.signature.r),\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(a.signature.s)\r\n        ];\r\n    });\r\n}\r\nfunction formatHashes(value, param) {\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(value), `invalid ${param}`, \"value\", value);\r\n    for (let i = 0; i < value.length; i++) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value[i], 32), \"invalid ${ param } hash\", `value[${i}]`, value[i]);\r\n    }\r\n    return value;\r\n}\r\nfunction _parseLegacy(data) {\r\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.decodeRlp)(data);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\r\n    const tx = {\r\n        type: 0,\r\n        nonce: handleNumber(fields[0], \"nonce\"),\r\n        gasPrice: handleUint(fields[1], \"gasPrice\"),\r\n        gasLimit: handleUint(fields[2], \"gasLimit\"),\r\n        to: handleAddress(fields[3]),\r\n        value: handleUint(fields[4], \"value\"),\r\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[5]),\r\n        chainId: BN_0\r\n    };\r\n    // Legacy unsigned transaction\r\n    if (fields.length === 6) {\r\n        return tx;\r\n    }\r\n    const v = handleUint(fields[6], \"v\");\r\n    const r = handleUint(fields[7], \"r\");\r\n    const s = handleUint(fields[8], \"s\");\r\n    if (r === BN_0 && s === BN_0) {\r\n        // EIP-155 unsigned transaction\r\n        tx.chainId = v;\r\n    }\r\n    else {\r\n        // Compute the EIP-155 chain ID (or 0 for legacy)\r\n        let chainId = (v - BN_35) / BN_2;\r\n        if (chainId < BN_0) {\r\n            chainId = BN_0;\r\n        }\r\n        tx.chainId = chainId;\r\n        // Signed Legacy Transaction\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(chainId !== BN_0 || (v === BN_27 || v === BN_28), \"non-canonical legacy v\", \"v\", fields[6]);\r\n        tx.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.Signature.from({\r\n            r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[7], 32),\r\n            s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[8], 32),\r\n            v\r\n        });\r\n        //tx.hash = keccak256(data);\r\n    }\r\n    return tx;\r\n}\r\nfunction _serializeLegacy(tx, sig) {\r\n    const fields = [\r\n        formatNumber(tx.nonce, \"nonce\"),\r\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\r\n        formatNumber(tx.gasLimit, \"gasLimit\"),\r\n        (tx.to || \"0x\"),\r\n        formatNumber(tx.value, \"value\"),\r\n        tx.data,\r\n    ];\r\n    let chainId = BN_0;\r\n    if (tx.chainId != BN_0) {\r\n        // A chainId was provided; if non-zero we'll use EIP-155\r\n        chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(tx.chainId, \"tx.chainId\");\r\n        // We have a chainId in the tx and an EIP-155 v in the signature,\r\n        // make sure they agree with each other\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\r\n    }\r\n    else if (tx.signature) {\r\n        // No explicit chainId, but EIP-155 have a derived implicit chainId\r\n        const legacy = tx.signature.legacyChainId;\r\n        if (legacy != null) {\r\n            chainId = legacy;\r\n        }\r\n    }\r\n    // Requesting an unsigned transaction\r\n    if (!sig) {\r\n        // We have an EIP-155 transaction (chainId was specified and non-zero)\r\n        if (chainId !== BN_0) {\r\n            fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(chainId));\r\n            fields.push(\"0x\");\r\n            fields.push(\"0x\");\r\n        }\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.encodeRlp)(fields);\r\n    }\r\n    // @TODO: We should probably check that tx.signature, chainId, and sig\r\n    //        match but that logic could break existing code, so schedule\r\n    //        this for the next major bump.\r\n    // Compute the EIP-155 v\r\n    let v = BigInt(27 + sig.yParity);\r\n    if (chainId !== BN_0) {\r\n        v = _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.Signature.getChainIdV(chainId, sig.v);\r\n    }\r\n    else if (BigInt(sig.v) !== v) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\r\n    }\r\n    // Add the signature\r\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(v));\r\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(sig.r));\r\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(sig.s));\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.encodeRlp)(fields);\r\n}\r\nfunction _parseEipSignature(tx, fields) {\r\n    let yParity;\r\n    try {\r\n        yParity = handleNumber(fields[0], \"yParity\");\r\n        if (yParity !== 0 && yParity !== 1) {\r\n            throw new Error(\"bad yParity\");\r\n        }\r\n    }\r\n    catch (error) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid yParity\", \"yParity\", fields[0]);\r\n    }\r\n    const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[1], 32);\r\n    const s = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[2], 32);\r\n    const signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.Signature.from({ r, s, yParity });\r\n    tx.signature = signature;\r\n}\r\nfunction _parseEip1559(data) {\r\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\r\n    const tx = {\r\n        type: 2,\r\n        chainId: handleUint(fields[0], \"chainId\"),\r\n        nonce: handleNumber(fields[1], \"nonce\"),\r\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\r\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\r\n        gasPrice: null,\r\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\r\n        to: handleAddress(fields[5]),\r\n        value: handleUint(fields[6], \"value\"),\r\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[7]),\r\n        accessList: handleAccessList(fields[8], \"accessList\"),\r\n    };\r\n    // Unsigned EIP-1559 Transaction\r\n    if (fields.length === 9) {\r\n        return tx;\r\n    }\r\n    //tx.hash = keccak256(data);\r\n    _parseEipSignature(tx, fields.slice(9));\r\n    return tx;\r\n}\r\nfunction _serializeEip1559(tx, sig) {\r\n    const fields = [\r\n        formatNumber(tx.chainId, \"chainId\"),\r\n        formatNumber(tx.nonce, \"nonce\"),\r\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\r\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\r\n        formatNumber(tx.gasLimit, \"gasLimit\"),\r\n        (tx.to || \"0x\"),\r\n        formatNumber(tx.value, \"value\"),\r\n        tx.data,\r\n        formatAccessList(tx.accessList || [])\r\n    ];\r\n    if (sig) {\r\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\r\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(sig.r));\r\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(sig.s));\r\n    }\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\"0x02\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.encodeRlp)(fields)]);\r\n}\r\nfunction _parseEip2930(data) {\r\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\r\n    const tx = {\r\n        type: 1,\r\n        chainId: handleUint(fields[0], \"chainId\"),\r\n        nonce: handleNumber(fields[1], \"nonce\"),\r\n        gasPrice: handleUint(fields[2], \"gasPrice\"),\r\n        gasLimit: handleUint(fields[3], \"gasLimit\"),\r\n        to: handleAddress(fields[4]),\r\n        value: handleUint(fields[5], \"value\"),\r\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[6]),\r\n        accessList: handleAccessList(fields[7], \"accessList\")\r\n    };\r\n    // Unsigned EIP-2930 Transaction\r\n    if (fields.length === 8) {\r\n        return tx;\r\n    }\r\n    //tx.hash = keccak256(data);\r\n    _parseEipSignature(tx, fields.slice(8));\r\n    return tx;\r\n}\r\nfunction _serializeEip2930(tx, sig) {\r\n    const fields = [\r\n        formatNumber(tx.chainId, \"chainId\"),\r\n        formatNumber(tx.nonce, \"nonce\"),\r\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\r\n        formatNumber(tx.gasLimit, \"gasLimit\"),\r\n        (tx.to || \"0x\"),\r\n        formatNumber(tx.value, \"value\"),\r\n        tx.data,\r\n        formatAccessList(tx.accessList || [])\r\n    ];\r\n    if (sig) {\r\n        fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\r\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(sig.r));\r\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(sig.s));\r\n    }\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\"0x01\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.encodeRlp)(fields)]);\r\n}\r\nfunction _parseEip4844(data) {\r\n    let fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\r\n    let typeName = \"3\";\r\n    let blobs = null;\r\n    // Parse the network format\r\n    if (fields.length === 4 && Array.isArray(fields[0])) {\r\n        typeName = \"3 (network format)\";\r\n        const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(fBlobs), \"invalid network format: blobs not an array\", \"fields[1]\", fBlobs);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(fCommits), \"invalid network format: commitments not an array\", \"fields[2]\", fCommits);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(fProofs), \"invalid network format: proofs not an array\", \"fields[3]\", fProofs);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(fBlobs.length === fCommits.length, \"invalid network format: blobs/commitments length mismatch\", \"fields\", fields);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(fBlobs.length === fProofs.length, \"invalid network format: blobs/proofs length mismatch\", \"fields\", fields);\r\n        blobs = [];\r\n        for (let i = 0; i < fields[1].length; i++) {\r\n            blobs.push({\r\n                data: fBlobs[i],\r\n                commitment: fCommits[i],\r\n                proof: fProofs[i],\r\n            });\r\n        }\r\n        fields = fields[0];\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\r\n    const tx = {\r\n        type: 3,\r\n        chainId: handleUint(fields[0], \"chainId\"),\r\n        nonce: handleNumber(fields[1], \"nonce\"),\r\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\r\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\r\n        gasPrice: null,\r\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\r\n        to: handleAddress(fields[5]),\r\n        value: handleUint(fields[6], \"value\"),\r\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[7]),\r\n        accessList: handleAccessList(fields[8], \"accessList\"),\r\n        maxFeePerBlobGas: handleUint(fields[9], \"maxFeePerBlobGas\"),\r\n        blobVersionedHashes: fields[10]\r\n    };\r\n    if (blobs) {\r\n        tx.blobs = blobs;\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(tx.to != null, `invalid address for transaction type: ${typeName}`, \"data\", data);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(tx.blobVersionedHashes), \"invalid blobVersionedHashes: must be an array\", \"data\", data);\r\n    for (let i = 0; i < tx.blobVersionedHashes.length; i++) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, \"data\", data);\r\n    }\r\n    // Unsigned EIP-4844 Transaction\r\n    if (fields.length === 11) {\r\n        return tx;\r\n    }\r\n    // @TODO: Do we need to do this? This is only called internally\r\n    // and used to verify hashes; it might save time to not do this\r\n    //tx.hash = keccak256(concat([ \"0x03\", encodeRlp(fields) ]));\r\n    _parseEipSignature(tx, fields.slice(11));\r\n    return tx;\r\n}\r\nfunction _serializeEip4844(tx, sig, blobs) {\r\n    const fields = [\r\n        formatNumber(tx.chainId, \"chainId\"),\r\n        formatNumber(tx.nonce, \"nonce\"),\r\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\r\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\r\n        formatNumber(tx.gasLimit, \"gasLimit\"),\r\n        (tx.to || _constants_addresses_js__WEBPACK_IMPORTED_MODULE_4__.ZeroAddress),\r\n        formatNumber(tx.value, \"value\"),\r\n        tx.data,\r\n        formatAccessList(tx.accessList || []),\r\n        formatNumber(tx.maxFeePerBlobGas || 0, \"maxFeePerBlobGas\"),\r\n        formatHashes(tx.blobVersionedHashes || [], \"blobVersionedHashes\")\r\n    ];\r\n    if (sig) {\r\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\r\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(sig.r));\r\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(sig.s));\r\n        // We have blobs; return the network wrapped format\r\n        if (blobs) {\r\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\r\n                \"0x03\",\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.encodeRlp)([\r\n                    fields,\r\n                    blobs.map((b) => b.data),\r\n                    blobs.map((b) => b.commitment),\r\n                    blobs.map((b) => b.proof),\r\n                ])\r\n            ]);\r\n        }\r\n    }\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\"0x03\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.encodeRlp)(fields)]);\r\n}\r\nfunction _parseEip7702(data) {\r\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(fields) && (fields.length === 10 || fields.length === 13), \"invalid field count for transaction type: 4\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\r\n    const tx = {\r\n        type: 4,\r\n        chainId: handleUint(fields[0], \"chainId\"),\r\n        nonce: handleNumber(fields[1], \"nonce\"),\r\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\r\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\r\n        gasPrice: null,\r\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\r\n        to: handleAddress(fields[5]),\r\n        value: handleUint(fields[6], \"value\"),\r\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[7]),\r\n        accessList: handleAccessList(fields[8], \"accessList\"),\r\n        authorizationList: handleAuthorizationList(fields[9], \"authorizationList\"),\r\n    };\r\n    // Unsigned EIP-7702 Transaction\r\n    if (fields.length === 10) {\r\n        return tx;\r\n    }\r\n    _parseEipSignature(tx, fields.slice(10));\r\n    return tx;\r\n}\r\nfunction _serializeEip7702(tx, sig) {\r\n    const fields = [\r\n        formatNumber(tx.chainId, \"chainId\"),\r\n        formatNumber(tx.nonce, \"nonce\"),\r\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\r\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\r\n        formatNumber(tx.gasLimit, \"gasLimit\"),\r\n        (tx.to || \"0x\"),\r\n        formatNumber(tx.value, \"value\"),\r\n        tx.data,\r\n        formatAccessList(tx.accessList || []),\r\n        formatAuthorizationList(tx.authorizationList || [])\r\n    ];\r\n    if (sig) {\r\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\r\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(sig.r));\r\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(sig.s));\r\n    }\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\"0x04\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.encodeRlp)(fields)]);\r\n}\r\n/**\r\n *  A **Transaction** describes an operation to be executed on\r\n *  Ethereum by an Externally Owned Account (EOA). It includes\r\n *  who (the [[to]] address), what (the [[data]]) and how much (the\r\n *  [[value]] in ether) the operation should entail.\r\n *\r\n *  @example:\r\n *    tx = new Transaction()\r\n *    //_result:\r\n *\r\n *    tx.data = \"0x1234\";\r\n *    //_result:\r\n */\r\nclass Transaction {\r\n    #type;\r\n    #to;\r\n    #data;\r\n    #nonce;\r\n    #gasLimit;\r\n    #gasPrice;\r\n    #maxPriorityFeePerGas;\r\n    #maxFeePerGas;\r\n    #value;\r\n    #chainId;\r\n    #sig;\r\n    #accessList;\r\n    #maxFeePerBlobGas;\r\n    #blobVersionedHashes;\r\n    #kzg;\r\n    #blobs;\r\n    #auths;\r\n    /**\r\n     *  The transaction type.\r\n     *\r\n     *  If null, the type will be automatically inferred based on\r\n     *  explicit properties.\r\n     */\r\n    get type() { return this.#type; }\r\n    set type(value) {\r\n        switch (value) {\r\n            case null:\r\n                this.#type = null;\r\n                break;\r\n            case 0:\r\n            case \"legacy\":\r\n                this.#type = 0;\r\n                break;\r\n            case 1:\r\n            case \"berlin\":\r\n            case \"eip-2930\":\r\n                this.#type = 1;\r\n                break;\r\n            case 2:\r\n            case \"london\":\r\n            case \"eip-1559\":\r\n                this.#type = 2;\r\n                break;\r\n            case 3:\r\n            case \"cancun\":\r\n            case \"eip-4844\":\r\n                this.#type = 3;\r\n                break;\r\n            case 4:\r\n            case \"pectra\":\r\n            case \"eip-7702\":\r\n                this.#type = 4;\r\n                break;\r\n            default:\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported transaction type\", \"type\", value);\r\n        }\r\n    }\r\n    /**\r\n     *  The name of the transaction type.\r\n     */\r\n    get typeName() {\r\n        switch (this.type) {\r\n            case 0: return \"legacy\";\r\n            case 1: return \"eip-2930\";\r\n            case 2: return \"eip-1559\";\r\n            case 3: return \"eip-4844\";\r\n            case 4: return \"eip-7702\";\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     *  The ``to`` address for the transaction or ``null`` if the\r\n     *  transaction is an ``init`` transaction.\r\n     */\r\n    get to() {\r\n        const value = this.#to;\r\n        if (value == null && this.type === 3) {\r\n            return _constants_addresses_js__WEBPACK_IMPORTED_MODULE_4__.ZeroAddress;\r\n        }\r\n        return value;\r\n    }\r\n    set to(value) {\r\n        this.#to = (value == null) ? null : (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)(value);\r\n    }\r\n    /**\r\n     *  The transaction nonce.\r\n     */\r\n    get nonce() { return this.#nonce; }\r\n    set nonce(value) { this.#nonce = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(value, \"value\"); }\r\n    /**\r\n     *  The gas limit.\r\n     */\r\n    get gasLimit() { return this.#gasLimit; }\r\n    set gasLimit(value) { this.#gasLimit = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value); }\r\n    /**\r\n     *  The gas price.\r\n     *\r\n     *  On legacy networks this defines the fee that will be paid. On\r\n     *  EIP-1559 networks, this should be ``null``.\r\n     */\r\n    get gasPrice() {\r\n        const value = this.#gasPrice;\r\n        if (value == null && (this.type === 0 || this.type === 1)) {\r\n            return BN_0;\r\n        }\r\n        return value;\r\n    }\r\n    set gasPrice(value) {\r\n        this.#gasPrice = (value == null) ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"gasPrice\");\r\n    }\r\n    /**\r\n     *  The maximum priority fee per unit of gas to pay. On legacy\r\n     *  networks this should be ``null``.\r\n     */\r\n    get maxPriorityFeePerGas() {\r\n        const value = this.#maxPriorityFeePerGas;\r\n        if (value == null) {\r\n            if (this.type === 2 || this.type === 3) {\r\n                return BN_0;\r\n            }\r\n            return null;\r\n        }\r\n        return value;\r\n    }\r\n    set maxPriorityFeePerGas(value) {\r\n        this.#maxPriorityFeePerGas = (value == null) ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"maxPriorityFeePerGas\");\r\n    }\r\n    /**\r\n     *  The maximum total fee per unit of gas to pay. On legacy\r\n     *  networks this should be ``null``.\r\n     */\r\n    get maxFeePerGas() {\r\n        const value = this.#maxFeePerGas;\r\n        if (value == null) {\r\n            if (this.type === 2 || this.type === 3) {\r\n                return BN_0;\r\n            }\r\n            return null;\r\n        }\r\n        return value;\r\n    }\r\n    set maxFeePerGas(value) {\r\n        this.#maxFeePerGas = (value == null) ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"maxFeePerGas\");\r\n    }\r\n    /**\r\n     *  The transaction data. For ``init`` transactions this is the\r\n     *  deployment code.\r\n     */\r\n    get data() { return this.#data; }\r\n    set data(value) { this.#data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(value); }\r\n    /**\r\n     *  The amount of ether (in wei) to send in this transactions.\r\n     */\r\n    get value() { return this.#value; }\r\n    set value(value) {\r\n        this.#value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"value\");\r\n    }\r\n    /**\r\n     *  The chain ID this transaction is valid on.\r\n     */\r\n    get chainId() { return this.#chainId; }\r\n    set chainId(value) { this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value); }\r\n    /**\r\n     *  If signed, the signature for this transaction.\r\n     */\r\n    get signature() { return this.#sig || null; }\r\n    set signature(value) {\r\n        this.#sig = (value == null) ? null : _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.Signature.from(value);\r\n    }\r\n    /**\r\n     *  The access list.\r\n     *\r\n     *  An access list permits discounted (but pre-paid) access to\r\n     *  bytecode and state variable access within contract execution.\r\n     */\r\n    get accessList() {\r\n        const value = this.#accessList || null;\r\n        if (value == null) {\r\n            if (this.type === 1 || this.type === 2 || this.type === 3) {\r\n                // @TODO: in v7, this should assign the value or become\r\n                // a live object itself, otherwise mutation is inconsistent\r\n                return [];\r\n            }\r\n            return null;\r\n        }\r\n        return value;\r\n    }\r\n    set accessList(value) {\r\n        this.#accessList = (value == null) ? null : (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_3__.accessListify)(value);\r\n    }\r\n    get authorizationList() {\r\n        const value = this.#auths || null;\r\n        if (value == null) {\r\n            if (this.type === 4) {\r\n                // @TODO: in v7, this should become a live object itself,\r\n                // otherwise mutation is inconsistent\r\n                return [];\r\n            }\r\n        }\r\n        return value;\r\n    }\r\n    set authorizationList(auths) {\r\n        this.#auths = (auths == null) ? null : auths.map((a) => (0,_authorization_js__WEBPACK_IMPORTED_MODULE_5__.authorizationify)(a));\r\n    }\r\n    /**\r\n     *  The max fee per blob gas for Cancun transactions.\r\n     */\r\n    get maxFeePerBlobGas() {\r\n        const value = this.#maxFeePerBlobGas;\r\n        if (value == null && this.type === 3) {\r\n            return BN_0;\r\n        }\r\n        return value;\r\n    }\r\n    set maxFeePerBlobGas(value) {\r\n        this.#maxFeePerBlobGas = (value == null) ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"maxFeePerBlobGas\");\r\n    }\r\n    /**\r\n     *  The BLOb versioned hashes for Cancun transactions.\r\n     */\r\n    get blobVersionedHashes() {\r\n        // @TODO: Mutation is inconsistent; if unset, the returned value\r\n        // cannot mutate the object, if set it can\r\n        let value = this.#blobVersionedHashes;\r\n        if (value == null && this.type === 3) {\r\n            return [];\r\n        }\r\n        return value;\r\n    }\r\n    set blobVersionedHashes(value) {\r\n        if (value != null) {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(value), \"blobVersionedHashes must be an Array\", \"value\", value);\r\n            value = value.slice();\r\n            for (let i = 0; i < value.length; i++) {\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value[i], 32), \"invalid blobVersionedHash\", `value[${i}]`, value[i]);\r\n            }\r\n        }\r\n        this.#blobVersionedHashes = value;\r\n    }\r\n    /**\r\n     *  The BLObs for the Transaction, if any.\r\n     *\r\n     *  If ``blobs`` is non-``null``, then the [[seriailized]]\r\n     *  will return the network formatted sidecar, otherwise it\r\n     *  will return the standard [[link-eip-2718]] payload. The\r\n     *  [[unsignedSerialized]] is unaffected regardless.\r\n     *\r\n     *  When setting ``blobs``, either fully valid [[Blob]] objects\r\n     *  may be specified (i.e. correctly padded, with correct\r\n     *  committments and proofs) or a raw [[BytesLike]] may\r\n     *  be provided.\r\n     *\r\n     *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**\r\n     *  be already set. The blob will be correctly padded and the\r\n     *  [[KzgLibrary]] will be used to compute the committment and\r\n     *  proof for the blob.\r\n     *\r\n     *  A BLOb is a sequence of field elements, each of which must\r\n     *  be within the BLS field modulo, so some additional processing\r\n     *  may be required to encode arbitrary data to ensure each 32 byte\r\n     *  field is within the valid range.\r\n     *\r\n     *  Setting this automatically populates [[blobVersionedHashes]],\r\n     *  overwriting any existing values. Setting this to ``null``\r\n     *  does **not** remove the [[blobVersionedHashes]], leaving them\r\n     *  present.\r\n     */\r\n    get blobs() {\r\n        if (this.#blobs == null) {\r\n            return null;\r\n        }\r\n        return this.#blobs.map((b) => Object.assign({}, b));\r\n    }\r\n    set blobs(_blobs) {\r\n        if (_blobs == null) {\r\n            this.#blobs = null;\r\n            return;\r\n        }\r\n        const blobs = [];\r\n        const versionedHashes = [];\r\n        for (let i = 0; i < _blobs.length; i++) {\r\n            const blob = _blobs[i];\r\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isBytesLike)(blob)) {\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.#kzg, \"adding a raw blob requires a KZG library\", \"UNSUPPORTED_OPERATION\", {\r\n                    operation: \"set blobs()\"\r\n                });\r\n                let data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(blob);\r\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(data.length <= BLOB_SIZE, \"blob is too large\", `blobs[${i}]`, blob);\r\n                // Pad blob if necessary\r\n                if (data.length !== BLOB_SIZE) {\r\n                    const padded = new Uint8Array(BLOB_SIZE);\r\n                    padded.set(data);\r\n                    data = padded;\r\n                }\r\n                const commit = this.#kzg.blobToKzgCommitment(data);\r\n                const proof = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(this.#kzg.computeBlobKzgProof(data, commit));\r\n                blobs.push({\r\n                    data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data),\r\n                    commitment: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(commit),\r\n                    proof\r\n                });\r\n                versionedHashes.push(getVersionedHash(1, commit));\r\n            }\r\n            else {\r\n                const commit = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob.commitment);\r\n                blobs.push({\r\n                    data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob.data),\r\n                    commitment: commit,\r\n                    proof: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob.proof)\r\n                });\r\n                versionedHashes.push(getVersionedHash(1, commit));\r\n            }\r\n        }\r\n        this.#blobs = blobs;\r\n        this.#blobVersionedHashes = versionedHashes;\r\n    }\r\n    get kzg() { return this.#kzg; }\r\n    set kzg(kzg) {\r\n        if (kzg == null) {\r\n            this.#kzg = null;\r\n        }\r\n        else {\r\n            this.#kzg = getKzgLibrary(kzg);\r\n        }\r\n    }\r\n    /**\r\n     *  Creates a new Transaction with default values.\r\n     */\r\n    constructor() {\r\n        this.#type = null;\r\n        this.#to = null;\r\n        this.#nonce = 0;\r\n        this.#gasLimit = BN_0;\r\n        this.#gasPrice = null;\r\n        this.#maxPriorityFeePerGas = null;\r\n        this.#maxFeePerGas = null;\r\n        this.#data = \"0x\";\r\n        this.#value = BN_0;\r\n        this.#chainId = BN_0;\r\n        this.#sig = null;\r\n        this.#accessList = null;\r\n        this.#maxFeePerBlobGas = null;\r\n        this.#blobVersionedHashes = null;\r\n        this.#kzg = null;\r\n        this.#blobs = null;\r\n        this.#auths = null;\r\n    }\r\n    /**\r\n     *  The transaction hash, if signed. Otherwise, ``null``.\r\n     */\r\n    get hash() {\r\n        if (this.signature == null) {\r\n            return null;\r\n        }\r\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)(this.#getSerialized(true, false));\r\n    }\r\n    /**\r\n     *  The pre-image hash of this transaction.\r\n     *\r\n     *  This is the digest that a [[Signer]] must sign to authorize\r\n     *  this transaction.\r\n     */\r\n    get unsignedHash() {\r\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)(this.unsignedSerialized);\r\n    }\r\n    /**\r\n     *  The sending address, if signed. Otherwise, ``null``.\r\n     */\r\n    get from() {\r\n        if (this.signature == null) {\r\n            return null;\r\n        }\r\n        return (0,_address_js__WEBPACK_IMPORTED_MODULE_6__.recoverAddress)(this.unsignedHash, this.signature);\r\n    }\r\n    /**\r\n     *  The public key of the sender, if signed. Otherwise, ``null``.\r\n     */\r\n    get fromPublicKey() {\r\n        if (this.signature == null) {\r\n            return null;\r\n        }\r\n        return _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\r\n    }\r\n    /**\r\n     *  Returns true if signed.\r\n     *\r\n     *  This provides a Type Guard that properties requiring a signed\r\n     *  transaction are non-null.\r\n     */\r\n    isSigned() {\r\n        return this.signature != null;\r\n    }\r\n    #getSerialized(signed, sidecar) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!signed || this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\" });\r\n        const sig = signed ? this.signature : null;\r\n        switch (this.inferType()) {\r\n            case 0:\r\n                return _serializeLegacy(this, sig);\r\n            case 1:\r\n                return _serializeEip2930(this, sig);\r\n            case 2:\r\n                return _serializeEip1559(this, sig);\r\n            case 3:\r\n                return _serializeEip4844(this, sig, sidecar ? this.blobs : null);\r\n            case 4:\r\n                return _serializeEip7702(this, sig);\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\" });\r\n    }\r\n    /**\r\n     *  The serialized transaction.\r\n     *\r\n     *  This throws if the transaction is unsigned. For the pre-image,\r\n     *  use [[unsignedSerialized]].\r\n     */\r\n    get serialized() {\r\n        return this.#getSerialized(true, true);\r\n    }\r\n    /**\r\n     *  The transaction pre-image.\r\n     *\r\n     *  The hash of this is the digest which needs to be signed to\r\n     *  authorize this transaction.\r\n     */\r\n    get unsignedSerialized() {\r\n        return this.#getSerialized(false, false);\r\n    }\r\n    /**\r\n     *  Return the most \"likely\" type; currently the highest\r\n     *  supported transaction type.\r\n     */\r\n    inferType() {\r\n        const types = this.inferTypes();\r\n        // Prefer London (EIP-1559) over Cancun (BLOb)\r\n        if (types.indexOf(2) >= 0) {\r\n            return 2;\r\n        }\r\n        // Return the highest inferred type\r\n        return (types.pop());\r\n    }\r\n    /**\r\n     *  Validates the explicit properties and returns a list of compatible\r\n     *  transaction types.\r\n     */\r\n    inferTypes() {\r\n        // Checks that there are no conflicting properties set\r\n        const hasGasPrice = this.gasPrice != null;\r\n        const hasFee = (this.maxFeePerGas != null || this.maxPriorityFeePerGas != null);\r\n        const hasAccessList = (this.accessList != null);\r\n        const hasBlob = (this.#maxFeePerBlobGas != null || this.#blobVersionedHashes);\r\n        //if (hasGasPrice && hasFee) {\r\n        //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\r\n        //}\r\n        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", { value: this });\r\n        }\r\n        //if (this.type === 2 && hasGasPrice) {\r\n        //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\r\n        //}\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!hasFee || (this.type !== 0 && this.type !== 1), \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", { value: this });\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", { value: this });\r\n        const types = [];\r\n        // Explicit type\r\n        if (this.type != null) {\r\n            types.push(this.type);\r\n        }\r\n        else {\r\n            if (this.authorizationList && this.authorizationList.length) {\r\n                types.push(4);\r\n            }\r\n            else if (hasFee) {\r\n                types.push(2);\r\n            }\r\n            else if (hasGasPrice) {\r\n                types.push(1);\r\n                if (!hasAccessList) {\r\n                    types.push(0);\r\n                }\r\n            }\r\n            else if (hasAccessList) {\r\n                types.push(1);\r\n                types.push(2);\r\n            }\r\n            else if (hasBlob && this.to) {\r\n                types.push(3);\r\n            }\r\n            else {\r\n                types.push(0);\r\n                types.push(1);\r\n                types.push(2);\r\n                types.push(3);\r\n            }\r\n        }\r\n        types.sort();\r\n        return types;\r\n    }\r\n    /**\r\n     *  Returns true if this transaction is a legacy transaction (i.e.\r\n     *  ``type === 0``).\r\n     *\r\n     *  This provides a Type Guard that the related properties are\r\n     *  non-null.\r\n     */\r\n    isLegacy() {\r\n        return (this.type === 0);\r\n    }\r\n    /**\r\n     *  Returns true if this transaction is berlin hardform transaction (i.e.\r\n     *  ``type === 1``).\r\n     *\r\n     *  This provides a Type Guard that the related properties are\r\n     *  non-null.\r\n     */\r\n    isBerlin() {\r\n        return (this.type === 1);\r\n    }\r\n    /**\r\n     *  Returns true if this transaction is london hardform transaction (i.e.\r\n     *  ``type === 2``).\r\n     *\r\n     *  This provides a Type Guard that the related properties are\r\n     *  non-null.\r\n     */\r\n    isLondon() {\r\n        return (this.type === 2);\r\n    }\r\n    /**\r\n     *  Returns true if this transaction is an [[link-eip-4844]] BLOB\r\n     *  transaction.\r\n     *\r\n     *  This provides a Type Guard that the related properties are\r\n     *  non-null.\r\n     */\r\n    isCancun() {\r\n        return (this.type === 3);\r\n    }\r\n    /**\r\n     *  Create a copy of this transaciton.\r\n     */\r\n    clone() {\r\n        return Transaction.from(this);\r\n    }\r\n    /**\r\n     *  Return a JSON-friendly object.\r\n     */\r\n    toJSON() {\r\n        const s = (v) => {\r\n            if (v == null) {\r\n                return null;\r\n            }\r\n            return v.toString();\r\n        };\r\n        return {\r\n            type: this.type,\r\n            to: this.to,\r\n            //            from: this.from,\r\n            data: this.data,\r\n            nonce: this.nonce,\r\n            gasLimit: s(this.gasLimit),\r\n            gasPrice: s(this.gasPrice),\r\n            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\r\n            maxFeePerGas: s(this.maxFeePerGas),\r\n            value: s(this.value),\r\n            chainId: s(this.chainId),\r\n            sig: this.signature ? this.signature.toJSON() : null,\r\n            accessList: this.accessList\r\n        };\r\n    }\r\n    /**\r\n     *  Create a **Transaction** from a serialized transaction or a\r\n     *  Transaction-like object.\r\n     */\r\n    static from(tx) {\r\n        if (tx == null) {\r\n            return new Transaction();\r\n        }\r\n        if (typeof (tx) === \"string\") {\r\n            const payload = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(tx);\r\n            if (payload[0] >= 0x7f) { // @TODO: > vs >= ??\r\n                return Transaction.from(_parseLegacy(payload));\r\n            }\r\n            switch (payload[0]) {\r\n                case 1: return Transaction.from(_parseEip2930(payload));\r\n                case 2: return Transaction.from(_parseEip1559(payload));\r\n                case 3: return Transaction.from(_parseEip4844(payload));\r\n                case 4: return Transaction.from(_parseEip7702(payload));\r\n            }\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \"from\" });\r\n        }\r\n        const result = new Transaction();\r\n        if (tx.type != null) {\r\n            result.type = tx.type;\r\n        }\r\n        if (tx.to != null) {\r\n            result.to = tx.to;\r\n        }\r\n        if (tx.nonce != null) {\r\n            result.nonce = tx.nonce;\r\n        }\r\n        if (tx.gasLimit != null) {\r\n            result.gasLimit = tx.gasLimit;\r\n        }\r\n        if (tx.gasPrice != null) {\r\n            result.gasPrice = tx.gasPrice;\r\n        }\r\n        if (tx.maxPriorityFeePerGas != null) {\r\n            result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\r\n        }\r\n        if (tx.maxFeePerGas != null) {\r\n            result.maxFeePerGas = tx.maxFeePerGas;\r\n        }\r\n        if (tx.maxFeePerBlobGas != null) {\r\n            result.maxFeePerBlobGas = tx.maxFeePerBlobGas;\r\n        }\r\n        if (tx.data != null) {\r\n            result.data = tx.data;\r\n        }\r\n        if (tx.value != null) {\r\n            result.value = tx.value;\r\n        }\r\n        if (tx.chainId != null) {\r\n            result.chainId = tx.chainId;\r\n        }\r\n        if (tx.signature != null) {\r\n            result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.Signature.from(tx.signature);\r\n        }\r\n        if (tx.accessList != null) {\r\n            result.accessList = tx.accessList;\r\n        }\r\n        if (tx.authorizationList != null) {\r\n            result.authorizationList = tx.authorizationList;\r\n        }\r\n        // This will get overwritten by blobs, if present\r\n        if (tx.blobVersionedHashes != null) {\r\n            result.blobVersionedHashes = tx.blobVersionedHashes;\r\n        }\r\n        // Make sure we assign the kzg before assigning blobs, which\r\n        // require the library in the event raw blob data is provided.\r\n        if (tx.kzg != null) {\r\n            result.kzg = tx.kzg;\r\n        }\r\n        if (tx.blobs != null) {\r\n            result.blobs = tx.blobs;\r\n        }\r\n        if (tx.hash != null) {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(result.isSigned(), \"unsigned transaction cannot define '.hash'\", \"tx\", tx);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\r\n        }\r\n        if (tx.from != null) {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(result.isSigned(), \"unsigned transaction cannot define '.from'\", \"tx\", tx);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n//# sourceMappingURL=transaction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi90cmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFpRDtBQUNPO0FBQ3NCO0FBQ3VHO0FBQ3JJO0FBQ007QUFDUjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLHlEQUFRLHlCQUF5Qix3REFBTztBQUMvRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsbUJBQW1CLHlEQUFRO0FBQzNCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsbUJBQW1CLHlEQUFRLHlCQUF5Qix3REFBTztBQUMzRDtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseURBQVEsc0JBQXNCLHdEQUFPLFFBQVEsd0RBQU87QUFDdkU7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsbUJBQW1CLHlEQUFRLHlCQUF5Qix3REFBTyxRQUFRLHdEQUFPO0FBQzFFO0FBQ0EsUUFBUSwrREFBYztBQUN0QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2REFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZEQUFhO0FBQzVCO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQWM7QUFDMUIsWUFBWSwrREFBYztBQUMxQjtBQUNBO0FBQ0EsWUFBWSwrREFBYztBQUMxQixZQUFZLCtEQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcdHJhbnNhY3Rpb25cXHRyYW5zYWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBaZXJvQWRkcmVzcyB9IGZyb20gXCIuLi9jb25zdGFudHMvYWRkcmVzc2VzLmpzXCI7XHJcbmltcG9ydCB7IGtlY2NhazI1Niwgc2hhMjU2LCBTaWduYXR1cmUsIFNpZ25pbmdLZXkgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGNvbmNhdCwgZGVjb2RlUmxwLCBlbmNvZGVSbHAsIGdldEJ5dGVzLCBnZXRCaWdJbnQsIGdldE51bWJlciwgaGV4bGlmeSwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgaXNCeXRlc0xpa2UsIGlzSGV4U3RyaW5nLCB0b0JlQXJyYXksIHplcm9QYWRWYWx1ZSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIi4vYWNjZXNzbGlzdC5qc1wiO1xyXG5pbXBvcnQgeyBhdXRob3JpemF0aW9uaWZ5IH0gZnJvbSBcIi4vYXV0aG9yaXphdGlvbi5qc1wiO1xyXG5pbXBvcnQgeyByZWNvdmVyQWRkcmVzcyB9IGZyb20gXCIuL2FkZHJlc3MuanNcIjtcclxuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcclxuY29uc3QgQk5fMiA9IEJpZ0ludCgyKTtcclxuY29uc3QgQk5fMjcgPSBCaWdJbnQoMjcpO1xyXG5jb25zdCBCTl8yOCA9IEJpZ0ludCgyOCk7XHJcbmNvbnN0IEJOXzM1ID0gQmlnSW50KDM1KTtcclxuY29uc3QgQk5fTUFYX1VJTlQgPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XHJcbmNvbnN0IEJMT0JfU0laRSA9IDQwOTYgKiAzMjtcclxuZnVuY3Rpb24gZ2V0S3pnTGlicmFyeShremcpIHtcclxuICAgIGNvbnN0IGJsb2JUb0t6Z0NvbW1pdG1lbnQgPSAoYmxvYikgPT4ge1xyXG4gICAgICAgIGlmIChcImNvbXB1dGVCbG9iUHJvb2ZcIiBpbiBremcpIHtcclxuICAgICAgICAgICAgLy8gbWljcm8tZWNjLXNpZ25lcjsgY2hlY2sgZm9yIGNvbXB1dGVCbG9iUHJvb2Ygc2luY2UgdGhpcyBBUElcclxuICAgICAgICAgICAgLy8gZXhwZWN0cyBhIHN0cmluZyB3aGlsZSB0aGUga3pnLXdhc20gYmVsb3cgZXhwZWN0cyBhIFVuaXQ4QXJyYXlcclxuICAgICAgICAgICAgaWYgKFwiYmxvYlRvS3pnQ29tbWl0bWVudFwiIGluIGt6ZyAmJiB0eXBlb2YgKGt6Zy5ibG9iVG9LemdDb21taXRtZW50KSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZXMoa3pnLmJsb2JUb0t6Z0NvbW1pdG1lbnQoaGV4bGlmeShibG9iKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFwiYmxvYlRvS3pnQ29tbWl0bWVudFwiIGluIGt6ZyAmJiB0eXBlb2YgKGt6Zy5ibG9iVG9LemdDb21taXRtZW50KSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIC8vIGt6Zy13YXNtIDwwLjUuMDsgYmxvYlRvS3pnQ29tbWl0bWVudChVaW50OEFycmF5KSA9PiBVaW50OEFycmF5XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyhremcuYmxvYlRvS3pnQ29tbWl0bWVudChibG9iKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGt6Zy13YXNtID49IDAuNS4wOyBibG9iVG9LWkdDb21taXRtZW50KHN0cmluZykgPT4gc3RyaW5nXHJcbiAgICAgICAgaWYgKFwiYmxvYlRvS1pHQ29tbWl0bWVudFwiIGluIGt6ZyAmJiB0eXBlb2YgKGt6Zy5ibG9iVG9LWkdDb21taXRtZW50KSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyhremcuYmxvYlRvS1pHQ29tbWl0bWVudChoZXhsaWZ5KGJsb2IpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIEtaRyBsaWJyYXJ5XCIsIFwia3pnXCIsIGt6Zyk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgY29tcHV0ZUJsb2JLemdQcm9vZiA9IChibG9iLCBjb21taXRtZW50KSA9PiB7XHJcbiAgICAgICAgLy8gbWljcm8tZWNjLXNpZ25lclxyXG4gICAgICAgIGlmIChcImNvbXB1dGVCbG9iUHJvb2ZcIiBpbiBremcgJiYgdHlwZW9mIChremcuY29tcHV0ZUJsb2JQcm9vZikgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZXMoa3pnLmNvbXB1dGVCbG9iUHJvb2YoaGV4bGlmeShibG9iKSwgaGV4bGlmeShjb21taXRtZW50KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBremctd2FzbSA8MC41LjA7IGNvbXB1dGVCbG9iS3pnUHJvb2YoVWludDhBcnJheSwgVWludDhBcnJheSkgPT4gVWludDhBcnJheVxyXG4gICAgICAgIGlmIChcImNvbXB1dGVCbG9iS3pnUHJvb2ZcIiBpbiBremcgJiYgdHlwZW9mIChremcuY29tcHV0ZUJsb2JLemdQcm9vZikgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICByZXR1cm4ga3pnLmNvbXB1dGVCbG9iS3pnUHJvb2YoYmxvYiwgY29tbWl0bWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGt6Zy13YXNtID49IDAuNS4wOyBjb21wdXRlQmxvYktaR1Byb29mKHN0cmluZywgc3RyaW5nKSA9PiBzdHJpbmdcclxuICAgICAgICBpZiAoXCJjb21wdXRlQmxvYktaR1Byb29mXCIgaW4ga3pnICYmIHR5cGVvZiAoa3pnLmNvbXB1dGVCbG9iS1pHUHJvb2YpID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVzKGt6Zy5jb21wdXRlQmxvYktaR1Byb29mKGhleGxpZnkoYmxvYiksIGhleGxpZnkoY29tbWl0bWVudCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgS1pHIGxpYnJhcnlcIiwgXCJremdcIiwga3pnKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4geyBibG9iVG9LemdDb21taXRtZW50LCBjb21wdXRlQmxvYkt6Z1Byb29mIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0VmVyc2lvbmVkSGFzaCh2ZXJzaW9uLCBoYXNoKSB7XHJcbiAgICBsZXQgdmVyc2lvbmVkID0gdmVyc2lvbi50b1N0cmluZygxNik7XHJcbiAgICB3aGlsZSAodmVyc2lvbmVkLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICB2ZXJzaW9uZWQgPSBcIjBcIiArIHZlcnNpb25lZDtcclxuICAgIH1cclxuICAgIHZlcnNpb25lZCArPSBzaGEyNTYoaGFzaCkuc3Vic3RyaW5nKDQpO1xyXG4gICAgcmV0dXJuIFwiMHhcIiArIHZlcnNpb25lZDtcclxufVxyXG5mdW5jdGlvbiBoYW5kbGVBZGRyZXNzKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT09IFwiMHhcIikge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdldEFkZHJlc3ModmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZUFjY2Vzc0xpc3QodmFsdWUsIHBhcmFtKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBlcnJvci5tZXNzYWdlLCBwYXJhbSwgdmFsdWUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZUF1dGhvcml6YXRpb25MaXN0KHZhbHVlLCBwYXJhbSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF1dGhvcml6YXRpb25MaXN0OiBpbnZhbGlkIGFycmF5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGF1dGggPSB2YWx1ZVtpXTtcclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGF1dGgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGF1dGhvcml6YXRpb25bJHtpfV06IGludmFsaWQgYXJyYXlgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYXV0aC5sZW5ndGggIT09IDYpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYXV0aG9yaXphdGlvblske2l9XTogd3JvbmcgbGVuZ3RoYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFhdXRoWzFdKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGF1dGhvcml6YXRpb25bJHtpfV06IG51bGwgYWRkcmVzc2ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGhhbmRsZUFkZHJlc3MoYXV0aFsxXSksXHJcbiAgICAgICAgICAgICAgICBub25jZTogaGFuZGxlVWludChhdXRoWzJdLCBcIm5vbmNlXCIpLFxyXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogaGFuZGxlVWludChhdXRoWzBdLCBcImNoYWluSWRcIiksXHJcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFNpZ25hdHVyZS5mcm9tKHtcclxuICAgICAgICAgICAgICAgICAgICB5UGFyaXR5OiBoYW5kbGVOdW1iZXIoYXV0aFszXSwgXCJ5UGFyaXR5XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIHI6IHplcm9QYWRWYWx1ZShhdXRoWzRdLCAzMiksXHJcbiAgICAgICAgICAgICAgICAgICAgczogemVyb1BhZFZhbHVlKGF1dGhbNV0sIDMyKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgZXJyb3IubWVzc2FnZSwgcGFyYW0sIHZhbHVlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoYW5kbGVOdW1iZXIoX3ZhbHVlLCBwYXJhbSkge1xyXG4gICAgaWYgKF92YWx1ZSA9PT0gXCIweFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0TnVtYmVyKF92YWx1ZSwgcGFyYW0pO1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZVVpbnQoX3ZhbHVlLCBwYXJhbSkge1xyXG4gICAgaWYgKF92YWx1ZSA9PT0gXCIweFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIEJOXzA7XHJcbiAgICB9XHJcbiAgICBjb25zdCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIHBhcmFtKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlIDw9IEJOX01BWF9VSU5ULCBcInZhbHVlIGV4Y2VlZHMgdWludCBzaXplXCIsIHBhcmFtLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKF92YWx1ZSwgbmFtZSkge1xyXG4gICAgY29uc3QgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gdG9CZUFycmF5KHZhbHVlKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5sZW5ndGggPD0gMzIsIGB2YWx1ZSB0b28gbGFyZ2VgLCBgdHguJHtuYW1lfWAsIHZhbHVlKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gZm9ybWF0QWNjZXNzTGlzdCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGFjY2Vzc0xpc3RpZnkodmFsdWUpLm1hcCgoc2V0KSA9PiBbc2V0LmFkZHJlc3MsIHNldC5zdG9yYWdlS2V5c10pO1xyXG59XHJcbmZ1bmN0aW9uIGZvcm1hdEF1dGhvcml6YXRpb25MaXN0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUubWFwKChhKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgZm9ybWF0TnVtYmVyKGEuY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxyXG4gICAgICAgICAgICBhLmFkZHJlc3MsXHJcbiAgICAgICAgICAgIGZvcm1hdE51bWJlcihhLm5vbmNlLCBcIm5vbmNlXCIpLFxyXG4gICAgICAgICAgICBmb3JtYXROdW1iZXIoYS5zaWduYXR1cmUueVBhcml0eSwgXCJ5UGFyaXR5XCIpLFxyXG4gICAgICAgICAgICB0b0JlQXJyYXkoYS5zaWduYXR1cmUuciksXHJcbiAgICAgICAgICAgIHRvQmVBcnJheShhLnNpZ25hdHVyZS5zKVxyXG4gICAgICAgIF07XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBmb3JtYXRIYXNoZXModmFsdWUsIHBhcmFtKSB7XHJcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KHZhbHVlKSwgYGludmFsaWQgJHtwYXJhbX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh2YWx1ZVtpXSwgMzIpLCBcImludmFsaWQgJHsgcGFyYW0gfSBoYXNoXCIsIGB2YWx1ZVske2l9XWAsIHZhbHVlW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBfcGFyc2VMZWdhY3koZGF0YSkge1xyXG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlUmxwKGRhdGEpO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIChmaWVsZHMubGVuZ3RoID09PSA5IHx8IGZpZWxkcy5sZW5ndGggPT09IDYpLCBcImludmFsaWQgZmllbGQgY291bnQgZm9yIGxlZ2FjeSB0cmFuc2FjdGlvblwiLCBcImRhdGFcIiwgZGF0YSk7XHJcbiAgICBjb25zdCB0eCA9IHtcclxuICAgICAgICB0eXBlOiAwLFxyXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzBdLCBcIm5vbmNlXCIpLFxyXG4gICAgICAgIGdhc1ByaWNlOiBoYW5kbGVVaW50KGZpZWxkc1sxXSwgXCJnYXNQcmljZVwiKSxcclxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbMl0sIFwiZ2FzTGltaXRcIiksXHJcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3MoZmllbGRzWzNdKSxcclxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNF0sIFwidmFsdWVcIiksXHJcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbNV0pLFxyXG4gICAgICAgIGNoYWluSWQ6IEJOXzBcclxuICAgIH07XHJcbiAgICAvLyBMZWdhY3kgdW5zaWduZWQgdHJhbnNhY3Rpb25cclxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA2KSB7XHJcbiAgICAgICAgcmV0dXJuIHR4O1xyXG4gICAgfVxyXG4gICAgY29uc3QgdiA9IGhhbmRsZVVpbnQoZmllbGRzWzZdLCBcInZcIik7XHJcbiAgICBjb25zdCByID0gaGFuZGxlVWludChmaWVsZHNbN10sIFwiclwiKTtcclxuICAgIGNvbnN0IHMgPSBoYW5kbGVVaW50KGZpZWxkc1s4XSwgXCJzXCIpO1xyXG4gICAgaWYgKHIgPT09IEJOXzAgJiYgcyA9PT0gQk5fMCkge1xyXG4gICAgICAgIC8vIEVJUC0xNTUgdW5zaWduZWQgdHJhbnNhY3Rpb25cclxuICAgICAgICB0eC5jaGFpbklkID0gdjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIEVJUC0xNTUgY2hhaW4gSUQgKG9yIDAgZm9yIGxlZ2FjeSlcclxuICAgICAgICBsZXQgY2hhaW5JZCA9ICh2IC0gQk5fMzUpIC8gQk5fMjtcclxuICAgICAgICBpZiAoY2hhaW5JZCA8IEJOXzApIHtcclxuICAgICAgICAgICAgY2hhaW5JZCA9IEJOXzA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHR4LmNoYWluSWQgPSBjaGFpbklkO1xyXG4gICAgICAgIC8vIFNpZ25lZCBMZWdhY3kgVHJhbnNhY3Rpb25cclxuICAgICAgICBhc3NlcnRBcmd1bWVudChjaGFpbklkICE9PSBCTl8wIHx8ICh2ID09PSBCTl8yNyB8fCB2ID09PSBCTl8yOCksIFwibm9uLWNhbm9uaWNhbCBsZWdhY3kgdlwiLCBcInZcIiwgZmllbGRzWzZdKTtcclxuICAgICAgICB0eC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh7XHJcbiAgICAgICAgICAgIHI6IHplcm9QYWRWYWx1ZShmaWVsZHNbN10sIDMyKSxcclxuICAgICAgICAgICAgczogemVyb1BhZFZhbHVlKGZpZWxkc1s4XSwgMzIpLFxyXG4gICAgICAgICAgICB2XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy90eC5oYXNoID0ga2VjY2FrMjU2KGRhdGEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHR4O1xyXG59XHJcbmZ1bmN0aW9uIF9zZXJpYWxpemVMZWdhY3kodHgsIHNpZykge1xyXG4gICAgY29uc3QgZmllbGRzID0gW1xyXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSwgXCJub25jZVwiKSxcclxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzUHJpY2UgfHwgMCwgXCJnYXNQcmljZVwiKSxcclxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXHJcbiAgICAgICAgKHR4LnRvIHx8IFwiMHhcIiksXHJcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LnZhbHVlLCBcInZhbHVlXCIpLFxyXG4gICAgICAgIHR4LmRhdGEsXHJcbiAgICBdO1xyXG4gICAgbGV0IGNoYWluSWQgPSBCTl8wO1xyXG4gICAgaWYgKHR4LmNoYWluSWQgIT0gQk5fMCkge1xyXG4gICAgICAgIC8vIEEgY2hhaW5JZCB3YXMgcHJvdmlkZWQ7IGlmIG5vbi16ZXJvIHdlJ2xsIHVzZSBFSVAtMTU1XHJcbiAgICAgICAgY2hhaW5JZCA9IGdldEJpZ0ludCh0eC5jaGFpbklkLCBcInR4LmNoYWluSWRcIik7XHJcbiAgICAgICAgLy8gV2UgaGF2ZSBhIGNoYWluSWQgaW4gdGhlIHR4IGFuZCBhbiBFSVAtMTU1IHYgaW4gdGhlIHNpZ25hdHVyZSxcclxuICAgICAgICAvLyBtYWtlIHN1cmUgdGhleSBhZ3JlZSB3aXRoIGVhY2ggb3RoZXJcclxuICAgICAgICBhc3NlcnRBcmd1bWVudCghc2lnIHx8IHNpZy5uZXR3b3JrViA9PSBudWxsIHx8IHNpZy5sZWdhY3lDaGFpbklkID09PSBjaGFpbklkLCBcInR4LmNoYWluSWQvc2lnLnYgbWlzbWF0Y2hcIiwgXCJzaWdcIiwgc2lnKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR4LnNpZ25hdHVyZSkge1xyXG4gICAgICAgIC8vIE5vIGV4cGxpY2l0IGNoYWluSWQsIGJ1dCBFSVAtMTU1IGhhdmUgYSBkZXJpdmVkIGltcGxpY2l0IGNoYWluSWRcclxuICAgICAgICBjb25zdCBsZWdhY3kgPSB0eC5zaWduYXR1cmUubGVnYWN5Q2hhaW5JZDtcclxuICAgICAgICBpZiAobGVnYWN5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY2hhaW5JZCA9IGxlZ2FjeTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBSZXF1ZXN0aW5nIGFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uXHJcbiAgICBpZiAoIXNpZykge1xyXG4gICAgICAgIC8vIFdlIGhhdmUgYW4gRUlQLTE1NSB0cmFuc2FjdGlvbiAoY2hhaW5JZCB3YXMgc3BlY2lmaWVkIGFuZCBub24temVybylcclxuICAgICAgICBpZiAoY2hhaW5JZCAhPT0gQk5fMCkge1xyXG4gICAgICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoY2hhaW5JZCkpO1xyXG4gICAgICAgICAgICBmaWVsZHMucHVzaChcIjB4XCIpO1xyXG4gICAgICAgICAgICBmaWVsZHMucHVzaChcIjB4XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW5jb2RlUmxwKGZpZWxkcyk7XHJcbiAgICB9XHJcbiAgICAvLyBAVE9ETzogV2Ugc2hvdWxkIHByb2JhYmx5IGNoZWNrIHRoYXQgdHguc2lnbmF0dXJlLCBjaGFpbklkLCBhbmQgc2lnXHJcbiAgICAvLyAgICAgICAgbWF0Y2ggYnV0IHRoYXQgbG9naWMgY291bGQgYnJlYWsgZXhpc3RpbmcgY29kZSwgc28gc2NoZWR1bGVcclxuICAgIC8vICAgICAgICB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciBidW1wLlxyXG4gICAgLy8gQ29tcHV0ZSB0aGUgRUlQLTE1NSB2XHJcbiAgICBsZXQgdiA9IEJpZ0ludCgyNyArIHNpZy55UGFyaXR5KTtcclxuICAgIGlmIChjaGFpbklkICE9PSBCTl8wKSB7XHJcbiAgICAgICAgdiA9IFNpZ25hdHVyZS5nZXRDaGFpbklkVihjaGFpbklkLCBzaWcudik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChCaWdJbnQoc2lnLnYpICE9PSB2KSB7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidHguY2hhaW5JZC9zaWcudiBtaXNtYXRjaFwiLCBcInNpZ1wiLCBzaWcpO1xyXG4gICAgfVxyXG4gICAgLy8gQWRkIHRoZSBzaWduYXR1cmVcclxuICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheSh2KSk7XHJcbiAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcclxuICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucykpO1xyXG4gICAgcmV0dXJuIGVuY29kZVJscChmaWVsZHMpO1xyXG59XHJcbmZ1bmN0aW9uIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzKSB7XHJcbiAgICBsZXQgeVBhcml0eTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgeVBhcml0eSA9IGhhbmRsZU51bWJlcihmaWVsZHNbMF0sIFwieVBhcml0eVwiKTtcclxuICAgICAgICBpZiAoeVBhcml0eSAhPT0gMCAmJiB5UGFyaXR5ICE9PSAxKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCB5UGFyaXR5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgeVBhcml0eVwiLCBcInlQYXJpdHlcIiwgZmllbGRzWzBdKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHIgPSB6ZXJvUGFkVmFsdWUoZmllbGRzWzFdLCAzMik7XHJcbiAgICBjb25zdCBzID0gemVyb1BhZFZhbHVlKGZpZWxkc1syXSwgMzIpO1xyXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20oeyByLCBzLCB5UGFyaXR5IH0pO1xyXG4gICAgdHguc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xyXG59XHJcbmZ1bmN0aW9uIF9wYXJzZUVpcDE1NTkoZGF0YSkge1xyXG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlUmxwKGdldEJ5dGVzKGRhdGEpLnNsaWNlKDEpKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gOSB8fCBmaWVsZHMubGVuZ3RoID09PSAxMiksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogMlwiLCBcImRhdGFcIiwgaGV4bGlmeShkYXRhKSk7XHJcbiAgICBjb25zdCB0eCA9IHtcclxuICAgICAgICB0eXBlOiAyLFxyXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXHJcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMV0sIFwibm9uY2VcIiksXHJcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxyXG4gICAgICAgIG1heEZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbM10sIFwibWF4RmVlUGVyR2FzXCIpLFxyXG4gICAgICAgIGdhc1ByaWNlOiBudWxsLFxyXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVVaW50KGZpZWxkc1s0XSwgXCJnYXNMaW1pdFwiKSxcclxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbNV0pLFxyXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s2XSwgXCJ2YWx1ZVwiKSxcclxuICAgICAgICBkYXRhOiBoZXhsaWZ5KGZpZWxkc1s3XSksXHJcbiAgICAgICAgYWNjZXNzTGlzdDogaGFuZGxlQWNjZXNzTGlzdChmaWVsZHNbOF0sIFwiYWNjZXNzTGlzdFwiKSxcclxuICAgIH07XHJcbiAgICAvLyBVbnNpZ25lZCBFSVAtMTU1OSBUcmFuc2FjdGlvblxyXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDkpIHtcclxuICAgICAgICByZXR1cm4gdHg7XHJcbiAgICB9XHJcbiAgICAvL3R4Lmhhc2ggPSBrZWNjYWsyNTYoZGF0YSk7XHJcbiAgICBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcy5zbGljZSg5KSk7XHJcbiAgICByZXR1cm4gdHg7XHJcbn1cclxuZnVuY3Rpb24gX3NlcmlhbGl6ZUVpcDE1NTkodHgsIHNpZykge1xyXG4gICAgY29uc3QgZmllbGRzID0gW1xyXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5jaGFpbklkLCBcImNoYWluSWRcIiksXHJcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm5vbmNlLCBcIm5vbmNlXCIpLFxyXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCAwLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxyXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhGZWVQZXJHYXMgfHwgMCwgXCJtYXhGZWVQZXJHYXNcIiksXHJcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0LCBcImdhc0xpbWl0XCIpLFxyXG4gICAgICAgICh0eC50byB8fCBcIjB4XCIpLFxyXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSwgXCJ2YWx1ZVwiKSxcclxuICAgICAgICB0eC5kYXRhLFxyXG4gICAgICAgIGZvcm1hdEFjY2Vzc0xpc3QodHguYWNjZXNzTGlzdCB8fCBbXSlcclxuICAgIF07XHJcbiAgICBpZiAoc2lnKSB7XHJcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInlQYXJpdHlcIikpO1xyXG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xyXG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbmNhdChbXCIweDAyXCIsIGVuY29kZVJscChmaWVsZHMpXSk7XHJcbn1cclxuZnVuY3Rpb24gX3BhcnNlRWlwMjkzMChkYXRhKSB7XHJcbiAgICBjb25zdCBmaWVsZHMgPSBkZWNvZGVSbHAoZ2V0Qnl0ZXMoZGF0YSkuc2xpY2UoMSkpO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIChmaWVsZHMubGVuZ3RoID09PSA4IHx8IGZpZWxkcy5sZW5ndGggPT09IDExKSwgXCJpbnZhbGlkIGZpZWxkIGNvdW50IGZvciB0cmFuc2FjdGlvbiB0eXBlOiAxXCIsIFwiZGF0YVwiLCBoZXhsaWZ5KGRhdGEpKTtcclxuICAgIGNvbnN0IHR4ID0ge1xyXG4gICAgICAgIHR5cGU6IDEsXHJcbiAgICAgICAgY2hhaW5JZDogaGFuZGxlVWludChmaWVsZHNbMF0sIFwiY2hhaW5JZFwiKSxcclxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1sxXSwgXCJub25jZVwiKSxcclxuICAgICAgICBnYXNQcmljZTogaGFuZGxlVWludChmaWVsZHNbMl0sIFwiZ2FzUHJpY2VcIiksXHJcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzNdLCBcImdhc0xpbWl0XCIpLFxyXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1s0XSksXHJcbiAgICAgICAgdmFsdWU6IGhhbmRsZVVpbnQoZmllbGRzWzVdLCBcInZhbHVlXCIpLFxyXG4gICAgICAgIGRhdGE6IGhleGxpZnkoZmllbGRzWzZdKSxcclxuICAgICAgICBhY2Nlc3NMaXN0OiBoYW5kbGVBY2Nlc3NMaXN0KGZpZWxkc1s3XSwgXCJhY2Nlc3NMaXN0XCIpXHJcbiAgICB9O1xyXG4gICAgLy8gVW5zaWduZWQgRUlQLTI5MzAgVHJhbnNhY3Rpb25cclxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA4KSB7XHJcbiAgICAgICAgcmV0dXJuIHR4O1xyXG4gICAgfVxyXG4gICAgLy90eC5oYXNoID0ga2VjY2FrMjU2KGRhdGEpO1xyXG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMuc2xpY2UoOCkpO1xyXG4gICAgcmV0dXJuIHR4O1xyXG59XHJcbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXAyOTMwKHR4LCBzaWcpIHtcclxuICAgIGNvbnN0IGZpZWxkcyA9IFtcclxuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxyXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSwgXCJub25jZVwiKSxcclxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzUHJpY2UgfHwgMCwgXCJnYXNQcmljZVwiKSxcclxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXHJcbiAgICAgICAgKHR4LnRvIHx8IFwiMHhcIiksXHJcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LnZhbHVlLCBcInZhbHVlXCIpLFxyXG4gICAgICAgIHR4LmRhdGEsXHJcbiAgICAgICAgZm9ybWF0QWNjZXNzTGlzdCh0eC5hY2Nlc3NMaXN0IHx8IFtdKVxyXG4gICAgXTtcclxuICAgIGlmIChzaWcpIHtcclxuICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnlQYXJpdHksIFwicmVjb3ZlcnlQYXJhbVwiKSk7XHJcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5yKSk7XHJcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5zKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29uY2F0KFtcIjB4MDFcIiwgZW5jb2RlUmxwKGZpZWxkcyldKTtcclxufVxyXG5mdW5jdGlvbiBfcGFyc2VFaXA0ODQ0KGRhdGEpIHtcclxuICAgIGxldCBmaWVsZHMgPSBkZWNvZGVSbHAoZ2V0Qnl0ZXMoZGF0YSkuc2xpY2UoMSkpO1xyXG4gICAgbGV0IHR5cGVOYW1lID0gXCIzXCI7XHJcbiAgICBsZXQgYmxvYnMgPSBudWxsO1xyXG4gICAgLy8gUGFyc2UgdGhlIG5ldHdvcmsgZm9ybWF0XHJcbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gNCAmJiBBcnJheS5pc0FycmF5KGZpZWxkc1swXSkpIHtcclxuICAgICAgICB0eXBlTmFtZSA9IFwiMyAobmV0d29yayBmb3JtYXQpXCI7XHJcbiAgICAgICAgY29uc3QgZkJsb2JzID0gZmllbGRzWzFdLCBmQ29tbWl0cyA9IGZpZWxkc1syXSwgZlByb29mcyA9IGZpZWxkc1szXTtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZCbG9icyksIFwiaW52YWxpZCBuZXR3b3JrIGZvcm1hdDogYmxvYnMgbm90IGFuIGFycmF5XCIsIFwiZmllbGRzWzFdXCIsIGZCbG9icyk7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmQ29tbWl0cyksIFwiaW52YWxpZCBuZXR3b3JrIGZvcm1hdDogY29tbWl0bWVudHMgbm90IGFuIGFycmF5XCIsIFwiZmllbGRzWzJdXCIsIGZDb21taXRzKTtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZQcm9vZnMpLCBcImludmFsaWQgbmV0d29yayBmb3JtYXQ6IHByb29mcyBub3QgYW4gYXJyYXlcIiwgXCJmaWVsZHNbM11cIiwgZlByb29mcyk7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZkJsb2JzLmxlbmd0aCA9PT0gZkNvbW1pdHMubGVuZ3RoLCBcImludmFsaWQgbmV0d29yayBmb3JtYXQ6IGJsb2JzL2NvbW1pdG1lbnRzIGxlbmd0aCBtaXNtYXRjaFwiLCBcImZpZWxkc1wiLCBmaWVsZHMpO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZCbG9icy5sZW5ndGggPT09IGZQcm9vZnMubGVuZ3RoLCBcImludmFsaWQgbmV0d29yayBmb3JtYXQ6IGJsb2JzL3Byb29mcyBsZW5ndGggbWlzbWF0Y2hcIiwgXCJmaWVsZHNcIiwgZmllbGRzKTtcclxuICAgICAgICBibG9icyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzWzFdLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJsb2JzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgZGF0YTogZkJsb2JzW2ldLFxyXG4gICAgICAgICAgICAgICAgY29tbWl0bWVudDogZkNvbW1pdHNbaV0sXHJcbiAgICAgICAgICAgICAgICBwcm9vZjogZlByb29mc1tpXSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpZWxkcyA9IGZpZWxkc1swXTtcclxuICAgIH1cclxuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gMTEgfHwgZmllbGRzLmxlbmd0aCA9PT0gMTQpLCBgaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogJHt0eXBlTmFtZX1gLCBcImRhdGFcIiwgaGV4bGlmeShkYXRhKSk7XHJcbiAgICBjb25zdCB0eCA9IHtcclxuICAgICAgICB0eXBlOiAzLFxyXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXHJcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMV0sIFwibm9uY2VcIiksXHJcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxyXG4gICAgICAgIG1heEZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbM10sIFwibWF4RmVlUGVyR2FzXCIpLFxyXG4gICAgICAgIGdhc1ByaWNlOiBudWxsLFxyXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVVaW50KGZpZWxkc1s0XSwgXCJnYXNMaW1pdFwiKSxcclxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbNV0pLFxyXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s2XSwgXCJ2YWx1ZVwiKSxcclxuICAgICAgICBkYXRhOiBoZXhsaWZ5KGZpZWxkc1s3XSksXHJcbiAgICAgICAgYWNjZXNzTGlzdDogaGFuZGxlQWNjZXNzTGlzdChmaWVsZHNbOF0sIFwiYWNjZXNzTGlzdFwiKSxcclxuICAgICAgICBtYXhGZWVQZXJCbG9iR2FzOiBoYW5kbGVVaW50KGZpZWxkc1s5XSwgXCJtYXhGZWVQZXJCbG9iR2FzXCIpLFxyXG4gICAgICAgIGJsb2JWZXJzaW9uZWRIYXNoZXM6IGZpZWxkc1sxMF1cclxuICAgIH07XHJcbiAgICBpZiAoYmxvYnMpIHtcclxuICAgICAgICB0eC5ibG9icyA9IGJsb2JzO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0QXJndW1lbnQodHgudG8gIT0gbnVsbCwgYGludmFsaWQgYWRkcmVzcyBmb3IgdHJhbnNhY3Rpb24gdHlwZTogJHt0eXBlTmFtZX1gLCBcImRhdGFcIiwgZGF0YSk7XHJcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMpLCBcImludmFsaWQgYmxvYlZlcnNpb25lZEhhc2hlczogbXVzdCBiZSBhbiBhcnJheVwiLCBcImRhdGFcIiwgZGF0YSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzW2ldLCAzMiksIGBpbnZhbGlkIGJsb2JWZXJzaW9uZWRIYXNoIGF0IGluZGV4ICR7aX06IG11c3QgYmUgbGVuZ3RoIDMyYCwgXCJkYXRhXCIsIGRhdGEpO1xyXG4gICAgfVxyXG4gICAgLy8gVW5zaWduZWQgRUlQLTQ4NDQgVHJhbnNhY3Rpb25cclxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSAxMSkge1xyXG4gICAgICAgIHJldHVybiB0eDtcclxuICAgIH1cclxuICAgIC8vIEBUT0RPOiBEbyB3ZSBuZWVkIHRvIGRvIHRoaXM/IFRoaXMgaXMgb25seSBjYWxsZWQgaW50ZXJuYWxseVxyXG4gICAgLy8gYW5kIHVzZWQgdG8gdmVyaWZ5IGhhc2hlczsgaXQgbWlnaHQgc2F2ZSB0aW1lIHRvIG5vdCBkbyB0aGlzXHJcbiAgICAvL3R4Lmhhc2ggPSBrZWNjYWsyNTYoY29uY2F0KFsgXCIweDAzXCIsIGVuY29kZVJscChmaWVsZHMpIF0pKTtcclxuICAgIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLnNsaWNlKDExKSk7XHJcbiAgICByZXR1cm4gdHg7XHJcbn1cclxuZnVuY3Rpb24gX3NlcmlhbGl6ZUVpcDQ4NDQodHgsIHNpZywgYmxvYnMpIHtcclxuICAgIGNvbnN0IGZpZWxkcyA9IFtcclxuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxyXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSwgXCJub25jZVwiKSxcclxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgMCwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcclxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4RmVlUGVyR2FzIHx8IDAsIFwibWF4RmVlUGVyR2FzXCIpLFxyXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNMaW1pdCwgXCJnYXNMaW1pdFwiKSxcclxuICAgICAgICAodHgudG8gfHwgWmVyb0FkZHJlc3MpLFxyXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSwgXCJ2YWx1ZVwiKSxcclxuICAgICAgICB0eC5kYXRhLFxyXG4gICAgICAgIGZvcm1hdEFjY2Vzc0xpc3QodHguYWNjZXNzTGlzdCB8fCBbXSksXHJcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heEZlZVBlckJsb2JHYXMgfHwgMCwgXCJtYXhGZWVQZXJCbG9iR2FzXCIpLFxyXG4gICAgICAgIGZvcm1hdEhhc2hlcyh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzIHx8IFtdLCBcImJsb2JWZXJzaW9uZWRIYXNoZXNcIilcclxuICAgIF07XHJcbiAgICBpZiAoc2lnKSB7XHJcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInlQYXJpdHlcIikpO1xyXG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xyXG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucykpO1xyXG4gICAgICAgIC8vIFdlIGhhdmUgYmxvYnM7IHJldHVybiB0aGUgbmV0d29yayB3cmFwcGVkIGZvcm1hdFxyXG4gICAgICAgIGlmIChibG9icykge1xyXG4gICAgICAgICAgICByZXR1cm4gY29uY2F0KFtcclxuICAgICAgICAgICAgICAgIFwiMHgwM1wiLFxyXG4gICAgICAgICAgICAgICAgZW5jb2RlUmxwKFtcclxuICAgICAgICAgICAgICAgICAgICBmaWVsZHMsXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvYnMubWFwKChiKSA9PiBiLmRhdGEpLFxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2JzLm1hcCgoYikgPT4gYi5jb21taXRtZW50KSxcclxuICAgICAgICAgICAgICAgICAgICBibG9icy5tYXAoKGIpID0+IGIucHJvb2YpLFxyXG4gICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbmNhdChbXCIweDAzXCIsIGVuY29kZVJscChmaWVsZHMpXSk7XHJcbn1cclxuZnVuY3Rpb24gX3BhcnNlRWlwNzcwMihkYXRhKSB7XHJcbiAgICBjb25zdCBmaWVsZHMgPSBkZWNvZGVSbHAoZ2V0Qnl0ZXMoZGF0YSkuc2xpY2UoMSkpO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIChmaWVsZHMubGVuZ3RoID09PSAxMCB8fCBmaWVsZHMubGVuZ3RoID09PSAxMyksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogNFwiLCBcImRhdGFcIiwgaGV4bGlmeShkYXRhKSk7XHJcbiAgICBjb25zdCB0eCA9IHtcclxuICAgICAgICB0eXBlOiA0LFxyXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXHJcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMV0sIFwibm9uY2VcIiksXHJcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxyXG4gICAgICAgIG1heEZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbM10sIFwibWF4RmVlUGVyR2FzXCIpLFxyXG4gICAgICAgIGdhc1ByaWNlOiBudWxsLFxyXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVVaW50KGZpZWxkc1s0XSwgXCJnYXNMaW1pdFwiKSxcclxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbNV0pLFxyXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s2XSwgXCJ2YWx1ZVwiKSxcclxuICAgICAgICBkYXRhOiBoZXhsaWZ5KGZpZWxkc1s3XSksXHJcbiAgICAgICAgYWNjZXNzTGlzdDogaGFuZGxlQWNjZXNzTGlzdChmaWVsZHNbOF0sIFwiYWNjZXNzTGlzdFwiKSxcclxuICAgICAgICBhdXRob3JpemF0aW9uTGlzdDogaGFuZGxlQXV0aG9yaXphdGlvbkxpc3QoZmllbGRzWzldLCBcImF1dGhvcml6YXRpb25MaXN0XCIpLFxyXG4gICAgfTtcclxuICAgIC8vIFVuc2lnbmVkIEVJUC03NzAyIFRyYW5zYWN0aW9uXHJcbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMTApIHtcclxuICAgICAgICByZXR1cm4gdHg7XHJcbiAgICB9XHJcbiAgICBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcy5zbGljZSgxMCkpO1xyXG4gICAgcmV0dXJuIHR4O1xyXG59XHJcbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXA3NzAyKHR4LCBzaWcpIHtcclxuICAgIGNvbnN0IGZpZWxkcyA9IFtcclxuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxyXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSwgXCJub25jZVwiKSxcclxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgMCwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcclxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4RmVlUGVyR2FzIHx8IDAsIFwibWF4RmVlUGVyR2FzXCIpLFxyXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNMaW1pdCwgXCJnYXNMaW1pdFwiKSxcclxuICAgICAgICAodHgudG8gfHwgXCIweFwiKSxcclxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUsIFwidmFsdWVcIiksXHJcbiAgICAgICAgdHguZGF0YSxcclxuICAgICAgICBmb3JtYXRBY2Nlc3NMaXN0KHR4LmFjY2Vzc0xpc3QgfHwgW10pLFxyXG4gICAgICAgIGZvcm1hdEF1dGhvcml6YXRpb25MaXN0KHR4LmF1dGhvcml6YXRpb25MaXN0IHx8IFtdKVxyXG4gICAgXTtcclxuICAgIGlmIChzaWcpIHtcclxuICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnlQYXJpdHksIFwieVBhcml0eVwiKSk7XHJcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5yKSk7XHJcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5zKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29uY2F0KFtcIjB4MDRcIiwgZW5jb2RlUmxwKGZpZWxkcyldKTtcclxufVxyXG4vKipcclxuICogIEEgKipUcmFuc2FjdGlvbioqIGRlc2NyaWJlcyBhbiBvcGVyYXRpb24gdG8gYmUgZXhlY3V0ZWQgb25cclxuICogIEV0aGVyZXVtIGJ5IGFuIEV4dGVybmFsbHkgT3duZWQgQWNjb3VudCAoRU9BKS4gSXQgaW5jbHVkZXNcclxuICogIHdobyAodGhlIFtbdG9dXSBhZGRyZXNzKSwgd2hhdCAodGhlIFtbZGF0YV1dKSBhbmQgaG93IG11Y2ggKHRoZVxyXG4gKiAgW1t2YWx1ZV1dIGluIGV0aGVyKSB0aGUgb3BlcmF0aW9uIHNob3VsZCBlbnRhaWwuXHJcbiAqXHJcbiAqICBAZXhhbXBsZTpcclxuICogICAgdHggPSBuZXcgVHJhbnNhY3Rpb24oKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIHR4LmRhdGEgPSBcIjB4MTIzNFwiO1xyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb24ge1xyXG4gICAgI3R5cGU7XHJcbiAgICAjdG87XHJcbiAgICAjZGF0YTtcclxuICAgICNub25jZTtcclxuICAgICNnYXNMaW1pdDtcclxuICAgICNnYXNQcmljZTtcclxuICAgICNtYXhQcmlvcml0eUZlZVBlckdhcztcclxuICAgICNtYXhGZWVQZXJHYXM7XHJcbiAgICAjdmFsdWU7XHJcbiAgICAjY2hhaW5JZDtcclxuICAgICNzaWc7XHJcbiAgICAjYWNjZXNzTGlzdDtcclxuICAgICNtYXhGZWVQZXJCbG9iR2FzO1xyXG4gICAgI2Jsb2JWZXJzaW9uZWRIYXNoZXM7XHJcbiAgICAja3pnO1xyXG4gICAgI2Jsb2JzO1xyXG4gICAgI2F1dGhzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIHR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogIElmIG51bGwsIHRoZSB0eXBlIHdpbGwgYmUgYXV0b21hdGljYWxseSBpbmZlcnJlZCBiYXNlZCBvblxyXG4gICAgICogIGV4cGxpY2l0IHByb3BlcnRpZXMuXHJcbiAgICAgKi9cclxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy4jdHlwZTsgfVxyXG4gICAgc2V0IHR5cGUodmFsdWUpIHtcclxuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgbnVsbDpcclxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgY2FzZSBcImxlZ2FjeVwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICBjYXNlIFwiYmVybGluXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJlaXAtMjkzMFwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICBjYXNlIFwibG9uZG9uXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJlaXAtMTU1OVwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICBjYXNlIFwiY2FuY3VuXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJlaXAtNDg0NFwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDM7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICBjYXNlIFwicGVjdHJhXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJlaXAtNzcwMlwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGVcIiwgXCJ0eXBlXCIsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgdHJhbnNhY3Rpb24gdHlwZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHR5cGVOYW1lKCkge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFwibGVnYWN5XCI7XHJcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFwiZWlwLTI5MzBcIjtcclxuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gXCJlaXAtMTU1OVwiO1xyXG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiBcImVpcC00ODQ0XCI7XHJcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFwiZWlwLTc3MDJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYGB0b2BgIGFkZHJlc3MgZm9yIHRoZSB0cmFuc2FjdGlvbiBvciBgYG51bGxgYCBpZiB0aGVcclxuICAgICAqICB0cmFuc2FjdGlvbiBpcyBhbiBgYGluaXRgYCB0cmFuc2FjdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0IHRvKCkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdG87XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgdGhpcy50eXBlID09PSAzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBaZXJvQWRkcmVzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IHRvKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy4jdG8gPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QWRkcmVzcyh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gbm9uY2UuXHJcbiAgICAgKi9cclxuICAgIGdldCBub25jZSgpIHsgcmV0dXJuIHRoaXMuI25vbmNlOyB9XHJcbiAgICBzZXQgbm9uY2UodmFsdWUpIHsgdGhpcy4jbm9uY2UgPSBnZXROdW1iZXIodmFsdWUsIFwidmFsdWVcIik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBnYXMgbGltaXQuXHJcbiAgICAgKi9cclxuICAgIGdldCBnYXNMaW1pdCgpIHsgcmV0dXJuIHRoaXMuI2dhc0xpbWl0OyB9XHJcbiAgICBzZXQgZ2FzTGltaXQodmFsdWUpIHsgdGhpcy4jZ2FzTGltaXQgPSBnZXRCaWdJbnQodmFsdWUpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZ2FzIHByaWNlLlxyXG4gICAgICpcclxuICAgICAqICBPbiBsZWdhY3kgbmV0d29ya3MgdGhpcyBkZWZpbmVzIHRoZSBmZWUgdGhhdCB3aWxsIGJlIHBhaWQuIE9uXHJcbiAgICAgKiAgRUlQLTE1NTkgbmV0d29ya3MsIHRoaXMgc2hvdWxkIGJlIGBgbnVsbGBgLlxyXG4gICAgICovXHJcbiAgICBnZXQgZ2FzUHJpY2UoKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNnYXNQcmljZTtcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiAodGhpcy50eXBlID09PSAwIHx8IHRoaXMudHlwZSA9PT0gMSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEJOXzA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCBnYXNQcmljZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuI2dhc1ByaWNlID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGdldEJpZ0ludCh2YWx1ZSwgXCJnYXNQcmljZVwiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBtYXhpbXVtIHByaW9yaXR5IGZlZSBwZXIgdW5pdCBvZiBnYXMgdG8gcGF5LiBPbiBsZWdhY3lcclxuICAgICAqICBuZXR3b3JrcyB0aGlzIHNob3VsZCBiZSBgYG51bGxgYC5cclxuICAgICAqL1xyXG4gICAgZ2V0IG1heFByaW9yaXR5RmVlUGVyR2FzKCkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4UHJpb3JpdHlGZWVQZXJHYXM7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gMiB8fCB0aGlzLnR5cGUgPT09IDMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBCTl8wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXModmFsdWUpIHtcclxuICAgICAgICB0aGlzLiNtYXhQcmlvcml0eUZlZVBlckdhcyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRCaWdJbnQodmFsdWUsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbWF4aW11bSB0b3RhbCBmZWUgcGVyIHVuaXQgb2YgZ2FzIHRvIHBheS4gT24gbGVnYWN5XHJcbiAgICAgKiAgbmV0d29ya3MgdGhpcyBzaG91bGQgYmUgYGBudWxsYGAuXHJcbiAgICAgKi9cclxuICAgIGdldCBtYXhGZWVQZXJHYXMoKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNtYXhGZWVQZXJHYXM7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gMiB8fCB0aGlzLnR5cGUgPT09IDMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBCTl8wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgbWF4RmVlUGVyR2FzKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy4jbWF4RmVlUGVyR2FzID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGdldEJpZ0ludCh2YWx1ZSwgXCJtYXhGZWVQZXJHYXNcIik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gZGF0YS4gRm9yIGBgaW5pdGBgIHRyYW5zYWN0aW9ucyB0aGlzIGlzIHRoZVxyXG4gICAgICogIGRlcGxveW1lbnQgY29kZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGRhdGEoKSB7IHJldHVybiB0aGlzLiNkYXRhOyB9XHJcbiAgICBzZXQgZGF0YSh2YWx1ZSkgeyB0aGlzLiNkYXRhID0gaGV4bGlmeSh2YWx1ZSk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBhbW91bnQgb2YgZXRoZXIgKGluIHdlaSkgdG8gc2VuZCBpbiB0aGlzIHRyYW5zYWN0aW9ucy5cclxuICAgICAqL1xyXG4gICAgZ2V0IHZhbHVlKCkgeyByZXR1cm4gdGhpcy4jdmFsdWU7IH1cclxuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuI3ZhbHVlID0gZ2V0QmlnSW50KHZhbHVlLCBcInZhbHVlXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGNoYWluIElEIHRoaXMgdHJhbnNhY3Rpb24gaXMgdmFsaWQgb24uXHJcbiAgICAgKi9cclxuICAgIGdldCBjaGFpbklkKCkgeyByZXR1cm4gdGhpcy4jY2hhaW5JZDsgfVxyXG4gICAgc2V0IGNoYWluSWQodmFsdWUpIHsgdGhpcy4jY2hhaW5JZCA9IGdldEJpZ0ludCh2YWx1ZSk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIElmIHNpZ25lZCwgdGhlIHNpZ25hdHVyZSBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0IHNpZ25hdHVyZSgpIHsgcmV0dXJuIHRoaXMuI3NpZyB8fCBudWxsOyB9XHJcbiAgICBzZXQgc2lnbmF0dXJlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy4jc2lnID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IFNpZ25hdHVyZS5mcm9tKHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBhY2Nlc3MgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiAgQW4gYWNjZXNzIGxpc3QgcGVybWl0cyBkaXNjb3VudGVkIChidXQgcHJlLXBhaWQpIGFjY2VzcyB0b1xyXG4gICAgICogIGJ5dGVjb2RlIGFuZCBzdGF0ZSB2YXJpYWJsZSBhY2Nlc3Mgd2l0aGluIGNvbnRyYWN0IGV4ZWN1dGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0IGFjY2Vzc0xpc3QoKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNhY2Nlc3NMaXN0IHx8IG51bGw7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gMSB8fCB0aGlzLnR5cGUgPT09IDIgfHwgdGhpcy50eXBlID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBAVE9ETzogaW4gdjcsIHRoaXMgc2hvdWxkIGFzc2lnbiB0aGUgdmFsdWUgb3IgYmVjb21lXHJcbiAgICAgICAgICAgICAgICAvLyBhIGxpdmUgb2JqZWN0IGl0c2VsZiwgb3RoZXJ3aXNlIG11dGF0aW9uIGlzIGluY29uc2lzdGVudFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgYWNjZXNzTGlzdCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuI2FjY2Vzc0xpc3QgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogYWNjZXNzTGlzdGlmeSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBnZXQgYXV0aG9yaXphdGlvbkxpc3QoKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNhdXRocyB8fCBudWxsO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IDQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBpbiB2NywgdGhpcyBzaG91bGQgYmVjb21lIGEgbGl2ZSBvYmplY3QgaXRzZWxmLFxyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIG11dGF0aW9uIGlzIGluY29uc2lzdGVudFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCBhdXRob3JpemF0aW9uTGlzdChhdXRocykge1xyXG4gICAgICAgIHRoaXMuI2F1dGhzID0gKGF1dGhzID09IG51bGwpID8gbnVsbCA6IGF1dGhzLm1hcCgoYSkgPT4gYXV0aG9yaXphdGlvbmlmeShhKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbWF4IGZlZSBwZXIgYmxvYiBnYXMgZm9yIENhbmN1biB0cmFuc2FjdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIGdldCBtYXhGZWVQZXJCbG9iR2FzKCkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4RmVlUGVyQmxvYkdhcztcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiB0aGlzLnR5cGUgPT09IDMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEJOXzA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCBtYXhGZWVQZXJCbG9iR2FzKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy4jbWF4RmVlUGVyQmxvYkdhcyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRCaWdJbnQodmFsdWUsIFwibWF4RmVlUGVyQmxvYkdhc1wiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBCTE9iIHZlcnNpb25lZCBoYXNoZXMgZm9yIENhbmN1biB0cmFuc2FjdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIGdldCBibG9iVmVyc2lvbmVkSGFzaGVzKCkge1xyXG4gICAgICAgIC8vIEBUT0RPOiBNdXRhdGlvbiBpcyBpbmNvbnNpc3RlbnQ7IGlmIHVuc2V0LCB0aGUgcmV0dXJuZWQgdmFsdWVcclxuICAgICAgICAvLyBjYW5ub3QgbXV0YXRlIHRoZSBvYmplY3QsIGlmIHNldCBpdCBjYW5cclxuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLiNibG9iVmVyc2lvbmVkSGFzaGVzO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmIHRoaXMudHlwZSA9PT0gMykge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCBibG9iVmVyc2lvbmVkSGFzaGVzKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheSh2YWx1ZSksIFwiYmxvYlZlcnNpb25lZEhhc2hlcyBtdXN0IGJlIGFuIEFycmF5XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHZhbHVlW2ldLCAzMiksIFwiaW52YWxpZCBibG9iVmVyc2lvbmVkSGFzaFwiLCBgdmFsdWVbJHtpfV1gLCB2YWx1ZVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jYmxvYlZlcnNpb25lZEhhc2hlcyA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIEJMT2JzIGZvciB0aGUgVHJhbnNhY3Rpb24sIGlmIGFueS5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgYGBibG9ic2BgIGlzIG5vbi1gYG51bGxgYCwgdGhlbiB0aGUgW1tzZXJpYWlsaXplZF1dXHJcbiAgICAgKiAgd2lsbCByZXR1cm4gdGhlIG5ldHdvcmsgZm9ybWF0dGVkIHNpZGVjYXIsIG90aGVyd2lzZSBpdFxyXG4gICAgICogIHdpbGwgcmV0dXJuIHRoZSBzdGFuZGFyZCBbW2xpbmstZWlwLTI3MThdXSBwYXlsb2FkLiBUaGVcclxuICAgICAqICBbW3Vuc2lnbmVkU2VyaWFsaXplZF1dIGlzIHVuYWZmZWN0ZWQgcmVnYXJkbGVzcy5cclxuICAgICAqXHJcbiAgICAgKiAgV2hlbiBzZXR0aW5nIGBgYmxvYnNgYCwgZWl0aGVyIGZ1bGx5IHZhbGlkIFtbQmxvYl1dIG9iamVjdHNcclxuICAgICAqICBtYXkgYmUgc3BlY2lmaWVkIChpLmUuIGNvcnJlY3RseSBwYWRkZWQsIHdpdGggY29ycmVjdFxyXG4gICAgICogIGNvbW1pdHRtZW50cyBhbmQgcHJvb2ZzKSBvciBhIHJhdyBbW0J5dGVzTGlrZV1dIG1heVxyXG4gICAgICogIGJlIHByb3ZpZGVkLlxyXG4gICAgICpcclxuICAgICAqICBJZiByYXcgW1tCeXRlc0xpa2VdXSBhcmUgcHJvdmlkZWQsIHRoZSBbW2t6Z11dIHByb3BlcnR5ICoqbXVzdCoqXHJcbiAgICAgKiAgYmUgYWxyZWFkeSBzZXQuIFRoZSBibG9iIHdpbGwgYmUgY29ycmVjdGx5IHBhZGRlZCBhbmQgdGhlXHJcbiAgICAgKiAgW1tLemdMaWJyYXJ5XV0gd2lsbCBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGNvbW1pdHRtZW50IGFuZFxyXG4gICAgICogIHByb29mIGZvciB0aGUgYmxvYi5cclxuICAgICAqXHJcbiAgICAgKiAgQSBCTE9iIGlzIGEgc2VxdWVuY2Ugb2YgZmllbGQgZWxlbWVudHMsIGVhY2ggb2Ygd2hpY2ggbXVzdFxyXG4gICAgICogIGJlIHdpdGhpbiB0aGUgQkxTIGZpZWxkIG1vZHVsbywgc28gc29tZSBhZGRpdGlvbmFsIHByb2Nlc3NpbmdcclxuICAgICAqICBtYXkgYmUgcmVxdWlyZWQgdG8gZW5jb2RlIGFyYml0cmFyeSBkYXRhIHRvIGVuc3VyZSBlYWNoIDMyIGJ5dGVcclxuICAgICAqICBmaWVsZCBpcyB3aXRoaW4gdGhlIHZhbGlkIHJhbmdlLlxyXG4gICAgICpcclxuICAgICAqICBTZXR0aW5nIHRoaXMgYXV0b21hdGljYWxseSBwb3B1bGF0ZXMgW1tibG9iVmVyc2lvbmVkSGFzaGVzXV0sXHJcbiAgICAgKiAgb3ZlcndyaXRpbmcgYW55IGV4aXN0aW5nIHZhbHVlcy4gU2V0dGluZyB0aGlzIHRvIGBgbnVsbGBgXHJcbiAgICAgKiAgZG9lcyAqKm5vdCoqIHJlbW92ZSB0aGUgW1tibG9iVmVyc2lvbmVkSGFzaGVzXV0sIGxlYXZpbmcgdGhlbVxyXG4gICAgICogIHByZXNlbnQuXHJcbiAgICAgKi9cclxuICAgIGdldCBibG9icygpIHtcclxuICAgICAgICBpZiAodGhpcy4jYmxvYnMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Jsb2JzLm1hcCgoYikgPT4gT2JqZWN0LmFzc2lnbih7fSwgYikpO1xyXG4gICAgfVxyXG4gICAgc2V0IGJsb2JzKF9ibG9icykge1xyXG4gICAgICAgIGlmIChfYmxvYnMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLiNibG9icyA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYmxvYnMgPSBbXTtcclxuICAgICAgICBjb25zdCB2ZXJzaW9uZWRIYXNoZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9ibG9icy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBibG9iID0gX2Jsb2JzW2ldO1xyXG4gICAgICAgICAgICBpZiAoaXNCeXRlc0xpa2UoYmxvYikpIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydCh0aGlzLiNremcsIFwiYWRkaW5nIGEgcmF3IGJsb2IgcmVxdWlyZXMgYSBLWkcgbGlicmFyeVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldCBibG9icygpXCJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBnZXRCeXRlcyhibG9iKTtcclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGEubGVuZ3RoIDw9IEJMT0JfU0laRSwgXCJibG9iIGlzIHRvbyBsYXJnZVwiLCBgYmxvYnNbJHtpfV1gLCBibG9iKTtcclxuICAgICAgICAgICAgICAgIC8vIFBhZCBibG9iIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSBCTE9CX1NJWkUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheShCTE9CX1NJWkUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZGRlZC5zZXQoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHBhZGRlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1pdCA9IHRoaXMuI2t6Zy5ibG9iVG9LemdDb21taXRtZW50KGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvb2YgPSBoZXhsaWZ5KHRoaXMuI2t6Zy5jb21wdXRlQmxvYkt6Z1Byb29mKGRhdGEsIGNvbW1pdCkpO1xyXG4gICAgICAgICAgICAgICAgYmxvYnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaGV4bGlmeShkYXRhKSxcclxuICAgICAgICAgICAgICAgICAgICBjb21taXRtZW50OiBoZXhsaWZ5KGNvbW1pdCksXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvb2ZcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdmVyc2lvbmVkSGFzaGVzLnB1c2goZ2V0VmVyc2lvbmVkSGFzaCgxLCBjb21taXQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1pdCA9IGhleGxpZnkoYmxvYi5jb21taXRtZW50KTtcclxuICAgICAgICAgICAgICAgIGJsb2JzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGhleGxpZnkoYmxvYi5kYXRhKSxcclxuICAgICAgICAgICAgICAgICAgICBjb21taXRtZW50OiBjb21taXQsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvb2Y6IGhleGxpZnkoYmxvYi5wcm9vZilcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdmVyc2lvbmVkSGFzaGVzLnB1c2goZ2V0VmVyc2lvbmVkSGFzaCgxLCBjb21taXQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiNibG9icyA9IGJsb2JzO1xyXG4gICAgICAgIHRoaXMuI2Jsb2JWZXJzaW9uZWRIYXNoZXMgPSB2ZXJzaW9uZWRIYXNoZXM7XHJcbiAgICB9XHJcbiAgICBnZXQga3pnKCkgeyByZXR1cm4gdGhpcy4ja3pnOyB9XHJcbiAgICBzZXQga3pnKGt6Zykge1xyXG4gICAgICAgIGlmIChremcgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLiNremcgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy4ja3pnID0gZ2V0S3pnTGlicmFyeShremcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgVHJhbnNhY3Rpb24gd2l0aCBkZWZhdWx0IHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy4jdHlwZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy4jdG8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuI25vbmNlID0gMDtcclxuICAgICAgICB0aGlzLiNnYXNMaW1pdCA9IEJOXzA7XHJcbiAgICAgICAgdGhpcy4jZ2FzUHJpY2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuI21heFByaW9yaXR5RmVlUGVyR2FzID0gbnVsbDtcclxuICAgICAgICB0aGlzLiNtYXhGZWVQZXJHYXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuI2RhdGEgPSBcIjB4XCI7XHJcbiAgICAgICAgdGhpcy4jdmFsdWUgPSBCTl8wO1xyXG4gICAgICAgIHRoaXMuI2NoYWluSWQgPSBCTl8wO1xyXG4gICAgICAgIHRoaXMuI3NpZyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy4jYWNjZXNzTGlzdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy4jbWF4RmVlUGVyQmxvYkdhcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy4jYmxvYlZlcnNpb25lZEhhc2hlcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy4ja3pnID0gbnVsbDtcclxuICAgICAgICB0aGlzLiNibG9icyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy4jYXV0aHMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2gsIGlmIHNpZ25lZC4gT3RoZXJ3aXNlLCBgYG51bGxgYC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGhhc2goKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2lnbmF0dXJlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYodGhpcy4jZ2V0U2VyaWFsaXplZCh0cnVlLCBmYWxzZSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHByZS1pbWFnZSBoYXNoIG9mIHRoaXMgdHJhbnNhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgaXMgdGhlIGRpZ2VzdCB0aGF0IGEgW1tTaWduZXJdXSBtdXN0IHNpZ24gdG8gYXV0aG9yaXplXHJcbiAgICAgKiAgdGhpcyB0cmFuc2FjdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0IHVuc2lnbmVkSGFzaCgpIHtcclxuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHRoaXMudW5zaWduZWRTZXJpYWxpemVkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBzZW5kaW5nIGFkZHJlc3MsIGlmIHNpZ25lZC4gT3RoZXJ3aXNlLCBgYG51bGxgYC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGZyb20oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2lnbmF0dXJlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWNvdmVyQWRkcmVzcyh0aGlzLnVuc2lnbmVkSGFzaCwgdGhpcy5zaWduYXR1cmUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHB1YmxpYyBrZXkgb2YgdGhlIHNlbmRlciwgaWYgc2lnbmVkLiBPdGhlcndpc2UsIGBgbnVsbGBgLlxyXG4gICAgICovXHJcbiAgICBnZXQgZnJvbVB1YmxpY0tleSgpIHtcclxuICAgICAgICBpZiAodGhpcy5zaWduYXR1cmUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNpZ25pbmdLZXkucmVjb3ZlclB1YmxpY0tleSh0aGlzLnVuc2lnbmVkSGFzaCwgdGhpcy5zaWduYXR1cmUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHNpZ25lZC5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCBwcm9wZXJ0aWVzIHJlcXVpcmluZyBhIHNpZ25lZFxyXG4gICAgICogIHRyYW5zYWN0aW9uIGFyZSBub24tbnVsbC5cclxuICAgICAqL1xyXG4gICAgaXNTaWduZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmF0dXJlICE9IG51bGw7XHJcbiAgICB9XHJcbiAgICAjZ2V0U2VyaWFsaXplZChzaWduZWQsIHNpZGVjYXIpIHtcclxuICAgICAgICBhc3NlcnQoIXNpZ25lZCB8fCB0aGlzLnNpZ25hdHVyZSAhPSBudWxsLCBcImNhbm5vdCBzZXJpYWxpemUgdW5zaWduZWQgdHJhbnNhY3Rpb247IG1heWJlIHlvdSBtZWFudCAudW5zaWduZWRTZXJpYWxpemVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcIi5zZXJpYWxpemVkXCIgfSk7XHJcbiAgICAgICAgY29uc3Qgc2lnID0gc2lnbmVkID8gdGhpcy5zaWduYXR1cmUgOiBudWxsO1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5pbmZlclR5cGUoKSkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUxlZ2FjeSh0aGlzLCBzaWcpO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDI5MzAodGhpcywgc2lnKTtcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAxNTU5KHRoaXMsIHNpZyk7XHJcbiAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwNDg0NCh0aGlzLCBzaWcsIHNpZGVjYXIgPyB0aGlzLmJsb2JzIDogbnVsbCk7XHJcbiAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwNzcwMih0aGlzLCBzaWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCIuc2VyaWFsaXplZFwiIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgdGhyb3dzIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyB1bnNpZ25lZC4gRm9yIHRoZSBwcmUtaW1hZ2UsXHJcbiAgICAgKiAgdXNlIFtbdW5zaWduZWRTZXJpYWxpemVkXV0uXHJcbiAgICAgKi9cclxuICAgIGdldCBzZXJpYWxpemVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNnZXRTZXJpYWxpemVkKHRydWUsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIHByZS1pbWFnZS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhlIGhhc2ggb2YgdGhpcyBpcyB0aGUgZGlnZXN0IHdoaWNoIG5lZWRzIHRvIGJlIHNpZ25lZCB0b1xyXG4gICAgICogIGF1dGhvcml6ZSB0aGlzIHRyYW5zYWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXQgdW5zaWduZWRTZXJpYWxpemVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNnZXRTZXJpYWxpemVkKGZhbHNlLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gdGhlIG1vc3QgXCJsaWtlbHlcIiB0eXBlOyBjdXJyZW50bHkgdGhlIGhpZ2hlc3RcclxuICAgICAqICBzdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZS5cclxuICAgICAqL1xyXG4gICAgaW5mZXJUeXBlKCkge1xyXG4gICAgICAgIGNvbnN0IHR5cGVzID0gdGhpcy5pbmZlclR5cGVzKCk7XHJcbiAgICAgICAgLy8gUHJlZmVyIExvbmRvbiAoRUlQLTE1NTkpIG92ZXIgQ2FuY3VuIChCTE9iKVxyXG4gICAgICAgIGlmICh0eXBlcy5pbmRleE9mKDIpID49IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJldHVybiB0aGUgaGlnaGVzdCBpbmZlcnJlZCB0eXBlXHJcbiAgICAgICAgcmV0dXJuICh0eXBlcy5wb3AoKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBWYWxpZGF0ZXMgdGhlIGV4cGxpY2l0IHByb3BlcnRpZXMgYW5kIHJldHVybnMgYSBsaXN0IG9mIGNvbXBhdGlibGVcclxuICAgICAqICB0cmFuc2FjdGlvbiB0eXBlcy5cclxuICAgICAqL1xyXG4gICAgaW5mZXJUeXBlcygpIHtcclxuICAgICAgICAvLyBDaGVja3MgdGhhdCB0aGVyZSBhcmUgbm8gY29uZmxpY3RpbmcgcHJvcGVydGllcyBzZXRcclxuICAgICAgICBjb25zdCBoYXNHYXNQcmljZSA9IHRoaXMuZ2FzUHJpY2UgIT0gbnVsbDtcclxuICAgICAgICBjb25zdCBoYXNGZWUgPSAodGhpcy5tYXhGZWVQZXJHYXMgIT0gbnVsbCB8fCB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpO1xyXG4gICAgICAgIGNvbnN0IGhhc0FjY2Vzc0xpc3QgPSAodGhpcy5hY2Nlc3NMaXN0ICE9IG51bGwpO1xyXG4gICAgICAgIGNvbnN0IGhhc0Jsb2IgPSAodGhpcy4jbWF4RmVlUGVyQmxvYkdhcyAhPSBudWxsIHx8IHRoaXMuI2Jsb2JWZXJzaW9uZWRIYXNoZXMpO1xyXG4gICAgICAgIC8vaWYgKGhhc0dhc1ByaWNlICYmIGhhc0ZlZSkge1xyXG4gICAgICAgIC8vICAgIHRocm93IG5ldyBFcnJvcihcInRyYW5zYWN0aW9uIGNhbm5vdCBoYXZlIGdhc1ByaWNlIGFuZCBtYXhGZWVQZXJHYXNcIik7XHJcbiAgICAgICAgLy99XHJcbiAgICAgICAgaWYgKHRoaXMubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLm1heEZlZVBlckdhcyA+PSB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzLCBcInByaW9yaXR5RmVlIGNhbm5vdCBiZSBtb3JlIHRoYW4gbWF4RmVlXCIsIFwiQkFEX0RBVEFcIiwgeyB2YWx1ZTogdGhpcyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9pZiAodGhpcy50eXBlID09PSAyICYmIGhhc0dhc1ByaWNlKSB7XHJcbiAgICAgICAgLy8gICAgdGhyb3cgbmV3IEVycm9yKFwiZWlwLTE1NTkgdHJhbnNhY3Rpb24gY2Fubm90IGhhdmUgZ2FzUHJpY2VcIik7XHJcbiAgICAgICAgLy99XHJcbiAgICAgICAgYXNzZXJ0KCFoYXNGZWUgfHwgKHRoaXMudHlwZSAhPT0gMCAmJiB0aGlzLnR5cGUgIT09IDEpLCBcInRyYW5zYWN0aW9uIHR5cGUgY2Fubm90IGhhdmUgbWF4RmVlUGVyR2FzIG9yIG1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwiQkFEX0RBVEFcIiwgeyB2YWx1ZTogdGhpcyB9KTtcclxuICAgICAgICBhc3NlcnQodGhpcy50eXBlICE9PSAwIHx8ICFoYXNBY2Nlc3NMaXN0LCBcImxlZ2FjeSB0cmFuc2FjdGlvbiBjYW5ub3QgaGF2ZSBhY2Nlc3NMaXN0XCIsIFwiQkFEX0RBVEFcIiwgeyB2YWx1ZTogdGhpcyB9KTtcclxuICAgICAgICBjb25zdCB0eXBlcyA9IFtdO1xyXG4gICAgICAgIC8vIEV4cGxpY2l0IHR5cGVcclxuICAgICAgICBpZiAodGhpcy50eXBlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdHlwZXMucHVzaCh0aGlzLnR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYXV0aG9yaXphdGlvbkxpc3QgJiYgdGhpcy5hdXRob3JpemF0aW9uTGlzdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goNCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzRmVlKSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0dhc1ByaWNlKSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNBY2Nlc3NMaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZXMucHVzaCgwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChoYXNBY2Nlc3NMaXN0KSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDEpO1xyXG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChoYXNCbG9iICYmIHRoaXMudG8pIHtcclxuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDApO1xyXG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcclxuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMik7XHJcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHR5cGVzLnNvcnQoKTtcclxuICAgICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBhIGxlZ2FjeSB0cmFuc2FjdGlvbiAoaS5lLlxyXG4gICAgICogIGBgdHlwZSA9PT0gMGBgKS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxyXG4gICAgICogIG5vbi1udWxsLlxyXG4gICAgICovXHJcbiAgICBpc0xlZ2FjeSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBiZXJsaW4gaGFyZGZvcm0gdHJhbnNhY3Rpb24gKGkuZS5cclxuICAgICAqICBgYHR5cGUgPT09IDFgYCkuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhlIHJlbGF0ZWQgcHJvcGVydGllcyBhcmVcclxuICAgICAqICBub24tbnVsbC5cclxuICAgICAqL1xyXG4gICAgaXNCZXJsaW4oKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgbG9uZG9uIGhhcmRmb3JtIHRyYW5zYWN0aW9uIChpLmUuXHJcbiAgICAgKiAgYGB0eXBlID09PSAyYGApLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoZSByZWxhdGVkIHByb3BlcnRpZXMgYXJlXHJcbiAgICAgKiAgbm9uLW51bGwuXHJcbiAgICAgKi9cclxuICAgIGlzTG9uZG9uKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHRyYW5zYWN0aW9uIGlzIGFuIFtbbGluay1laXAtNDg0NF1dIEJMT0JcclxuICAgICAqICB0cmFuc2FjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxyXG4gICAgICogIG5vbi1udWxsLlxyXG4gICAgICovXHJcbiAgICBpc0NhbmN1bigpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgdHJhbnNhY2l0b24uXHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgSlNPTi1mcmllbmRseSBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCBzID0gKHYpID0+IHtcclxuICAgICAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcclxuICAgICAgICAgICAgdG86IHRoaXMudG8sXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLFxyXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXHJcbiAgICAgICAgICAgIG5vbmNlOiB0aGlzLm5vbmNlLFxyXG4gICAgICAgICAgICBnYXNMaW1pdDogcyh0aGlzLmdhc0xpbWl0KSxcclxuICAgICAgICAgICAgZ2FzUHJpY2U6IHModGhpcy5nYXNQcmljZSksXHJcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBzKHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxyXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHModGhpcy5tYXhGZWVQZXJHYXMpLFxyXG4gICAgICAgICAgICB2YWx1ZTogcyh0aGlzLnZhbHVlKSxcclxuICAgICAgICAgICAgY2hhaW5JZDogcyh0aGlzLmNoYWluSWQpLFxyXG4gICAgICAgICAgICBzaWc6IHRoaXMuc2lnbmF0dXJlID8gdGhpcy5zaWduYXR1cmUudG9KU09OKCkgOiBudWxsLFxyXG4gICAgICAgICAgICBhY2Nlc3NMaXN0OiB0aGlzLmFjY2Vzc0xpc3RcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlIGEgKipUcmFuc2FjdGlvbioqIGZyb20gYSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIG9yIGFcclxuICAgICAqICBUcmFuc2FjdGlvbi1saWtlIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb20odHgpIHtcclxuICAgICAgICBpZiAodHggPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZ2V0Qnl0ZXModHgpO1xyXG4gICAgICAgICAgICBpZiAocGF5bG9hZFswXSA+PSAweDdmKSB7IC8vIEBUT0RPOiA+IHZzID49ID8/XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShfcGFyc2VMZWdhY3kocGF5bG9hZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAocGF5bG9hZFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShfcGFyc2VFaXAyOTMwKHBheWxvYWQpKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlRWlwMTU1OShwYXlsb2FkKSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUVpcDQ4NDQocGF5bG9hZCkpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShfcGFyc2VFaXA3NzAyKHBheWxvYWQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmcm9tXCIgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBUcmFuc2FjdGlvbigpO1xyXG4gICAgICAgIGlmICh0eC50eXBlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSB0eC50eXBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHgudG8gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQudG8gPSB0eC50bztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR4Lm5vbmNlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0Lm5vbmNlID0gdHgubm9uY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eC5nYXNMaW1pdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5nYXNMaW1pdCA9IHR4Lmdhc0xpbWl0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQuZ2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0Lm1heFByaW9yaXR5RmVlUGVyR2FzID0gdHgubWF4UHJpb3JpdHlGZWVQZXJHYXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQubWF4RmVlUGVyR2FzID0gdHgubWF4RmVlUGVyR2FzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHgubWF4RmVlUGVyQmxvYkdhcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5tYXhGZWVQZXJCbG9iR2FzID0gdHgubWF4RmVlUGVyQmxvYkdhcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR4LmRhdGEgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IHR4LmRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eC52YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHR4LnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHguY2hhaW5JZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gdHguY2hhaW5JZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR4LnNpZ25hdHVyZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh0eC5zaWduYXR1cmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHguYWNjZXNzTGlzdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hY2Nlc3NMaXN0ID0gdHguYWNjZXNzTGlzdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR4LmF1dGhvcml6YXRpb25MaXN0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmF1dGhvcml6YXRpb25MaXN0ID0gdHguYXV0aG9yaXphdGlvbkxpc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoaXMgd2lsbCBnZXQgb3ZlcndyaXR0ZW4gYnkgYmxvYnMsIGlmIHByZXNlbnRcclxuICAgICAgICBpZiAodHguYmxvYlZlcnNpb25lZEhhc2hlcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5ibG9iVmVyc2lvbmVkSGFzaGVzID0gdHguYmxvYlZlcnNpb25lZEhhc2hlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGFzc2lnbiB0aGUga3pnIGJlZm9yZSBhc3NpZ25pbmcgYmxvYnMsIHdoaWNoXHJcbiAgICAgICAgLy8gcmVxdWlyZSB0aGUgbGlicmFyeSBpbiB0aGUgZXZlbnQgcmF3IGJsb2IgZGF0YSBpcyBwcm92aWRlZC5cclxuICAgICAgICBpZiAodHgua3pnICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0Lmt6ZyA9IHR4Lmt6ZztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR4LmJsb2JzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmJsb2JzID0gdHguYmxvYnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eC5oYXNoICE9IG51bGwpIHtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0LmlzU2lnbmVkKCksIFwidW5zaWduZWQgdHJhbnNhY3Rpb24gY2Fubm90IGRlZmluZSAnLmhhc2gnXCIsIFwidHhcIiwgdHgpO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQuaGFzaCA9PT0gdHguaGFzaCwgXCJoYXNoIG1pc21hdGNoXCIsIFwidHhcIiwgdHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHguZnJvbSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5pc1NpZ25lZCgpLCBcInVuc2lnbmVkIHRyYW5zYWN0aW9uIGNhbm5vdCBkZWZpbmUgJy5mcm9tJ1wiLCBcInR4XCIsIHR4KTtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0LmZyb20udG9Mb3dlckNhc2UoKSA9PT0gKHR4LmZyb20gfHwgXCJcIikudG9Mb3dlckNhc2UoKSwgXCJmcm9tIG1pc21hdGNoXCIsIFwidHhcIiwgdHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zYWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/transaction.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/base58.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/base58.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBase58: () => (/* binding */ decodeBase58),\n/* harmony export */   encodeBase58: () => (/* binding */ encodeBase58)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./maths.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/**\r\n *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value\r\n *  to be encoded as a compact string using a radix of 58 using only\r\n *  alpha-numeric characters. Confusingly similar characters are omitted\r\n *  (i.e. ``\"l0O\"``).\r\n *\r\n *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,\r\n *  since any zero-bytes on the left would get removed. To mitigate this\r\n *  issue most schemes that use Base58 choose specific high-order values\r\n *  to ensure non-zero prefixes.\r\n *\r\n *  @_subsection: api/utils:Base58 Encoding [about-base58]\r\n */\r\n\r\n\r\n\r\nconst Alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\r\nlet Lookup = null;\r\nfunction getAlpha(letter) {\r\n    if (Lookup == null) {\r\n        Lookup = {};\r\n        for (let i = 0; i < Alphabet.length; i++) {\r\n            Lookup[Alphabet[i]] = BigInt(i);\r\n        }\r\n    }\r\n    const result = Lookup[letter];\r\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(result != null, `invalid base58 value`, \"letter\", letter);\r\n    return result;\r\n}\r\nconst BN_0 = BigInt(0);\r\nconst BN_58 = BigInt(58);\r\n/**\r\n *  Encode %%value%% as a Base58-encoded string.\r\n */\r\nfunction encodeBase58(_value) {\r\n    const bytes = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_value);\r\n    let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.toBigInt)(bytes);\r\n    let result = \"\";\r\n    while (value) {\r\n        result = Alphabet[Number(value % BN_58)] + result;\r\n        value /= BN_58;\r\n    }\r\n    // Account for leading padding zeros\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        if (bytes[i]) {\r\n            break;\r\n        }\r\n        result = Alphabet[0] + result;\r\n    }\r\n    return result;\r\n}\r\n/**\r\n *  Decode the Base58-encoded %%value%%.\r\n */\r\nfunction decodeBase58(value) {\r\n    let result = BN_0;\r\n    for (let i = 0; i < value.length; i++) {\r\n        result *= BN_58;\r\n        result += getAlpha(value[i]);\r\n    }\r\n    return result;\r\n}\r\n//# sourceMappingURL=base58.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9iYXNlNTguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQztBQUNRO0FBQ1A7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDBEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxrQkFBa0Isa0RBQVE7QUFDMUIsZ0JBQWdCLG1EQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcdXRpbHNcXGJhc2U1OC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIFRoZSBbQmFzZTU4IEVuY29kaW5nXShsaW5rLWJhc2U1OCkgc2NoZW1lIGFsbG93cyBhICoqbnVtZXJpYyoqIHZhbHVlXHJcbiAqICB0byBiZSBlbmNvZGVkIGFzIGEgY29tcGFjdCBzdHJpbmcgdXNpbmcgYSByYWRpeCBvZiA1OCB1c2luZyBvbmx5XHJcbiAqICBhbHBoYS1udW1lcmljIGNoYXJhY3RlcnMuIENvbmZ1c2luZ2x5IHNpbWlsYXIgY2hhcmFjdGVycyBhcmUgb21pdHRlZFxyXG4gKiAgKGkuZS4gYGBcImwwT1wiYGApLlxyXG4gKlxyXG4gKiAgTm90ZSB0aGF0IEJhc2U1OCBlbmNvZGVzIGEgKipudW1lcmljKiogdmFsdWUsIG5vdCBhcmJpdHJhcnkgYnl0ZXMsXHJcbiAqICBzaW5jZSBhbnkgemVyby1ieXRlcyBvbiB0aGUgbGVmdCB3b3VsZCBnZXQgcmVtb3ZlZC4gVG8gbWl0aWdhdGUgdGhpc1xyXG4gKiAgaXNzdWUgbW9zdCBzY2hlbWVzIHRoYXQgdXNlIEJhc2U1OCBjaG9vc2Ugc3BlY2lmaWMgaGlnaC1vcmRlciB2YWx1ZXNcclxuICogIHRvIGVuc3VyZSBub24temVybyBwcmVmaXhlcy5cclxuICpcclxuICogIEBfc3Vic2VjdGlvbjogYXBpL3V0aWxzOkJhc2U1OCBFbmNvZGluZyBbYWJvdXQtYmFzZTU4XVxyXG4gKi9cclxuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XHJcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XHJcbmltcG9ydCB7IHRvQmlnSW50IH0gZnJvbSBcIi4vbWF0aHMuanNcIjtcclxuY29uc3QgQWxwaGFiZXQgPSBcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIjtcclxubGV0IExvb2t1cCA9IG51bGw7XHJcbmZ1bmN0aW9uIGdldEFscGhhKGxldHRlcikge1xyXG4gICAgaWYgKExvb2t1cCA9PSBudWxsKSB7XHJcbiAgICAgICAgTG9va3VwID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBBbHBoYWJldC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBMb29rdXBbQWxwaGFiZXRbaV1dID0gQmlnSW50KGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHJlc3VsdCA9IExvb2t1cFtsZXR0ZXJdO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0ICE9IG51bGwsIGBpbnZhbGlkIGJhc2U1OCB2YWx1ZWAsIFwibGV0dGVyXCIsIGxldHRlcik7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XHJcbmNvbnN0IEJOXzU4ID0gQmlnSW50KDU4KTtcclxuLyoqXHJcbiAqICBFbmNvZGUgJSV2YWx1ZSUlIGFzIGEgQmFzZTU4LWVuY29kZWQgc3RyaW5nLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJhc2U1OChfdmFsdWUpIHtcclxuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoX3ZhbHVlKTtcclxuICAgIGxldCB2YWx1ZSA9IHRvQmlnSW50KGJ5dGVzKTtcclxuICAgIGxldCByZXN1bHQgPSBcIlwiO1xyXG4gICAgd2hpbGUgKHZhbHVlKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gQWxwaGFiZXRbTnVtYmVyKHZhbHVlICUgQk5fNTgpXSArIHJlc3VsdDtcclxuICAgICAgICB2YWx1ZSAvPSBCTl81ODtcclxuICAgIH1cclxuICAgIC8vIEFjY291bnQgZm9yIGxlYWRpbmcgcGFkZGluZyB6ZXJvc1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChieXRlc1tpXSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0ID0gQWxwaGFiZXRbMF0gKyByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiAgRGVjb2RlIHRoZSBCYXNlNTgtZW5jb2RlZCAlJXZhbHVlJSUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQmFzZTU4KHZhbHVlKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gQk5fMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICByZXN1bHQgKj0gQk5fNTg7XHJcbiAgICAgICAgcmVzdWx0ICs9IGdldEFscGhhKHZhbHVlW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTU4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/base58.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/base64-browser.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/base64-browser.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBase64: () => (/* binding */ decodeBase64),\n/* harmony export */   encodeBase64: () => (/* binding */ encodeBase64)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n// utils/base64-browser\r\n\r\nfunction decodeBase64(textData) {\r\n    textData = atob(textData);\r\n    const data = new Uint8Array(textData.length);\r\n    for (let i = 0; i < textData.length; i++) {\r\n        data[i] = textData.charCodeAt(i);\r\n    }\r\n    return (0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data);\r\n}\r\nfunction encodeBase64(_data) {\r\n    const data = (0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(_data);\r\n    let textData = \"\";\r\n    for (let i = 0; i < data.length; i++) {\r\n        textData += String.fromCharCode(data[i]);\r\n    }\r\n    return btoa(textData);\r\n}\r\n//# sourceMappingURL=base64-browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9iYXNlNjQtYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNxQztBQUM5QjtBQUNQO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQSxXQUFXLGtEQUFRO0FBQ25CO0FBQ087QUFDUCxpQkFBaUIsa0RBQVE7QUFDekI7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcdXRpbHNcXGJhc2U2NC1icm93c2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHV0aWxzL2Jhc2U2NC1icm93c2VyXHJcbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xyXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQmFzZTY0KHRleHREYXRhKSB7XHJcbiAgICB0ZXh0RGF0YSA9IGF0b2IodGV4dERhdGEpO1xyXG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRleHREYXRhLmxlbmd0aCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHREYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZGF0YVtpXSA9IHRleHREYXRhLmNoYXJDb2RlQXQoaSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0Qnl0ZXMoZGF0YSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJhc2U2NChfZGF0YSkge1xyXG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhKTtcclxuICAgIGxldCB0ZXh0RGF0YSA9IFwiXCI7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0ZXh0RGF0YSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJ0b2EodGV4dERhdGEpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U2NC1icm93c2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/base64-browser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/data.js":
/*!***************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/data.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   dataLength: () => (/* binding */ dataLength),\n/* harmony export */   dataSlice: () => (/* binding */ dataSlice),\n/* harmony export */   getBytes: () => (/* binding */ getBytes),\n/* harmony export */   getBytesCopy: () => (/* binding */ getBytesCopy),\n/* harmony export */   hexlify: () => (/* binding */ hexlify),\n/* harmony export */   isBytesLike: () => (/* binding */ isBytesLike),\n/* harmony export */   isHexString: () => (/* binding */ isHexString),\n/* harmony export */   stripZerosLeft: () => (/* binding */ stripZerosLeft),\n/* harmony export */   zeroPadBytes: () => (/* binding */ zeroPadBytes),\n/* harmony export */   zeroPadValue: () => (/* binding */ zeroPadValue)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\r\n *  Some data helpers.\r\n *\r\n *\r\n *  @_subsection api/utils:Data Helpers  [about-data]\r\n */\r\n\r\nfunction _getBytes(value, name, copy) {\r\n    if (value instanceof Uint8Array) {\r\n        if (copy) {\r\n            return new Uint8Array(value);\r\n        }\r\n        return value;\r\n    }\r\n    if (typeof (value) === \"string\" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {\r\n        const result = new Uint8Array((value.length - 2) / 2);\r\n        let offset = 2;\r\n        for (let i = 0; i < result.length; i++) {\r\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\r\n            offset += 2;\r\n        }\r\n        return result;\r\n    }\r\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BytesLike value\", name || \"value\", value);\r\n}\r\n/**\r\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\r\n *  the original %%value%% is returned; if a copy is required use\r\n *  [[getBytesCopy]].\r\n *\r\n *  @see: getBytesCopy\r\n */\r\nfunction getBytes(value, name) {\r\n    return _getBytes(value, name, false);\r\n}\r\n/**\r\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\r\n *  to prevent any modifications of the returned value from being\r\n *  reflected elsewhere.\r\n *\r\n *  @see: getBytes\r\n */\r\nfunction getBytesCopy(value, name) {\r\n    return _getBytes(value, name, true);\r\n}\r\n/**\r\n *  Returns true if %%value%% is a valid [[HexString]].\r\n *\r\n *  If %%length%% is ``true`` or a //number//, it also checks that\r\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\r\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\r\n */\r\nfunction isHexString(value, length) {\r\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\r\n        return false;\r\n    }\r\n    if (typeof (length) === \"number\" && value.length !== 2 + 2 * length) {\r\n        return false;\r\n    }\r\n    if (length === true && (value.length % 2) !== 0) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n *  Returns true if %%value%% is a valid representation of arbitrary\r\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\r\n */\r\nfunction isBytesLike(value) {\r\n    return (isHexString(value, true) || (value instanceof Uint8Array));\r\n}\r\nconst HexCharacters = \"0123456789abcdef\";\r\n/**\r\n *  Returns a [[DataHexString]] representation of %%data%%.\r\n */\r\nfunction hexlify(data) {\r\n    const bytes = getBytes(data);\r\n    let result = \"0x\";\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        const v = bytes[i];\r\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\r\n    }\r\n    return result;\r\n}\r\n/**\r\n *  Returns a [[DataHexString]] by concatenating all values\r\n *  within %%data%%.\r\n */\r\nfunction concat(datas) {\r\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\r\n}\r\n/**\r\n *  Returns the length of %%data%%, in bytes.\r\n */\r\nfunction dataLength(data) {\r\n    if (isHexString(data, true)) {\r\n        return (data.length - 2) / 2;\r\n    }\r\n    return getBytes(data).length;\r\n}\r\n/**\r\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\r\n *  offset to the %%end%% offset.\r\n *\r\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\r\n */\r\nfunction dataSlice(data, start, end) {\r\n    const bytes = getBytes(data);\r\n    if (end != null && end > bytes.length) {\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\r\n            buffer: bytes, length: bytes.length, offset: end\r\n        });\r\n    }\r\n    return hexlify(bytes.slice((start == null) ? 0 : start, (end == null) ? bytes.length : end));\r\n}\r\n/**\r\n *  Return the [[DataHexString]] result by stripping all **leading**\r\n ** zero bytes from %%data%%.\r\n */\r\nfunction stripZerosLeft(data) {\r\n    let bytes = hexlify(data).substring(2);\r\n    while (bytes.startsWith(\"00\")) {\r\n        bytes = bytes.substring(2);\r\n    }\r\n    return \"0x\" + bytes;\r\n}\r\nfunction zeroPad(data, length, left) {\r\n    const bytes = getBytes(data);\r\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\r\n        buffer: new Uint8Array(bytes),\r\n        length: length,\r\n        offset: length + 1\r\n    });\r\n    const result = new Uint8Array(length);\r\n    result.fill(0);\r\n    if (left) {\r\n        result.set(bytes, length - bytes.length);\r\n    }\r\n    else {\r\n        result.set(bytes, 0);\r\n    }\r\n    return hexlify(result);\r\n}\r\n/**\r\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\r\n *  to %%length%% bytes.\r\n *\r\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\r\n *  thrown.\r\n *\r\n *  This pads data the same as **values** are in Solidity\r\n *  (e.g. ``uint128``).\r\n */\r\nfunction zeroPadValue(data, length) {\r\n    return zeroPad(data, length, true);\r\n}\r\n/**\r\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\r\n *  to %%length%% bytes.\r\n *\r\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\r\n *  thrown.\r\n *\r\n *  This pads data the same as **bytes** are in Solidity\r\n *  (e.g. ``bytes16``).\r\n */\r\nfunction zeroPadBytes(data, length) {\r\n    return zeroPad(data, length, false);\r\n}\r\n//# sourceMappingURL=data.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9kYXRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMERBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcdXRpbHNcXGRhdGEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqICBTb21lIGRhdGEgaGVscGVycy5cclxuICpcclxuICpcclxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6RGF0YSBIZWxwZXJzICBbYWJvdXQtZGF0YV1cclxuICovXHJcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcclxuZnVuY3Rpb24gX2dldEJ5dGVzKHZhbHVlLCBuYW1lLCBjb3B5KSB7XHJcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XHJcbiAgICAgICAgaWYgKGNvcHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLm1hdGNoKC9eMHgoPzpbMC05YS1mXVswLTlhLWZdKSokL2kpKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoKHZhbHVlLmxlbmd0aCAtIDIpIC8gMik7XHJcbiAgICAgICAgbGV0IG9mZnNldCA9IDI7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0W2ldID0gcGFyc2VJbnQodmFsdWUuc3Vic3RyaW5nKG9mZnNldCwgb2Zmc2V0ICsgMiksIDE2KTtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIEJ5dGVzTGlrZSB2YWx1ZVwiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xyXG59XHJcbi8qKlxyXG4gKiAgR2V0IGEgdHlwZWQgVWludDhBcnJheSBmb3IgJSV2YWx1ZSUlLiBJZiBhbHJlYWR5IGEgVWludDhBcnJheVxyXG4gKiAgdGhlIG9yaWdpbmFsICUldmFsdWUlJSBpcyByZXR1cm5lZDsgaWYgYSBjb3B5IGlzIHJlcXVpcmVkIHVzZVxyXG4gKiAgW1tnZXRCeXRlc0NvcHldXS5cclxuICpcclxuICogIEBzZWU6IGdldEJ5dGVzQ29weVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEJ5dGVzKHZhbHVlLCBuYW1lKSB7XHJcbiAgICByZXR1cm4gX2dldEJ5dGVzKHZhbHVlLCBuYW1lLCBmYWxzZSk7XHJcbn1cclxuLyoqXHJcbiAqICBHZXQgYSB0eXBlZCBVaW50OEFycmF5IGZvciAlJXZhbHVlJSUsIGNyZWF0aW5nIGEgY29weSBpZiBuZWNlc3NhcnlcclxuICogIHRvIHByZXZlbnQgYW55IG1vZGlmaWNhdGlvbnMgb2YgdGhlIHJldHVybmVkIHZhbHVlIGZyb20gYmVpbmdcclxuICogIHJlZmxlY3RlZCBlbHNld2hlcmUuXHJcbiAqXHJcbiAqICBAc2VlOiBnZXRCeXRlc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEJ5dGVzQ29weSh2YWx1ZSwgbmFtZSkge1xyXG4gICAgcmV0dXJuIF9nZXRCeXRlcyh2YWx1ZSwgbmFtZSwgdHJ1ZSk7XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgW1tIZXhTdHJpbmddXS5cclxuICpcclxuICogIElmICUlbGVuZ3RoJSUgaXMgYGB0cnVlYGAgb3IgYSAvL251bWJlci8vLCBpdCBhbHNvIGNoZWNrcyB0aGF0XHJcbiAqICAlJXZhbHVlJSUgaXMgYSB2YWxpZCBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWxlbmd0aCUlIChpZiBhIC8vbnVtYmVyLy8pXHJcbiAqICBieXRlcyBvZiBkYXRhIChlLmcuIGBgMHgxMjM0YGAgaXMgMiBieXRlcykuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xyXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiAobGVuZ3RoKSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGxlbmd0aCA9PT0gdHJ1ZSAmJiAodmFsdWUubGVuZ3RoICUgMikgIT09IDApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSB2YWxpZCByZXByZXNlbnRhdGlvbiBvZiBhcmJpdHJhcnlcclxuICogIGRhdGEgKGkuZS4gYSB2YWxpZCBbW0RhdGFIZXhTdHJpbmddXSBvciBhIFVpbnQ4QXJyYXkpLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXNMaWtlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gKGlzSGV4U3RyaW5nKHZhbHVlLCB0cnVlKSB8fCAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSk7XHJcbn1cclxuY29uc3QgSGV4Q2hhcmFjdGVycyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xyXG4vKipcclxuICogIFJldHVybnMgYSBbW0RhdGFIZXhTdHJpbmddXSByZXByZXNlbnRhdGlvbiBvZiAlJWRhdGElJS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBoZXhsaWZ5KGRhdGEpIHtcclxuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XHJcbiAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHYgPSBieXRlc1tpXTtcclxuICAgICAgICByZXN1bHQgKz0gSGV4Q2hhcmFjdGVyc1sodiAmIDB4ZjApID4+IDRdICsgSGV4Q2hhcmFjdGVyc1t2ICYgMHgwZl07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIGJ5IGNvbmNhdGVuYXRpbmcgYWxsIHZhbHVlc1xyXG4gKiAgd2l0aGluICUlZGF0YSUlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdChkYXRhcykge1xyXG4gICAgcmV0dXJuIFwiMHhcIiArIGRhdGFzLm1hcCgoZCkgPT4gaGV4bGlmeShkKS5zdWJzdHJpbmcoMikpLmpvaW4oXCJcIik7XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm5zIHRoZSBsZW5ndGggb2YgJSVkYXRhJSUsIGluIGJ5dGVzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRhdGFMZW5ndGgoZGF0YSkge1xyXG4gICAgaWYgKGlzSGV4U3RyaW5nKGRhdGEsIHRydWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIChkYXRhLmxlbmd0aCAtIDIpIC8gMjtcclxuICAgIH1cclxuICAgIHJldHVybiBnZXRCeXRlcyhkYXRhKS5sZW5ndGg7XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm5zIGEgW1tEYXRhSGV4U3RyaW5nXV0gYnkgc2xpY2luZyAlJWRhdGElJSBmcm9tIHRoZSAlJXN0YXJ0JSVcclxuICogIG9mZnNldCB0byB0aGUgJSVlbmQlJSBvZmZzZXQuXHJcbiAqXHJcbiAqICBCeSBkZWZhdWx0ICUlc3RhcnQlJSBpcyAwIGFuZCAlJWVuZCUlIGlzIHRoZSBsZW5ndGggb2YgJSVkYXRhJSUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGF0YVNsaWNlKGRhdGEsIHN0YXJ0LCBlbmQpIHtcclxuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XHJcbiAgICBpZiAoZW5kICE9IG51bGwgJiYgZW5kID4gYnl0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNhbm5vdCBzbGljZSBiZXlvbmQgZGF0YSBib3VuZHNcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcjogYnl0ZXMsIGxlbmd0aDogYnl0ZXMubGVuZ3RoLCBvZmZzZXQ6IGVuZFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMuc2xpY2UoKHN0YXJ0ID09IG51bGwpID8gMCA6IHN0YXJ0LCAoZW5kID09IG51bGwpID8gYnl0ZXMubGVuZ3RoIDogZW5kKSk7XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm4gdGhlIFtbRGF0YUhleFN0cmluZ11dIHJlc3VsdCBieSBzdHJpcHBpbmcgYWxsICoqbGVhZGluZyoqXHJcbiAqKiB6ZXJvIGJ5dGVzIGZyb20gJSVkYXRhJSUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBaZXJvc0xlZnQoZGF0YSkge1xyXG4gICAgbGV0IGJ5dGVzID0gaGV4bGlmeShkYXRhKS5zdWJzdHJpbmcoMik7XHJcbiAgICB3aGlsZSAoYnl0ZXMuc3RhcnRzV2l0aChcIjAwXCIpKSB7XHJcbiAgICAgICAgYnl0ZXMgPSBieXRlcy5zdWJzdHJpbmcoMik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXCIweFwiICsgYnl0ZXM7XHJcbn1cclxuZnVuY3Rpb24gemVyb1BhZChkYXRhLCBsZW5ndGgsIGxlZnQpIHtcclxuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XHJcbiAgICBhc3NlcnQobGVuZ3RoID49IGJ5dGVzLmxlbmd0aCwgXCJwYWRkaW5nIGV4Y2VlZHMgZGF0YSBsZW5ndGhcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XHJcbiAgICAgICAgYnVmZmVyOiBuZXcgVWludDhBcnJheShieXRlcyksXHJcbiAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXHJcbiAgICAgICAgb2Zmc2V0OiBsZW5ndGggKyAxXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XHJcbiAgICByZXN1bHQuZmlsbCgwKTtcclxuICAgIGlmIChsZWZ0KSB7XHJcbiAgICAgICAgcmVzdWx0LnNldChieXRlcywgbGVuZ3RoIC0gYnl0ZXMubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdC5zZXQoYnl0ZXMsIDApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcclxufVxyXG4vKipcclxuICogIFJldHVybiB0aGUgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVkYXRhJSUgcGFkZGVkIG9uIHRoZSAqKmxlZnQqKlxyXG4gKiAgdG8gJSVsZW5ndGglJSBieXRlcy5cclxuICpcclxuICogIElmICUlZGF0YSUlIGFscmVhZHkgZXhjZWVkcyAlJWxlbmd0aCUlLCBhIFtbQnVmZmVyT3ZlcnJ1bkVycm9yXV0gaXNcclxuICogIHRocm93bi5cclxuICpcclxuICogIFRoaXMgcGFkcyBkYXRhIHRoZSBzYW1lIGFzICoqdmFsdWVzKiogYXJlIGluIFNvbGlkaXR5XHJcbiAqICAoZS5nLiBgYHVpbnQxMjhgYCkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gemVyb1BhZFZhbHVlKGRhdGEsIGxlbmd0aCkge1xyXG4gICAgcmV0dXJuIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCB0cnVlKTtcclxufVxyXG4vKipcclxuICogIFJldHVybiB0aGUgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVkYXRhJSUgcGFkZGVkIG9uIHRoZSAqKnJpZ2h0KipcclxuICogIHRvICUlbGVuZ3RoJSUgYnl0ZXMuXHJcbiAqXHJcbiAqICBJZiAlJWRhdGElJSBhbHJlYWR5IGV4Y2VlZHMgJSVsZW5ndGglJSwgYSBbW0J1ZmZlck92ZXJydW5FcnJvcl1dIGlzXHJcbiAqICB0aHJvd24uXHJcbiAqXHJcbiAqICBUaGlzIHBhZHMgZGF0YSB0aGUgc2FtZSBhcyAqKmJ5dGVzKiogYXJlIGluIFNvbGlkaXR5XHJcbiAqICAoZS5nLiBgYGJ5dGVzMTZgYCkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gemVyb1BhZEJ5dGVzKGRhdGEsIGxlbmd0aCkge1xyXG4gICAgcmV0dXJuIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCBmYWxzZSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/data.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/errors.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertArgument: () => (/* binding */ assertArgument),\n/* harmony export */   assertArgumentCount: () => (/* binding */ assertArgumentCount),\n/* harmony export */   assertNormalize: () => (/* binding */ assertNormalize),\n/* harmony export */   assertPrivate: () => (/* binding */ assertPrivate),\n/* harmony export */   isCallException: () => (/* binding */ isCallException),\n/* harmony export */   isError: () => (/* binding */ isError),\n/* harmony export */   makeError: () => (/* binding */ makeError)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/_version.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./properties.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\r\n *  All errors in ethers include properties to ensure they are both\r\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\r\n *\r\n *  The [[isError]] function can be used to check the error ``code`` and\r\n *  provide a type guard for the properties present on that error interface.\r\n *\r\n *  @_section: api/utils/errors:Errors  [about-errors]\r\n */\r\n\r\n\r\nfunction stringify(value, seen) {\r\n    if (value == null) {\r\n        return \"null\";\r\n    }\r\n    if (seen == null) {\r\n        seen = new Set();\r\n    }\r\n    if (typeof (value) === \"object\") {\r\n        if (seen.has(value)) {\r\n            return \"[Circular]\";\r\n        }\r\n        seen.add(value);\r\n    }\r\n    if (Array.isArray(value)) {\r\n        return \"[ \" + (value.map((v) => stringify(v, seen))).join(\", \") + \" ]\";\r\n    }\r\n    if (value instanceof Uint8Array) {\r\n        const HEX = \"0123456789abcdef\";\r\n        let result = \"0x\";\r\n        for (let i = 0; i < value.length; i++) {\r\n            result += HEX[value[i] >> 4];\r\n            result += HEX[value[i] & 0xf];\r\n        }\r\n        return result;\r\n    }\r\n    if (typeof (value) === \"object\" && typeof (value.toJSON) === \"function\") {\r\n        return stringify(value.toJSON(), seen);\r\n    }\r\n    switch (typeof (value)) {\r\n        case \"boolean\":\r\n        case \"number\":\r\n        case \"symbol\":\r\n            return value.toString();\r\n        case \"bigint\":\r\n            return BigInt(value).toString();\r\n        case \"string\":\r\n            return JSON.stringify(value);\r\n        case \"object\": {\r\n            const keys = Object.keys(value);\r\n            keys.sort();\r\n            return \"{ \" + keys.map((k) => `${stringify(k, seen)}: ${stringify(value[k], seen)}`).join(\", \") + \" }\";\r\n        }\r\n    }\r\n    return `[ COULD NOT SERIALIZE ]`;\r\n}\r\n/**\r\n *  Returns true if the %%error%% matches an error thrown by ethers\r\n *  that matches the error %%code%%.\r\n *\r\n *  In TypeScript environments, this can be used to check that %%error%%\r\n *  matches an EthersError type, which means the expected properties will\r\n *  be set.\r\n *\r\n *  @See [ErrorCodes](api:ErrorCode)\r\n *  @example\r\n *    try {\r\n *      // code....\r\n *    } catch (e) {\r\n *      if (isError(e, \"CALL_EXCEPTION\")) {\r\n *          // The Type Guard has validated this object\r\n *          console.log(e.data);\r\n *      }\r\n *    }\r\n */\r\nfunction isError(error, code) {\r\n    return (error && error.code === code);\r\n}\r\n/**\r\n *  Returns true if %%error%% is a [[CallExceptionError].\r\n */\r\nfunction isCallException(error) {\r\n    return isError(error, \"CALL_EXCEPTION\");\r\n}\r\n/**\r\n *  Returns a new Error configured to the format ethers emits errors, with\r\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties\r\n *  for the corresponding EthersError.\r\n *\r\n *  Each error in ethers includes the version of ethers, a\r\n *  machine-readable [[ErrorCode]], and depending on %%code%%, additional\r\n *  required properties. The error message will also include the %%message%%,\r\n *  ethers version, %%code%% and all additional properties, serialized.\r\n */\r\nfunction makeError(message, code, info) {\r\n    let shortMessage = message;\r\n    {\r\n        const details = [];\r\n        if (info) {\r\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\r\n                throw new Error(`value will overwrite populated values: ${stringify(info)}`);\r\n            }\r\n            for (const key in info) {\r\n                if (key === \"shortMessage\") {\r\n                    continue;\r\n                }\r\n                const value = (info[key]);\r\n                //                try {\r\n                details.push(key + \"=\" + stringify(value));\r\n                //                } catch (error: any) {\r\n                //                console.log(\"MMM\", error.message);\r\n                //                    details.push(key + \"=[could not serialize object]\");\r\n                //                }\r\n            }\r\n        }\r\n        details.push(`code=${code}`);\r\n        details.push(`version=${_version_js__WEBPACK_IMPORTED_MODULE_0__.version}`);\r\n        if (details.length) {\r\n            message += \" (\" + details.join(\", \") + \")\";\r\n        }\r\n    }\r\n    let error;\r\n    switch (code) {\r\n        case \"INVALID_ARGUMENT\":\r\n            error = new TypeError(message);\r\n            break;\r\n        case \"NUMERIC_FAULT\":\r\n        case \"BUFFER_OVERRUN\":\r\n            error = new RangeError(message);\r\n            break;\r\n        default:\r\n            error = new Error(message);\r\n    }\r\n    (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, { code });\r\n    if (info) {\r\n        Object.assign(error, info);\r\n    }\r\n    if (error.shortMessage == null) {\r\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, { shortMessage });\r\n    }\r\n    return error;\r\n}\r\n/**\r\n *  Throws an EthersError with %%message%%, %%code%% and additional error\r\n *  %%info%% when %%check%% is falsish..\r\n *\r\n *  @see [[api:makeError]]\r\n */\r\nfunction assert(check, message, code, info) {\r\n    if (!check) {\r\n        throw makeError(message, code, info);\r\n    }\r\n}\r\n/**\r\n *  A simple helper to simply ensuring provided arguments match expected\r\n *  constraints, throwing if not.\r\n *\r\n *  In TypeScript environments, the %%check%% has been asserted true, so\r\n *  any further code does not need additional compile-time checks.\r\n */\r\nfunction assertArgument(check, message, name, value) {\r\n    assert(check, message, \"INVALID_ARGUMENT\", { argument: name, value: value });\r\n}\r\nfunction assertArgumentCount(count, expectedCount, message) {\r\n    if (message == null) {\r\n        message = \"\";\r\n    }\r\n    if (message) {\r\n        message = \": \" + message;\r\n    }\r\n    assert(count >= expectedCount, \"missing argument\" + message, \"MISSING_ARGUMENT\", {\r\n        count: count,\r\n        expectedCount: expectedCount\r\n    });\r\n    assert(count <= expectedCount, \"too many arguments\" + message, \"UNEXPECTED_ARGUMENT\", {\r\n        count: count,\r\n        expectedCount: expectedCount\r\n    });\r\n}\r\nconst _normalizeForms = [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].reduce((accum, form) => {\r\n    try {\r\n        // General test for normalize\r\n        /* c8 ignore start */\r\n        if (\"test\".normalize(form) !== \"test\") {\r\n            throw new Error(\"bad\");\r\n        }\r\n        ;\r\n        /* c8 ignore stop */\r\n        if (form === \"NFD\") {\r\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\r\n            const expected = String.fromCharCode(0x65, 0x0301);\r\n            /* c8 ignore start */\r\n            if (check !== expected) {\r\n                throw new Error(\"broken\");\r\n            }\r\n            /* c8 ignore stop */\r\n        }\r\n        accum.push(form);\r\n    }\r\n    catch (error) { }\r\n    return accum;\r\n}, []);\r\n/**\r\n *  Throws if the normalization %%form%% is not supported.\r\n */\r\nfunction assertNormalize(form) {\r\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\r\n        operation: \"String.prototype.normalize\", info: { form }\r\n    });\r\n}\r\n/**\r\n *  Many classes use file-scoped values to guard the constructor,\r\n *  making it effectively private. This facilitates that pattern\r\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\r\n *  throwing if not, indicating the %%className%% if provided.\r\n */\r\nfunction assertPrivate(givenGuard, guard, className) {\r\n    if (className == null) {\r\n        className = \"\";\r\n    }\r\n    if (givenGuard !== guard) {\r\n        let method = className, operation = \"new\";\r\n        if (className) {\r\n            method += \".\";\r\n            operation += \" \" + className;\r\n        }\r\n        assert(false, `private constructor; use ${method}from* methods`, \"UNSUPPORTED_OPERATION\", {\r\n            operation\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9lcnJvcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN5QztBQUNVO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QixtQkFBbUIsSUFBSSwwQkFBMEIsbUJBQW1CO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGdCQUFnQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsS0FBSztBQUNsQyxnQ0FBZ0MsZ0RBQU8sQ0FBQztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQWdCLFVBQVUsTUFBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0VBQWdCLFVBQVUsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlEQUFpRCw4QkFBOEI7QUFDL0U7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EseURBQXlEO0FBQ3pELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE1BQU0sT0FBTztBQUN6RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcdXRpbHNcXGVycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIEFsbCBlcnJvcnMgaW4gZXRoZXJzIGluY2x1ZGUgcHJvcGVydGllcyB0byBlbnN1cmUgdGhleSBhcmUgYm90aFxyXG4gKiAgaHVtYW4tcmVhZGFibGUgKGkuZS4gYGAubWVzc2FnZWBgKSBhbmQgbWFjaGluZS1yZWFkYWJsZSAoaS5lLiBgYC5jb2RlYGApLlxyXG4gKlxyXG4gKiAgVGhlIFtbaXNFcnJvcl1dIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGNoZWNrIHRoZSBlcnJvciBgYGNvZGVgYCBhbmRcclxuICogIHByb3ZpZGUgYSB0eXBlIGd1YXJkIGZvciB0aGUgcHJvcGVydGllcyBwcmVzZW50IG9uIHRoYXQgZXJyb3IgaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiAgQF9zZWN0aW9uOiBhcGkvdXRpbHMvZXJyb3JzOkVycm9ycyAgW2Fib3V0LWVycm9yc11cclxuICovXHJcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3ZlcnNpb24uanNcIjtcclxuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuL3Byb3BlcnRpZXMuanNcIjtcclxuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlLCBzZWVuKSB7XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcclxuICAgIH1cclxuICAgIGlmIChzZWVuID09IG51bGwpIHtcclxuICAgICAgICBzZWVuID0gbmV3IFNldCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgaWYgKHNlZW4uaGFzKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXJdXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlZW4uYWRkKHZhbHVlKTtcclxuICAgIH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBcIlsgXCIgKyAodmFsdWUubWFwKCh2KSA9PiBzdHJpbmdpZnkodiwgc2VlbikpKS5qb2luKFwiLCBcIikgKyBcIiBdXCI7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XHJcbiAgICAgICAgY29uc3QgSEVYID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBIRVhbdmFsdWVbaV0gPj4gNF07XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBIRVhbdmFsdWVbaV0gJiAweGZdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiAodmFsdWUudG9KU09OKSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeSh2YWx1ZS50b0pTT04oKSwgc2Vlbik7XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XHJcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcclxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XHJcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XHJcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xyXG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xyXG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xyXG4gICAgICAgICAgICBrZXlzLnNvcnQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIFwieyBcIiArIGtleXMubWFwKChrKSA9PiBgJHtzdHJpbmdpZnkoaywgc2Vlbil9OiAke3N0cmluZ2lmeSh2YWx1ZVtrXSwgc2Vlbil9YCkuam9pbihcIiwgXCIpICsgXCIgfVwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBgWyBDT1VMRCBOT1QgU0VSSUFMSVpFIF1gO1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyB0cnVlIGlmIHRoZSAlJWVycm9yJSUgbWF0Y2hlcyBhbiBlcnJvciB0aHJvd24gYnkgZXRoZXJzXHJcbiAqICB0aGF0IG1hdGNoZXMgdGhlIGVycm9yICUlY29kZSUlLlxyXG4gKlxyXG4gKiAgSW4gVHlwZVNjcmlwdCBlbnZpcm9ubWVudHMsIHRoaXMgY2FuIGJlIHVzZWQgdG8gY2hlY2sgdGhhdCAlJWVycm9yJSVcclxuICogIG1hdGNoZXMgYW4gRXRoZXJzRXJyb3IgdHlwZSwgd2hpY2ggbWVhbnMgdGhlIGV4cGVjdGVkIHByb3BlcnRpZXMgd2lsbFxyXG4gKiAgYmUgc2V0LlxyXG4gKlxyXG4gKiAgQFNlZSBbRXJyb3JDb2Rlc10oYXBpOkVycm9yQ29kZSlcclxuICogIEBleGFtcGxlXHJcbiAqICAgIHRyeSB7XHJcbiAqICAgICAgLy8gY29kZS4uLi5cclxuICogICAgfSBjYXRjaCAoZSkge1xyXG4gKiAgICAgIGlmIChpc0Vycm9yKGUsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcclxuICogICAgICAgICAgLy8gVGhlIFR5cGUgR3VhcmQgaGFzIHZhbGlkYXRlZCB0aGlzIG9iamVjdFxyXG4gKiAgICAgICAgICBjb25zb2xlLmxvZyhlLmRhdGEpO1xyXG4gKiAgICAgIH1cclxuICogICAgfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRXJyb3IoZXJyb3IsIGNvZGUpIHtcclxuICAgIHJldHVybiAoZXJyb3IgJiYgZXJyb3IuY29kZSA9PT0gY29kZSk7XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm5zIHRydWUgaWYgJSVlcnJvciUlIGlzIGEgW1tDYWxsRXhjZXB0aW9uRXJyb3JdLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FsbEV4Y2VwdGlvbihlcnJvcikge1xyXG4gICAgcmV0dXJuIGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIik7XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm5zIGEgbmV3IEVycm9yIGNvbmZpZ3VyZWQgdG8gdGhlIGZvcm1hdCBldGhlcnMgZW1pdHMgZXJyb3JzLCB3aXRoXHJcbiAqICB0aGUgJSVtZXNzYWdlJSUsIFtbYXBpOkVycm9yQ29kZV1dICUlY29kZSUlIGFuZCBhZGRpdGlvbmFsIHByb3BlcnRpZXNcclxuICogIGZvciB0aGUgY29ycmVzcG9uZGluZyBFdGhlcnNFcnJvci5cclxuICpcclxuICogIEVhY2ggZXJyb3IgaW4gZXRoZXJzIGluY2x1ZGVzIHRoZSB2ZXJzaW9uIG9mIGV0aGVycywgYVxyXG4gKiAgbWFjaGluZS1yZWFkYWJsZSBbW0Vycm9yQ29kZV1dLCBhbmQgZGVwZW5kaW5nIG9uICUlY29kZSUlLCBhZGRpdGlvbmFsXHJcbiAqICByZXF1aXJlZCBwcm9wZXJ0aWVzLiBUaGUgZXJyb3IgbWVzc2FnZSB3aWxsIGFsc28gaW5jbHVkZSB0aGUgJSVtZXNzYWdlJSUsXHJcbiAqICBldGhlcnMgdmVyc2lvbiwgJSVjb2RlJSUgYW5kIGFsbCBhZGRpdGlvbmFsIHByb3BlcnRpZXMsIHNlcmlhbGl6ZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIGluZm8pIHtcclxuICAgIGxldCBzaG9ydE1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAge1xyXG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBbXTtcclxuICAgICAgICBpZiAoaW5mbykge1xyXG4gICAgICAgICAgICBpZiAoXCJtZXNzYWdlXCIgaW4gaW5mbyB8fCBcImNvZGVcIiBpbiBpbmZvIHx8IFwibmFtZVwiIGluIGluZm8pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsdWUgd2lsbCBvdmVyd3JpdGUgcG9wdWxhdGVkIHZhbHVlczogJHtzdHJpbmdpZnkoaW5mbyl9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5mbykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJzaG9ydE1lc3NhZ2VcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAoaW5mb1trZXldKTtcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBkZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBzdHJpbmdpZnkodmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTU1NXCIsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIGRldGFpbHMucHVzaChrZXkgKyBcIj1bY291bGQgbm90IHNlcmlhbGl6ZSBvYmplY3RdXCIpO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRldGFpbHMucHVzaChgY29kZT0ke2NvZGV9YCk7XHJcbiAgICAgICAgZGV0YWlscy5wdXNoKGB2ZXJzaW9uPSR7dmVyc2lvbn1gKTtcclxuICAgICAgICBpZiAoZGV0YWlscy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoXCIgKyBkZXRhaWxzLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBlcnJvcjtcclxuICAgIHN3aXRjaCAoY29kZSkge1xyXG4gICAgICAgIGNhc2UgXCJJTlZBTElEX0FSR1VNRU5UXCI6XHJcbiAgICAgICAgICAgIGVycm9yID0gbmV3IFR5cGVFcnJvcihtZXNzYWdlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIk5VTUVSSUNfRkFVTFRcIjpcclxuICAgICAgICBjYXNlIFwiQlVGRkVSX09WRVJSVU5cIjpcclxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgUmFuZ2VFcnJvcihtZXNzYWdlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKGVycm9yLCB7IGNvZGUgfSk7XHJcbiAgICBpZiAoaW5mbykge1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oZXJyb3IsIGluZm8pO1xyXG4gICAgfVxyXG4gICAgaWYgKGVycm9yLnNob3J0TWVzc2FnZSA9PSBudWxsKSB7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhlcnJvciwgeyBzaG9ydE1lc3NhZ2UgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXJyb3I7XHJcbn1cclxuLyoqXHJcbiAqICBUaHJvd3MgYW4gRXRoZXJzRXJyb3Igd2l0aCAlJW1lc3NhZ2UlJSwgJSVjb2RlJSUgYW5kIGFkZGl0aW9uYWwgZXJyb3JcclxuICogICUlaW5mbyUlIHdoZW4gJSVjaGVjayUlIGlzIGZhbHNpc2guLlxyXG4gKlxyXG4gKiAgQHNlZSBbW2FwaTptYWtlRXJyb3JdXVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChjaGVjaywgbWVzc2FnZSwgY29kZSwgaW5mbykge1xyXG4gICAgaWYgKCFjaGVjaykge1xyXG4gICAgICAgIHRocm93IG1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBpbmZvKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEEgc2ltcGxlIGhlbHBlciB0byBzaW1wbHkgZW5zdXJpbmcgcHJvdmlkZWQgYXJndW1lbnRzIG1hdGNoIGV4cGVjdGVkXHJcbiAqICBjb25zdHJhaW50cywgdGhyb3dpbmcgaWYgbm90LlxyXG4gKlxyXG4gKiAgSW4gVHlwZVNjcmlwdCBlbnZpcm9ubWVudHMsIHRoZSAlJWNoZWNrJSUgaGFzIGJlZW4gYXNzZXJ0ZWQgdHJ1ZSwgc29cclxuICogIGFueSBmdXJ0aGVyIGNvZGUgZG9lcyBub3QgbmVlZCBhZGRpdGlvbmFsIGNvbXBpbGUtdGltZSBjaGVja3MuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0QXJndW1lbnQoY2hlY2ssIG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XHJcbiAgICBhc3NlcnQoY2hlY2ssIG1lc3NhZ2UsIFwiSU5WQUxJRF9BUkdVTUVOVFwiLCB7IGFyZ3VtZW50OiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50Q291bnQoY291bnQsIGV4cGVjdGVkQ291bnQsIG1lc3NhZ2UpIHtcclxuICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcclxuICAgICAgICBtZXNzYWdlID0gXCJcIjtcclxuICAgIH1cclxuICAgIGlmIChtZXNzYWdlKSB7XHJcbiAgICAgICAgbWVzc2FnZSA9IFwiOiBcIiArIG1lc3NhZ2U7XHJcbiAgICB9XHJcbiAgICBhc3NlcnQoY291bnQgPj0gZXhwZWN0ZWRDb3VudCwgXCJtaXNzaW5nIGFyZ3VtZW50XCIgKyBtZXNzYWdlLCBcIk1JU1NJTkdfQVJHVU1FTlRcIiwge1xyXG4gICAgICAgIGNvdW50OiBjb3VudCxcclxuICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XHJcbiAgICB9KTtcclxuICAgIGFzc2VydChjb3VudCA8PSBleHBlY3RlZENvdW50LCBcInRvbyBtYW55IGFyZ3VtZW50c1wiICsgbWVzc2FnZSwgXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCIsIHtcclxuICAgICAgICBjb3VudDogY291bnQsXHJcbiAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxyXG4gICAgfSk7XHJcbn1cclxuY29uc3QgX25vcm1hbGl6ZUZvcm1zID0gW1wiTkZEXCIsIFwiTkZDXCIsIFwiTkZLRFwiLCBcIk5GS0NcIl0ucmVkdWNlKChhY2N1bSwgZm9ybSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBHZW5lcmFsIHRlc3QgZm9yIG5vcm1hbGl6ZVxyXG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xyXG4gICAgICAgIGlmIChcInRlc3RcIi5ub3JtYWxpemUoZm9ybSkgIT09IFwidGVzdFwiKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgO1xyXG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXHJcbiAgICAgICAgaWYgKGZvcm0gPT09IFwiTkZEXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hlY2sgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTkpLm5vcm1hbGl6ZShcIk5GRFwiKTtcclxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4NjUsIDB4MDMwMSk7XHJcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xyXG4gICAgICAgICAgICBpZiAoY2hlY2sgIT09IGV4cGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJicm9rZW5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cclxuICAgICAgICB9XHJcbiAgICAgICAgYWNjdW0ucHVzaChmb3JtKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICByZXR1cm4gYWNjdW07XHJcbn0sIFtdKTtcclxuLyoqXHJcbiAqICBUaHJvd3MgaWYgdGhlIG5vcm1hbGl6YXRpb24gJSVmb3JtJSUgaXMgbm90IHN1cHBvcnRlZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROb3JtYWxpemUoZm9ybSkge1xyXG4gICAgYXNzZXJ0KF9ub3JtYWxpemVGb3Jtcy5pbmRleE9mKGZvcm0pID49IDAsIFwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgb3BlcmF0aW9uOiBcIlN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIGluZm86IHsgZm9ybSB9XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogIE1hbnkgY2xhc3NlcyB1c2UgZmlsZS1zY29wZWQgdmFsdWVzIHRvIGd1YXJkIHRoZSBjb25zdHJ1Y3RvcixcclxuICogIG1ha2luZyBpdCBlZmZlY3RpdmVseSBwcml2YXRlLiBUaGlzIGZhY2lsaXRhdGVzIHRoYXQgcGF0dGVyblxyXG4gKiAgYnkgZW5zdXJpbmcgdGhlICUlZ2l2ZW5HYXVyZCUlIG1hdGNoZXMgdGhlIGZpbGUtc2NvcGVkICUlZ3VhcmQlJSxcclxuICogIHRocm93aW5nIGlmIG5vdCwgaW5kaWNhdGluZyB0aGUgJSVjbGFzc05hbWUlJSBpZiBwcm92aWRlZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRQcml2YXRlKGdpdmVuR3VhcmQsIGd1YXJkLCBjbGFzc05hbWUpIHtcclxuICAgIGlmIChjbGFzc05hbWUgPT0gbnVsbCkge1xyXG4gICAgICAgIGNsYXNzTmFtZSA9IFwiXCI7XHJcbiAgICB9XHJcbiAgICBpZiAoZ2l2ZW5HdWFyZCAhPT0gZ3VhcmQpIHtcclxuICAgICAgICBsZXQgbWV0aG9kID0gY2xhc3NOYW1lLCBvcGVyYXRpb24gPSBcIm5ld1wiO1xyXG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgbWV0aG9kICs9IFwiLlwiO1xyXG4gICAgICAgICAgICBvcGVyYXRpb24gKz0gXCIgXCIgKyBjbGFzc05hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydChmYWxzZSwgYHByaXZhdGUgY29uc3RydWN0b3I7IHVzZSAke21ldGhvZH1mcm9tKiBtZXRob2RzYCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICBvcGVyYXRpb25cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/errors.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/events.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/events.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventPayload: () => (/* binding */ EventPayload)\n/* harmony export */ });\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./properties.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\r\n *  Events allow for applications to use the observer pattern, which\r\n *  allows subscribing and publishing events, outside the normal\r\n *  execution paths.\r\n *\r\n *  @_section api/utils/events:Events  [about-events]\r\n */\r\n\r\n/**\r\n *  When an [[EventEmitterable]] triggers a [[Listener]], the\r\n *  callback always ahas one additional argument passed, which is\r\n *  an **EventPayload**.\r\n */\r\nclass EventPayload {\r\n    /**\r\n     *  The event filter.\r\n     */\r\n    filter;\r\n    /**\r\n     *  The **EventEmitterable**.\r\n     */\r\n    emitter;\r\n    #listener;\r\n    /**\r\n     *  Create a new **EventPayload** for %%emitter%% with\r\n     *  the %%listener%% and for %%filter%%.\r\n     */\r\n    constructor(emitter, listener, filter) {\r\n        this.#listener = listener;\r\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { emitter, filter });\r\n    }\r\n    /**\r\n     *  Unregister the triggered listener for future events.\r\n     */\r\n    async removeListener() {\r\n        if (this.#listener == null) {\r\n            return;\r\n        }\r\n        await this.emitter.off(this.filter, this.#listener);\r\n    }\r\n}\r\n//# sourceMappingURL=events.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9ldmVudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdFQUFnQixTQUFTLGlCQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcdXRpbHNcXGV2ZW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIEV2ZW50cyBhbGxvdyBmb3IgYXBwbGljYXRpb25zIHRvIHVzZSB0aGUgb2JzZXJ2ZXIgcGF0dGVybiwgd2hpY2hcclxuICogIGFsbG93cyBzdWJzY3JpYmluZyBhbmQgcHVibGlzaGluZyBldmVudHMsIG91dHNpZGUgdGhlIG5vcm1hbFxyXG4gKiAgZXhlY3V0aW9uIHBhdGhzLlxyXG4gKlxyXG4gKiAgQF9zZWN0aW9uIGFwaS91dGlscy9ldmVudHM6RXZlbnRzICBbYWJvdXQtZXZlbnRzXVxyXG4gKi9cclxuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuL3Byb3BlcnRpZXMuanNcIjtcclxuLyoqXHJcbiAqICBXaGVuIGFuIFtbRXZlbnRFbWl0dGVyYWJsZV1dIHRyaWdnZXJzIGEgW1tMaXN0ZW5lcl1dLCB0aGVcclxuICogIGNhbGxiYWNrIGFsd2F5cyBhaGFzIG9uZSBhZGRpdGlvbmFsIGFyZ3VtZW50IHBhc3NlZCwgd2hpY2ggaXNcclxuICogIGFuICoqRXZlbnRQYXlsb2FkKiouXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRXZlbnRQYXlsb2FkIHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBldmVudCBmaWx0ZXIuXHJcbiAgICAgKi9cclxuICAgIGZpbHRlcjtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSAqKkV2ZW50RW1pdHRlcmFibGUqKi5cclxuICAgICAqL1xyXG4gICAgZW1pdHRlcjtcclxuICAgICNsaXN0ZW5lcjtcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkV2ZW50UGF5bG9hZCoqIGZvciAlJWVtaXR0ZXIlJSB3aXRoXHJcbiAgICAgKiAgdGhlICUlbGlzdGVuZXIlJSBhbmQgZm9yICUlZmlsdGVyJSUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGVtaXR0ZXIsIGxpc3RlbmVyLCBmaWx0ZXIpIHtcclxuICAgICAgICB0aGlzLiNsaXN0ZW5lciA9IGxpc3RlbmVyO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBlbWl0dGVyLCBmaWx0ZXIgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBVbnJlZ2lzdGVyIHRoZSB0cmlnZ2VyZWQgbGlzdGVuZXIgZm9yIGZ1dHVyZSBldmVudHMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlbW92ZUxpc3RlbmVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLiNsaXN0ZW5lciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXdhaXQgdGhpcy5lbWl0dGVyLm9mZih0aGlzLmZpbHRlciwgdGhpcy4jbGlzdGVuZXIpO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/events.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/fetch.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/fetch.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchCancelSignal: () => (/* binding */ FetchCancelSignal),\n/* harmony export */   FetchRequest: () => (/* binding */ FetchRequest),\n/* harmony export */   FetchResponse: () => (/* binding */ FetchResponse)\n/* harmony export */ });\n/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base64.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/base64-browser.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./properties.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utf8_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utf8.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _geturl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geturl.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/geturl-browser.js\");\n/**\r\n *  Fetching content from the web is environment-specific, so Ethers\r\n *  provides an abstraction that each environment can implement to provide\r\n *  this service.\r\n *\r\n *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to\r\n *  create a request object, register event listeners and process data\r\n *  and populate the [[FetchResponse]].\r\n *\r\n *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting\r\n *  ``Promise`` is waited on to retrieve the payload.\r\n *\r\n *  The [[FetchRequest]] is responsible for handling many common situations,\r\n *  such as redirects, server throttling, authentication, etc.\r\n *\r\n *  It also handles common gateways, such as IPFS and data URIs.\r\n *\r\n *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst MAX_ATTEMPTS = 12;\r\nconst SLOT_INTERVAL = 250;\r\n// The global FetchGetUrlFunc implementation.\r\nlet defaultGetUrlFunc = (0,_geturl_js__WEBPACK_IMPORTED_MODULE_0__.createGetUrl)();\r\nconst reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\r\nconst reIpfs = new RegExp(\"^ipfs:/\\/(ipfs/)?(.*)$\", \"i\");\r\n// If locked, new Gateways cannot be added\r\nlet locked = false;\r\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs\r\nasync function dataGatewayFunc(url, signal) {\r\n    try {\r\n        const match = url.match(reData);\r\n        if (!match) {\r\n            throw new Error(\"invalid data\");\r\n        }\r\n        return new FetchResponse(200, \"OK\", {\r\n            \"content-type\": (match[1] || \"text/plain\"),\r\n        }, (match[2] ? (0,_base64_js__WEBPACK_IMPORTED_MODULE_1__.decodeBase64)(match[3]) : unpercent(match[3])));\r\n    }\r\n    catch (error) {\r\n        return new FetchResponse(599, \"BAD REQUEST (invalid data: URI)\", {}, null, new FetchRequest(url));\r\n    }\r\n}\r\n/**\r\n *  Returns a [[FetchGatewayFunc]] for fetching content from a standard\r\n *  IPFS gateway hosted at %%baseUrl%%.\r\n */\r\nfunction getIpfsGatewayFunc(baseUrl) {\r\n    async function gatewayIpfs(url, signal) {\r\n        try {\r\n            const match = url.match(reIpfs);\r\n            if (!match) {\r\n                throw new Error(\"invalid link\");\r\n            }\r\n            return new FetchRequest(`${baseUrl}${match[2]}`);\r\n        }\r\n        catch (error) {\r\n            return new FetchResponse(599, \"BAD REQUEST (invalid IPFS URI)\", {}, null, new FetchRequest(url));\r\n        }\r\n    }\r\n    return gatewayIpfs;\r\n}\r\nconst Gateways = {\r\n    \"data\": dataGatewayFunc,\r\n    \"ipfs\": getIpfsGatewayFunc(\"https:/\\/gateway.ipfs.io/ipfs/\")\r\n};\r\nconst fetchSignals = new WeakMap();\r\n/**\r\n *  @_ignore\r\n */\r\nclass FetchCancelSignal {\r\n    #listeners;\r\n    #cancelled;\r\n    constructor(request) {\r\n        this.#listeners = [];\r\n        this.#cancelled = false;\r\n        fetchSignals.set(request, () => {\r\n            if (this.#cancelled) {\r\n                return;\r\n            }\r\n            this.#cancelled = true;\r\n            for (const listener of this.#listeners) {\r\n                setTimeout(() => { listener(); }, 0);\r\n            }\r\n            this.#listeners = [];\r\n        });\r\n    }\r\n    addListener(listener) {\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.#cancelled, \"singal already cancelled\", \"UNSUPPORTED_OPERATION\", {\r\n            operation: \"fetchCancelSignal.addCancelListener\"\r\n        });\r\n        this.#listeners.push(listener);\r\n    }\r\n    get cancelled() { return this.#cancelled; }\r\n    checkSignal() {\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.cancelled, \"cancelled\", \"CANCELLED\", {});\r\n    }\r\n}\r\n// Check the signal, throwing if it is cancelled\r\nfunction checkSignal(signal) {\r\n    if (signal == null) {\r\n        throw new Error(\"missing signal; should not happen\");\r\n    }\r\n    signal.checkSignal();\r\n    return signal;\r\n}\r\n/**\r\n *  Represents a request for a resource using a URI.\r\n *\r\n *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\r\n *  and ``IPFS:``.\r\n *\r\n *  Additional schemes can be added globally using [[registerGateway]].\r\n *\r\n *  @example:\r\n *    req = new FetchRequest(\"https://www.ricmoo.com\")\r\n *    resp = await req.send()\r\n *    resp.body.length\r\n *    //_result:\r\n */\r\nclass FetchRequest {\r\n    #allowInsecure;\r\n    #gzip;\r\n    #headers;\r\n    #method;\r\n    #timeout;\r\n    #url;\r\n    #body;\r\n    #bodyType;\r\n    #creds;\r\n    // Hooks\r\n    #preflight;\r\n    #process;\r\n    #retry;\r\n    #signal;\r\n    #throttle;\r\n    #getUrlFunc;\r\n    /**\r\n     *  The fetch URL to request.\r\n     */\r\n    get url() { return this.#url; }\r\n    set url(url) {\r\n        this.#url = String(url);\r\n    }\r\n    /**\r\n     *  The fetch body, if any, to send as the request body. //(default: null)//\r\n     *\r\n     *  When setting a body, the intrinsic ``Content-Type`` is automatically\r\n     *  set and will be used if **not overridden** by setting a custom\r\n     *  header.\r\n     *\r\n     *  If %%body%% is null, the body is cleared (along with the\r\n     *  intrinsic ``Content-Type``).\r\n     *\r\n     *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to\r\n     *  ``text/plain``.\r\n     *\r\n     *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to\r\n     *  ``application/octet-stream``.\r\n     *\r\n     *  If %%body%% is any other object, the intrinsic ``Content-Type`` is\r\n     *  set to ``application/json``.\r\n     */\r\n    get body() {\r\n        if (this.#body == null) {\r\n            return null;\r\n        }\r\n        return new Uint8Array(this.#body);\r\n    }\r\n    set body(body) {\r\n        if (body == null) {\r\n            this.#body = undefined;\r\n            this.#bodyType = undefined;\r\n        }\r\n        else if (typeof (body) === \"string\") {\r\n            this.#body = (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(body);\r\n            this.#bodyType = \"text/plain\";\r\n        }\r\n        else if (body instanceof Uint8Array) {\r\n            this.#body = body;\r\n            this.#bodyType = \"application/octet-stream\";\r\n        }\r\n        else if (typeof (body) === \"object\") {\r\n            this.#body = (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(JSON.stringify(body));\r\n            this.#bodyType = \"application/json\";\r\n        }\r\n        else {\r\n            throw new Error(\"invalid body\");\r\n        }\r\n    }\r\n    /**\r\n     *  Returns true if the request has a body.\r\n     */\r\n    hasBody() {\r\n        return (this.#body != null);\r\n    }\r\n    /**\r\n     *  The HTTP method to use when requesting the URI. If no method\r\n     *  has been explicitly set, then ``GET`` is used if the body is\r\n     *  null and ``POST`` otherwise.\r\n     */\r\n    get method() {\r\n        if (this.#method) {\r\n            return this.#method;\r\n        }\r\n        if (this.hasBody()) {\r\n            return \"POST\";\r\n        }\r\n        return \"GET\";\r\n    }\r\n    set method(method) {\r\n        if (method == null) {\r\n            method = \"\";\r\n        }\r\n        this.#method = String(method).toUpperCase();\r\n    }\r\n    /**\r\n     *  The headers that will be used when requesting the URI. All\r\n     *  keys are lower-case.\r\n     *\r\n     *  This object is a copy, so any changes will **NOT** be reflected\r\n     *  in the ``FetchRequest``.\r\n     *\r\n     *  To set a header entry, use the ``setHeader`` method.\r\n     */\r\n    get headers() {\r\n        const headers = Object.assign({}, this.#headers);\r\n        if (this.#creds) {\r\n            headers[\"authorization\"] = `Basic ${(0,_base64_js__WEBPACK_IMPORTED_MODULE_1__.encodeBase64)((0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(this.#creds))}`;\r\n        }\r\n        ;\r\n        if (this.allowGzip) {\r\n            headers[\"accept-encoding\"] = \"gzip\";\r\n        }\r\n        if (headers[\"content-type\"] == null && this.#bodyType) {\r\n            headers[\"content-type\"] = this.#bodyType;\r\n        }\r\n        if (this.body) {\r\n            headers[\"content-length\"] = String(this.body.length);\r\n        }\r\n        return headers;\r\n    }\r\n    /**\r\n     *  Get the header for %%key%%, ignoring case.\r\n     */\r\n    getHeader(key) {\r\n        return this.headers[key.toLowerCase()];\r\n    }\r\n    /**\r\n     *  Set the header for %%key%% to %%value%%. All values are coerced\r\n     *  to a string.\r\n     */\r\n    setHeader(key, value) {\r\n        this.#headers[String(key).toLowerCase()] = String(value);\r\n    }\r\n    /**\r\n     *  Clear all headers, resetting all intrinsic headers.\r\n     */\r\n    clearHeaders() {\r\n        this.#headers = {};\r\n    }\r\n    [Symbol.iterator]() {\r\n        const headers = this.headers;\r\n        const keys = Object.keys(headers);\r\n        let index = 0;\r\n        return {\r\n            next: () => {\r\n                if (index < keys.length) {\r\n                    const key = keys[index++];\r\n                    return {\r\n                        value: [key, headers[key]], done: false\r\n                    };\r\n                }\r\n                return { value: undefined, done: true };\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     *  The value that will be sent for the ``Authorization`` header.\r\n     *\r\n     *  To set the credentials, use the ``setCredentials`` method.\r\n     */\r\n    get credentials() {\r\n        return this.#creds || null;\r\n    }\r\n    /**\r\n     *  Sets an ``Authorization`` for %%username%% with %%password%%.\r\n     */\r\n    setCredentials(username, password) {\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!username.match(/:/), \"invalid basic authentication username\", \"username\", \"[REDACTED]\");\r\n        this.#creds = `${username}:${password}`;\r\n    }\r\n    /**\r\n     *  Enable and request gzip-encoded responses. The response will\r\n     *  automatically be decompressed. //(default: true)//\r\n     */\r\n    get allowGzip() {\r\n        return this.#gzip;\r\n    }\r\n    set allowGzip(value) {\r\n        this.#gzip = !!value;\r\n    }\r\n    /**\r\n     *  Allow ``Authentication`` credentials to be sent over insecure\r\n     *  channels. //(default: false)//\r\n     */\r\n    get allowInsecureAuthentication() {\r\n        return !!this.#allowInsecure;\r\n    }\r\n    set allowInsecureAuthentication(value) {\r\n        this.#allowInsecure = !!value;\r\n    }\r\n    /**\r\n     *  The timeout (in milliseconds) to wait for a complete response.\r\n     *  //(default: 5 minutes)//\r\n     */\r\n    get timeout() { return this.#timeout; }\r\n    set timeout(timeout) {\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(timeout >= 0, \"timeout must be non-zero\", \"timeout\", timeout);\r\n        this.#timeout = timeout;\r\n    }\r\n    /**\r\n     *  This function is called prior to each request, for example\r\n     *  during a redirection or retry in case of server throttling.\r\n     *\r\n     *  This offers an opportunity to populate headers or update\r\n     *  content before sending a request.\r\n     */\r\n    get preflightFunc() {\r\n        return this.#preflight || null;\r\n    }\r\n    set preflightFunc(preflight) {\r\n        this.#preflight = preflight;\r\n    }\r\n    /**\r\n     *  This function is called after each response, offering an\r\n     *  opportunity to provide client-level throttling or updating\r\n     *  response data.\r\n     *\r\n     *  Any error thrown in this causes the ``send()`` to throw.\r\n     *\r\n     *  To schedule a retry attempt (assuming the maximum retry limit\r\n     *  has not been reached), use [[response.throwThrottleError]].\r\n     */\r\n    get processFunc() {\r\n        return this.#process || null;\r\n    }\r\n    set processFunc(process) {\r\n        this.#process = process;\r\n    }\r\n    /**\r\n     *  This function is called on each retry attempt.\r\n     */\r\n    get retryFunc() {\r\n        return this.#retry || null;\r\n    }\r\n    set retryFunc(retry) {\r\n        this.#retry = retry;\r\n    }\r\n    /**\r\n     *  This function is called to fetch content from HTTP and\r\n     *  HTTPS URLs and is platform specific (e.g. nodejs vs\r\n     *  browsers).\r\n     *\r\n     *  This is by default the currently registered global getUrl\r\n     *  function, which can be changed using [[registerGetUrl]].\r\n     *  If this has been set, setting is to ``null`` will cause\r\n     *  this FetchRequest (and any future clones) to revert back to\r\n     *  using the currently registered global getUrl function.\r\n     *\r\n     *  Setting this is generally not necessary, but may be useful\r\n     *  for developers that wish to intercept requests or to\r\n     *  configurege a proxy or other agent.\r\n     */\r\n    get getUrlFunc() {\r\n        return this.#getUrlFunc || defaultGetUrlFunc;\r\n    }\r\n    set getUrlFunc(value) {\r\n        this.#getUrlFunc = value;\r\n    }\r\n    /**\r\n     *  Create a new FetchRequest instance with default values.\r\n     *\r\n     *  Once created, each property may be set before issuing a\r\n     *  ``.send()`` to make the request.\r\n     */\r\n    constructor(url) {\r\n        this.#url = String(url);\r\n        this.#allowInsecure = false;\r\n        this.#gzip = true;\r\n        this.#headers = {};\r\n        this.#method = \"\";\r\n        this.#timeout = 300000;\r\n        this.#throttle = {\r\n            slotInterval: SLOT_INTERVAL,\r\n            maxAttempts: MAX_ATTEMPTS\r\n        };\r\n        this.#getUrlFunc = null;\r\n    }\r\n    toString() {\r\n        return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(this.#body) : \"null\"}>`;\r\n    }\r\n    /**\r\n     *  Update the throttle parameters used to determine maximum\r\n     *  attempts and exponential-backoff properties.\r\n     */\r\n    setThrottleParams(params) {\r\n        if (params.slotInterval != null) {\r\n            this.#throttle.slotInterval = params.slotInterval;\r\n        }\r\n        if (params.maxAttempts != null) {\r\n            this.#throttle.maxAttempts = params.maxAttempts;\r\n        }\r\n    }\r\n    async #send(attempt, expires, delay, _request, _response) {\r\n        if (attempt >= this.#throttle.maxAttempts) {\r\n            return _response.makeServerError(\"exceeded maximum retry limit\");\r\n        }\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(getTime() <= expires, \"timeout\", \"TIMEOUT\", {\r\n            operation: \"request.send\", reason: \"timeout\", request: _request\r\n        });\r\n        if (delay > 0) {\r\n            await wait(delay);\r\n        }\r\n        let req = this.clone();\r\n        const scheme = (req.url.split(\":\")[0] || \"\").toLowerCase();\r\n        // Process any Gateways\r\n        if (scheme in Gateways) {\r\n            const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));\r\n            if (result instanceof FetchResponse) {\r\n                let response = result;\r\n                if (this.processFunc) {\r\n                    checkSignal(_request.#signal);\r\n                    try {\r\n                        response = await this.processFunc(req, response);\r\n                    }\r\n                    catch (error) {\r\n                        // Something went wrong during processing; throw a 5xx server error\r\n                        if (error.throttle == null || typeof (error.stall) !== \"number\") {\r\n                            response.makeServerError(\"error in post-processing function\", error).assertOk();\r\n                        }\r\n                        // Ignore throttling\r\n                    }\r\n                }\r\n                return response;\r\n            }\r\n            req = result;\r\n        }\r\n        // We have a preflight function; update the request\r\n        if (this.preflightFunc) {\r\n            req = await this.preflightFunc(req);\r\n        }\r\n        const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));\r\n        let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);\r\n        if (response.statusCode === 301 || response.statusCode === 302) {\r\n            // Redirect\r\n            try {\r\n                const location = response.headers.location || \"\";\r\n                return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);\r\n            }\r\n            catch (error) { }\r\n            // Things won't get any better on another attempt; abort\r\n            return response;\r\n        }\r\n        else if (response.statusCode === 429) {\r\n            // Throttle\r\n            if (this.retryFunc == null || (await this.retryFunc(req, response, attempt))) {\r\n                const retryAfter = response.headers[\"retry-after\"];\r\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\r\n                if (typeof (retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\r\n                    delay = parseInt(retryAfter);\r\n                }\r\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\r\n            }\r\n        }\r\n        if (this.processFunc) {\r\n            checkSignal(_request.#signal);\r\n            try {\r\n                response = await this.processFunc(req, response);\r\n            }\r\n            catch (error) {\r\n                // Something went wrong during processing; throw a 5xx server error\r\n                if (error.throttle == null || typeof (error.stall) !== \"number\") {\r\n                    response.makeServerError(\"error in post-processing function\", error).assertOk();\r\n                }\r\n                // Throttle\r\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\r\n                ;\r\n                if (error.stall >= 0) {\r\n                    delay = error.stall;\r\n                }\r\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\r\n            }\r\n        }\r\n        return response;\r\n    }\r\n    /**\r\n     *  Resolves to the response by sending the request.\r\n     */\r\n    send() {\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.#signal == null, \"request already sent\", \"UNSUPPORTED_OPERATION\", { operation: \"fetchRequest.send\" });\r\n        this.#signal = new FetchCancelSignal(this);\r\n        return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, \"\", {}, null, this));\r\n    }\r\n    /**\r\n     *  Cancels the inflight response, causing a ``CANCELLED``\r\n     *  error to be rejected from the [[send]].\r\n     */\r\n    cancel() {\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.#signal != null, \"request has not been sent\", \"UNSUPPORTED_OPERATION\", { operation: \"fetchRequest.cancel\" });\r\n        const signal = fetchSignals.get(this);\r\n        if (!signal) {\r\n            throw new Error(\"missing signal; should not happen\");\r\n        }\r\n        signal();\r\n    }\r\n    /**\r\n     *  Returns a new [[FetchRequest]] that represents the redirection\r\n     *  to %%location%%.\r\n     */\r\n    redirect(location) {\r\n        // Redirection; for now we only support absolute locations\r\n        const current = this.url.split(\":\")[0].toLowerCase();\r\n        const target = location.split(\":\")[0].toLowerCase();\r\n        // Don't allow redirecting:\r\n        // - non-GET requests\r\n        // - downgrading the security (e.g. https => http)\r\n        // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.method === \"GET\" && (current !== \"https\" || target !== \"http\") && location.match(/^https?:/), `unsupported redirect`, \"UNSUPPORTED_OPERATION\", {\r\n            operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`\r\n        });\r\n        // Create a copy of this request, with a new URL\r\n        const req = new FetchRequest(location);\r\n        req.method = \"GET\";\r\n        req.allowGzip = this.allowGzip;\r\n        req.timeout = this.timeout;\r\n        req.#headers = Object.assign({}, this.#headers);\r\n        if (this.#body) {\r\n            req.#body = new Uint8Array(this.#body);\r\n        }\r\n        req.#bodyType = this.#bodyType;\r\n        // Do not forward credentials unless on the same domain; only absolute\r\n        //req.allowInsecure = false;\r\n        // paths are currently supported; may want a way to specify to forward?\r\n        //setStore(req.#props, \"creds\", getStore(this.#pros, \"creds\"));\r\n        return req;\r\n    }\r\n    /**\r\n     *  Create a new copy of this request.\r\n     */\r\n    clone() {\r\n        const clone = new FetchRequest(this.url);\r\n        // Preserve \"default method\" (i.e. null)\r\n        clone.#method = this.#method;\r\n        // Preserve \"default body\" with type, copying the Uint8Array is present\r\n        if (this.#body) {\r\n            clone.#body = this.#body;\r\n        }\r\n        clone.#bodyType = this.#bodyType;\r\n        // Preserve \"default headers\"\r\n        clone.#headers = Object.assign({}, this.#headers);\r\n        // Credentials is readonly, so we copy internally\r\n        clone.#creds = this.#creds;\r\n        if (this.allowGzip) {\r\n            clone.allowGzip = true;\r\n        }\r\n        clone.timeout = this.timeout;\r\n        if (this.allowInsecureAuthentication) {\r\n            clone.allowInsecureAuthentication = true;\r\n        }\r\n        clone.#preflight = this.#preflight;\r\n        clone.#process = this.#process;\r\n        clone.#retry = this.#retry;\r\n        clone.#throttle = Object.assign({}, this.#throttle);\r\n        clone.#getUrlFunc = this.#getUrlFunc;\r\n        return clone;\r\n    }\r\n    /**\r\n     *  Locks all static configuration for gateways and FetchGetUrlFunc\r\n     *  registration.\r\n     */\r\n    static lockConfig() {\r\n        locked = true;\r\n    }\r\n    /**\r\n     *  Get the current Gateway function for %%scheme%%.\r\n     */\r\n    static getGateway(scheme) {\r\n        return Gateways[scheme.toLowerCase()] || null;\r\n    }\r\n    /**\r\n     *  Use the %%func%% when fetching URIs using %%scheme%%.\r\n     *\r\n     *  This method affects all requests globally.\r\n     *\r\n     *  If [[lockConfig]] has been called, no change is made and this\r\n     *  throws.\r\n     */\r\n    static registerGateway(scheme, func) {\r\n        scheme = scheme.toLowerCase();\r\n        if (scheme === \"http\" || scheme === \"https\") {\r\n            throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);\r\n        }\r\n        if (locked) {\r\n            throw new Error(\"gateways locked\");\r\n        }\r\n        Gateways[scheme] = func;\r\n    }\r\n    /**\r\n     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.\r\n     *\r\n     *  This method affects all requests globally.\r\n     *\r\n     *  If [[lockConfig]] has been called, no change is made and this\r\n     *  throws.\r\n     */\r\n    static registerGetUrl(getUrl) {\r\n        if (locked) {\r\n            throw new Error(\"gateways locked\");\r\n        }\r\n        defaultGetUrlFunc = getUrl;\r\n    }\r\n    /**\r\n     *  Creates a getUrl function that fetches content from HTTP and\r\n     *  HTTPS URLs.\r\n     *\r\n     *  The available %%options%% are dependent on the platform\r\n     *  implementation of the default getUrl function.\r\n     *\r\n     *  This is not generally something that is needed, but is useful\r\n     *  when trying to customize simple behaviour when fetching HTTP\r\n     *  content.\r\n     */\r\n    static createGetUrlFunc(options) {\r\n        return (0,_geturl_js__WEBPACK_IMPORTED_MODULE_0__.createGetUrl)(options);\r\n    }\r\n    /**\r\n     *  Creates a function that can \"fetch\" data URIs.\r\n     *\r\n     *  Note that this is automatically done internally to support\r\n     *  data URIs, so it is not necessary to register it.\r\n     *\r\n     *  This is not generally something that is needed, but may\r\n     *  be useful in a wrapper to perfom custom data URI functionality.\r\n     */\r\n    static createDataGateway() {\r\n        return dataGatewayFunc;\r\n    }\r\n    /**\r\n     *  Creates a function that will fetch IPFS (unvalidated) from\r\n     *  a custom gateway baseUrl.\r\n     *\r\n     *  The default IPFS gateway used internally is\r\n     *  ``\"https:/\\/gateway.ipfs.io/ipfs/\"``.\r\n     */\r\n    static createIpfsGatewayFunc(baseUrl) {\r\n        return getIpfsGatewayFunc(baseUrl);\r\n    }\r\n}\r\n;\r\n/**\r\n *  The response for a FetchRequest.\r\n */\r\nclass FetchResponse {\r\n    #statusCode;\r\n    #statusMessage;\r\n    #headers;\r\n    #body;\r\n    #request;\r\n    #error;\r\n    toString() {\r\n        return `<FetchResponse status=${this.statusCode} body=${this.#body ? (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(this.#body) : \"null\"}>`;\r\n    }\r\n    /**\r\n     *  The response status code.\r\n     */\r\n    get statusCode() { return this.#statusCode; }\r\n    /**\r\n     *  The response status message.\r\n     */\r\n    get statusMessage() { return this.#statusMessage; }\r\n    /**\r\n     *  The response headers. All keys are lower-case.\r\n     */\r\n    get headers() { return Object.assign({}, this.#headers); }\r\n    /**\r\n     *  The response body, or ``null`` if there was no body.\r\n     */\r\n    get body() {\r\n        return (this.#body == null) ? null : new Uint8Array(this.#body);\r\n    }\r\n    /**\r\n     *  The response body as a UTF-8 encoded string, or the empty\r\n     *  string (i.e. ``\"\"``) if there was no body.\r\n     *\r\n     *  An error is thrown if the body is invalid UTF-8 data.\r\n     */\r\n    get bodyText() {\r\n        try {\r\n            return (this.#body == null) ? \"\" : (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(this.#body);\r\n        }\r\n        catch (error) {\r\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"response body is not valid UTF-8 data\", \"UNSUPPORTED_OPERATION\", {\r\n                operation: \"bodyText\", info: { response: this }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     *  The response body, decoded as JSON.\r\n     *\r\n     *  An error is thrown if the body is invalid JSON-encoded data\r\n     *  or if there was no body.\r\n     */\r\n    get bodyJson() {\r\n        try {\r\n            return JSON.parse(this.bodyText);\r\n        }\r\n        catch (error) {\r\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"response body is not valid JSON\", \"UNSUPPORTED_OPERATION\", {\r\n                operation: \"bodyJson\", info: { response: this }\r\n            });\r\n        }\r\n    }\r\n    [Symbol.iterator]() {\r\n        const headers = this.headers;\r\n        const keys = Object.keys(headers);\r\n        let index = 0;\r\n        return {\r\n            next: () => {\r\n                if (index < keys.length) {\r\n                    const key = keys[index++];\r\n                    return {\r\n                        value: [key, headers[key]], done: false\r\n                    };\r\n                }\r\n                return { value: undefined, done: true };\r\n            }\r\n        };\r\n    }\r\n    constructor(statusCode, statusMessage, headers, body, request) {\r\n        this.#statusCode = statusCode;\r\n        this.#statusMessage = statusMessage;\r\n        this.#headers = Object.keys(headers).reduce((accum, k) => {\r\n            accum[k.toLowerCase()] = String(headers[k]);\r\n            return accum;\r\n        }, {});\r\n        this.#body = ((body == null) ? null : new Uint8Array(body));\r\n        this.#request = (request || null);\r\n        this.#error = { message: \"\" };\r\n    }\r\n    /**\r\n     *  Return a Response with matching headers and body, but with\r\n     *  an error status code (i.e. 599) and %%message%% with an\r\n     *  optional %%error%%.\r\n     */\r\n    makeServerError(message, error) {\r\n        let statusMessage;\r\n        if (!message) {\r\n            message = `${this.statusCode} ${this.statusMessage}`;\r\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;\r\n        }\r\n        else {\r\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;\r\n        }\r\n        const response = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || undefined);\r\n        response.#error = { message, error };\r\n        return response;\r\n    }\r\n    /**\r\n     *  If called within a [request.processFunc](FetchRequest-processFunc)\r\n     *  call, causes the request to retry as if throttled for %%stall%%\r\n     *  milliseconds.\r\n     */\r\n    throwThrottleError(message, stall) {\r\n        if (stall == null) {\r\n            stall = -1;\r\n        }\r\n        else {\r\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(Number.isInteger(stall) && stall >= 0, \"invalid stall timeout\", \"stall\", stall);\r\n        }\r\n        const error = new Error(message || \"throttling requests\");\r\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_5__.defineProperties)(error, { stall, throttle: true });\r\n        throw error;\r\n    }\r\n    /**\r\n     *  Get the header value for %%key%%, ignoring case.\r\n     */\r\n    getHeader(key) {\r\n        return this.headers[key.toLowerCase()];\r\n    }\r\n    /**\r\n     *  Returns true if the response has a body.\r\n     */\r\n    hasBody() {\r\n        return (this.#body != null);\r\n    }\r\n    /**\r\n     *  The request made for this response.\r\n     */\r\n    get request() { return this.#request; }\r\n    /**\r\n     *  Returns true if this response was a success statusCode.\r\n     */\r\n    ok() {\r\n        return (this.#error.message === \"\" && this.statusCode >= 200 && this.statusCode < 300);\r\n    }\r\n    /**\r\n     *  Throws a ``SERVER_ERROR`` if this response is not ok.\r\n     */\r\n    assertOk() {\r\n        if (this.ok()) {\r\n            return;\r\n        }\r\n        let { message, error } = this.#error;\r\n        if (message === \"\") {\r\n            message = `server response ${this.statusCode} ${this.statusMessage}`;\r\n        }\r\n        let requestUrl = null;\r\n        if (this.request) {\r\n            requestUrl = this.request.url;\r\n        }\r\n        let responseBody = null;\r\n        try {\r\n            if (this.#body) {\r\n                responseBody = (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(this.#body);\r\n            }\r\n        }\r\n        catch (e) { }\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, message, \"SERVER_ERROR\", {\r\n            request: (this.request || \"unknown request\"), response: this, error,\r\n            info: {\r\n                requestUrl, responseBody,\r\n                responseStatus: `${this.statusCode} ${this.statusMessage}`\r\n            }\r\n        });\r\n    }\r\n}\r\nfunction getTime() { return (new Date()).getTime(); }\r\nfunction unpercent(value) {\r\n    return (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\r\n        return String.fromCharCode(parseInt(code, 16));\r\n    }));\r\n}\r\nfunction wait(delay) {\r\n    return new Promise((resolve) => setTimeout(resolve, delay));\r\n}\r\n//# sourceMappingURL=fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9mZXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN5RDtBQUNyQjtBQUNpQjtBQUNGO0FBQ0c7QUFDWDtBQUMzQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQVk7QUFDcEMscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxjQUFjLHdEQUFZO0FBQ25DO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUSxFQUFFLFNBQVM7QUFDMUQ7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsYUFBYTtBQUNoRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLFFBQVEsa0RBQU0sOENBQThDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxnREFBZ0Qsd0RBQVksQ0FBQyxxREFBVyxlQUFlO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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bjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcdXRpbHNcXGZldGNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgRmV0Y2hpbmcgY29udGVudCBmcm9tIHRoZSB3ZWIgaXMgZW52aXJvbm1lbnQtc3BlY2lmaWMsIHNvIEV0aGVyc1xyXG4gKiAgcHJvdmlkZXMgYW4gYWJzdHJhY3Rpb24gdGhhdCBlYWNoIGVudmlyb25tZW50IGNhbiBpbXBsZW1lbnQgdG8gcHJvdmlkZVxyXG4gKiAgdGhpcyBzZXJ2aWNlLlxyXG4gKlxyXG4gKiAgT24gW05vZGUuanNdKGxpbmstbm9kZSksIHRoZSBgYGh0dHBgYCBhbmQgYGBodHRwc2BgIGxpYnMgYXJlIHVzZWQgdG9cclxuICogIGNyZWF0ZSBhIHJlcXVlc3Qgb2JqZWN0LCByZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgYW5kIHByb2Nlc3MgZGF0YVxyXG4gKiAgYW5kIHBvcHVsYXRlIHRoZSBbW0ZldGNoUmVzcG9uc2VdXS5cclxuICpcclxuICogIEluIGEgYnJvd3NlciwgdGhlIFtET00gZmV0Y2hdKGxpbmstanMtZmV0Y2gpIGlzIHVzZWQsIGFuZCB0aGUgcmVzdWx0aW5nXHJcbiAqICBgYFByb21pc2VgYCBpcyB3YWl0ZWQgb24gdG8gcmV0cmlldmUgdGhlIHBheWxvYWQuXHJcbiAqXHJcbiAqICBUaGUgW1tGZXRjaFJlcXVlc3RdXSBpcyByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgbWFueSBjb21tb24gc2l0dWF0aW9ucyxcclxuICogIHN1Y2ggYXMgcmVkaXJlY3RzLCBzZXJ2ZXIgdGhyb3R0bGluZywgYXV0aGVudGljYXRpb24sIGV0Yy5cclxuICpcclxuICogIEl0IGFsc28gaGFuZGxlcyBjb21tb24gZ2F0ZXdheXMsIHN1Y2ggYXMgSVBGUyBhbmQgZGF0YSBVUklzLlxyXG4gKlxyXG4gKiAgQF9zZWN0aW9uIGFwaS91dGlscy9mZXRjaGluZzpGZXRjaGluZyBXZWIgQ29udGVudCAgW2Fib3V0LWZldGNoXVxyXG4gKi9cclxuaW1wb3J0IHsgZGVjb2RlQmFzZTY0LCBlbmNvZGVCYXNlNjQgfSBmcm9tIFwiLi9iYXNlNjQuanNcIjtcclxuaW1wb3J0IHsgaGV4bGlmeSB9IGZyb20gXCIuL2RhdGEuanNcIjtcclxuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xyXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vcHJvcGVydGllcy5qc1wiO1xyXG5pbXBvcnQgeyB0b1V0ZjhCeXRlcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIi4vdXRmOC5qc1wiO1xyXG5pbXBvcnQgeyBjcmVhdGVHZXRVcmwgfSBmcm9tIFwiLi9nZXR1cmwuanNcIjtcclxuY29uc3QgTUFYX0FUVEVNUFRTID0gMTI7XHJcbmNvbnN0IFNMT1RfSU5URVJWQUwgPSAyNTA7XHJcbi8vIFRoZSBnbG9iYWwgRmV0Y2hHZXRVcmxGdW5jIGltcGxlbWVudGF0aW9uLlxyXG5sZXQgZGVmYXVsdEdldFVybEZ1bmMgPSBjcmVhdGVHZXRVcmwoKTtcclxuY29uc3QgcmVEYXRhID0gbmV3IFJlZ0V4cChcIl5kYXRhOihbXjs6XSopPyg7YmFzZTY0KT8sKC4qKSRcIiwgXCJpXCIpO1xyXG5jb25zdCByZUlwZnMgPSBuZXcgUmVnRXhwKFwiXmlwZnM6L1xcLyhpcGZzLyk/KC4qKSRcIiwgXCJpXCIpO1xyXG4vLyBJZiBsb2NrZWQsIG5ldyBHYXRld2F5cyBjYW5ub3QgYmUgYWRkZWRcclxubGV0IGxvY2tlZCA9IGZhbHNlO1xyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0Jhc2ljc19vZl9IVFRQL0RhdGFfVVJMc1xyXG5hc3luYyBmdW5jdGlvbiBkYXRhR2F0ZXdheUZ1bmModXJsLCBzaWduYWwpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVEYXRhKTtcclxuICAgICAgICBpZiAoIW1hdGNoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZGF0YVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGZXRjaFJlc3BvbnNlKDIwMCwgXCJPS1wiLCB7XHJcbiAgICAgICAgICAgIFwiY29udGVudC10eXBlXCI6IChtYXRjaFsxXSB8fCBcInRleHQvcGxhaW5cIiksXHJcbiAgICAgICAgfSwgKG1hdGNoWzJdID8gZGVjb2RlQmFzZTY0KG1hdGNoWzNdKSA6IHVucGVyY2VudChtYXRjaFszXSkpKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZSg1OTksIFwiQkFEIFJFUVVFU1QgKGludmFsaWQgZGF0YTogVVJJKVwiLCB7fSwgbnVsbCwgbmV3IEZldGNoUmVxdWVzdCh1cmwpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIFJldHVybnMgYSBbW0ZldGNoR2F0ZXdheUZ1bmNdXSBmb3IgZmV0Y2hpbmcgY29udGVudCBmcm9tIGEgc3RhbmRhcmRcclxuICogIElQRlMgZ2F0ZXdheSBob3N0ZWQgYXQgJSViYXNlVXJsJSUuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRJcGZzR2F0ZXdheUZ1bmMoYmFzZVVybCkge1xyXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2F0ZXdheUlwZnModXJsLCBzaWduYWwpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHVybC5tYXRjaChyZUlwZnMpO1xyXG4gICAgICAgICAgICBpZiAoIW1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGxpbmtcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGZXRjaFJlcXVlc3QoYCR7YmFzZVVybH0ke21hdGNoWzJdfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGZXRjaFJlc3BvbnNlKDU5OSwgXCJCQUQgUkVRVUVTVCAoaW52YWxpZCBJUEZTIFVSSSlcIiwge30sIG51bGwsIG5ldyBGZXRjaFJlcXVlc3QodXJsKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdhdGV3YXlJcGZzO1xyXG59XHJcbmNvbnN0IEdhdGV3YXlzID0ge1xyXG4gICAgXCJkYXRhXCI6IGRhdGFHYXRld2F5RnVuYyxcclxuICAgIFwiaXBmc1wiOiBnZXRJcGZzR2F0ZXdheUZ1bmMoXCJodHRwczovXFwvZ2F0ZXdheS5pcGZzLmlvL2lwZnMvXCIpXHJcbn07XHJcbmNvbnN0IGZldGNoU2lnbmFscyA9IG5ldyBXZWFrTWFwKCk7XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBGZXRjaENhbmNlbFNpZ25hbCB7XHJcbiAgICAjbGlzdGVuZXJzO1xyXG4gICAgI2NhbmNlbGxlZDtcclxuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QpIHtcclxuICAgICAgICB0aGlzLiNsaXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICB0aGlzLiNjYW5jZWxsZWQgPSBmYWxzZTtcclxuICAgICAgICBmZXRjaFNpZ25hbHMuc2V0KHJlcXVlc3QsICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuI2NhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuI2NhbmNlbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4jbGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgbGlzdGVuZXIoKTsgfSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy4jbGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhZGRMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIGFzc2VydCghdGhpcy4jY2FuY2VsbGVkLCBcInNpbmdhbCBhbHJlYWR5IGNhbmNlbGxlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmZXRjaENhbmNlbFNpZ25hbC5hZGRDYW5jZWxMaXN0ZW5lclwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy4jbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNhbmNlbGxlZCgpIHsgcmV0dXJuIHRoaXMuI2NhbmNlbGxlZDsgfVxyXG4gICAgY2hlY2tTaWduYWwoKSB7XHJcbiAgICAgICAgYXNzZXJ0KCF0aGlzLmNhbmNlbGxlZCwgXCJjYW5jZWxsZWRcIiwgXCJDQU5DRUxMRURcIiwge30pO1xyXG4gICAgfVxyXG59XHJcbi8vIENoZWNrIHRoZSBzaWduYWwsIHRocm93aW5nIGlmIGl0IGlzIGNhbmNlbGxlZFxyXG5mdW5jdGlvbiBjaGVja1NpZ25hbChzaWduYWwpIHtcclxuICAgIGlmIChzaWduYWwgPT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgc2lnbmFsOyBzaG91bGQgbm90IGhhcHBlblwiKTtcclxuICAgIH1cclxuICAgIHNpZ25hbC5jaGVja1NpZ25hbCgpO1xyXG4gICAgcmV0dXJuIHNpZ25hbDtcclxufVxyXG4vKipcclxuICogIFJlcHJlc2VudHMgYSByZXF1ZXN0IGZvciBhIHJlc291cmNlIHVzaW5nIGEgVVJJLlxyXG4gKlxyXG4gKiAgQnkgZGVmYXVsdCwgdGhlIHN1cHBvcnRlZCBzY2hlbWVzIGFyZSBgYEhUVFBgYCwgYGBIVFRQU2BgLCBgYGRhdGE6YGAsXHJcbiAqICBhbmQgYGBJUEZTOmBgLlxyXG4gKlxyXG4gKiAgQWRkaXRpb25hbCBzY2hlbWVzIGNhbiBiZSBhZGRlZCBnbG9iYWxseSB1c2luZyBbW3JlZ2lzdGVyR2F0ZXdheV1dLlxyXG4gKlxyXG4gKiAgQGV4YW1wbGU6XHJcbiAqICAgIHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QoXCJodHRwczovL3d3dy5yaWNtb28uY29tXCIpXHJcbiAqICAgIHJlc3AgPSBhd2FpdCByZXEuc2VuZCgpXHJcbiAqICAgIHJlc3AuYm9keS5sZW5ndGhcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEZldGNoUmVxdWVzdCB7XHJcbiAgICAjYWxsb3dJbnNlY3VyZTtcclxuICAgICNnemlwO1xyXG4gICAgI2hlYWRlcnM7XHJcbiAgICAjbWV0aG9kO1xyXG4gICAgI3RpbWVvdXQ7XHJcbiAgICAjdXJsO1xyXG4gICAgI2JvZHk7XHJcbiAgICAjYm9keVR5cGU7XHJcbiAgICAjY3JlZHM7XHJcbiAgICAvLyBIb29rc1xyXG4gICAgI3ByZWZsaWdodDtcclxuICAgICNwcm9jZXNzO1xyXG4gICAgI3JldHJ5O1xyXG4gICAgI3NpZ25hbDtcclxuICAgICN0aHJvdHRsZTtcclxuICAgICNnZXRVcmxGdW5jO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGZldGNoIFVSTCB0byByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICBnZXQgdXJsKCkgeyByZXR1cm4gdGhpcy4jdXJsOyB9XHJcbiAgICBzZXQgdXJsKHVybCkge1xyXG4gICAgICAgIHRoaXMuI3VybCA9IFN0cmluZyh1cmwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGZldGNoIGJvZHksIGlmIGFueSwgdG8gc2VuZCBhcyB0aGUgcmVxdWVzdCBib2R5LiAvLyhkZWZhdWx0OiBudWxsKS8vXHJcbiAgICAgKlxyXG4gICAgICogIFdoZW4gc2V0dGluZyBhIGJvZHksIHRoZSBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCBpcyBhdXRvbWF0aWNhbGx5XHJcbiAgICAgKiAgc2V0IGFuZCB3aWxsIGJlIHVzZWQgaWYgKipub3Qgb3ZlcnJpZGRlbioqIGJ5IHNldHRpbmcgYSBjdXN0b21cclxuICAgICAqICBoZWFkZXIuXHJcbiAgICAgKlxyXG4gICAgICogIElmICUlYm9keSUlIGlzIG51bGwsIHRoZSBib2R5IGlzIGNsZWFyZWQgKGFsb25nIHdpdGggdGhlXHJcbiAgICAgKiAgaW50cmluc2ljIGBgQ29udGVudC1UeXBlYGApLlxyXG4gICAgICpcclxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhIHN0cmluZywgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzIHNldCB0b1xyXG4gICAgICogIGBgdGV4dC9wbGFpbmBgLlxyXG4gICAgICpcclxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhIFVpbnQ4QXJyYXksIHRoZSBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCBpcyBzZXQgdG9cclxuICAgICAqICBgYGFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbWBgLlxyXG4gICAgICpcclxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhbnkgb3RoZXIgb2JqZWN0LCB0aGUgaW50cmluc2ljIGBgQ29udGVudC1UeXBlYGAgaXNcclxuICAgICAqICBzZXQgdG8gYGBhcHBsaWNhdGlvbi9qc29uYGAuXHJcbiAgICAgKi9cclxuICAgIGdldCBib2R5KCkge1xyXG4gICAgICAgIGlmICh0aGlzLiNib2R5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLiNib2R5KTtcclxuICAgIH1cclxuICAgIHNldCBib2R5KGJvZHkpIHtcclxuICAgICAgICBpZiAoYm9keSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGJvZHkpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSB0b1V0ZjhCeXRlcyhib2R5KTtcclxuICAgICAgICAgICAgdGhpcy4jYm9keVR5cGUgPSBcInRleHQvcGxhaW5cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcclxuICAgICAgICAgICAgdGhpcy4jYm9keSA9IGJvZHk7XHJcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChib2R5KSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICB0aGlzLiNib2R5ID0gdG9VdGY4Qnl0ZXMoSlNPTi5zdHJpbmdpZnkoYm9keSkpO1xyXG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBib2R5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVxdWVzdCBoYXMgYSBib2R5LlxyXG4gICAgICovXHJcbiAgICBoYXNCb2R5KCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy4jYm9keSAhPSBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBIVFRQIG1ldGhvZCB0byB1c2Ugd2hlbiByZXF1ZXN0aW5nIHRoZSBVUkkuIElmIG5vIG1ldGhvZFxyXG4gICAgICogIGhhcyBiZWVuIGV4cGxpY2l0bHkgc2V0LCB0aGVuIGBgR0VUYGAgaXMgdXNlZCBpZiB0aGUgYm9keSBpc1xyXG4gICAgICogIG51bGwgYW5kIGBgUE9TVGBgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IG1ldGhvZCgpIHtcclxuICAgICAgICBpZiAodGhpcy4jbWV0aG9kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNtZXRob2Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmhhc0JvZHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJQT1NUXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcIkdFVFwiO1xyXG4gICAgfVxyXG4gICAgc2V0IG1ldGhvZChtZXRob2QpIHtcclxuICAgICAgICBpZiAobWV0aG9kID09IG51bGwpIHtcclxuICAgICAgICAgICAgbWV0aG9kID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jbWV0aG9kID0gU3RyaW5nKG1ldGhvZCkudG9VcHBlckNhc2UoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBoZWFkZXJzIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gcmVxdWVzdGluZyB0aGUgVVJJLiBBbGxcclxuICAgICAqICBrZXlzIGFyZSBsb3dlci1jYXNlLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIG9iamVjdCBpcyBhIGNvcHksIHNvIGFueSBjaGFuZ2VzIHdpbGwgKipOT1QqKiBiZSByZWZsZWN0ZWRcclxuICAgICAqICBpbiB0aGUgYGBGZXRjaFJlcXVlc3RgYC5cclxuICAgICAqXHJcbiAgICAgKiAgVG8gc2V0IGEgaGVhZGVyIGVudHJ5LCB1c2UgdGhlIGBgc2V0SGVhZGVyYGAgbWV0aG9kLlxyXG4gICAgICovXHJcbiAgICBnZXQgaGVhZGVycygpIHtcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7XHJcbiAgICAgICAgaWYgKHRoaXMuI2NyZWRzKSB7XHJcbiAgICAgICAgICAgIGhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdID0gYEJhc2ljICR7ZW5jb2RlQmFzZTY0KHRvVXRmOEJ5dGVzKHRoaXMuI2NyZWRzKSl9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgO1xyXG4gICAgICAgIGlmICh0aGlzLmFsbG93R3ppcCkge1xyXG4gICAgICAgICAgICBoZWFkZXJzW1wiYWNjZXB0LWVuY29kaW5nXCJdID0gXCJnemlwXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID09IG51bGwgJiYgdGhpcy4jYm9keVR5cGUpIHtcclxuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IHRoaXMuI2JvZHlUeXBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5ib2R5KSB7XHJcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXSA9IFN0cmluZyh0aGlzLmJvZHkubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBHZXQgdGhlIGhlYWRlciBmb3IgJSVrZXklJSwgaWdub3JpbmcgY2FzZS5cclxuICAgICAqL1xyXG4gICAgZ2V0SGVhZGVyKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgU2V0IHRoZSBoZWFkZXIgZm9yICUla2V5JSUgdG8gJSV2YWx1ZSUlLiBBbGwgdmFsdWVzIGFyZSBjb2VyY2VkXHJcbiAgICAgKiAgdG8gYSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIHNldEhlYWRlcihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy4jaGVhZGVyc1tTdHJpbmcoa2V5KS50b0xvd2VyQ2FzZSgpXSA9IFN0cmluZyh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDbGVhciBhbGwgaGVhZGVycywgcmVzZXR0aW5nIGFsbCBpbnRyaW5zaWMgaGVhZGVycy5cclxuICAgICAqL1xyXG4gICAgY2xlYXJIZWFkZXJzKCkge1xyXG4gICAgICAgIHRoaXMuI2hlYWRlcnMgPSB7fTtcclxuICAgIH1cclxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmhlYWRlcnM7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpO1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwga2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2luZGV4KytdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBba2V5LCBoZWFkZXJzW2tleV1dLCBkb25lOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHZhbHVlIHRoYXQgd2lsbCBiZSBzZW50IGZvciB0aGUgYGBBdXRob3JpemF0aW9uYGAgaGVhZGVyLlxyXG4gICAgICpcclxuICAgICAqICBUbyBzZXQgdGhlIGNyZWRlbnRpYWxzLCB1c2UgdGhlIGBgc2V0Q3JlZGVudGlhbHNgYCBtZXRob2QuXHJcbiAgICAgKi9cclxuICAgIGdldCBjcmVkZW50aWFscygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4jY3JlZHMgfHwgbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFNldHMgYW4gYGBBdXRob3JpemF0aW9uYGAgZm9yICUldXNlcm5hbWUlJSB3aXRoICUlcGFzc3dvcmQlJS5cclxuICAgICAqL1xyXG4gICAgc2V0Q3JlZGVudGlhbHModXNlcm5hbWUsIHBhc3N3b3JkKSB7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIXVzZXJuYW1lLm1hdGNoKC86LyksIFwiaW52YWxpZCBiYXNpYyBhdXRoZW50aWNhdGlvbiB1c2VybmFtZVwiLCBcInVzZXJuYW1lXCIsIFwiW1JFREFDVEVEXVwiKTtcclxuICAgICAgICB0aGlzLiNjcmVkcyA9IGAke3VzZXJuYW1lfToke3Bhc3N3b3JkfWA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBFbmFibGUgYW5kIHJlcXVlc3QgZ3ppcC1lbmNvZGVkIHJlc3BvbnNlcy4gVGhlIHJlc3BvbnNlIHdpbGxcclxuICAgICAqICBhdXRvbWF0aWNhbGx5IGJlIGRlY29tcHJlc3NlZC4gLy8oZGVmYXVsdDogdHJ1ZSkvL1xyXG4gICAgICovXHJcbiAgICBnZXQgYWxsb3dHemlwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNnemlwO1xyXG4gICAgfVxyXG4gICAgc2V0IGFsbG93R3ppcCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuI2d6aXAgPSAhIXZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQWxsb3cgYGBBdXRoZW50aWNhdGlvbmBgIGNyZWRlbnRpYWxzIHRvIGJlIHNlbnQgb3ZlciBpbnNlY3VyZVxyXG4gICAgICogIGNoYW5uZWxzLiAvLyhkZWZhdWx0OiBmYWxzZSkvL1xyXG4gICAgICovXHJcbiAgICBnZXQgYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuI2FsbG93SW5zZWN1cmU7XHJcbiAgICB9XHJcbiAgICBzZXQgYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy4jYWxsb3dJbnNlY3VyZSA9ICEhdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdGltZW91dCAoaW4gbWlsbGlzZWNvbmRzKSB0byB3YWl0IGZvciBhIGNvbXBsZXRlIHJlc3BvbnNlLlxyXG4gICAgICogIC8vKGRlZmF1bHQ6IDUgbWludXRlcykvL1xyXG4gICAgICovXHJcbiAgICBnZXQgdGltZW91dCgpIHsgcmV0dXJuIHRoaXMuI3RpbWVvdXQ7IH1cclxuICAgIHNldCB0aW1lb3V0KHRpbWVvdXQpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudCh0aW1lb3V0ID49IDAsIFwidGltZW91dCBtdXN0IGJlIG5vbi16ZXJvXCIsIFwidGltZW91dFwiLCB0aW1lb3V0KTtcclxuICAgICAgICB0aGlzLiN0aW1lb3V0ID0gdGltZW91dDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHByaW9yIHRvIGVhY2ggcmVxdWVzdCwgZm9yIGV4YW1wbGVcclxuICAgICAqICBkdXJpbmcgYSByZWRpcmVjdGlvbiBvciByZXRyeSBpbiBjYXNlIG9mIHNlcnZlciB0aHJvdHRsaW5nLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIG9mZmVycyBhbiBvcHBvcnR1bml0eSB0byBwb3B1bGF0ZSBoZWFkZXJzIG9yIHVwZGF0ZVxyXG4gICAgICogIGNvbnRlbnQgYmVmb3JlIHNlbmRpbmcgYSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICBnZXQgcHJlZmxpZ2h0RnVuYygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4jcHJlZmxpZ2h0IHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBzZXQgcHJlZmxpZ2h0RnVuYyhwcmVmbGlnaHQpIHtcclxuICAgICAgICB0aGlzLiNwcmVmbGlnaHQgPSBwcmVmbGlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciBlYWNoIHJlc3BvbnNlLCBvZmZlcmluZyBhblxyXG4gICAgICogIG9wcG9ydHVuaXR5IHRvIHByb3ZpZGUgY2xpZW50LWxldmVsIHRocm90dGxpbmcgb3IgdXBkYXRpbmdcclxuICAgICAqICByZXNwb25zZSBkYXRhLlxyXG4gICAgICpcclxuICAgICAqICBBbnkgZXJyb3IgdGhyb3duIGluIHRoaXMgY2F1c2VzIHRoZSBgYHNlbmQoKWBgIHRvIHRocm93LlxyXG4gICAgICpcclxuICAgICAqICBUbyBzY2hlZHVsZSBhIHJldHJ5IGF0dGVtcHQgKGFzc3VtaW5nIHRoZSBtYXhpbXVtIHJldHJ5IGxpbWl0XHJcbiAgICAgKiAgaGFzIG5vdCBiZWVuIHJlYWNoZWQpLCB1c2UgW1tyZXNwb25zZS50aHJvd1Rocm90dGxlRXJyb3JdXS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHByb2Nlc3NGdW5jKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNwcm9jZXNzIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBzZXQgcHJvY2Vzc0Z1bmMocHJvY2Vzcykge1xyXG4gICAgICAgIHRoaXMuI3Byb2Nlc3MgPSBwcm9jZXNzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZWFjaCByZXRyeSBhdHRlbXB0LlxyXG4gICAgICovXHJcbiAgICBnZXQgcmV0cnlGdW5jKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNyZXRyeSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgc2V0IHJldHJ5RnVuYyhyZXRyeSkge1xyXG4gICAgICAgIHRoaXMuI3JldHJ5ID0gcmV0cnk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB0byBmZXRjaCBjb250ZW50IGZyb20gSFRUUCBhbmRcclxuICAgICAqICBIVFRQUyBVUkxzIGFuZCBpcyBwbGF0Zm9ybSBzcGVjaWZpYyAoZS5nLiBub2RlanMgdnNcclxuICAgICAqICBicm93c2VycykuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgaXMgYnkgZGVmYXVsdCB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgZ2xvYmFsIGdldFVybFxyXG4gICAgICogIGZ1bmN0aW9uLCB3aGljaCBjYW4gYmUgY2hhbmdlZCB1c2luZyBbW3JlZ2lzdGVyR2V0VXJsXV0uXHJcbiAgICAgKiAgSWYgdGhpcyBoYXMgYmVlbiBzZXQsIHNldHRpbmcgaXMgdG8gYGBudWxsYGAgd2lsbCBjYXVzZVxyXG4gICAgICogIHRoaXMgRmV0Y2hSZXF1ZXN0IChhbmQgYW55IGZ1dHVyZSBjbG9uZXMpIHRvIHJldmVydCBiYWNrIHRvXHJcbiAgICAgKiAgdXNpbmcgdGhlIGN1cnJlbnRseSByZWdpc3RlcmVkIGdsb2JhbCBnZXRVcmwgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogIFNldHRpbmcgdGhpcyBpcyBnZW5lcmFsbHkgbm90IG5lY2Vzc2FyeSwgYnV0IG1heSBiZSB1c2VmdWxcclxuICAgICAqICBmb3IgZGV2ZWxvcGVycyB0aGF0IHdpc2ggdG8gaW50ZXJjZXB0IHJlcXVlc3RzIG9yIHRvXHJcbiAgICAgKiAgY29uZmlndXJlZ2UgYSBwcm94eSBvciBvdGhlciBhZ2VudC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGdldFVybEZ1bmMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldFVybEZ1bmMgfHwgZGVmYXVsdEdldFVybEZ1bmM7XHJcbiAgICB9XHJcbiAgICBzZXQgZ2V0VXJsRnVuYyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuI2dldFVybEZ1bmMgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZSBhIG5ldyBGZXRjaFJlcXVlc3QgaW5zdGFuY2Ugd2l0aCBkZWZhdWx0IHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiAgT25jZSBjcmVhdGVkLCBlYWNoIHByb3BlcnR5IG1heSBiZSBzZXQgYmVmb3JlIGlzc3VpbmcgYVxyXG4gICAgICogIGBgLnNlbmQoKWBgIHRvIG1ha2UgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHVybCkge1xyXG4gICAgICAgIHRoaXMuI3VybCA9IFN0cmluZyh1cmwpO1xyXG4gICAgICAgIHRoaXMuI2FsbG93SW5zZWN1cmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLiNnemlwID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLiNoZWFkZXJzID0ge307XHJcbiAgICAgICAgdGhpcy4jbWV0aG9kID0gXCJcIjtcclxuICAgICAgICB0aGlzLiN0aW1lb3V0ID0gMzAwMDAwO1xyXG4gICAgICAgIHRoaXMuI3Rocm90dGxlID0ge1xyXG4gICAgICAgICAgICBzbG90SW50ZXJ2YWw6IFNMT1RfSU5URVJWQUwsXHJcbiAgICAgICAgICAgIG1heEF0dGVtcHRzOiBNQVhfQVRURU1QVFNcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuI2dldFVybEZ1bmMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIGA8RmV0Y2hSZXF1ZXN0IG1ldGhvZD0ke0pTT04uc3RyaW5naWZ5KHRoaXMubWV0aG9kKX0gdXJsPSR7SlNPTi5zdHJpbmdpZnkodGhpcy51cmwpfSBoZWFkZXJzPSR7SlNPTi5zdHJpbmdpZnkodGhpcy5oZWFkZXJzKX0gYm9keT0ke3RoaXMuI2JvZHkgPyBoZXhsaWZ5KHRoaXMuI2JvZHkpIDogXCJudWxsXCJ9PmA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBVcGRhdGUgdGhlIHRocm90dGxlIHBhcmFtZXRlcnMgdXNlZCB0byBkZXRlcm1pbmUgbWF4aW11bVxyXG4gICAgICogIGF0dGVtcHRzIGFuZCBleHBvbmVudGlhbC1iYWNrb2ZmIHByb3BlcnRpZXMuXHJcbiAgICAgKi9cclxuICAgIHNldFRocm90dGxlUGFyYW1zKHBhcmFtcykge1xyXG4gICAgICAgIGlmIChwYXJhbXMuc2xvdEludGVydmFsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy4jdGhyb3R0bGUuc2xvdEludGVydmFsID0gcGFyYW1zLnNsb3RJbnRlcnZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhcmFtcy5tYXhBdHRlbXB0cyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuI3Rocm90dGxlLm1heEF0dGVtcHRzID0gcGFyYW1zLm1heEF0dGVtcHRzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jICNzZW5kKGF0dGVtcHQsIGV4cGlyZXMsIGRlbGF5LCBfcmVxdWVzdCwgX3Jlc3BvbnNlKSB7XHJcbiAgICAgICAgaWYgKGF0dGVtcHQgPj0gdGhpcy4jdGhyb3R0bGUubWF4QXR0ZW1wdHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9yZXNwb25zZS5tYWtlU2VydmVyRXJyb3IoXCJleGNlZWRlZCBtYXhpbXVtIHJldHJ5IGxpbWl0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnQoZ2V0VGltZSgpIDw9IGV4cGlyZXMsIFwidGltZW91dFwiLCBcIlRJTUVPVVRcIiwge1xyXG4gICAgICAgICAgICBvcGVyYXRpb246IFwicmVxdWVzdC5zZW5kXCIsIHJlYXNvbjogXCJ0aW1lb3V0XCIsIHJlcXVlc3Q6IF9yZXF1ZXN0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGRlbGF5ID4gMCkge1xyXG4gICAgICAgICAgICBhd2FpdCB3YWl0KGRlbGF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlcSA9IHRoaXMuY2xvbmUoKTtcclxuICAgICAgICBjb25zdCBzY2hlbWUgPSAocmVxLnVybC5zcGxpdChcIjpcIilbMF0gfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAvLyBQcm9jZXNzIGFueSBHYXRld2F5c1xyXG4gICAgICAgIGlmIChzY2hlbWUgaW4gR2F0ZXdheXMpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgR2F0ZXdheXNbc2NoZW1lXShyZXEudXJsLCBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKSk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBGZXRjaFJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzRnVuYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm9jZXNzRnVuYyhyZXEsIHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBwcm9jZXNzaW5nOyB0aHJvdyBhIDV4eCBzZXJ2ZXIgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnRocm90dGxlID09IG51bGwgfHwgdHlwZW9mIChlcnJvci5zdGFsbCkgIT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1ha2VTZXJ2ZXJFcnJvcihcImVycm9yIGluIHBvc3QtcHJvY2Vzc2luZyBmdW5jdGlvblwiLCBlcnJvcikuYXNzZXJ0T2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdGhyb3R0bGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXEgPSByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlIGhhdmUgYSBwcmVmbGlnaHQgZnVuY3Rpb247IHVwZGF0ZSB0aGUgcmVxdWVzdFxyXG4gICAgICAgIGlmICh0aGlzLnByZWZsaWdodEZ1bmMpIHtcclxuICAgICAgICAgICAgcmVxID0gYXdhaXQgdGhpcy5wcmVmbGlnaHRGdW5jKHJlcSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmdldFVybEZ1bmMocmVxLCBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKSk7XHJcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gbmV3IEZldGNoUmVzcG9uc2UocmVzcC5zdGF0dXNDb2RlLCByZXNwLnN0YXR1c01lc3NhZ2UsIHJlc3AuaGVhZGVycywgcmVzcC5ib2R5LCBfcmVxdWVzdCk7XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDIpIHtcclxuICAgICAgICAgICAgLy8gUmVkaXJlY3RcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbiB8fCBcIlwiO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5yZWRpcmVjdChsb2NhdGlvbikuI3NlbmQoYXR0ZW1wdCArIDEsIGV4cGlyZXMsIDAsIF9yZXF1ZXN0LCByZXNwb25zZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgICAgICAgICAgLy8gVGhpbmdzIHdvbid0IGdldCBhbnkgYmV0dGVyIG9uIGFub3RoZXIgYXR0ZW1wdDsgYWJvcnRcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MjkpIHtcclxuICAgICAgICAgICAgLy8gVGhyb3R0bGVcclxuICAgICAgICAgICAgaWYgKHRoaXMucmV0cnlGdW5jID09IG51bGwgfHwgKGF3YWl0IHRoaXMucmV0cnlGdW5jKHJlcSwgcmVzcG9uc2UsIGF0dGVtcHQpKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IHJlc3BvbnNlLmhlYWRlcnNbXCJyZXRyeS1hZnRlclwiXTtcclxuICAgICAgICAgICAgICAgIGxldCBkZWxheSA9IHRoaXMuI3Rocm90dGxlLnNsb3RJbnRlcnZhbCAqIE1hdGgudHJ1bmMoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHJldHJ5QWZ0ZXIpID09PSBcInN0cmluZ1wiICYmIHJldHJ5QWZ0ZXIubWF0Y2goL15bMS05XVswLTldKiQvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gcGFyc2VJbnQocmV0cnlBZnRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxLmNsb25lKCkuI3NlbmQoYXR0ZW1wdCArIDEsIGV4cGlyZXMsIGRlbGF5LCBfcmVxdWVzdCwgcmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NGdW5jKSB7XHJcbiAgICAgICAgICAgIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb2Nlc3NGdW5jKHJlcSwgcmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIHByb2Nlc3Npbmc7IHRocm93IGEgNXh4IHNlcnZlciBlcnJvclxyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnRocm90dGxlID09IG51bGwgfHwgdHlwZW9mIChlcnJvci5zdGFsbCkgIT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5tYWtlU2VydmVyRXJyb3IoXCJlcnJvciBpbiBwb3N0LXByb2Nlc3NpbmcgZnVuY3Rpb25cIiwgZXJyb3IpLmFzc2VydE9rKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUaHJvdHRsZVxyXG4gICAgICAgICAgICAgICAgbGV0IGRlbGF5ID0gdGhpcy4jdGhyb3R0bGUuc2xvdEludGVydmFsICogTWF0aC50cnVuYyhNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgYXR0ZW1wdCkpO1xyXG4gICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnN0YWxsID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxheSA9IGVycm9yLnN0YWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5jbG9uZSgpLiNzZW5kKGF0dGVtcHQgKyAxLCBleHBpcmVzLCBkZWxheSwgX3JlcXVlc3QsIHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgcmVzcG9uc2UgYnkgc2VuZGluZyB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgc2VuZCgpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy4jc2lnbmFsID09IG51bGwsIFwicmVxdWVzdCBhbHJlYWR5IHNlbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZmV0Y2hSZXF1ZXN0LnNlbmRcIiB9KTtcclxuICAgICAgICB0aGlzLiNzaWduYWwgPSBuZXcgRmV0Y2hDYW5jZWxTaWduYWwodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI3NlbmQoMCwgZ2V0VGltZSgpICsgdGhpcy50aW1lb3V0LCAwLCB0aGlzLCBuZXcgRmV0Y2hSZXNwb25zZSgwLCBcIlwiLCB7fSwgbnVsbCwgdGhpcykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ2FuY2VscyB0aGUgaW5mbGlnaHQgcmVzcG9uc2UsIGNhdXNpbmcgYSBgYENBTkNFTExFRGBgXHJcbiAgICAgKiAgZXJyb3IgdG8gYmUgcmVqZWN0ZWQgZnJvbSB0aGUgW1tzZW5kXV0uXHJcbiAgICAgKi9cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy4jc2lnbmFsICE9IG51bGwsIFwicmVxdWVzdCBoYXMgbm90IGJlZW4gc2VudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmZXRjaFJlcXVlc3QuY2FuY2VsXCIgfSk7XHJcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gZmV0Y2hTaWduYWxzLmdldCh0aGlzKTtcclxuICAgICAgICBpZiAoIXNpZ25hbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHNpZ25hbDsgc2hvdWxkIG5vdCBoYXBwZW5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNpZ25hbCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZldGNoUmVxdWVzdF1dIHRoYXQgcmVwcmVzZW50cyB0aGUgcmVkaXJlY3Rpb25cclxuICAgICAqICB0byAlJWxvY2F0aW9uJSUuXHJcbiAgICAgKi9cclxuICAgIHJlZGlyZWN0KGxvY2F0aW9uKSB7XHJcbiAgICAgICAgLy8gUmVkaXJlY3Rpb247IGZvciBub3cgd2Ugb25seSBzdXBwb3J0IGFic29sdXRlIGxvY2F0aW9uc1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLnVybC5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBsb2NhdGlvbi5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAvLyBEb24ndCBhbGxvdyByZWRpcmVjdGluZzpcclxuICAgICAgICAvLyAtIG5vbi1HRVQgcmVxdWVzdHNcclxuICAgICAgICAvLyAtIGRvd25ncmFkaW5nIHRoZSBzZWN1cml0eSAoZS5nLiBodHRwcyA9PiBodHRwKVxyXG4gICAgICAgIC8vIC0gdG8gbm9uLUhUVFAgKG9yIG5vbi1IVFRQUykgcHJvdG9jb2xzIFt0aGlzIGNvdWxkIGJlIHJlbGF4ZWQ/XVxyXG4gICAgICAgIGFzc2VydCh0aGlzLm1ldGhvZCA9PT0gXCJHRVRcIiAmJiAoY3VycmVudCAhPT0gXCJodHRwc1wiIHx8IHRhcmdldCAhPT0gXCJodHRwXCIpICYmIGxvY2F0aW9uLm1hdGNoKC9eaHR0cHM/Oi8pLCBgdW5zdXBwb3J0ZWQgcmVkaXJlY3RgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogYHJlZGlyZWN0KCR7dGhpcy5tZXRob2R9ICR7SlNPTi5zdHJpbmdpZnkodGhpcy51cmwpfSA9PiAke0pTT04uc3RyaW5naWZ5KGxvY2F0aW9uKX0pYFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyByZXF1ZXN0LCB3aXRoIGEgbmV3IFVSTFxyXG4gICAgICAgIGNvbnN0IHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QobG9jYXRpb24pO1xyXG4gICAgICAgIHJlcS5tZXRob2QgPSBcIkdFVFwiO1xyXG4gICAgICAgIHJlcS5hbGxvd0d6aXAgPSB0aGlzLmFsbG93R3ppcDtcclxuICAgICAgICByZXEudGltZW91dCA9IHRoaXMudGltZW91dDtcclxuICAgICAgICByZXEuI2hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTtcclxuICAgICAgICBpZiAodGhpcy4jYm9keSkge1xyXG4gICAgICAgICAgICByZXEuI2JvZHkgPSBuZXcgVWludDhBcnJheSh0aGlzLiNib2R5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVxLiNib2R5VHlwZSA9IHRoaXMuI2JvZHlUeXBlO1xyXG4gICAgICAgIC8vIERvIG5vdCBmb3J3YXJkIGNyZWRlbnRpYWxzIHVubGVzcyBvbiB0aGUgc2FtZSBkb21haW47IG9ubHkgYWJzb2x1dGVcclxuICAgICAgICAvL3JlcS5hbGxvd0luc2VjdXJlID0gZmFsc2U7XHJcbiAgICAgICAgLy8gcGF0aHMgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWQ7IG1heSB3YW50IGEgd2F5IHRvIHNwZWNpZnkgdG8gZm9yd2FyZD9cclxuICAgICAgICAvL3NldFN0b3JlKHJlcS4jcHJvcHMsIFwiY3JlZHNcIiwgZ2V0U3RvcmUodGhpcy4jcHJvcywgXCJjcmVkc1wiKSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZSBhIG5ldyBjb3B5IG9mIHRoaXMgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgRmV0Y2hSZXF1ZXN0KHRoaXMudXJsKTtcclxuICAgICAgICAvLyBQcmVzZXJ2ZSBcImRlZmF1bHQgbWV0aG9kXCIgKGkuZS4gbnVsbClcclxuICAgICAgICBjbG9uZS4jbWV0aG9kID0gdGhpcy4jbWV0aG9kO1xyXG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBib2R5XCIgd2l0aCB0eXBlLCBjb3B5aW5nIHRoZSBVaW50OEFycmF5IGlzIHByZXNlbnRcclxuICAgICAgICBpZiAodGhpcy4jYm9keSkge1xyXG4gICAgICAgICAgICBjbG9uZS4jYm9keSA9IHRoaXMuI2JvZHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsb25lLiNib2R5VHlwZSA9IHRoaXMuI2JvZHlUeXBlO1xyXG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBoZWFkZXJzXCJcclxuICAgICAgICBjbG9uZS4jaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpO1xyXG4gICAgICAgIC8vIENyZWRlbnRpYWxzIGlzIHJlYWRvbmx5LCBzbyB3ZSBjb3B5IGludGVybmFsbHlcclxuICAgICAgICBjbG9uZS4jY3JlZHMgPSB0aGlzLiNjcmVkcztcclxuICAgICAgICBpZiAodGhpcy5hbGxvd0d6aXApIHtcclxuICAgICAgICAgICAgY2xvbmUuYWxsb3dHemlwID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xvbmUudGltZW91dCA9IHRoaXMudGltZW91dDtcclxuICAgICAgICBpZiAodGhpcy5hbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24pIHtcclxuICAgICAgICAgICAgY2xvbmUuYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xvbmUuI3ByZWZsaWdodCA9IHRoaXMuI3ByZWZsaWdodDtcclxuICAgICAgICBjbG9uZS4jcHJvY2VzcyA9IHRoaXMuI3Byb2Nlc3M7XHJcbiAgICAgICAgY2xvbmUuI3JldHJ5ID0gdGhpcy4jcmV0cnk7XHJcbiAgICAgICAgY2xvbmUuI3Rocm90dGxlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jdGhyb3R0bGUpO1xyXG4gICAgICAgIGNsb25lLiNnZXRVcmxGdW5jID0gdGhpcy4jZ2V0VXJsRnVuYztcclxuICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBMb2NrcyBhbGwgc3RhdGljIGNvbmZpZ3VyYXRpb24gZm9yIGdhdGV3YXlzIGFuZCBGZXRjaEdldFVybEZ1bmNcclxuICAgICAqICByZWdpc3RyYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBsb2NrQ29uZmlnKCkge1xyXG4gICAgICAgIGxvY2tlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBHZXQgdGhlIGN1cnJlbnQgR2F0ZXdheSBmdW5jdGlvbiBmb3IgJSVzY2hlbWUlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEdhdGV3YXkoc2NoZW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIEdhdGV3YXlzW3NjaGVtZS50b0xvd2VyQ2FzZSgpXSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVXNlIHRoZSAlJWZ1bmMlJSB3aGVuIGZldGNoaW5nIFVSSXMgdXNpbmcgJSVzY2hlbWUlJS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBtZXRob2QgYWZmZWN0cyBhbGwgcmVxdWVzdHMgZ2xvYmFsbHkuXHJcbiAgICAgKlxyXG4gICAgICogIElmIFtbbG9ja0NvbmZpZ11dIGhhcyBiZWVuIGNhbGxlZCwgbm8gY2hhbmdlIGlzIG1hZGUgYW5kIHRoaXNcclxuICAgICAqICB0aHJvd3MuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyByZWdpc3RlckdhdGV3YXkoc2NoZW1lLCBmdW5jKSB7XHJcbiAgICAgICAgc2NoZW1lID0gc2NoZW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJodHRwXCIgfHwgc2NoZW1lID09PSBcImh0dHBzXCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgaW50ZXJjZXB0ICR7c2NoZW1lfTsgdXNlIHJlZ2lzdGVyR2V0VXJsYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsb2NrZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2F0ZXdheXMgbG9ja2VkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBHYXRld2F5c1tzY2hlbWVdID0gZnVuYztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFVzZSAlJWdldFVybCUlIHdoZW4gZmV0Y2hpbmcgVVJJcyBvdmVyIEhUVFAgYW5kIEhUVFBTIHJlcXVlc3RzLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIG1ldGhvZCBhZmZlY3RzIGFsbCByZXF1ZXN0cyBnbG9iYWxseS5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgW1tsb2NrQ29uZmlnXV0gaGFzIGJlZW4gY2FsbGVkLCBubyBjaGFuZ2UgaXMgbWFkZSBhbmQgdGhpc1xyXG4gICAgICogIHRocm93cy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHJlZ2lzdGVyR2V0VXJsKGdldFVybCkge1xyXG4gICAgICAgIGlmIChsb2NrZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2F0ZXdheXMgbG9ja2VkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0R2V0VXJsRnVuYyA9IGdldFVybDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBnZXRVcmwgZnVuY3Rpb24gdGhhdCBmZXRjaGVzIGNvbnRlbnQgZnJvbSBIVFRQIGFuZFxyXG4gICAgICogIEhUVFBTIFVSTHMuXHJcbiAgICAgKlxyXG4gICAgICogIFRoZSBhdmFpbGFibGUgJSVvcHRpb25zJSUgYXJlIGRlcGVuZGVudCBvbiB0aGUgcGxhdGZvcm1cclxuICAgICAqICBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgZGVmYXVsdCBnZXRVcmwgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgaXMgbm90IGdlbmVyYWxseSBzb21ldGhpbmcgdGhhdCBpcyBuZWVkZWQsIGJ1dCBpcyB1c2VmdWxcclxuICAgICAqICB3aGVuIHRyeWluZyB0byBjdXN0b21pemUgc2ltcGxlIGJlaGF2aW91ciB3aGVuIGZldGNoaW5nIEhUVFBcclxuICAgICAqICBjb250ZW50LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlR2V0VXJsRnVuYyhvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUdldFVybChvcHRpb25zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBcImZldGNoXCIgZGF0YSBVUklzLlxyXG4gICAgICpcclxuICAgICAqICBOb3RlIHRoYXQgdGhpcyBpcyBhdXRvbWF0aWNhbGx5IGRvbmUgaW50ZXJuYWxseSB0byBzdXBwb3J0XHJcbiAgICAgKiAgZGF0YSBVUklzLCBzbyBpdCBpcyBub3QgbmVjZXNzYXJ5IHRvIHJlZ2lzdGVyIGl0LlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIG5vdCBnZW5lcmFsbHkgc29tZXRoaW5nIHRoYXQgaXMgbmVlZGVkLCBidXQgbWF5XHJcbiAgICAgKiAgYmUgdXNlZnVsIGluIGEgd3JhcHBlciB0byBwZXJmb20gY3VzdG9tIGRhdGEgVVJJIGZ1bmN0aW9uYWxpdHkuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVEYXRhR2F0ZXdheSgpIHtcclxuICAgICAgICByZXR1cm4gZGF0YUdhdGV3YXlGdW5jO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBmZXRjaCBJUEZTICh1bnZhbGlkYXRlZCkgZnJvbVxyXG4gICAgICogIGEgY3VzdG9tIGdhdGV3YXkgYmFzZVVybC5cclxuICAgICAqXHJcbiAgICAgKiAgVGhlIGRlZmF1bHQgSVBGUyBnYXRld2F5IHVzZWQgaW50ZXJuYWxseSBpc1xyXG4gICAgICogIGBgXCJodHRwczovXFwvZ2F0ZXdheS5pcGZzLmlvL2lwZnMvXCJgYC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUlwZnNHYXRld2F5RnVuYyhiYXNlVXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldElwZnNHYXRld2F5RnVuYyhiYXNlVXJsKTtcclxuICAgIH1cclxufVxyXG47XHJcbi8qKlxyXG4gKiAgVGhlIHJlc3BvbnNlIGZvciBhIEZldGNoUmVxdWVzdC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBGZXRjaFJlc3BvbnNlIHtcclxuICAgICNzdGF0dXNDb2RlO1xyXG4gICAgI3N0YXR1c01lc3NhZ2U7XHJcbiAgICAjaGVhZGVycztcclxuICAgICNib2R5O1xyXG4gICAgI3JlcXVlc3Q7XHJcbiAgICAjZXJyb3I7XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gYDxGZXRjaFJlc3BvbnNlIHN0YXR1cz0ke3RoaXMuc3RhdHVzQ29kZX0gYm9keT0ke3RoaXMuI2JvZHkgPyBoZXhsaWZ5KHRoaXMuI2JvZHkpIDogXCJudWxsXCJ9PmA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgcmVzcG9uc2Ugc3RhdHVzIGNvZGUuXHJcbiAgICAgKi9cclxuICAgIGdldCBzdGF0dXNDb2RlKCkgeyByZXR1cm4gdGhpcy4jc3RhdHVzQ29kZTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHJlc3BvbnNlIHN0YXR1cyBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICBnZXQgc3RhdHVzTWVzc2FnZSgpIHsgcmV0dXJuIHRoaXMuI3N0YXR1c01lc3NhZ2U7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSByZXNwb25zZSBoZWFkZXJzLiBBbGwga2V5cyBhcmUgbG93ZXItY2FzZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGhlYWRlcnMoKSB7IHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHJlc3BvbnNlIGJvZHksIG9yIGBgbnVsbGBgIGlmIHRoZXJlIHdhcyBubyBib2R5LlxyXG4gICAgICovXHJcbiAgICBnZXQgYm9keSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgPT0gbnVsbCkgPyBudWxsIDogbmV3IFVpbnQ4QXJyYXkodGhpcy4jYm9keSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgcmVzcG9uc2UgYm9keSBhcyBhIFVURi04IGVuY29kZWQgc3RyaW5nLCBvciB0aGUgZW1wdHlcclxuICAgICAqICBzdHJpbmcgKGkuZS4gYGBcIlwiYGApIGlmIHRoZXJlIHdhcyBubyBib2R5LlxyXG4gICAgICpcclxuICAgICAqICBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIGJvZHkgaXMgaW52YWxpZCBVVEYtOCBkYXRhLlxyXG4gICAgICovXHJcbiAgICBnZXQgYm9keVRleHQoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ID09IG51bGwpID8gXCJcIiA6IHRvVXRmOFN0cmluZyh0aGlzLiNib2R5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJyZXNwb25zZSBib2R5IGlzIG5vdCB2YWxpZCBVVEYtOCBkYXRhXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJib2R5VGV4dFwiLCBpbmZvOiB7IHJlc3BvbnNlOiB0aGlzIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHJlc3BvbnNlIGJvZHksIGRlY29kZWQgYXMgSlNPTi5cclxuICAgICAqXHJcbiAgICAgKiAgQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBib2R5IGlzIGludmFsaWQgSlNPTi1lbmNvZGVkIGRhdGFcclxuICAgICAqICBvciBpZiB0aGVyZSB3YXMgbm8gYm9keS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGJvZHlKc29uKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuYm9keVRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInJlc3BvbnNlIGJvZHkgaXMgbm90IHZhbGlkIEpTT05cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImJvZHlKc29uXCIsIGluZm86IHsgcmVzcG9uc2U6IHRoaXMgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5oZWFkZXJzO1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKTtcclxuICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpbmRleCsrXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW2tleSwgaGVhZGVyc1trZXldXSwgZG9uZTogZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMsIGJvZHksIHJlcXVlc3QpIHtcclxuICAgICAgICB0aGlzLiNzdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcclxuICAgICAgICB0aGlzLiNzdGF0dXNNZXNzYWdlID0gc3RhdHVzTWVzc2FnZTtcclxuICAgICAgICB0aGlzLiNoZWFkZXJzID0gT2JqZWN0LmtleXMoaGVhZGVycykucmVkdWNlKChhY2N1bSwgaykgPT4ge1xyXG4gICAgICAgICAgICBhY2N1bVtrLnRvTG93ZXJDYXNlKCldID0gU3RyaW5nKGhlYWRlcnNba10pO1xyXG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XHJcbiAgICAgICAgfSwge30pO1xyXG4gICAgICAgIHRoaXMuI2JvZHkgPSAoKGJvZHkgPT0gbnVsbCkgPyBudWxsIDogbmV3IFVpbnQ4QXJyYXkoYm9keSkpO1xyXG4gICAgICAgIHRoaXMuI3JlcXVlc3QgPSAocmVxdWVzdCB8fCBudWxsKTtcclxuICAgICAgICB0aGlzLiNlcnJvciA9IHsgbWVzc2FnZTogXCJcIiB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgUmVzcG9uc2Ugd2l0aCBtYXRjaGluZyBoZWFkZXJzIGFuZCBib2R5LCBidXQgd2l0aFxyXG4gICAgICogIGFuIGVycm9yIHN0YXR1cyBjb2RlIChpLmUuIDU5OSkgYW5kICUlbWVzc2FnZSUlIHdpdGggYW5cclxuICAgICAqICBvcHRpb25hbCAlJWVycm9yJSUuXHJcbiAgICAgKi9cclxuICAgIG1ha2VTZXJ2ZXJFcnJvcihtZXNzYWdlLCBlcnJvcikge1xyXG4gICAgICAgIGxldCBzdGF0dXNNZXNzYWdlO1xyXG4gICAgICAgIGlmICghbWVzc2FnZSkge1xyXG4gICAgICAgICAgICBtZXNzYWdlID0gYCR7dGhpcy5zdGF0dXNDb2RlfSAke3RoaXMuc3RhdHVzTWVzc2FnZX1gO1xyXG4gICAgICAgICAgICBzdGF0dXNNZXNzYWdlID0gYENMSUVOVCBFU0NBTEFURUQgU0VSVkVSIEVSUk9SICgke21lc3NhZ2V9KWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdGF0dXNNZXNzYWdlID0gYENMSUVOVCBFU0NBTEFURUQgU0VSVkVSIEVSUk9SICgke3RoaXMuc3RhdHVzQ29kZX0gJHt0aGlzLnN0YXR1c01lc3NhZ2V9OyAke21lc3NhZ2V9KWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IEZldGNoUmVzcG9uc2UoNTk5LCBzdGF0dXNNZXNzYWdlLCB0aGlzLmhlYWRlcnMsIHRoaXMuYm9keSwgdGhpcy4jcmVxdWVzdCB8fCB1bmRlZmluZWQpO1xyXG4gICAgICAgIHJlc3BvbnNlLiNlcnJvciA9IHsgbWVzc2FnZSwgZXJyb3IgfTtcclxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBJZiBjYWxsZWQgd2l0aGluIGEgW3JlcXVlc3QucHJvY2Vzc0Z1bmNdKEZldGNoUmVxdWVzdC1wcm9jZXNzRnVuYylcclxuICAgICAqICBjYWxsLCBjYXVzZXMgdGhlIHJlcXVlc3QgdG8gcmV0cnkgYXMgaWYgdGhyb3R0bGVkIGZvciAlJXN0YWxsJSVcclxuICAgICAqICBtaWxsaXNlY29uZHMuXHJcbiAgICAgKi9cclxuICAgIHRocm93VGhyb3R0bGVFcnJvcihtZXNzYWdlLCBzdGFsbCkge1xyXG4gICAgICAgIGlmIChzdGFsbCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0YWxsID0gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChOdW1iZXIuaXNJbnRlZ2VyKHN0YWxsKSAmJiBzdGFsbCA+PSAwLCBcImludmFsaWQgc3RhbGwgdGltZW91dFwiLCBcInN0YWxsXCIsIHN0YWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSB8fCBcInRocm90dGxpbmcgcmVxdWVzdHNcIik7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhlcnJvciwgeyBzdGFsbCwgdGhyb3R0bGU6IHRydWUgfSk7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBHZXQgdGhlIGhlYWRlciB2YWx1ZSBmb3IgJSVrZXklJSwgaWdub3JpbmcgY2FzZS5cclxuICAgICAqL1xyXG4gICAgZ2V0SGVhZGVyKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSByZXNwb25zZSBoYXMgYSBib2R5LlxyXG4gICAgICovXHJcbiAgICBoYXNCb2R5KCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy4jYm9keSAhPSBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSByZXF1ZXN0IG1hZGUgZm9yIHRoaXMgcmVzcG9uc2UuXHJcbiAgICAgKi9cclxuICAgIGdldCByZXF1ZXN0KCkgeyByZXR1cm4gdGhpcy4jcmVxdWVzdDsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgcmVzcG9uc2Ugd2FzIGEgc3VjY2VzcyBzdGF0dXNDb2RlLlxyXG4gICAgICovXHJcbiAgICBvaygpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuI2Vycm9yLm1lc3NhZ2UgPT09IFwiXCIgJiYgdGhpcy5zdGF0dXNDb2RlID49IDIwMCAmJiB0aGlzLnN0YXR1c0NvZGUgPCAzMDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhyb3dzIGEgYGBTRVJWRVJfRVJST1JgYCBpZiB0aGlzIHJlc3BvbnNlIGlzIG5vdCBvay5cclxuICAgICAqL1xyXG4gICAgYXNzZXJ0T2soKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub2soKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB7IG1lc3NhZ2UsIGVycm9yIH0gPSB0aGlzLiNlcnJvcjtcclxuICAgICAgICBpZiAobWVzc2FnZSA9PT0gXCJcIikge1xyXG4gICAgICAgICAgICBtZXNzYWdlID0gYHNlcnZlciByZXNwb25zZSAke3RoaXMuc3RhdHVzQ29kZX0gJHt0aGlzLnN0YXR1c01lc3NhZ2V9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlcXVlc3RVcmwgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3QpIHtcclxuICAgICAgICAgICAgcmVxdWVzdFVybCA9IHRoaXMucmVxdWVzdC51cmw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXNwb25zZUJvZHkgPSBudWxsO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLiNib2R5KSB7XHJcbiAgICAgICAgICAgICAgICByZXNwb25zZUJvZHkgPSB0b1V0ZjhTdHJpbmcodGhpcy4jYm9keSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgIGFzc2VydChmYWxzZSwgbWVzc2FnZSwgXCJTRVJWRVJfRVJST1JcIiwge1xyXG4gICAgICAgICAgICByZXF1ZXN0OiAodGhpcy5yZXF1ZXN0IHx8IFwidW5rbm93biByZXF1ZXN0XCIpLCByZXNwb25zZTogdGhpcywgZXJyb3IsXHJcbiAgICAgICAgICAgIGluZm86IHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RVcmwsIHJlc3BvbnNlQm9keSxcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlU3RhdHVzOiBgJHt0aGlzLnN0YXR1c0NvZGV9ICR7dGhpcy5zdGF0dXNNZXNzYWdlfWBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFRpbWUoKSB7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpOyB9XHJcbmZ1bmN0aW9uIHVucGVyY2VudCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRvVXRmOEJ5dGVzKHZhbHVlLnJlcGxhY2UoLyUoWzAtOWEtZl1bMC05YS1mXSkvZ2ksIChhbGwsIGNvZGUpID0+IHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChjb2RlLCAxNikpO1xyXG4gICAgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIHdhaXQoZGVsYXkpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/fetch.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/fixednumber.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/fixednumber.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedNumber: () => (/* binding */ FixedNumber)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./properties.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\r\n *  The **FixedNumber** class permits using values with decimal places,\r\n *  using fixed-pont math.\r\n *\r\n *  Fixed-point math is still based on integers under-the-hood, but uses an\r\n *  internal offset to store fractional components below, and each operation\r\n *  corrects for this after each operation.\r\n *\r\n *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]\r\n */\r\n\r\n\r\n\r\n\r\nconst BN_N1 = BigInt(-1);\r\nconst BN_0 = BigInt(0);\r\nconst BN_1 = BigInt(1);\r\nconst BN_5 = BigInt(5);\r\nconst _guard = {};\r\n// Constant to pull zeros from for multipliers\r\nlet Zeros = \"0000\";\r\nwhile (Zeros.length < 80) {\r\n    Zeros += Zeros;\r\n}\r\n// Returns a string \"1\" followed by decimal \"0\"s\r\nfunction getTens(decimals) {\r\n    let result = Zeros;\r\n    while (result.length < decimals) {\r\n        result += result;\r\n    }\r\n    return BigInt(\"1\" + result.substring(0, decimals));\r\n}\r\nfunction checkValue(val, format, safeOp) {\r\n    const width = BigInt(format.width);\r\n    if (format.signed) {\r\n        const limit = (BN_1 << (width - BN_1));\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(safeOp == null || (val >= -limit && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\r\n            operation: safeOp, fault: \"overflow\", value: val\r\n        });\r\n        if (val > BN_0) {\r\n            val = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)((0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.mask)(val, width), width);\r\n        }\r\n        else {\r\n            val = -(0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)((0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.mask)(-val, width), width);\r\n        }\r\n    }\r\n    else {\r\n        const limit = (BN_1 << width);\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(safeOp == null || (val >= 0 && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\r\n            operation: safeOp, fault: \"overflow\", value: val\r\n        });\r\n        val = (((val % limit) + limit) % limit) & (limit - BN_1);\r\n    }\r\n    return val;\r\n}\r\nfunction getFormat(value) {\r\n    if (typeof (value) === \"number\") {\r\n        value = `fixed128x${value}`;\r\n    }\r\n    let signed = true;\r\n    let width = 128;\r\n    let decimals = 18;\r\n    if (typeof (value) === \"string\") {\r\n        // Parse the format string\r\n        if (value === \"fixed\") {\r\n            // defaults...\r\n        }\r\n        else if (value === \"ufixed\") {\r\n            signed = false;\r\n        }\r\n        else {\r\n            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\r\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match, \"invalid fixed format\", \"format\", value);\r\n            signed = (match[1] !== \"u\");\r\n            width = parseInt(match[2]);\r\n            decimals = parseInt(match[3]);\r\n        }\r\n    }\r\n    else if (value) {\r\n        // Extract the values from the object\r\n        const v = value;\r\n        const check = (key, type, defaultValue) => {\r\n            if (v[key] == null) {\r\n                return defaultValue;\r\n            }\r\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (v[key]) === type, \"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, v[key]);\r\n            return v[key];\r\n        };\r\n        signed = check(\"signed\", \"boolean\", signed);\r\n        width = check(\"width\", \"number\", width);\r\n        decimals = check(\"decimals\", \"number\", decimals);\r\n    }\r\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((width % 8) === 0, \"invalid FixedNumber width (not byte aligned)\", \"format.width\", width);\r\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(decimals <= 80, \"invalid FixedNumber decimals (too large)\", \"format.decimals\", decimals);\r\n    const name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\r\n    return { signed, width, decimals, name };\r\n}\r\nfunction toString(val, decimals) {\r\n    let negative = \"\";\r\n    if (val < BN_0) {\r\n        negative = \"-\";\r\n        val *= BN_N1;\r\n    }\r\n    let str = val.toString();\r\n    // No decimal point for whole values\r\n    if (decimals === 0) {\r\n        return (negative + str);\r\n    }\r\n    // Pad out to the whole component (including a whole digit)\r\n    while (str.length <= decimals) {\r\n        str = Zeros + str;\r\n    }\r\n    // Insert the decimal point\r\n    const index = str.length - decimals;\r\n    str = str.substring(0, index) + \".\" + str.substring(index);\r\n    // Trim the whole component (leaving at least one 0)\r\n    while (str[0] === \"0\" && str[1] !== \".\") {\r\n        str = str.substring(1);\r\n    }\r\n    // Trim the decimal component (leaving at least one 0)\r\n    while (str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\") {\r\n        str = str.substring(0, str.length - 1);\r\n    }\r\n    return (negative + str);\r\n}\r\n/**\r\n *  A FixedNumber represents a value over its [[FixedFormat]]\r\n *  arithmetic field.\r\n *\r\n *  A FixedNumber can be used to perform math, losslessly, on\r\n *  values which have decmial places.\r\n *\r\n *  A FixedNumber has a fixed bit-width to store values in, and stores all\r\n *  values internally by multiplying the value by 10 raised to the power of\r\n *  %%decimals%%.\r\n *\r\n *  If operations are performed that cause a value to grow too high (close to\r\n *  positive infinity) or too low (close to negative infinity), the value\r\n *  is said to //overflow//.\r\n *\r\n *  For example, an 8-bit signed value, with 0 decimals may only be within\r\n *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\r\n *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\r\n *\r\n *  Many operation have a normal and //unsafe// variant. The normal variant\r\n *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//\r\n *  variant will silently allow overflow, corrupting its value value.\r\n *\r\n *  If operations are performed that cause a value to become too small\r\n *  (close to zero), the value loses precison and is said to //underflow//.\r\n *\r\n *  For example, a value with 1 decimal place may store a number as small\r\n *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\r\n *  into 1 decimal place, so underflow occurs which means precision is lost\r\n *  and the value becomes ``0``.\r\n *\r\n *  Some operations have a normal and //signalling// variant. The normal\r\n *  variant will silently ignore underflow, while the //signalling// variant\r\n *  will thow a [[NumericFaultError]] on underflow.\r\n */\r\nclass FixedNumber {\r\n    /**\r\n     *  The specific fixed-point arithmetic field for this value.\r\n     */\r\n    format;\r\n    #format;\r\n    // The actual value (accounting for decimals)\r\n    #val;\r\n    // A base-10 value to multiple values by to maintain the magnitude\r\n    #tens;\r\n    /**\r\n     *  This is a property so console.log shows a human-meaningful value.\r\n     *\r\n     *  @private\r\n     */\r\n    _value;\r\n    // Use this when changing this file to get some typing info,\r\n    // but then switch to any to mask the internal type\r\n    //constructor(guard: any, value: bigint, format: _FixedFormat) {\r\n    /**\r\n     *  @private\r\n     */\r\n    constructor(guard, value, format) {\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"FixedNumber\");\r\n        this.#val = value;\r\n        this.#format = format;\r\n        const _value = toString(value, format.decimals);\r\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, { format: format.name, _value });\r\n        this.#tens = getTens(format.decimals);\r\n    }\r\n    /**\r\n     *  If true, negative values are permitted, otherwise only\r\n     *  positive values and zero are allowed.\r\n     */\r\n    get signed() { return this.#format.signed; }\r\n    /**\r\n     *  The number of bits available to store the value.\r\n     */\r\n    get width() { return this.#format.width; }\r\n    /**\r\n     *  The number of decimal places in the fixed-point arithment field.\r\n     */\r\n    get decimals() { return this.#format.decimals; }\r\n    /**\r\n     *  The value as an integer, based on the smallest unit the\r\n     *  [[decimals]] allow.\r\n     */\r\n    get value() { return this.#val; }\r\n    #checkFormat(other) {\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(this.format === other.format, \"incompatible format; use fixedNumber.toFormat\", \"other\", other);\r\n    }\r\n    #checkValue(val, safeOp) {\r\n        /*\r\n                const width = BigInt(this.width);\r\n                if (this.signed) {\r\n                    const limit = (BN_1 << (width - BN_1));\r\n                    assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\r\n                        operation: <string>safeOp, fault: \"overflow\", value: val\r\n                    });\r\n        \r\n                    if (val > BN_0) {\r\n                        val = fromTwos(mask(val, width), width);\r\n                    } else {\r\n                        val = -fromTwos(mask(-val, width), width);\r\n                    }\r\n        \r\n                } else {\r\n                    const masked = mask(val, width);\r\n                    assert(safeOp == null || (val >= 0 && val === masked), \"overflow\", \"NUMERIC_FAULT\", {\r\n                        operation: <string>safeOp, fault: \"overflow\", value: val\r\n                    });\r\n                    val = masked;\r\n                }\r\n        */\r\n        val = checkValue(val, this.#format, safeOp);\r\n        return new FixedNumber(_guard, val, this.#format);\r\n    }\r\n    #add(o, safeOp) {\r\n        this.#checkFormat(o);\r\n        return this.#checkValue(this.#val + o.#val, safeOp);\r\n    }\r\n    /**\r\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\r\n     *  to %%other%%, ignoring overflow.\r\n     */\r\n    addUnsafe(other) { return this.#add(other); }\r\n    /**\r\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\r\n     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow\r\n     *  occurs.\r\n     */\r\n    add(other) { return this.#add(other, \"add\"); }\r\n    #sub(o, safeOp) {\r\n        this.#checkFormat(o);\r\n        return this.#checkValue(this.#val - o.#val, safeOp);\r\n    }\r\n    /**\r\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\r\n     *  from %%this%%, ignoring overflow.\r\n     */\r\n    subUnsafe(other) { return this.#sub(other); }\r\n    /**\r\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\r\n     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow\r\n     *  occurs.\r\n     */\r\n    sub(other) { return this.#sub(other, \"sub\"); }\r\n    #mul(o, safeOp) {\r\n        this.#checkFormat(o);\r\n        return this.#checkValue((this.#val * o.#val) / this.#tens, safeOp);\r\n    }\r\n    /**\r\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\r\n     *  by %%other%%, ignoring overflow and underflow (precision loss).\r\n     */\r\n    mulUnsafe(other) { return this.#mul(other); }\r\n    /**\r\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\r\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\r\n     *  occurs.\r\n     */\r\n    mul(other) { return this.#mul(other, \"mul\"); }\r\n    /**\r\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\r\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\r\n     *  occurs or if underflow (precision loss) occurs.\r\n     */\r\n    mulSignal(other) {\r\n        this.#checkFormat(other);\r\n        const value = this.#val * other.#val;\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)((value % this.#tens) === BN_0, \"precision lost during signalling mul\", \"NUMERIC_FAULT\", {\r\n            operation: \"mulSignal\", fault: \"underflow\", value: this\r\n        });\r\n        return this.#checkValue(value / this.#tens, \"mulSignal\");\r\n    }\r\n    #div(o, safeOp) {\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(o.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\r\n            operation: \"div\", fault: \"divide-by-zero\", value: this\r\n        });\r\n        this.#checkFormat(o);\r\n        return this.#checkValue((this.#val * this.#tens) / o.#val, safeOp);\r\n    }\r\n    /**\r\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\r\n     *  by %%other%%, ignoring underflow (precision loss). A\r\n     *  [[NumericFaultError]] is thrown if overflow occurs.\r\n     */\r\n    divUnsafe(other) { return this.#div(other); }\r\n    /**\r\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\r\n     *  by %%other%%, ignoring underflow (precision loss). A\r\n     *  [[NumericFaultError]] is thrown if overflow occurs.\r\n     */\r\n    div(other) { return this.#div(other, \"div\"); }\r\n    /**\r\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\r\n     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow\r\n     *  (precision loss) occurs.\r\n     */\r\n    divSignal(other) {\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(other.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\r\n            operation: \"div\", fault: \"divide-by-zero\", value: this\r\n        });\r\n        this.#checkFormat(other);\r\n        const value = (this.#val * this.#tens);\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)((value % other.#val) === BN_0, \"precision lost during signalling div\", \"NUMERIC_FAULT\", {\r\n            operation: \"divSignal\", fault: \"underflow\", value: this\r\n        });\r\n        return this.#checkValue(value / other.#val, \"divSignal\");\r\n    }\r\n    /**\r\n     *  Returns a comparison result between %%this%% and %%other%%.\r\n     *\r\n     *  This is suitable for use in sorting, where ``-1`` implies %%this%%\r\n     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies\r\n     *  both are equal.\r\n     */\r\n    cmp(other) {\r\n        let a = this.value, b = other.value;\r\n        // Coerce a and b to the same magnitude\r\n        const delta = this.decimals - other.decimals;\r\n        if (delta > 0) {\r\n            b *= getTens(delta);\r\n        }\r\n        else if (delta < 0) {\r\n            a *= getTens(-delta);\r\n        }\r\n        // Comnpare\r\n        if (a < b) {\r\n            return -1;\r\n        }\r\n        if (a > b) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    }\r\n    /**\r\n     *  Returns true if %%other%% is equal to %%this%%.\r\n     */\r\n    eq(other) { return this.cmp(other) === 0; }\r\n    /**\r\n     *  Returns true if %%other%% is less than to %%this%%.\r\n     */\r\n    lt(other) { return this.cmp(other) < 0; }\r\n    /**\r\n     *  Returns true if %%other%% is less than or equal to %%this%%.\r\n     */\r\n    lte(other) { return this.cmp(other) <= 0; }\r\n    /**\r\n     *  Returns true if %%other%% is greater than to %%this%%.\r\n     */\r\n    gt(other) { return this.cmp(other) > 0; }\r\n    /**\r\n     *  Returns true if %%other%% is greater than or equal to %%this%%.\r\n     */\r\n    gte(other) { return this.cmp(other) >= 0; }\r\n    /**\r\n     *  Returns a new [[FixedNumber]] which is the largest **integer**\r\n     *  that is less than or equal to %%this%%.\r\n     *\r\n     *  The decimal component of the result will always be ``0``.\r\n     */\r\n    floor() {\r\n        let val = this.#val;\r\n        if (this.#val < BN_0) {\r\n            val -= this.#tens - BN_1;\r\n        }\r\n        val = (this.#val / this.#tens) * this.#tens;\r\n        return this.#checkValue(val, \"floor\");\r\n    }\r\n    /**\r\n     *  Returns a new [[FixedNumber]] which is the smallest **integer**\r\n     *  that is greater than or equal to %%this%%.\r\n     *\r\n     *  The decimal component of the result will always be ``0``.\r\n     */\r\n    ceiling() {\r\n        let val = this.#val;\r\n        if (this.#val > BN_0) {\r\n            val += this.#tens - BN_1;\r\n        }\r\n        val = (this.#val / this.#tens) * this.#tens;\r\n        return this.#checkValue(val, \"ceiling\");\r\n    }\r\n    /**\r\n     *  Returns a new [[FixedNumber]] with the decimal component\r\n     *  rounded up on ties at %%decimals%% places.\r\n     */\r\n    round(decimals) {\r\n        if (decimals == null) {\r\n            decimals = 0;\r\n        }\r\n        // Not enough precision to not already be rounded\r\n        if (decimals >= this.decimals) {\r\n            return this;\r\n        }\r\n        const delta = this.decimals - decimals;\r\n        const bump = BN_5 * getTens(delta - 1);\r\n        let value = this.value + bump;\r\n        const tens = getTens(delta);\r\n        value = (value / tens) * tens;\r\n        checkValue(value, this.#format, \"round\");\r\n        return new FixedNumber(_guard, value, this.#format);\r\n    }\r\n    /**\r\n     *  Returns true if %%this%% is equal to ``0``.\r\n     */\r\n    isZero() { return (this.#val === BN_0); }\r\n    /**\r\n     *  Returns true if %%this%% is less than ``0``.\r\n     */\r\n    isNegative() { return (this.#val < BN_0); }\r\n    /**\r\n     *  Returns the string representation of %%this%%.\r\n     */\r\n    toString() { return this._value; }\r\n    /**\r\n     *  Returns a float approximation.\r\n     *\r\n     *  Due to IEEE 754 precission (or lack thereof), this function\r\n     *  can only return an approximation and most values will contain\r\n     *  rounding errors.\r\n     */\r\n    toUnsafeFloat() { return parseFloat(this.toString()); }\r\n    /**\r\n     *  Return a new [[FixedNumber]] with the same value but has had\r\n     *  its field set to %%format%%.\r\n     *\r\n     *  This will throw if the value cannot fit into %%format%%.\r\n     */\r\n    toFormat(format) {\r\n        return FixedNumber.fromString(this.toString(), format);\r\n    }\r\n    /**\r\n     *  Creates a new [[FixedNumber]] for %%value%% divided by\r\n     *  %%decimal%% places with %%format%%.\r\n     *\r\n     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted\r\n     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow\r\n     *  or underflow (precision loss).\r\n     */\r\n    static fromValue(_value, _decimals, _format) {\r\n        const decimals = (_decimals == null) ? 0 : (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(_decimals);\r\n        const format = getFormat(_format);\r\n        let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"value\");\r\n        const delta = decimals - format.decimals;\r\n        if (delta > 0) {\r\n            const tens = getTens(delta);\r\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)((value % tens) === BN_0, \"value loses precision for format\", \"NUMERIC_FAULT\", {\r\n                operation: \"fromValue\", fault: \"underflow\", value: _value\r\n            });\r\n            value /= tens;\r\n        }\r\n        else if (delta < 0) {\r\n            value *= getTens(-delta);\r\n        }\r\n        checkValue(value, format, \"fromValue\");\r\n        return new FixedNumber(_guard, value, format);\r\n    }\r\n    /**\r\n     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.\r\n     *\r\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\r\n     *  in %%format%%, either due to overflow or underflow (precision loss).\r\n     */\r\n    static fromString(_value, _format) {\r\n        const match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match && (match[2].length + match[3].length) > 0, \"invalid FixedNumber string value\", \"value\", _value);\r\n        const format = getFormat(_format);\r\n        let whole = (match[2] || \"0\"), decimal = (match[3] || \"\");\r\n        // Pad out the decimals\r\n        while (decimal.length < format.decimals) {\r\n            decimal += Zeros;\r\n        }\r\n        // Check precision is safe\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(decimal.substring(format.decimals).match(/^0*$/), \"too many decimals for format\", \"NUMERIC_FAULT\", {\r\n            operation: \"fromString\", fault: \"underflow\", value: _value\r\n        });\r\n        // Remove extra padding\r\n        decimal = decimal.substring(0, format.decimals);\r\n        const value = BigInt(match[1] + whole + decimal);\r\n        checkValue(value, format, \"fromString\");\r\n        return new FixedNumber(_guard, value, format);\r\n    }\r\n    /**\r\n     *  Creates a new [[FixedNumber]] with the big-endian representation\r\n     *  %%value%% with %%format%%.\r\n     *\r\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\r\n     *  in %%format%% due to overflow.\r\n     */\r\n    static fromBytes(_value, _format) {\r\n        let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt)((0,_data_js__WEBPACK_IMPORTED_MODULE_3__.getBytes)(_value, \"value\"));\r\n        const format = getFormat(_format);\r\n        if (format.signed) {\r\n            value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)(value, format.width);\r\n        }\r\n        checkValue(value, format, \"fromBytes\");\r\n        return new FixedNumber(_guard, value, format);\r\n    }\r\n}\r\n//const f1 = FixedNumber.fromString(\"12.56\", \"fixed16x2\");\r\n//const f2 = FixedNumber.fromString(\"0.3\", \"fixed16x2\");\r\n//console.log(f1.divSignal(f2));\r\n//const BUMP = FixedNumber.from(\"0.5\");\r\n//# sourceMappingURL=fixednumber.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9maXhlZG51bWJlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FDO0FBQytCO0FBQ1E7QUFDekI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsbURBQVEsQ0FBQywrQ0FBSTtBQUMvQjtBQUNBO0FBQ0EsbUJBQW1CLG1EQUFRLENBQUMsK0NBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDBEQUFjO0FBQ2xCLElBQUksMERBQWM7QUFDbEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvREFBUztBQUM1RDtBQUNBLG9CQUFvQixvREFBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtEQUFNO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1EQUFRLENBQUMsa0RBQVE7QUFDckM7QUFDQTtBQUNBLG9CQUFvQixtREFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFx1dGlsc1xcZml4ZWRudW1iZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqICBUaGUgKipGaXhlZE51bWJlcioqIGNsYXNzIHBlcm1pdHMgdXNpbmcgdmFsdWVzIHdpdGggZGVjaW1hbCBwbGFjZXMsXHJcbiAqICB1c2luZyBmaXhlZC1wb250IG1hdGguXHJcbiAqXHJcbiAqICBGaXhlZC1wb2ludCBtYXRoIGlzIHN0aWxsIGJhc2VkIG9uIGludGVnZXJzIHVuZGVyLXRoZS1ob29kLCBidXQgdXNlcyBhblxyXG4gKiAgaW50ZXJuYWwgb2Zmc2V0IHRvIHN0b3JlIGZyYWN0aW9uYWwgY29tcG9uZW50cyBiZWxvdywgYW5kIGVhY2ggb3BlcmF0aW9uXHJcbiAqICBjb3JyZWN0cyBmb3IgdGhpcyBhZnRlciBlYWNoIG9wZXJhdGlvbi5cclxuICpcclxuICogIEBfc2VjdGlvbjogYXBpL3V0aWxzL2ZpeGVkLXBvaW50LW1hdGg6Rml4ZWQtUG9pbnQgTWF0aHMgIFthYm91dC1maXhlZC1wb2ludC1tYXRoXVxyXG4gKi9cclxuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XHJcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGFzc2VydFByaXZhdGUgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcclxuaW1wb3J0IHsgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGZyb21Ud29zLCBtYXNrLCB0b0JpZ0ludCB9IGZyb20gXCIuL21hdGhzLmpzXCI7XHJcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XHJcbmNvbnN0IEJOX04xID0gQmlnSW50KC0xKTtcclxuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcclxuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcclxuY29uc3QgQk5fNSA9IEJpZ0ludCg1KTtcclxuY29uc3QgX2d1YXJkID0ge307XHJcbi8vIENvbnN0YW50IHRvIHB1bGwgemVyb3MgZnJvbSBmb3IgbXVsdGlwbGllcnNcclxubGV0IFplcm9zID0gXCIwMDAwXCI7XHJcbndoaWxlIChaZXJvcy5sZW5ndGggPCA4MCkge1xyXG4gICAgWmVyb3MgKz0gWmVyb3M7XHJcbn1cclxuLy8gUmV0dXJucyBhIHN0cmluZyBcIjFcIiBmb2xsb3dlZCBieSBkZWNpbWFsIFwiMFwic1xyXG5mdW5jdGlvbiBnZXRUZW5zKGRlY2ltYWxzKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gWmVyb3M7XHJcbiAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IGRlY2ltYWxzKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJldHVybiBCaWdJbnQoXCIxXCIgKyByZXN1bHQuc3Vic3RyaW5nKDAsIGRlY2ltYWxzKSk7XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tWYWx1ZSh2YWwsIGZvcm1hdCwgc2FmZU9wKSB7XHJcbiAgICBjb25zdCB3aWR0aCA9IEJpZ0ludChmb3JtYXQud2lkdGgpO1xyXG4gICAgaWYgKGZvcm1hdC5zaWduZWQpIHtcclxuICAgICAgICBjb25zdCBsaW1pdCA9IChCTl8xIDw8ICh3aWR0aCAtIEJOXzEpKTtcclxuICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAtbGltaXQgJiYgdmFsIDwgbGltaXQpLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogc2FmZU9wLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogdmFsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHZhbCA+IEJOXzApIHtcclxuICAgICAgICAgICAgdmFsID0gZnJvbVR3b3MobWFzayh2YWwsIHdpZHRoKSwgd2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFsID0gLWZyb21Ud29zKG1hc2soLXZhbCwgd2lkdGgpLCB3aWR0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgbGltaXQgPSAoQk5fMSA8PCB3aWR0aCk7XHJcbiAgICAgICAgYXNzZXJ0KHNhZmVPcCA9PSBudWxsIHx8ICh2YWwgPj0gMCAmJiB2YWwgPCBsaW1pdCksIFwib3ZlcmZsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiBzYWZlT3AsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiB2YWxcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YWwgPSAoKCh2YWwgJSBsaW1pdCkgKyBsaW1pdCkgJSBsaW1pdCkgJiAobGltaXQgLSBCTl8xKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWw7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Rm9ybWF0KHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICB2YWx1ZSA9IGBmaXhlZDEyOHgke3ZhbHVlfWA7XHJcbiAgICB9XHJcbiAgICBsZXQgc2lnbmVkID0gdHJ1ZTtcclxuICAgIGxldCB3aWR0aCA9IDEyODtcclxuICAgIGxldCBkZWNpbWFscyA9IDE4O1xyXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgLy8gUGFyc2UgdGhlIGZvcm1hdCBzdHJpbmdcclxuICAgICAgICBpZiAodmFsdWUgPT09IFwiZml4ZWRcIikge1xyXG4gICAgICAgICAgICAvLyBkZWZhdWx0cy4uLlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gXCJ1Zml4ZWRcIikge1xyXG4gICAgICAgICAgICBzaWduZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdmFsdWUubWF0Y2goL14odT8pZml4ZWQoWzAtOV0rKXgoWzAtOV0rKSQvKTtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQobWF0Y2gsIFwiaW52YWxpZCBmaXhlZCBmb3JtYXRcIiwgXCJmb3JtYXRcIiwgdmFsdWUpO1xyXG4gICAgICAgICAgICBzaWduZWQgPSAobWF0Y2hbMV0gIT09IFwidVwiKTtcclxuICAgICAgICAgICAgd2lkdGggPSBwYXJzZUludChtYXRjaFsyXSk7XHJcbiAgICAgICAgICAgIGRlY2ltYWxzID0gcGFyc2VJbnQobWF0Y2hbM10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgdmFsdWVzIGZyb20gdGhlIG9iamVjdFxyXG4gICAgICAgIGNvbnN0IHYgPSB2YWx1ZTtcclxuICAgICAgICBjb25zdCBjaGVjayA9IChrZXksIHR5cGUsIGRlZmF1bHRWYWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodltrZXldID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2W2tleV0pID09PSB0eXBlLCBcImludmFsaWQgZml4ZWQgZm9ybWF0IChcIiArIGtleSArIFwiIG5vdCBcIiArIHR5cGUgKyBcIilcIiwgXCJmb3JtYXQuXCIgKyBrZXksIHZba2V5XSk7XHJcbiAgICAgICAgICAgIHJldHVybiB2W2tleV07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzaWduZWQgPSBjaGVjayhcInNpZ25lZFwiLCBcImJvb2xlYW5cIiwgc2lnbmVkKTtcclxuICAgICAgICB3aWR0aCA9IGNoZWNrKFwid2lkdGhcIiwgXCJudW1iZXJcIiwgd2lkdGgpO1xyXG4gICAgICAgIGRlY2ltYWxzID0gY2hlY2soXCJkZWNpbWFsc1wiLCBcIm51bWJlclwiLCBkZWNpbWFscyk7XHJcbiAgICB9XHJcbiAgICBhc3NlcnRBcmd1bWVudCgod2lkdGggJSA4KSA9PT0gMCwgXCJpbnZhbGlkIEZpeGVkTnVtYmVyIHdpZHRoIChub3QgYnl0ZSBhbGlnbmVkKVwiLCBcImZvcm1hdC53aWR0aFwiLCB3aWR0aCk7XHJcbiAgICBhc3NlcnRBcmd1bWVudChkZWNpbWFscyA8PSA4MCwgXCJpbnZhbGlkIEZpeGVkTnVtYmVyIGRlY2ltYWxzICh0b28gbGFyZ2UpXCIsIFwiZm9ybWF0LmRlY2ltYWxzXCIsIGRlY2ltYWxzKTtcclxuICAgIGNvbnN0IG5hbWUgPSAoc2lnbmVkID8gXCJcIiA6IFwidVwiKSArIFwiZml4ZWRcIiArIFN0cmluZyh3aWR0aCkgKyBcInhcIiArIFN0cmluZyhkZWNpbWFscyk7XHJcbiAgICByZXR1cm4geyBzaWduZWQsIHdpZHRoLCBkZWNpbWFscywgbmFtZSB9O1xyXG59XHJcbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbCwgZGVjaW1hbHMpIHtcclxuICAgIGxldCBuZWdhdGl2ZSA9IFwiXCI7XHJcbiAgICBpZiAodmFsIDwgQk5fMCkge1xyXG4gICAgICAgIG5lZ2F0aXZlID0gXCItXCI7XHJcbiAgICAgICAgdmFsICo9IEJOX04xO1xyXG4gICAgfVxyXG4gICAgbGV0IHN0ciA9IHZhbC50b1N0cmluZygpO1xyXG4gICAgLy8gTm8gZGVjaW1hbCBwb2ludCBmb3Igd2hvbGUgdmFsdWVzXHJcbiAgICBpZiAoZGVjaW1hbHMgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gKG5lZ2F0aXZlICsgc3RyKTtcclxuICAgIH1cclxuICAgIC8vIFBhZCBvdXQgdG8gdGhlIHdob2xlIGNvbXBvbmVudCAoaW5jbHVkaW5nIGEgd2hvbGUgZGlnaXQpXHJcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8PSBkZWNpbWFscykge1xyXG4gICAgICAgIHN0ciA9IFplcm9zICsgc3RyO1xyXG4gICAgfVxyXG4gICAgLy8gSW5zZXJ0IHRoZSBkZWNpbWFsIHBvaW50XHJcbiAgICBjb25zdCBpbmRleCA9IHN0ci5sZW5ndGggLSBkZWNpbWFscztcclxuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaW5kZXgpICsgXCIuXCIgKyBzdHIuc3Vic3RyaW5nKGluZGV4KTtcclxuICAgIC8vIFRyaW0gdGhlIHdob2xlIGNvbXBvbmVudCAobGVhdmluZyBhdCBsZWFzdCBvbmUgMClcclxuICAgIHdoaWxlIChzdHJbMF0gPT09IFwiMFwiICYmIHN0clsxXSAhPT0gXCIuXCIpIHtcclxuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDEpO1xyXG4gICAgfVxyXG4gICAgLy8gVHJpbSB0aGUgZGVjaW1hbCBjb21wb25lbnQgKGxlYXZpbmcgYXQgbGVhc3Qgb25lIDApXHJcbiAgICB3aGlsZSAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gXCIwXCIgJiYgc3RyW3N0ci5sZW5ndGggLSAyXSAhPT0gXCIuXCIpIHtcclxuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcclxuICAgIH1cclxuICAgIHJldHVybiAobmVnYXRpdmUgKyBzdHIpO1xyXG59XHJcbi8qKlxyXG4gKiAgQSBGaXhlZE51bWJlciByZXByZXNlbnRzIGEgdmFsdWUgb3ZlciBpdHMgW1tGaXhlZEZvcm1hdF1dXHJcbiAqICBhcml0aG1ldGljIGZpZWxkLlxyXG4gKlxyXG4gKiAgQSBGaXhlZE51bWJlciBjYW4gYmUgdXNlZCB0byBwZXJmb3JtIG1hdGgsIGxvc3NsZXNzbHksIG9uXHJcbiAqICB2YWx1ZXMgd2hpY2ggaGF2ZSBkZWNtaWFsIHBsYWNlcy5cclxuICpcclxuICogIEEgRml4ZWROdW1iZXIgaGFzIGEgZml4ZWQgYml0LXdpZHRoIHRvIHN0b3JlIHZhbHVlcyBpbiwgYW5kIHN0b3JlcyBhbGxcclxuICogIHZhbHVlcyBpbnRlcm5hbGx5IGJ5IG11bHRpcGx5aW5nIHRoZSB2YWx1ZSBieSAxMCByYWlzZWQgdG8gdGhlIHBvd2VyIG9mXHJcbiAqICAlJWRlY2ltYWxzJSUuXHJcbiAqXHJcbiAqICBJZiBvcGVyYXRpb25zIGFyZSBwZXJmb3JtZWQgdGhhdCBjYXVzZSBhIHZhbHVlIHRvIGdyb3cgdG9vIGhpZ2ggKGNsb3NlIHRvXHJcbiAqICBwb3NpdGl2ZSBpbmZpbml0eSkgb3IgdG9vIGxvdyAoY2xvc2UgdG8gbmVnYXRpdmUgaW5maW5pdHkpLCB0aGUgdmFsdWVcclxuICogIGlzIHNhaWQgdG8gLy9vdmVyZmxvdy8vLlxyXG4gKlxyXG4gKiAgRm9yIGV4YW1wbGUsIGFuIDgtYml0IHNpZ25lZCB2YWx1ZSwgd2l0aCAwIGRlY2ltYWxzIG1heSBvbmx5IGJlIHdpdGhpblxyXG4gKiAgdGhlIHJhbmdlIGBgLTEyOGBgIHRvIGBgMTI3YGA7IHNvIGBgLTEyOCAtIDFgYCB3aWxsIG92ZXJmbG93IGFuZCBiZWNvbWVcclxuICogIGBgMTI3YGAuIExpa2V3aXNlLCBgYDEyNyArIDFgYCB3aWxsIG92ZXJmbG93IGFuZCBiZWNvbWUgYGAtMTI3YGAuXHJcbiAqXHJcbiAqICBNYW55IG9wZXJhdGlvbiBoYXZlIGEgbm9ybWFsIGFuZCAvL3Vuc2FmZS8vIHZhcmlhbnQuIFRoZSBub3JtYWwgdmFyaWFudFxyXG4gKiAgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBvbiBhbnkgb3ZlcmZsb3csIHdoaWxlIHRoZSAvL3Vuc2FmZS8vXHJcbiAqICB2YXJpYW50IHdpbGwgc2lsZW50bHkgYWxsb3cgb3ZlcmZsb3csIGNvcnJ1cHRpbmcgaXRzIHZhbHVlIHZhbHVlLlxyXG4gKlxyXG4gKiAgSWYgb3BlcmF0aW9ucyBhcmUgcGVyZm9ybWVkIHRoYXQgY2F1c2UgYSB2YWx1ZSB0byBiZWNvbWUgdG9vIHNtYWxsXHJcbiAqICAoY2xvc2UgdG8gemVybyksIHRoZSB2YWx1ZSBsb3NlcyBwcmVjaXNvbiBhbmQgaXMgc2FpZCB0byAvL3VuZGVyZmxvdy8vLlxyXG4gKlxyXG4gKiAgRm9yIGV4YW1wbGUsIGEgdmFsdWUgd2l0aCAxIGRlY2ltYWwgcGxhY2UgbWF5IHN0b3JlIGEgbnVtYmVyIGFzIHNtYWxsXHJcbiAqICBhcyBgYDAuMWBgLCBidXQgdGhlIHZhbHVlIG9mIGBgMC4xIC8gMmBgIGlzIGBgMC4wNWBgLCB3aGljaCBjYW5ub3QgZml0XHJcbiAqICBpbnRvIDEgZGVjaW1hbCBwbGFjZSwgc28gdW5kZXJmbG93IG9jY3VycyB3aGljaCBtZWFucyBwcmVjaXNpb24gaXMgbG9zdFxyXG4gKiAgYW5kIHRoZSB2YWx1ZSBiZWNvbWVzIGBgMGBgLlxyXG4gKlxyXG4gKiAgU29tZSBvcGVyYXRpb25zIGhhdmUgYSBub3JtYWwgYW5kIC8vc2lnbmFsbGluZy8vIHZhcmlhbnQuIFRoZSBub3JtYWxcclxuICogIHZhcmlhbnQgd2lsbCBzaWxlbnRseSBpZ25vcmUgdW5kZXJmbG93LCB3aGlsZSB0aGUgLy9zaWduYWxsaW5nLy8gdmFyaWFudFxyXG4gKiAgd2lsbCB0aG93IGEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIG9uIHVuZGVyZmxvdy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBGaXhlZE51bWJlciB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgc3BlY2lmaWMgZml4ZWQtcG9pbnQgYXJpdGhtZXRpYyBmaWVsZCBmb3IgdGhpcyB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgZm9ybWF0O1xyXG4gICAgI2Zvcm1hdDtcclxuICAgIC8vIFRoZSBhY3R1YWwgdmFsdWUgKGFjY291bnRpbmcgZm9yIGRlY2ltYWxzKVxyXG4gICAgI3ZhbDtcclxuICAgIC8vIEEgYmFzZS0xMCB2YWx1ZSB0byBtdWx0aXBsZSB2YWx1ZXMgYnkgdG8gbWFpbnRhaW4gdGhlIG1hZ25pdHVkZVxyXG4gICAgI3RlbnM7XHJcbiAgICAvKipcclxuICAgICAqICBUaGlzIGlzIGEgcHJvcGVydHkgc28gY29uc29sZS5sb2cgc2hvd3MgYSBodW1hbi1tZWFuaW5nZnVsIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqICBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfdmFsdWU7XHJcbiAgICAvLyBVc2UgdGhpcyB3aGVuIGNoYW5naW5nIHRoaXMgZmlsZSB0byBnZXQgc29tZSB0eXBpbmcgaW5mbyxcclxuICAgIC8vIGJ1dCB0aGVuIHN3aXRjaCB0byBhbnkgdG8gbWFzayB0aGUgaW50ZXJuYWwgdHlwZVxyXG4gICAgLy9jb25zdHJ1Y3RvcihndWFyZDogYW55LCB2YWx1ZTogYmlnaW50LCBmb3JtYXQ6IF9GaXhlZEZvcm1hdCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHZhbHVlLCBmb3JtYXQpIHtcclxuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiRml4ZWROdW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy4jdmFsID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy4jZm9ybWF0ID0gZm9ybWF0O1xyXG4gICAgICAgIGNvbnN0IF92YWx1ZSA9IHRvU3RyaW5nKHZhbHVlLCBmb3JtYXQuZGVjaW1hbHMpO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBmb3JtYXQ6IGZvcm1hdC5uYW1lLCBfdmFsdWUgfSk7XHJcbiAgICAgICAgdGhpcy4jdGVucyA9IGdldFRlbnMoZm9ybWF0LmRlY2ltYWxzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIElmIHRydWUsIG5lZ2F0aXZlIHZhbHVlcyBhcmUgcGVybWl0dGVkLCBvdGhlcndpc2Ugb25seVxyXG4gICAgICogIHBvc2l0aXZlIHZhbHVlcyBhbmQgemVybyBhcmUgYWxsb3dlZC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHNpZ25lZCgpIHsgcmV0dXJuIHRoaXMuI2Zvcm1hdC5zaWduZWQ7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBudW1iZXIgb2YgYml0cyBhdmFpbGFibGUgdG8gc3RvcmUgdGhlIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLiNmb3JtYXQud2lkdGg7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgaW4gdGhlIGZpeGVkLXBvaW50IGFyaXRobWVudCBmaWVsZC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGRlY2ltYWxzKCkgeyByZXR1cm4gdGhpcy4jZm9ybWF0LmRlY2ltYWxzOyB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdmFsdWUgYXMgYW4gaW50ZWdlciwgYmFzZWQgb24gdGhlIHNtYWxsZXN0IHVuaXQgdGhlXHJcbiAgICAgKiAgW1tkZWNpbWFsc11dIGFsbG93LlxyXG4gICAgICovXHJcbiAgICBnZXQgdmFsdWUoKSB7IHJldHVybiB0aGlzLiN2YWw7IH1cclxuICAgICNjaGVja0Zvcm1hdChvdGhlcikge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHRoaXMuZm9ybWF0ID09PSBvdGhlci5mb3JtYXQsIFwiaW5jb21wYXRpYmxlIGZvcm1hdDsgdXNlIGZpeGVkTnVtYmVyLnRvRm9ybWF0XCIsIFwib3RoZXJcIiwgb3RoZXIpO1xyXG4gICAgfVxyXG4gICAgI2NoZWNrVmFsdWUodmFsLCBzYWZlT3ApIHtcclxuICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBCaWdJbnQodGhpcy53aWR0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW1pdCA9IChCTl8xIDw8ICh3aWR0aCAtIEJOXzEpKTtcclxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAtbGltaXQgICYmIHZhbCA8IGxpbWl0KSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IDxzdHJpbmc+c2FmZU9wLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogdmFsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA+IEJOXzApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gZnJvbVR3b3MobWFzayh2YWwsIHdpZHRoKSwgd2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IC1mcm9tVHdvcyhtYXNrKC12YWwsIHdpZHRoKSwgd2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFza2VkID0gbWFzayh2YWwsIHdpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAwICYmIHZhbCA9PT0gbWFza2VkKSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IDxzdHJpbmc+c2FmZU9wLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogdmFsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gbWFza2VkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICovXHJcbiAgICAgICAgdmFsID0gY2hlY2tWYWx1ZSh2YWwsIHRoaXMuI2Zvcm1hdCwgc2FmZU9wKTtcclxuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsLCB0aGlzLiNmb3JtYXQpO1xyXG4gICAgfVxyXG4gICAgI2FkZChvLCBzYWZlT3ApIHtcclxuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvKTtcclxuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSh0aGlzLiN2YWwgKyBvLiN2YWwsIHNhZmVPcCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgYWRkZWRcclxuICAgICAqICB0byAlJW90aGVyJSUsIGlnbm9yaW5nIG92ZXJmbG93LlxyXG4gICAgICovXHJcbiAgICBhZGRVbnNhZmUob3RoZXIpIHsgcmV0dXJuIHRoaXMuI2FkZChvdGhlcik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBhZGRlZFxyXG4gICAgICogIHRvICUlb3RoZXIlJS4gQSBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93XHJcbiAgICAgKiAgb2NjdXJzLlxyXG4gICAgICovXHJcbiAgICBhZGQob3RoZXIpIHsgcmV0dXJuIHRoaXMuI2FkZChvdGhlciwgXCJhZGRcIik7IH1cclxuICAgICNzdWIobywgc2FmZU9wKSB7XHJcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodGhpcy4jdmFsIC0gby4jdmFsLCBzYWZlT3ApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUlb3RoZXIlJSBzdWJ0cmFjdGVkXHJcbiAgICAgKiAgZnJvbSAlJXRoaXMlJSwgaWdub3Jpbmcgb3ZlcmZsb3cuXHJcbiAgICAgKi9cclxuICAgIHN1YlVuc2FmZShvdGhlcikgeyByZXR1cm4gdGhpcy4jc3ViKG90aGVyKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUlb3RoZXIlJSBzdWJ0cmFjdGVkXHJcbiAgICAgKiAgZnJvbSAlJXRoaXMlJS4gQSBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93XHJcbiAgICAgKiAgb2NjdXJzLlxyXG4gICAgICovXHJcbiAgICBzdWIob3RoZXIpIHsgcmV0dXJuIHRoaXMuI3N1YihvdGhlciwgXCJzdWJcIik7IH1cclxuICAgICNtdWwobywgc2FmZU9wKSB7XHJcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUoKHRoaXMuI3ZhbCAqIG8uI3ZhbCkgLyB0aGlzLiN0ZW5zLCBzYWZlT3ApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIG11bHRpcGxpZWRcclxuICAgICAqICBieSAlJW90aGVyJSUsIGlnbm9yaW5nIG92ZXJmbG93IGFuZCB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS5cclxuICAgICAqL1xyXG4gICAgbXVsVW5zYWZlKG90aGVyKSB7IHJldHVybiB0aGlzLiNtdWwob3RoZXIpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgbXVsdGlwbGllZFxyXG4gICAgICogIGJ5ICUlb3RoZXIlJS4gQSBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93XHJcbiAgICAgKiAgb2NjdXJzLlxyXG4gICAgICovXHJcbiAgICBtdWwob3RoZXIpIHsgcmV0dXJuIHRoaXMuI211bChvdGhlciwgXCJtdWxcIik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBtdWx0aXBsaWVkXHJcbiAgICAgKiAgYnkgJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcclxuICAgICAqICBvY2N1cnMgb3IgaWYgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykgb2NjdXJzLlxyXG4gICAgICovXHJcbiAgICBtdWxTaWduYWwob3RoZXIpIHtcclxuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvdGhlcik7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2YWwgKiBvdGhlci4jdmFsO1xyXG4gICAgICAgIGFzc2VydCgodmFsdWUgJSB0aGlzLiN0ZW5zKSA9PT0gQk5fMCwgXCJwcmVjaXNpb24gbG9zdCBkdXJpbmcgc2lnbmFsbGluZyBtdWxcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm11bFNpZ25hbFwiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IHRoaXNcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSh2YWx1ZSAvIHRoaXMuI3RlbnMsIFwibXVsU2lnbmFsXCIpO1xyXG4gICAgfVxyXG4gICAgI2RpdihvLCBzYWZlT3ApIHtcclxuICAgICAgICBhc3NlcnQoby4jdmFsICE9PSBCTl8wLCBcImRpdmlzaW9uIGJ5IHplcm9cIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRpdlwiLCBmYXVsdDogXCJkaXZpZGUtYnktemVyb1wiLCB2YWx1ZTogdGhpc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKCh0aGlzLiN2YWwgKiB0aGlzLiN0ZW5zKSAvIG8uI3ZhbCwgc2FmZU9wKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBkaXZpZGVkXHJcbiAgICAgKiAgYnkgJSVvdGhlciUlLCBpZ25vcmluZyB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS4gQVxyXG4gICAgICogIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3cgb2NjdXJzLlxyXG4gICAgICovXHJcbiAgICBkaXZVbnNhZmUob3RoZXIpIHsgcmV0dXJuIHRoaXMuI2RpdihvdGhlcik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBkaXZpZGVkXHJcbiAgICAgKiAgYnkgJSVvdGhlciUlLCBpZ25vcmluZyB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS4gQVxyXG4gICAgICogIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3cgb2NjdXJzLlxyXG4gICAgICovXHJcbiAgICBkaXYob3RoZXIpIHsgcmV0dXJuIHRoaXMuI2RpdihvdGhlciwgXCJkaXZcIik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBkaXZpZGVkXHJcbiAgICAgKiAgYnkgJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgdW5kZXJmbG93XHJcbiAgICAgKiAgKHByZWNpc2lvbiBsb3NzKSBvY2N1cnMuXHJcbiAgICAgKi9cclxuICAgIGRpdlNpZ25hbChvdGhlcikge1xyXG4gICAgICAgIGFzc2VydChvdGhlci4jdmFsICE9PSBCTl8wLCBcImRpdmlzaW9uIGJ5IHplcm9cIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRpdlwiLCBmYXVsdDogXCJkaXZpZGUtYnktemVyb1wiLCB2YWx1ZTogdGhpc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG90aGVyKTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9ICh0aGlzLiN2YWwgKiB0aGlzLiN0ZW5zKTtcclxuICAgICAgICBhc3NlcnQoKHZhbHVlICUgb3RoZXIuI3ZhbCkgPT09IEJOXzAsIFwicHJlY2lzaW9uIGxvc3QgZHVyaW5nIHNpZ25hbGxpbmcgZGl2XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJkaXZTaWduYWxcIiwgZmF1bHQ6IFwidW5kZXJmbG93XCIsIHZhbHVlOiB0aGlzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsdWUgLyBvdGhlci4jdmFsLCBcImRpdlNpZ25hbFwiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBjb21wYXJpc29uIHJlc3VsdCBiZXR3ZWVuICUldGhpcyUlIGFuZCAlJW90aGVyJSUuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgaXMgc3VpdGFibGUgZm9yIHVzZSBpbiBzb3J0aW5nLCB3aGVyZSBgYC0xYGAgaW1wbGllcyAlJXRoaXMlJVxyXG4gICAgICogIGlzIHNtYWxsZXIsIGBgMWBgIGltcGxpZXMgJSV0aGlzJSUgaXMgbGFyZ2VyIGFuZCBgYDBgYCBpbXBsaWVzXHJcbiAgICAgKiAgYm90aCBhcmUgZXF1YWwuXHJcbiAgICAgKi9cclxuICAgIGNtcChvdGhlcikge1xyXG4gICAgICAgIGxldCBhID0gdGhpcy52YWx1ZSwgYiA9IG90aGVyLnZhbHVlO1xyXG4gICAgICAgIC8vIENvZXJjZSBhIGFuZCBiIHRvIHRoZSBzYW1lIG1hZ25pdHVkZVxyXG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5kZWNpbWFscyAtIG90aGVyLmRlY2ltYWxzO1xyXG4gICAgICAgIGlmIChkZWx0YSA+IDApIHtcclxuICAgICAgICAgICAgYiAqPSBnZXRUZW5zKGRlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGVsdGEgPCAwKSB7XHJcbiAgICAgICAgICAgIGEgKj0gZ2V0VGVucygtZGVsdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb21ucGFyZVxyXG4gICAgICAgIGlmIChhIDwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhID4gYikge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGVxdWFsIHRvICUldGhpcyUlLlxyXG4gICAgICovXHJcbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy5jbXAob3RoZXIpID09PSAwOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGxlc3MgdGhhbiB0byAlJXRoaXMlJS5cclxuICAgICAqL1xyXG4gICAgbHQob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA8IDA7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxyXG4gICAgICovXHJcbiAgICBsdGUob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA8PSAwOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGdyZWF0ZXIgdGhhbiB0byAlJXRoaXMlJS5cclxuICAgICAqL1xyXG4gICAgZ3Qob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA+IDA7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxyXG4gICAgICovXHJcbiAgICBndGUob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA+PSAwOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aGljaCBpcyB0aGUgbGFyZ2VzdCAqKmludGVnZXIqKlxyXG4gICAgICogIHRoYXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxyXG4gICAgICpcclxuICAgICAqICBUaGUgZGVjaW1hbCBjb21wb25lbnQgb2YgdGhlIHJlc3VsdCB3aWxsIGFsd2F5cyBiZSBgYDBgYC5cclxuICAgICAqL1xyXG4gICAgZmxvb3IoKSB7XHJcbiAgICAgICAgbGV0IHZhbCA9IHRoaXMuI3ZhbDtcclxuICAgICAgICBpZiAodGhpcy4jdmFsIDwgQk5fMCkge1xyXG4gICAgICAgICAgICB2YWwgLT0gdGhpcy4jdGVucyAtIEJOXzE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbCA9ICh0aGlzLiN2YWwgLyB0aGlzLiN0ZW5zKSAqIHRoaXMuI3RlbnM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsLCBcImZsb29yXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2hpY2ggaXMgdGhlIHNtYWxsZXN0ICoqaW50ZWdlcioqXHJcbiAgICAgKiAgdGhhdCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJSV0aGlzJSUuXHJcbiAgICAgKlxyXG4gICAgICogIFRoZSBkZWNpbWFsIGNvbXBvbmVudCBvZiB0aGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGBgMGBgLlxyXG4gICAgICovXHJcbiAgICBjZWlsaW5nKCkge1xyXG4gICAgICAgIGxldCB2YWwgPSB0aGlzLiN2YWw7XHJcbiAgICAgICAgaWYgKHRoaXMuI3ZhbCA+IEJOXzApIHtcclxuICAgICAgICAgICAgdmFsICs9IHRoaXMuI3RlbnMgLSBCTl8xO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWwgPSAodGhpcy4jdmFsIC8gdGhpcy4jdGVucykgKiB0aGlzLiN0ZW5zO1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbCwgXCJjZWlsaW5nXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgZGVjaW1hbCBjb21wb25lbnRcclxuICAgICAqICByb3VuZGVkIHVwIG9uIHRpZXMgYXQgJSVkZWNpbWFscyUlIHBsYWNlcy5cclxuICAgICAqL1xyXG4gICAgcm91bmQoZGVjaW1hbHMpIHtcclxuICAgICAgICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkZWNpbWFscyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vdCBlbm91Z2ggcHJlY2lzaW9uIHRvIG5vdCBhbHJlYWR5IGJlIHJvdW5kZWRcclxuICAgICAgICBpZiAoZGVjaW1hbHMgPj0gdGhpcy5kZWNpbWFscykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLmRlY2ltYWxzIC0gZGVjaW1hbHM7XHJcbiAgICAgICAgY29uc3QgYnVtcCA9IEJOXzUgKiBnZXRUZW5zKGRlbHRhIC0gMSk7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy52YWx1ZSArIGJ1bXA7XHJcbiAgICAgICAgY29uc3QgdGVucyA9IGdldFRlbnMoZGVsdGEpO1xyXG4gICAgICAgIHZhbHVlID0gKHZhbHVlIC8gdGVucykgKiB0ZW5zO1xyXG4gICAgICAgIGNoZWNrVmFsdWUodmFsdWUsIHRoaXMuI2Zvcm1hdCwgXCJyb3VuZFwiKTtcclxuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsdWUsIHRoaXMuI2Zvcm1hdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgZXF1YWwgdG8gYGAwYGAuXHJcbiAgICAgKi9cclxuICAgIGlzWmVybygpIHsgcmV0dXJuICh0aGlzLiN2YWwgPT09IEJOXzApOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgbGVzcyB0aGFuIGBgMGBgLlxyXG4gICAgICovXHJcbiAgICBpc05lZ2F0aXZlKCkgeyByZXR1cm4gKHRoaXMuI3ZhbCA8IEJOXzApOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgJSV0aGlzJSUuXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBmbG9hdCBhcHByb3hpbWF0aW9uLlxyXG4gICAgICpcclxuICAgICAqICBEdWUgdG8gSUVFRSA3NTQgcHJlY2lzc2lvbiAob3IgbGFjayB0aGVyZW9mKSwgdGhpcyBmdW5jdGlvblxyXG4gICAgICogIGNhbiBvbmx5IHJldHVybiBhbiBhcHByb3hpbWF0aW9uIGFuZCBtb3N0IHZhbHVlcyB3aWxsIGNvbnRhaW5cclxuICAgICAqICByb3VuZGluZyBlcnJvcnMuXHJcbiAgICAgKi9cclxuICAgIHRvVW5zYWZlRmxvYXQoKSB7IHJldHVybiBwYXJzZUZsb2F0KHRoaXMudG9TdHJpbmcoKSk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgc2FtZSB2YWx1ZSBidXQgaGFzIGhhZFxyXG4gICAgICogIGl0cyBmaWVsZCBzZXQgdG8gJSVmb3JtYXQlJS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIHRoZSB2YWx1ZSBjYW5ub3QgZml0IGludG8gJSVmb3JtYXQlJS5cclxuICAgICAqL1xyXG4gICAgdG9Gb3JtYXQoZm9ybWF0KSB7XHJcbiAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcodGhpcy50b1N0cmluZygpLCBmb3JtYXQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gZm9yICUldmFsdWUlJSBkaXZpZGVkIGJ5XHJcbiAgICAgKiAgJSVkZWNpbWFsJSUgcGxhY2VzIHdpdGggJSVmb3JtYXQlJS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlmICUldmFsdWUlJSAob25jZSBhZGp1c3RlZFxyXG4gICAgICogIGZvciAlJWRlY2ltYWxzJSUpIGNhbm5vdCBmaXQgaW4gJSVmb3JtYXQlJSwgZWl0aGVyIGR1ZSB0byBvdmVyZmxvd1xyXG4gICAgICogIG9yIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVZhbHVlKF92YWx1ZSwgX2RlY2ltYWxzLCBfZm9ybWF0KSB7XHJcbiAgICAgICAgY29uc3QgZGVjaW1hbHMgPSAoX2RlY2ltYWxzID09IG51bGwpID8gMCA6IGdldE51bWJlcihfZGVjaW1hbHMpO1xyXG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGdldEZvcm1hdChfZm9ybWF0KTtcclxuICAgICAgICBsZXQgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xyXG4gICAgICAgIGNvbnN0IGRlbHRhID0gZGVjaW1hbHMgLSBmb3JtYXQuZGVjaW1hbHM7XHJcbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCB0ZW5zID0gZ2V0VGVucyhkZWx0YSk7XHJcbiAgICAgICAgICAgIGFzc2VydCgodmFsdWUgJSB0ZW5zKSA9PT0gQk5fMCwgXCJ2YWx1ZSBsb3NlcyBwcmVjaXNpb24gZm9yIGZvcm1hdFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyb21WYWx1ZVwiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFsdWUgLz0gdGVucztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGVsdGEgPCAwKSB7XHJcbiAgICAgICAgICAgIHZhbHVlICo9IGdldFRlbnMoLWRlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2hlY2tWYWx1ZSh2YWx1ZSwgZm9ybWF0LCBcImZyb21WYWx1ZVwiKTtcclxuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsdWUsIGZvcm1hdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbRml4ZWROdW1iZXJdXSBmb3IgJSV2YWx1ZSUlIHdpdGggJSVmb3JtYXQlJS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlmICUldmFsdWUlJSBjYW5ub3QgZml0XHJcbiAgICAgKiAgaW4gJSVmb3JtYXQlJSwgZWl0aGVyIGR1ZSB0byBvdmVyZmxvdyBvciB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21TdHJpbmcoX3ZhbHVlLCBfZm9ybWF0KSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBfdmFsdWUubWF0Y2goL14oLT8pKFswLTldKilcXC4/KFswLTldKikkLyk7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQobWF0Y2ggJiYgKG1hdGNoWzJdLmxlbmd0aCArIG1hdGNoWzNdLmxlbmd0aCkgPiAwLCBcImludmFsaWQgRml4ZWROdW1iZXIgc3RyaW5nIHZhbHVlXCIsIFwidmFsdWVcIiwgX3ZhbHVlKTtcclxuICAgICAgICBjb25zdCBmb3JtYXQgPSBnZXRGb3JtYXQoX2Zvcm1hdCk7XHJcbiAgICAgICAgbGV0IHdob2xlID0gKG1hdGNoWzJdIHx8IFwiMFwiKSwgZGVjaW1hbCA9IChtYXRjaFszXSB8fCBcIlwiKTtcclxuICAgICAgICAvLyBQYWQgb3V0IHRoZSBkZWNpbWFsc1xyXG4gICAgICAgIHdoaWxlIChkZWNpbWFsLmxlbmd0aCA8IGZvcm1hdC5kZWNpbWFscykge1xyXG4gICAgICAgICAgICBkZWNpbWFsICs9IFplcm9zO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayBwcmVjaXNpb24gaXMgc2FmZVxyXG4gICAgICAgIGFzc2VydChkZWNpbWFsLnN1YnN0cmluZyhmb3JtYXQuZGVjaW1hbHMpLm1hdGNoKC9eMCokLyksIFwidG9vIG1hbnkgZGVjaW1hbHMgZm9yIGZvcm1hdFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xyXG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZnJvbVN0cmluZ1wiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFJlbW92ZSBleHRyYSBwYWRkaW5nXHJcbiAgICAgICAgZGVjaW1hbCA9IGRlY2ltYWwuc3Vic3RyaW5nKDAsIGZvcm1hdC5kZWNpbWFscyk7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBCaWdJbnQobWF0Y2hbMV0gKyB3aG9sZSArIGRlY2ltYWwpO1xyXG4gICAgICAgIGNoZWNrVmFsdWUodmFsdWUsIGZvcm1hdCwgXCJmcm9tU3RyaW5nXCIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2d1YXJkLCB2YWx1ZSwgZm9ybWF0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIGJpZy1lbmRpYW4gcmVwcmVzZW50YXRpb25cclxuICAgICAqICAlJXZhbHVlJSUgd2l0aCAlJWZvcm1hdCUlLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gaWYgJSV2YWx1ZSUlIGNhbm5vdCBmaXRcclxuICAgICAqICBpbiAlJWZvcm1hdCUlIGR1ZSB0byBvdmVyZmxvdy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21CeXRlcyhfdmFsdWUsIF9mb3JtYXQpIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSB0b0JpZ0ludChnZXRCeXRlcyhfdmFsdWUsIFwidmFsdWVcIikpO1xyXG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGdldEZvcm1hdChfZm9ybWF0KTtcclxuICAgICAgICBpZiAoZm9ybWF0LnNpZ25lZCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGZyb21Ud29zKHZhbHVlLCBmb3JtYXQud2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCBmb3JtYXQsIFwiZnJvbUJ5dGVzXCIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2d1YXJkLCB2YWx1ZSwgZm9ybWF0KTtcclxuICAgIH1cclxufVxyXG4vL2NvbnN0IGYxID0gRml4ZWROdW1iZXIuZnJvbVN0cmluZyhcIjEyLjU2XCIsIFwiZml4ZWQxNngyXCIpO1xyXG4vL2NvbnN0IGYyID0gRml4ZWROdW1iZXIuZnJvbVN0cmluZyhcIjAuM1wiLCBcImZpeGVkMTZ4MlwiKTtcclxuLy9jb25zb2xlLmxvZyhmMS5kaXZTaWduYWwoZjIpKTtcclxuLy9jb25zdCBCVU1QID0gRml4ZWROdW1iZXIuZnJvbShcIjAuNVwiKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml4ZWRudW1iZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/fixednumber.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/geturl-browser.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/geturl-browser.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGetUrl: () => (/* binding */ createGetUrl),\n/* harmony export */   getUrl: () => (/* binding */ getUrl)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n\r\nfunction createGetUrl(options) {\r\n    async function getUrl(req, _signal) {\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(_signal == null || !_signal.cancelled, \"request cancelled before sending\", \"CANCELLED\");\r\n        const protocol = req.url.split(\":\")[0].toLowerCase();\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(protocol === \"http\" || protocol === \"https\", `unsupported protocol ${protocol}`, \"UNSUPPORTED_OPERATION\", {\r\n            info: { protocol },\r\n            operation: \"request\"\r\n        });\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(protocol === \"https\" || !req.credentials || req.allowInsecureAuthentication, \"insecure authorized connections unsupported\", \"UNSUPPORTED_OPERATION\", {\r\n            operation: \"request\"\r\n        });\r\n        let error = null;\r\n        const controller = new AbortController();\r\n        const timer = setTimeout(() => {\r\n            error = (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(\"request timeout\", \"TIMEOUT\");\r\n            controller.abort();\r\n        }, req.timeout);\r\n        if (_signal) {\r\n            _signal.addListener(() => {\r\n                error = (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(\"request cancelled\", \"CANCELLED\");\r\n                controller.abort();\r\n            });\r\n        }\r\n        const init = Object.assign({}, options, {\r\n            method: req.method,\r\n            headers: new Headers(Array.from(req)),\r\n            body: req.body || undefined,\r\n            signal: controller.signal\r\n        });\r\n        let resp;\r\n        try {\r\n            resp = await fetch(req.url, init);\r\n        }\r\n        catch (_error) {\r\n            clearTimeout(timer);\r\n            if (error) {\r\n                throw error;\r\n            }\r\n            throw _error;\r\n        }\r\n        clearTimeout(timer);\r\n        const headers = {};\r\n        resp.headers.forEach((value, key) => {\r\n            headers[key.toLowerCase()] = value;\r\n        });\r\n        const respBody = await resp.arrayBuffer();\r\n        const body = (respBody == null) ? null : new Uint8Array(respBody);\r\n        return {\r\n            statusCode: resp.status,\r\n            statusMessage: resp.statusText,\r\n            headers, body\r\n        };\r\n    }\r\n    return getUrl;\r\n}\r\n// @TODO: remove in v7; provided for backwards compat\r\nconst defaultGetUrl = createGetUrl({});\r\nasync function getUrl(req, _signal) {\r\n    return defaultGetUrl(req, _signal);\r\n}\r\n//# sourceMappingURL=geturl-browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9nZXR1cmwtYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0Q7QUFDekM7QUFDUDtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBLFFBQVEsa0RBQU0sc0VBQXNFLFNBQVM7QUFDN0Ysb0JBQW9CLFVBQVU7QUFDOUI7QUFDQSxTQUFTO0FBQ1QsUUFBUSxrREFBTTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBUztBQUM3QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFTO0FBQ2pDO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixxQ0FBcUM7QUFDOUI7QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcdXRpbHNcXGdldHVybC1icm93c2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2VydCwgbWFrZUVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVHZXRVcmwob3B0aW9ucykge1xyXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0VXJsKHJlcSwgX3NpZ25hbCkge1xyXG4gICAgICAgIGFzc2VydChfc2lnbmFsID09IG51bGwgfHwgIV9zaWduYWwuY2FuY2VsbGVkLCBcInJlcXVlc3QgY2FuY2VsbGVkIGJlZm9yZSBzZW5kaW5nXCIsIFwiQ0FOQ0VMTEVEXCIpO1xyXG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gcmVxLnVybC5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBhc3NlcnQocHJvdG9jb2wgPT09IFwiaHR0cFwiIHx8IHByb3RvY29sID09PSBcImh0dHBzXCIsIGB1bnN1cHBvcnRlZCBwcm90b2NvbCAke3Byb3RvY29sfWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgaW5mbzogeyBwcm90b2NvbCB9LFxyXG4gICAgICAgICAgICBvcGVyYXRpb246IFwicmVxdWVzdFwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYXNzZXJ0KHByb3RvY29sID09PSBcImh0dHBzXCIgfHwgIXJlcS5jcmVkZW50aWFscyB8fCByZXEuYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uLCBcImluc2VjdXJlIGF1dGhvcml6ZWQgY29ubmVjdGlvbnMgdW5zdXBwb3J0ZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICBvcGVyYXRpb246IFwicmVxdWVzdFwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IGVycm9yID0gbnVsbDtcclxuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGVycm9yID0gbWFrZUVycm9yKFwicmVxdWVzdCB0aW1lb3V0XCIsIFwiVElNRU9VVFwiKTtcclxuICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xyXG4gICAgICAgIH0sIHJlcS50aW1lb3V0KTtcclxuICAgICAgICBpZiAoX3NpZ25hbCkge1xyXG4gICAgICAgICAgICBfc2lnbmFsLmFkZExpc3RlbmVyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGVycm9yID0gbWFrZUVycm9yKFwicmVxdWVzdCBjYW5jZWxsZWRcIiwgXCJDQU5DRUxMRURcIik7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbml0ID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xyXG4gICAgICAgICAgICBtZXRob2Q6IHJlcS5tZXRob2QsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKEFycmF5LmZyb20ocmVxKSksXHJcbiAgICAgICAgICAgIGJvZHk6IHJlcS5ib2R5IHx8IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCByZXNwO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3AgPSBhd2FpdCBmZXRjaChyZXEudXJsLCBpbml0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IF9lcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XHJcbiAgICAgICAgcmVzcC5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCByZXNwQm9keSA9IGF3YWl0IHJlc3AuYXJyYXlCdWZmZXIoKTtcclxuICAgICAgICBjb25zdCBib2R5ID0gKHJlc3BCb2R5ID09IG51bGwpID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KHJlc3BCb2R5KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwLnN0YXR1cyxcclxuICAgICAgICAgICAgc3RhdHVzTWVzc2FnZTogcmVzcC5zdGF0dXNUZXh0LFxyXG4gICAgICAgICAgICBoZWFkZXJzLCBib2R5XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBnZXRVcmw7XHJcbn1cclxuLy8gQFRPRE86IHJlbW92ZSBpbiB2NzsgcHJvdmlkZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRcclxuY29uc3QgZGVmYXVsdEdldFVybCA9IGNyZWF0ZUdldFVybCh7fSk7XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVcmwocmVxLCBfc2lnbmFsKSB7XHJcbiAgICByZXR1cm4gZGVmYXVsdEdldFVybChyZXEsIF9zaWduYWwpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldHVybC1icm93c2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/geturl-browser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventPayload: () => (/* reexport safe */ _events_js__WEBPACK_IMPORTED_MODULE_4__.EventPayload),\n/* harmony export */   FetchCancelSignal: () => (/* reexport safe */ _fetch_js__WEBPACK_IMPORTED_MODULE_5__.FetchCancelSignal),\n/* harmony export */   FetchRequest: () => (/* reexport safe */ _fetch_js__WEBPACK_IMPORTED_MODULE_5__.FetchRequest),\n/* harmony export */   FetchResponse: () => (/* reexport safe */ _fetch_js__WEBPACK_IMPORTED_MODULE_5__.FetchResponse),\n/* harmony export */   FixedNumber: () => (/* reexport safe */ _fixednumber_js__WEBPACK_IMPORTED_MODULE_6__.FixedNumber),\n/* harmony export */   Utf8ErrorFuncs: () => (/* reexport safe */ _utf8_js__WEBPACK_IMPORTED_MODULE_12__.Utf8ErrorFuncs),\n/* harmony export */   assert: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_3__.assert),\n/* harmony export */   assertArgument: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument),\n/* harmony export */   assertArgumentCount: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_3__.assertArgumentCount),\n/* harmony export */   assertNormalize: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_3__.assertNormalize),\n/* harmony export */   assertPrivate: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_3__.assertPrivate),\n/* harmony export */   concat: () => (/* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.concat),\n/* harmony export */   dataLength: () => (/* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.dataLength),\n/* harmony export */   dataSlice: () => (/* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.dataSlice),\n/* harmony export */   decodeBase58: () => (/* reexport safe */ _base58_js__WEBPACK_IMPORTED_MODULE_0__.decodeBase58),\n/* harmony export */   decodeBase64: () => (/* reexport safe */ _base64_js__WEBPACK_IMPORTED_MODULE_1__.decodeBase64),\n/* harmony export */   decodeRlp: () => (/* reexport safe */ _rlp_decode_js__WEBPACK_IMPORTED_MODULE_9__.decodeRlp),\n/* harmony export */   defineProperties: () => (/* reexport safe */ _properties_js__WEBPACK_IMPORTED_MODULE_8__.defineProperties),\n/* harmony export */   encodeBase58: () => (/* reexport safe */ _base58_js__WEBPACK_IMPORTED_MODULE_0__.encodeBase58),\n/* harmony export */   encodeBase64: () => (/* reexport safe */ _base64_js__WEBPACK_IMPORTED_MODULE_1__.encodeBase64),\n/* harmony export */   encodeRlp: () => (/* reexport safe */ _rlp_encode_js__WEBPACK_IMPORTED_MODULE_10__.encodeRlp),\n/* harmony export */   formatEther: () => (/* reexport safe */ _units_js__WEBPACK_IMPORTED_MODULE_11__.formatEther),\n/* harmony export */   formatUnits: () => (/* reexport safe */ _units_js__WEBPACK_IMPORTED_MODULE_11__.formatUnits),\n/* harmony export */   fromTwos: () => (/* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.fromTwos),\n/* harmony export */   getBigInt: () => (/* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.getBigInt),\n/* harmony export */   getBytes: () => (/* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.getBytes),\n/* harmony export */   getBytesCopy: () => (/* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy),\n/* harmony export */   getNumber: () => (/* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.getNumber),\n/* harmony export */   getUint: () => (/* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.getUint),\n/* harmony export */   hexlify: () => (/* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.hexlify),\n/* harmony export */   isBytesLike: () => (/* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.isBytesLike),\n/* harmony export */   isCallException: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_3__.isCallException),\n/* harmony export */   isError: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_3__.isError),\n/* harmony export */   isHexString: () => (/* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.isHexString),\n/* harmony export */   makeError: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_3__.makeError),\n/* harmony export */   mask: () => (/* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.mask),\n/* harmony export */   parseEther: () => (/* reexport safe */ _units_js__WEBPACK_IMPORTED_MODULE_11__.parseEther),\n/* harmony export */   parseUnits: () => (/* reexport safe */ _units_js__WEBPACK_IMPORTED_MODULE_11__.parseUnits),\n/* harmony export */   resolveProperties: () => (/* reexport safe */ _properties_js__WEBPACK_IMPORTED_MODULE_8__.resolveProperties),\n/* harmony export */   stripZerosLeft: () => (/* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.stripZerosLeft),\n/* harmony export */   toBeArray: () => (/* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.toBeArray),\n/* harmony export */   toBeHex: () => (/* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.toBeHex),\n/* harmony export */   toBigInt: () => (/* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.toBigInt),\n/* harmony export */   toNumber: () => (/* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.toNumber),\n/* harmony export */   toQuantity: () => (/* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.toQuantity),\n/* harmony export */   toTwos: () => (/* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.toTwos),\n/* harmony export */   toUtf8Bytes: () => (/* reexport safe */ _utf8_js__WEBPACK_IMPORTED_MODULE_12__.toUtf8Bytes),\n/* harmony export */   toUtf8CodePoints: () => (/* reexport safe */ _utf8_js__WEBPACK_IMPORTED_MODULE_12__.toUtf8CodePoints),\n/* harmony export */   toUtf8String: () => (/* reexport safe */ _utf8_js__WEBPACK_IMPORTED_MODULE_12__.toUtf8String),\n/* harmony export */   uuidV4: () => (/* reexport safe */ _uuid_js__WEBPACK_IMPORTED_MODULE_13__.uuidV4),\n/* harmony export */   zeroPadBytes: () => (/* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.zeroPadBytes),\n/* harmony export */   zeroPadValue: () => (/* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)\n/* harmony export */ });\n/* harmony import */ var _base58_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base58.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/base58.js\");\n/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base64.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/base64-browser.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/events.js\");\n/* harmony import */ var _fetch_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fetch.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/fetch.js\");\n/* harmony import */ var _fixednumber_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./fixednumber.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/fixednumber.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./maths.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./properties.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _rlp_decode_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./rlp-decode.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/rlp-decode.js\");\n/* harmony import */ var _rlp_encode_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./rlp-encode.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/rlp-encode.js\");\n/* harmony import */ var _units_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./units.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var _utf8_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utf8.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _uuid_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./uuid.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/uuid.js\");\n/**\r\n *  There are many simple utilities required to interact with\r\n *  Ethereum and to simplify the library, without increasing\r\n *  the library dependencies for simple functions.\r\n *\r\n *  @_section api/utils:Utilities  [about-utils]\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN5RDtBQUNBO0FBQ3dHO0FBQ2xCO0FBQ3BHO0FBQ2tDO0FBQzlCO0FBQ3dGO0FBQ2pFO0FBQzFCO0FBQ0E7QUFDa0M7QUFDVztBQUN0RDtBQUNuQyIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFx1dGlsc1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqICBUaGVyZSBhcmUgbWFueSBzaW1wbGUgdXRpbGl0aWVzIHJlcXVpcmVkIHRvIGludGVyYWN0IHdpdGhcclxuICogIEV0aGVyZXVtIGFuZCB0byBzaW1wbGlmeSB0aGUgbGlicmFyeSwgd2l0aG91dCBpbmNyZWFzaW5nXHJcbiAqICB0aGUgbGlicmFyeSBkZXBlbmRlbmNpZXMgZm9yIHNpbXBsZSBmdW5jdGlvbnMuXHJcbiAqXHJcbiAqICBAX3NlY3Rpb24gYXBpL3V0aWxzOlV0aWxpdGllcyAgW2Fib3V0LXV0aWxzXVxyXG4gKi9cclxuZXhwb3J0IHsgZGVjb2RlQmFzZTU4LCBlbmNvZGVCYXNlNTggfSBmcm9tIFwiLi9iYXNlNTguanNcIjtcclxuZXhwb3J0IHsgZGVjb2RlQmFzZTY0LCBlbmNvZGVCYXNlNjQgfSBmcm9tIFwiLi9iYXNlNjQuanNcIjtcclxuZXhwb3J0IHsgZ2V0Qnl0ZXMsIGdldEJ5dGVzQ29weSwgaXNIZXhTdHJpbmcsIGlzQnl0ZXNMaWtlLCBoZXhsaWZ5LCBjb25jYXQsIGRhdGFMZW5ndGgsIGRhdGFTbGljZSwgc3RyaXBaZXJvc0xlZnQsIHplcm9QYWRWYWx1ZSwgemVyb1BhZEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xyXG5leHBvcnQgeyBpc0NhbGxFeGNlcHRpb24sIGlzRXJyb3IsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGFzc2VydEFyZ3VtZW50Q291bnQsIGFzc2VydFByaXZhdGUsIGFzc2VydE5vcm1hbGl6ZSwgbWFrZUVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XHJcbmV4cG9ydCB7IEV2ZW50UGF5bG9hZCB9IGZyb20gXCIuL2V2ZW50cy5qc1wiO1xyXG5leHBvcnQgeyBGZXRjaFJlcXVlc3QsIEZldGNoUmVzcG9uc2UsIEZldGNoQ2FuY2VsU2lnbmFsLCB9IGZyb20gXCIuL2ZldGNoLmpzXCI7XHJcbmV4cG9ydCB7IEZpeGVkTnVtYmVyIH0gZnJvbSBcIi4vZml4ZWRudW1iZXIuanNcIjtcclxuZXhwb3J0IHsgZnJvbVR3b3MsIHRvVHdvcywgbWFzaywgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGdldFVpbnQsIHRvQmlnSW50LCB0b051bWJlciwgdG9CZUhleCwgdG9CZUFycmF5LCB0b1F1YW50aXR5IH0gZnJvbSBcIi4vbWF0aHMuanNcIjtcclxuZXhwb3J0IHsgcmVzb2x2ZVByb3BlcnRpZXMsIGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XHJcbmV4cG9ydCB7IGRlY29kZVJscCB9IGZyb20gXCIuL3JscC1kZWNvZGUuanNcIjtcclxuZXhwb3J0IHsgZW5jb2RlUmxwIH0gZnJvbSBcIi4vcmxwLWVuY29kZS5qc1wiO1xyXG5leHBvcnQgeyBmb3JtYXRFdGhlciwgcGFyc2VFdGhlciwgZm9ybWF0VW5pdHMsIHBhcnNlVW5pdHMgfSBmcm9tIFwiLi91bml0cy5qc1wiO1xyXG5leHBvcnQgeyB0b1V0ZjhCeXRlcywgdG9VdGY4Q29kZVBvaW50cywgdG9VdGY4U3RyaW5nLCBVdGY4RXJyb3JGdW5jcywgfSBmcm9tIFwiLi91dGY4LmpzXCI7XHJcbmV4cG9ydCB7IHV1aWRWNCB9IGZyb20gXCIuL3V1aWQuanNcIjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/maths.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/maths.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTwos: () => (/* binding */ fromTwos),\n/* harmony export */   getBigInt: () => (/* binding */ getBigInt),\n/* harmony export */   getNumber: () => (/* binding */ getNumber),\n/* harmony export */   getUint: () => (/* binding */ getUint),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   toBeArray: () => (/* binding */ toBeArray),\n/* harmony export */   toBeHex: () => (/* binding */ toBeHex),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toQuantity: () => (/* binding */ toQuantity),\n/* harmony export */   toTwos: () => (/* binding */ toTwos)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\r\n *  Some mathematic operations.\r\n *\r\n *  @_subsection: api/utils:Math Helpers  [about-maths]\r\n */\r\n\r\n\r\nconst BN_0 = BigInt(0);\r\nconst BN_1 = BigInt(1);\r\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\r\n// IEEE 754 support 53-bits of mantissa\r\nconst maxValue = 0x1fffffffffffff;\r\n/**\r\n *  Convert %%value%% from a twos-compliment representation of %%width%%\r\n *  bits to its value.\r\n *\r\n *  If the highest bit is ``1``, the result will be negative.\r\n */\r\nfunction fromTwos(_value, _width) {\r\n    const value = getUint(_value, \"value\");\r\n    const width = BigInt(getNumber(_width, \"width\"));\r\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)((value >> width) === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\r\n        operation: \"fromTwos\", fault: \"overflow\", value: _value\r\n    });\r\n    // Top bit set; treat as a negative value\r\n    if (value >> (width - BN_1)) {\r\n        const mask = (BN_1 << width) - BN_1;\r\n        return -(((~value) & mask) + BN_1);\r\n    }\r\n    return value;\r\n}\r\n/**\r\n *  Convert %%value%% to a twos-compliment representation of\r\n *  %%width%% bits.\r\n *\r\n *  The result will always be positive.\r\n */\r\nfunction toTwos(_value, _width) {\r\n    let value = getBigInt(_value, \"value\");\r\n    const width = BigInt(getNumber(_width, \"width\"));\r\n    const limit = (BN_1 << (width - BN_1));\r\n    if (value < BN_0) {\r\n        value = -value;\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\r\n            operation: \"toTwos\", fault: \"overflow\", value: _value\r\n        });\r\n        const mask = (BN_1 << width) - BN_1;\r\n        return ((~value) & mask) + BN_1;\r\n    }\r\n    else {\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value < limit, \"too high\", \"NUMERIC_FAULT\", {\r\n            operation: \"toTwos\", fault: \"overflow\", value: _value\r\n        });\r\n    }\r\n    return value;\r\n}\r\n/**\r\n *  Mask %%value%% with a bitmask of %%bits%% ones.\r\n */\r\nfunction mask(_value, _bits) {\r\n    const value = getUint(_value, \"value\");\r\n    const bits = BigInt(getNumber(_bits, \"bits\"));\r\n    return value & ((BN_1 << bits) - BN_1);\r\n}\r\n/**\r\n *  Gets a BigInt from %%value%%. If it is an invalid value for\r\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\r\n */\r\nfunction getBigInt(value, name) {\r\n    switch (typeof (value)) {\r\n        case \"bigint\": return value;\r\n        case \"number\":\r\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\r\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\r\n            return BigInt(value);\r\n        case \"string\":\r\n            try {\r\n                if (value === \"\") {\r\n                    throw new Error(\"empty string\");\r\n                }\r\n                if (value[0] === \"-\" && value[1] !== \"-\") {\r\n                    return -BigInt(value.substring(1));\r\n                }\r\n                return BigInt(value);\r\n            }\r\n            catch (e) {\r\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid BigNumberish string: ${e.message}`, name || \"value\", value);\r\n            }\r\n    }\r\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BigNumberish value\", name || \"value\", value);\r\n}\r\n/**\r\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\r\n *  value and that it is positive.\r\n */\r\nfunction getUint(value, name) {\r\n    const result = getBigInt(value, name);\r\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\r\n        fault: \"overflow\", operation: \"getUint\", value\r\n    });\r\n    return result;\r\n}\r\nconst Nibbles = \"0123456789abcdef\";\r\n/*\r\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\r\n * is treated as Big Endian data.\r\n */\r\nfunction toBigInt(value) {\r\n    if (value instanceof Uint8Array) {\r\n        let result = \"0x0\";\r\n        for (const v of value) {\r\n            result += Nibbles[v >> 4];\r\n            result += Nibbles[v & 0x0f];\r\n        }\r\n        return BigInt(result);\r\n    }\r\n    return getBigInt(value);\r\n}\r\n/**\r\n *  Gets a //number// from %%value%%. If it is an invalid value for\r\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\r\n */\r\nfunction getNumber(value, name) {\r\n    switch (typeof (value)) {\r\n        case \"bigint\":\r\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\r\n            return Number(value);\r\n        case \"number\":\r\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\r\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\r\n            return value;\r\n        case \"string\":\r\n            try {\r\n                if (value === \"\") {\r\n                    throw new Error(\"empty string\");\r\n                }\r\n                return getNumber(BigInt(value), name);\r\n            }\r\n            catch (e) {\r\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid numeric string: ${e.message}`, name || \"value\", value);\r\n            }\r\n    }\r\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid numeric value\", name || \"value\", value);\r\n}\r\n/**\r\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\r\n *  is treated as Big Endian data. Throws if the value is not safe.\r\n */\r\nfunction toNumber(value) {\r\n    return getNumber(toBigInt(value));\r\n}\r\n/**\r\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\r\n *  %%width%% bytes.\r\n */\r\nfunction toBeHex(_value, _width) {\r\n    const value = getUint(_value, \"value\");\r\n    let result = value.toString(16);\r\n    if (_width == null) {\r\n        // Ensure the value is of even length\r\n        if (result.length % 2) {\r\n            result = \"0\" + result;\r\n        }\r\n    }\r\n    else {\r\n        const width = getNumber(_width, \"width\");\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(width * 2 >= result.length, `value exceeds width (${width} bytes)`, \"NUMERIC_FAULT\", {\r\n            operation: \"toBeHex\",\r\n            fault: \"overflow\",\r\n            value: _value\r\n        });\r\n        // Pad the value to the required width\r\n        while (result.length < (width * 2)) {\r\n            result = \"0\" + result;\r\n        }\r\n    }\r\n    return \"0x\" + result;\r\n}\r\n/**\r\n *  Converts %%value%% to a Big Endian Uint8Array.\r\n */\r\nfunction toBeArray(_value) {\r\n    const value = getUint(_value, \"value\");\r\n    if (value === BN_0) {\r\n        return new Uint8Array([]);\r\n    }\r\n    let hex = value.toString(16);\r\n    if (hex.length % 2) {\r\n        hex = \"0\" + hex;\r\n    }\r\n    const result = new Uint8Array(hex.length / 2);\r\n    for (let i = 0; i < result.length; i++) {\r\n        const offset = i * 2;\r\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\r\n *\r\n *  A //Quantity// does not have and leading 0 values unless the value is\r\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\r\n *  numeric values.\r\n */\r\nfunction toQuantity(value) {\r\n    let result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_data_js__WEBPACK_IMPORTED_MODULE_1__.isBytesLike)(value) ? value : toBeArray(value)).substring(2);\r\n    while (result.startsWith(\"0\")) {\r\n        result = result.substring(1);\r\n    }\r\n    if (result === \"\") {\r\n        result = \"0\";\r\n    }\r\n    return \"0x\" + result;\r\n}\r\n//# sourceMappingURL=maths.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9tYXRocy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpRDtBQUNJO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxJQUFJLGtEQUFNO0FBQ1Y7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQWM7QUFDMUIsWUFBWSwwREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQWMsd0NBQXdDLFVBQVU7QUFDaEY7QUFDQTtBQUNBLElBQUksMERBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxJQUFJLGtEQUFNO0FBQ1Y7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxZQUFZLDBEQUFjO0FBQzFCO0FBQ0E7QUFDQSxZQUFZLDBEQUFjO0FBQzFCLFlBQVksMERBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBEQUFjLG1DQUFtQyxVQUFVO0FBQzNFO0FBQ0E7QUFDQSxJQUFJLDBEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNLHFEQUFxRCxPQUFPO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQixpREFBTyxDQUFDLHFEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFx1dGlsc1xcbWF0aHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqICBTb21lIG1hdGhlbWF0aWMgb3BlcmF0aW9ucy5cclxuICpcclxuICogIEBfc3Vic2VjdGlvbjogYXBpL3V0aWxzOk1hdGggSGVscGVycyAgW2Fib3V0LW1hdGhzXVxyXG4gKi9cclxuaW1wb3J0IHsgaGV4bGlmeSwgaXNCeXRlc0xpa2UgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XHJcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcclxuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcclxuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcclxuLy9jb25zdCBCTl9NYXgyNTYgPSAoQk5fMSA8PCBCaWdJbnQoMjU2KSkgLSBCTl8xO1xyXG4vLyBJRUVFIDc1NCBzdXBwb3J0IDUzLWJpdHMgb2YgbWFudGlzc2FcclxuY29uc3QgbWF4VmFsdWUgPSAweDFmZmZmZmZmZmZmZmZmO1xyXG4vKipcclxuICogIENvbnZlcnQgJSV2YWx1ZSUlIGZyb20gYSB0d29zLWNvbXBsaW1lbnQgcmVwcmVzZW50YXRpb24gb2YgJSV3aWR0aCUlXHJcbiAqICBiaXRzIHRvIGl0cyB2YWx1ZS5cclxuICpcclxuICogIElmIHRoZSBoaWdoZXN0IGJpdCBpcyBgYDFgYCwgdGhlIHJlc3VsdCB3aWxsIGJlIG5lZ2F0aXZlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Ud29zKF92YWx1ZSwgX3dpZHRoKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xyXG4gICAgY29uc3Qgd2lkdGggPSBCaWdJbnQoZ2V0TnVtYmVyKF93aWR0aCwgXCJ3aWR0aFwiKSk7XHJcbiAgICBhc3NlcnQoKHZhbHVlID4+IHdpZHRoKSA9PT0gQk5fMCwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xyXG4gICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXHJcbiAgICB9KTtcclxuICAgIC8vIFRvcCBiaXQgc2V0OyB0cmVhdCBhcyBhIG5lZ2F0aXZlIHZhbHVlXHJcbiAgICBpZiAodmFsdWUgPj4gKHdpZHRoIC0gQk5fMSkpIHtcclxuICAgICAgICBjb25zdCBtYXNrID0gKEJOXzEgPDwgd2lkdGgpIC0gQk5fMTtcclxuICAgICAgICByZXR1cm4gLSgoKH52YWx1ZSkgJiBtYXNrKSArIEJOXzEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbi8qKlxyXG4gKiAgQ29udmVydCAlJXZhbHVlJSUgdG8gYSB0d29zLWNvbXBsaW1lbnQgcmVwcmVzZW50YXRpb24gb2ZcclxuICogICUld2lkdGglJSBiaXRzLlxyXG4gKlxyXG4gKiAgVGhlIHJlc3VsdCB3aWxsIGFsd2F5cyBiZSBwb3NpdGl2ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1R3b3MoX3ZhbHVlLCBfd2lkdGgpIHtcclxuICAgIGxldCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwidmFsdWVcIik7XHJcbiAgICBjb25zdCB3aWR0aCA9IEJpZ0ludChnZXROdW1iZXIoX3dpZHRoLCBcIndpZHRoXCIpKTtcclxuICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xyXG4gICAgaWYgKHZhbHVlIDwgQk5fMCkge1xyXG4gICAgICAgIHZhbHVlID0gLXZhbHVlO1xyXG4gICAgICAgIGFzc2VydCh2YWx1ZSA8PSBsaW1pdCwgXCJ0b28gbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b1R3b3NcIiwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IG1hc2sgPSAoQk5fMSA8PCB3aWR0aCkgLSBCTl8xO1xyXG4gICAgICAgIHJldHVybiAoKH52YWx1ZSkgJiBtYXNrKSArIEJOXzE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhc3NlcnQodmFsdWUgPCBsaW1pdCwgXCJ0b28gaGlnaFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xyXG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9Ud29zXCIsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG4vKipcclxuICogIE1hc2sgJSV2YWx1ZSUlIHdpdGggYSBiaXRtYXNrIG9mICUlYml0cyUlIG9uZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWFzayhfdmFsdWUsIF9iaXRzKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xyXG4gICAgY29uc3QgYml0cyA9IEJpZ0ludChnZXROdW1iZXIoX2JpdHMsIFwiYml0c1wiKSk7XHJcbiAgICByZXR1cm4gdmFsdWUgJiAoKEJOXzEgPDwgYml0cykgLSBCTl8xKTtcclxufVxyXG4vKipcclxuICogIEdldHMgYSBCaWdJbnQgZnJvbSAlJXZhbHVlJSUuIElmIGl0IGlzIGFuIGludmFsaWQgdmFsdWUgZm9yXHJcbiAqICBhIEJpZ0ludCwgdGhlbiBhbiBBcmd1bWVudEVycm9yIHdpbGwgYmUgdGhyb3duIGZvciAlJW5hbWUlJS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRCaWdJbnQodmFsdWUsIG5hbWUpIHtcclxuICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSkpIHtcclxuICAgICAgICBjYXNlIFwiYmlnaW50XCI6IHJldHVybiB2YWx1ZTtcclxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcInVuZGVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XHJcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWzBdID09PSBcIi1cIiAmJiB2YWx1ZVsxXSAhPT0gXCItXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLUJpZ0ludCh2YWx1ZS5zdWJzdHJpbmcoMSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBCaWdOdW1iZXJpc2ggc3RyaW5nOiAke2UubWVzc2FnZX1gLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIEJpZ051bWJlcmlzaCB2YWx1ZVwiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyAlJXZhbHVlJSUgYXMgYSBiaWdpbnQsIHZhbGlkYXRpbmcgaXQgaXMgdmFsaWQgYXMgYSBiaWdpbnRcclxuICogIHZhbHVlIGFuZCB0aGF0IGl0IGlzIHBvc2l0aXZlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFVpbnQodmFsdWUsIG5hbWUpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGdldEJpZ0ludCh2YWx1ZSwgbmFtZSk7XHJcbiAgICBhc3NlcnQocmVzdWx0ID49IEJOXzAsIFwidW5zaWduZWQgdmFsdWUgY2Fubm90IGJlIG5lZ2F0aXZlXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XHJcbiAgICAgICAgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgb3BlcmF0aW9uOiBcImdldFVpbnRcIiwgdmFsdWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5jb25zdCBOaWJibGVzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XHJcbi8qXHJcbiAqIENvbnZlcnRzICUldmFsdWUlJSB0byBhIEJpZ0ludC4gSWYgJSV2YWx1ZSUlIGlzIGEgVWludDhBcnJheSwgaXRcclxuICogaXMgdHJlYXRlZCBhcyBCaWcgRW5kaWFuIGRhdGEuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdG9CaWdJbnQodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweDBcIjtcclxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IE5pYmJsZXNbdiA+PiA0XTtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IE5pYmJsZXNbdiAmIDB4MGZdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQmlnSW50KHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0QmlnSW50KHZhbHVlKTtcclxufVxyXG4vKipcclxuICogIEdldHMgYSAvL251bWJlci8vIGZyb20gJSV2YWx1ZSUlLiBJZiBpdCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvclxyXG4gKiAgYSAvL251bWJlci8vLCB0aGVuIGFuIEFyZ3VtZW50RXJyb3Igd2lsbCBiZSB0aHJvd24gZm9yICUlbmFtZSUlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE51bWJlcih2YWx1ZSwgbmFtZSkge1xyXG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xyXG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gLW1heFZhbHVlICYmIHZhbHVlIDw9IG1heFZhbHVlLCBcIm92ZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xyXG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksIFwidW5kZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IC1tYXhWYWx1ZSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgXCJvdmVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE51bWJlcihCaWdJbnQodmFsdWUpLCBuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIG51bWVyaWMgc3RyaW5nOiAke2UubWVzc2FnZX1gLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIG51bWVyaWMgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcclxufVxyXG4vKipcclxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIG51bWJlci4gSWYgJSV2YWx1ZSUlIGlzIGEgVWludDhBcnJheSwgaXRcclxuICogIGlzIHRyZWF0ZWQgYXMgQmlnIEVuZGlhbiBkYXRhLiBUaHJvd3MgaWYgdGhlIHZhbHVlIGlzIG5vdCBzYWZlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gZ2V0TnVtYmVyKHRvQmlnSW50KHZhbHVlKSk7XHJcbn1cclxuLyoqXHJcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWcgRW5kaWFuIGhleHN0cmluZywgb3B0aW9uYWxseSBwYWRkZWQgdG9cclxuICogICUld2lkdGglJSBieXRlcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0JlSGV4KF92YWx1ZSwgX3dpZHRoKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xyXG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcclxuICAgIGlmIChfd2lkdGggPT0gbnVsbCkge1xyXG4gICAgICAgIC8vIEVuc3VyZSB0aGUgdmFsdWUgaXMgb2YgZXZlbiBsZW5ndGhcclxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBnZXROdW1iZXIoX3dpZHRoLCBcIndpZHRoXCIpO1xyXG4gICAgICAgIGFzc2VydCh3aWR0aCAqIDIgPj0gcmVzdWx0Lmxlbmd0aCwgYHZhbHVlIGV4Y2VlZHMgd2lkdGggKCR7d2lkdGh9IGJ5dGVzKWAsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b0JlSGV4XCIsXHJcbiAgICAgICAgICAgIGZhdWx0OiBcIm92ZXJmbG93XCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiBfdmFsdWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBQYWQgdGhlIHZhbHVlIHRvIHRoZSByZXF1aXJlZCB3aWR0aFxyXG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgKHdpZHRoICogMikpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIEJpZyBFbmRpYW4gVWludDhBcnJheS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0JlQXJyYXkoX3ZhbHVlKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xyXG4gICAgaWYgKHZhbHVlID09PSBCTl8wKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtdKTtcclxuICAgIH1cclxuICAgIGxldCBoZXggPSB2YWx1ZS50b1N0cmluZygxNik7XHJcbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcclxuICAgICAgICBoZXggPSBcIjBcIiArIGhleDtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaSAqIDI7XHJcbiAgICAgICAgcmVzdWx0W2ldID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIDIpLCAxNik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyBhIFtbSGV4U3RyaW5nXV0gZm9yICUldmFsdWUlJSBzYWZlIHRvIHVzZSBhcyBhIC8vUXVhbnRpdHkvLy5cclxuICpcclxuICogIEEgLy9RdWFudGl0eS8vIGRvZXMgbm90IGhhdmUgYW5kIGxlYWRpbmcgMCB2YWx1ZXMgdW5sZXNzIHRoZSB2YWx1ZSBpc1xyXG4gKiAgdGhlIGxpdGVyYWwgdmFsdWUgYDB4MGAuIFRoaXMgaXMgbW9zdCBjb21tb25seSB1c2VkIGZvciBKU1NPTi1SUENcclxuICogIG51bWVyaWMgdmFsdWVzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvUXVhbnRpdHkodmFsdWUpIHtcclxuICAgIGxldCByZXN1bHQgPSBoZXhsaWZ5KGlzQnl0ZXNMaWtlKHZhbHVlKSA/IHZhbHVlIDogdG9CZUFycmF5KHZhbHVlKSkuc3Vic3RyaW5nKDIpO1xyXG4gICAgd2hpbGUgKHJlc3VsdC5zdGFydHNXaXRoKFwiMFwiKSkge1xyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHJpbmcoMSk7XHJcbiAgICB9XHJcbiAgICBpZiAocmVzdWx0ID09PSBcIlwiKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gXCIwXCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGhzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/maths.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/properties.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/properties.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defineProperties: () => (/* binding */ defineProperties),\n/* harmony export */   resolveProperties: () => (/* binding */ resolveProperties)\n/* harmony export */ });\n/**\r\n *  Property helper functions.\r\n *\r\n *  @_subsection api/utils:Properties  [about-properties]\r\n */\r\nfunction checkType(value, type, name) {\r\n    const types = type.split(\"|\").map(t => t.trim());\r\n    for (let i = 0; i < types.length; i++) {\r\n        switch (type) {\r\n            case \"any\":\r\n                return;\r\n            case \"bigint\":\r\n            case \"boolean\":\r\n            case \"number\":\r\n            case \"string\":\r\n                if (typeof (value) === type) {\r\n                    return;\r\n                }\r\n        }\r\n    }\r\n    const error = new Error(`invalid value for type ${type}`);\r\n    error.code = \"INVALID_ARGUMENT\";\r\n    error.argument = `value.${name}`;\r\n    error.value = value;\r\n    throw error;\r\n}\r\n/**\r\n *  Resolves to a new object that is a copy of %%value%%, but with all\r\n *  values resolved.\r\n */\r\nasync function resolveProperties(value) {\r\n    const keys = Object.keys(value);\r\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));\r\n    return results.reduce((accum, v, index) => {\r\n        accum[keys[index]] = v;\r\n        return accum;\r\n    }, {});\r\n}\r\n/**\r\n *  Assigns the %%values%% to %%target%% as read-only values.\r\n *\r\n *  It %%types%% is specified, the values are checked.\r\n */\r\nfunction defineProperties(target, values, types) {\r\n    for (let key in values) {\r\n        let value = values[key];\r\n        const type = (types ? types[key] : null);\r\n        if (type) {\r\n            checkType(value, type, key);\r\n        }\r\n        Object.defineProperty(target, key, { enumerable: true, value, writable: false });\r\n    }\r\n}\r\n//# sourceMappingURL=properties.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9wcm9wZXJ0aWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLO0FBQzNEO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywwQ0FBMEM7QUFDdkY7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHV0aWxzXFxwcm9wZXJ0aWVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgUHJvcGVydHkgaGVscGVyIGZ1bmN0aW9ucy5cclxuICpcclxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6UHJvcGVydGllcyAgW2Fib3V0LXByb3BlcnRpZXNdXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGVja1R5cGUodmFsdWUsIHR5cGUsIG5hbWUpIHtcclxuICAgIGNvbnN0IHR5cGVzID0gdHlwZS5zcGxpdChcInxcIikubWFwKHQgPT4gdC50cmltKCkpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiYW55XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcclxuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcclxuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxyXG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IHR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGludmFsaWQgdmFsdWUgZm9yIHR5cGUgJHt0eXBlfWApO1xyXG4gICAgZXJyb3IuY29kZSA9IFwiSU5WQUxJRF9BUkdVTUVOVFwiO1xyXG4gICAgZXJyb3IuYXJndW1lbnQgPSBgdmFsdWUuJHtuYW1lfWA7XHJcbiAgICBlcnJvci52YWx1ZSA9IHZhbHVlO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbn1cclxuLyoqXHJcbiAqICBSZXNvbHZlcyB0byBhIG5ldyBvYmplY3QgdGhhdCBpcyBhIGNvcHkgb2YgJSV2YWx1ZSUlLCBidXQgd2l0aCBhbGxcclxuICogIHZhbHVlcyByZXNvbHZlZC5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlUHJvcGVydGllcyh2YWx1ZSkge1xyXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChrZXlzLm1hcCgoaykgPT4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlW2tdKSkpO1xyXG4gICAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKChhY2N1bSwgdiwgaW5kZXgpID0+IHtcclxuICAgICAgICBhY2N1bVtrZXlzW2luZGV4XV0gPSB2O1xyXG4gICAgICAgIHJldHVybiBhY2N1bTtcclxuICAgIH0sIHt9KTtcclxufVxyXG4vKipcclxuICogIEFzc2lnbnMgdGhlICUldmFsdWVzJSUgdG8gJSV0YXJnZXQlJSBhcyByZWFkLW9ubHkgdmFsdWVzLlxyXG4gKlxyXG4gKiAgSXQgJSV0eXBlcyUlIGlzIHNwZWNpZmllZCwgdGhlIHZhbHVlcyBhcmUgY2hlY2tlZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgdmFsdWVzLCB0eXBlcykge1xyXG4gICAgZm9yIChsZXQga2V5IGluIHZhbHVlcykge1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IHZhbHVlc1trZXldO1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSAodHlwZXMgPyB0eXBlc1trZXldIDogbnVsbCk7XHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgY2hlY2tUeXBlKHZhbHVlLCB0eXBlLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWUsIHdyaXRhYmxlOiBmYWxzZSB9KTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wZXJ0aWVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/properties.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/rlp-decode.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/rlp-decode.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeRlp: () => (/* binding */ decodeRlp)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n//See: https://github.com/ethereum/wiki/wiki/RLP\r\n\r\n\r\n\r\nfunction hexlifyByte(value) {\r\n    let result = value.toString(16);\r\n    while (result.length < 2) {\r\n        result = \"0\" + result;\r\n    }\r\n    return \"0x\" + result;\r\n}\r\nfunction unarrayifyInteger(data, offset, length) {\r\n    let result = 0;\r\n    for (let i = 0; i < length; i++) {\r\n        result = (result * 256) + data[offset + i];\r\n    }\r\n    return result;\r\n}\r\nfunction _decodeChildren(data, offset, childOffset, length) {\r\n    const result = [];\r\n    while (childOffset < offset + 1 + length) {\r\n        const decoded = _decode(data, childOffset);\r\n        result.push(decoded.result);\r\n        childOffset += decoded.consumed;\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(childOffset <= offset + 1 + length, \"child data too short\", \"BUFFER_OVERRUN\", {\r\n            buffer: data, length, offset\r\n        });\r\n    }\r\n    return { consumed: (1 + length), result: result };\r\n}\r\n// returns { consumed: number, result: Object }\r\nfunction _decode(data, offset) {\r\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\r\n        buffer: data, length: 0, offset: 1\r\n    });\r\n    const checkOffset = (offset) => {\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(offset <= data.length, \"data short segment too short\", \"BUFFER_OVERRUN\", {\r\n            buffer: data, length: data.length, offset\r\n        });\r\n    };\r\n    // Array with extra length prefix\r\n    if (data[offset] >= 0xf8) {\r\n        const lengthLength = data[offset] - 0xf7;\r\n        checkOffset(offset + 1 + lengthLength);\r\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\r\n        checkOffset(offset + 1 + lengthLength + length);\r\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\r\n    }\r\n    else if (data[offset] >= 0xc0) {\r\n        const length = data[offset] - 0xc0;\r\n        checkOffset(offset + 1 + length);\r\n        return _decodeChildren(data, offset, offset + 1, length);\r\n    }\r\n    else if (data[offset] >= 0xb8) {\r\n        const lengthLength = data[offset] - 0xb7;\r\n        checkOffset(offset + 1 + lengthLength);\r\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\r\n        checkOffset(offset + 1 + lengthLength + length);\r\n        const result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\r\n        return { consumed: (1 + lengthLength + length), result: result };\r\n    }\r\n    else if (data[offset] >= 0x80) {\r\n        const length = data[offset] - 0x80;\r\n        checkOffset(offset + 1 + length);\r\n        const result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data.slice(offset + 1, offset + 1 + length));\r\n        return { consumed: (1 + length), result: result };\r\n    }\r\n    return { consumed: 1, result: hexlifyByte(data[offset]) };\r\n}\r\n/**\r\n *  Decodes %%data%% into the structured data it represents.\r\n */\r\nfunction decodeRlp(_data) {\r\n    const data = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\r\n    const decoded = _decode(data, 0);\r\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\r\n    return decoded.result;\r\n}\r\n//# sourceMappingURL=rlp-decode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9ybHAtZGVjb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ29DO0FBQ2lCO0FBQ2hCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsSUFBSSxrREFBTTtBQUNWO0FBQ0EsS0FBSztBQUNMO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFPO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBTztBQUM5QixpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQixrREFBUTtBQUN6QjtBQUNBLElBQUksMERBQWM7QUFDbEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHV0aWxzXFxybHAtZGVjb2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL1JMUFxyXG5pbXBvcnQgeyBoZXhsaWZ5IH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xyXG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XHJcbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xyXG5mdW5jdGlvbiBoZXhsaWZ5Qnl0ZSh2YWx1ZSkge1xyXG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcclxuICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgMikge1xyXG4gICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgbGV0IHJlc3VsdCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCAqIDI1NikgKyBkYXRhW29mZnNldCArIGldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBjaGlsZE9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIHdoaWxlIChjaGlsZE9mZnNldCA8IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShkYXRhLCBjaGlsZE9mZnNldCk7XHJcbiAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZC5yZXN1bHQpO1xyXG4gICAgICAgIGNoaWxkT2Zmc2V0ICs9IGRlY29kZWQuY29uc3VtZWQ7XHJcbiAgICAgICAgYXNzZXJ0KGNoaWxkT2Zmc2V0IDw9IG9mZnNldCArIDEgKyBsZW5ndGgsIFwiY2hpbGQgZGF0YSB0b28gc2hvcnRcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcjogZGF0YSwgbGVuZ3RoLCBvZmZzZXRcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XHJcbn1cclxuLy8gcmV0dXJucyB7IGNvbnN1bWVkOiBudW1iZXIsIHJlc3VsdDogT2JqZWN0IH1cclxuZnVuY3Rpb24gX2RlY29kZShkYXRhLCBvZmZzZXQpIHtcclxuICAgIGFzc2VydChkYXRhLmxlbmd0aCAhPT0gMCwgXCJkYXRhIHRvbyBzaG9ydFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcclxuICAgICAgICBidWZmZXI6IGRhdGEsIGxlbmd0aDogMCwgb2Zmc2V0OiAxXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGNoZWNrT2Zmc2V0ID0gKG9mZnNldCkgPT4ge1xyXG4gICAgICAgIGFzc2VydChvZmZzZXQgPD0gZGF0YS5sZW5ndGgsIFwiZGF0YSBzaG9ydCBzZWdtZW50IHRvbyBzaG9ydFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcclxuICAgICAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGg6IGRhdGEubGVuZ3RoLCBvZmZzZXRcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBBcnJheSB3aXRoIGV4dHJhIGxlbmd0aCBwcmVmaXhcclxuICAgIGlmIChkYXRhW29mZnNldF0gPj0gMHhmOCkge1xyXG4gICAgICAgIGNvbnN0IGxlbmd0aExlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4Zjc7XHJcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcclxuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCwgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGMwKSB7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhjMDtcclxuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSwgbGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGI4KSB7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoTGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhiNztcclxuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQgKyAxLCBsZW5ndGhMZW5ndGgpO1xyXG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSk7XHJcbiAgICAgICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweDgwKSB7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHg4MDtcclxuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBoZXhsaWZ5KGRhdGEuc2xpY2Uob2Zmc2V0ICsgMSwgb2Zmc2V0ICsgMSArIGxlbmd0aCkpO1xyXG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBjb25zdW1lZDogMSwgcmVzdWx0OiBoZXhsaWZ5Qnl0ZShkYXRhW29mZnNldF0pIH07XHJcbn1cclxuLyoqXHJcbiAqICBEZWNvZGVzICUlZGF0YSUlIGludG8gdGhlIHN0cnVjdHVyZWQgZGF0YSBpdCByZXByZXNlbnRzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVJscChfZGF0YSkge1xyXG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XHJcbiAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShkYXRhLCAwKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KGRlY29kZWQuY29uc3VtZWQgPT09IGRhdGEubGVuZ3RoLCBcInVuZXhwZWN0ZWQganVuayBhZnRlciBybHAgcGF5bG9hZFwiLCBcImRhdGFcIiwgX2RhdGEpO1xyXG4gICAgcmV0dXJuIGRlY29kZWQucmVzdWx0O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJscC1kZWNvZGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/rlp-decode.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/rlp-encode.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/rlp-encode.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeRlp: () => (/* binding */ encodeRlp)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n//See: https://github.com/ethereum/wiki/wiki/RLP\r\n\r\nfunction arrayifyInteger(value) {\r\n    const result = [];\r\n    while (value) {\r\n        result.unshift(value & 0xff);\r\n        value >>= 8;\r\n    }\r\n    return result;\r\n}\r\nfunction _encode(object) {\r\n    if (Array.isArray(object)) {\r\n        let payload = [];\r\n        object.forEach(function (child) {\r\n            payload = payload.concat(_encode(child));\r\n        });\r\n        if (payload.length <= 55) {\r\n            payload.unshift(0xc0 + payload.length);\r\n            return payload;\r\n        }\r\n        const length = arrayifyInteger(payload.length);\r\n        length.unshift(0xf7 + length.length);\r\n        return length.concat(payload);\r\n    }\r\n    const data = Array.prototype.slice.call((0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(object, \"object\"));\r\n    if (data.length === 1 && data[0] <= 0x7f) {\r\n        return data;\r\n    }\r\n    else if (data.length <= 55) {\r\n        data.unshift(0x80 + data.length);\r\n        return data;\r\n    }\r\n    const length = arrayifyInteger(data.length);\r\n    length.unshift(0xb7 + length.length);\r\n    return length.concat(data);\r\n}\r\nconst nibbles = \"0123456789abcdef\";\r\n/**\r\n *  Encodes %%object%% as an RLP-encoded [[DataHexString]].\r\n */\r\nfunction encodeRlp(object) {\r\n    let result = \"0x\";\r\n    for (const v of _encode(object)) {\r\n        result += nibbles[v >> 4];\r\n        result += nibbles[v & 0xf];\r\n    }\r\n    return result;\r\n}\r\n//# sourceMappingURL=rlp-encode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9ybHAtZW5jb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrREFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcdXRpbHNcXHJscC1lbmNvZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy9TZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvUkxQXHJcbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xyXG5mdW5jdGlvbiBhcnJheWlmeUludGVnZXIodmFsdWUpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgd2hpbGUgKHZhbHVlKSB7XHJcbiAgICAgICAgcmVzdWx0LnVuc2hpZnQodmFsdWUgJiAweGZmKTtcclxuICAgICAgICB2YWx1ZSA+Pj0gODtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gX2VuY29kZShvYmplY3QpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcclxuICAgICAgICBsZXQgcGF5bG9hZCA9IFtdO1xyXG4gICAgICAgIG9iamVjdC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICBwYXlsb2FkID0gcGF5bG9hZC5jb25jYXQoX2VuY29kZShjaGlsZCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChwYXlsb2FkLmxlbmd0aCA8PSA1NSkge1xyXG4gICAgICAgICAgICBwYXlsb2FkLnVuc2hpZnQoMHhjMCArIHBheWxvYWQubGVuZ3RoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihwYXlsb2FkLmxlbmd0aCk7XHJcbiAgICAgICAgbGVuZ3RoLnVuc2hpZnQoMHhmNyArIGxlbmd0aC5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBsZW5ndGguY29uY2F0KHBheWxvYWQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGF0YSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGdldEJ5dGVzKG9iamVjdCwgXCJvYmplY3RcIikpO1xyXG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAxICYmIGRhdGFbMF0gPD0gMHg3Zikge1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZGF0YS5sZW5ndGggPD0gNTUpIHtcclxuICAgICAgICBkYXRhLnVuc2hpZnQoMHg4MCArIGRhdGEubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihkYXRhLmxlbmd0aCk7XHJcbiAgICBsZW5ndGgudW5zaGlmdCgweGI3ICsgbGVuZ3RoLmxlbmd0aCk7XHJcbiAgICByZXR1cm4gbGVuZ3RoLmNvbmNhdChkYXRhKTtcclxufVxyXG5jb25zdCBuaWJibGVzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XHJcbi8qKlxyXG4gKiAgRW5jb2RlcyAlJW9iamVjdCUlIGFzIGFuIFJMUC1lbmNvZGVkIFtbRGF0YUhleFN0cmluZ11dLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVJscChvYmplY3QpIHtcclxuICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XHJcbiAgICBmb3IgKGNvbnN0IHYgb2YgX2VuY29kZShvYmplY3QpKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IG5pYmJsZXNbdiA+PiA0XTtcclxuICAgICAgICByZXN1bHQgKz0gbmliYmxlc1t2ICYgMHhmXTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmxwLWVuY29kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/rlp-encode.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/units.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/units.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatEther: () => (/* binding */ formatEther),\n/* harmony export */   formatUnits: () => (/* binding */ formatUnits),\n/* harmony export */   parseEther: () => (/* binding */ parseEther),\n/* harmony export */   parseUnits: () => (/* binding */ parseUnits)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fixednumber.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/fixednumber.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/**\r\n *  Most interactions with Ethereum requires integer values, which use\r\n *  the smallest magnitude unit.\r\n *\r\n *  For example, imagine dealing with dollars and cents. Since dollars\r\n *  are divisible, non-integer values are possible, such as ``$10.77``.\r\n *  By using the smallest indivisible unit (i.e. cents), the value can\r\n *  be kept as the integer ``1077``.\r\n *\r\n *  When receiving decimal input from the user (as a decimal string),\r\n *  the value should be converted to an integer and when showing a user\r\n *  a value, the integer value should be converted to a decimal string.\r\n *\r\n *  This creates a clear distinction, between values to be used by code\r\n *  (integers) and values used for display logic to users (decimals).\r\n *\r\n *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,\r\n *  where each individual unit is called a //wei//.\r\n *\r\n *  @_subsection api/utils:Unit Conversion  [about-units]\r\n */\r\n\r\n\r\n\r\nconst names = [\r\n    \"wei\",\r\n    \"kwei\",\r\n    \"mwei\",\r\n    \"gwei\",\r\n    \"szabo\",\r\n    \"finney\",\r\n    \"ether\",\r\n];\r\n/**\r\n *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal\r\n *  places. The %%unit%% may be the number of decimal places or the name of\r\n *  a unit (e.g. ``\"gwei\"`` for 9 decimal places).\r\n *\r\n */\r\nfunction formatUnits(value, unit) {\r\n    let decimals = 18;\r\n    if (typeof (unit) === \"string\") {\r\n        const index = names.indexOf(unit);\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\r\n        decimals = 3 * index;\r\n    }\r\n    else if (unit != null) {\r\n        decimals = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(unit, \"unit\");\r\n    }\r\n    return _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__.FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();\r\n}\r\n/**\r\n *  Converts the //decimal string// %%value%% to a BigInt, assuming\r\n *  %%unit%% decimal places. The %%unit%% may the number of decimal places\r\n *  or the name of a unit (e.g. ``\"gwei\"`` for 9 decimal places).\r\n */\r\nfunction parseUnits(value, unit) {\r\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (value) === \"string\", \"value must be a string\", \"value\", value);\r\n    let decimals = 18;\r\n    if (typeof (unit) === \"string\") {\r\n        const index = names.indexOf(unit);\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\r\n        decimals = 3 * index;\r\n    }\r\n    else if (unit != null) {\r\n        decimals = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(unit, \"unit\");\r\n    }\r\n    return _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__.FixedNumber.fromString(value, { decimals, width: 512 }).value;\r\n}\r\n/**\r\n *  Converts %%value%% into a //decimal string// using 18 decimal places.\r\n */\r\nfunction formatEther(wei) {\r\n    return formatUnits(wei, 18);\r\n}\r\n/**\r\n *  Converts the //decimal string// %%ether%% to a BigInt, using 18\r\n *  decimal places.\r\n */\r\nfunction parseEther(ether) {\r\n    return parseUnits(ether, 18);\r\n}\r\n//# sourceMappingURL=units.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy91bml0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZDO0FBQ0U7QUFDUjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFTO0FBQzVCO0FBQ0EsV0FBVyx3REFBVyw4QkFBOEIsc0JBQXNCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSwwREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvREFBUztBQUM1QjtBQUNBLFdBQVcsd0RBQVcscUJBQXFCLHNCQUFzQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcdXRpbHNcXHVuaXRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgTW9zdCBpbnRlcmFjdGlvbnMgd2l0aCBFdGhlcmV1bSByZXF1aXJlcyBpbnRlZ2VyIHZhbHVlcywgd2hpY2ggdXNlXHJcbiAqICB0aGUgc21hbGxlc3QgbWFnbml0dWRlIHVuaXQuXHJcbiAqXHJcbiAqICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBkZWFsaW5nIHdpdGggZG9sbGFycyBhbmQgY2VudHMuIFNpbmNlIGRvbGxhcnNcclxuICogIGFyZSBkaXZpc2libGUsIG5vbi1pbnRlZ2VyIHZhbHVlcyBhcmUgcG9zc2libGUsIHN1Y2ggYXMgYGAkMTAuNzdgYC5cclxuICogIEJ5IHVzaW5nIHRoZSBzbWFsbGVzdCBpbmRpdmlzaWJsZSB1bml0IChpLmUuIGNlbnRzKSwgdGhlIHZhbHVlIGNhblxyXG4gKiAgYmUga2VwdCBhcyB0aGUgaW50ZWdlciBgYDEwNzdgYC5cclxuICpcclxuICogIFdoZW4gcmVjZWl2aW5nIGRlY2ltYWwgaW5wdXQgZnJvbSB0aGUgdXNlciAoYXMgYSBkZWNpbWFsIHN0cmluZyksXHJcbiAqICB0aGUgdmFsdWUgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyIGFuZCB3aGVuIHNob3dpbmcgYSB1c2VyXHJcbiAqICBhIHZhbHVlLCB0aGUgaW50ZWdlciB2YWx1ZSBzaG91bGQgYmUgY29udmVydGVkIHRvIGEgZGVjaW1hbCBzdHJpbmcuXHJcbiAqXHJcbiAqICBUaGlzIGNyZWF0ZXMgYSBjbGVhciBkaXN0aW5jdGlvbiwgYmV0d2VlbiB2YWx1ZXMgdG8gYmUgdXNlZCBieSBjb2RlXHJcbiAqICAoaW50ZWdlcnMpIGFuZCB2YWx1ZXMgdXNlZCBmb3IgZGlzcGxheSBsb2dpYyB0byB1c2VycyAoZGVjaW1hbHMpLlxyXG4gKlxyXG4gKiAgVGhlIG5hdGl2ZSB1bml0IGluIEV0aGVyZXVtLCAvL2V0aGVyLy8gaXMgZGl2aXNpYmxlIHRvIDE4IGRlY2ltYWwgcGxhY2VzLFxyXG4gKiAgd2hlcmUgZWFjaCBpbmRpdmlkdWFsIHVuaXQgaXMgY2FsbGVkIGEgLy93ZWkvLy5cclxuICpcclxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6VW5pdCBDb252ZXJzaW9uICBbYWJvdXQtdW5pdHNdXHJcbiAqL1xyXG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xyXG5pbXBvcnQgeyBGaXhlZE51bWJlciB9IGZyb20gXCIuL2ZpeGVkbnVtYmVyLmpzXCI7XHJcbmltcG9ydCB7IGdldE51bWJlciB9IGZyb20gXCIuL21hdGhzLmpzXCI7XHJcbmNvbnN0IG5hbWVzID0gW1xyXG4gICAgXCJ3ZWlcIixcclxuICAgIFwia3dlaVwiLFxyXG4gICAgXCJtd2VpXCIsXHJcbiAgICBcImd3ZWlcIixcclxuICAgIFwic3phYm9cIixcclxuICAgIFwiZmlubmV5XCIsXHJcbiAgICBcImV0aGVyXCIsXHJcbl07XHJcbi8qKlxyXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIGludG8gYSAvL2RlY2ltYWwgc3RyaW5nLy8sIGFzc3VtaW5nICUldW5pdCUlIGRlY2ltYWxcclxuICogIHBsYWNlcy4gVGhlICUldW5pdCUlIG1heSBiZSB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9yIHRoZSBuYW1lIG9mXHJcbiAqICBhIHVuaXQgKGUuZy4gYGBcImd3ZWlcImBgIGZvciA5IGRlY2ltYWwgcGxhY2VzKS5cclxuICpcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVbml0cyh2YWx1ZSwgdW5pdCkge1xyXG4gICAgbGV0IGRlY2ltYWxzID0gMTg7XHJcbiAgICBpZiAodHlwZW9mICh1bml0KSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZXMuaW5kZXhPZih1bml0KTtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA+PSAwLCBcImludmFsaWQgdW5pdFwiLCBcInVuaXRcIiwgdW5pdCk7XHJcbiAgICAgICAgZGVjaW1hbHMgPSAzICogaW5kZXg7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh1bml0ICE9IG51bGwpIHtcclxuICAgICAgICBkZWNpbWFscyA9IGdldE51bWJlcih1bml0LCBcInVuaXRcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKHZhbHVlLCBkZWNpbWFscywgeyBkZWNpbWFscywgd2lkdGg6IDUxMiB9KS50b1N0cmluZygpO1xyXG59XHJcbi8qKlxyXG4gKiAgQ29udmVydHMgdGhlIC8vZGVjaW1hbCBzdHJpbmcvLyAlJXZhbHVlJSUgdG8gYSBCaWdJbnQsIGFzc3VtaW5nXHJcbiAqICAlJXVuaXQlJSBkZWNpbWFsIHBsYWNlcy4gVGhlICUldW5pdCUlIG1heSB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXHJcbiAqICBvciB0aGUgbmFtZSBvZiBhIHVuaXQgKGUuZy4gYGBcImd3ZWlcImBgIGZvciA5IGRlY2ltYWwgcGxhY2VzKS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVVuaXRzKHZhbHVlLCB1bml0KSB7XHJcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiwgXCJ2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgbGV0IGRlY2ltYWxzID0gMTg7XHJcbiAgICBpZiAodHlwZW9mICh1bml0KSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZXMuaW5kZXhPZih1bml0KTtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA+PSAwLCBcImludmFsaWQgdW5pdFwiLCBcInVuaXRcIiwgdW5pdCk7XHJcbiAgICAgICAgZGVjaW1hbHMgPSAzICogaW5kZXg7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh1bml0ICE9IG51bGwpIHtcclxuICAgICAgICBkZWNpbWFscyA9IGdldE51bWJlcih1bml0LCBcInVuaXRcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyh2YWx1ZSwgeyBkZWNpbWFscywgd2lkdGg6IDUxMiB9KS52YWx1ZTtcclxufVxyXG4vKipcclxuICogIENvbnZlcnRzICUldmFsdWUlJSBpbnRvIGEgLy9kZWNpbWFsIHN0cmluZy8vIHVzaW5nIDE4IGRlY2ltYWwgcGxhY2VzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEV0aGVyKHdlaSkge1xyXG4gICAgcmV0dXJuIGZvcm1hdFVuaXRzKHdlaSwgMTgpO1xyXG59XHJcbi8qKlxyXG4gKiAgQ29udmVydHMgdGhlIC8vZGVjaW1hbCBzdHJpbmcvLyAlJWV0aGVyJSUgdG8gYSBCaWdJbnQsIHVzaW5nIDE4XHJcbiAqICBkZWNpbWFsIHBsYWNlcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUV0aGVyKGV0aGVyKSB7XHJcbiAgICByZXR1cm4gcGFyc2VVbml0cyhldGhlciwgMTgpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaXRzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/units.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/utf8.js":
/*!***************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/utf8.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Utf8ErrorFuncs: () => (/* binding */ Utf8ErrorFuncs),\n/* harmony export */   toUtf8Bytes: () => (/* binding */ toUtf8Bytes),\n/* harmony export */   toUtf8CodePoints: () => (/* binding */ toUtf8CodePoints),\n/* harmony export */   toUtf8String: () => (/* binding */ toUtf8String)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\r\n *  Using strings in Ethereum (or any security-basd system) requires\r\n *  additional care. These utilities attempt to mitigate some of the\r\n *  safety issues as well as provide the ability to recover and analyse\r\n *  strings.\r\n *\r\n *  @_subsection api/utils:Strings and UTF-8  [about-strings]\r\n */\r\n\r\n\r\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\r\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\r\n}\r\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\r\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\r\n    if (reason === \"BAD_PREFIX\" || reason === \"UNEXPECTED_CONTINUE\") {\r\n        let i = 0;\r\n        for (let o = offset + 1; o < bytes.length; o++) {\r\n            if (bytes[o] >> 6 !== 0x02) {\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        return i;\r\n    }\r\n    // This byte runs us past the end of the string, so just jump to the end\r\n    // (but the first byte was read already read and therefore skipped)\r\n    if (reason === \"OVERRUN\") {\r\n        return bytes.length - offset - 1;\r\n    }\r\n    // Nothing to skip\r\n    return 0;\r\n}\r\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\r\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\r\n    if (reason === \"OVERLONG\") {\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (badCodepoint) === \"number\", \"invalid bad code point for replacement\", \"badCodepoint\", badCodepoint);\r\n        output.push(badCodepoint);\r\n        return 0;\r\n    }\r\n    // Put the replacement character into the output\r\n    output.push(0xfffd);\r\n    // Otherwise, process as if ignoring errors\r\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\r\n}\r\n/**\r\n *  A handful of popular, built-in UTF-8 error handling strategies.\r\n *\r\n *  **``\"error\"``** - throws on ANY illegal UTF-8 sequence or\r\n *  non-canonical (overlong) codepoints (this is the default)\r\n *\r\n *  **``\"ignore\"``** - silently drops any illegal UTF-8 sequence\r\n *  and accepts non-canonical (overlong) codepoints\r\n *\r\n *  **``\"replace\"``** - replace any illegal UTF-8 sequence with the\r\n *  UTF-8 replacement character (i.e. ``\"\\\\ufffd\"``) and accepts\r\n *  non-canonical (overlong) codepoints\r\n *\r\n *  @returns: Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>\r\n */\r\nconst Utf8ErrorFuncs = Object.freeze({\r\n    error: errorFunc,\r\n    ignore: ignoreFunc,\r\n    replace: replaceFunc\r\n});\r\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\r\nfunction getUtf8CodePoints(_bytes, onError) {\r\n    if (onError == null) {\r\n        onError = Utf8ErrorFuncs.error;\r\n    }\r\n    const bytes = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_bytes, \"bytes\");\r\n    const result = [];\r\n    let i = 0;\r\n    // Invalid bytes are ignored\r\n    while (i < bytes.length) {\r\n        const c = bytes[i++];\r\n        // 0xxx xxxx\r\n        if (c >> 7 === 0) {\r\n            result.push(c);\r\n            continue;\r\n        }\r\n        // Multibyte; how many bytes left for this character?\r\n        let extraLength = null;\r\n        let overlongMask = null;\r\n        // 110x xxxx 10xx xxxx\r\n        if ((c & 0xe0) === 0xc0) {\r\n            extraLength = 1;\r\n            overlongMask = 0x7f;\r\n            // 1110 xxxx 10xx xxxx 10xx xxxx\r\n        }\r\n        else if ((c & 0xf0) === 0xe0) {\r\n            extraLength = 2;\r\n            overlongMask = 0x7ff;\r\n            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\r\n        }\r\n        else if ((c & 0xf8) === 0xf0) {\r\n            extraLength = 3;\r\n            overlongMask = 0xffff;\r\n        }\r\n        else {\r\n            if ((c & 0xc0) === 0x80) {\r\n                i += onError(\"UNEXPECTED_CONTINUE\", i - 1, bytes, result);\r\n            }\r\n            else {\r\n                i += onError(\"BAD_PREFIX\", i - 1, bytes, result);\r\n            }\r\n            continue;\r\n        }\r\n        // Do we have enough bytes in our data?\r\n        if (i - 1 + extraLength >= bytes.length) {\r\n            i += onError(\"OVERRUN\", i - 1, bytes, result);\r\n            continue;\r\n        }\r\n        // Remove the length prefix from the char\r\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\r\n        for (let j = 0; j < extraLength; j++) {\r\n            let nextChar = bytes[i];\r\n            // Invalid continuation byte\r\n            if ((nextChar & 0xc0) != 0x80) {\r\n                i += onError(\"MISSING_CONTINUE\", i, bytes, result);\r\n                res = null;\r\n                break;\r\n            }\r\n            ;\r\n            res = (res << 6) | (nextChar & 0x3f);\r\n            i++;\r\n        }\r\n        // See above loop for invalid continuation byte\r\n        if (res === null) {\r\n            continue;\r\n        }\r\n        // Maximum code point\r\n        if (res > 0x10ffff) {\r\n            i += onError(\"OUT_OF_RANGE\", i - 1 - extraLength, bytes, result, res);\r\n            continue;\r\n        }\r\n        // Reserved for UTF-16 surrogate halves\r\n        if (res >= 0xd800 && res <= 0xdfff) {\r\n            i += onError(\"UTF16_SURROGATE\", i - 1 - extraLength, bytes, result, res);\r\n            continue;\r\n        }\r\n        // Check for overlong sequences (more bytes than needed)\r\n        if (res <= overlongMask) {\r\n            i += onError(\"OVERLONG\", i - 1 - extraLength, bytes, result, res);\r\n            continue;\r\n        }\r\n        result.push(res);\r\n    }\r\n    return result;\r\n}\r\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\r\n/**\r\n *  Returns the UTF-8 byte representation of %%str%%.\r\n *\r\n *  If %%form%% is specified, the string is normalized.\r\n */\r\nfunction toUtf8Bytes(str, form) {\r\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (str) === \"string\", \"invalid string value\", \"str\", str);\r\n    if (form != null) {\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertNormalize)(form);\r\n        str = str.normalize(form);\r\n    }\r\n    let result = [];\r\n    for (let i = 0; i < str.length; i++) {\r\n        const c = str.charCodeAt(i);\r\n        if (c < 0x80) {\r\n            result.push(c);\r\n        }\r\n        else if (c < 0x800) {\r\n            result.push((c >> 6) | 0xc0);\r\n            result.push((c & 0x3f) | 0x80);\r\n        }\r\n        else if ((c & 0xfc00) == 0xd800) {\r\n            i++;\r\n            const c2 = str.charCodeAt(i);\r\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(i < str.length && ((c2 & 0xfc00) === 0xdc00), \"invalid surrogate pair\", \"str\", str);\r\n            // Surrogate Pair\r\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\r\n            result.push((pair >> 18) | 0xf0);\r\n            result.push(((pair >> 12) & 0x3f) | 0x80);\r\n            result.push(((pair >> 6) & 0x3f) | 0x80);\r\n            result.push((pair & 0x3f) | 0x80);\r\n        }\r\n        else {\r\n            result.push((c >> 12) | 0xe0);\r\n            result.push(((c >> 6) & 0x3f) | 0x80);\r\n            result.push((c & 0x3f) | 0x80);\r\n        }\r\n    }\r\n    return new Uint8Array(result);\r\n}\r\n;\r\n//export \r\nfunction _toUtf8String(codePoints) {\r\n    return codePoints.map((codePoint) => {\r\n        if (codePoint <= 0xffff) {\r\n            return String.fromCharCode(codePoint);\r\n        }\r\n        codePoint -= 0x10000;\r\n        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));\r\n    }).join(\"\");\r\n}\r\n/**\r\n *  Returns the string represented by the UTF-8 data %%bytes%%.\r\n *\r\n *  When %%onError%% function is specified, it is called on UTF-8\r\n *  errors allowing recovery using the [[Utf8ErrorFunc]] API.\r\n *  (default: [error](Utf8ErrorFuncs))\r\n */\r\nfunction toUtf8String(bytes, onError) {\r\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\r\n}\r\n/**\r\n *  Returns the UTF-8 code-points for %%str%%.\r\n *\r\n *  If %%form%% is specified, the string is normalized.\r\n */\r\nfunction toUtf8CodePoints(str, form) {\r\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\r\n}\r\n//# sourceMappingURL=utf8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy91dGY4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUM7QUFDeUI7QUFDOUQ7QUFDQSxJQUFJLDBEQUFjLHVDQUF1QyxTQUFTLEVBQUUsT0FBTztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLFFBQVEsMERBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0RBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSwwREFBYztBQUNsQjtBQUNBLFFBQVEsMkRBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFx1dGlsc1xcdXRmOC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIFVzaW5nIHN0cmluZ3MgaW4gRXRoZXJldW0gKG9yIGFueSBzZWN1cml0eS1iYXNkIHN5c3RlbSkgcmVxdWlyZXNcclxuICogIGFkZGl0aW9uYWwgY2FyZS4gVGhlc2UgdXRpbGl0aWVzIGF0dGVtcHQgdG8gbWl0aWdhdGUgc29tZSBvZiB0aGVcclxuICogIHNhZmV0eSBpc3N1ZXMgYXMgd2VsbCBhcyBwcm92aWRlIHRoZSBhYmlsaXR5IHRvIHJlY292ZXIgYW5kIGFuYWx5c2VcclxuICogIHN0cmluZ3MuXHJcbiAqXHJcbiAqICBAX3N1YnNlY3Rpb24gYXBpL3V0aWxzOlN0cmluZ3MgYW5kIFVURi04ICBbYWJvdXQtc3RyaW5nc11cclxuICovXHJcbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xyXG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCwgYXNzZXJ0Tm9ybWFsaXplIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XHJcbmZ1bmN0aW9uIGVycm9yRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XHJcbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgY29kZXBvaW50IGF0IG9mZnNldCAke29mZnNldH07ICR7cmVhc29ufWAsIFwiYnl0ZXNcIiwgYnl0ZXMpO1xyXG59XHJcbmZ1bmN0aW9uIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xyXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gaW52YWxpZCBwcmVmaXggKGluY2x1ZGluZyBzdHJheSBjb250aW51YXRpb24pLCBza2lwIGFueSBhZGRpdGlvbmFsIGNvbnRpbnVhdGlvbiBieXRlc1xyXG4gICAgaWYgKHJlYXNvbiA9PT0gXCJCQURfUFJFRklYXCIgfHwgcmVhc29uID09PSBcIlVORVhQRUNURURfQ09OVElOVUVcIikge1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBmb3IgKGxldCBvID0gb2Zmc2V0ICsgMTsgbyA8IGJ5dGVzLmxlbmd0aDsgbysrKSB7XHJcbiAgICAgICAgICAgIGlmIChieXRlc1tvXSA+PiA2ICE9PSAweDAyKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgfVxyXG4gICAgLy8gVGhpcyBieXRlIHJ1bnMgdXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHNvIGp1c3QganVtcCB0byB0aGUgZW5kXHJcbiAgICAvLyAoYnV0IHRoZSBmaXJzdCBieXRlIHdhcyByZWFkIGFscmVhZHkgcmVhZCBhbmQgdGhlcmVmb3JlIHNraXBwZWQpXHJcbiAgICBpZiAocmVhc29uID09PSBcIk9WRVJSVU5cIikge1xyXG4gICAgICAgIHJldHVybiBieXRlcy5sZW5ndGggLSBvZmZzZXQgLSAxO1xyXG4gICAgfVxyXG4gICAgLy8gTm90aGluZyB0byBza2lwXHJcbiAgICByZXR1cm4gMDtcclxufVxyXG5mdW5jdGlvbiByZXBsYWNlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XHJcbiAgICAvLyBPdmVybG9uZyByZXByZXNlbnRhdGlvbnMgYXJlIG90aGVyd2lzZSBcInZhbGlkXCIgY29kZSBwb2ludHM7IGp1c3Qgbm9uLWRlaXN0aW5ndGlzaGVkXHJcbiAgICBpZiAocmVhc29uID09PSBcIk9WRVJMT05HXCIpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKGJhZENvZGVwb2ludCkgPT09IFwibnVtYmVyXCIsIFwiaW52YWxpZCBiYWQgY29kZSBwb2ludCBmb3IgcmVwbGFjZW1lbnRcIiwgXCJiYWRDb2RlcG9pbnRcIiwgYmFkQ29kZXBvaW50KTtcclxuICAgICAgICBvdXRwdXQucHVzaChiYWRDb2RlcG9pbnQpO1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgLy8gUHV0IHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaW50byB0aGUgb3V0cHV0XHJcbiAgICBvdXRwdXQucHVzaCgweGZmZmQpO1xyXG4gICAgLy8gT3RoZXJ3aXNlLCBwcm9jZXNzIGFzIGlmIGlnbm9yaW5nIGVycm9yc1xyXG4gICAgcmV0dXJuIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCk7XHJcbn1cclxuLyoqXHJcbiAqICBBIGhhbmRmdWwgb2YgcG9wdWxhciwgYnVpbHQtaW4gVVRGLTggZXJyb3IgaGFuZGxpbmcgc3RyYXRlZ2llcy5cclxuICpcclxuICogICoqYGBcImVycm9yXCJgYCoqIC0gdGhyb3dzIG9uIEFOWSBpbGxlZ2FsIFVURi04IHNlcXVlbmNlIG9yXHJcbiAqICBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50cyAodGhpcyBpcyB0aGUgZGVmYXVsdClcclxuICpcclxuICogICoqYGBcImlnbm9yZVwiYGAqKiAtIHNpbGVudGx5IGRyb3BzIGFueSBpbGxlZ2FsIFVURi04IHNlcXVlbmNlXHJcbiAqICBhbmQgYWNjZXB0cyBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50c1xyXG4gKlxyXG4gKiAgKipgYFwicmVwbGFjZVwiYGAqKiAtIHJlcGxhY2UgYW55IGlsbGVnYWwgVVRGLTggc2VxdWVuY2Ugd2l0aCB0aGVcclxuICogIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoaS5lLiBgYFwiXFxcXHVmZmZkXCJgYCkgYW5kIGFjY2VwdHNcclxuICogIG5vbi1jYW5vbmljYWwgKG92ZXJsb25nKSBjb2RlcG9pbnRzXHJcbiAqXHJcbiAqICBAcmV0dXJuczogUmVjb3JkPFwiZXJyb3JcIiB8IFwiaWdub3JlXCIgfCBcInJlcGxhY2VcIiwgVXRmOEVycm9yRnVuYz5cclxuICovXHJcbmV4cG9ydCBjb25zdCBVdGY4RXJyb3JGdW5jcyA9IE9iamVjdC5mcmVlemUoe1xyXG4gICAgZXJyb3I6IGVycm9yRnVuYyxcclxuICAgIGlnbm9yZTogaWdub3JlRnVuYyxcclxuICAgIHJlcGxhY2U6IHJlcGxhY2VGdW5jXHJcbn0pO1xyXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzMzU2NDkzL2RlY29kZS11dGYtOC13aXRoLWphdmFzY3JpcHQjMTM2OTE0OTlcclxuZnVuY3Rpb24gZ2V0VXRmOENvZGVQb2ludHMoX2J5dGVzLCBvbkVycm9yKSB7XHJcbiAgICBpZiAob25FcnJvciA9PSBudWxsKSB7XHJcbiAgICAgICAgb25FcnJvciA9IFV0ZjhFcnJvckZ1bmNzLmVycm9yO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhfYnl0ZXMsIFwiYnl0ZXNcIik7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIGxldCBpID0gMDtcclxuICAgIC8vIEludmFsaWQgYnl0ZXMgYXJlIGlnbm9yZWRcclxuICAgIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgYyA9IGJ5dGVzW2krK107XHJcbiAgICAgICAgLy8gMHh4eCB4eHh4XHJcbiAgICAgICAgaWYgKGMgPj4gNyA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChjKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE11bHRpYnl0ZTsgaG93IG1hbnkgYnl0ZXMgbGVmdCBmb3IgdGhpcyBjaGFyYWN0ZXI/XHJcbiAgICAgICAgbGV0IGV4dHJhTGVuZ3RoID0gbnVsbDtcclxuICAgICAgICBsZXQgb3ZlcmxvbmdNYXNrID0gbnVsbDtcclxuICAgICAgICAvLyAxMTB4IHh4eHggMTB4eCB4eHh4XHJcbiAgICAgICAgaWYgKChjICYgMHhlMCkgPT09IDB4YzApIHtcclxuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAxO1xyXG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweDdmO1xyXG4gICAgICAgICAgICAvLyAxMTEwIHh4eHggMTB4eCB4eHh4IDEweHggeHh4eFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjApID09PSAweGUwKSB7XHJcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMjtcclxuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZmY7XHJcbiAgICAgICAgICAgIC8vIDExMTEgMHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4IDEweHggeHh4eFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjgpID09PSAweGYwKSB7XHJcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMztcclxuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHhmZmZmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKChjICYgMHhjMCkgPT09IDB4ODApIHtcclxuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIlVORVhQRUNURURfQ09OVElOVUVcIiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiQkFEX1BSRUZJWFwiLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvIHdlIGhhdmUgZW5vdWdoIGJ5dGVzIGluIG91ciBkYXRhP1xyXG4gICAgICAgIGlmIChpIC0gMSArIGV4dHJhTGVuZ3RoID49IGJ5dGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVkVSUlVOXCIsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGVuZ3RoIHByZWZpeCBmcm9tIHRoZSBjaGFyXHJcbiAgICAgICAgbGV0IHJlcyA9IGMgJiAoKDEgPDwgKDggLSBleHRyYUxlbmd0aCAtIDEpKSAtIDEpO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZXh0cmFMZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBsZXQgbmV4dENoYXIgPSBieXRlc1tpXTtcclxuICAgICAgICAgICAgLy8gSW52YWxpZCBjb250aW51YXRpb24gYnl0ZVxyXG4gICAgICAgICAgICBpZiAoKG5leHRDaGFyICYgMHhjMCkgIT0gMHg4MCkge1xyXG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiTUlTU0lOR19DT05USU5VRVwiLCBpLCBieXRlcywgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHJlcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIHJlcyA9IChyZXMgPDwgNikgfCAobmV4dENoYXIgJiAweDNmKTtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTZWUgYWJvdmUgbG9vcCBmb3IgaW52YWxpZCBjb250aW51YXRpb24gYnl0ZVxyXG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1heGltdW0gY29kZSBwb2ludFxyXG4gICAgICAgIGlmIChyZXMgPiAweDEwZmZmZikge1xyXG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVVRfT0ZfUkFOR0VcIiwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlc2VydmVkIGZvciBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xyXG4gICAgICAgIGlmIChyZXMgPj0gMHhkODAwICYmIHJlcyA8PSAweGRmZmYpIHtcclxuICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiVVRGMTZfU1VSUk9HQVRFXCIsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayBmb3Igb3Zlcmxvbmcgc2VxdWVuY2VzIChtb3JlIGJ5dGVzIHRoYW4gbmVlZGVkKVxyXG4gICAgICAgIGlmIChyZXMgPD0gb3ZlcmxvbmdNYXNrKSB7XHJcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk9WRVJMT05HXCIsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQucHVzaChyZXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4NzI5NDA1L2hvdy10by1jb252ZXJ0LXV0Zjgtc3RyaW5nLXRvLWJ5dGUtYXJyYXlcclxuLyoqXHJcbiAqICBSZXR1cm5zIHRoZSBVVEYtOCBieXRlIHJlcHJlc2VudGF0aW9uIG9mICUlc3RyJSUuXHJcbiAqXHJcbiAqICBJZiAlJWZvcm0lJSBpcyBzcGVjaWZpZWQsIHRoZSBzdHJpbmcgaXMgbm9ybWFsaXplZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1V0ZjhCeXRlcyhzdHIsIGZvcm0pIHtcclxuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoc3RyKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIHN0cmluZyB2YWx1ZVwiLCBcInN0clwiLCBzdHIpO1xyXG4gICAgaWYgKGZvcm0gIT0gbnVsbCkge1xyXG4gICAgICAgIGFzc2VydE5vcm1hbGl6ZShmb3JtKTtcclxuICAgICAgICBzdHIgPSBzdHIubm9ybWFsaXplKGZvcm0pO1xyXG4gICAgfVxyXG4gICAgbGV0IHJlc3VsdCA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgPj4gNikgfCAweGMwKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgJiAweDNmKSB8IDB4ODApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT0gMHhkODAwKSB7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgY29uc3QgYzIgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaSA8IHN0ci5sZW5ndGggJiYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCksIFwiaW52YWxpZCBzdXJyb2dhdGUgcGFpclwiLCBcInN0clwiLCBzdHIpO1xyXG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxyXG4gICAgICAgICAgICBjb25zdCBwYWlyID0gMHgxMDAwMCArICgoYyAmIDB4MDNmZikgPDwgMTApICsgKGMyICYgMHgwM2ZmKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgPj4gMTgpIHwgMHhmMCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiAxMikgJiAweDNmKSB8IDB4ODApO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gNikgJiAweDNmKSB8IDB4ODApO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciAmIDB4M2YpIHwgMHg4MCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiAxMikgfCAweGUwKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChjID4+IDYpICYgMHgzZikgfCAweDgwKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgJiAweDNmKSB8IDB4ODApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpO1xyXG59XHJcbjtcclxuLy9leHBvcnQgXHJcbmZ1bmN0aW9uIF90b1V0ZjhTdHJpbmcoY29kZVBvaW50cykge1xyXG4gICAgcmV0dXJuIGNvZGVQb2ludHMubWFwKChjb2RlUG9pbnQpID0+IHtcclxuICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcclxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoKChjb2RlUG9pbnQgPj4gMTApICYgMHgzZmYpICsgMHhkODAwKSwgKChjb2RlUG9pbnQgJiAweDNmZikgKyAweGRjMDApKTtcclxuICAgIH0pLmpvaW4oXCJcIik7XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50ZWQgYnkgdGhlIFVURi04IGRhdGEgJSVieXRlcyUlLlxyXG4gKlxyXG4gKiAgV2hlbiAlJW9uRXJyb3IlJSBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IGlzIGNhbGxlZCBvbiBVVEYtOFxyXG4gKiAgZXJyb3JzIGFsbG93aW5nIHJlY292ZXJ5IHVzaW5nIHRoZSBbW1V0ZjhFcnJvckZ1bmNdXSBBUEkuXHJcbiAqICAoZGVmYXVsdDogW2Vycm9yXShVdGY4RXJyb3JGdW5jcykpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4U3RyaW5nKGJ5dGVzLCBvbkVycm9yKSB7XHJcbiAgICByZXR1cm4gX3RvVXRmOFN0cmluZyhnZXRVdGY4Q29kZVBvaW50cyhieXRlcywgb25FcnJvcikpO1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyB0aGUgVVRGLTggY29kZS1wb2ludHMgZm9yICUlc3RyJSUuXHJcbiAqXHJcbiAqICBJZiAlJWZvcm0lJSBpcyBzcGVjaWZpZWQsIHRoZSBzdHJpbmcgaXMgbm9ybWFsaXplZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1V0ZjhDb2RlUG9pbnRzKHN0ciwgZm9ybSkge1xyXG4gICAgcmV0dXJuIGdldFV0ZjhDb2RlUG9pbnRzKHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSkpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0ZjguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/uuid.js":
/*!***************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/uuid.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uuidV4: () => (/* binding */ uuidV4)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/**\r\n *  Explain UUID and link to RFC here.\r\n *\r\n *  @_subsection: api/utils:UUID  [about-uuid]\r\n */\r\n\r\n/**\r\n *  Returns the version 4 [[link-uuid]] for the %%randomBytes%%.\r\n *\r\n *  @see: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\r\n */\r\nfunction uuidV4(randomBytes) {\r\n    const bytes = (0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(randomBytes, \"randomBytes\");\r\n    // Section: 4.1.3:\r\n    // - time_hi_and_version[12:16] = 0b0100\r\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\r\n    // Section 4.4\r\n    // - clock_seq_hi_and_reserved[6] = 0b0\r\n    // - clock_seq_hi_and_reserved[7] = 0b1\r\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\r\n    const value = (0,_data_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\r\n    return [\r\n        value.substring(2, 10),\r\n        value.substring(10, 14),\r\n        value.substring(14, 18),\r\n        value.substring(18, 22),\r\n        value.substring(22, 34),\r\n    ].join(\"-\");\r\n}\r\n//# sourceMappingURL=uuid.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy91dWlkLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxrQkFBa0Isa0RBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaURBQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHV0aWxzXFx1dWlkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgRXhwbGFpbiBVVUlEIGFuZCBsaW5rIHRvIFJGQyBoZXJlLlxyXG4gKlxyXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvdXRpbHM6VVVJRCAgW2Fib3V0LXV1aWRdXHJcbiAqL1xyXG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSB9IGZyb20gXCIuL2RhdGEuanNcIjtcclxuLyoqXHJcbiAqICBSZXR1cm5zIHRoZSB2ZXJzaW9uIDQgW1tsaW5rLXV1aWRdXSBmb3IgdGhlICUlcmFuZG9tQnl0ZXMlJS5cclxuICpcclxuICogIEBzZWU6IGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmM0MTIyLnR4dCAoU2VjdGlvbiA0LjQpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXVpZFY0KHJhbmRvbUJ5dGVzKSB7XHJcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHJhbmRvbUJ5dGVzLCBcInJhbmRvbUJ5dGVzXCIpO1xyXG4gICAgLy8gU2VjdGlvbjogNC4xLjM6XHJcbiAgICAvLyAtIHRpbWVfaGlfYW5kX3ZlcnNpb25bMTI6MTZdID0gMGIwMTAwXHJcbiAgICBieXRlc1s2XSA9IChieXRlc1s2XSAmIDB4MGYpIHwgMHg0MDtcclxuICAgIC8vIFNlY3Rpb24gNC40XHJcbiAgICAvLyAtIGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRbNl0gPSAwYjBcclxuICAgIC8vIC0gY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZFs3XSA9IDBiMVxyXG4gICAgYnl0ZXNbOF0gPSAoYnl0ZXNbOF0gJiAweDNmKSB8IDB4ODA7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGhleGxpZnkoYnl0ZXMpO1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMiwgMTApLFxyXG4gICAgICAgIHZhbHVlLnN1YnN0cmluZygxMCwgMTQpLFxyXG4gICAgICAgIHZhbHVlLnN1YnN0cmluZygxNCwgMTgpLFxyXG4gICAgICAgIHZhbHVlLnN1YnN0cmluZygxOCwgMjIpLFxyXG4gICAgICAgIHZhbHVlLnN1YnN0cmluZygyMiwgMzQpLFxyXG4gICAgXS5qb2luKFwiLVwiKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dWlkLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/uuid.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/base-wallet.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/wallet/base-wallet.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseWallet: () => (/* binding */ BaseWallet)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../address/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../hash/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/index.js\");\n/* harmony import */ var _providers_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../providers/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transaction/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n *  The **BaseWallet** is a stream-lined implementation of a\r\n *  [[Signer]] that operates with a private key.\r\n *\r\n *  It is preferred to use the [[Wallet]] class, as it offers\r\n *  additional functionality and simplifies loading a variety\r\n *  of JSON formats, Mnemonic Phrases, etc.\r\n *\r\n *  This class may be of use for those attempting to implement\r\n *  a minimal Signer.\r\n */\r\nclass BaseWallet extends _providers_index_js__WEBPACK_IMPORTED_MODULE_0__.AbstractSigner {\r\n    /**\r\n     *  The wallet address.\r\n     */\r\n    address;\r\n    #signingKey;\r\n    /**\r\n     *  Creates a new BaseWallet for %%privateKey%%, optionally\r\n     *  connected to %%provider%%.\r\n     *\r\n     *  If %%provider%% is not specified, only offline methods can\r\n     *  be used.\r\n     */\r\n    constructor(privateKey, provider) {\r\n        super(provider);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(privateKey && typeof (privateKey.sign) === \"function\", \"invalid private key\", \"privateKey\", \"[ REDACTED ]\");\r\n        this.#signingKey = privateKey;\r\n        const address = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_2__.computeAddress)(this.signingKey.publicKey);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { address });\r\n    }\r\n    // Store private values behind getters to reduce visibility\r\n    // in console.log\r\n    /**\r\n     *  The [[SigningKey]] used for signing payloads.\r\n     */\r\n    get signingKey() { return this.#signingKey; }\r\n    /**\r\n     *  The private key for this wallet.\r\n     */\r\n    get privateKey() { return this.signingKey.privateKey; }\r\n    async getAddress() { return this.address; }\r\n    connect(provider) {\r\n        return new BaseWallet(this.#signingKey, provider);\r\n    }\r\n    async signTransaction(tx) {\r\n        tx = (0,_providers_index_js__WEBPACK_IMPORTED_MODULE_0__.copyRequest)(tx);\r\n        // Replace any Addressable or ENS name with an address\r\n        const { to, from } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveProperties)({\r\n            to: (tx.to ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.resolveAddress)(tx.to, this) : undefined),\r\n            from: (tx.from ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.resolveAddress)(tx.from, this) : undefined)\r\n        });\r\n        if (to != null) {\r\n            tx.to = to;\r\n        }\r\n        if (from != null) {\r\n            tx.from = from;\r\n        }\r\n        if (tx.from != null) {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)((tx.from)) === this.address, \"transaction from address mismatch\", \"tx.from\", tx.from);\r\n            delete tx.from;\r\n        }\r\n        // Build the transaction\r\n        const btx = _transaction_index_js__WEBPACK_IMPORTED_MODULE_2__.Transaction.from(tx);\r\n        btx.signature = this.signingKey.sign(btx.unsignedHash);\r\n        return btx.serialized;\r\n    }\r\n    async signMessage(message) {\r\n        return this.signMessageSync(message);\r\n    }\r\n    // @TODO: Add a secialized signTx and signTyped sync that enforces\r\n    // all parameters are known?\r\n    /**\r\n     *  Returns the signature for %%message%% signed with this wallet.\r\n     */\r\n    signMessageSync(message) {\r\n        return this.signingKey.sign((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_4__.hashMessage)(message)).serialized;\r\n    }\r\n    /**\r\n     *  Returns the Authorization for %%auth%%.\r\n     */\r\n    authorizeSync(auth) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof (auth.address) === \"string\", \"invalid address for authorizeSync\", \"auth.address\", auth);\r\n        const signature = this.signingKey.sign((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_4__.hashAuthorization)(auth));\r\n        return Object.assign({}, {\r\n            address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(auth.address),\r\n            nonce: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(auth.nonce || 0),\r\n            chainId: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(auth.chainId || 0),\r\n        }, { signature });\r\n    }\r\n    /**\r\n     *  Resolves to the Authorization for %%auth%%.\r\n     */\r\n    async authorize(auth) {\r\n        auth = Object.assign({}, auth, {\r\n            address: await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.resolveAddress)(auth.address, this)\r\n        });\r\n        return this.authorizeSync(await this.populateAuthorization(auth));\r\n    }\r\n    async signTypedData(domain, types, value) {\r\n        // Populate any ENS names\r\n        const populated = await _hash_index_js__WEBPACK_IMPORTED_MODULE_4__.TypedDataEncoder.resolveNames(domain, types, value, async (name) => {\r\n            // @TODO: this should use resolveName; addresses don't\r\n            //        need a provider\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.provider != null, \"cannot resolve ENS names without a provider\", \"UNSUPPORTED_OPERATION\", {\r\n                operation: \"resolveName\",\r\n                info: { name }\r\n            });\r\n            const address = await this.provider.resolveName(name);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(address != null, \"unconfigured ENS name\", \"UNCONFIGURED_NAME\", {\r\n                value: name\r\n            });\r\n            return address;\r\n        });\r\n        return this.signingKey.sign(_hash_index_js__WEBPACK_IMPORTED_MODULE_4__.TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;\r\n    }\r\n}\r\n//# sourceMappingURL=base-wallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvYmFzZS13YWxsZXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlFO0FBQ21CO0FBQ2hCO0FBQ0U7QUFDcUM7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlCQUF5QiwrREFBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYztBQUN0QjtBQUNBLHdCQUF3QixxRUFBYztBQUN0QyxRQUFRLGlFQUFnQixTQUFTLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdFQUFXO0FBQ3hCO0FBQ0EsZ0JBQWdCLFdBQVcsUUFBUSxrRUFBaUI7QUFDcEQseUJBQXlCLGlFQUFjO0FBQ3ZDLDZCQUE2QixpRUFBYztBQUMzQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUFjLENBQUMsNkRBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhEQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyREFBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYztBQUN0QiwrQ0FBK0MsaUVBQWlCO0FBQ2hFLCtCQUErQjtBQUMvQixxQkFBcUIsNkRBQVU7QUFDL0IsbUJBQW1CLDBEQUFTO0FBQzVCLHFCQUFxQiwwREFBUztBQUM5QixTQUFTLElBQUksV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLDJCQUEyQixpRUFBYztBQUN6QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNERBQWdCO0FBQ2hELG1EQUFtRDtBQUNuRDtBQUNBLFlBQVksdURBQU07QUFDbEI7QUFDQSx3QkFBd0I7QUFDeEIsYUFBYTtBQUNiO0FBQ0EsWUFBWSx1REFBTTtBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsNERBQWdCO0FBQ3BEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFx3YWxsZXRcXGJhc2Utd2FsbGV0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEFkZHJlc3MsIHJlc29sdmVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgaGFzaEF1dGhvcml6YXRpb24sIGhhc2hNZXNzYWdlLCBUeXBlZERhdGFFbmNvZGVyIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgQWJzdHJhY3RTaWduZXIsIGNvcHlSZXF1ZXN0IH0gZnJvbSBcIi4uL3Byb3ZpZGVycy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBjb21wdXRlQWRkcmVzcywgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcclxuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCByZXNvbHZlUHJvcGVydGllcywgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG4vKipcclxuICogIFRoZSAqKkJhc2VXYWxsZXQqKiBpcyBhIHN0cmVhbS1saW5lZCBpbXBsZW1lbnRhdGlvbiBvZiBhXHJcbiAqICBbW1NpZ25lcl1dIHRoYXQgb3BlcmF0ZXMgd2l0aCBhIHByaXZhdGUga2V5LlxyXG4gKlxyXG4gKiAgSXQgaXMgcHJlZmVycmVkIHRvIHVzZSB0aGUgW1tXYWxsZXRdXSBjbGFzcywgYXMgaXQgb2ZmZXJzXHJcbiAqICBhZGRpdGlvbmFsIGZ1bmN0aW9uYWxpdHkgYW5kIHNpbXBsaWZpZXMgbG9hZGluZyBhIHZhcmlldHlcclxuICogIG9mIEpTT04gZm9ybWF0cywgTW5lbW9uaWMgUGhyYXNlcywgZXRjLlxyXG4gKlxyXG4gKiAgVGhpcyBjbGFzcyBtYXkgYmUgb2YgdXNlIGZvciB0aG9zZSBhdHRlbXB0aW5nIHRvIGltcGxlbWVudFxyXG4gKiAgYSBtaW5pbWFsIFNpZ25lci5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBCYXNlV2FsbGV0IGV4dGVuZHMgQWJzdHJhY3RTaWduZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHdhbGxldCBhZGRyZXNzLlxyXG4gICAgICovXHJcbiAgICBhZGRyZXNzO1xyXG4gICAgI3NpZ25pbmdLZXk7XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgbmV3IEJhc2VXYWxsZXQgZm9yICUlcHJpdmF0ZUtleSUlLCBvcHRpb25hbGx5XHJcbiAgICAgKiAgY29ubmVjdGVkIHRvICUlcHJvdmlkZXIlJS5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgJSVwcm92aWRlciUlIGlzIG5vdCBzcGVjaWZpZWQsIG9ubHkgb2ZmbGluZSBtZXRob2RzIGNhblxyXG4gICAgICogIGJlIHVzZWQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGVLZXksIHByb3ZpZGVyKSB7XHJcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHByaXZhdGVLZXkgJiYgdHlwZW9mIChwcml2YXRlS2V5LnNpZ24pID09PSBcImZ1bmN0aW9uXCIsIFwiaW52YWxpZCBwcml2YXRlIGtleVwiLCBcInByaXZhdGVLZXlcIiwgXCJbIFJFREFDVEVEIF1cIik7XHJcbiAgICAgICAgdGhpcy4jc2lnbmluZ0tleSA9IHByaXZhdGVLZXk7XHJcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGNvbXB1dGVBZGRyZXNzKHRoaXMuc2lnbmluZ0tleS5wdWJsaWNLZXkpO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhZGRyZXNzIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gU3RvcmUgcHJpdmF0ZSB2YWx1ZXMgYmVoaW5kIGdldHRlcnMgdG8gcmVkdWNlIHZpc2liaWxpdHlcclxuICAgIC8vIGluIGNvbnNvbGUubG9nXHJcbiAgICAvKipcclxuICAgICAqICBUaGUgW1tTaWduaW5nS2V5XV0gdXNlZCBmb3Igc2lnbmluZyBwYXlsb2Fkcy5cclxuICAgICAqL1xyXG4gICAgZ2V0IHNpZ25pbmdLZXkoKSB7IHJldHVybiB0aGlzLiNzaWduaW5nS2V5OyB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgcHJpdmF0ZSBrZXkgZm9yIHRoaXMgd2FsbGV0LlxyXG4gICAgICovXHJcbiAgICBnZXQgcHJpdmF0ZUtleSgpIHsgcmV0dXJuIHRoaXMuc2lnbmluZ0tleS5wcml2YXRlS2V5OyB9XHJcbiAgICBhc3luYyBnZXRBZGRyZXNzKCkgeyByZXR1cm4gdGhpcy5hZGRyZXNzOyB9XHJcbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlV2FsbGV0KHRoaXMuI3NpZ25pbmdLZXksIHByb3ZpZGVyKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0eCkge1xyXG4gICAgICAgIHR4ID0gY29weVJlcXVlc3QodHgpO1xyXG4gICAgICAgIC8vIFJlcGxhY2UgYW55IEFkZHJlc3NhYmxlIG9yIEVOUyBuYW1lIHdpdGggYW4gYWRkcmVzc1xyXG4gICAgICAgIGNvbnN0IHsgdG8sIGZyb20gfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgdG86ICh0eC50byA/IHJlc29sdmVBZGRyZXNzKHR4LnRvLCB0aGlzKSA6IHVuZGVmaW5lZCksXHJcbiAgICAgICAgICAgIGZyb206ICh0eC5mcm9tID8gcmVzb2x2ZUFkZHJlc3ModHguZnJvbSwgdGhpcykgOiB1bmRlZmluZWQpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRvICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdHgudG8gPSB0bztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZyb20gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0eC5mcm9tID0gZnJvbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR4LmZyb20gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChnZXRBZGRyZXNzKCh0eC5mcm9tKSkgPT09IHRoaXMuYWRkcmVzcywgXCJ0cmFuc2FjdGlvbiBmcm9tIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0eC5mcm9tXCIsIHR4LmZyb20pO1xyXG4gICAgICAgICAgICBkZWxldGUgdHguZnJvbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQnVpbGQgdGhlIHRyYW5zYWN0aW9uXHJcbiAgICAgICAgY29uc3QgYnR4ID0gVHJhbnNhY3Rpb24uZnJvbSh0eCk7XHJcbiAgICAgICAgYnR4LnNpZ25hdHVyZSA9IHRoaXMuc2lnbmluZ0tleS5zaWduKGJ0eC51bnNpZ25lZEhhc2gpO1xyXG4gICAgICAgIHJldHVybiBidHguc2VyaWFsaXplZDtcclxuICAgIH1cclxuICAgIGFzeW5jIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zaWduTWVzc2FnZVN5bmMobWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICAvLyBAVE9ETzogQWRkIGEgc2VjaWFsaXplZCBzaWduVHggYW5kIHNpZ25UeXBlZCBzeW5jIHRoYXQgZW5mb3JjZXNcclxuICAgIC8vIGFsbCBwYXJhbWV0ZXJzIGFyZSBrbm93bj9cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIHNpZ25hdHVyZSBmb3IgJSVtZXNzYWdlJSUgc2lnbmVkIHdpdGggdGhpcyB3YWxsZXQuXHJcbiAgICAgKi9cclxuICAgIHNpZ25NZXNzYWdlU3luYyhtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmluZ0tleS5zaWduKGhhc2hNZXNzYWdlKG1lc3NhZ2UpKS5zZXJpYWxpemVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgQXV0aG9yaXphdGlvbiBmb3IgJSVhdXRoJSUuXHJcbiAgICAgKi9cclxuICAgIGF1dGhvcml6ZVN5bmMoYXV0aCkge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoYXV0aC5hZGRyZXNzKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIGFkZHJlc3MgZm9yIGF1dGhvcml6ZVN5bmNcIiwgXCJhdXRoLmFkZHJlc3NcIiwgYXV0aCk7XHJcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdGhpcy5zaWduaW5nS2V5LnNpZ24oaGFzaEF1dGhvcml6YXRpb24oYXV0aCkpO1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB7XHJcbiAgICAgICAgICAgIGFkZHJlc3M6IGdldEFkZHJlc3MoYXV0aC5hZGRyZXNzKSxcclxuICAgICAgICAgICAgbm9uY2U6IGdldEJpZ0ludChhdXRoLm5vbmNlIHx8IDApLFxyXG4gICAgICAgICAgICBjaGFpbklkOiBnZXRCaWdJbnQoYXV0aC5jaGFpbklkIHx8IDApLFxyXG4gICAgICAgIH0sIHsgc2lnbmF0dXJlIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIEF1dGhvcml6YXRpb24gZm9yICUlYXV0aCUlLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBhdXRob3JpemUoYXV0aCkge1xyXG4gICAgICAgIGF1dGggPSBPYmplY3QuYXNzaWduKHt9LCBhdXRoLCB7XHJcbiAgICAgICAgICAgIGFkZHJlc3M6IGF3YWl0IHJlc29sdmVBZGRyZXNzKGF1dGguYWRkcmVzcywgdGhpcylcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdXRob3JpemVTeW5jKGF3YWl0IHRoaXMucG9wdWxhdGVBdXRob3JpemF0aW9uKGF1dGgpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHNpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcclxuICAgICAgICAvLyBQb3B1bGF0ZSBhbnkgRU5TIG5hbWVzXHJcbiAgICAgICAgY29uc3QgcG9wdWxhdGVkID0gYXdhaXQgVHlwZWREYXRhRW5jb2Rlci5yZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIGFzeW5jIChuYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEBUT0RPOiB0aGlzIHNob3VsZCB1c2UgcmVzb2x2ZU5hbWU7IGFkZHJlc3NlcyBkb24ndFxyXG4gICAgICAgICAgICAvLyAgICAgICAgbmVlZCBhIHByb3ZpZGVyXHJcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLnByb3ZpZGVyICE9IG51bGwsIFwiY2Fubm90IHJlc29sdmUgRU5TIG5hbWVzIHdpdGhvdXQgYSBwcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIixcclxuICAgICAgICAgICAgICAgIGluZm86IHsgbmFtZSB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKTtcclxuICAgICAgICAgICAgYXNzZXJ0KGFkZHJlc3MgIT0gbnVsbCwgXCJ1bmNvbmZpZ3VyZWQgRU5TIG5hbWVcIiwgXCJVTkNPTkZJR1VSRURfTkFNRVwiLCB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmFtZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmluZ0tleS5zaWduKFR5cGVkRGF0YUVuY29kZXIuaGFzaChwb3B1bGF0ZWQuZG9tYWluLCB0eXBlcywgcG9wdWxhdGVkLnZhbHVlKSkuc2VyaWFsaXplZDtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLXdhbGxldC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/base-wallet.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/hdwallet.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/wallet/hdwallet.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HDNodeVoidWallet: () => (/* binding */ HDNodeVoidWallet),\n/* harmony export */   HDNodeWallet: () => (/* binding */ HDNodeWallet),\n/* harmony export */   defaultPath: () => (/* binding */ defaultPath),\n/* harmony export */   getAccountPath: () => (/* binding */ getAccountPath),\n/* harmony export */   getIndexedAccountPath: () => (/* binding */ getIndexedAccountPath)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _providers_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../providers/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/providers/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transaction/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../wordlists/lang-en.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/lang-en.js\");\n/* harmony import */ var _base_wallet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base-wallet.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/base-wallet.js\");\n/* harmony import */ var _mnemonic_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mnemonic.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/mnemonic.js\");\n/* harmony import */ var _json_keystore_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./json-keystore.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/json-keystore.js\");\n/**\r\n *  Explain HD Wallets..\r\n *\r\n *  @_subsection: api/wallet:HD Wallets  [hd-wallets]\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n *  The default derivation path for Ethereum HD Nodes. (i.e. ``\"m/44'/60'/0'/0/0\"``)\r\n */\r\nconst defaultPath = \"m/44'/60'/0'/0/0\";\r\n// \"Bitcoin seed\"\r\nconst MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);\r\nconst HardenedBit = 0x80000000;\r\nconst N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\r\nconst Nibbles = \"0123456789abcdef\";\r\nfunction zpad(value, length) {\r\n    let result = \"\";\r\n    while (value) {\r\n        result = Nibbles[value % 16] + result;\r\n        value = Math.trunc(value / 16);\r\n    }\r\n    while (result.length < length * 2) {\r\n        result = \"0\" + result;\r\n    }\r\n    return \"0x\" + result;\r\n}\r\nfunction encodeBase58Check(_value) {\r\n    const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(_value);\r\n    const check = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.sha256)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.sha256)(value)), 0, 4);\r\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([value, check]);\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.encodeBase58)(bytes);\r\n}\r\nconst _guard = {};\r\nfunction ser_I(index, chainCode, publicKey, privateKey) {\r\n    const data = new Uint8Array(37);\r\n    if (index & HardenedBit) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(privateKey != null, \"cannot derive child of neutered node\", \"UNSUPPORTED_OPERATION\", {\r\n            operation: \"deriveChild\"\r\n        });\r\n        // Data = 0x00 || ser_256(k_par)\r\n        data.set((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(privateKey), 1);\r\n    }\r\n    else {\r\n        // Data = ser_p(point(k_par))\r\n        data.set((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(publicKey));\r\n    }\r\n    // Data += ser_32(i)\r\n    for (let i = 24; i >= 0; i -= 8) {\r\n        data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff);\r\n    }\r\n    const I = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.computeHmac)(\"sha512\", chainCode, data));\r\n    return { IL: I.slice(0, 32), IR: I.slice(32) };\r\n}\r\nfunction derivePath(node, path) {\r\n    const components = path.split(\"/\");\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(components.length > 0, \"invalid path\", \"path\", path);\r\n    if (components[0] === \"m\") {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(node.depth === 0, `cannot derive root path (i.e. path starting with \"m/\") for a node at non-zero depth ${node.depth}`, \"path\", path);\r\n        components.shift();\r\n    }\r\n    let result = node;\r\n    for (let i = 0; i < components.length; i++) {\r\n        const component = components[i];\r\n        if (component.match(/^[0-9]+'$/)) {\r\n            const index = parseInt(component.substring(0, component.length - 1));\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index < HardenedBit, \"invalid path index\", `path[${i}]`, component);\r\n            result = result.deriveChild(HardenedBit + index);\r\n        }\r\n        else if (component.match(/^[0-9]+$/)) {\r\n            const index = parseInt(component);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index < HardenedBit, \"invalid path index\", `path[${i}]`, component);\r\n            result = result.deriveChild(index);\r\n        }\r\n        else {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid path component\", `path[${i}]`, component);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n *  An **HDNodeWallet** is a [[Signer]] backed by the private key derived\r\n *  from an HD Node using the [[link-bip-32]] stantard.\r\n *\r\n *  An HD Node forms a hierarchal structure with each HD Node having a\r\n *  private key and the ability to derive child HD Nodes, defined by\r\n *  a path indicating the index of each child.\r\n */\r\nclass HDNodeWallet extends _base_wallet_js__WEBPACK_IMPORTED_MODULE_2__.BaseWallet {\r\n    /**\r\n     *  The compressed public key.\r\n     */\r\n    publicKey;\r\n    /**\r\n     *  The fingerprint.\r\n     *\r\n     *  A fingerprint allows quick qay to detect parent and child nodes,\r\n     *  but developers should be prepared to deal with collisions as it\r\n     *  is only 4 bytes.\r\n     */\r\n    fingerprint;\r\n    /**\r\n     *  The parent fingerprint.\r\n     */\r\n    parentFingerprint;\r\n    /**\r\n     *  The mnemonic used to create this HD Node, if available.\r\n     *\r\n     *  Sources such as extended keys do not encode the mnemonic, in\r\n     *  which case this will be ``null``.\r\n     */\r\n    mnemonic;\r\n    /**\r\n     *  The chaincode, which is effectively a public key used\r\n     *  to derive children.\r\n     */\r\n    chainCode;\r\n    /**\r\n     *  The derivation path of this wallet.\r\n     *\r\n     *  Since extended keys do not provide full path details, this\r\n     *  may be ``null``, if instantiated from a source that does not\r\n     *  encode it.\r\n     */\r\n    path;\r\n    /**\r\n     *  The child index of this wallet. Values over ``2 *\\* 31`` indicate\r\n     *  the node is hardened.\r\n     */\r\n    index;\r\n    /**\r\n     *  The depth of this wallet, which is the number of components\r\n     *  in its path.\r\n     */\r\n    depth;\r\n    /**\r\n     *  @private\r\n     */\r\n    constructor(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider) {\r\n        super(signingKey, provider);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"HDNodeWallet\");\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { publicKey: signingKey.compressedPublicKey });\r\n        const fingerprint = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.ripemd160)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.sha256)(this.publicKey)), 0, 4);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\r\n            parentFingerprint, fingerprint,\r\n            chainCode, path, index, depth\r\n        });\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { mnemonic });\r\n    }\r\n    connect(provider) {\r\n        return new HDNodeWallet(_guard, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);\r\n    }\r\n    #account() {\r\n        const account = { address: this.address, privateKey: this.privateKey };\r\n        const m = this.mnemonic;\r\n        if (this.path && m && m.wordlist.locale === \"en\" && m.password === \"\") {\r\n            account.mnemonic = {\r\n                path: this.path,\r\n                locale: \"en\",\r\n                entropy: m.entropy\r\n            };\r\n        }\r\n        return account;\r\n    }\r\n    /**\r\n     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with\r\n     *  %%password%%.\r\n     *\r\n     *  If %%progressCallback%% is specified, it will receive periodic\r\n     *  updates as the encryption process progreses.\r\n     */\r\n    async encrypt(password, progressCallback) {\r\n        return await (0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_3__.encryptKeystoreJson)(this.#account(), password, { progressCallback });\r\n    }\r\n    /**\r\n     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with\r\n     *  %%password%%.\r\n     *\r\n     *  It is preferred to use the [async version](encrypt) instead,\r\n     *  which allows a [[ProgressCallback]] to keep the user informed.\r\n     *\r\n     *  This method will block the event loop (freezing all UI) until\r\n     *  it is complete, which may be a non-trivial duration.\r\n     */\r\n    encryptSync(password) {\r\n        return (0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_3__.encryptKeystoreJsonSync)(this.#account(), password);\r\n    }\r\n    /**\r\n     *  The extended key.\r\n     *\r\n     *  This key will begin with the prefix ``xpriv`` and can be used to\r\n     *  reconstruct this HD Node to derive its children.\r\n     */\r\n    get extendedKey() {\r\n        // We only support the mainnet values for now, but if anyone needs\r\n        // testnet values, let me know. I believe current sentiment is that\r\n        // we should always use mainnet, and use BIP-44 to derive the network\r\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\r\n        //   - Testnet: public=0x043587CF, private=0x04358394\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", { operation: \"extendedKey\" });\r\n        return encodeBase58Check((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\r\n            \"0x0488ADE4\", zpad(this.depth, 1), this.parentFingerprint,\r\n            zpad(this.index, 4), this.chainCode,\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\"0x00\", this.privateKey])\r\n        ]));\r\n    }\r\n    /**\r\n     *  Returns true if this wallet has a path, providing a Type Guard\r\n     *  that the path is non-null.\r\n     */\r\n    hasPath() { return (this.path != null); }\r\n    /**\r\n     *  Returns a neutered HD Node, which removes the private details\r\n     *  of an HD Node.\r\n     *\r\n     *  A neutered node has no private key, but can be used to derive\r\n     *  child addresses and other public data about the HD Node.\r\n     */\r\n    neuter() {\r\n        return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);\r\n    }\r\n    /**\r\n     *  Return the child for %%index%%.\r\n     */\r\n    deriveChild(_index) {\r\n        const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(_index, \"index\");\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index <= 0xffffffff, \"invalid index\", \"index\", index);\r\n        // Base path\r\n        let path = this.path;\r\n        if (path) {\r\n            path += \"/\" + (index & ~HardenedBit);\r\n            if (index & HardenedBit) {\r\n                path += \"'\";\r\n            }\r\n        }\r\n        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);\r\n        const ki = new _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.SigningKey((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeHex)(((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBigInt)(IL) + BigInt(this.privateKey)) % N, 32));\r\n        return new HDNodeWallet(_guard, ki, this.fingerprint, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(IR), path, index, this.depth + 1, this.mnemonic, this.provider);\r\n    }\r\n    /**\r\n     *  Return the HDNode for %%path%% from this node.\r\n     */\r\n    derivePath(path) {\r\n        return derivePath(this, path);\r\n    }\r\n    static #fromSeed(_seed, mnemonic) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isBytesLike)(_seed), \"invalid seed\", \"seed\", \"[REDACTED]\");\r\n        const seed = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(_seed, \"seed\");\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(seed.length >= 16 && seed.length <= 64, \"invalid seed\", \"seed\", \"[REDACTED]\");\r\n        const I = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.computeHmac)(\"sha512\", MasterSecret, seed));\r\n        const signingKey = new _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.SigningKey((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(I.slice(0, 32)));\r\n        return new HDNodeWallet(_guard, signingKey, \"0x00000000\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(I.slice(32)), \"m\", 0, 0, mnemonic, null);\r\n    }\r\n    /**\r\n     *  Creates a new HD Node from %%extendedKey%%.\r\n     *\r\n     *  If the %%extendedKey%% will either have a prefix or ``xpub`` or\r\n     *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])\r\n     *  or full HD Node ([[HDNodeWallet) respectively.\r\n     */\r\n    static fromExtendedKey(extendedKey) {\r\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.decodeBase58)(extendedKey)); // @TODO: redact\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(bytes.length === 82 || encodeBase58Check(bytes.slice(0, 78)) === extendedKey, \"invalid extended key\", \"extendedKey\", \"[ REDACTED ]\");\r\n        const depth = bytes[4];\r\n        const parentFingerprint = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(5, 9));\r\n        const index = parseInt((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(9, 13)).substring(2), 16);\r\n        const chainCode = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(13, 45));\r\n        const key = bytes.slice(45, 78);\r\n        switch ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4))) {\r\n            // Public Key\r\n            case \"0x0488b21e\":\r\n            case \"0x043587cf\": {\r\n                const publicKey = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(key);\r\n                return new HDNodeVoidWallet(_guard, (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_4__.computeAddress)(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);\r\n            }\r\n            // Private Key\r\n            case \"0x0488ade4\":\r\n            case \"0x04358394 \":\r\n                if (key[0] !== 0) {\r\n                    break;\r\n                }\r\n                return new HDNodeWallet(_guard, new _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid extended key prefix\", \"extendedKey\", \"[ REDACTED ]\");\r\n    }\r\n    /**\r\n     *  Creates a new random HDNode.\r\n     */\r\n    static createRandom(password, path, wordlist) {\r\n        if (password == null) {\r\n            password = \"\";\r\n        }\r\n        if (path == null) {\r\n            path = defaultPath;\r\n        }\r\n        if (wordlist == null) {\r\n            wordlist = _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_5__.LangEn.wordlist();\r\n        }\r\n        const mnemonic = _mnemonic_js__WEBPACK_IMPORTED_MODULE_6__.Mnemonic.fromEntropy((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.randomBytes)(16), password, wordlist);\r\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\r\n    }\r\n    /**\r\n     *  Create an HD Node from %%mnemonic%%.\r\n     */\r\n    static fromMnemonic(mnemonic, path) {\r\n        if (!path) {\r\n            path = defaultPath;\r\n        }\r\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\r\n    }\r\n    /**\r\n     *  Creates an HD Node from a mnemonic %%phrase%%.\r\n     */\r\n    static fromPhrase(phrase, password, path, wordlist) {\r\n        if (password == null) {\r\n            password = \"\";\r\n        }\r\n        if (path == null) {\r\n            path = defaultPath;\r\n        }\r\n        if (wordlist == null) {\r\n            wordlist = _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_5__.LangEn.wordlist();\r\n        }\r\n        const mnemonic = _mnemonic_js__WEBPACK_IMPORTED_MODULE_6__.Mnemonic.fromPhrase(phrase, password, wordlist);\r\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\r\n    }\r\n    /**\r\n     *  Creates an HD Node from a %%seed%%.\r\n     */\r\n    static fromSeed(seed) {\r\n        return HDNodeWallet.#fromSeed(seed, null);\r\n    }\r\n}\r\n/**\r\n *  A **HDNodeVoidWallet** cannot sign, but provides access to\r\n *  the children nodes of a [[link-bip-32]] HD wallet addresses.\r\n *\r\n *  The can be created by using an extended ``xpub`` key to\r\n *  [[HDNodeWallet_fromExtendedKey]] or by\r\n *  [nuetering](HDNodeWallet-neuter) a [[HDNodeWallet]].\r\n */\r\nclass HDNodeVoidWallet extends _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.VoidSigner {\r\n    /**\r\n     *  The compressed public key.\r\n     */\r\n    publicKey;\r\n    /**\r\n     *  The fingerprint.\r\n     *\r\n     *  A fingerprint allows quick qay to detect parent and child nodes,\r\n     *  but developers should be prepared to deal with collisions as it\r\n     *  is only 4 bytes.\r\n     */\r\n    fingerprint;\r\n    /**\r\n     *  The parent node fingerprint.\r\n     */\r\n    parentFingerprint;\r\n    /**\r\n     *  The chaincode, which is effectively a public key used\r\n     *  to derive children.\r\n     */\r\n    chainCode;\r\n    /**\r\n     *  The derivation path of this wallet.\r\n     *\r\n     *  Since extended keys do not provider full path details, this\r\n     *  may be ``null``, if instantiated from a source that does not\r\n     *  enocde it.\r\n     */\r\n    path;\r\n    /**\r\n     *  The child index of this wallet. Values over ``2 *\\* 31`` indicate\r\n     *  the node is hardened.\r\n     */\r\n    index;\r\n    /**\r\n     *  The depth of this wallet, which is the number of components\r\n     *  in its path.\r\n     */\r\n    depth;\r\n    /**\r\n     *  @private\r\n     */\r\n    constructor(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider) {\r\n        super(address, provider);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"HDNodeVoidWallet\");\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { publicKey });\r\n        const fingerprint = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.ripemd160)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.sha256)(publicKey)), 0, 4);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\r\n            publicKey, fingerprint, parentFingerprint, chainCode, path, index, depth\r\n        });\r\n    }\r\n    connect(provider) {\r\n        return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);\r\n    }\r\n    /**\r\n     *  The extended key.\r\n     *\r\n     *  This key will begin with the prefix ``xpub`` and can be used to\r\n     *  reconstruct this neutered key to derive its children addresses.\r\n     */\r\n    get extendedKey() {\r\n        // We only support the mainnet values for now, but if anyone needs\r\n        // testnet values, let me know. I believe current sentiment is that\r\n        // we should always use mainnet, and use BIP-44 to derive the network\r\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\r\n        //   - Testnet: public=0x043587CF, private=0x04358394\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", { operation: \"extendedKey\" });\r\n        return encodeBase58Check((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\r\n            \"0x0488B21E\",\r\n            zpad(this.depth, 1),\r\n            this.parentFingerprint,\r\n            zpad(this.index, 4),\r\n            this.chainCode,\r\n            this.publicKey,\r\n        ]));\r\n    }\r\n    /**\r\n     *  Returns true if this wallet has a path, providing a Type Guard\r\n     *  that the path is non-null.\r\n     */\r\n    hasPath() { return (this.path != null); }\r\n    /**\r\n     *  Return the child for %%index%%.\r\n     */\r\n    deriveChild(_index) {\r\n        const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(_index, \"index\");\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index <= 0xffffffff, \"invalid index\", \"index\", index);\r\n        // Base path\r\n        let path = this.path;\r\n        if (path) {\r\n            path += \"/\" + (index & ~HardenedBit);\r\n            if (index & HardenedBit) {\r\n                path += \"'\";\r\n            }\r\n        }\r\n        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null);\r\n        const Ki = _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.SigningKey.addPoints(IL, this.publicKey, true);\r\n        const address = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_4__.computeAddress)(Ki);\r\n        return new HDNodeVoidWallet(_guard, address, Ki, this.fingerprint, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(IR), path, index, this.depth + 1, this.provider);\r\n    }\r\n    /**\r\n     *  Return the signer for %%path%% from this node.\r\n     */\r\n    derivePath(path) {\r\n        return derivePath(this, path);\r\n    }\r\n}\r\n/*\r\nexport class HDNodeWalletManager {\r\n    #root: HDNodeWallet;\r\n\r\n    constructor(phrase: string, password?: null | string, path?: null | string, locale?: null | Wordlist) {\r\n        if (password == null) { password = \"\"; }\r\n        if (path == null) { path = \"m/44'/60'/0'/0\"; }\r\n        if (locale == null) { locale = LangEn.wordlist(); }\r\n        this.#root = HDNodeWallet.fromPhrase(phrase, password, path, locale);\r\n    }\r\n\r\n    getSigner(index?: number): HDNodeWallet {\r\n        return this.#root.deriveChild((index == null) ? 0: index);\r\n    }\r\n}\r\n*/\r\n/**\r\n *  Returns the [[link-bip-32]] path for the account at %%index%%.\r\n *\r\n *  This is the pattern used by wallets like Ledger.\r\n *\r\n *  There is also an [alternate pattern](getIndexedAccountPath) used by\r\n *  some software.\r\n */\r\nfunction getAccountPath(_index) {\r\n    const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(_index, \"index\");\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\r\n    return `m/44'/60'/${index}'/0/0`;\r\n}\r\n/**\r\n *  Returns the path using an alternative pattern for deriving accounts,\r\n *  at %%index%%.\r\n *\r\n *  This derivation path uses the //index// component rather than the\r\n *  //account// component to derive sequential accounts.\r\n *\r\n *  This is the pattern used by wallets like MetaMask.\r\n */\r\nfunction getIndexedAccountPath(_index) {\r\n    const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(_index, \"index\");\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\r\n    return `m/44'/60'/0'/0/${index}`;\r\n}\r\n//# sourceMappingURL=hdwallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvaGR3YWxsZXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkY7QUFDMUM7QUFDTTtBQUMySjtBQUNuSztBQUNIO0FBQ0w7QUFDMEM7QUFDbkY7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlEQUFRO0FBQzFCLGtCQUFrQiwwREFBUyxDQUFDLHdEQUFNLENBQUMsd0RBQU07QUFDekMsa0JBQWtCLHVEQUFNO0FBQ3hCLFdBQVcsNkRBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBLGlCQUFpQix5REFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseURBQVE7QUFDekI7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxjQUFjLHlEQUFRLENBQUMsNkRBQVc7QUFDbEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLElBQUksK0RBQWM7QUFDbEI7QUFDQSxRQUFRLCtEQUFjLDBHQUEwRyxXQUFXO0FBQzNJO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBYyxvREFBb0QsRUFBRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQWMsb0RBQW9ELEVBQUU7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBYywwQ0FBMEMsRUFBRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQkFBMkIsdURBQVU7QUFD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QTtBQUNBLGdDQUFnQztBQUNoQyw0QkFBNEI7QUFDNUIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxrQkFBa0IsMERBQVM7QUFDM0IsSUFBSSwrREFBYztBQUNsQix3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0JBQWtCLDBEQUFTO0FBQzNCLElBQUksK0RBQWM7QUFDbEIsNkJBQTZCLE1BQU07QUFDbkM7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFx3YWxsZXRcXGhkd2FsbGV0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgRXhwbGFpbiBIRCBXYWxsZXRzLi5cclxuICpcclxuICogIEBfc3Vic2VjdGlvbjogYXBpL3dhbGxldDpIRCBXYWxsZXRzICBbaGQtd2FsbGV0c11cclxuICovXHJcbmltcG9ydCB7IGNvbXB1dGVIbWFjLCByYW5kb21CeXRlcywgcmlwZW1kMTYwLCBTaWduaW5nS2V5LCBzaGEyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IFZvaWRTaWduZXIgfSBmcm9tIFwiLi4vcHJvdmlkZXJzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGNvbXB1dGVBZGRyZXNzIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGNvbmNhdCwgZGF0YVNsaWNlLCBkZWNvZGVCYXNlNTgsIGRlZmluZVByb3BlcnRpZXMsIGVuY29kZUJhc2U1OCwgZ2V0Qnl0ZXMsIGhleGxpZnksIGlzQnl0ZXNMaWtlLCBnZXROdW1iZXIsIHRvQmVBcnJheSwgdG9CaWdJbnQsIHRvQmVIZXgsIGFzc2VydFByaXZhdGUsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgTGFuZ0VuIH0gZnJvbSBcIi4uL3dvcmRsaXN0cy9sYW5nLWVuLmpzXCI7XHJcbmltcG9ydCB7IEJhc2VXYWxsZXQgfSBmcm9tIFwiLi9iYXNlLXdhbGxldC5qc1wiO1xyXG5pbXBvcnQgeyBNbmVtb25pYyB9IGZyb20gXCIuL21uZW1vbmljLmpzXCI7XHJcbmltcG9ydCB7IGVuY3J5cHRLZXlzdG9yZUpzb24sIGVuY3J5cHRLZXlzdG9yZUpzb25TeW5jLCB9IGZyb20gXCIuL2pzb24ta2V5c3RvcmUuanNcIjtcclxuLyoqXHJcbiAqICBUaGUgZGVmYXVsdCBkZXJpdmF0aW9uIHBhdGggZm9yIEV0aGVyZXVtIEhEIE5vZGVzLiAoaS5lLiBgYFwibS80NCcvNjAnLzAnLzAvMFwiYGApXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZGVmYXVsdFBhdGggPSBcIm0vNDQnLzYwJy8wJy8wLzBcIjtcclxuLy8gXCJCaXRjb2luIHNlZWRcIlxyXG5jb25zdCBNYXN0ZXJTZWNyZXQgPSBuZXcgVWludDhBcnJheShbNjYsIDEwNSwgMTE2LCA5OSwgMTExLCAxMDUsIDExMCwgMzIsIDExNSwgMTAxLCAxMDEsIDEwMF0pO1xyXG5jb25zdCBIYXJkZW5lZEJpdCA9IDB4ODAwMDAwMDA7XHJcbmNvbnN0IE4gPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFcIik7XHJcbmNvbnN0IE5pYmJsZXMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcclxuZnVuY3Rpb24genBhZCh2YWx1ZSwgbGVuZ3RoKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuICAgIHdoaWxlICh2YWx1ZSkge1xyXG4gICAgICAgIHJlc3VsdCA9IE5pYmJsZXNbdmFsdWUgJSAxNl0gKyByZXN1bHQ7XHJcbiAgICAgICAgdmFsdWUgPSBNYXRoLnRydW5jKHZhbHVlIC8gMTYpO1xyXG4gICAgfVxyXG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBsZW5ndGggKiAyKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGVuY29kZUJhc2U1OENoZWNrKF92YWx1ZSkge1xyXG4gICAgY29uc3QgdmFsdWUgPSBnZXRCeXRlcyhfdmFsdWUpO1xyXG4gICAgY29uc3QgY2hlY2sgPSBkYXRhU2xpY2Uoc2hhMjU2KHNoYTI1Nih2YWx1ZSkpLCAwLCA0KTtcclxuICAgIGNvbnN0IGJ5dGVzID0gY29uY2F0KFt2YWx1ZSwgY2hlY2tdKTtcclxuICAgIHJldHVybiBlbmNvZGVCYXNlNTgoYnl0ZXMpO1xyXG59XHJcbmNvbnN0IF9ndWFyZCA9IHt9O1xyXG5mdW5jdGlvbiBzZXJfSShpbmRleCwgY2hhaW5Db2RlLCBwdWJsaWNLZXksIHByaXZhdGVLZXkpIHtcclxuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSgzNyk7XHJcbiAgICBpZiAoaW5kZXggJiBIYXJkZW5lZEJpdCkge1xyXG4gICAgICAgIGFzc2VydChwcml2YXRlS2V5ICE9IG51bGwsIFwiY2Fubm90IGRlcml2ZSBjaGlsZCBvZiBuZXV0ZXJlZCBub2RlXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRlcml2ZUNoaWxkXCJcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBEYXRhID0gMHgwMCB8fCBzZXJfMjU2KGtfcGFyKVxyXG4gICAgICAgIGRhdGEuc2V0KGdldEJ5dGVzKHByaXZhdGVLZXkpLCAxKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIERhdGEgPSBzZXJfcChwb2ludChrX3BhcikpXHJcbiAgICAgICAgZGF0YS5zZXQoZ2V0Qnl0ZXMocHVibGljS2V5KSk7XHJcbiAgICB9XHJcbiAgICAvLyBEYXRhICs9IHNlcl8zMihpKVxyXG4gICAgZm9yIChsZXQgaSA9IDI0OyBpID49IDA7IGkgLT0gOCkge1xyXG4gICAgICAgIGRhdGFbMzMgKyAoaSA+PiAzKV0gPSAoKGluZGV4ID4+ICgyNCAtIGkpKSAmIDB4ZmYpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgSSA9IGdldEJ5dGVzKGNvbXB1dGVIbWFjKFwic2hhNTEyXCIsIGNoYWluQ29kZSwgZGF0YSkpO1xyXG4gICAgcmV0dXJuIHsgSUw6IEkuc2xpY2UoMCwgMzIpLCBJUjogSS5zbGljZSgzMikgfTtcclxufVxyXG5mdW5jdGlvbiBkZXJpdmVQYXRoKG5vZGUsIHBhdGgpIHtcclxuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KGNvbXBvbmVudHMubGVuZ3RoID4gMCwgXCJpbnZhbGlkIHBhdGhcIiwgXCJwYXRoXCIsIHBhdGgpO1xyXG4gICAgaWYgKGNvbXBvbmVudHNbMF0gPT09IFwibVwiKSB7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQobm9kZS5kZXB0aCA9PT0gMCwgYGNhbm5vdCBkZXJpdmUgcm9vdCBwYXRoIChpLmUuIHBhdGggc3RhcnRpbmcgd2l0aCBcIm0vXCIpIGZvciBhIG5vZGUgYXQgbm9uLXplcm8gZGVwdGggJHtub2RlLmRlcHRofWAsIFwicGF0aFwiLCBwYXRoKTtcclxuICAgICAgICBjb21wb25lbnRzLnNoaWZ0KCk7XHJcbiAgICB9XHJcbiAgICBsZXQgcmVzdWx0ID0gbm9kZTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudC5tYXRjaCgvXlswLTldKyckLykpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChjb21wb25lbnQuc3Vic3RyaW5nKDAsIGNvbXBvbmVudC5sZW5ndGggLSAxKSk7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGluZGV4IDwgSGFyZGVuZWRCaXQsIFwiaW52YWxpZCBwYXRoIGluZGV4XCIsIGBwYXRoWyR7aX1dYCwgY29tcG9uZW50KTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmRlcml2ZUNoaWxkKEhhcmRlbmVkQml0ICsgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb21wb25lbnQubWF0Y2goL15bMC05XSskLykpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChjb21wb25lbnQpO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA8IEhhcmRlbmVkQml0LCBcImludmFsaWQgcGF0aCBpbmRleFwiLCBgcGF0aFske2l9XWAsIGNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5kZXJpdmVDaGlsZChpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHBhdGggY29tcG9uZW50XCIsIGBwYXRoWyR7aX1dYCwgY29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiAgQW4gKipIRE5vZGVXYWxsZXQqKiBpcyBhIFtbU2lnbmVyXV0gYmFja2VkIGJ5IHRoZSBwcml2YXRlIGtleSBkZXJpdmVkXHJcbiAqICBmcm9tIGFuIEhEIE5vZGUgdXNpbmcgdGhlIFtbbGluay1iaXAtMzJdXSBzdGFudGFyZC5cclxuICpcclxuICogIEFuIEhEIE5vZGUgZm9ybXMgYSBoaWVyYXJjaGFsIHN0cnVjdHVyZSB3aXRoIGVhY2ggSEQgTm9kZSBoYXZpbmcgYVxyXG4gKiAgcHJpdmF0ZSBrZXkgYW5kIHRoZSBhYmlsaXR5IHRvIGRlcml2ZSBjaGlsZCBIRCBOb2RlcywgZGVmaW5lZCBieVxyXG4gKiAgYSBwYXRoIGluZGljYXRpbmcgdGhlIGluZGV4IG9mIGVhY2ggY2hpbGQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSEROb2RlV2FsbGV0IGV4dGVuZHMgQmFzZVdhbGxldCB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgY29tcHJlc3NlZCBwdWJsaWMga2V5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWNLZXk7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZmluZ2VycHJpbnQuXHJcbiAgICAgKlxyXG4gICAgICogIEEgZmluZ2VycHJpbnQgYWxsb3dzIHF1aWNrIHFheSB0byBkZXRlY3QgcGFyZW50IGFuZCBjaGlsZCBub2RlcyxcclxuICAgICAqICBidXQgZGV2ZWxvcGVycyBzaG91bGQgYmUgcHJlcGFyZWQgdG8gZGVhbCB3aXRoIGNvbGxpc2lvbnMgYXMgaXRcclxuICAgICAqICBpcyBvbmx5IDQgYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIGZpbmdlcnByaW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHBhcmVudCBmaW5nZXJwcmludC5cclxuICAgICAqL1xyXG4gICAgcGFyZW50RmluZ2VycHJpbnQ7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbW5lbW9uaWMgdXNlZCB0byBjcmVhdGUgdGhpcyBIRCBOb2RlLCBpZiBhdmFpbGFibGUuXHJcbiAgICAgKlxyXG4gICAgICogIFNvdXJjZXMgc3VjaCBhcyBleHRlbmRlZCBrZXlzIGRvIG5vdCBlbmNvZGUgdGhlIG1uZW1vbmljLCBpblxyXG4gICAgICogIHdoaWNoIGNhc2UgdGhpcyB3aWxsIGJlIGBgbnVsbGBgLlxyXG4gICAgICovXHJcbiAgICBtbmVtb25pYztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBjaGFpbmNvZGUsIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IGEgcHVibGljIGtleSB1c2VkXHJcbiAgICAgKiAgdG8gZGVyaXZlIGNoaWxkcmVuLlxyXG4gICAgICovXHJcbiAgICBjaGFpbkNvZGU7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZGVyaXZhdGlvbiBwYXRoIG9mIHRoaXMgd2FsbGV0LlxyXG4gICAgICpcclxuICAgICAqICBTaW5jZSBleHRlbmRlZCBrZXlzIGRvIG5vdCBwcm92aWRlIGZ1bGwgcGF0aCBkZXRhaWxzLCB0aGlzXHJcbiAgICAgKiAgbWF5IGJlIGBgbnVsbGBgLCBpZiBpbnN0YW50aWF0ZWQgZnJvbSBhIHNvdXJjZSB0aGF0IGRvZXMgbm90XHJcbiAgICAgKiAgZW5jb2RlIGl0LlxyXG4gICAgICovXHJcbiAgICBwYXRoO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGNoaWxkIGluZGV4IG9mIHRoaXMgd2FsbGV0LiBWYWx1ZXMgb3ZlciBgYDIgKlxcKiAzMWBgIGluZGljYXRlXHJcbiAgICAgKiAgdGhlIG5vZGUgaXMgaGFyZGVuZWQuXHJcbiAgICAgKi9cclxuICAgIGluZGV4O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGRlcHRoIG9mIHRoaXMgd2FsbGV0LCB3aGljaCBpcyB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHNcclxuICAgICAqICBpbiBpdHMgcGF0aC5cclxuICAgICAqL1xyXG4gICAgZGVwdGg7XHJcbiAgICAvKipcclxuICAgICAqICBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgc2lnbmluZ0tleSwgcGFyZW50RmluZ2VycHJpbnQsIGNoYWluQ29kZSwgcGF0aCwgaW5kZXgsIGRlcHRoLCBtbmVtb25pYywgcHJvdmlkZXIpIHtcclxuICAgICAgICBzdXBlcihzaWduaW5nS2V5LCBwcm92aWRlcik7XHJcbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIkhETm9kZVdhbGxldFwiKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcHVibGljS2V5OiBzaWduaW5nS2V5LmNvbXByZXNzZWRQdWJsaWNLZXkgfSk7XHJcbiAgICAgICAgY29uc3QgZmluZ2VycHJpbnQgPSBkYXRhU2xpY2UocmlwZW1kMTYwKHNoYTI1Nih0aGlzLnB1YmxpY0tleSkpLCAwLCA0KTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgICAgICAgICAgcGFyZW50RmluZ2VycHJpbnQsIGZpbmdlcnByaW50LFxyXG4gICAgICAgICAgICBjaGFpbkNvZGUsIHBhdGgsIGluZGV4LCBkZXB0aFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBtbmVtb25pYyB9KTtcclxuICAgIH1cclxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVdhbGxldChfZ3VhcmQsIHRoaXMuc2lnbmluZ0tleSwgdGhpcy5wYXJlbnRGaW5nZXJwcmludCwgdGhpcy5jaGFpbkNvZGUsIHRoaXMucGF0aCwgdGhpcy5pbmRleCwgdGhpcy5kZXB0aCwgdGhpcy5tbmVtb25pYywgcHJvdmlkZXIpO1xyXG4gICAgfVxyXG4gICAgI2FjY291bnQoKSB7XHJcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IHsgYWRkcmVzczogdGhpcy5hZGRyZXNzLCBwcml2YXRlS2V5OiB0aGlzLnByaXZhdGVLZXkgfTtcclxuICAgICAgICBjb25zdCBtID0gdGhpcy5tbmVtb25pYztcclxuICAgICAgICBpZiAodGhpcy5wYXRoICYmIG0gJiYgbS53b3JkbGlzdC5sb2NhbGUgPT09IFwiZW5cIiAmJiBtLnBhc3N3b3JkID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIGFjY291bnQubW5lbW9uaWMgPSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXHJcbiAgICAgICAgICAgICAgICBsb2NhbGU6IFwiZW5cIixcclxuICAgICAgICAgICAgICAgIGVudHJvcHk6IG0uZW50cm9weVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWNjb3VudDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIHRvIGEgW0pTT04gS2V5c3RvcmUgV2FsbGV0XShqc29uLXdhbGxldHMpIGVuY3J5cHRlZCB3aXRoXHJcbiAgICAgKiAgJSVwYXNzd29yZCUlLlxyXG4gICAgICpcclxuICAgICAqICBJZiAlJXByb2dyZXNzQ2FsbGJhY2slJSBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgcmVjZWl2ZSBwZXJpb2RpY1xyXG4gICAgICogIHVwZGF0ZXMgYXMgdGhlIGVuY3J5cHRpb24gcHJvY2VzcyBwcm9ncmVzZXMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGVuY3J5cHQocGFzc3dvcmQsIHByb2dyZXNzQ2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgZW5jcnlwdEtleXN0b3JlSnNvbih0aGlzLiNhY2NvdW50KCksIHBhc3N3b3JkLCB7IHByb2dyZXNzQ2FsbGJhY2sgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgW0pTT04gS2V5c3RvcmUgV2FsbGV0XShqc29uLXdhbGxldHMpIGVuY3J5cGVkIHdpdGhcclxuICAgICAqICAlJXBhc3N3b3JkJSUuXHJcbiAgICAgKlxyXG4gICAgICogIEl0IGlzIHByZWZlcnJlZCB0byB1c2UgdGhlIFthc3luYyB2ZXJzaW9uXShlbmNyeXB0KSBpbnN0ZWFkLFxyXG4gICAgICogIHdoaWNoIGFsbG93cyBhIFtbUHJvZ3Jlc3NDYWxsYmFja11dIHRvIGtlZXAgdGhlIHVzZXIgaW5mb3JtZWQuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgbWV0aG9kIHdpbGwgYmxvY2sgdGhlIGV2ZW50IGxvb3AgKGZyZWV6aW5nIGFsbCBVSSkgdW50aWxcclxuICAgICAqICBpdCBpcyBjb21wbGV0ZSwgd2hpY2ggbWF5IGJlIGEgbm9uLXRyaXZpYWwgZHVyYXRpb24uXHJcbiAgICAgKi9cclxuICAgIGVuY3J5cHRTeW5jKHBhc3N3b3JkKSB7XHJcbiAgICAgICAgcmV0dXJuIGVuY3J5cHRLZXlzdG9yZUpzb25TeW5jKHRoaXMuI2FjY291bnQoKSwgcGFzc3dvcmQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGV4dGVuZGVkIGtleS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBrZXkgd2lsbCBiZWdpbiB3aXRoIHRoZSBwcmVmaXggYGB4cHJpdmBgIGFuZCBjYW4gYmUgdXNlZCB0b1xyXG4gICAgICogIHJlY29uc3RydWN0IHRoaXMgSEQgTm9kZSB0byBkZXJpdmUgaXRzIGNoaWxkcmVuLlxyXG4gICAgICovXHJcbiAgICBnZXQgZXh0ZW5kZWRLZXkoKSB7XHJcbiAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHRoZSBtYWlubmV0IHZhbHVlcyBmb3Igbm93LCBidXQgaWYgYW55b25lIG5lZWRzXHJcbiAgICAgICAgLy8gdGVzdG5ldCB2YWx1ZXMsIGxldCBtZSBrbm93LiBJIGJlbGlldmUgY3VycmVudCBzZW50aW1lbnQgaXMgdGhhdFxyXG4gICAgICAgIC8vIHdlIHNob3VsZCBhbHdheXMgdXNlIG1haW5uZXQsIGFuZCB1c2UgQklQLTQ0IHRvIGRlcml2ZSB0aGUgbmV0d29ya1xyXG4gICAgICAgIC8vICAgLSBNYWlubmV0OiBwdWJsaWM9MHgwNDg4QjIxRSwgcHJpdmF0ZT0weDA0ODhBREU0XHJcbiAgICAgICAgLy8gICAtIFRlc3RuZXQ6IHB1YmxpYz0weDA0MzU4N0NGLCBwcml2YXRlPTB4MDQzNTgzOTRcclxuICAgICAgICBhc3NlcnQodGhpcy5kZXB0aCA8IDI1NiwgXCJEZXB0aCB0b28gZGVlcFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJleHRlbmRlZEtleVwiIH0pO1xyXG4gICAgICAgIHJldHVybiBlbmNvZGVCYXNlNThDaGVjayhjb25jYXQoW1xyXG4gICAgICAgICAgICBcIjB4MDQ4OEFERTRcIiwgenBhZCh0aGlzLmRlcHRoLCAxKSwgdGhpcy5wYXJlbnRGaW5nZXJwcmludCxcclxuICAgICAgICAgICAgenBhZCh0aGlzLmluZGV4LCA0KSwgdGhpcy5jaGFpbkNvZGUsXHJcbiAgICAgICAgICAgIGNvbmNhdChbXCIweDAwXCIsIHRoaXMucHJpdmF0ZUtleV0pXHJcbiAgICAgICAgXSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgd2FsbGV0IGhhcyBhIHBhdGgsIHByb3ZpZGluZyBhIFR5cGUgR3VhcmRcclxuICAgICAqICB0aGF0IHRoZSBwYXRoIGlzIG5vbi1udWxsLlxyXG4gICAgICovXHJcbiAgICBoYXNQYXRoKCkgeyByZXR1cm4gKHRoaXMucGF0aCAhPSBudWxsKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIG5ldXRlcmVkIEhEIE5vZGUsIHdoaWNoIHJlbW92ZXMgdGhlIHByaXZhdGUgZGV0YWlsc1xyXG4gICAgICogIG9mIGFuIEhEIE5vZGUuXHJcbiAgICAgKlxyXG4gICAgICogIEEgbmV1dGVyZWQgbm9kZSBoYXMgbm8gcHJpdmF0ZSBrZXksIGJ1dCBjYW4gYmUgdXNlZCB0byBkZXJpdmVcclxuICAgICAqICBjaGlsZCBhZGRyZXNzZXMgYW5kIG90aGVyIHB1YmxpYyBkYXRhIGFib3V0IHRoZSBIRCBOb2RlLlxyXG4gICAgICovXHJcbiAgICBuZXV0ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVWb2lkV2FsbGV0KF9ndWFyZCwgdGhpcy5hZGRyZXNzLCB0aGlzLnB1YmxpY0tleSwgdGhpcy5wYXJlbnRGaW5nZXJwcmludCwgdGhpcy5jaGFpbkNvZGUsIHRoaXMucGF0aCwgdGhpcy5pbmRleCwgdGhpcy5kZXB0aCwgdGhpcy5wcm92aWRlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gdGhlIGNoaWxkIGZvciAlJWluZGV4JSUuXHJcbiAgICAgKi9cclxuICAgIGRlcml2ZUNoaWxkKF9pbmRleCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0TnVtYmVyKF9pbmRleCwgXCJpbmRleFwiKTtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA8PSAweGZmZmZmZmZmLCBcImludmFsaWQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XHJcbiAgICAgICAgLy8gQmFzZSBwYXRoXHJcbiAgICAgICAgbGV0IHBhdGggPSB0aGlzLnBhdGg7XHJcbiAgICAgICAgaWYgKHBhdGgpIHtcclxuICAgICAgICAgICAgcGF0aCArPSBcIi9cIiArIChpbmRleCAmIH5IYXJkZW5lZEJpdCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCAmIEhhcmRlbmVkQml0KSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoICs9IFwiJ1wiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgSVIsIElMIH0gPSBzZXJfSShpbmRleCwgdGhpcy5jaGFpbkNvZGUsIHRoaXMucHVibGljS2V5LCB0aGlzLnByaXZhdGVLZXkpO1xyXG4gICAgICAgIGNvbnN0IGtpID0gbmV3IFNpZ25pbmdLZXkodG9CZUhleCgodG9CaWdJbnQoSUwpICsgQmlnSW50KHRoaXMucHJpdmF0ZUtleSkpICUgTiwgMzIpKTtcclxuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVdhbGxldChfZ3VhcmQsIGtpLCB0aGlzLmZpbmdlcnByaW50LCBoZXhsaWZ5KElSKSwgcGF0aCwgaW5kZXgsIHRoaXMuZGVwdGggKyAxLCB0aGlzLm1uZW1vbmljLCB0aGlzLnByb3ZpZGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiB0aGUgSEROb2RlIGZvciAlJXBhdGglJSBmcm9tIHRoaXMgbm9kZS5cclxuICAgICAqL1xyXG4gICAgZGVyaXZlUGF0aChwYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlcml2ZVBhdGgodGhpcywgcGF0aCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgI2Zyb21TZWVkKF9zZWVkLCBtbmVtb25pYykge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGlzQnl0ZXNMaWtlKF9zZWVkKSwgXCJpbnZhbGlkIHNlZWRcIiwgXCJzZWVkXCIsIFwiW1JFREFDVEVEXVwiKTtcclxuICAgICAgICBjb25zdCBzZWVkID0gZ2V0Qnl0ZXMoX3NlZWQsIFwic2VlZFwiKTtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChzZWVkLmxlbmd0aCA+PSAxNiAmJiBzZWVkLmxlbmd0aCA8PSA2NCwgXCJpbnZhbGlkIHNlZWRcIiwgXCJzZWVkXCIsIFwiW1JFREFDVEVEXVwiKTtcclxuICAgICAgICBjb25zdCBJID0gZ2V0Qnl0ZXMoY29tcHV0ZUhtYWMoXCJzaGE1MTJcIiwgTWFzdGVyU2VjcmV0LCBzZWVkKSk7XHJcbiAgICAgICAgY29uc3Qgc2lnbmluZ0tleSA9IG5ldyBTaWduaW5nS2V5KGhleGxpZnkoSS5zbGljZSgwLCAzMikpKTtcclxuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVdhbGxldChfZ3VhcmQsIHNpZ25pbmdLZXksIFwiMHgwMDAwMDAwMFwiLCBoZXhsaWZ5KEkuc2xpY2UoMzIpKSwgXCJtXCIsIDAsIDAsIG1uZW1vbmljLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgSEQgTm9kZSBmcm9tICUlZXh0ZW5kZWRLZXklJS5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgdGhlICUlZXh0ZW5kZWRLZXklJSB3aWxsIGVpdGhlciBoYXZlIGEgcHJlZml4IG9yIGBgeHB1YmBgIG9yXHJcbiAgICAgKiAgYGB4cHJpdmBgLCByZXR1cm5pbmcgYSBuZXV0ZXJlZCBIRCBOb2RlIChbW0hETm9kZVZvaWRXYWxsZXRdXSlcclxuICAgICAqICBvciBmdWxsIEhEIE5vZGUgKFtbSEROb2RlV2FsbGV0KSByZXNwZWN0aXZlbHkuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRLZXkoZXh0ZW5kZWRLZXkpIHtcclxuICAgICAgICBjb25zdCBieXRlcyA9IHRvQmVBcnJheShkZWNvZGVCYXNlNTgoZXh0ZW5kZWRLZXkpKTsgLy8gQFRPRE86IHJlZGFjdFxyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ5dGVzLmxlbmd0aCA9PT0gODIgfHwgZW5jb2RlQmFzZTU4Q2hlY2soYnl0ZXMuc2xpY2UoMCwgNzgpKSA9PT0gZXh0ZW5kZWRLZXksIFwiaW52YWxpZCBleHRlbmRlZCBrZXlcIiwgXCJleHRlbmRlZEtleVwiLCBcIlsgUkVEQUNURUQgXVwiKTtcclxuICAgICAgICBjb25zdCBkZXB0aCA9IGJ5dGVzWzRdO1xyXG4gICAgICAgIGNvbnN0IHBhcmVudEZpbmdlcnByaW50ID0gaGV4bGlmeShieXRlcy5zbGljZSg1LCA5KSk7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDksIDEzKSkuc3Vic3RyaW5nKDIpLCAxNik7XHJcbiAgICAgICAgY29uc3QgY2hhaW5Db2RlID0gaGV4bGlmeShieXRlcy5zbGljZSgxMywgNDUpKTtcclxuICAgICAgICBjb25zdCBrZXkgPSBieXRlcy5zbGljZSg0NSwgNzgpO1xyXG4gICAgICAgIHN3aXRjaCAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkpIHtcclxuICAgICAgICAgICAgLy8gUHVibGljIEtleVxyXG4gICAgICAgICAgICBjYXNlIFwiMHgwNDg4YjIxZVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiMHgwNDM1ODdjZlwiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBoZXhsaWZ5KGtleSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEhETm9kZVZvaWRXYWxsZXQoX2d1YXJkLCBjb21wdXRlQWRkcmVzcyhwdWJsaWNLZXkpLCBwdWJsaWNLZXksIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIG51bGwsIGluZGV4LCBkZXB0aCwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUHJpdmF0ZSBLZXlcclxuICAgICAgICAgICAgY2FzZSBcIjB4MDQ4OGFkZTRcIjpcclxuICAgICAgICAgICAgY2FzZSBcIjB4MDQzNTgzOTQgXCI6XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5WzBdICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEhETm9kZVdhbGxldChfZ3VhcmQsIG5ldyBTaWduaW5nS2V5KGtleS5zbGljZSgxKSksIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIG51bGwsIGluZGV4LCBkZXB0aCwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZXh0ZW5kZWQga2V5IHByZWZpeFwiLCBcImV4dGVuZGVkS2V5XCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyByYW5kb20gSEROb2RlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlUmFuZG9tKHBhc3N3b3JkLCBwYXRoLCB3b3JkbGlzdCkge1xyXG4gICAgICAgIGlmIChwYXNzd29yZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHBhc3N3b3JkID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhdGggPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwYXRoID0gZGVmYXVsdFBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gTGFuZ0VuLndvcmRsaXN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1uZW1vbmljID0gTW5lbW9uaWMuZnJvbUVudHJvcHkocmFuZG9tQnl0ZXMoMTYpLCBwYXNzd29yZCwgd29yZGxpc3QpO1xyXG4gICAgICAgIHJldHVybiBIRE5vZGVXYWxsZXQuI2Zyb21TZWVkKG1uZW1vbmljLmNvbXB1dGVTZWVkKCksIG1uZW1vbmljKS5kZXJpdmVQYXRoKHBhdGgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlIGFuIEhEIE5vZGUgZnJvbSAlJW1uZW1vbmljJSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tTW5lbW9uaWMobW5lbW9uaWMsIHBhdGgpIHtcclxuICAgICAgICBpZiAoIXBhdGgpIHtcclxuICAgICAgICAgICAgcGF0aCA9IGRlZmF1bHRQYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gSEROb2RlV2FsbGV0LiNmcm9tU2VlZChtbmVtb25pYy5jb21wdXRlU2VlZCgpLCBtbmVtb25pYykuZGVyaXZlUGF0aChwYXRoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYW4gSEQgTm9kZSBmcm9tIGEgbW5lbW9uaWMgJSVwaHJhc2UlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21QaHJhc2UocGhyYXNlLCBwYXNzd29yZCwgcGF0aCwgd29yZGxpc3QpIHtcclxuICAgICAgICBpZiAocGFzc3dvcmQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwYXNzd29yZCA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXRoID09IG51bGwpIHtcclxuICAgICAgICAgICAgcGF0aCA9IGRlZmF1bHRQYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB3b3JkbGlzdCA9IExhbmdFbi53b3JkbGlzdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtbmVtb25pYyA9IE1uZW1vbmljLmZyb21QaHJhc2UocGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpO1xyXG4gICAgICAgIHJldHVybiBIRE5vZGVXYWxsZXQuI2Zyb21TZWVkKG1uZW1vbmljLmNvbXB1dGVTZWVkKCksIG1uZW1vbmljKS5kZXJpdmVQYXRoKHBhdGgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhbiBIRCBOb2RlIGZyb20gYSAlJXNlZWQlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21TZWVkKHNlZWQpIHtcclxuICAgICAgICByZXR1cm4gSEROb2RlV2FsbGV0LiNmcm9tU2VlZChzZWVkLCBudWxsKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEEgKipIRE5vZGVWb2lkV2FsbGV0KiogY2Fubm90IHNpZ24sIGJ1dCBwcm92aWRlcyBhY2Nlc3MgdG9cclxuICogIHRoZSBjaGlsZHJlbiBub2RlcyBvZiBhIFtbbGluay1iaXAtMzJdXSBIRCB3YWxsZXQgYWRkcmVzc2VzLlxyXG4gKlxyXG4gKiAgVGhlIGNhbiBiZSBjcmVhdGVkIGJ5IHVzaW5nIGFuIGV4dGVuZGVkIGBgeHB1YmBgIGtleSB0b1xyXG4gKiAgW1tIRE5vZGVXYWxsZXRfZnJvbUV4dGVuZGVkS2V5XV0gb3IgYnlcclxuICogIFtudWV0ZXJpbmddKEhETm9kZVdhbGxldC1uZXV0ZXIpIGEgW1tIRE5vZGVXYWxsZXRdXS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBIRE5vZGVWb2lkV2FsbGV0IGV4dGVuZHMgVm9pZFNpZ25lciB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgY29tcHJlc3NlZCBwdWJsaWMga2V5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWNLZXk7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZmluZ2VycHJpbnQuXHJcbiAgICAgKlxyXG4gICAgICogIEEgZmluZ2VycHJpbnQgYWxsb3dzIHF1aWNrIHFheSB0byBkZXRlY3QgcGFyZW50IGFuZCBjaGlsZCBub2RlcyxcclxuICAgICAqICBidXQgZGV2ZWxvcGVycyBzaG91bGQgYmUgcHJlcGFyZWQgdG8gZGVhbCB3aXRoIGNvbGxpc2lvbnMgYXMgaXRcclxuICAgICAqICBpcyBvbmx5IDQgYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIGZpbmdlcnByaW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHBhcmVudCBub2RlIGZpbmdlcnByaW50LlxyXG4gICAgICovXHJcbiAgICBwYXJlbnRGaW5nZXJwcmludDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBjaGFpbmNvZGUsIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IGEgcHVibGljIGtleSB1c2VkXHJcbiAgICAgKiAgdG8gZGVyaXZlIGNoaWxkcmVuLlxyXG4gICAgICovXHJcbiAgICBjaGFpbkNvZGU7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZGVyaXZhdGlvbiBwYXRoIG9mIHRoaXMgd2FsbGV0LlxyXG4gICAgICpcclxuICAgICAqICBTaW5jZSBleHRlbmRlZCBrZXlzIGRvIG5vdCBwcm92aWRlciBmdWxsIHBhdGggZGV0YWlscywgdGhpc1xyXG4gICAgICogIG1heSBiZSBgYG51bGxgYCwgaWYgaW5zdGFudGlhdGVkIGZyb20gYSBzb3VyY2UgdGhhdCBkb2VzIG5vdFxyXG4gICAgICogIGVub2NkZSBpdC5cclxuICAgICAqL1xyXG4gICAgcGF0aDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBjaGlsZCBpbmRleCBvZiB0aGlzIHdhbGxldC4gVmFsdWVzIG92ZXIgYGAyICpcXCogMzFgYCBpbmRpY2F0ZVxyXG4gICAgICogIHRoZSBub2RlIGlzIGhhcmRlbmVkLlxyXG4gICAgICovXHJcbiAgICBpbmRleDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBkZXB0aCBvZiB0aGlzIHdhbGxldCwgd2hpY2ggaXMgdGhlIG51bWJlciBvZiBjb21wb25lbnRzXHJcbiAgICAgKiAgaW4gaXRzIHBhdGguXHJcbiAgICAgKi9cclxuICAgIGRlcHRoO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIGFkZHJlc3MsIHB1YmxpY0tleSwgcGFyZW50RmluZ2VycHJpbnQsIGNoYWluQ29kZSwgcGF0aCwgaW5kZXgsIGRlcHRoLCBwcm92aWRlcikge1xyXG4gICAgICAgIHN1cGVyKGFkZHJlc3MsIHByb3ZpZGVyKTtcclxuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiSEROb2RlVm9pZFdhbGxldFwiKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcHVibGljS2V5IH0pO1xyXG4gICAgICAgIGNvbnN0IGZpbmdlcnByaW50ID0gZGF0YVNsaWNlKHJpcGVtZDE2MChzaGEyNTYocHVibGljS2V5KSksIDAsIDQpO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xyXG4gICAgICAgICAgICBwdWJsaWNLZXksIGZpbmdlcnByaW50LCBwYXJlbnRGaW5nZXJwcmludCwgY2hhaW5Db2RlLCBwYXRoLCBpbmRleCwgZGVwdGhcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVZvaWRXYWxsZXQoX2d1YXJkLCB0aGlzLmFkZHJlc3MsIHRoaXMucHVibGljS2V5LCB0aGlzLnBhcmVudEZpbmdlcnByaW50LCB0aGlzLmNoYWluQ29kZSwgdGhpcy5wYXRoLCB0aGlzLmluZGV4LCB0aGlzLmRlcHRoLCBwcm92aWRlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZXh0ZW5kZWQga2V5LlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGtleSB3aWxsIGJlZ2luIHdpdGggdGhlIHByZWZpeCBgYHhwdWJgYCBhbmQgY2FuIGJlIHVzZWQgdG9cclxuICAgICAqICByZWNvbnN0cnVjdCB0aGlzIG5ldXRlcmVkIGtleSB0byBkZXJpdmUgaXRzIGNoaWxkcmVuIGFkZHJlc3Nlcy5cclxuICAgICAqL1xyXG4gICAgZ2V0IGV4dGVuZGVkS2V5KCkge1xyXG4gICAgICAgIC8vIFdlIG9ubHkgc3VwcG9ydCB0aGUgbWFpbm5ldCB2YWx1ZXMgZm9yIG5vdywgYnV0IGlmIGFueW9uZSBuZWVkc1xyXG4gICAgICAgIC8vIHRlc3RuZXQgdmFsdWVzLCBsZXQgbWUga25vdy4gSSBiZWxpZXZlIGN1cnJlbnQgc2VudGltZW50IGlzIHRoYXRcclxuICAgICAgICAvLyB3ZSBzaG91bGQgYWx3YXlzIHVzZSBtYWlubmV0LCBhbmQgdXNlIEJJUC00NCB0byBkZXJpdmUgdGhlIG5ldHdvcmtcclxuICAgICAgICAvLyAgIC0gTWFpbm5ldDogcHVibGljPTB4MDQ4OEIyMUUsIHByaXZhdGU9MHgwNDg4QURFNFxyXG4gICAgICAgIC8vICAgLSBUZXN0bmV0OiBwdWJsaWM9MHgwNDM1ODdDRiwgcHJpdmF0ZT0weDA0MzU4Mzk0XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMuZGVwdGggPCAyNTYsIFwiRGVwdGggdG9vIGRlZXBcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZXh0ZW5kZWRLZXlcIiB9KTtcclxuICAgICAgICByZXR1cm4gZW5jb2RlQmFzZTU4Q2hlY2soY29uY2F0KFtcclxuICAgICAgICAgICAgXCIweDA0ODhCMjFFXCIsXHJcbiAgICAgICAgICAgIHpwYWQodGhpcy5kZXB0aCwgMSksXHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50RmluZ2VycHJpbnQsXHJcbiAgICAgICAgICAgIHpwYWQodGhpcy5pbmRleCwgNCksXHJcbiAgICAgICAgICAgIHRoaXMuY2hhaW5Db2RlLFxyXG4gICAgICAgICAgICB0aGlzLnB1YmxpY0tleSxcclxuICAgICAgICBdKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB3YWxsZXQgaGFzIGEgcGF0aCwgcHJvdmlkaW5nIGEgVHlwZSBHdWFyZFxyXG4gICAgICogIHRoYXQgdGhlIHBhdGggaXMgbm9uLW51bGwuXHJcbiAgICAgKi9cclxuICAgIGhhc1BhdGgoKSB7IHJldHVybiAodGhpcy5wYXRoICE9IG51bGwpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gdGhlIGNoaWxkIGZvciAlJWluZGV4JSUuXHJcbiAgICAgKi9cclxuICAgIGRlcml2ZUNoaWxkKF9pbmRleCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0TnVtYmVyKF9pbmRleCwgXCJpbmRleFwiKTtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA8PSAweGZmZmZmZmZmLCBcImludmFsaWQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XHJcbiAgICAgICAgLy8gQmFzZSBwYXRoXHJcbiAgICAgICAgbGV0IHBhdGggPSB0aGlzLnBhdGg7XHJcbiAgICAgICAgaWYgKHBhdGgpIHtcclxuICAgICAgICAgICAgcGF0aCArPSBcIi9cIiArIChpbmRleCAmIH5IYXJkZW5lZEJpdCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCAmIEhhcmRlbmVkQml0KSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoICs9IFwiJ1wiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgSVIsIElMIH0gPSBzZXJfSShpbmRleCwgdGhpcy5jaGFpbkNvZGUsIHRoaXMucHVibGljS2V5LCBudWxsKTtcclxuICAgICAgICBjb25zdCBLaSA9IFNpZ25pbmdLZXkuYWRkUG9pbnRzKElMLCB0aGlzLnB1YmxpY0tleSwgdHJ1ZSk7XHJcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGNvbXB1dGVBZGRyZXNzKEtpKTtcclxuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVZvaWRXYWxsZXQoX2d1YXJkLCBhZGRyZXNzLCBLaSwgdGhpcy5maW5nZXJwcmludCwgaGV4bGlmeShJUiksIHBhdGgsIGluZGV4LCB0aGlzLmRlcHRoICsgMSwgdGhpcy5wcm92aWRlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gdGhlIHNpZ25lciBmb3IgJSVwYXRoJSUgZnJvbSB0aGlzIG5vZGUuXHJcbiAgICAgKi9cclxuICAgIGRlcml2ZVBhdGgocGF0aCkge1xyXG4gICAgICAgIHJldHVybiBkZXJpdmVQYXRoKHRoaXMsIHBhdGgpO1xyXG4gICAgfVxyXG59XHJcbi8qXHJcbmV4cG9ydCBjbGFzcyBIRE5vZGVXYWxsZXRNYW5hZ2VyIHtcclxuICAgICNyb290OiBIRE5vZGVXYWxsZXQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IocGhyYXNlOiBzdHJpbmcsIHBhc3N3b3JkPzogbnVsbCB8IHN0cmluZywgcGF0aD86IG51bGwgfCBzdHJpbmcsIGxvY2FsZT86IG51bGwgfCBXb3JkbGlzdCkge1xyXG4gICAgICAgIGlmIChwYXNzd29yZCA9PSBudWxsKSB7IHBhc3N3b3JkID0gXCJcIjsgfVxyXG4gICAgICAgIGlmIChwYXRoID09IG51bGwpIHsgcGF0aCA9IFwibS80NCcvNjAnLzAnLzBcIjsgfVxyXG4gICAgICAgIGlmIChsb2NhbGUgPT0gbnVsbCkgeyBsb2NhbGUgPSBMYW5nRW4ud29yZGxpc3QoKTsgfVxyXG4gICAgICAgIHRoaXMuI3Jvb3QgPSBIRE5vZGVXYWxsZXQuZnJvbVBocmFzZShwaHJhc2UsIHBhc3N3b3JkLCBwYXRoLCBsb2NhbGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFNpZ25lcihpbmRleD86IG51bWJlcik6IEhETm9kZVdhbGxldCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Jvb3QuZGVyaXZlQ2hpbGQoKGluZGV4ID09IG51bGwpID8gMDogaW5kZXgpO1xyXG4gICAgfVxyXG59XHJcbiovXHJcbi8qKlxyXG4gKiAgUmV0dXJucyB0aGUgW1tsaW5rLWJpcC0zMl1dIHBhdGggZm9yIHRoZSBhY2NvdW50IGF0ICUlaW5kZXglJS5cclxuICpcclxuICogIFRoaXMgaXMgdGhlIHBhdHRlcm4gdXNlZCBieSB3YWxsZXRzIGxpa2UgTGVkZ2VyLlxyXG4gKlxyXG4gKiAgVGhlcmUgaXMgYWxzbyBhbiBbYWx0ZXJuYXRlIHBhdHRlcm5dKGdldEluZGV4ZWRBY2NvdW50UGF0aCkgdXNlZCBieVxyXG4gKiAgc29tZSBzb2Z0d2FyZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBY2NvdW50UGF0aChfaW5kZXgpIHtcclxuICAgIGNvbnN0IGluZGV4ID0gZ2V0TnVtYmVyKF9pbmRleCwgXCJpbmRleFwiKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KGluZGV4ID49IDAgJiYgaW5kZXggPCBIYXJkZW5lZEJpdCwgXCJpbnZhbGlkIGFjY291bnQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XHJcbiAgICByZXR1cm4gYG0vNDQnLzYwJy8ke2luZGV4fScvMC8wYDtcclxufVxyXG4vKipcclxuICogIFJldHVybnMgdGhlIHBhdGggdXNpbmcgYW4gYWx0ZXJuYXRpdmUgcGF0dGVybiBmb3IgZGVyaXZpbmcgYWNjb3VudHMsXHJcbiAqICBhdCAlJWluZGV4JSUuXHJcbiAqXHJcbiAqICBUaGlzIGRlcml2YXRpb24gcGF0aCB1c2VzIHRoZSAvL2luZGV4Ly8gY29tcG9uZW50IHJhdGhlciB0aGFuIHRoZVxyXG4gKiAgLy9hY2NvdW50Ly8gY29tcG9uZW50IHRvIGRlcml2ZSBzZXF1ZW50aWFsIGFjY291bnRzLlxyXG4gKlxyXG4gKiAgVGhpcyBpcyB0aGUgcGF0dGVybiB1c2VkIGJ5IHdhbGxldHMgbGlrZSBNZXRhTWFzay5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmRleGVkQWNjb3VudFBhdGgoX2luZGV4KSB7XHJcbiAgICBjb25zdCBpbmRleCA9IGdldE51bWJlcihfaW5kZXgsIFwiaW5kZXhcIik7XHJcbiAgICBhc3NlcnRBcmd1bWVudChpbmRleCA+PSAwICYmIGluZGV4IDwgSGFyZGVuZWRCaXQsIFwiaW52YWxpZCBhY2NvdW50IGluZGV4XCIsIFwiaW5kZXhcIiwgaW5kZXgpO1xyXG4gICAgcmV0dXJuIGBtLzQ0Jy82MCcvMCcvMC8ke2luZGV4fWA7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGR3YWxsZXQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/hdwallet.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/wallet/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseWallet: () => (/* reexport safe */ _base_wallet_js__WEBPACK_IMPORTED_MODULE_0__.BaseWallet),\n/* harmony export */   HDNodeVoidWallet: () => (/* reexport safe */ _hdwallet_js__WEBPACK_IMPORTED_MODULE_1__.HDNodeVoidWallet),\n/* harmony export */   HDNodeWallet: () => (/* reexport safe */ _hdwallet_js__WEBPACK_IMPORTED_MODULE_1__.HDNodeWallet),\n/* harmony export */   Mnemonic: () => (/* reexport safe */ _mnemonic_js__WEBPACK_IMPORTED_MODULE_4__.Mnemonic),\n/* harmony export */   Wallet: () => (/* reexport safe */ _wallet_js__WEBPACK_IMPORTED_MODULE_5__.Wallet),\n/* harmony export */   decryptCrowdsaleJson: () => (/* reexport safe */ _json_crowdsale_js__WEBPACK_IMPORTED_MODULE_2__.decryptCrowdsaleJson),\n/* harmony export */   decryptKeystoreJson: () => (/* reexport safe */ _json_keystore_js__WEBPACK_IMPORTED_MODULE_3__.decryptKeystoreJson),\n/* harmony export */   decryptKeystoreJsonSync: () => (/* reexport safe */ _json_keystore_js__WEBPACK_IMPORTED_MODULE_3__.decryptKeystoreJsonSync),\n/* harmony export */   defaultPath: () => (/* reexport safe */ _hdwallet_js__WEBPACK_IMPORTED_MODULE_1__.defaultPath),\n/* harmony export */   encryptKeystoreJson: () => (/* reexport safe */ _json_keystore_js__WEBPACK_IMPORTED_MODULE_3__.encryptKeystoreJson),\n/* harmony export */   encryptKeystoreJsonSync: () => (/* reexport safe */ _json_keystore_js__WEBPACK_IMPORTED_MODULE_3__.encryptKeystoreJsonSync),\n/* harmony export */   getAccountPath: () => (/* reexport safe */ _hdwallet_js__WEBPACK_IMPORTED_MODULE_1__.getAccountPath),\n/* harmony export */   getIndexedAccountPath: () => (/* reexport safe */ _hdwallet_js__WEBPACK_IMPORTED_MODULE_1__.getIndexedAccountPath),\n/* harmony export */   isCrowdsaleJson: () => (/* reexport safe */ _json_crowdsale_js__WEBPACK_IMPORTED_MODULE_2__.isCrowdsaleJson),\n/* harmony export */   isKeystoreJson: () => (/* reexport safe */ _json_keystore_js__WEBPACK_IMPORTED_MODULE_3__.isKeystoreJson)\n/* harmony export */ });\n/* harmony import */ var _base_wallet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base-wallet.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/base-wallet.js\");\n/* harmony import */ var _hdwallet_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hdwallet.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/hdwallet.js\");\n/* harmony import */ var _json_crowdsale_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./json-crowdsale.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/json-crowdsale.js\");\n/* harmony import */ var _json_keystore_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./json-keystore.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/json-keystore.js\");\n/* harmony import */ var _mnemonic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mnemonic.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/mnemonic.js\");\n/* harmony import */ var _wallet_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wallet.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/wallet.js\");\n/**\r\n *  When interacting with Ethereum, it is necessary to use a private\r\n *  key authenticate actions by signing a payload.\r\n *\r\n *  Wallets are the simplest way to expose the concept of an\r\n *  //Externally Owner Account// (EOA) as it wraps a private key\r\n *  and supports high-level methods to sign common types of interaction\r\n *  and send transactions.\r\n *\r\n *  The class most developers will want to use is [[Wallet]], which\r\n *  can load a private key directly or from any common wallet format.\r\n *\r\n *  The [[HDNodeWallet]] can be used when it is necessary to access\r\n *  low-level details of how an HD wallets are derived, exported\r\n *  or imported.\r\n *\r\n *  @_section: api/wallet:Wallets  [about-wallets]\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhDO0FBQ3NFO0FBQ3hDO0FBQ29FO0FBQ3ZHO0FBQ0o7QUFDckMiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcd2FsbGV0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIFdoZW4gaW50ZXJhY3Rpbmcgd2l0aCBFdGhlcmV1bSwgaXQgaXMgbmVjZXNzYXJ5IHRvIHVzZSBhIHByaXZhdGVcclxuICogIGtleSBhdXRoZW50aWNhdGUgYWN0aW9ucyBieSBzaWduaW5nIGEgcGF5bG9hZC5cclxuICpcclxuICogIFdhbGxldHMgYXJlIHRoZSBzaW1wbGVzdCB3YXkgdG8gZXhwb3NlIHRoZSBjb25jZXB0IG9mIGFuXHJcbiAqICAvL0V4dGVybmFsbHkgT3duZXIgQWNjb3VudC8vIChFT0EpIGFzIGl0IHdyYXBzIGEgcHJpdmF0ZSBrZXlcclxuICogIGFuZCBzdXBwb3J0cyBoaWdoLWxldmVsIG1ldGhvZHMgdG8gc2lnbiBjb21tb24gdHlwZXMgb2YgaW50ZXJhY3Rpb25cclxuICogIGFuZCBzZW5kIHRyYW5zYWN0aW9ucy5cclxuICpcclxuICogIFRoZSBjbGFzcyBtb3N0IGRldmVsb3BlcnMgd2lsbCB3YW50IHRvIHVzZSBpcyBbW1dhbGxldF1dLCB3aGljaFxyXG4gKiAgY2FuIGxvYWQgYSBwcml2YXRlIGtleSBkaXJlY3RseSBvciBmcm9tIGFueSBjb21tb24gd2FsbGV0IGZvcm1hdC5cclxuICpcclxuICogIFRoZSBbW0hETm9kZVdhbGxldF1dIGNhbiBiZSB1c2VkIHdoZW4gaXQgaXMgbmVjZXNzYXJ5IHRvIGFjY2Vzc1xyXG4gKiAgbG93LWxldmVsIGRldGFpbHMgb2YgaG93IGFuIEhEIHdhbGxldHMgYXJlIGRlcml2ZWQsIGV4cG9ydGVkXHJcbiAqICBvciBpbXBvcnRlZC5cclxuICpcclxuICogIEBfc2VjdGlvbjogYXBpL3dhbGxldDpXYWxsZXRzICBbYWJvdXQtd2FsbGV0c11cclxuICovXHJcbmV4cG9ydCB7IEJhc2VXYWxsZXQgfSBmcm9tIFwiLi9iYXNlLXdhbGxldC5qc1wiO1xyXG5leHBvcnQgeyBkZWZhdWx0UGF0aCwgZ2V0QWNjb3VudFBhdGgsIGdldEluZGV4ZWRBY2NvdW50UGF0aCwgSEROb2RlV2FsbGV0LCBIRE5vZGVWb2lkV2FsbGV0LCB9IGZyb20gXCIuL2hkd2FsbGV0LmpzXCI7XHJcbmV4cG9ydCB7IGlzQ3Jvd2RzYWxlSnNvbiwgZGVjcnlwdENyb3dkc2FsZUpzb24gfSBmcm9tIFwiLi9qc29uLWNyb3dkc2FsZS5qc1wiO1xyXG5leHBvcnQgeyBpc0tleXN0b3JlSnNvbiwgZGVjcnlwdEtleXN0b3JlSnNvblN5bmMsIGRlY3J5cHRLZXlzdG9yZUpzb24sIGVuY3J5cHRLZXlzdG9yZUpzb24sIGVuY3J5cHRLZXlzdG9yZUpzb25TeW5jIH0gZnJvbSBcIi4vanNvbi1rZXlzdG9yZS5qc1wiO1xyXG5leHBvcnQgeyBNbmVtb25pYyB9IGZyb20gXCIuL21uZW1vbmljLmpzXCI7XHJcbmV4cG9ydCB7IFdhbGxldCB9IGZyb20gXCIuL3dhbGxldC5qc1wiO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/json-crowdsale.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/wallet/json-crowdsale.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decryptCrowdsaleJson: () => (/* binding */ decryptCrowdsaleJson),\n/* harmony export */   isCrowdsaleJson: () => (/* binding */ isCrowdsaleJson)\n/* harmony export */ });\n/* harmony import */ var aes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aes-js */ \"(pages-dir-browser)/./node_modules/aes-js/lib.esm/index.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../crypto/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../hash/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/utils.js\");\n/**\r\n *  @_subsection: api/wallet:JSON Wallets  [json-wallets]\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n *  Returns true if %%json%% is a valid JSON Crowdsale wallet.\r\n */\r\nfunction isCrowdsaleJson(json) {\r\n    try {\r\n        const data = JSON.parse(json);\r\n        if (data.encseed) {\r\n            return true;\r\n        }\r\n    }\r\n    catch (error) { }\r\n    return false;\r\n}\r\n// See: https://github.com/ethereum/pyethsaletool\r\n/**\r\n *  Before Ethereum launched, it was necessary to create a wallet\r\n *  format for backers to use, which would be used to receive ether\r\n *  as a reward for contributing to the project.\r\n *\r\n *  The [[link-crowdsale]] format is now obsolete, but it is still\r\n *  useful to support and the additional code is fairly trivial as\r\n *  all the primitives required are used through core portions of\r\n *  the library.\r\n */\r\nfunction decryptCrowdsaleJson(json, _password) {\r\n    const data = JSON.parse(json);\r\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPassword)(_password);\r\n    // Ethereum Address\r\n    const address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"ethaddr:string!\"));\r\n    // Encrypted Seed\r\n    const encseed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.looseArrayify)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"encseed:string!\"));\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(encseed && (encseed.length % 16) === 0, \"invalid encseed\", \"json\", json);\r\n    const key = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.pbkdf2)(password, password, 2000, 32, \"sha256\")).slice(0, 16);\r\n    const iv = encseed.slice(0, 16);\r\n    const encryptedSeed = encseed.slice(16);\r\n    // Decrypt the seed\r\n    const aesCbc = new aes_js__WEBPACK_IMPORTED_MODULE_0__.CBC(key, iv);\r\n    const seed = (0,aes_js__WEBPACK_IMPORTED_MODULE_0__.pkcs7Strip)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBytes)(aesCbc.decrypt(encryptedSeed)));\r\n    // This wallet format is weird... Convert the binary encoded hex to a string.\r\n    let seedHex = \"\";\r\n    for (let i = 0; i < seed.length; i++) {\r\n        seedHex += String.fromCharCode(seed[i]);\r\n    }\r\n    return { address, privateKey: (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_5__.id)(seedHex) };\r\n}\r\n//# sourceMappingURL=json-crowdsale.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvanNvbi1jcm93ZHNhbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDeUM7QUFDUTtBQUNMO0FBQ047QUFDdUI7QUFDSTtBQUNqRTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EscUJBQXFCLHNEQUFXO0FBQ2hDO0FBQ0Esb0JBQW9CLDZEQUFVLENBQUMsa0RBQU87QUFDdEM7QUFDQSxvQkFBb0Isd0RBQWEsQ0FBQyxrREFBTztBQUN6QyxJQUFJLCtEQUFjO0FBQ2xCLGdCQUFnQix5REFBUSxDQUFDLHdEQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1Q0FBRztBQUMxQixpQkFBaUIsa0RBQVUsQ0FBQyx5REFBUTtBQUNwQztBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0EsYUFBYSxxQkFBcUIsa0RBQUU7QUFDcEM7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFx3YWxsZXRcXGpzb24tY3Jvd2RzYWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvd2FsbGV0OkpTT04gV2FsbGV0cyAgW2pzb24td2FsbGV0c11cclxuICovXHJcbmltcG9ydCB7IENCQywgcGtjczdTdHJpcCB9IGZyb20gXCJhZXMtanNcIjtcclxuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IHBia2RmMiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcclxuaW1wb3J0IHsgaWQgfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBnZXRCeXRlcywgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgZ2V0UGFzc3dvcmQsIGxvb3NlQXJyYXlpZnksIHNwZWx1bmsgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xyXG4vKipcclxuICogIFJldHVybnMgdHJ1ZSBpZiAlJWpzb24lJSBpcyBhIHZhbGlkIEpTT04gQ3Jvd2RzYWxlIHdhbGxldC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0Nyb3dkc2FsZUpzb24oanNvbikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcclxuICAgICAgICBpZiAoZGF0YS5lbmNzZWVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vcHlldGhzYWxldG9vbFxyXG4vKipcclxuICogIEJlZm9yZSBFdGhlcmV1bSBsYXVuY2hlZCwgaXQgd2FzIG5lY2Vzc2FyeSB0byBjcmVhdGUgYSB3YWxsZXRcclxuICogIGZvcm1hdCBmb3IgYmFja2VycyB0byB1c2UsIHdoaWNoIHdvdWxkIGJlIHVzZWQgdG8gcmVjZWl2ZSBldGhlclxyXG4gKiAgYXMgYSByZXdhcmQgZm9yIGNvbnRyaWJ1dGluZyB0byB0aGUgcHJvamVjdC5cclxuICpcclxuICogIFRoZSBbW2xpbmstY3Jvd2RzYWxlXV0gZm9ybWF0IGlzIG5vdyBvYnNvbGV0ZSwgYnV0IGl0IGlzIHN0aWxsXHJcbiAqICB1c2VmdWwgdG8gc3VwcG9ydCBhbmQgdGhlIGFkZGl0aW9uYWwgY29kZSBpcyBmYWlybHkgdHJpdmlhbCBhc1xyXG4gKiAgYWxsIHRoZSBwcmltaXRpdmVzIHJlcXVpcmVkIGFyZSB1c2VkIHRocm91Z2ggY29yZSBwb3J0aW9ucyBvZlxyXG4gKiAgdGhlIGxpYnJhcnkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGVjcnlwdENyb3dkc2FsZUpzb24oanNvbiwgX3Bhc3N3b3JkKSB7XHJcbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcclxuICAgIGNvbnN0IHBhc3N3b3JkID0gZ2V0UGFzc3dvcmQoX3Bhc3N3b3JkKTtcclxuICAgIC8vIEV0aGVyZXVtIEFkZHJlc3NcclxuICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRBZGRyZXNzKHNwZWx1bmsoZGF0YSwgXCJldGhhZGRyOnN0cmluZyFcIikpO1xyXG4gICAgLy8gRW5jcnlwdGVkIFNlZWRcclxuICAgIGNvbnN0IGVuY3NlZWQgPSBsb29zZUFycmF5aWZ5KHNwZWx1bmsoZGF0YSwgXCJlbmNzZWVkOnN0cmluZyFcIikpO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQoZW5jc2VlZCAmJiAoZW5jc2VlZC5sZW5ndGggJSAxNikgPT09IDAsIFwiaW52YWxpZCBlbmNzZWVkXCIsIFwianNvblwiLCBqc29uKTtcclxuICAgIGNvbnN0IGtleSA9IGdldEJ5dGVzKHBia2RmMihwYXNzd29yZCwgcGFzc3dvcmQsIDIwMDAsIDMyLCBcInNoYTI1NlwiKSkuc2xpY2UoMCwgMTYpO1xyXG4gICAgY29uc3QgaXYgPSBlbmNzZWVkLnNsaWNlKDAsIDE2KTtcclxuICAgIGNvbnN0IGVuY3J5cHRlZFNlZWQgPSBlbmNzZWVkLnNsaWNlKDE2KTtcclxuICAgIC8vIERlY3J5cHQgdGhlIHNlZWRcclxuICAgIGNvbnN0IGFlc0NiYyA9IG5ldyBDQkMoa2V5LCBpdik7XHJcbiAgICBjb25zdCBzZWVkID0gcGtjczdTdHJpcChnZXRCeXRlcyhhZXNDYmMuZGVjcnlwdChlbmNyeXB0ZWRTZWVkKSkpO1xyXG4gICAgLy8gVGhpcyB3YWxsZXQgZm9ybWF0IGlzIHdlaXJkLi4uIENvbnZlcnQgdGhlIGJpbmFyeSBlbmNvZGVkIGhleCB0byBhIHN0cmluZy5cclxuICAgIGxldCBzZWVkSGV4ID0gXCJcIjtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHNlZWRIZXggKz0gU3RyaW5nLmZyb21DaGFyQ29kZShzZWVkW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGFkZHJlc3MsIHByaXZhdGVLZXk6IGlkKHNlZWRIZXgpIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi1jcm93ZHNhbGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/json-crowdsale.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/json-keystore.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/wallet/json-keystore.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decryptKeystoreJson: () => (/* binding */ decryptKeystoreJson),\n/* harmony export */   decryptKeystoreJsonSync: () => (/* binding */ decryptKeystoreJsonSync),\n/* harmony export */   encryptKeystoreJson: () => (/* binding */ encryptKeystoreJson),\n/* harmony export */   encryptKeystoreJsonSync: () => (/* binding */ encryptKeystoreJsonSync),\n/* harmony export */   isKeystoreJson: () => (/* binding */ isKeystoreJson)\n/* harmony export */ });\n/* harmony import */ var aes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aes-js */ \"(pages-dir-browser)/./node_modules/aes-js/lib.esm/index.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../address/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../crypto/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transaction/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/utils.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../_version.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/_version.js\");\n/**\r\n *  The JSON Wallet formats allow a simple way to store the private\r\n *  keys needed in Ethereum along with related information and allows\r\n *  for extensible forms of encryption.\r\n *\r\n *  These utilities facilitate decrypting and encrypting the most common\r\n *  JSON Wallet formats.\r\n *\r\n *  @_subsection: api/wallet:JSON Wallets  [json-wallets]\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst defaultPath = \"m/44'/60'/0'/0/0\";\r\n/**\r\n *  Returns true if %%json%% is a valid JSON Keystore Wallet.\r\n */\r\nfunction isKeystoreJson(json) {\r\n    try {\r\n        const data = JSON.parse(json);\r\n        const version = ((data.version != null) ? parseInt(data.version) : 0);\r\n        if (version === 3) {\r\n            return true;\r\n        }\r\n    }\r\n    catch (error) { }\r\n    return false;\r\n}\r\nfunction decrypt(data, key, ciphertext) {\r\n    const cipher = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.cipher:string\");\r\n    if (cipher === \"aes-128-ctr\") {\r\n        const iv = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.cipherparams.iv:data!\");\r\n        const aesCtr = new aes_js__WEBPACK_IMPORTED_MODULE_0__.CTR(key, iv);\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(aesCtr.decrypt(ciphertext));\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"unsupported cipher\", \"UNSUPPORTED_OPERATION\", {\r\n        operation: \"decrypt\"\r\n    });\r\n}\r\nfunction getAccount(data, _key) {\r\n    const key = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(_key);\r\n    const ciphertext = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.ciphertext:data!\");\r\n    const computedMAC = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([key.slice(16, 32), ciphertext]))).substring(2);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(computedMAC === (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.mac:string!\").toLowerCase(), \"incorrect password\", \"password\", \"[ REDACTED ]\");\r\n    const privateKey = decrypt(data, key.slice(0, 16), ciphertext);\r\n    const address = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_4__.computeAddress)(privateKey);\r\n    if (data.address) {\r\n        let check = data.address.toLowerCase();\r\n        if (!check.startsWith(\"0x\")) {\r\n            check = \"0x\" + check;\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)((0,_address_index_js__WEBPACK_IMPORTED_MODULE_5__.getAddress)(check) === address, \"keystore address/privateKey mismatch\", \"address\", data.address);\r\n    }\r\n    const account = { address, privateKey };\r\n    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\r\n    const version = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"x-ethers.version:string\");\r\n    if (version === \"0.1\") {\r\n        const mnemonicKey = key.slice(32, 64);\r\n        const mnemonicCiphertext = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"x-ethers.mnemonicCiphertext:data!\");\r\n        const mnemonicIv = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"x-ethers.mnemonicCounter:data!\");\r\n        const mnemonicAesCtr = new aes_js__WEBPACK_IMPORTED_MODULE_0__.CTR(mnemonicKey, mnemonicIv);\r\n        account.mnemonic = {\r\n            path: ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"x-ethers.path:string\") || defaultPath),\r\n            locale: ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"x-ethers.locale:string\") || \"en\"),\r\n            entropy: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(mnemonicAesCtr.decrypt(mnemonicCiphertext)))\r\n        };\r\n    }\r\n    return account;\r\n}\r\nfunction getDecryptKdfParams(data) {\r\n    const kdf = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdf:string\");\r\n    if (kdf && typeof (kdf) === \"string\") {\r\n        if (kdf.toLowerCase() === \"scrypt\") {\r\n            const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.salt:data!\");\r\n            const N = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.n:int!\");\r\n            const r = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.r:int!\");\r\n            const p = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.p:int!\");\r\n            // Make sure N is a power of 2\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(N > 0 && (N & (N - 1)) === 0, \"invalid kdf.N\", \"kdf.N\", N);\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(r > 0 && p > 0, \"invalid kdf\", \"kdf\", kdf);\r\n            const dkLen = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.dklen:int!\");\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(dkLen === 32, \"invalid kdf.dklen\", \"kdf.dflen\", dkLen);\r\n            return { name: \"scrypt\", salt, N, r, p, dkLen: 64 };\r\n        }\r\n        else if (kdf.toLowerCase() === \"pbkdf2\") {\r\n            const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.salt:data!\");\r\n            const prf = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.prf:string!\");\r\n            const algorithm = prf.split(\"-\").pop();\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(algorithm === \"sha256\" || algorithm === \"sha512\", \"invalid kdf.pdf\", \"kdf.pdf\", prf);\r\n            const count = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.c:int!\");\r\n            const dkLen = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.dklen:int!\");\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(dkLen === 32, \"invalid kdf.dklen\", \"kdf.dklen\", dkLen);\r\n            return { name: \"pbkdf2\", salt, count, dkLen, algorithm };\r\n        }\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"unsupported key-derivation function\", \"kdf\", kdf);\r\n}\r\n/**\r\n *  Returns the account details for the JSON Keystore Wallet %%json%%\r\n *  using %%password%%.\r\n *\r\n *  It is preferred to use the [async version](decryptKeystoreJson)\r\n *  instead, which allows a [[ProgressCallback]] to keep the user informed\r\n *  as to the decryption status.\r\n *\r\n *  This method will block the event loop (freezing all UI) until decryption\r\n *  is complete, which can take quite some time, depending on the wallet\r\n *  paramters and platform.\r\n */\r\nfunction decryptKeystoreJsonSync(json, _password) {\r\n    const data = JSON.parse(json);\r\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPassword)(_password);\r\n    const params = getDecryptKdfParams(data);\r\n    if (params.name === \"pbkdf2\") {\r\n        const { salt, count, dkLen, algorithm } = params;\r\n        const key = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.pbkdf2)(password, salt, count, dkLen, algorithm);\r\n        return getAccount(data, key);\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", { params });\r\n    const { salt, N, r, p, dkLen } = params;\r\n    const key = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.scryptSync)(password, salt, N, r, p, dkLen);\r\n    return getAccount(data, key);\r\n}\r\nfunction stall(duration) {\r\n    return new Promise((resolve) => { setTimeout(() => { resolve(); }, duration); });\r\n}\r\n/**\r\n *  Resolves to the decrypted JSON Keystore Wallet %%json%% using the\r\n *  %%password%%.\r\n *\r\n *  If provided, %%progress%% will be called periodically during the\r\n *  decrpytion to provide feedback, and if the function returns\r\n *  ``false`` will halt decryption.\r\n *\r\n *  The %%progressCallback%% will **always** receive ``0`` before\r\n *  decryption begins and ``1`` when complete.\r\n */\r\nasync function decryptKeystoreJson(json, _password, progress) {\r\n    const data = JSON.parse(json);\r\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPassword)(_password);\r\n    const params = getDecryptKdfParams(data);\r\n    if (params.name === \"pbkdf2\") {\r\n        if (progress) {\r\n            progress(0);\r\n            await stall(0);\r\n        }\r\n        const { salt, count, dkLen, algorithm } = params;\r\n        const key = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.pbkdf2)(password, salt, count, dkLen, algorithm);\r\n        if (progress) {\r\n            progress(1);\r\n            await stall(0);\r\n        }\r\n        return getAccount(data, key);\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", { params });\r\n    const { salt, N, r, p, dkLen } = params;\r\n    const key = await (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.scrypt)(password, salt, N, r, p, dkLen, progress);\r\n    return getAccount(data, key);\r\n}\r\nfunction getEncryptKdfParams(options) {\r\n    // Check/generate the salt\r\n    const salt = (options.salt != null) ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(options.salt, \"options.salt\") : (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.randomBytes)(32);\r\n    // Override the scrypt password-based key derivation function parameters\r\n    let N = (1 << 17), r = 8, p = 1;\r\n    if (options.scrypt) {\r\n        if (options.scrypt.N) {\r\n            N = options.scrypt.N;\r\n        }\r\n        if (options.scrypt.r) {\r\n            r = options.scrypt.r;\r\n        }\r\n        if (options.scrypt.p) {\r\n            p = options.scrypt.p;\r\n        }\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof (N) === \"number\" && N > 0 && Number.isSafeInteger(N) && (BigInt(N) & BigInt(N - 1)) === BigInt(0), \"invalid scrypt N parameter\", \"options.N\", N);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof (r) === \"number\" && r > 0 && Number.isSafeInteger(r), \"invalid scrypt r parameter\", \"options.r\", r);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof (p) === \"number\" && p > 0 && Number.isSafeInteger(p), \"invalid scrypt p parameter\", \"options.p\", p);\r\n    return { name: \"scrypt\", dkLen: 32, salt, N, r, p };\r\n}\r\nfunction _encryptKeystore(key, kdf, account, options) {\r\n    const privateKey = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(account.privateKey, \"privateKey\");\r\n    // Override initialization vector\r\n    const iv = (options.iv != null) ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(options.iv, \"options.iv\") : (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.randomBytes)(16);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(iv.length === 16, \"invalid options.iv length\", \"options.iv\", options.iv);\r\n    // Override the uuid\r\n    const uuidRandom = (options.uuid != null) ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(options.uuid, \"options.uuid\") : (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.randomBytes)(16);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(uuidRandom.length === 16, \"invalid options.uuid length\", \"options.uuid\", options.iv);\r\n    // This will be used to encrypt the wallet (as per Web3 secret storage)\r\n    // - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\r\n    // - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\r\n    const derivedKey = key.slice(0, 16);\r\n    const macPrefix = key.slice(16, 32);\r\n    // Encrypt the private key\r\n    const aesCtr = new aes_js__WEBPACK_IMPORTED_MODULE_0__.CTR(derivedKey, iv);\r\n    const ciphertext = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(aesCtr.encrypt(privateKey));\r\n    // Compute the message authentication code, used to check the password\r\n    const mac = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([macPrefix, ciphertext]));\r\n    // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\r\n    const data = {\r\n        address: account.address.substring(2).toLowerCase(),\r\n        id: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.uuidV4)(uuidRandom),\r\n        version: 3,\r\n        Crypto: {\r\n            cipher: \"aes-128-ctr\",\r\n            cipherparams: {\r\n                iv: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(iv).substring(2),\r\n            },\r\n            ciphertext: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(ciphertext).substring(2),\r\n            kdf: \"scrypt\",\r\n            kdfparams: {\r\n                salt: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(kdf.salt).substring(2),\r\n                n: kdf.N,\r\n                dklen: 32,\r\n                p: kdf.p,\r\n                r: kdf.r\r\n            },\r\n            mac: mac.substring(2)\r\n        }\r\n    };\r\n    // If we have a mnemonic, encrypt it into the JSON wallet\r\n    if (account.mnemonic) {\r\n        const client = (options.client != null) ? options.client : `ethers/${_version_js__WEBPACK_IMPORTED_MODULE_6__.version}`;\r\n        const path = account.mnemonic.path || defaultPath;\r\n        const locale = account.mnemonic.locale || \"en\";\r\n        const mnemonicKey = key.slice(32, 64);\r\n        const entropy = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(account.mnemonic.entropy, \"account.mnemonic.entropy\");\r\n        const mnemonicIv = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.randomBytes)(16);\r\n        const mnemonicAesCtr = new aes_js__WEBPACK_IMPORTED_MODULE_0__.CTR(mnemonicKey, mnemonicIv);\r\n        const mnemonicCiphertext = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(mnemonicAesCtr.encrypt(entropy));\r\n        const now = new Date();\r\n        const timestamp = (now.getUTCFullYear() + \"-\" +\r\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.zpad)(now.getUTCMonth() + 1, 2) + \"-\" +\r\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.zpad)(now.getUTCDate(), 2) + \"T\" +\r\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.zpad)(now.getUTCHours(), 2) + \"-\" +\r\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.zpad)(now.getUTCMinutes(), 2) + \"-\" +\r\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.zpad)(now.getUTCSeconds(), 2) + \".0Z\");\r\n        const gethFilename = (\"UTC--\" + timestamp + \"--\" + data.address);\r\n        data[\"x-ethers\"] = {\r\n            client, gethFilename, path, locale,\r\n            mnemonicCounter: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(mnemonicIv).substring(2),\r\n            mnemonicCiphertext: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(mnemonicCiphertext).substring(2),\r\n            version: \"0.1\"\r\n        };\r\n    }\r\n    return JSON.stringify(data);\r\n}\r\n/**\r\n *  Return the JSON Keystore Wallet for %%account%% encrypted with\r\n *  %%password%%.\r\n *\r\n *  The %%options%% can be used to tune the password-based key\r\n *  derivation function parameters, explicitly set the random values\r\n *  used. Any provided [[ProgressCallback]] is ignord.\r\n */\r\nfunction encryptKeystoreJsonSync(account, password, options) {\r\n    if (options == null) {\r\n        options = {};\r\n    }\r\n    const passwordBytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPassword)(password);\r\n    const kdf = getEncryptKdfParams(options);\r\n    const key = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.scryptSync)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);\r\n    return _encryptKeystore((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(key), kdf, account, options);\r\n}\r\n/**\r\n *  Resolved to the JSON Keystore Wallet for %%account%% encrypted\r\n *  with %%password%%.\r\n *\r\n *  The %%options%% can be used to tune the password-based key\r\n *  derivation function parameters, explicitly set the random values\r\n *  used and provide a [[ProgressCallback]] to receive periodic updates\r\n *  on the completion status..\r\n */\r\nasync function encryptKeystoreJson(account, password, options) {\r\n    if (options == null) {\r\n        options = {};\r\n    }\r\n    const passwordBytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPassword)(password);\r\n    const kdf = getEncryptKdfParams(options);\r\n    const key = await (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.scrypt)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);\r\n    return _encryptKeystore((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(key), kdf, account, options);\r\n}\r\n//# sourceMappingURL=json-keystore.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvanNvbi1rZXlzdG9yZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2QjtBQUNvQjtBQUN1QztBQUMvQjtBQUNxQztBQUN0QztBQUNmO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFPO0FBQzFCO0FBQ0EsbUJBQW1CLGtEQUFPO0FBQzFCLDJCQUEyQix1Q0FBRztBQUM5QixlQUFlLHdEQUFPO0FBQ3RCO0FBQ0EsSUFBSSx1REFBTTtBQUNWO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IseURBQVE7QUFDeEIsdUJBQXVCLGtEQUFPO0FBQzlCLHdCQUF3Qix3REFBTyxDQUFDLDJEQUFTLENBQUMsdURBQU07QUFDaEQsSUFBSSwrREFBYyxpQkFBaUIsa0RBQU87QUFDMUM7QUFDQSxvQkFBb0IscUVBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWMsQ0FBQyw2REFBVTtBQUNqQztBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLG9CQUFvQixrREFBTztBQUMzQjtBQUNBO0FBQ0EsbUNBQW1DLGtEQUFPO0FBQzFDLDJCQUEyQixrREFBTztBQUNsQyxtQ0FBbUMsdUNBQUc7QUFDdEM7QUFDQSxtQkFBbUIsa0RBQU87QUFDMUIscUJBQXFCLGtEQUFPO0FBQzVCLHFCQUFxQix3REFBTyxDQUFDLHlEQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0RBQU87QUFDdkI7QUFDQTtBQUNBLHlCQUF5QixrREFBTztBQUNoQyxzQkFBc0Isa0RBQU87QUFDN0Isc0JBQXNCLGtEQUFPO0FB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QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzREFBVztBQUNyQztBQUNBLHNCQUFzQix3REFBTTtBQUM1Qiw0QkFBNEIseURBQVE7QUFDcEM7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFx3YWxsZXRcXGpzb24ta2V5c3RvcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqICBUaGUgSlNPTiBXYWxsZXQgZm9ybWF0cyBhbGxvdyBhIHNpbXBsZSB3YXkgdG8gc3RvcmUgdGhlIHByaXZhdGVcclxuICogIGtleXMgbmVlZGVkIGluIEV0aGVyZXVtIGFsb25nIHdpdGggcmVsYXRlZCBpbmZvcm1hdGlvbiBhbmQgYWxsb3dzXHJcbiAqICBmb3IgZXh0ZW5zaWJsZSBmb3JtcyBvZiBlbmNyeXB0aW9uLlxyXG4gKlxyXG4gKiAgVGhlc2UgdXRpbGl0aWVzIGZhY2lsaXRhdGUgZGVjcnlwdGluZyBhbmQgZW5jcnlwdGluZyB0aGUgbW9zdCBjb21tb25cclxuICogIEpTT04gV2FsbGV0IGZvcm1hdHMuXHJcbiAqXHJcbiAqICBAX3N1YnNlY3Rpb246IGFwaS93YWxsZXQ6SlNPTiBXYWxsZXRzICBbanNvbi13YWxsZXRzXVxyXG4gKi9cclxuaW1wb3J0IHsgQ1RSIH0gZnJvbSBcImFlcy1qc1wiO1xyXG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcclxuaW1wb3J0IHsga2VjY2FrMjU2LCBwYmtkZjIsIHJhbmRvbUJ5dGVzLCBzY3J5cHQsIHNjcnlwdFN5bmMgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGNvbXB1dGVBZGRyZXNzIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGNvbmNhdCwgZ2V0Qnl0ZXMsIGhleGxpZnksIHV1aWRWNCwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBnZXRQYXNzd29yZCwgc3BlbHVuaywgenBhZCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XHJcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3ZlcnNpb24uanNcIjtcclxuY29uc3QgZGVmYXVsdFBhdGggPSBcIm0vNDQnLzYwJy8wJy8wLzBcIjtcclxuLyoqXHJcbiAqICBSZXR1cm5zIHRydWUgaWYgJSVqc29uJSUgaXMgYSB2YWxpZCBKU09OIEtleXN0b3JlIFdhbGxldC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0tleXN0b3JlSnNvbihqc29uKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xyXG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSAoKGRhdGEudmVyc2lvbiAhPSBudWxsKSA/IHBhcnNlSW50KGRhdGEudmVyc2lvbikgOiAwKTtcclxuICAgICAgICBpZiAodmVyc2lvbiA9PT0gMykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGRlY3J5cHQoZGF0YSwga2V5LCBjaXBoZXJ0ZXh0KSB7XHJcbiAgICBjb25zdCBjaXBoZXIgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmNpcGhlcjpzdHJpbmdcIik7XHJcbiAgICBpZiAoY2lwaGVyID09PSBcImFlcy0xMjgtY3RyXCIpIHtcclxuICAgICAgICBjb25zdCBpdiA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8uY2lwaGVycGFyYW1zLml2OmRhdGEhXCIpO1xyXG4gICAgICAgIGNvbnN0IGFlc0N0ciA9IG5ldyBDVFIoa2V5LCBpdik7XHJcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoYWVzQ3RyLmRlY3J5cHQoY2lwaGVydGV4dCkpO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIGNpcGhlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgb3BlcmF0aW9uOiBcImRlY3J5cHRcIlxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QWNjb3VudChkYXRhLCBfa2V5KSB7XHJcbiAgICBjb25zdCBrZXkgPSBnZXRCeXRlcyhfa2V5KTtcclxuICAgIGNvbnN0IGNpcGhlcnRleHQgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmNpcGhlcnRleHQ6ZGF0YSFcIik7XHJcbiAgICBjb25zdCBjb21wdXRlZE1BQyA9IGhleGxpZnkoa2VjY2FrMjU2KGNvbmNhdChba2V5LnNsaWNlKDE2LCAzMiksIGNpcGhlcnRleHRdKSkpLnN1YnN0cmluZygyKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KGNvbXB1dGVkTUFDID09PSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLm1hYzpzdHJpbmchXCIpLnRvTG93ZXJDYXNlKCksIFwiaW5jb3JyZWN0IHBhc3N3b3JkXCIsIFwicGFzc3dvcmRcIiwgXCJbIFJFREFDVEVEIF1cIik7XHJcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gZGVjcnlwdChkYXRhLCBrZXkuc2xpY2UoMCwgMTYpLCBjaXBoZXJ0ZXh0KTtcclxuICAgIGNvbnN0IGFkZHJlc3MgPSBjb21wdXRlQWRkcmVzcyhwcml2YXRlS2V5KTtcclxuICAgIGlmIChkYXRhLmFkZHJlc3MpIHtcclxuICAgICAgICBsZXQgY2hlY2sgPSBkYXRhLmFkZHJlc3MudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZiAoIWNoZWNrLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xyXG4gICAgICAgICAgICBjaGVjayA9IFwiMHhcIiArIGNoZWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnRBcmd1bWVudChnZXRBZGRyZXNzKGNoZWNrKSA9PT0gYWRkcmVzcywgXCJrZXlzdG9yZSBhZGRyZXNzL3ByaXZhdGVLZXkgbWlzbWF0Y2hcIiwgXCJhZGRyZXNzXCIsIGRhdGEuYWRkcmVzcyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhY2NvdW50ID0geyBhZGRyZXNzLCBwcml2YXRlS2V5IH07XHJcbiAgICAvLyBWZXJzaW9uIDAuMSB4LWV0aGVycyBtZXRhZGF0YSBtdXN0IGNvbnRhaW4gYW4gZW5jcnlwdGVkIG1uZW1vbmljIHBocmFzZVxyXG4gICAgY29uc3QgdmVyc2lvbiA9IHNwZWx1bmsoZGF0YSwgXCJ4LWV0aGVycy52ZXJzaW9uOnN0cmluZ1wiKTtcclxuICAgIGlmICh2ZXJzaW9uID09PSBcIjAuMVwiKSB7XHJcbiAgICAgICAgY29uc3QgbW5lbW9uaWNLZXkgPSBrZXkuc2xpY2UoMzIsIDY0KTtcclxuICAgICAgICBjb25zdCBtbmVtb25pY0NpcGhlcnRleHQgPSBzcGVsdW5rKGRhdGEsIFwieC1ldGhlcnMubW5lbW9uaWNDaXBoZXJ0ZXh0OmRhdGEhXCIpO1xyXG4gICAgICAgIGNvbnN0IG1uZW1vbmljSXYgPSBzcGVsdW5rKGRhdGEsIFwieC1ldGhlcnMubW5lbW9uaWNDb3VudGVyOmRhdGEhXCIpO1xyXG4gICAgICAgIGNvbnN0IG1uZW1vbmljQWVzQ3RyID0gbmV3IENUUihtbmVtb25pY0tleSwgbW5lbW9uaWNJdik7XHJcbiAgICAgICAgYWNjb3VudC5tbmVtb25pYyA9IHtcclxuICAgICAgICAgICAgcGF0aDogKHNwZWx1bmsoZGF0YSwgXCJ4LWV0aGVycy5wYXRoOnN0cmluZ1wiKSB8fCBkZWZhdWx0UGF0aCksXHJcbiAgICAgICAgICAgIGxvY2FsZTogKHNwZWx1bmsoZGF0YSwgXCJ4LWV0aGVycy5sb2NhbGU6c3RyaW5nXCIpIHx8IFwiZW5cIiksXHJcbiAgICAgICAgICAgIGVudHJvcHk6IGhleGxpZnkoZ2V0Qnl0ZXMobW5lbW9uaWNBZXNDdHIuZGVjcnlwdChtbmVtb25pY0NpcGhlcnRleHQpKSlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFjY291bnQ7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RGVjcnlwdEtkZlBhcmFtcyhkYXRhKSB7XHJcbiAgICBjb25zdCBrZGYgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmtkZjpzdHJpbmdcIik7XHJcbiAgICBpZiAoa2RmICYmIHR5cGVvZiAoa2RmKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGlmIChrZGYudG9Mb3dlckNhc2UoKSA9PT0gXCJzY3J5cHRcIikge1xyXG4gICAgICAgICAgICBjb25zdCBzYWx0ID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMuc2FsdDpkYXRhIVwiKTtcclxuICAgICAgICAgICAgY29uc3QgTiA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLm46aW50IVwiKTtcclxuICAgICAgICAgICAgY29uc3QgciA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLnI6aW50IVwiKTtcclxuICAgICAgICAgICAgY29uc3QgcCA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLnA6aW50IVwiKTtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIE4gaXMgYSBwb3dlciBvZiAyXHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KE4gPiAwICYmIChOICYgKE4gLSAxKSkgPT09IDAsIFwiaW52YWxpZCBrZGYuTlwiLCBcImtkZi5OXCIsIE4pO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyID4gMCAmJiBwID4gMCwgXCJpbnZhbGlkIGtkZlwiLCBcImtkZlwiLCBrZGYpO1xyXG4gICAgICAgICAgICBjb25zdCBka0xlbiA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLmRrbGVuOmludCFcIik7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGRrTGVuID09PSAzMiwgXCJpbnZhbGlkIGtkZi5ka2xlblwiLCBcImtkZi5kZmxlblwiLCBka0xlbik7XHJcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IFwic2NyeXB0XCIsIHNhbHQsIE4sIHIsIHAsIGRrTGVuOiA2NCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZGYudG9Mb3dlckNhc2UoKSA9PT0gXCJwYmtkZjJcIikge1xyXG4gICAgICAgICAgICBjb25zdCBzYWx0ID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMuc2FsdDpkYXRhIVwiKTtcclxuICAgICAgICAgICAgY29uc3QgcHJmID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMucHJmOnN0cmluZyFcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGFsZ29yaXRobSA9IHByZi5zcGxpdChcIi1cIikucG9wKCk7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFsZ29yaXRobSA9PT0gXCJzaGEyNTZcIiB8fCBhbGdvcml0aG0gPT09IFwic2hhNTEyXCIsIFwiaW52YWxpZCBrZGYucGRmXCIsIFwia2RmLnBkZlwiLCBwcmYpO1xyXG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLmM6aW50IVwiKTtcclxuICAgICAgICAgICAgY29uc3QgZGtMZW4gPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5ka2xlbjppbnQhXCIpO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChka0xlbiA9PT0gMzIsIFwiaW52YWxpZCBrZGYuZGtsZW5cIiwgXCJrZGYuZGtsZW5cIiwgZGtMZW4pO1xyXG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBcInBia2RmMlwiLCBzYWx0LCBjb3VudCwgZGtMZW4sIGFsZ29yaXRobSB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIGtleS1kZXJpdmF0aW9uIGZ1bmN0aW9uXCIsIFwia2RmXCIsIGtkZik7XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm5zIHRoZSBhY2NvdW50IGRldGFpbHMgZm9yIHRoZSBKU09OIEtleXN0b3JlIFdhbGxldCAlJWpzb24lJVxyXG4gKiAgdXNpbmcgJSVwYXNzd29yZCUlLlxyXG4gKlxyXG4gKiAgSXQgaXMgcHJlZmVycmVkIHRvIHVzZSB0aGUgW2FzeW5jIHZlcnNpb25dKGRlY3J5cHRLZXlzdG9yZUpzb24pXHJcbiAqICBpbnN0ZWFkLCB3aGljaCBhbGxvd3MgYSBbW1Byb2dyZXNzQ2FsbGJhY2tdXSB0byBrZWVwIHRoZSB1c2VyIGluZm9ybWVkXHJcbiAqICBhcyB0byB0aGUgZGVjcnlwdGlvbiBzdGF0dXMuXHJcbiAqXHJcbiAqICBUaGlzIG1ldGhvZCB3aWxsIGJsb2NrIHRoZSBldmVudCBsb29wIChmcmVlemluZyBhbGwgVUkpIHVudGlsIGRlY3J5cHRpb25cclxuICogIGlzIGNvbXBsZXRlLCB3aGljaCBjYW4gdGFrZSBxdWl0ZSBzb21lIHRpbWUsIGRlcGVuZGluZyBvbiB0aGUgd2FsbGV0XHJcbiAqICBwYXJhbXRlcnMgYW5kIHBsYXRmb3JtLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlY3J5cHRLZXlzdG9yZUpzb25TeW5jKGpzb24sIF9wYXNzd29yZCkge1xyXG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XHJcbiAgICBjb25zdCBwYXNzd29yZCA9IGdldFBhc3N3b3JkKF9wYXNzd29yZCk7XHJcbiAgICBjb25zdCBwYXJhbXMgPSBnZXREZWNyeXB0S2RmUGFyYW1zKGRhdGEpO1xyXG4gICAgaWYgKHBhcmFtcy5uYW1lID09PSBcInBia2RmMlwiKSB7XHJcbiAgICAgICAgY29uc3QgeyBzYWx0LCBjb3VudCwgZGtMZW4sIGFsZ29yaXRobSB9ID0gcGFyYW1zO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHBia2RmMihwYXNzd29yZCwgc2FsdCwgY291bnQsIGRrTGVuLCBhbGdvcml0aG0pO1xyXG4gICAgICAgIHJldHVybiBnZXRBY2NvdW50KGRhdGEsIGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3NlcnQocGFyYW1zLm5hbWUgPT09IFwic2NyeXB0XCIsIFwiY2Fubm90IGJlIHJlYWNoZWRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHsgcGFyYW1zIH0pO1xyXG4gICAgY29uc3QgeyBzYWx0LCBOLCByLCBwLCBka0xlbiB9ID0gcGFyYW1zO1xyXG4gICAgY29uc3Qga2V5ID0gc2NyeXB0U3luYyhwYXNzd29yZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4pO1xyXG4gICAgcmV0dXJuIGdldEFjY291bnQoZGF0YSwga2V5KTtcclxufVxyXG5mdW5jdGlvbiBzdGFsbChkdXJhdGlvbikge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7IHNldFRpbWVvdXQoKCkgPT4geyByZXNvbHZlKCk7IH0sIGR1cmF0aW9uKTsgfSk7XHJcbn1cclxuLyoqXHJcbiAqICBSZXNvbHZlcyB0byB0aGUgZGVjcnlwdGVkIEpTT04gS2V5c3RvcmUgV2FsbGV0ICUlanNvbiUlIHVzaW5nIHRoZVxyXG4gKiAgJSVwYXNzd29yZCUlLlxyXG4gKlxyXG4gKiAgSWYgcHJvdmlkZWQsICUlcHJvZ3Jlc3MlJSB3aWxsIGJlIGNhbGxlZCBwZXJpb2RpY2FsbHkgZHVyaW5nIHRoZVxyXG4gKiAgZGVjcnB5dGlvbiB0byBwcm92aWRlIGZlZWRiYWNrLCBhbmQgaWYgdGhlIGZ1bmN0aW9uIHJldHVybnNcclxuICogIGBgZmFsc2VgYCB3aWxsIGhhbHQgZGVjcnlwdGlvbi5cclxuICpcclxuICogIFRoZSAlJXByb2dyZXNzQ2FsbGJhY2slJSB3aWxsICoqYWx3YXlzKiogcmVjZWl2ZSBgYDBgYCBiZWZvcmVcclxuICogIGRlY3J5cHRpb24gYmVnaW5zIGFuZCBgYDFgYCB3aGVuIGNvbXBsZXRlLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlY3J5cHRLZXlzdG9yZUpzb24oanNvbiwgX3Bhc3N3b3JkLCBwcm9ncmVzcykge1xyXG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XHJcbiAgICBjb25zdCBwYXNzd29yZCA9IGdldFBhc3N3b3JkKF9wYXNzd29yZCk7XHJcbiAgICBjb25zdCBwYXJhbXMgPSBnZXREZWNyeXB0S2RmUGFyYW1zKGRhdGEpO1xyXG4gICAgaWYgKHBhcmFtcy5uYW1lID09PSBcInBia2RmMlwiKSB7XHJcbiAgICAgICAgaWYgKHByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgIHByb2dyZXNzKDApO1xyXG4gICAgICAgICAgICBhd2FpdCBzdGFsbCgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBzYWx0LCBjb3VudCwgZGtMZW4sIGFsZ29yaXRobSB9ID0gcGFyYW1zO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHBia2RmMihwYXNzd29yZCwgc2FsdCwgY291bnQsIGRrTGVuLCBhbGdvcml0aG0pO1xyXG4gICAgICAgIGlmIChwcm9ncmVzcykge1xyXG4gICAgICAgICAgICBwcm9ncmVzcygxKTtcclxuICAgICAgICAgICAgYXdhaXQgc3RhbGwoMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBnZXRBY2NvdW50KGRhdGEsIGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3NlcnQocGFyYW1zLm5hbWUgPT09IFwic2NyeXB0XCIsIFwiY2Fubm90IGJlIHJlYWNoZWRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHsgcGFyYW1zIH0pO1xyXG4gICAgY29uc3QgeyBzYWx0LCBOLCByLCBwLCBka0xlbiB9ID0gcGFyYW1zO1xyXG4gICAgY29uc3Qga2V5ID0gYXdhaXQgc2NyeXB0KHBhc3N3b3JkLCBzYWx0LCBOLCByLCBwLCBka0xlbiwgcHJvZ3Jlc3MpO1xyXG4gICAgcmV0dXJuIGdldEFjY291bnQoZGF0YSwga2V5KTtcclxufVxyXG5mdW5jdGlvbiBnZXRFbmNyeXB0S2RmUGFyYW1zKG9wdGlvbnMpIHtcclxuICAgIC8vIENoZWNrL2dlbmVyYXRlIHRoZSBzYWx0XHJcbiAgICBjb25zdCBzYWx0ID0gKG9wdGlvbnMuc2FsdCAhPSBudWxsKSA/IGdldEJ5dGVzKG9wdGlvbnMuc2FsdCwgXCJvcHRpb25zLnNhbHRcIikgOiByYW5kb21CeXRlcygzMik7XHJcbiAgICAvLyBPdmVycmlkZSB0aGUgc2NyeXB0IHBhc3N3b3JkLWJhc2VkIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIHBhcmFtZXRlcnNcclxuICAgIGxldCBOID0gKDEgPDwgMTcpLCByID0gOCwgcCA9IDE7XHJcbiAgICBpZiAob3B0aW9ucy5zY3J5cHQpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5zY3J5cHQuTikge1xyXG4gICAgICAgICAgICBOID0gb3B0aW9ucy5zY3J5cHQuTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NyeXB0LnIpIHtcclxuICAgICAgICAgICAgciA9IG9wdGlvbnMuc2NyeXB0LnI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLnNjcnlwdC5wKSB7XHJcbiAgICAgICAgICAgIHAgPSBvcHRpb25zLnNjcnlwdC5wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoTikgPT09IFwibnVtYmVyXCIgJiYgTiA+IDAgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIoTikgJiYgKEJpZ0ludChOKSAmIEJpZ0ludChOIC0gMSkpID09PSBCaWdJbnQoMCksIFwiaW52YWxpZCBzY3J5cHQgTiBwYXJhbWV0ZXJcIiwgXCJvcHRpb25zLk5cIiwgTik7XHJcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHIpID09PSBcIm51bWJlclwiICYmIHIgPiAwICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHIpLCBcImludmFsaWQgc2NyeXB0IHIgcGFyYW1ldGVyXCIsIFwib3B0aW9ucy5yXCIsIHIpO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChwKSA9PT0gXCJudW1iZXJcIiAmJiBwID4gMCAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcihwKSwgXCJpbnZhbGlkIHNjcnlwdCBwIHBhcmFtZXRlclwiLCBcIm9wdGlvbnMucFwiLCBwKTtcclxuICAgIHJldHVybiB7IG5hbWU6IFwic2NyeXB0XCIsIGRrTGVuOiAzMiwgc2FsdCwgTiwgciwgcCB9O1xyXG59XHJcbmZ1bmN0aW9uIF9lbmNyeXB0S2V5c3RvcmUoa2V5LCBrZGYsIGFjY291bnQsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBnZXRCeXRlcyhhY2NvdW50LnByaXZhdGVLZXksIFwicHJpdmF0ZUtleVwiKTtcclxuICAgIC8vIE92ZXJyaWRlIGluaXRpYWxpemF0aW9uIHZlY3RvclxyXG4gICAgY29uc3QgaXYgPSAob3B0aW9ucy5pdiAhPSBudWxsKSA/IGdldEJ5dGVzKG9wdGlvbnMuaXYsIFwib3B0aW9ucy5pdlwiKSA6IHJhbmRvbUJ5dGVzKDE2KTtcclxuICAgIGFzc2VydEFyZ3VtZW50KGl2Lmxlbmd0aCA9PT0gMTYsIFwiaW52YWxpZCBvcHRpb25zLml2IGxlbmd0aFwiLCBcIm9wdGlvbnMuaXZcIiwgb3B0aW9ucy5pdik7XHJcbiAgICAvLyBPdmVycmlkZSB0aGUgdXVpZFxyXG4gICAgY29uc3QgdXVpZFJhbmRvbSA9IChvcHRpb25zLnV1aWQgIT0gbnVsbCkgPyBnZXRCeXRlcyhvcHRpb25zLnV1aWQsIFwib3B0aW9ucy51dWlkXCIpIDogcmFuZG9tQnl0ZXMoMTYpO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQodXVpZFJhbmRvbS5sZW5ndGggPT09IDE2LCBcImludmFsaWQgb3B0aW9ucy51dWlkIGxlbmd0aFwiLCBcIm9wdGlvbnMudXVpZFwiLCBvcHRpb25zLml2KTtcclxuICAgIC8vIFRoaXMgd2lsbCBiZSB1c2VkIHRvIGVuY3J5cHQgdGhlIHdhbGxldCAoYXMgcGVyIFdlYjMgc2VjcmV0IHN0b3JhZ2UpXHJcbiAgICAvLyAtIDMyIGJ5dGVzICAgQXMgbm9ybWFsIGZvciB0aGUgV2ViMyBzZWNyZXQgc3RvcmFnZSAoZGVyaXZlZEtleSwgbWFjUHJlZml4KVxyXG4gICAgLy8gLSAzMiBieXRlcyAgIEFFUyBrZXkgdG8gZW5jcnlwdCBtbmVtb25pYyB3aXRoIChyZXF1aXJlZCBoZXJlIHRvIGJlIEV0aGVycyBXYWxsZXQpXHJcbiAgICBjb25zdCBkZXJpdmVkS2V5ID0ga2V5LnNsaWNlKDAsIDE2KTtcclxuICAgIGNvbnN0IG1hY1ByZWZpeCA9IGtleS5zbGljZSgxNiwgMzIpO1xyXG4gICAgLy8gRW5jcnlwdCB0aGUgcHJpdmF0ZSBrZXlcclxuICAgIGNvbnN0IGFlc0N0ciA9IG5ldyBDVFIoZGVyaXZlZEtleSwgaXYpO1xyXG4gICAgY29uc3QgY2lwaGVydGV4dCA9IGdldEJ5dGVzKGFlc0N0ci5lbmNyeXB0KHByaXZhdGVLZXkpKTtcclxuICAgIC8vIENvbXB1dGUgdGhlIG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZSwgdXNlZCB0byBjaGVjayB0aGUgcGFzc3dvcmRcclxuICAgIGNvbnN0IG1hYyA9IGtlY2NhazI1Nihjb25jYXQoW21hY1ByZWZpeCwgY2lwaGVydGV4dF0pKTtcclxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9XZWIzLVNlY3JldC1TdG9yYWdlLURlZmluaXRpb25cclxuICAgIGNvbnN0IGRhdGEgPSB7XHJcbiAgICAgICAgYWRkcmVzczogYWNjb3VudC5hZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgICAgIGlkOiB1dWlkVjQodXVpZFJhbmRvbSksXHJcbiAgICAgICAgdmVyc2lvbjogMyxcclxuICAgICAgICBDcnlwdG86IHtcclxuICAgICAgICAgICAgY2lwaGVyOiBcImFlcy0xMjgtY3RyXCIsXHJcbiAgICAgICAgICAgIGNpcGhlcnBhcmFtczoge1xyXG4gICAgICAgICAgICAgICAgaXY6IGhleGxpZnkoaXYpLnN1YnN0cmluZygyKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2lwaGVydGV4dDogaGV4bGlmeShjaXBoZXJ0ZXh0KS5zdWJzdHJpbmcoMiksXHJcbiAgICAgICAgICAgIGtkZjogXCJzY3J5cHRcIixcclxuICAgICAgICAgICAga2RmcGFyYW1zOiB7XHJcbiAgICAgICAgICAgICAgICBzYWx0OiBoZXhsaWZ5KGtkZi5zYWx0KS5zdWJzdHJpbmcoMiksXHJcbiAgICAgICAgICAgICAgICBuOiBrZGYuTixcclxuICAgICAgICAgICAgICAgIGRrbGVuOiAzMixcclxuICAgICAgICAgICAgICAgIHA6IGtkZi5wLFxyXG4gICAgICAgICAgICAgICAgcjoga2RmLnJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbWFjOiBtYWMuc3Vic3RyaW5nKDIpXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIElmIHdlIGhhdmUgYSBtbmVtb25pYywgZW5jcnlwdCBpdCBpbnRvIHRoZSBKU09OIHdhbGxldFxyXG4gICAgaWYgKGFjY291bnQubW5lbW9uaWMpIHtcclxuICAgICAgICBjb25zdCBjbGllbnQgPSAob3B0aW9ucy5jbGllbnQgIT0gbnVsbCkgPyBvcHRpb25zLmNsaWVudCA6IGBldGhlcnMvJHt2ZXJzaW9ufWA7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGFjY291bnQubW5lbW9uaWMucGF0aCB8fCBkZWZhdWx0UGF0aDtcclxuICAgICAgICBjb25zdCBsb2NhbGUgPSBhY2NvdW50Lm1uZW1vbmljLmxvY2FsZSB8fCBcImVuXCI7XHJcbiAgICAgICAgY29uc3QgbW5lbW9uaWNLZXkgPSBrZXkuc2xpY2UoMzIsIDY0KTtcclxuICAgICAgICBjb25zdCBlbnRyb3B5ID0gZ2V0Qnl0ZXMoYWNjb3VudC5tbmVtb25pYy5lbnRyb3B5LCBcImFjY291bnQubW5lbW9uaWMuZW50cm9weVwiKTtcclxuICAgICAgICBjb25zdCBtbmVtb25pY0l2ID0gcmFuZG9tQnl0ZXMoMTYpO1xyXG4gICAgICAgIGNvbnN0IG1uZW1vbmljQWVzQ3RyID0gbmV3IENUUihtbmVtb25pY0tleSwgbW5lbW9uaWNJdik7XHJcbiAgICAgICAgY29uc3QgbW5lbW9uaWNDaXBoZXJ0ZXh0ID0gZ2V0Qnl0ZXMobW5lbW9uaWNBZXNDdHIuZW5jcnlwdChlbnRyb3B5KSk7XHJcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcclxuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSAobm93LmdldFVUQ0Z1bGxZZWFyKCkgKyBcIi1cIiArXHJcbiAgICAgICAgICAgIHpwYWQobm93LmdldFVUQ01vbnRoKCkgKyAxLCAyKSArIFwiLVwiICtcclxuICAgICAgICAgICAgenBhZChub3cuZ2V0VVRDRGF0ZSgpLCAyKSArIFwiVFwiICtcclxuICAgICAgICAgICAgenBhZChub3cuZ2V0VVRDSG91cnMoKSwgMikgKyBcIi1cIiArXHJcbiAgICAgICAgICAgIHpwYWQobm93LmdldFVUQ01pbnV0ZXMoKSwgMikgKyBcIi1cIiArXHJcbiAgICAgICAgICAgIHpwYWQobm93LmdldFVUQ1NlY29uZHMoKSwgMikgKyBcIi4wWlwiKTtcclxuICAgICAgICBjb25zdCBnZXRoRmlsZW5hbWUgPSAoXCJVVEMtLVwiICsgdGltZXN0YW1wICsgXCItLVwiICsgZGF0YS5hZGRyZXNzKTtcclxuICAgICAgICBkYXRhW1wieC1ldGhlcnNcIl0gPSB7XHJcbiAgICAgICAgICAgIGNsaWVudCwgZ2V0aEZpbGVuYW1lLCBwYXRoLCBsb2NhbGUsXHJcbiAgICAgICAgICAgIG1uZW1vbmljQ291bnRlcjogaGV4bGlmeShtbmVtb25pY0l2KS5zdWJzdHJpbmcoMiksXHJcbiAgICAgICAgICAgIG1uZW1vbmljQ2lwaGVydGV4dDogaGV4bGlmeShtbmVtb25pY0NpcGhlcnRleHQpLnN1YnN0cmluZygyKSxcclxuICAgICAgICAgICAgdmVyc2lvbjogXCIwLjFcIlxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm4gdGhlIEpTT04gS2V5c3RvcmUgV2FsbGV0IGZvciAlJWFjY291bnQlJSBlbmNyeXB0ZWQgd2l0aFxyXG4gKiAgJSVwYXNzd29yZCUlLlxyXG4gKlxyXG4gKiAgVGhlICUlb3B0aW9ucyUlIGNhbiBiZSB1c2VkIHRvIHR1bmUgdGhlIHBhc3N3b3JkLWJhc2VkIGtleVxyXG4gKiAgZGVyaXZhdGlvbiBmdW5jdGlvbiBwYXJhbWV0ZXJzLCBleHBsaWNpdGx5IHNldCB0aGUgcmFuZG9tIHZhbHVlc1xyXG4gKiAgdXNlZC4gQW55IHByb3ZpZGVkIFtbUHJvZ3Jlc3NDYWxsYmFja11dIGlzIGlnbm9yZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlbmNyeXB0S2V5c3RvcmVKc29uU3luYyhhY2NvdW50LCBwYXNzd29yZCwgb3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xyXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgIH1cclxuICAgIGNvbnN0IHBhc3N3b3JkQnl0ZXMgPSBnZXRQYXNzd29yZChwYXNzd29yZCk7XHJcbiAgICBjb25zdCBrZGYgPSBnZXRFbmNyeXB0S2RmUGFyYW1zKG9wdGlvbnMpO1xyXG4gICAgY29uc3Qga2V5ID0gc2NyeXB0U3luYyhwYXNzd29yZEJ5dGVzLCBrZGYuc2FsdCwga2RmLk4sIGtkZi5yLCBrZGYucCwgNjQpO1xyXG4gICAgcmV0dXJuIF9lbmNyeXB0S2V5c3RvcmUoZ2V0Qnl0ZXMoa2V5KSwga2RmLCBhY2NvdW50LCBvcHRpb25zKTtcclxufVxyXG4vKipcclxuICogIFJlc29sdmVkIHRvIHRoZSBKU09OIEtleXN0b3JlIFdhbGxldCBmb3IgJSVhY2NvdW50JSUgZW5jcnlwdGVkXHJcbiAqICB3aXRoICUlcGFzc3dvcmQlJS5cclxuICpcclxuICogIFRoZSAlJW9wdGlvbnMlJSBjYW4gYmUgdXNlZCB0byB0dW5lIHRoZSBwYXNzd29yZC1iYXNlZCBrZXlcclxuICogIGRlcml2YXRpb24gZnVuY3Rpb24gcGFyYW1ldGVycywgZXhwbGljaXRseSBzZXQgdGhlIHJhbmRvbSB2YWx1ZXNcclxuICogIHVzZWQgYW5kIHByb3ZpZGUgYSBbW1Byb2dyZXNzQ2FsbGJhY2tdXSB0byByZWNlaXZlIHBlcmlvZGljIHVwZGF0ZXNcclxuICogIG9uIHRoZSBjb21wbGV0aW9uIHN0YXR1cy4uXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5jcnlwdEtleXN0b3JlSnNvbihhY2NvdW50LCBwYXNzd29yZCwgb3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xyXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgIH1cclxuICAgIGNvbnN0IHBhc3N3b3JkQnl0ZXMgPSBnZXRQYXNzd29yZChwYXNzd29yZCk7XHJcbiAgICBjb25zdCBrZGYgPSBnZXRFbmNyeXB0S2RmUGFyYW1zKG9wdGlvbnMpO1xyXG4gICAgY29uc3Qga2V5ID0gYXdhaXQgc2NyeXB0KHBhc3N3b3JkQnl0ZXMsIGtkZi5zYWx0LCBrZGYuTiwga2RmLnIsIGtkZi5wLCA2NCwgb3B0aW9ucy5wcm9ncmVzc0NhbGxiYWNrKTtcclxuICAgIHJldHVybiBfZW5jcnlwdEtleXN0b3JlKGdldEJ5dGVzKGtleSksIGtkZiwgYWNjb3VudCwgb3B0aW9ucyk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi1rZXlzdG9yZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/json-keystore.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/mnemonic.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/wallet/mnemonic.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mnemonic: () => (/* binding */ Mnemonic)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wordlists/lang-en.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/lang-en.js\");\n\r\n\r\n\r\n// Returns a byte with the MSB bits set\r\nfunction getUpperMask(bits) {\r\n    return ((1 << bits) - 1) << (8 - bits) & 0xff;\r\n}\r\n// Returns a byte with the LSB bits set\r\nfunction getLowerMask(bits) {\r\n    return ((1 << bits) - 1) & 0xff;\r\n}\r\nfunction mnemonicToEntropy(mnemonic, wordlist) {\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertNormalize)(\"NFKD\");\r\n    if (wordlist == null) {\r\n        wordlist = _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_1__.LangEn.wordlist();\r\n    }\r\n    const words = wordlist.split(mnemonic);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((words.length % 3) === 0 && words.length >= 12 && words.length <= 24, \"invalid mnemonic length\", \"mnemonic\", \"[ REDACTED ]\");\r\n    const entropy = new Uint8Array(Math.ceil(11 * words.length / 8));\r\n    let offset = 0;\r\n    for (let i = 0; i < words.length; i++) {\r\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, `invalid mnemonic word at index ${i}`, \"mnemonic\", \"[ REDACTED ]\");\r\n        for (let bit = 0; bit < 11; bit++) {\r\n            if (index & (1 << (10 - bit))) {\r\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\r\n            }\r\n            offset++;\r\n        }\r\n    }\r\n    const entropyBits = 32 * words.length / 3;\r\n    const checksumBits = words.length / 3;\r\n    const checksumMask = getUpperMask(checksumBits);\r\n    const checksum = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(checksum === (entropy[entropy.length - 1] & checksumMask), \"invalid mnemonic checksum\", \"mnemonic\", \"[ REDACTED ]\");\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(entropy.slice(0, entropyBits / 8));\r\n}\r\nfunction entropyToMnemonic(entropy, wordlist) {\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((entropy.length % 4) === 0 && entropy.length >= 16 && entropy.length <= 32, \"invalid entropy size\", \"entropy\", \"[ REDACTED ]\");\r\n    if (wordlist == null) {\r\n        wordlist = _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_1__.LangEn.wordlist();\r\n    }\r\n    const indices = [0];\r\n    let remainingBits = 11;\r\n    for (let i = 0; i < entropy.length; i++) {\r\n        // Consume the whole byte (with still more to go)\r\n        if (remainingBits > 8) {\r\n            indices[indices.length - 1] <<= 8;\r\n            indices[indices.length - 1] |= entropy[i];\r\n            remainingBits -= 8;\r\n            // This byte will complete an 11-bit index\r\n        }\r\n        else {\r\n            indices[indices.length - 1] <<= remainingBits;\r\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\r\n            // Start the next word\r\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\r\n            remainingBits += 3;\r\n        }\r\n    }\r\n    // Compute the checksum bits\r\n    const checksumBits = entropy.length / 4;\r\n    const checksum = parseInt((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.sha256)(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);\r\n    // Shift the checksum into the word indices\r\n    indices[indices.length - 1] <<= checksumBits;\r\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\r\n    return wordlist.join(indices.map((index) => wordlist.getWord(index)));\r\n}\r\nconst _guard = {};\r\n/**\r\n *  A **Mnemonic** wraps all properties required to compute [[link-bip-39]]\r\n *  seeds and convert between phrases and entropy.\r\n */\r\nclass Mnemonic {\r\n    /**\r\n     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.\r\n     *\r\n     *  Use the [[wordlist]] ``split`` method to get the individual words.\r\n     */\r\n    phrase;\r\n    /**\r\n     *  The password used for this mnemonic. If no password is used this\r\n     *  is the empty string (i.e. ``\"\"``) as per the specification.\r\n     */\r\n    password;\r\n    /**\r\n     *  The wordlist for this mnemonic.\r\n     */\r\n    wordlist;\r\n    /**\r\n     *  The underlying entropy which the mnemonic encodes.\r\n     */\r\n    entropy;\r\n    /**\r\n     *  @private\r\n     */\r\n    constructor(guard, entropy, phrase, password, wordlist) {\r\n        if (password == null) {\r\n            password = \"\";\r\n        }\r\n        if (wordlist == null) {\r\n            wordlist = _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_1__.LangEn.wordlist();\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"Mnemonic\");\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { phrase, password, wordlist, entropy });\r\n    }\r\n    /**\r\n     *  Returns the seed for the mnemonic.\r\n     */\r\n    computeSeed() {\r\n        const salt = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(\"mnemonic\" + this.password, \"NFKD\");\r\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.pbkdf2)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(this.phrase, \"NFKD\"), salt, 2048, 64, \"sha512\");\r\n    }\r\n    /**\r\n     *  Creates a new Mnemonic for the %%phrase%%.\r\n     *\r\n     *  The default %%password%% is the empty string and the default\r\n     *  wordlist is the [English wordlists](LangEn).\r\n     */\r\n    static fromPhrase(phrase, password, wordlist) {\r\n        // Normalize the case and space; throws if invalid\r\n        const entropy = mnemonicToEntropy(phrase, wordlist);\r\n        phrase = entropyToMnemonic((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(entropy), wordlist);\r\n        return new Mnemonic(_guard, entropy, phrase, password, wordlist);\r\n    }\r\n    /**\r\n     *  Create a new **Mnemonic** from the %%entropy%%.\r\n     *\r\n     *  The default %%password%% is the empty string and the default\r\n     *  wordlist is the [English wordlists](LangEn).\r\n     */\r\n    static fromEntropy(_entropy, password, wordlist) {\r\n        const entropy = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(_entropy, \"entropy\");\r\n        const phrase = entropyToMnemonic(entropy, wordlist);\r\n        return new Mnemonic(_guard, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(entropy), phrase, password, wordlist);\r\n    }\r\n    /**\r\n     *  Returns the phrase for %%mnemonic%%.\r\n     */\r\n    static entropyToPhrase(_entropy, wordlist) {\r\n        const entropy = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(_entropy, \"entropy\");\r\n        return entropyToMnemonic(entropy, wordlist);\r\n    }\r\n    /**\r\n     *  Returns the entropy for %%phrase%%.\r\n     */\r\n    static phraseToEntropy(phrase, wordlist) {\r\n        return mnemonicToEntropy(phrase, wordlist);\r\n    }\r\n    /**\r\n     *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.\r\n     *\r\n     *  This checks all the provided words belong to the %%wordlist%%,\r\n     *  that the length is valid and the checksum is correct.\r\n     */\r\n    static isValidMnemonic(phrase, wordlist) {\r\n        try {\r\n            mnemonicToEntropy(phrase, wordlist);\r\n            return true;\r\n        }\r\n        catch (error) { }\r\n        return false;\r\n    }\r\n}\r\n//# sourceMappingURL=mnemonic.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvbW5lbW9uaWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvRDtBQUNpRjtBQUNwRjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdFQUFlO0FBQ25CO0FBQ0EsbUJBQW1CLHlEQUFNO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EsUUFBUSwrREFBYywrQ0FBK0MsRUFBRTtBQUN2RSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseURBQVEsQ0FBQyx3REFBTTtBQUNwQyxJQUFJLCtEQUFjO0FBQ2xCLFdBQVcsd0RBQU87QUFDbEI7QUFDQTtBQUNBLElBQUksK0RBQWM7QUFDbEI7QUFDQSxtQkFBbUIseURBQU07QUFDekI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdEQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseURBQU07QUFDN0I7QUFDQSxRQUFRLDhEQUFhO0FBQ3JCLFFBQVEsaUVBQWdCLFNBQVMscUNBQXFDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNERBQVc7QUFDaEMsZUFBZSx3REFBTSxDQUFDLDREQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxtQ0FBbUMseURBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlEQUFRO0FBQ2hDO0FBQ0Esb0NBQW9DLHdEQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseURBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHdhbGxldFxcbW5lbW9uaWMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGJrZGYyLCBzaGEyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJ5dGVzLCBoZXhsaWZ5LCBhc3NlcnROb3JtYWxpemUsIGFzc2VydFByaXZhdGUsIGFzc2VydEFyZ3VtZW50LCB0b1V0ZjhCeXRlcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBMYW5nRW4gfSBmcm9tIFwiLi4vd29yZGxpc3RzL2xhbmctZW4uanNcIjtcclxuLy8gUmV0dXJucyBhIGJ5dGUgd2l0aCB0aGUgTVNCIGJpdHMgc2V0XHJcbmZ1bmN0aW9uIGdldFVwcGVyTWFzayhiaXRzKSB7XHJcbiAgICByZXR1cm4gKCgxIDw8IGJpdHMpIC0gMSkgPDwgKDggLSBiaXRzKSAmIDB4ZmY7XHJcbn1cclxuLy8gUmV0dXJucyBhIGJ5dGUgd2l0aCB0aGUgTFNCIGJpdHMgc2V0XHJcbmZ1bmN0aW9uIGdldExvd2VyTWFzayhiaXRzKSB7XHJcbiAgICByZXR1cm4gKCgxIDw8IGJpdHMpIC0gMSkgJiAweGZmO1xyXG59XHJcbmZ1bmN0aW9uIG1uZW1vbmljVG9FbnRyb3B5KG1uZW1vbmljLCB3b3JkbGlzdCkge1xyXG4gICAgYXNzZXJ0Tm9ybWFsaXplKFwiTkZLRFwiKTtcclxuICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XHJcbiAgICAgICAgd29yZGxpc3QgPSBMYW5nRW4ud29yZGxpc3QoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHdvcmRzID0gd29yZGxpc3Quc3BsaXQobW5lbW9uaWMpO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQoKHdvcmRzLmxlbmd0aCAlIDMpID09PSAwICYmIHdvcmRzLmxlbmd0aCA+PSAxMiAmJiB3b3Jkcy5sZW5ndGggPD0gMjQsIFwiaW52YWxpZCBtbmVtb25pYyBsZW5ndGhcIiwgXCJtbmVtb25pY1wiLCBcIlsgUkVEQUNURUQgXVwiKTtcclxuICAgIGNvbnN0IGVudHJvcHkgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwoMTEgKiB3b3Jkcy5sZW5ndGggLyA4KSk7XHJcbiAgICBsZXQgb2Zmc2V0ID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgaW5kZXggPSB3b3JkbGlzdC5nZXRXb3JkSW5kZXgod29yZHNbaV0ubm9ybWFsaXplKFwiTkZLRFwiKSk7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPj0gMCwgYGludmFsaWQgbW5lbW9uaWMgd29yZCBhdCBpbmRleCAke2l9YCwgXCJtbmVtb25pY1wiLCBcIlsgUkVEQUNURUQgXVwiKTtcclxuICAgICAgICBmb3IgKGxldCBiaXQgPSAwOyBiaXQgPCAxMTsgYml0KyspIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ICYgKDEgPDwgKDEwIC0gYml0KSkpIHtcclxuICAgICAgICAgICAgICAgIGVudHJvcHlbb2Zmc2V0ID4+IDNdIHw9ICgxIDw8ICg3IC0gKG9mZnNldCAlIDgpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2Zmc2V0Kys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgZW50cm9weUJpdHMgPSAzMiAqIHdvcmRzLmxlbmd0aCAvIDM7XHJcbiAgICBjb25zdCBjaGVja3N1bUJpdHMgPSB3b3Jkcy5sZW5ndGggLyAzO1xyXG4gICAgY29uc3QgY2hlY2tzdW1NYXNrID0gZ2V0VXBwZXJNYXNrKGNoZWNrc3VtQml0cyk7XHJcbiAgICBjb25zdCBjaGVja3N1bSA9IGdldEJ5dGVzKHNoYTI1NihlbnRyb3B5LnNsaWNlKDAsIGVudHJvcHlCaXRzIC8gOCkpKVswXSAmIGNoZWNrc3VtTWFzaztcclxuICAgIGFzc2VydEFyZ3VtZW50KGNoZWNrc3VtID09PSAoZW50cm9weVtlbnRyb3B5Lmxlbmd0aCAtIDFdICYgY2hlY2tzdW1NYXNrKSwgXCJpbnZhbGlkIG1uZW1vbmljIGNoZWNrc3VtXCIsIFwibW5lbW9uaWNcIiwgXCJbIFJFREFDVEVEIF1cIik7XHJcbiAgICByZXR1cm4gaGV4bGlmeShlbnRyb3B5LnNsaWNlKDAsIGVudHJvcHlCaXRzIC8gOCkpO1xyXG59XHJcbmZ1bmN0aW9uIGVudHJvcHlUb01uZW1vbmljKGVudHJvcHksIHdvcmRsaXN0KSB7XHJcbiAgICBhc3NlcnRBcmd1bWVudCgoZW50cm9weS5sZW5ndGggJSA0KSA9PT0gMCAmJiBlbnRyb3B5Lmxlbmd0aCA+PSAxNiAmJiBlbnRyb3B5Lmxlbmd0aCA8PSAzMiwgXCJpbnZhbGlkIGVudHJvcHkgc2l6ZVwiLCBcImVudHJvcHlcIiwgXCJbIFJFREFDVEVEIF1cIik7XHJcbiAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xyXG4gICAgICAgIHdvcmRsaXN0ID0gTGFuZ0VuLndvcmRsaXN0KCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbmRpY2VzID0gWzBdO1xyXG4gICAgbGV0IHJlbWFpbmluZ0JpdHMgPSAxMTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cm9weS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIC8vIENvbnN1bWUgdGhlIHdob2xlIGJ5dGUgKHdpdGggc3RpbGwgbW9yZSB0byBnbylcclxuICAgICAgICBpZiAocmVtYWluaW5nQml0cyA+IDgpIHtcclxuICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIDw8PSA4O1xyXG4gICAgICAgICAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gfD0gZW50cm9weVtpXTtcclxuICAgICAgICAgICAgcmVtYWluaW5nQml0cyAtPSA4O1xyXG4gICAgICAgICAgICAvLyBUaGlzIGJ5dGUgd2lsbCBjb21wbGV0ZSBhbiAxMS1iaXQgaW5kZXhcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSA8PD0gcmVtYWluaW5nQml0cztcclxuICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIHw9IGVudHJvcHlbaV0gPj4gKDggLSByZW1haW5pbmdCaXRzKTtcclxuICAgICAgICAgICAgLy8gU3RhcnQgdGhlIG5leHQgd29yZFxyXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goZW50cm9weVtpXSAmIGdldExvd2VyTWFzayg4IC0gcmVtYWluaW5nQml0cykpO1xyXG4gICAgICAgICAgICByZW1haW5pbmdCaXRzICs9IDM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQ29tcHV0ZSB0aGUgY2hlY2tzdW0gYml0c1xyXG4gICAgY29uc3QgY2hlY2tzdW1CaXRzID0gZW50cm9weS5sZW5ndGggLyA0O1xyXG4gICAgY29uc3QgY2hlY2tzdW0gPSBwYXJzZUludChzaGEyNTYoZW50cm9weSkuc3Vic3RyaW5nKDIsIDQpLCAxNikgJiBnZXRVcHBlck1hc2soY2hlY2tzdW1CaXRzKTtcclxuICAgIC8vIFNoaWZ0IHRoZSBjaGVja3N1bSBpbnRvIHRoZSB3b3JkIGluZGljZXNcclxuICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSA8PD0gY2hlY2tzdW1CaXRzO1xyXG4gICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIHw9IChjaGVja3N1bSA+PiAoOCAtIGNoZWNrc3VtQml0cykpO1xyXG4gICAgcmV0dXJuIHdvcmRsaXN0LmpvaW4oaW5kaWNlcy5tYXAoKGluZGV4KSA9PiB3b3JkbGlzdC5nZXRXb3JkKGluZGV4KSkpO1xyXG59XHJcbmNvbnN0IF9ndWFyZCA9IHt9O1xyXG4vKipcclxuICogIEEgKipNbmVtb25pYyoqIHdyYXBzIGFsbCBwcm9wZXJ0aWVzIHJlcXVpcmVkIHRvIGNvbXB1dGUgW1tsaW5rLWJpcC0zOV1dXHJcbiAqICBzZWVkcyBhbmQgY29udmVydCBiZXR3ZWVuIHBocmFzZXMgYW5kIGVudHJvcHkuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTW5lbW9uaWMge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG1uZW1vbmljIHBocmFzZSBvZiAxMiwgMTUsIDE4LCAyMSBvciAyNCB3b3Jkcy5cclxuICAgICAqXHJcbiAgICAgKiAgVXNlIHRoZSBbW3dvcmRsaXN0XV0gYGBzcGxpdGBgIG1ldGhvZCB0byBnZXQgdGhlIGluZGl2aWR1YWwgd29yZHMuXHJcbiAgICAgKi9cclxuICAgIHBocmFzZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBwYXNzd29yZCB1c2VkIGZvciB0aGlzIG1uZW1vbmljLiBJZiBubyBwYXNzd29yZCBpcyB1c2VkIHRoaXNcclxuICAgICAqICBpcyB0aGUgZW1wdHkgc3RyaW5nIChpLmUuIGBgXCJcImBgKSBhcyBwZXIgdGhlIHNwZWNpZmljYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHBhc3N3b3JkO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHdvcmRsaXN0IGZvciB0aGlzIG1uZW1vbmljLlxyXG4gICAgICovXHJcbiAgICB3b3JkbGlzdDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSB1bmRlcmx5aW5nIGVudHJvcHkgd2hpY2ggdGhlIG1uZW1vbmljIGVuY29kZXMuXHJcbiAgICAgKi9cclxuICAgIGVudHJvcHk7XHJcbiAgICAvKipcclxuICAgICAqICBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgZW50cm9weSwgcGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpIHtcclxuICAgICAgICBpZiAocGFzc3dvcmQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwYXNzd29yZCA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gTGFuZ0VuLndvcmRsaXN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJNbmVtb25pY1wiKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QsIGVudHJvcHkgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRoZSBzZWVkIGZvciB0aGUgbW5lbW9uaWMuXHJcbiAgICAgKi9cclxuICAgIGNvbXB1dGVTZWVkKCkge1xyXG4gICAgICAgIGNvbnN0IHNhbHQgPSB0b1V0ZjhCeXRlcyhcIm1uZW1vbmljXCIgKyB0aGlzLnBhc3N3b3JkLCBcIk5GS0RcIik7XHJcbiAgICAgICAgcmV0dXJuIHBia2RmMih0b1V0ZjhCeXRlcyh0aGlzLnBocmFzZSwgXCJORktEXCIpLCBzYWx0LCAyMDQ4LCA2NCwgXCJzaGE1MTJcIik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgbmV3IE1uZW1vbmljIGZvciB0aGUgJSVwaHJhc2UlJS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhlIGRlZmF1bHQgJSVwYXNzd29yZCUlIGlzIHRoZSBlbXB0eSBzdHJpbmcgYW5kIHRoZSBkZWZhdWx0XHJcbiAgICAgKiAgd29yZGxpc3QgaXMgdGhlIFtFbmdsaXNoIHdvcmRsaXN0c10oTGFuZ0VuKS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21QaHJhc2UocGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpIHtcclxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGNhc2UgYW5kIHNwYWNlOyB0aHJvd3MgaWYgaW52YWxpZFxyXG4gICAgICAgIGNvbnN0IGVudHJvcHkgPSBtbmVtb25pY1RvRW50cm9weShwaHJhc2UsIHdvcmRsaXN0KTtcclxuICAgICAgICBwaHJhc2UgPSBlbnRyb3B5VG9NbmVtb25pYyhnZXRCeXRlcyhlbnRyb3B5KSwgd29yZGxpc3QpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTW5lbW9uaWMoX2d1YXJkLCBlbnRyb3B5LCBwaHJhc2UsIHBhc3N3b3JkLCB3b3JkbGlzdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGUgYSBuZXcgKipNbmVtb25pYyoqIGZyb20gdGhlICUlZW50cm9weSUlLlxyXG4gICAgICpcclxuICAgICAqICBUaGUgZGVmYXVsdCAlJXBhc3N3b3JkJSUgaXMgdGhlIGVtcHR5IHN0cmluZyBhbmQgdGhlIGRlZmF1bHRcclxuICAgICAqICB3b3JkbGlzdCBpcyB0aGUgW0VuZ2xpc2ggd29yZGxpc3RzXShMYW5nRW4pLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUVudHJvcHkoX2VudHJvcHksIHBhc3N3b3JkLCB3b3JkbGlzdCkge1xyXG4gICAgICAgIGNvbnN0IGVudHJvcHkgPSBnZXRCeXRlcyhfZW50cm9weSwgXCJlbnRyb3B5XCIpO1xyXG4gICAgICAgIGNvbnN0IHBocmFzZSA9IGVudHJvcHlUb01uZW1vbmljKGVudHJvcHksIHdvcmRsaXN0KTtcclxuICAgICAgICByZXR1cm4gbmV3IE1uZW1vbmljKF9ndWFyZCwgaGV4bGlmeShlbnRyb3B5KSwgcGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgcGhyYXNlIGZvciAlJW1uZW1vbmljJSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBlbnRyb3B5VG9QaHJhc2UoX2VudHJvcHksIHdvcmRsaXN0KSB7XHJcbiAgICAgICAgY29uc3QgZW50cm9weSA9IGdldEJ5dGVzKF9lbnRyb3B5LCBcImVudHJvcHlcIik7XHJcbiAgICAgICAgcmV0dXJuIGVudHJvcHlUb01uZW1vbmljKGVudHJvcHksIHdvcmRsaXN0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIGVudHJvcHkgZm9yICUlcGhyYXNlJSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBwaHJhc2VUb0VudHJvcHkocGhyYXNlLCB3b3JkbGlzdCkge1xyXG4gICAgICAgIHJldHVybiBtbmVtb25pY1RvRW50cm9weShwaHJhc2UsIHdvcmRsaXN0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXBocmFzZSUlIGlzIGEgdmFsaWQgW1tsaW5rLWJpcC0zOV1dIHBocmFzZS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBjaGVja3MgYWxsIHRoZSBwcm92aWRlZCB3b3JkcyBiZWxvbmcgdG8gdGhlICUld29yZGxpc3QlJSxcclxuICAgICAqICB0aGF0IHRoZSBsZW5ndGggaXMgdmFsaWQgYW5kIHRoZSBjaGVja3N1bSBpcyBjb3JyZWN0LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNWYWxpZE1uZW1vbmljKHBocmFzZSwgd29yZGxpc3QpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBtbmVtb25pY1RvRW50cm9weShwaHJhc2UsIHdvcmRsaXN0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1uZW1vbmljLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/mnemonic.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/wallet/utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPassword: () => (/* binding */ getPassword),\n/* harmony export */   looseArrayify: () => (/* binding */ looseArrayify),\n/* harmony export */   spelunk: () => (/* binding */ spelunk),\n/* harmony export */   zpad: () => (/* binding */ zpad)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/**\r\n *  @_ignore\r\n */\r\n\r\nfunction looseArrayify(hexString) {\r\n    if (typeof (hexString) === \"string\" && !hexString.startsWith(\"0x\")) {\r\n        hexString = \"0x\" + hexString;\r\n    }\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(hexString);\r\n}\r\nfunction zpad(value, length) {\r\n    value = String(value);\r\n    while (value.length < length) {\r\n        value = '0' + value;\r\n    }\r\n    return value;\r\n}\r\nfunction getPassword(password) {\r\n    if (typeof (password) === 'string') {\r\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(password, \"NFKC\");\r\n    }\r\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(password);\r\n}\r\nfunction spelunk(object, _path) {\r\n    const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match != null, \"invalid path\", \"path\", _path);\r\n    const path = match[1];\r\n    const type = match[3];\r\n    const reqd = (match[4] === \"!\");\r\n    let cur = object;\r\n    for (const comp of path.toLowerCase().split('.')) {\r\n        // Search for a child object with a case-insensitive matching key\r\n        if (Array.isArray(cur)) {\r\n            if (!comp.match(/^[0-9]+$/)) {\r\n                break;\r\n            }\r\n            cur = cur[parseInt(comp)];\r\n        }\r\n        else if (typeof (cur) === \"object\") {\r\n            let found = null;\r\n            for (const key in cur) {\r\n                if (key.toLowerCase() === comp) {\r\n                    found = cur[key];\r\n                    break;\r\n                }\r\n            }\r\n            cur = found;\r\n        }\r\n        else {\r\n            cur = null;\r\n        }\r\n        if (cur == null) {\r\n            break;\r\n        }\r\n    }\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(!reqd || cur != null, \"missing required value\", \"path\", path);\r\n    if (type && cur != null) {\r\n        if (type === \"int\") {\r\n            if (typeof (cur) === \"string\" && cur.match(/^-?[0-9]+$/)) {\r\n                return parseInt(cur);\r\n            }\r\n            else if (Number.isSafeInteger(cur)) {\r\n                return cur;\r\n            }\r\n        }\r\n        if (type === \"number\") {\r\n            if (typeof (cur) === \"string\" && cur.match(/^-?[0-9.]*$/)) {\r\n                return parseFloat(cur);\r\n            }\r\n        }\r\n        if (type === \"data\") {\r\n            if (typeof (cur) === \"string\") {\r\n                return looseArrayify(cur);\r\n            }\r\n        }\r\n        if (type === \"array\" && Array.isArray(cur)) {\r\n            return cur;\r\n        }\r\n        if (type === typeof (cur)) {\r\n            return cur;\r\n        }\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `wrong type found for ${type} `, \"path\", path);\r\n    }\r\n    return cur;\r\n}\r\n/*\r\nexport function follow(object: any, path: string): null | string {\r\n    let currentChild = object;\r\n\r\n    for (const comp of path.toLowerCase().split('/')) {\r\n\r\n        // Search for a child object with a case-insensitive matching key\r\n        let matchingChild = null;\r\n        for (const key in currentChild) {\r\n             if (key.toLowerCase() === comp) {\r\n                 matchingChild = currentChild[key];\r\n                 break;\r\n             }\r\n        }\r\n\r\n        if (matchingChild === null) { return null; }\r\n\r\n        currentChild = matchingChild;\r\n    }\r\n\r\n    return currentChild;\r\n}\r\n\r\n// \"path/to/something:type!\"\r\nexport function followRequired(data: any, path: string): string {\r\n    const value = follow(data, path);\r\n    if (value != null) { return value; }\r\n    return logger.throwArgumentError(\"invalid value\", `data:${ path }`,\r\n    JSON.stringify(data));\r\n}\r\n*/\r\n// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\r\n/*\r\nexport function uuidV4(randomBytes: BytesLike): string {\r\n    const bytes = getBytes(randomBytes, \"randomBytes\");\r\n\r\n    // Section: 4.1.3:\r\n    // - time_hi_and_version[12:16] = 0b0100\r\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\r\n\r\n    // Section 4.4\r\n    // - clock_seq_hi_and_reserved[6] = 0b0\r\n    // - clock_seq_hi_and_reserved[7] = 0b1\r\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\r\n\r\n    const value = hexlify(bytes);\r\n\r\n    return [\r\n       value.substring(2, 10),\r\n       value.substring(10, 14),\r\n       value.substring(14, 18),\r\n       value.substring(18, 22),\r\n       value.substring(22, 34),\r\n    ].join(\"-\");\r\n}\r\n*/\r\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDOEU7QUFDdkU7QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZEQUFZO0FBQ3ZCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZUFBZSw0REFBVztBQUMxQjtBQUNBLFdBQVcsNkRBQVk7QUFDdkI7QUFDTztBQUNQO0FBQ0EsSUFBSSwrREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWMsZ0NBQWdDLE1BQU07QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLCtEQUErRCxNQUFNO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcd2FsbGV0XFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIEBfaWdub3JlXHJcbiAqL1xyXG5pbXBvcnQgeyBnZXRCeXRlc0NvcHksIGFzc2VydEFyZ3VtZW50LCB0b1V0ZjhCeXRlcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5leHBvcnQgZnVuY3Rpb24gbG9vc2VBcnJheWlmeShoZXhTdHJpbmcpIHtcclxuICAgIGlmICh0eXBlb2YgKGhleFN0cmluZykgPT09IFwic3RyaW5nXCIgJiYgIWhleFN0cmluZy5zdGFydHNXaXRoKFwiMHhcIikpIHtcclxuICAgICAgICBoZXhTdHJpbmcgPSBcIjB4XCIgKyBoZXhTdHJpbmc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0Qnl0ZXNDb3B5KGhleFN0cmluZyk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHpwYWQodmFsdWUsIGxlbmd0aCkge1xyXG4gICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xyXG4gICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA8IGxlbmd0aCkge1xyXG4gICAgICAgIHZhbHVlID0gJzAnICsgdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhc3N3b3JkKHBhc3N3b3JkKSB7XHJcbiAgICBpZiAodHlwZW9mIChwYXNzd29yZCkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHRvVXRmOEJ5dGVzKHBhc3N3b3JkLCBcIk5GS0NcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0Qnl0ZXNDb3B5KHBhc3N3b3JkKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gc3BlbHVuayhvYmplY3QsIF9wYXRoKSB7XHJcbiAgICBjb25zdCBtYXRjaCA9IF9wYXRoLm1hdGNoKC9eKFthLXowLTkkXy4tXSopKDooW2Etel0rKSk/KCEpPyQvaSk7XHJcbiAgICBhc3NlcnRBcmd1bWVudChtYXRjaCAhPSBudWxsLCBcImludmFsaWQgcGF0aFwiLCBcInBhdGhcIiwgX3BhdGgpO1xyXG4gICAgY29uc3QgcGF0aCA9IG1hdGNoWzFdO1xyXG4gICAgY29uc3QgdHlwZSA9IG1hdGNoWzNdO1xyXG4gICAgY29uc3QgcmVxZCA9IChtYXRjaFs0XSA9PT0gXCIhXCIpO1xyXG4gICAgbGV0IGN1ciA9IG9iamVjdDtcclxuICAgIGZvciAoY29uc3QgY29tcCBvZiBwYXRoLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy4nKSkge1xyXG4gICAgICAgIC8vIFNlYXJjaCBmb3IgYSBjaGlsZCBvYmplY3Qgd2l0aCBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2hpbmcga2V5XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VyKSkge1xyXG4gICAgICAgICAgICBpZiAoIWNvbXAubWF0Y2goL15bMC05XSskLykpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1ciA9IGN1cltwYXJzZUludChjb21wKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoY3VyKSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICBsZXQgZm91bmQgPSBudWxsO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gY29tcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gY3VyW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VyID0gZm91bmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY3VyID09IG51bGwpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXNzZXJ0QXJndW1lbnQoIXJlcWQgfHwgY3VyICE9IG51bGwsIFwibWlzc2luZyByZXF1aXJlZCB2YWx1ZVwiLCBcInBhdGhcIiwgcGF0aCk7XHJcbiAgICBpZiAodHlwZSAmJiBjdXIgIT0gbnVsbCkge1xyXG4gICAgICAgIGlmICh0eXBlID09PSBcImludFwiKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGN1cikgPT09IFwic3RyaW5nXCIgJiYgY3VyLm1hdGNoKC9eLT9bMC05XSskLykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChjdXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKGN1cikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoY3VyKSA9PT0gXCJzdHJpbmdcIiAmJiBjdXIubWF0Y2goL14tP1swLTkuXSokLykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGN1cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZGF0YVwiKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGN1cikgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsb29zZUFycmF5aWZ5KGN1cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiYXJyYXlcIiAmJiBBcnJheS5pc0FycmF5KGN1cikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IHR5cGVvZiAoY3VyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYHdyb25nIHR5cGUgZm91bmQgZm9yICR7dHlwZX0gYCwgXCJwYXRoXCIsIHBhdGgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGN1cjtcclxufVxyXG4vKlxyXG5leHBvcnQgZnVuY3Rpb24gZm9sbG93KG9iamVjdDogYW55LCBwYXRoOiBzdHJpbmcpOiBudWxsIHwgc3RyaW5nIHtcclxuICAgIGxldCBjdXJyZW50Q2hpbGQgPSBvYmplY3Q7XHJcblxyXG4gICAgZm9yIChjb25zdCBjb21wIG9mIHBhdGgudG9Mb3dlckNhc2UoKS5zcGxpdCgnLycpKSB7XHJcblxyXG4gICAgICAgIC8vIFNlYXJjaCBmb3IgYSBjaGlsZCBvYmplY3Qgd2l0aCBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2hpbmcga2V5XHJcbiAgICAgICAgbGV0IG1hdGNoaW5nQ2hpbGQgPSBudWxsO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN1cnJlbnRDaGlsZCkge1xyXG4gICAgICAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSBjb21wKSB7XHJcbiAgICAgICAgICAgICAgICAgbWF0Y2hpbmdDaGlsZCA9IGN1cnJlbnRDaGlsZFtrZXldO1xyXG4gICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1hdGNoaW5nQ2hpbGQgPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cclxuXHJcbiAgICAgICAgY3VycmVudENoaWxkID0gbWF0Y2hpbmdDaGlsZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY3VycmVudENoaWxkO1xyXG59XHJcblxyXG4vLyBcInBhdGgvdG8vc29tZXRoaW5nOnR5cGUhXCJcclxuZXhwb3J0IGZ1bmN0aW9uIGZvbGxvd1JlcXVpcmVkKGRhdGE6IGFueSwgcGF0aDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IHZhbHVlID0gZm9sbG93KGRhdGEsIHBhdGgpO1xyXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHsgcmV0dXJuIHZhbHVlOyB9XHJcbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdmFsdWVcIiwgYGRhdGE6JHsgcGF0aCB9YCxcclxuICAgIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcclxufVxyXG4qL1xyXG4vLyBTZWU6IGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmM0MTIyLnR4dCAoU2VjdGlvbiA0LjQpXHJcbi8qXHJcbmV4cG9ydCBmdW5jdGlvbiB1dWlkVjQocmFuZG9tQnl0ZXM6IEJ5dGVzTGlrZSk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHJhbmRvbUJ5dGVzLCBcInJhbmRvbUJ5dGVzXCIpO1xyXG5cclxuICAgIC8vIFNlY3Rpb246IDQuMS4zOlxyXG4gICAgLy8gLSB0aW1lX2hpX2FuZF92ZXJzaW9uWzEyOjE2XSA9IDBiMDEwMFxyXG4gICAgYnl0ZXNbNl0gPSAoYnl0ZXNbNl0gJiAweDBmKSB8IDB4NDA7XHJcblxyXG4gICAgLy8gU2VjdGlvbiA0LjRcclxuICAgIC8vIC0gY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZFs2XSA9IDBiMFxyXG4gICAgLy8gLSBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkWzddID0gMGIxXHJcbiAgICBieXRlc1s4XSA9IChieXRlc1s4XSAmIDB4M2YpIHwgMHg4MDtcclxuXHJcbiAgICBjb25zdCB2YWx1ZSA9IGhleGxpZnkoYnl0ZXMpO1xyXG5cclxuICAgIHJldHVybiBbXHJcbiAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMiwgMTApLFxyXG4gICAgICAgdmFsdWUuc3Vic3RyaW5nKDEwLCAxNCksXHJcbiAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTQsIDE4KSxcclxuICAgICAgIHZhbHVlLnN1YnN0cmluZygxOCwgMjIpLFxyXG4gICAgICAgdmFsdWUuc3Vic3RyaW5nKDIyLCAzNCksXHJcbiAgICBdLmpvaW4oXCItXCIpO1xyXG59XHJcbiovXHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/utils.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/wallet.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/wallet/wallet.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Wallet: () => (/* binding */ Wallet)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _base_wallet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base-wallet.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/base-wallet.js\");\n/* harmony import */ var _hdwallet_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hdwallet.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/hdwallet.js\");\n/* harmony import */ var _json_crowdsale_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./json-crowdsale.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/json-crowdsale.js\");\n/* harmony import */ var _json_keystore_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./json-keystore.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/json-keystore.js\");\n/* harmony import */ var _mnemonic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mnemonic.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/mnemonic.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction stall(duration) {\r\n    return new Promise((resolve) => { setTimeout(() => { resolve(); }, duration); });\r\n}\r\n/**\r\n *  A **Wallet** manages a single private key which is used to sign\r\n *  transactions, messages and other common payloads.\r\n *\r\n *  This class is generally the main entry point for developers\r\n *  that wish to use a private key directly, as it can create\r\n *  instances from a large variety of common sources, including\r\n *  raw private key, [[link-bip-39]] mnemonics and encrypte JSON\r\n *  wallets.\r\n */\r\nclass Wallet extends _base_wallet_js__WEBPACK_IMPORTED_MODULE_0__.BaseWallet {\r\n    /**\r\n     *  Create a new wallet for the private %%key%%, optionally connected\r\n     *  to %%provider%%.\r\n     */\r\n    constructor(key, provider) {\r\n        if (typeof (key) === \"string\" && !key.startsWith(\"0x\")) {\r\n            key = \"0x\" + key;\r\n        }\r\n        let signingKey = (typeof (key) === \"string\") ? new _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.SigningKey(key) : key;\r\n        super(signingKey, provider);\r\n    }\r\n    connect(provider) {\r\n        return new Wallet(this.signingKey, provider);\r\n    }\r\n    /**\r\n     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with\r\n     *  %%password%%.\r\n     *\r\n     *  If %%progressCallback%% is specified, it will receive periodic\r\n     *  updates as the encryption process progreses.\r\n     */\r\n    async encrypt(password, progressCallback) {\r\n        const account = { address: this.address, privateKey: this.privateKey };\r\n        return await (0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_2__.encryptKeystoreJson)(account, password, { progressCallback });\r\n    }\r\n    /**\r\n     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with\r\n     *  %%password%%.\r\n     *\r\n     *  It is preferred to use the [async version](encrypt) instead,\r\n     *  which allows a [[ProgressCallback]] to keep the user informed.\r\n     *\r\n     *  This method will block the event loop (freezing all UI) until\r\n     *  it is complete, which may be a non-trivial duration.\r\n     */\r\n    encryptSync(password) {\r\n        const account = { address: this.address, privateKey: this.privateKey };\r\n        return (0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_2__.encryptKeystoreJsonSync)(account, password);\r\n    }\r\n    static #fromAccount(account) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(account, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\");\r\n        if (\"mnemonic\" in account && account.mnemonic && account.mnemonic.locale === \"en\") {\r\n            const mnemonic = _mnemonic_js__WEBPACK_IMPORTED_MODULE_4__.Mnemonic.fromEntropy(account.mnemonic.entropy);\r\n            const wallet = _hdwallet_js__WEBPACK_IMPORTED_MODULE_5__.HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);\r\n            if (wallet.address === account.address && wallet.privateKey === account.privateKey) {\r\n                return wallet;\r\n            }\r\n            console.log(\"WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key\");\r\n        }\r\n        const wallet = new Wallet(account.privateKey);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(wallet.address === account.address, \"address/privateKey mismatch\", \"json\", \"[ REDACTED ]\");\r\n        return wallet;\r\n    }\r\n    /**\r\n     *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%\r\n     *  with %%password%%.\r\n     *\r\n     *  If %%progress%% is provided, it is called periodically during\r\n     *  decryption so that any UI can be updated.\r\n     */\r\n    static async fromEncryptedJson(json, password, progress) {\r\n        let account = null;\r\n        if ((0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_2__.isKeystoreJson)(json)) {\r\n            account = await (0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_2__.decryptKeystoreJson)(json, password, progress);\r\n        }\r\n        else if ((0,_json_crowdsale_js__WEBPACK_IMPORTED_MODULE_6__.isCrowdsaleJson)(json)) {\r\n            if (progress) {\r\n                progress(0);\r\n                await stall(0);\r\n            }\r\n            account = (0,_json_crowdsale_js__WEBPACK_IMPORTED_MODULE_6__.decryptCrowdsaleJson)(json, password);\r\n            if (progress) {\r\n                progress(1);\r\n                await stall(0);\r\n            }\r\n        }\r\n        return Wallet.#fromAccount(account);\r\n    }\r\n    /**\r\n     *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.\r\n     *\r\n     *  The [[fromEncryptedJson]] method is preferred, as this method\r\n     *  will lock up and freeze the UI during decryption, which may take\r\n     *  some time.\r\n     */\r\n    static fromEncryptedJsonSync(json, password) {\r\n        let account = null;\r\n        if ((0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_2__.isKeystoreJson)(json)) {\r\n            account = (0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_2__.decryptKeystoreJsonSync)(json, password);\r\n        }\r\n        else if ((0,_json_crowdsale_js__WEBPACK_IMPORTED_MODULE_6__.isCrowdsaleJson)(json)) {\r\n            account = (0,_json_crowdsale_js__WEBPACK_IMPORTED_MODULE_6__.decryptCrowdsaleJson)(json, password);\r\n        }\r\n        else {\r\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\");\r\n        }\r\n        return Wallet.#fromAccount(account);\r\n    }\r\n    /**\r\n     *  Creates a new random [[HDNodeWallet]] using the available\r\n     *  [cryptographic random source](randomBytes).\r\n     *\r\n     *  If there is no crytographic random source, this will throw.\r\n     */\r\n    static createRandom(provider) {\r\n        const wallet = _hdwallet_js__WEBPACK_IMPORTED_MODULE_5__.HDNodeWallet.createRandom();\r\n        if (provider) {\r\n            return wallet.connect(provider);\r\n        }\r\n        return wallet;\r\n    }\r\n    /**\r\n     *  Creates a [[HDNodeWallet]] for %%phrase%%.\r\n     */\r\n    static fromPhrase(phrase, provider) {\r\n        const wallet = _hdwallet_js__WEBPACK_IMPORTED_MODULE_5__.HDNodeWallet.fromPhrase(phrase);\r\n        if (provider) {\r\n            return wallet.connect(provider);\r\n        }\r\n        return wallet;\r\n    }\r\n}\r\n//# sourceMappingURL=wallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvd2FsbGV0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ0c7QUFDTDtBQUNEO0FBQytCO0FBQ29FO0FBQ3ZHO0FBQ3pDO0FBQ0Esc0NBQXNDLG1CQUFtQixZQUFZLGNBQWM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQix1REFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHdEQUFVO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHFCQUFxQixzRUFBbUIsc0JBQXNCLGtCQUFrQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsZUFBZSwwRUFBdUI7QUFDdEM7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQSw2QkFBNkIsa0RBQVE7QUFDckMsMkJBQTJCLHNEQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0EsUUFBUSwrREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpRUFBYztBQUMxQiw0QkFBNEIsc0VBQW1CO0FBQy9DO0FBQ0EsaUJBQWlCLG1FQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdFQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUVBQWM7QUFDMUIsc0JBQXNCLDBFQUF1QjtBQUM3QztBQUNBLGlCQUFpQixtRUFBZTtBQUNoQyxzQkFBc0Isd0VBQW9CO0FBQzFDO0FBQ0E7QUFDQSxZQUFZLCtEQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFx3YWxsZXRcXHdhbGxldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTaWduaW5nS2V5IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBCYXNlV2FsbGV0IH0gZnJvbSBcIi4vYmFzZS13YWxsZXQuanNcIjtcclxuaW1wb3J0IHsgSEROb2RlV2FsbGV0IH0gZnJvbSBcIi4vaGR3YWxsZXQuanNcIjtcclxuaW1wb3J0IHsgZGVjcnlwdENyb3dkc2FsZUpzb24sIGlzQ3Jvd2RzYWxlSnNvbiB9IGZyb20gXCIuL2pzb24tY3Jvd2RzYWxlLmpzXCI7XHJcbmltcG9ydCB7IGRlY3J5cHRLZXlzdG9yZUpzb24sIGRlY3J5cHRLZXlzdG9yZUpzb25TeW5jLCBlbmNyeXB0S2V5c3RvcmVKc29uLCBlbmNyeXB0S2V5c3RvcmVKc29uU3luYywgaXNLZXlzdG9yZUpzb24gfSBmcm9tIFwiLi9qc29uLWtleXN0b3JlLmpzXCI7XHJcbmltcG9ydCB7IE1uZW1vbmljIH0gZnJvbSBcIi4vbW5lbW9uaWMuanNcIjtcclxuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4geyBzZXRUaW1lb3V0KCgpID0+IHsgcmVzb2x2ZSgpOyB9LCBkdXJhdGlvbik7IH0pO1xyXG59XHJcbi8qKlxyXG4gKiAgQSAqKldhbGxldCoqIG1hbmFnZXMgYSBzaW5nbGUgcHJpdmF0ZSBrZXkgd2hpY2ggaXMgdXNlZCB0byBzaWduXHJcbiAqICB0cmFuc2FjdGlvbnMsIG1lc3NhZ2VzIGFuZCBvdGhlciBjb21tb24gcGF5bG9hZHMuXHJcbiAqXHJcbiAqICBUaGlzIGNsYXNzIGlzIGdlbmVyYWxseSB0aGUgbWFpbiBlbnRyeSBwb2ludCBmb3IgZGV2ZWxvcGVyc1xyXG4gKiAgdGhhdCB3aXNoIHRvIHVzZSBhIHByaXZhdGUga2V5IGRpcmVjdGx5LCBhcyBpdCBjYW4gY3JlYXRlXHJcbiAqICBpbnN0YW5jZXMgZnJvbSBhIGxhcmdlIHZhcmlldHkgb2YgY29tbW9uIHNvdXJjZXMsIGluY2x1ZGluZ1xyXG4gKiAgcmF3IHByaXZhdGUga2V5LCBbW2xpbmstYmlwLTM5XV0gbW5lbW9uaWNzIGFuZCBlbmNyeXB0ZSBKU09OXHJcbiAqICB3YWxsZXRzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFdhbGxldCBleHRlbmRzIEJhc2VXYWxsZXQge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IHdhbGxldCBmb3IgdGhlIHByaXZhdGUgJSVrZXklJSwgb3B0aW9uYWxseSBjb25uZWN0ZWRcclxuICAgICAqICB0byAlJXByb3ZpZGVyJSUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGtleSwgcHJvdmlkZXIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIChrZXkpID09PSBcInN0cmluZ1wiICYmICFrZXkuc3RhcnRzV2l0aChcIjB4XCIpKSB7XHJcbiAgICAgICAgICAgIGtleSA9IFwiMHhcIiArIGtleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHNpZ25pbmdLZXkgPSAodHlwZW9mIChrZXkpID09PSBcInN0cmluZ1wiKSA/IG5ldyBTaWduaW5nS2V5KGtleSkgOiBrZXk7XHJcbiAgICAgICAgc3VwZXIoc2lnbmluZ0tleSwgcHJvdmlkZXIpO1xyXG4gICAgfVxyXG4gICAgY29ubmVjdChwcm92aWRlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgV2FsbGV0KHRoaXMuc2lnbmluZ0tleSwgcHJvdmlkZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gYSBbSlNPTiBLZXlzdG9yZSBXYWxsZXRdKGpzb24td2FsbGV0cykgZW5jcnlwdGVkIHdpdGhcclxuICAgICAqICAlJXBhc3N3b3JkJSUuXHJcbiAgICAgKlxyXG4gICAgICogIElmICUlcHJvZ3Jlc3NDYWxsYmFjayUlIGlzIHNwZWNpZmllZCwgaXQgd2lsbCByZWNlaXZlIHBlcmlvZGljXHJcbiAgICAgKiAgdXBkYXRlcyBhcyB0aGUgZW5jcnlwdGlvbiBwcm9jZXNzIHByb2dyZXNlcy5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZW5jcnlwdChwYXNzd29yZCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IGFjY291bnQgPSB7IGFkZHJlc3M6IHRoaXMuYWRkcmVzcywgcHJpdmF0ZUtleTogdGhpcy5wcml2YXRlS2V5IH07XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IGVuY3J5cHRLZXlzdG9yZUpzb24oYWNjb3VudCwgcGFzc3dvcmQsIHsgcHJvZ3Jlc3NDYWxsYmFjayB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBbSlNPTiBLZXlzdG9yZSBXYWxsZXRdKGpzb24td2FsbGV0cykgZW5jcnlwZWQgd2l0aFxyXG4gICAgICogICUlcGFzc3dvcmQlJS5cclxuICAgICAqXHJcbiAgICAgKiAgSXQgaXMgcHJlZmVycmVkIHRvIHVzZSB0aGUgW2FzeW5jIHZlcnNpb25dKGVuY3J5cHQpIGluc3RlYWQsXHJcbiAgICAgKiAgd2hpY2ggYWxsb3dzIGEgW1tQcm9ncmVzc0NhbGxiYWNrXV0gdG8ga2VlcCB0aGUgdXNlciBpbmZvcm1lZC5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBtZXRob2Qgd2lsbCBibG9jayB0aGUgZXZlbnQgbG9vcCAoZnJlZXppbmcgYWxsIFVJKSB1bnRpbFxyXG4gICAgICogIGl0IGlzIGNvbXBsZXRlLCB3aGljaCBtYXkgYmUgYSBub24tdHJpdmlhbCBkdXJhdGlvbi5cclxuICAgICAqL1xyXG4gICAgZW5jcnlwdFN5bmMocGFzc3dvcmQpIHtcclxuICAgICAgICBjb25zdCBhY2NvdW50ID0geyBhZGRyZXNzOiB0aGlzLmFkZHJlc3MsIHByaXZhdGVLZXk6IHRoaXMucHJpdmF0ZUtleSB9O1xyXG4gICAgICAgIHJldHVybiBlbmNyeXB0S2V5c3RvcmVKc29uU3luYyhhY2NvdW50LCBwYXNzd29yZCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgI2Zyb21BY2NvdW50KGFjY291bnQpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChhY2NvdW50LCBcImludmFsaWQgSlNPTiB3YWxsZXRcIiwgXCJqc29uXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xyXG4gICAgICAgIGlmIChcIm1uZW1vbmljXCIgaW4gYWNjb3VudCAmJiBhY2NvdW50Lm1uZW1vbmljICYmIGFjY291bnQubW5lbW9uaWMubG9jYWxlID09PSBcImVuXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgbW5lbW9uaWMgPSBNbmVtb25pYy5mcm9tRW50cm9weShhY2NvdW50Lm1uZW1vbmljLmVudHJvcHkpO1xyXG4gICAgICAgICAgICBjb25zdCB3YWxsZXQgPSBIRE5vZGVXYWxsZXQuZnJvbU1uZW1vbmljKG1uZW1vbmljLCBhY2NvdW50Lm1uZW1vbmljLnBhdGgpO1xyXG4gICAgICAgICAgICBpZiAod2FsbGV0LmFkZHJlc3MgPT09IGFjY291bnQuYWRkcmVzcyAmJiB3YWxsZXQucHJpdmF0ZUtleSA9PT0gYWNjb3VudC5wcml2YXRlS2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd2FsbGV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV0FSTklORzogSlNPTiBtaXNtYXRjaCBhZGRyZXNzL3ByaXZhdGVLZXkgIT0gbW5lbW9uaWM7IGZhbGxiYWNrIG9udG8gcHJpdmF0ZSBrZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHdhbGxldCA9IG5ldyBXYWxsZXQoYWNjb3VudC5wcml2YXRlS2V5KTtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudCh3YWxsZXQuYWRkcmVzcyA9PT0gYWNjb3VudC5hZGRyZXNzLCBcImFkZHJlc3MvcHJpdmF0ZUtleSBtaXNtYXRjaFwiLCBcImpzb25cIiwgXCJbIFJFREFDVEVEIF1cIik7XHJcbiAgICAgICAgcmV0dXJuIHdhbGxldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgKGFzeW5jaHJvbm91c2x5KSBhICoqV2FsbGV0KiogYnkgZGVjcnlwdGluZyB0aGUgJSVqc29uJSVcclxuICAgICAqICB3aXRoICUlcGFzc3dvcmQlJS5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgJSVwcm9ncmVzcyUlIGlzIHByb3ZpZGVkLCBpdCBpcyBjYWxsZWQgcGVyaW9kaWNhbGx5IGR1cmluZ1xyXG4gICAgICogIGRlY3J5cHRpb24gc28gdGhhdCBhbnkgVUkgY2FuIGJlIHVwZGF0ZWQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhc3luYyBmcm9tRW5jcnlwdGVkSnNvbihqc29uLCBwYXNzd29yZCwgcHJvZ3Jlc3MpIHtcclxuICAgICAgICBsZXQgYWNjb3VudCA9IG51bGw7XHJcbiAgICAgICAgaWYgKGlzS2V5c3RvcmVKc29uKGpzb24pKSB7XHJcbiAgICAgICAgICAgIGFjY291bnQgPSBhd2FpdCBkZWNyeXB0S2V5c3RvcmVKc29uKGpzb24sIHBhc3N3b3JkLCBwcm9ncmVzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzQ3Jvd2RzYWxlSnNvbihqc29uKSkge1xyXG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3MpIHtcclxuICAgICAgICAgICAgICAgIHByb2dyZXNzKDApO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgc3RhbGwoMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWNjb3VudCA9IGRlY3J5cHRDcm93ZHNhbGVKc29uKGpzb24sIHBhc3N3b3JkKTtcclxuICAgICAgICAgICAgaWYgKHByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzcygxKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHN0YWxsKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBXYWxsZXQuI2Zyb21BY2NvdW50KGFjY291bnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhICoqV2FsbGV0KiogYnkgZGVjcnlwdGluZyB0aGUgJSVqc29uJSUgd2l0aCAlJXBhc3N3b3JkJSUuXHJcbiAgICAgKlxyXG4gICAgICogIFRoZSBbW2Zyb21FbmNyeXB0ZWRKc29uXV0gbWV0aG9kIGlzIHByZWZlcnJlZCwgYXMgdGhpcyBtZXRob2RcclxuICAgICAqICB3aWxsIGxvY2sgdXAgYW5kIGZyZWV6ZSB0aGUgVUkgZHVyaW5nIGRlY3J5cHRpb24sIHdoaWNoIG1heSB0YWtlXHJcbiAgICAgKiAgc29tZSB0aW1lLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUVuY3J5cHRlZEpzb25TeW5jKGpzb24sIHBhc3N3b3JkKSB7XHJcbiAgICAgICAgbGV0IGFjY291bnQgPSBudWxsO1xyXG4gICAgICAgIGlmIChpc0tleXN0b3JlSnNvbihqc29uKSkge1xyXG4gICAgICAgICAgICBhY2NvdW50ID0gZGVjcnlwdEtleXN0b3JlSnNvblN5bmMoanNvbiwgcGFzc3dvcmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0Nyb3dkc2FsZUpzb24oanNvbikpIHtcclxuICAgICAgICAgICAgYWNjb3VudCA9IGRlY3J5cHRDcm93ZHNhbGVKc29uKGpzb24sIHBhc3N3b3JkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgSlNPTiB3YWxsZXRcIiwgXCJqc29uXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gV2FsbGV0LiNmcm9tQWNjb3VudChhY2NvdW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgcmFuZG9tIFtbSEROb2RlV2FsbGV0XV0gdXNpbmcgdGhlIGF2YWlsYWJsZVxyXG4gICAgICogIFtjcnlwdG9ncmFwaGljIHJhbmRvbSBzb3VyY2VdKHJhbmRvbUJ5dGVzKS5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgdGhlcmUgaXMgbm8gY3J5dG9ncmFwaGljIHJhbmRvbSBzb3VyY2UsIHRoaXMgd2lsbCB0aHJvdy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZVJhbmRvbShwcm92aWRlcikge1xyXG4gICAgICAgIGNvbnN0IHdhbGxldCA9IEhETm9kZVdhbGxldC5jcmVhdGVSYW5kb20oKTtcclxuICAgICAgICBpZiAocHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdhbGxldC5jb25uZWN0KHByb3ZpZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHdhbGxldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBbW0hETm9kZVdhbGxldF1dIGZvciAlJXBocmFzZSUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVBocmFzZShwaHJhc2UsIHByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3Qgd2FsbGV0ID0gSEROb2RlV2FsbGV0LmZyb21QaHJhc2UocGhyYXNlKTtcclxuICAgICAgICBpZiAocHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdhbGxldC5jb25uZWN0KHByb3ZpZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHdhbGxldDtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD13YWxsZXQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/wallet/wallet.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/bit-reader.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/wordlists/bit-reader.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBits: () => (/* binding */ decodeBits)\n/* harmony export */ });\nconst Base64 = \")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\";\r\n/**\r\n *  @_ignore\r\n */\r\nfunction decodeBits(width, data) {\r\n    const maxValue = (1 << width) - 1;\r\n    const result = [];\r\n    let accum = 0, bits = 0, flood = 0;\r\n    for (let i = 0; i < data.length; i++) {\r\n        // Accumulate 6 bits of data\r\n        accum = ((accum << 6) | Base64.indexOf(data[i]));\r\n        bits += 6;\r\n        // While we have enough for a word...\r\n        while (bits >= width) {\r\n            // ...read the word\r\n            const value = (accum >> (bits - width));\r\n            accum &= (1 << (bits - width)) - 1;\r\n            bits -= width;\r\n            // A value of 0 indicates we exceeded maxValue, it\r\n            // floods over into the next value\r\n            if (value === 0) {\r\n                flood += maxValue;\r\n            }\r\n            else {\r\n                result.push(value + flood);\r\n                flood = 0;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n//# sourceMappingURL=bit-reader.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvYml0LXJlYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFx3b3JkbGlzdHNcXGJpdC1yZWFkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQmFzZTY0ID0gXCIpIUAjJCVeJiooQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fXCI7XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCaXRzKHdpZHRoLCBkYXRhKSB7XHJcbiAgICBjb25zdCBtYXhWYWx1ZSA9ICgxIDw8IHdpZHRoKSAtIDE7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIGxldCBhY2N1bSA9IDAsIGJpdHMgPSAwLCBmbG9vZCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyBBY2N1bXVsYXRlIDYgYml0cyBvZiBkYXRhXHJcbiAgICAgICAgYWNjdW0gPSAoKGFjY3VtIDw8IDYpIHwgQmFzZTY0LmluZGV4T2YoZGF0YVtpXSkpO1xyXG4gICAgICAgIGJpdHMgKz0gNjtcclxuICAgICAgICAvLyBXaGlsZSB3ZSBoYXZlIGVub3VnaCBmb3IgYSB3b3JkLi4uXHJcbiAgICAgICAgd2hpbGUgKGJpdHMgPj0gd2lkdGgpIHtcclxuICAgICAgICAgICAgLy8gLi4ucmVhZCB0aGUgd29yZFxyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IChhY2N1bSA+PiAoYml0cyAtIHdpZHRoKSk7XHJcbiAgICAgICAgICAgIGFjY3VtICY9ICgxIDw8IChiaXRzIC0gd2lkdGgpKSAtIDE7XHJcbiAgICAgICAgICAgIGJpdHMgLT0gd2lkdGg7XHJcbiAgICAgICAgICAgIC8vIEEgdmFsdWUgb2YgMCBpbmRpY2F0ZXMgd2UgZXhjZWVkZWQgbWF4VmFsdWUsIGl0XHJcbiAgICAgICAgICAgIC8vIGZsb29kcyBvdmVyIGludG8gdGhlIG5leHQgdmFsdWVcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBmbG9vZCArPSBtYXhWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlICsgZmxvb2QpO1xyXG4gICAgICAgICAgICAgICAgZmxvb2QgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaXQtcmVhZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/bit-reader.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/decode-owl.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/wordlists/decode-owl.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   decodeOwl: () => (/* binding */ decodeOwl)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n\r\nconst subsChrs = \" !#$%&'()*+,-./<=>?@[]^_`{|}~\";\r\nconst Word = /^[a-z]*$/i;\r\nfunction unfold(words, sep) {\r\n    let initial = 97;\r\n    return words.reduce((accum, word) => {\r\n        if (word === sep) {\r\n            initial++;\r\n        }\r\n        else if (word.match(Word)) {\r\n            accum.push(String.fromCharCode(initial) + word);\r\n        }\r\n        else {\r\n            initial = 97;\r\n            accum.push(word);\r\n        }\r\n        return accum;\r\n    }, []);\r\n}\r\n/**\r\n *  @_ignore\r\n */\r\nfunction decode(data, subs) {\r\n    // Replace all the substitutions with their expanded form\r\n    for (let i = subsChrs.length - 1; i >= 0; i--) {\r\n        data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));\r\n    }\r\n    // Get all tle clumps; each suffix, first-increment and second-increment\r\n    const clumps = [];\r\n    const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word) => {\r\n        if (semi) {\r\n            for (let i = parseInt(semi); i >= 0; i--) {\r\n                clumps.push(\";\");\r\n            }\r\n        }\r\n        else {\r\n            clumps.push(item.toLowerCase());\r\n        }\r\n        return \"\";\r\n    });\r\n    /* c8 ignore start */\r\n    if (leftover) {\r\n        throw new Error(`leftovers: ${JSON.stringify(leftover)}`);\r\n    }\r\n    /* c8 ignore stop */\r\n    return unfold(unfold(clumps, \";\"), \":\");\r\n}\r\n/**\r\n *  @_ignore\r\n */\r\nfunction decodeOwl(data) {\r\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(data[0] === \"0\", \"unsupported auwl data\", \"data\", data);\r\n    return decode(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));\r\n}\r\n//# sourceMappingURL=decode-owl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvZGVjb2RlLW93bC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBbUQ7QUFDbkQsNENBQTRDLEVBQUU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0NBQXNDLHlCQUF5QjtBQUMvRDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFx3b3JkbGlzdHNcXGRlY29kZS1vd2wuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuY29uc3Qgc3Vic0NocnMgPSBcIiAhIyQlJicoKSorLC0uLzw9Pj9AW11eX2B7fH1+XCI7XHJcbmNvbnN0IFdvcmQgPSAvXlthLXpdKiQvaTtcclxuZnVuY3Rpb24gdW5mb2xkKHdvcmRzLCBzZXApIHtcclxuICAgIGxldCBpbml0aWFsID0gOTc7XHJcbiAgICByZXR1cm4gd29yZHMucmVkdWNlKChhY2N1bSwgd29yZCkgPT4ge1xyXG4gICAgICAgIGlmICh3b3JkID09PSBzZXApIHtcclxuICAgICAgICAgICAgaW5pdGlhbCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh3b3JkLm1hdGNoKFdvcmQpKSB7XHJcbiAgICAgICAgICAgIGFjY3VtLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpbml0aWFsKSArIHdvcmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaW5pdGlhbCA9IDk3O1xyXG4gICAgICAgICAgICBhY2N1bS5wdXNoKHdvcmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWNjdW07XHJcbiAgICB9LCBbXSk7XHJcbn1cclxuLyoqXHJcbiAqICBAX2lnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShkYXRhLCBzdWJzKSB7XHJcbiAgICAvLyBSZXBsYWNlIGFsbCB0aGUgc3Vic3RpdHV0aW9ucyB3aXRoIHRoZWlyIGV4cGFuZGVkIGZvcm1cclxuICAgIGZvciAobGV0IGkgPSBzdWJzQ2hycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KHN1YnNDaHJzW2ldKS5qb2luKHN1YnMuc3Vic3RyaW5nKDIgKiBpLCAyICogaSArIDIpKTtcclxuICAgIH1cclxuICAgIC8vIEdldCBhbGwgdGxlIGNsdW1wczsgZWFjaCBzdWZmaXgsIGZpcnN0LWluY3JlbWVudCBhbmQgc2Vjb25kLWluY3JlbWVudFxyXG4gICAgY29uc3QgY2x1bXBzID0gW107XHJcbiAgICBjb25zdCBsZWZ0b3ZlciA9IGRhdGEucmVwbGFjZSgvKDp8KFswLTldKXwoW0EtWl1bYS16XSopKS9nLCAoYWxsLCBpdGVtLCBzZW1pLCB3b3JkKSA9PiB7XHJcbiAgICAgICAgaWYgKHNlbWkpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcnNlSW50KHNlbWkpOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgY2x1bXBzLnB1c2goXCI7XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjbHVtcHMucHVzaChpdGVtLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIH0pO1xyXG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXHJcbiAgICBpZiAobGVmdG92ZXIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGxlZnRvdmVyczogJHtKU09OLnN0cmluZ2lmeShsZWZ0b3Zlcil9YCk7XHJcbiAgICB9XHJcbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xyXG4gICAgcmV0dXJuIHVuZm9sZCh1bmZvbGQoY2x1bXBzLCBcIjtcIiksIFwiOlwiKTtcclxufVxyXG4vKipcclxuICogIEBfaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlT3dsKGRhdGEpIHtcclxuICAgIGFzc2VydEFyZ3VtZW50KGRhdGFbMF0gPT09IFwiMFwiLCBcInVuc3VwcG9ydGVkIGF1d2wgZGF0YVwiLCBcImRhdGFcIiwgZGF0YSk7XHJcbiAgICByZXR1cm4gZGVjb2RlKGRhdGEuc3Vic3RyaW5nKDEgKyAyICogc3Vic0NocnMubGVuZ3RoKSwgZGF0YS5zdWJzdHJpbmcoMSwgMSArIDIgKiBzdWJzQ2hycy5sZW5ndGgpKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWNvZGUtb3dsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/decode-owl.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/decode-owla.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/wordlists/decode-owla.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeOwlA: () => (/* binding */ decodeOwlA)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _bit_reader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bit-reader.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/bit-reader.js\");\n/* harmony import */ var _decode_owl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decode-owl.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/decode-owl.js\");\n\r\n\r\n\r\n/**\r\n *  @_ignore\r\n */\r\nfunction decodeOwlA(data, accents) {\r\n    let words = (0,_decode_owl_js__WEBPACK_IMPORTED_MODULE_0__.decodeOwl)(data).join(\",\");\r\n    // Inject the accents\r\n    accents.split(/,/g).forEach((accent) => {\r\n        const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(match !== null, \"internal error parsing accents\", \"accents\", accents);\r\n        let posOffset = 0;\r\n        const positions = (0,_bit_reader_js__WEBPACK_IMPORTED_MODULE_2__.decodeBits)(parseInt(match[3]), match[4]);\r\n        const charCode = parseInt(match[2]);\r\n        const regex = new RegExp(`([${match[1]}])`, \"g\");\r\n        words = words.replace(regex, (all, letter) => {\r\n            const rem = --positions[posOffset];\r\n            if (rem === 0) {\r\n                letter = String.fromCharCode(letter.charCodeAt(0), charCode);\r\n                posOffset++;\r\n            }\r\n            return letter;\r\n        });\r\n    });\r\n    return words.split(\",\");\r\n}\r\n//# sourceMappingURL=decode-owla.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvZGVjb2RlLW93bGEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFtRDtBQUNOO0FBQ0Q7QUFDNUM7QUFDQTtBQUNBO0FBQ087QUFDUCxnQkFBZ0IseURBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYztBQUN0QjtBQUNBLDBCQUEwQiwwREFBVTtBQUNwQztBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcd29yZGxpc3RzXFxkZWNvZGUtb3dsYS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBkZWNvZGVCaXRzIH0gZnJvbSBcIi4vYml0LXJlYWRlci5qc1wiO1xyXG5pbXBvcnQgeyBkZWNvZGVPd2wgfSBmcm9tIFwiLi9kZWNvZGUtb3dsLmpzXCI7XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVPd2xBKGRhdGEsIGFjY2VudHMpIHtcclxuICAgIGxldCB3b3JkcyA9IGRlY29kZU93bChkYXRhKS5qb2luKFwiLFwiKTtcclxuICAgIC8vIEluamVjdCB0aGUgYWNjZW50c1xyXG4gICAgYWNjZW50cy5zcGxpdCgvLC9nKS5mb3JFYWNoKChhY2NlbnQpID0+IHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IGFjY2VudC5tYXRjaCgvXihbYS16XSopKFswLTldKykoWzAtOV0pKC4qKSQvKTtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChtYXRjaCAhPT0gbnVsbCwgXCJpbnRlcm5hbCBlcnJvciBwYXJzaW5nIGFjY2VudHNcIiwgXCJhY2NlbnRzXCIsIGFjY2VudHMpO1xyXG4gICAgICAgIGxldCBwb3NPZmZzZXQgPSAwO1xyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IGRlY29kZUJpdHMocGFyc2VJbnQobWF0Y2hbM10pLCBtYXRjaFs0XSk7XHJcbiAgICAgICAgY29uc3QgY2hhckNvZGUgPSBwYXJzZUludChtYXRjaFsyXSk7XHJcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGAoWyR7bWF0Y2hbMV19XSlgLCBcImdcIik7XHJcbiAgICAgICAgd29yZHMgPSB3b3Jkcy5yZXBsYWNlKHJlZ2V4LCAoYWxsLCBsZXR0ZXIpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVtID0gLS1wb3NpdGlvbnNbcG9zT2Zmc2V0XTtcclxuICAgICAgICAgICAgaWYgKHJlbSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbGV0dGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZShsZXR0ZXIuY2hhckNvZGVBdCgwKSwgY2hhckNvZGUpO1xyXG4gICAgICAgICAgICAgICAgcG9zT2Zmc2V0Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGxldHRlcjtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHdvcmRzLnNwbGl0KFwiLFwiKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWNvZGUtb3dsYS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/decode-owla.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/wordlists/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LangEn: () => (/* reexport safe */ _lang_en_js__WEBPACK_IMPORTED_MODULE_1__.LangEn),\n/* harmony export */   Wordlist: () => (/* reexport safe */ _wordlist_js__WEBPACK_IMPORTED_MODULE_0__.Wordlist),\n/* harmony export */   WordlistOwl: () => (/* reexport safe */ _wordlist_owl_js__WEBPACK_IMPORTED_MODULE_2__.WordlistOwl),\n/* harmony export */   WordlistOwlA: () => (/* reexport safe */ _wordlist_owla_js__WEBPACK_IMPORTED_MODULE_3__.WordlistOwlA),\n/* harmony export */   wordlists: () => (/* reexport safe */ _wordlists_js__WEBPACK_IMPORTED_MODULE_4__.wordlists)\n/* harmony export */ });\n/* harmony import */ var _wordlist_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wordlist.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/wordlist.js\");\n/* harmony import */ var _lang_en_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lang-en.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/lang-en.js\");\n/* harmony import */ var _wordlist_owl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wordlist-owl.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/wordlist-owl.js\");\n/* harmony import */ var _wordlist_owla_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wordlist-owla.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/wordlist-owla.js\");\n/* harmony import */ var _wordlists_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wordlists.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/wordlists-browser.js\");\n/**\r\n *  A Wordlist is a set of 2048 words used to encode private keys\r\n *  (or other binary data) that is easier for humans to write down,\r\n *  transcribe and dictate.\r\n *\r\n *  The [[link-bip-39]] standard includes several checksum bits,\r\n *  depending on the size of the mnemonic phrase.\r\n *\r\n *  A mnemonic phrase may be 12, 15, 18, 21 or 24 words long. For\r\n *  most purposes 12 word mnemonics should be used, as including\r\n *  additional words increases the difficulty and potential for\r\n *  mistakes and does not offer any effective improvement on security.\r\n *\r\n *  There are a variety of [[link-bip39-wordlists]] for different\r\n *  languages, but for maximal compatibility, the\r\n *  [English Wordlist](LangEn) is recommended.\r\n *\r\n *  @_section: api/wordlists:Wordlists [about-wordlists]\r\n */\r\n\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lDO0FBQ0g7QUFDVTtBQUNFO0FBQ1A7QUFDM0MiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcd29yZGxpc3RzXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIEEgV29yZGxpc3QgaXMgYSBzZXQgb2YgMjA0OCB3b3JkcyB1c2VkIHRvIGVuY29kZSBwcml2YXRlIGtleXNcclxuICogIChvciBvdGhlciBiaW5hcnkgZGF0YSkgdGhhdCBpcyBlYXNpZXIgZm9yIGh1bWFucyB0byB3cml0ZSBkb3duLFxyXG4gKiAgdHJhbnNjcmliZSBhbmQgZGljdGF0ZS5cclxuICpcclxuICogIFRoZSBbW2xpbmstYmlwLTM5XV0gc3RhbmRhcmQgaW5jbHVkZXMgc2V2ZXJhbCBjaGVja3N1bSBiaXRzLFxyXG4gKiAgZGVwZW5kaW5nIG9uIHRoZSBzaXplIG9mIHRoZSBtbmVtb25pYyBwaHJhc2UuXHJcbiAqXHJcbiAqICBBIG1uZW1vbmljIHBocmFzZSBtYXkgYmUgMTIsIDE1LCAxOCwgMjEgb3IgMjQgd29yZHMgbG9uZy4gRm9yXHJcbiAqICBtb3N0IHB1cnBvc2VzIDEyIHdvcmQgbW5lbW9uaWNzIHNob3VsZCBiZSB1c2VkLCBhcyBpbmNsdWRpbmdcclxuICogIGFkZGl0aW9uYWwgd29yZHMgaW5jcmVhc2VzIHRoZSBkaWZmaWN1bHR5IGFuZCBwb3RlbnRpYWwgZm9yXHJcbiAqICBtaXN0YWtlcyBhbmQgZG9lcyBub3Qgb2ZmZXIgYW55IGVmZmVjdGl2ZSBpbXByb3ZlbWVudCBvbiBzZWN1cml0eS5cclxuICpcclxuICogIFRoZXJlIGFyZSBhIHZhcmlldHkgb2YgW1tsaW5rLWJpcDM5LXdvcmRsaXN0c11dIGZvciBkaWZmZXJlbnRcclxuICogIGxhbmd1YWdlcywgYnV0IGZvciBtYXhpbWFsIGNvbXBhdGliaWxpdHksIHRoZVxyXG4gKiAgW0VuZ2xpc2ggV29yZGxpc3RdKExhbmdFbikgaXMgcmVjb21tZW5kZWQuXHJcbiAqXHJcbiAqICBAX3NlY3Rpb246IGFwaS93b3JkbGlzdHM6V29yZGxpc3RzIFthYm91dC13b3JkbGlzdHNdXHJcbiAqL1xyXG5leHBvcnQgeyBXb3JkbGlzdCB9IGZyb20gXCIuL3dvcmRsaXN0LmpzXCI7XHJcbmV4cG9ydCB7IExhbmdFbiB9IGZyb20gXCIuL2xhbmctZW4uanNcIjtcclxuZXhwb3J0IHsgV29yZGxpc3RPd2wgfSBmcm9tIFwiLi93b3JkbGlzdC1vd2wuanNcIjtcclxuZXhwb3J0IHsgV29yZGxpc3RPd2xBIH0gZnJvbSBcIi4vd29yZGxpc3Qtb3dsYS5qc1wiO1xyXG5leHBvcnQgeyB3b3JkbGlzdHMgfSBmcm9tIFwiLi93b3JkbGlzdHMuanNcIjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/lang-en.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/wordlists/lang-en.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LangEn: () => (/* binding */ LangEn)\n/* harmony export */ });\n/* harmony import */ var _wordlist_owl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wordlist-owl.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/wordlist-owl.js\");\n\r\nconst words = \"0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO\";\r\nconst checksum = \"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\";\r\nlet wordlist = null;\r\n/**\r\n *  The [[link-bip39-en]] for [mnemonic phrases](link-bip-39).\r\n *\r\n *  @_docloc: api/wordlists\r\n */\r\nclass LangEn extends _wordlist_owl_js__WEBPACK_IMPORTED_MODULE_0__.WordlistOwl {\r\n    /**\r\n     *  Creates a new instance of the English language Wordlist.\r\n     *\r\n     *  This should be unnecessary most of the time as the exported\r\n     *  [[langEn]] should suffice.\r\n     *\r\n     *  @_ignore:\r\n     */\r\n    constructor() { super(\"en\", words, checksum); }\r\n    /**\r\n     *  Returns a singleton instance of a ``LangEn``, creating it\r\n     *  if this is the first time being called.\r\n     */\r\n    static wordlist() {\r\n        if (wordlist == null) {\r\n            wordlist = new LangEn();\r\n        }\r\n        return wordlist;\r\n    }\r\n}\r\n//# sourceMappingURL=lang-en.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvbGFuZy1lbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFnRDtBQUNoRCxrUEFBa1AsZ01BQWdNLDhNQUE4TSxpRkFBaUYsb0JBQW9CLHlRQUF5USxhQUFhLFVBQVUsWUFBWSxtREFBbUQsZUFBZSx3RkFBd0YsNERBQTRELFVBQVUseUJBQXlCLGk0QkFBaTRCLDRCQUE0QiwyQ0FBMkMsMGRBQTBkLGNBQWMsb0xBQW9MLHdDQUF3Qyw2QkFBNkIsdU5BQXVOLHlqQkFBeWpCLGdIQUFnSCxvQ0FBb0MsY0FBYyxnQkFBZ0IsME9BQTBPLHNVQUFzVSx5REFBeUQsc0lBQXNJLE9BQU8saUpBQWlKLG1NQUFtTSxRQUFRLE1BQU0sd1hBQXdYLDBDQUEwQyxrQkFBa0IsNEJBQTRCLDhGQUE4RixzVUFBc1UsNkJBQTZCO0FBQzkxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQix5REFBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFx3b3JkbGlzdHNcXGxhbmctZW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgV29yZGxpc3RPd2wgfSBmcm9tIFwiLi93b3JkbGlzdC1vd2wuanNcIjtcclxuY29uc3Qgd29yZHMgPSBcIjBlcmxlb25hbG9yZW5zZWluY2VyZWdlc3RpY2l0U3RhbnZldGVhcmN0c3NpI2NoMkF0aGNrJnRuZUxsMEFuZCNJbC55TGVPdXRPPVN8UyViL3JhQFN1cmRVJzBDZVtDaWR8Q291bnRDdSdIaWU9SWRPdSwtUXVpKlJvW1RUXVQlVCpbVHUkMEFwdERELXREKltKdSxNLlVsdFY8KVZpKTBSb2ItMEZhaXJGJWRSYWlkMEEoRUVudFJlZTBFYWQwTVJScCV0UyFfcm1CdW1Db2hvbEVydEkmTExleUxvd01vLE99UGhhUmVhZHlTb1QgV2F5czBBPnVyQXooZ09uZ091bnRVJ2QwQWx5LENoJUNpfEcgRyFHcnlJbSRLIU5vdW4pTnUkT2AgU3cgVCZuYVRpcXVlWGlldHlZMUFydE9sb2d5UGU/UCFQcm89UmlsMUNoQ3QtRWFFbmFHdWVNTWVkTSVNeU91bmRSPCtSZSxSaT1Sb3dUVGVmYUBUaSxUdyVrMEtQZUBTYXVsdFNldFNpLFN1bWVUaG1hMEghPk9tVGF7VCZkVC51ZGVUcmFAMEN0XUQuR3UsTnRUaCVUb1R1bW4wRXJhK09jYWRvT2lkMEFrZUEqQXlFc29tZUZ1bEt3P2QwSXM6QnlDaGVsJUMjRCtHTDwpTGMjeX5NYm9vTjxhTm4gUlJlbHlSZ2EoUipsU2VTLVNrZXRUdCEzQV5BbkF1dHlDYXUnQ29tZUVmRiVlRyhIYT1IKGRMaWU9TG93THROXk5lZi4vVHJheVR0IFR3ZSZZI2QzQ3ljIURLZU5kT2xvZ3lSZFJgVHQgX3tBZGVBbWVBbmtldEEsRWFrRVtJbmRPb2RPW29tT3UnVWVVclVzaF9yZEF0RHlJbE1iTmVOdXNPa08sUmQgUihnUnJvd1NzVHRvbVVuKVhZX3tldEEoQW5kQVtBPUVhZEVlemVJe0lkK0llZklnaHRJbmdJc2tPY2NvbGlPayZPbnplT29tT2AgT3duVXNoMkJiIURkeUQrdEZmJG9JbGRMYkxrTCF0TmQhTmsgUmQmUmcgUixTUyhlW1N5VHQgWSBaejpCYmErQihCIUN0dXNHZUtlfkxtTSBhTXBOTiROKWxOZHlObiNOb2VOdmFzTnkjUGFiIVAuJFB0YShSUmIjUmRSZ29ScGV0UnJ5UnRTZVNoUyhvLyFTdSRUVCRvZ1ReVGVnJXlUdCFVZ2h0VSdVdF1WZTNJbChnTCB5TXxOc3VzTnR1cnlSZSRSdGEoX2lyQWxrQW1wXUFuK0Fvc0FwdCBBcitBJ0F0RWFwRXtFZSdFZkVycnlFLEl7JkllZklsZEltfXlPaSlPbydSIy1VeyFVbmtVcm4wRz9ObmFtI1JjIVRpeiZUeVZpbF9pbUFwQXJpZnlBd0F5RTxFcmtFdiBJe0l8SWZmSW1iSW4tSXBPe09nTydPYE91ZE93blViVW1wVSwgVXReX15BLEMjdXREZUZmZWVJbEluTCFATCVMdW1uTWIoZU1lTWYldE0tTW0jTXA8eU5jIHROZHVATmZpcm1OZypbTn1ATnNpZCBOdHJvbE52KClPa09sUHAgUHlSJFJlUm5SKkAvVHQjVV5VbnRyeVVwIVVyJ1VzKFYgWW8+X3tBZCFBZnRBbUF9QXNoQXQgQXdsQXp5RWFtRWQuRWVrRXdJe2V0SW1lSXNwSXQtT3BPW091Xk93ZFVjaSRVZWxVaSdVbWIhVW5eVXNoWVksJDJCZUx0dSpQUGJvP2RSaW91c1JyfFJ0YShSPVNoXS9vbVRlM0MhOkRNYStNcE4pTmcgUihnU2hVZ2h0IFduWTNBbEJhPkJyaXNDYWRlQ2VtYiBDaWRlQ2woZUMlYT5DKmEnRXJGJidGKGVGeUcqZUxheUxpdiBNPGRNaSdOaSROdGksTnlQP3RQJmRQb3MuUGBQdXR5Umk9U2NyaWJlUyB0U2lnblNrU3BhaXIvcm95VGFpbFRlQFZlbG9wVmkpVm8+M0FncmFtQWxBbSNkQXJ5Q2VFJ2xFdEZmIEcuJEduLnlMZW1tYU5uIE5vc2F1clJlQFJ0U2FnKmVTY292IFNlYSdTaFNtaVtTJWQgU3BsYXkvPClWIHRWaWRlViUpWnp5NUN0JUN1bXxHfkxwaChNYShOYT5Oa2V5TiVPclNlVWIhVmVfZnRBZyNBbWFBLC1Bd0VhbUVbSWZ0SWxsSW5rSXBJPU9wVW1ZMkNrTWJOZVIoZy9UXlR5MUFyZjFOYW0tOkcgRyFSbHlSblJgU2lseS9TeTFIb09sb2d5T25vbXkwR2VJdFVjYT4xRiV0MEcxR2h0VGggMkJvd0QgRUByLUVnPHRFbXxFcGg8dEV2YXQlST5TZTBCP2tCb2R5QnJhKUVyK090XVBsb3lQb3cgUHR5MEFiIUFAREQhW0QlJ0VteUVyZ3lGJSlHYStHKGVIPClKb3lMaSxPdWdoUi1oUm9sbFN1KlQgVGkqVHJ5VmVsb3BlMUlzb2RlMFUkVWlwMEFBJ09kZU9zXVIlVXB0MENhcGVTYXlTJilUYT4wRXJuJEgtczFJZCYpSWxPa2VPbD0xQUBBbXAhQ2VbQ2g8K0MuZUNsdWRlQ3UnRWN1PkVyY2knSGF1LEhpYi5JIUksSXRPdC1QPGRQZUBQaSpQbGEoUG8nUCpbVCZkVHJhMEVFYnJvdzpCci1DZUN1bHR5RGVJbnRJYH5MJ01lTWlseU1vdXNOTmN5TnRhc3lSbVNoXVRUJFRoIFRpZ3VlVWx0ViUuZTNBdHUqQnJ1P3lEICRFRWRFbE1hIU4pL2l2JFReViBXM0IgQ3RdRWxkR3UqTGVMbUx0IE4kTmROZU5nIE5pc2hSZVJtUixTYyRTaFRUfVtYX2dBbWVBc2hBdEF2JUVlSWdodElwT2F0T3tPJU93IFVpZFVzaFlfbUN1c0dJbExkfm93T2RPdFIpUmUsUit0UmtSdHV9UnVtUnc/ZFNzaWwvIFVuZFhfZ2khQW1lRXF1fEVzaEkmZEluK09nT250TyxPd25PeiZVLjJFbE5ObnlSbmEpUnlUdSo6RCt0SW5MYXh5fiB5TWVQUmErUmJhK1JkJlJsLVJtfFNTcFRlVGggVStaZTNOICROaXVzTipOdCFOdShlL3UqMk8sMEFudEZ0R2chTmcgUmFmZmVSbFZlX2RBbilBKkFbSWRlSW1wJ09iZU9vbU9yeU89T3dVZV90RGRlW0xkT2RPJ1JpbGxhU3BlbFNzaXBWIG5Xbl9iQSlBKEFudEFwZUFbQXYueUVhdEUmSWRJZWZJdE9jIHlPdXBPd1VudF9yZEVbSWRlSWx0SXQ/TjNNOkIuSXJMZk1tIE0sIE5kUHB5UmIlUmRSc2hSPSxUVmVXa1o/ZDNBZEFsYEFydEF2eUQraG9nSWdodH5vTG1ldExwTlJvM0RkJkdofk50UFJlLyV5NUJieUNrZXlMZExlTGlkYXl+b3dNZU5leU9kUGVSblJyJVInU3AuJC9UZWxVclYgNUJHZU08TWIhTSVOZCpkTmdyeU50UmQhUnJ5UnRTYjxkM0JyaWQ6MUVPbjBFYUVudGlmeUxlMk4lZTRMTGVnJEx9WzBBK0l0YT5NJidNdX1QYUBQbydQcm89UHVsJzBDaENsdWRlQ29tZUMqYSdEZXhELWE+RG8lRHUscnlGPHRGbC10RiVtSGEhSCAuSXRpJEplQEp1cnlNYT5OIE5vY3xQdXRRdWlyeVM8ZVNlQFNpZGVTcGkqLyRsVGFAVCBlLFRvVmUsVi5lVm9sPTNPbjBMPGRPbGE+U3VlMEVtMU9yeTpDa2V0R3U/Ulp6M0Fsb3VzQW5zfnlXZWw5QkluS2VVcn15WTVEK0kpTXBOZyFOaSVOay86Tmc/b28zRW5FcFRedXBZM0NrRER9eU5kTmdkb21Tc1RUXiZUZVR0JldpNEVlSWZlT3tPdzpCQmVsQiVEZCBEeUtlTXBOZ3VhK1B0b3BSK1QgVChVZ2hVbmRyeVZhV1duV3N1LlkgWnkzQWQgQWZBcm5BPUN0dSpGdEdHJEcmZElzdSpNI05kTmdgTnNPcD9kU3MjVHQgVmVsM0FyQiB0eUJyP3lDJidGZUZ0R2h0S2VNYk0uTmtPblF1aWQvVHQhVmVaP2Q1QWRBbkIsIEMkQ2tHLU5lbHlOZ09wVHQgeVVkVW4rVmVZJDVDa3lHZ2ErTWIgTj9OXlh1cnkzUi1zOkNoKGVERy1HfXRJZElsSW5KJUtlTW0kTk5hK05kYT5OZ29Oc11OdSRQIVJiIVJeUmcoUihlUmtldFJyaWErU2tTcy8gVF5UIGkkVGhUcml4VHQgWGltdW1aZTNBZG93QW5Bc3UqQXRDaDwtRCREaWFMb2R5THRNYiBNJXlOdF1OdVJjeVIrUi5ScnlTaFNzYStUJFRob2QzRGQhRG5pZ2h0TGt+XU0tTmROaW11bU4lTnU+UmFjIVJyJVMgeVNzL2FrZVhYZWRYdHUqNUJpIURlbERpZnlNTXxOLiVOa2V5TiwgTmBPblIkUmVSbihnU3F1Lm9UaCBUXVQlVW50YShVJ1ZlVmllNUNoRmYoTGVMdGlwbHlTYyFTZXVtU2hyb29tUy0vVHUkM1NlbGYvIHlUaDpJPU1lUGsoUnJvdy95VF1UdSozQXJDa0VkR2F0aT1HIUBJYCBQaGV3Uj0vVFR3JWtVdHIkViBXc1h0M0NlR2h0NUIhSSdNKGVlT2QhUm0kUmBTZVRhYiFUZVRoKGdUaSlWZWxXNUMhP01iIFInVDpLMEV5SmVATGkrU2N1KlMgPVRhKFZpb3VzMEN1ckU8VG9iIDBPcjFGRiBGaSlUJjJMMUF5MERJPVltcC0wSXQwQ2VFSSNMKGVMeTFFbkVyYUluXVBvJ1RdMUFuK0IuQ2g/ZEQgRCg/eUc8SXxJZygkUGg8MFRyLWgwSCAwVGRvJVQgVHB1dFRzaWRlMEFsRW5FcjBOTiAwWWcmMC8gME99OkN0RGQhR2VJckxhKUxtTmRhTmVsTi1OYCBQIFJhZGVSfFJrUnJvdFJ0eVNzVF5UaFRpfFRyb2xUdCBuVSdWZVltfDNBKUFudXRBckFzPHRMLTxOTiR0eU5jaWxPcCFQcCBSZmVAUm0uUnMjVDJPfU90b1JhJ1lzLSQwQW5vQ24tQ3R1KkUpR0dlI35Mb3ROa099IFBlL29sVF5aemFfKUF9dEEsLUE+QXlFYSdFZCtVe1VnVW4rMkVtRXRJbnRMP0xlTGkpTmROeU9sUHVsP1J0XVMuXVNzaWIhL1RhdG9UdCB5ViB0eVdkIFcgX0BpKUFpJ0VkLXRFZiBFcGEqRXN8RXR0eUV2fEkpSWRlSW0/eUludEklLnlJcyNJdmE+SXplT2IhbU8pW09kdSlPZi5PZ3JhbU9qZUBPbW8+T29mT3AgdHlPc3AgTz5AT3VkT3ZpZGUyQmwtRGQoZ35McEwnTXBrKE5eUGlsUHB5Ul5hJ1IueVJwbydSJ1NoVFp6ITNSYW1pZDo5OUFsLnlBbnR1bUFydCBFLF1Je0l0SXpPPjpCYi5DY28jQ2VDa0Q/RGlvSWxJbkknfnlNcE5eTmRvbU4rUGlkUmVUZVRoIFYmV1olM0FkeUFsQXMjQmVsQnVpbGRDJGxDZWk9Q2lwZUMlZEN5YyFEdSlGIUBGJW1GdSdHXUcqdEd1bD9KZUBMYXhMZWEnTGllZkx5TWEoTWVtYiBNKGRNbz1OZCBOZXdOdE9wJlBhaXJQZWF0UGxhKVAldFF1aSpTY3VlU2VtYiFTaSxTb3VyKVNwIydTdWx0VGkqVCphdFR1cm5Vbl1WZSRWaWV3Vz9kMllgbTBCQmIjQ2VDaERlRCtGIUdodEdpZE5nT3RQcCFTa1R1JFYkViA1QWRBLEJvdEJ1LENrZXRNPClPZk9raWVPbVNlVGE+VWdoVW5kVT5ZJDVCYiBEZUdMZU5Od2F5UiQ6RERkIUR9W0ZlSWxMYWRMbSNMI0x0THU+TWVNcCFOZFRpc2Z5VG9zaGlVKVVzYStWZVkxQSFBbkEqQXR0IEV9SGVtZUhvb2xJJilJWyVzT3JwXU91dFJhcFJlJlJpcHRSdWIxQUFyXkFzI0F0QyNkQyp0Q3RdQ3VyLnlFZEVrR218TGVAfk0oP05pJU4nTnQmKVJpZXNSdmkpU3NdVHQhVHVwViZfZG93QWZ0QWxsb3dBKkVkRWxsRXJpZmZJZWxkSWZ0SX1JcEl2IE97T2VPb3RPcE9ydE91bGQgTz1SaW1wUnVnVWZmIVkwQmwoZ0NrRGVFK0dodEduTHxMa355THYgTWlsP01wIU4pTmdSJi8gVHVhPlhaZTFBPkV0XklJbGxJbklydFVsbDBBYkFtRWVwRW5kIEkpSWRlSWdodEltT2c8T3RPd1VzaDBBbGxBcnRJIU9rZU9vYDBBe0FrZUFwSWZmT3cwQXBDYyBDaSRDa0RhRnRMP0xkaSBMaWRMdXRdTD1NZSNlTmdPblJyeVJ0VWxVbmRVcFVyKVVgMEEpQSpBdGkkQXduRWFrRWNpJEVlZEVsbEVuZEggZUkpSWQgSWtlSW5Jci5MLk9pbE9ucyVPI09ydE90UmF5UmVhZFIoZ1kwVWEqVWVlemVVaXIqbF9iIUFkaXVtQWZmQStBaXJzQW1wQW5kQXJ0QT5BeUVha0VlbEVtRXBFKm9Je0lsbEluZ097T21hXk99T29sT3J5Tz1SYT5neVJlZXRSaWtlUiNnUnVnZyFVZHxVZmZVbWIhWSEwQmplQEJtLkJ3YXlDKVtDaERkJkZmIEc/RyssSXRNbSBOTm55Tid0UCBQcGx5UCptZVJlUmZhKVIrUnByaSdScm91bmRSPXlTcGVAL2EoMUFsbG93QW1wQXBBcm1FP0VldElmdEltSW5nSXReT3JkMU1ib2xNcHRvbVJ1cC9lbTpCIUNrIUdJbEx8TGtOa1BlUit0U2svZVR0b29YaTNBXkFtfk5OPHRObmlzTnRSbS9YdF9ua0F0RW1lRW5FJXlFKkV5SW5nSXNPdWdodFJlZVJpPVJvd1VtYlVuZCAwQ2tldERlRyBMdE1iIE1lTnlQUmVkU3N1ZVQhNUEsQmFjY29EYXlEZGwgRUdlYCBJIXRLJk1hdG9NJXJvd05lTmd1ZU5pZ2h0T2xPYFBQLVBwIVJeUm5hZG9SdG9pJ1NzVCRVcmksVz9kVyBXbllfe0FkZUFmZi1BZy1BKEFuc2YgQXBBc2hBPWxBeUVhdEVlRW5kSSRJYmVJe0lnZyBJbUlwT3BoeU91YiFVe1VlVWx5VW1wZXRVLFVgWTJCZUl0XU1iIU5hTn1sUmtleVJuUnQhMUVsPUVudHlJKUluSSxPMVBlUC0kOjVMeTVCKmxsYTBBYiFBd2EqQyFDb3YgRCBEb0ZhaXJGb2xkSGFwcHlJZiVtSXF1ZUl0SXYgJ0tub3duTG97VGlsVXN1JFZlaWwxRGE+R3JhZGVIb2xkT25QIFNldDFCPEdlMEErRUVkRWZ1bEUhW1UkMElsLnk6Qzx0Q3V1bUd1ZUxpZEwheUw9Tk5pc2hQJVJpb3VzL1VsdDNILSFMPXROZCVOdHUqTnVlUmJSaWZ5UnNdUnlTJ2xUIDwzQWIhQnI8dENpb3VzQ3QleURlb0V3fmErTnRhK09sKFJ0dSRSdXNTYVMuU3UkVCRWaWQ1QyRJKUlkTGM8b0x1bWVUZVlhKzpHZUcjSXRMa35MbnV0TnRSZmEqUm1ScmklU2hTcC9lVCBWZVkzQWxgQXAjQXJBJ2xBYCBCRGQoZ0VrJmRJcmRMY29tZS9UXyFBdEVhdEVlbEVuRSpJcElzcCAwRGVEYEZlTGR+Tk5kb3dOZU5nTmtObiBOdCBSZVNkb21TZVNoVH1bNUxmTTxOZCBPZE9sUmRSa1JsZFJyeVJgX3BFe0UsIUksST5Pbmc6OlJkM0Fyfm93OVVVbmdVYDozQnJhUm85TmVPXCI7XHJcbmNvbnN0IGNoZWNrc3VtID0gXCIweDNjOGFjYzFlN2IwOGQ4ZTc2ZjlmZGEwMTVlZjQ4ZGM4YzcxMGE3M2NiN2UwZjc3YjJjMThhOWI1YTdhZGRlNjBcIjtcclxubGV0IHdvcmRsaXN0ID0gbnVsbDtcclxuLyoqXHJcbiAqICBUaGUgW1tsaW5rLWJpcDM5LWVuXV0gZm9yIFttbmVtb25pYyBwaHJhc2VzXShsaW5rLWJpcC0zOSkuXHJcbiAqXHJcbiAqICBAX2RvY2xvYzogYXBpL3dvcmRsaXN0c1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExhbmdFbiBleHRlbmRzIFdvcmRsaXN0T3dsIHtcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEVuZ2xpc2ggbGFuZ3VhZ2UgV29yZGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgc2hvdWxkIGJlIHVubmVjZXNzYXJ5IG1vc3Qgb2YgdGhlIHRpbWUgYXMgdGhlIGV4cG9ydGVkXHJcbiAgICAgKiAgW1tsYW5nRW5dXSBzaG91bGQgc3VmZmljZS5cclxuICAgICAqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkgeyBzdXBlcihcImVuXCIsIHdvcmRzLCBjaGVja3N1bSk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgYSBgYExhbmdFbmBgLCBjcmVhdGluZyBpdFxyXG4gICAgICogIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgYmVpbmcgY2FsbGVkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgd29yZGxpc3QoKSB7XHJcbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgd29yZGxpc3QgPSBuZXcgTGFuZ0VuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3b3JkbGlzdDtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nLWVuLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/lang-en.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/wordlist-owl.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/wordlists/wordlist-owl.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WordlistOwl: () => (/* binding */ WordlistOwl)\n/* harmony export */ });\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../hash/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/hash/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _decode_owl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decode-owl.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/decode-owl.js\");\n/* harmony import */ var _wordlist_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wordlist.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/wordlist.js\");\n// Use the encode-latin.js script to create the necessary\r\n// data files to be consumed by this class\r\n\r\n\r\n\r\n\r\n/**\r\n *  An OWL format Wordlist is an encoding method that exploits\r\n *  the general locality of alphabetically sorted words to\r\n *  achieve a simple but effective means of compression.\r\n *\r\n *  This class is generally not useful to most developers as\r\n *  it is used mainly internally to keep Wordlists for languages\r\n *  based on ASCII-7 small.\r\n *\r\n *  If necessary, there are tools within the ``generation/`` folder\r\n *  to create the necessary data.\r\n */\r\nclass WordlistOwl extends _wordlist_js__WEBPACK_IMPORTED_MODULE_0__.Wordlist {\r\n    #data;\r\n    #checksum;\r\n    /**\r\n     *  Creates a new Wordlist for %%locale%% using the OWL %%data%%\r\n     *  and validated against the %%checksum%%.\r\n     */\r\n    constructor(locale, data, checksum) {\r\n        super(locale);\r\n        this.#data = data;\r\n        this.#checksum = checksum;\r\n        this.#words = null;\r\n    }\r\n    /**\r\n     *  The OWL-encoded data.\r\n     */\r\n    get _data() { return this.#data; }\r\n    /**\r\n     *  Decode all the words for the wordlist.\r\n     */\r\n    _decodeWords() {\r\n        return (0,_decode_owl_js__WEBPACK_IMPORTED_MODULE_1__.decodeOwl)(this.#data);\r\n    }\r\n    #words;\r\n    #loadWords() {\r\n        if (this.#words == null) {\r\n            const words = this._decodeWords();\r\n            // Verify the computed list matches the official list\r\n            const checksum = (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_2__.id)(words.join(\"\\n\") + \"\\n\");\r\n            /* c8 ignore start */\r\n            if (checksum !== this.#checksum) {\r\n                throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);\r\n            }\r\n            /* c8 ignore stop */\r\n            this.#words = words;\r\n        }\r\n        return this.#words;\r\n    }\r\n    getWord(index) {\r\n        const words = this.#loadWords();\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(index >= 0 && index < words.length, `invalid word index: ${index}`, \"index\", index);\r\n        return words[index];\r\n    }\r\n    getWordIndex(word) {\r\n        return this.#loadWords().indexOf(word);\r\n    }\r\n}\r\n//# sourceMappingURL=wordlist-owl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvd29yZGxpc3Qtb3dsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNzQztBQUNhO0FBQ1A7QUFDSDtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQkFBMEIsa0RBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0RBQUU7QUFDL0I7QUFDQTtBQUNBLHNEQUFzRCxhQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjLDREQUE0RCxNQUFNO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHdvcmRsaXN0c1xcd29yZGxpc3Qtb3dsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFVzZSB0aGUgZW5jb2RlLWxhdGluLmpzIHNjcmlwdCB0byBjcmVhdGUgdGhlIG5lY2Vzc2FyeVxyXG4vLyBkYXRhIGZpbGVzIHRvIGJlIGNvbnN1bWVkIGJ5IHRoaXMgY2xhc3NcclxuaW1wb3J0IHsgaWQgfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBkZWNvZGVPd2wgfSBmcm9tIFwiLi9kZWNvZGUtb3dsLmpzXCI7XHJcbmltcG9ydCB7IFdvcmRsaXN0IH0gZnJvbSBcIi4vd29yZGxpc3QuanNcIjtcclxuLyoqXHJcbiAqICBBbiBPV0wgZm9ybWF0IFdvcmRsaXN0IGlzIGFuIGVuY29kaW5nIG1ldGhvZCB0aGF0IGV4cGxvaXRzXHJcbiAqICB0aGUgZ2VuZXJhbCBsb2NhbGl0eSBvZiBhbHBoYWJldGljYWxseSBzb3J0ZWQgd29yZHMgdG9cclxuICogIGFjaGlldmUgYSBzaW1wbGUgYnV0IGVmZmVjdGl2ZSBtZWFucyBvZiBjb21wcmVzc2lvbi5cclxuICpcclxuICogIFRoaXMgY2xhc3MgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwgdG8gbW9zdCBkZXZlbG9wZXJzIGFzXHJcbiAqICBpdCBpcyB1c2VkIG1haW5seSBpbnRlcm5hbGx5IHRvIGtlZXAgV29yZGxpc3RzIGZvciBsYW5ndWFnZXNcclxuICogIGJhc2VkIG9uIEFTQ0lJLTcgc21hbGwuXHJcbiAqXHJcbiAqICBJZiBuZWNlc3NhcnksIHRoZXJlIGFyZSB0b29scyB3aXRoaW4gdGhlIGBgZ2VuZXJhdGlvbi9gYCBmb2xkZXJcclxuICogIHRvIGNyZWF0ZSB0aGUgbmVjZXNzYXJ5IGRhdGEuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgV29yZGxpc3RPd2wgZXh0ZW5kcyBXb3JkbGlzdCB7XHJcbiAgICAjZGF0YTtcclxuICAgICNjaGVja3N1bTtcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgV29yZGxpc3QgZm9yICUlbG9jYWxlJSUgdXNpbmcgdGhlIE9XTCAlJWRhdGElJVxyXG4gICAgICogIGFuZCB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgJSVjaGVja3N1bSUlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGUsIGRhdGEsIGNoZWNrc3VtKSB7XHJcbiAgICAgICAgc3VwZXIobG9jYWxlKTtcclxuICAgICAgICB0aGlzLiNkYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLiNjaGVja3N1bSA9IGNoZWNrc3VtO1xyXG4gICAgICAgIHRoaXMuI3dvcmRzID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBPV0wtZW5jb2RlZCBkYXRhLlxyXG4gICAgICovXHJcbiAgICBnZXQgX2RhdGEoKSB7IHJldHVybiB0aGlzLiNkYXRhOyB9XHJcbiAgICAvKipcclxuICAgICAqICBEZWNvZGUgYWxsIHRoZSB3b3JkcyBmb3IgdGhlIHdvcmRsaXN0LlxyXG4gICAgICovXHJcbiAgICBfZGVjb2RlV29yZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlY29kZU93bCh0aGlzLiNkYXRhKTtcclxuICAgIH1cclxuICAgICN3b3JkcztcclxuICAgICNsb2FkV29yZHMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuI3dvcmRzID09IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3Qgd29yZHMgPSB0aGlzLl9kZWNvZGVXb3JkcygpO1xyXG4gICAgICAgICAgICAvLyBWZXJpZnkgdGhlIGNvbXB1dGVkIGxpc3QgbWF0Y2hlcyB0aGUgb2ZmaWNpYWwgbGlzdFxyXG4gICAgICAgICAgICBjb25zdCBjaGVja3N1bSA9IGlkKHdvcmRzLmpvaW4oXCJcXG5cIikgKyBcIlxcblwiKTtcclxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXHJcbiAgICAgICAgICAgIGlmIChjaGVja3N1bSAhPT0gdGhpcy4jY2hlY2tzdW0pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQklQMzkgV29yZGxpc3QgZm9yICR7dGhpcy5sb2NhbGV9IEZBSUxFRGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXHJcbiAgICAgICAgICAgIHRoaXMuI3dvcmRzID0gd29yZHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLiN3b3JkcztcclxuICAgIH1cclxuICAgIGdldFdvcmQoaW5kZXgpIHtcclxuICAgICAgICBjb25zdCB3b3JkcyA9IHRoaXMuI2xvYWRXb3JkcygpO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGluZGV4ID49IDAgJiYgaW5kZXggPCB3b3Jkcy5sZW5ndGgsIGBpbnZhbGlkIHdvcmQgaW5kZXg6ICR7aW5kZXh9YCwgXCJpbmRleFwiLCBpbmRleCk7XHJcbiAgICAgICAgcmV0dXJuIHdvcmRzW2luZGV4XTtcclxuICAgIH1cclxuICAgIGdldFdvcmRJbmRleCh3b3JkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI2xvYWRXb3JkcygpLmluZGV4T2Yod29yZCk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29yZGxpc3Qtb3dsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/wordlist-owl.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/wordlist-owla.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/wordlists/wordlist-owla.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WordlistOwlA: () => (/* binding */ WordlistOwlA)\n/* harmony export */ });\n/* harmony import */ var _wordlist_owl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wordlist-owl.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/wordlist-owl.js\");\n/* harmony import */ var _decode_owla_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decode-owla.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/decode-owla.js\");\n\r\n\r\n/**\r\n *  An OWL-A format Wordlist extends the OWL format to add an\r\n *  overlay onto an OWL format Wordlist to support diacritic\r\n *  marks.\r\n *\r\n *  This class is generally not useful to most developers as\r\n *  it is used mainly internally to keep Wordlists for languages\r\n *  based on latin-1 small.\r\n *\r\n *  If necessary, there are tools within the ``generation/`` folder\r\n *  to create the necessary data.\r\n */\r\nclass WordlistOwlA extends _wordlist_owl_js__WEBPACK_IMPORTED_MODULE_0__.WordlistOwl {\r\n    #accent;\r\n    /**\r\n     *  Creates a new Wordlist for %%locale%% using the OWLA %%data%%\r\n     *  and %%accent%% data and validated against the %%checksum%%.\r\n     */\r\n    constructor(locale, data, accent, checksum) {\r\n        super(locale, data, checksum);\r\n        this.#accent = accent;\r\n    }\r\n    /**\r\n     *  The OWLA-encoded accent data.\r\n     */\r\n    get _accent() { return this.#accent; }\r\n    /**\r\n     *  Decode all the words for the wordlist.\r\n     */\r\n    _decodeWords() {\r\n        return (0,_decode_owla_js__WEBPACK_IMPORTED_MODULE_1__.decodeOwlA)(this._data, this._accent);\r\n    }\r\n}\r\n//# sourceMappingURL=wordlist-owla.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvd29yZGxpc3Qtb3dsYS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0Q7QUFDRjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQkFBMkIseURBQVc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyREFBVTtBQUN6QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXGV0aGVyc1xcbGliLmVzbVxcd29yZGxpc3RzXFx3b3JkbGlzdC1vd2xhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdvcmRsaXN0T3dsIH0gZnJvbSBcIi4vd29yZGxpc3Qtb3dsLmpzXCI7XHJcbmltcG9ydCB7IGRlY29kZU93bEEgfSBmcm9tIFwiLi9kZWNvZGUtb3dsYS5qc1wiO1xyXG4vKipcclxuICogIEFuIE9XTC1BIGZvcm1hdCBXb3JkbGlzdCBleHRlbmRzIHRoZSBPV0wgZm9ybWF0IHRvIGFkZCBhblxyXG4gKiAgb3ZlcmxheSBvbnRvIGFuIE9XTCBmb3JtYXQgV29yZGxpc3QgdG8gc3VwcG9ydCBkaWFjcml0aWNcclxuICogIG1hcmtzLlxyXG4gKlxyXG4gKiAgVGhpcyBjbGFzcyBpcyBnZW5lcmFsbHkgbm90IHVzZWZ1bCB0byBtb3N0IGRldmVsb3BlcnMgYXNcclxuICogIGl0IGlzIHVzZWQgbWFpbmx5IGludGVybmFsbHkgdG8ga2VlcCBXb3JkbGlzdHMgZm9yIGxhbmd1YWdlc1xyXG4gKiAgYmFzZWQgb24gbGF0aW4tMSBzbWFsbC5cclxuICpcclxuICogIElmIG5lY2Vzc2FyeSwgdGhlcmUgYXJlIHRvb2xzIHdpdGhpbiB0aGUgYGBnZW5lcmF0aW9uL2BgIGZvbGRlclxyXG4gKiAgdG8gY3JlYXRlIHRoZSBuZWNlc3NhcnkgZGF0YS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBXb3JkbGlzdE93bEEgZXh0ZW5kcyBXb3JkbGlzdE93bCB7XHJcbiAgICAjYWNjZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBXb3JkbGlzdCBmb3IgJSVsb2NhbGUlJSB1c2luZyB0aGUgT1dMQSAlJWRhdGElJVxyXG4gICAgICogIGFuZCAlJWFjY2VudCUlIGRhdGEgYW5kIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSAlJWNoZWNrc3VtJSUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvY2FsZSwgZGF0YSwgYWNjZW50LCBjaGVja3N1bSkge1xyXG4gICAgICAgIHN1cGVyKGxvY2FsZSwgZGF0YSwgY2hlY2tzdW0pO1xyXG4gICAgICAgIHRoaXMuI2FjY2VudCA9IGFjY2VudDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBPV0xBLWVuY29kZWQgYWNjZW50IGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGdldCBfYWNjZW50KCkgeyByZXR1cm4gdGhpcy4jYWNjZW50OyB9XHJcbiAgICAvKipcclxuICAgICAqICBEZWNvZGUgYWxsIHRoZSB3b3JkcyBmb3IgdGhlIHdvcmRsaXN0LlxyXG4gICAgICovXHJcbiAgICBfZGVjb2RlV29yZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlY29kZU93bEEodGhpcy5fZGF0YSwgdGhpcy5fYWNjZW50KTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JkbGlzdC1vd2xhLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/wordlist-owla.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/wordlist.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/wordlists/wordlist.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Wordlist: () => (/* binding */ Wordlist)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/utils/index.js\");\n\r\n/**\r\n *  A Wordlist represents a collection of language-specific\r\n *  words used to encode and devoce [[link-bip-39]] encoded data\r\n *  by mapping words to 11-bit values and vice versa.\r\n */\r\nclass Wordlist {\r\n    locale;\r\n    /**\r\n     *  Creates a new Wordlist instance.\r\n     *\r\n     *  Sub-classes MUST call this if they provide their own constructor,\r\n     *  passing in the locale string of the language.\r\n     *\r\n     *  Generally there is no need to create instances of a Wordlist,\r\n     *  since each language-specific Wordlist creates an instance and\r\n     *  there is no state kept internally, so they are safe to share.\r\n     */\r\n    constructor(locale) {\r\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { locale });\r\n    }\r\n    /**\r\n     *  Sub-classes may override this to provide a language-specific\r\n     *  method for spliting %%phrase%% into individual words.\r\n     *\r\n     *  By default, %%phrase%% is split using any sequences of\r\n     *  white-space as defined by regular expressions (i.e. ``/\\s+/``).\r\n     */\r\n    split(phrase) {\r\n        return phrase.toLowerCase().split(/\\s+/g);\r\n    }\r\n    /**\r\n     *  Sub-classes may override this to provider a language-specific\r\n     *  method for joining %%words%% into a phrase.\r\n     *\r\n     *  By default, %%words%% are joined by a single space.\r\n     */\r\n    join(words) {\r\n        return words.join(\" \");\r\n    }\r\n}\r\n//# sourceMappingURL=wordlist.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvd29yZGxpc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0IsU0FBUyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxldGhlcnNcXGxpYi5lc21cXHdvcmRsaXN0c1xcd29yZGxpc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG4vKipcclxuICogIEEgV29yZGxpc3QgcmVwcmVzZW50cyBhIGNvbGxlY3Rpb24gb2YgbGFuZ3VhZ2Utc3BlY2lmaWNcclxuICogIHdvcmRzIHVzZWQgdG8gZW5jb2RlIGFuZCBkZXZvY2UgW1tsaW5rLWJpcC0zOV1dIGVuY29kZWQgZGF0YVxyXG4gKiAgYnkgbWFwcGluZyB3b3JkcyB0byAxMS1iaXQgdmFsdWVzIGFuZCB2aWNlIHZlcnNhLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFdvcmRsaXN0IHtcclxuICAgIGxvY2FsZTtcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgV29yZGxpc3QgaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogIFN1Yi1jbGFzc2VzIE1VU1QgY2FsbCB0aGlzIGlmIHRoZXkgcHJvdmlkZSB0aGVpciBvd24gY29uc3RydWN0b3IsXHJcbiAgICAgKiAgcGFzc2luZyBpbiB0aGUgbG9jYWxlIHN0cmluZyBvZiB0aGUgbGFuZ3VhZ2UuXHJcbiAgICAgKlxyXG4gICAgICogIEdlbmVyYWxseSB0aGVyZSBpcyBubyBuZWVkIHRvIGNyZWF0ZSBpbnN0YW5jZXMgb2YgYSBXb3JkbGlzdCxcclxuICAgICAqICBzaW5jZSBlYWNoIGxhbmd1YWdlLXNwZWNpZmljIFdvcmRsaXN0IGNyZWF0ZXMgYW4gaW5zdGFuY2UgYW5kXHJcbiAgICAgKiAgdGhlcmUgaXMgbm8gc3RhdGUga2VwdCBpbnRlcm5hbGx5LCBzbyB0aGV5IGFyZSBzYWZlIHRvIHNoYXJlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGUpIHtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbG9jYWxlIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gcHJvdmlkZSBhIGxhbmd1YWdlLXNwZWNpZmljXHJcbiAgICAgKiAgbWV0aG9kIGZvciBzcGxpdGluZyAlJXBocmFzZSUlIGludG8gaW5kaXZpZHVhbCB3b3Jkcy5cclxuICAgICAqXHJcbiAgICAgKiAgQnkgZGVmYXVsdCwgJSVwaHJhc2UlJSBpcyBzcGxpdCB1c2luZyBhbnkgc2VxdWVuY2VzIG9mXHJcbiAgICAgKiAgd2hpdGUtc3BhY2UgYXMgZGVmaW5lZCBieSByZWd1bGFyIGV4cHJlc3Npb25zIChpLmUuIGBgL1xccysvYGApLlxyXG4gICAgICovXHJcbiAgICBzcGxpdChwaHJhc2UpIHtcclxuICAgICAgICByZXR1cm4gcGhyYXNlLnRvTG93ZXJDYXNlKCkuc3BsaXQoL1xccysvZyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyB0byBwcm92aWRlciBhIGxhbmd1YWdlLXNwZWNpZmljXHJcbiAgICAgKiAgbWV0aG9kIGZvciBqb2luaW5nICUld29yZHMlJSBpbnRvIGEgcGhyYXNlLlxyXG4gICAgICpcclxuICAgICAqICBCeSBkZWZhdWx0LCAlJXdvcmRzJSUgYXJlIGpvaW5lZCBieSBhIHNpbmdsZSBzcGFjZS5cclxuICAgICAqL1xyXG4gICAgam9pbih3b3Jkcykge1xyXG4gICAgICAgIHJldHVybiB3b3Jkcy5qb2luKFwiIFwiKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JkbGlzdC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/wordlist.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/wordlists-browser.js":
/*!********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/wordlists/wordlists-browser.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   wordlists: () => (/* binding */ wordlists)\n/* harmony export */ });\n/* harmony import */ var _lang_en_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lang-en.js */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/lang-en.js\");\n\r\nconst wordlists = {\r\n    en: _lang_en_js__WEBPACK_IMPORTED_MODULE_0__.LangEn.wordlist(),\r\n};\r\n//# sourceMappingURL=wordlists-browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvd29yZGxpc3RzLWJyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0M7QUFDL0I7QUFDUCxRQUFRLCtDQUFNO0FBQ2Q7QUFDQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xcZXRoZXJzXFxsaWIuZXNtXFx3b3JkbGlzdHNcXHdvcmRsaXN0cy1icm93c2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExhbmdFbiB9IGZyb20gXCIuL2xhbmctZW4uanNcIjtcclxuZXhwb3J0IGNvbnN0IHdvcmRsaXN0cyA9IHtcclxuICAgIGVuOiBMYW5nRW4ud29yZGxpc3QoKSxcclxufTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29yZGxpc3RzLWJyb3dzZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ethers/lib.esm/wordlists/wordlists-browser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[11].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[11].use[2]!./node_modules/react-toastify/dist/ReactToastify.css":
/*!******************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[11].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[11].use[2]!./node_modules/react-toastify/dist/ReactToastify.css ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \":root {\\r\\n  --toastify-color-light: #fff;\\r\\n  --toastify-color-dark: #121212;\\r\\n  --toastify-color-info: #3498db;\\r\\n  --toastify-color-success: #07bc0c;\\r\\n  --toastify-color-warning: #f1c40f;\\r\\n  --toastify-color-error: #e74c3c;\\r\\n  --toastify-color-transparent: rgba(255, 255, 255, 0.7);\\r\\n  --toastify-icon-color-info: var(--toastify-color-info);\\r\\n  --toastify-icon-color-success: var(--toastify-color-success);\\r\\n  --toastify-icon-color-warning: var(--toastify-color-warning);\\r\\n  --toastify-icon-color-error: var(--toastify-color-error);\\r\\n  --toastify-toast-width: 320px;\\r\\n  --toastify-toast-background: #fff;\\r\\n  --toastify-toast-min-height: 64px;\\r\\n  --toastify-toast-max-height: 800px;\\r\\n  --toastify-font-family: sans-serif;\\r\\n  --toastify-z-index: 9999;\\r\\n  --toastify-text-color-light: #757575;\\r\\n  --toastify-text-color-dark: #fff;\\r\\n  --toastify-text-color-info: #fff;\\r\\n  --toastify-text-color-success: #fff;\\r\\n  --toastify-text-color-warning: #fff;\\r\\n  --toastify-text-color-error: #fff;\\r\\n  --toastify-spinner-color: #616161;\\r\\n  --toastify-spinner-color-empty-area: #e0e0e0;\\r\\n  --toastify-color-progress-light: linear-gradient(\\r\\n    to right,\\r\\n    #4cd964,\\r\\n    #5ac8fa,\\r\\n    #007aff,\\r\\n    #34aadc,\\r\\n    #5856d6,\\r\\n    #ff2d55\\r\\n  );\\r\\n  --toastify-color-progress-dark: #bb86fc;\\r\\n  --toastify-color-progress-info: var(--toastify-color-info);\\r\\n  --toastify-color-progress-success: var(--toastify-color-success);\\r\\n  --toastify-color-progress-warning: var(--toastify-color-warning);\\r\\n  --toastify-color-progress-error: var(--toastify-color-error);\\r\\n}\\r\\n\\r\\n.Toastify__toast-container {\\r\\n  z-index: var(--toastify-z-index);\\r\\n  -webkit-transform: translate3d(0, 0, var(--toastify-z-index));\\r\\n  position: fixed;\\r\\n  padding: 4px;\\r\\n  width: var(--toastify-toast-width);\\r\\n  box-sizing: border-box;\\r\\n  color: #fff;\\r\\n}\\r\\n.Toastify__toast-container--top-left {\\r\\n  top: 1em;\\r\\n  left: 1em;\\r\\n}\\r\\n.Toastify__toast-container--top-center {\\r\\n  top: 1em;\\r\\n  left: 50%;\\r\\n  transform: translateX(-50%);\\r\\n}\\r\\n.Toastify__toast-container--top-right {\\r\\n  top: 1em;\\r\\n  right: 1em;\\r\\n}\\r\\n.Toastify__toast-container--bottom-left {\\r\\n  bottom: 1em;\\r\\n  left: 1em;\\r\\n}\\r\\n.Toastify__toast-container--bottom-center {\\r\\n  bottom: 1em;\\r\\n  left: 50%;\\r\\n  transform: translateX(-50%);\\r\\n}\\r\\n.Toastify__toast-container--bottom-right {\\r\\n  bottom: 1em;\\r\\n  right: 1em;\\r\\n}\\r\\n\\r\\n@media only screen and (max-width : 480px) {\\r\\n  .Toastify__toast-container {\\r\\n    width: 100vw;\\r\\n    padding: 0;\\r\\n    left: 0;\\r\\n    margin: 0;\\r\\n  }\\r\\n  .Toastify__toast-container--top-left, .Toastify__toast-container--top-center, .Toastify__toast-container--top-right {\\r\\n    top: 0;\\r\\n    transform: translateX(0);\\r\\n  }\\r\\n  .Toastify__toast-container--bottom-left, .Toastify__toast-container--bottom-center, .Toastify__toast-container--bottom-right {\\r\\n    bottom: 0;\\r\\n    transform: translateX(0);\\r\\n  }\\r\\n  .Toastify__toast-container--rtl {\\r\\n    right: 0;\\r\\n    left: initial;\\r\\n  }\\r\\n}\\r\\n.Toastify__toast {\\r\\n  position: relative;\\r\\n  min-height: var(--toastify-toast-min-height);\\r\\n  box-sizing: border-box;\\r\\n  margin-bottom: 1rem;\\r\\n  padding: 8px;\\r\\n  border-radius: 4px;\\r\\n  box-shadow: 0 1px 10px 0 rgba(0, 0, 0, 0.1), 0 2px 15px 0 rgba(0, 0, 0, 0.05);\\r\\n  display: flex;\\r\\n  justify-content: space-between;\\r\\n  max-height: var(--toastify-toast-max-height);\\r\\n  overflow: hidden;\\r\\n  font-family: var(--toastify-font-family);\\r\\n  cursor: default;\\r\\n  direction: ltr;\\r\\n  /* webkit only issue #791 */\\r\\n  z-index: 0;\\r\\n}\\r\\n.Toastify__toast--rtl {\\r\\n  direction: rtl;\\r\\n}\\r\\n.Toastify__toast--close-on-click {\\r\\n  cursor: pointer;\\r\\n}\\r\\n.Toastify__toast-body {\\r\\n  margin: auto 0;\\r\\n  flex: 1 1 auto;\\r\\n  padding: 6px;\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n}\\r\\n.Toastify__toast-body > div:last-child {\\r\\n  word-break: break-word;\\r\\n  flex: 1;\\r\\n}\\r\\n.Toastify__toast-icon {\\r\\n  margin-inline-end: 10px;\\r\\n  width: 20px;\\r\\n  flex-shrink: 0;\\r\\n  display: flex;\\r\\n}\\r\\n\\r\\n.Toastify--animate {\\r\\n  animation-fill-mode: both;\\r\\n  animation-duration: 0.7s;\\r\\n}\\r\\n\\r\\n.Toastify--animate-icon {\\r\\n  animation-fill-mode: both;\\r\\n  animation-duration: 0.3s;\\r\\n}\\r\\n\\r\\n@media only screen and (max-width : 480px) {\\r\\n  .Toastify__toast {\\r\\n    margin-bottom: 0;\\r\\n    border-radius: 0;\\r\\n  }\\r\\n}\\r\\n.Toastify__toast-theme--dark {\\r\\n  background: var(--toastify-color-dark);\\r\\n  color: var(--toastify-text-color-dark);\\r\\n}\\r\\n.Toastify__toast-theme--light {\\r\\n  background: var(--toastify-color-light);\\r\\n  color: var(--toastify-text-color-light);\\r\\n}\\r\\n.Toastify__toast-theme--colored.Toastify__toast--default {\\r\\n  background: var(--toastify-color-light);\\r\\n  color: var(--toastify-text-color-light);\\r\\n}\\r\\n.Toastify__toast-theme--colored.Toastify__toast--info {\\r\\n  color: var(--toastify-text-color-info);\\r\\n  background: var(--toastify-color-info);\\r\\n}\\r\\n.Toastify__toast-theme--colored.Toastify__toast--success {\\r\\n  color: var(--toastify-text-color-success);\\r\\n  background: var(--toastify-color-success);\\r\\n}\\r\\n.Toastify__toast-theme--colored.Toastify__toast--warning {\\r\\n  color: var(--toastify-text-color-warning);\\r\\n  background: var(--toastify-color-warning);\\r\\n}\\r\\n.Toastify__toast-theme--colored.Toastify__toast--error {\\r\\n  color: var(--toastify-text-color-error);\\r\\n  background: var(--toastify-color-error);\\r\\n}\\r\\n\\r\\n.Toastify__progress-bar-theme--light {\\r\\n  background: var(--toastify-color-progress-light);\\r\\n}\\r\\n.Toastify__progress-bar-theme--dark {\\r\\n  background: var(--toastify-color-progress-dark);\\r\\n}\\r\\n.Toastify__progress-bar--info {\\r\\n  background: var(--toastify-color-progress-info);\\r\\n}\\r\\n.Toastify__progress-bar--success {\\r\\n  background: var(--toastify-color-progress-success);\\r\\n}\\r\\n.Toastify__progress-bar--warning {\\r\\n  background: var(--toastify-color-progress-warning);\\r\\n}\\r\\n.Toastify__progress-bar--error {\\r\\n  background: var(--toastify-color-progress-error);\\r\\n}\\r\\n.Toastify__progress-bar-theme--colored.Toastify__progress-bar--info, .Toastify__progress-bar-theme--colored.Toastify__progress-bar--success, .Toastify__progress-bar-theme--colored.Toastify__progress-bar--warning, .Toastify__progress-bar-theme--colored.Toastify__progress-bar--error {\\r\\n  background: var(--toastify-color-transparent);\\r\\n}\\r\\n\\r\\n.Toastify__close-button {\\r\\n  color: #fff;\\r\\n  background: transparent;\\r\\n  outline: none;\\r\\n  border: none;\\r\\n  padding: 0;\\r\\n  cursor: pointer;\\r\\n  opacity: 0.7;\\r\\n  transition: 0.3s ease;\\r\\n  align-self: flex-start;\\r\\n}\\r\\n.Toastify__close-button--light {\\r\\n  color: #000;\\r\\n  opacity: 0.3;\\r\\n}\\r\\n.Toastify__close-button > svg {\\r\\n  fill: currentColor;\\r\\n  height: 16px;\\r\\n  width: 14px;\\r\\n}\\r\\n.Toastify__close-button:hover, .Toastify__close-button:focus {\\r\\n  opacity: 1;\\r\\n}\\r\\n\\r\\n@keyframes Toastify__trackProgress {\\r\\n  0% {\\r\\n    transform: scaleX(1);\\r\\n  }\\r\\n  100% {\\r\\n    transform: scaleX(0);\\r\\n  }\\r\\n}\\r\\n.Toastify__progress-bar {\\r\\n  position: absolute;\\r\\n  bottom: 0;\\r\\n  left: 0;\\r\\n  width: 100%;\\r\\n  height: 5px;\\r\\n  z-index: var(--toastify-z-index);\\r\\n  opacity: 0.7;\\r\\n  transform-origin: left;\\r\\n}\\r\\n.Toastify__progress-bar--animated {\\r\\n  animation: Toastify__trackProgress linear 1 forwards;\\r\\n}\\r\\n.Toastify__progress-bar--controlled {\\r\\n  transition: transform 0.2s;\\r\\n}\\r\\n.Toastify__progress-bar--rtl {\\r\\n  right: 0;\\r\\n  left: initial;\\r\\n  transform-origin: right;\\r\\n}\\r\\n\\r\\n.Toastify__spinner {\\r\\n  width: 20px;\\r\\n  height: 20px;\\r\\n  box-sizing: border-box;\\r\\n  border: 2px solid;\\r\\n  border-radius: 100%;\\r\\n  border-color: var(--toastify-spinner-color-empty-area);\\r\\n  border-right-color: var(--toastify-spinner-color);\\r\\n  animation: Toastify__spin 0.65s linear infinite;\\r\\n}\\r\\n\\r\\n@keyframes Toastify__bounceInRight {\\r\\n  from, 60%, 75%, 90%, to {\\r\\n    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);\\r\\n  }\\r\\n  from {\\r\\n    opacity: 0;\\r\\n    transform: translate3d(3000px, 0, 0);\\r\\n  }\\r\\n  60% {\\r\\n    opacity: 1;\\r\\n    transform: translate3d(-25px, 0, 0);\\r\\n  }\\r\\n  75% {\\r\\n    transform: translate3d(10px, 0, 0);\\r\\n  }\\r\\n  90% {\\r\\n    transform: translate3d(-5px, 0, 0);\\r\\n  }\\r\\n  to {\\r\\n    transform: none;\\r\\n  }\\r\\n}\\r\\n@keyframes Toastify__bounceOutRight {\\r\\n  20% {\\r\\n    opacity: 1;\\r\\n    transform: translate3d(-20px, 0, 0);\\r\\n  }\\r\\n  to {\\r\\n    opacity: 0;\\r\\n    transform: translate3d(2000px, 0, 0);\\r\\n  }\\r\\n}\\r\\n@keyframes Toastify__bounceInLeft {\\r\\n  from, 60%, 75%, 90%, to {\\r\\n    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);\\r\\n  }\\r\\n  0% {\\r\\n    opacity: 0;\\r\\n    transform: translate3d(-3000px, 0, 0);\\r\\n  }\\r\\n  60% {\\r\\n    opacity: 1;\\r\\n    transform: translate3d(25px, 0, 0);\\r\\n  }\\r\\n  75% {\\r\\n    transform: translate3d(-10px, 0, 0);\\r\\n  }\\r\\n  90% {\\r\\n    transform: translate3d(5px, 0, 0);\\r\\n  }\\r\\n  to {\\r\\n    transform: none;\\r\\n  }\\r\\n}\\r\\n@keyframes Toastify__bounceOutLeft {\\r\\n  20% {\\r\\n    opacity: 1;\\r\\n    transform: translate3d(20px, 0, 0);\\r\\n  }\\r\\n  to {\\r\\n    opacity: 0;\\r\\n    transform: translate3d(-2000px, 0, 0);\\r\\n  }\\r\\n}\\r\\n@keyframes Toastify__bounceInUp {\\r\\n  from, 60%, 75%, 90%, to {\\r\\n    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);\\r\\n  }\\r\\n  from {\\r\\n    opacity: 0;\\r\\n    transform: translate3d(0, 3000px, 0);\\r\\n  }\\r\\n  60% {\\r\\n    opacity: 1;\\r\\n    transform: translate3d(0, -20px, 0);\\r\\n  }\\r\\n  75% {\\r\\n    transform: translate3d(0, 10px, 0);\\r\\n  }\\r\\n  90% {\\r\\n    transform: translate3d(0, -5px, 0);\\r\\n  }\\r\\n  to {\\r\\n    transform: translate3d(0, 0, 0);\\r\\n  }\\r\\n}\\r\\n@keyframes Toastify__bounceOutUp {\\r\\n  20% {\\r\\n    transform: translate3d(0, -10px, 0);\\r\\n  }\\r\\n  40%, 45% {\\r\\n    opacity: 1;\\r\\n    transform: translate3d(0, 20px, 0);\\r\\n  }\\r\\n  to {\\r\\n    opacity: 0;\\r\\n    transform: translate3d(0, -2000px, 0);\\r\\n  }\\r\\n}\\r\\n@keyframes Toastify__bounceInDown {\\r\\n  from, 60%, 75%, 90%, to {\\r\\n    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);\\r\\n  }\\r\\n  0% {\\r\\n    opacity: 0;\\r\\n    transform: translate3d(0, -3000px, 0);\\r\\n  }\\r\\n  60% {\\r\\n    opacity: 1;\\r\\n    transform: translate3d(0, 25px, 0);\\r\\n  }\\r\\n  75% {\\r\\n    transform: translate3d(0, -10px, 0);\\r\\n  }\\r\\n  90% {\\r\\n    transform: translate3d(0, 5px, 0);\\r\\n  }\\r\\n  to {\\r\\n    transform: none;\\r\\n  }\\r\\n}\\r\\n@keyframes Toastify__bounceOutDown {\\r\\n  20% {\\r\\n    transform: translate3d(0, 10px, 0);\\r\\n  }\\r\\n  40%, 45% {\\r\\n    opacity: 1;\\r\\n    transform: translate3d(0, -20px, 0);\\r\\n  }\\r\\n  to {\\r\\n    opacity: 0;\\r\\n    transform: translate3d(0, 2000px, 0);\\r\\n  }\\r\\n}\\r\\n.Toastify__bounce-enter--top-left, .Toastify__bounce-enter--bottom-left {\\r\\n  animation-name: Toastify__bounceInLeft;\\r\\n}\\r\\n.Toastify__bounce-enter--top-right, .Toastify__bounce-enter--bottom-right {\\r\\n  animation-name: Toastify__bounceInRight;\\r\\n}\\r\\n.Toastify__bounce-enter--top-center {\\r\\n  animation-name: Toastify__bounceInDown;\\r\\n}\\r\\n.Toastify__bounce-enter--bottom-center {\\r\\n  animation-name: Toastify__bounceInUp;\\r\\n}\\r\\n\\r\\n.Toastify__bounce-exit--top-left, .Toastify__bounce-exit--bottom-left {\\r\\n  animation-name: Toastify__bounceOutLeft;\\r\\n}\\r\\n.Toastify__bounce-exit--top-right, .Toastify__bounce-exit--bottom-right {\\r\\n  animation-name: Toastify__bounceOutRight;\\r\\n}\\r\\n.Toastify__bounce-exit--top-center {\\r\\n  animation-name: Toastify__bounceOutUp;\\r\\n}\\r\\n.Toastify__bounce-exit--bottom-center {\\r\\n  animation-name: Toastify__bounceOutDown;\\r\\n}\\r\\n\\r\\n@keyframes Toastify__zoomIn {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n    transform: scale3d(0.3, 0.3, 0.3);\\r\\n  }\\r\\n  50% {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n@keyframes Toastify__zoomOut {\\r\\n  from {\\r\\n    opacity: 1;\\r\\n  }\\r\\n  50% {\\r\\n    opacity: 0;\\r\\n    transform: scale3d(0.3, 0.3, 0.3);\\r\\n  }\\r\\n  to {\\r\\n    opacity: 0;\\r\\n  }\\r\\n}\\r\\n.Toastify__zoom-enter {\\r\\n  animation-name: Toastify__zoomIn;\\r\\n}\\r\\n\\r\\n.Toastify__zoom-exit {\\r\\n  animation-name: Toastify__zoomOut;\\r\\n}\\r\\n\\r\\n@keyframes Toastify__flipIn {\\r\\n  from {\\r\\n    transform: perspective(400px) rotate3d(1, 0, 0, 90deg);\\r\\n    animation-timing-function: ease-in;\\r\\n    opacity: 0;\\r\\n  }\\r\\n  40% {\\r\\n    transform: perspective(400px) rotate3d(1, 0, 0, -20deg);\\r\\n    animation-timing-function: ease-in;\\r\\n  }\\r\\n  60% {\\r\\n    transform: perspective(400px) rotate3d(1, 0, 0, 10deg);\\r\\n    opacity: 1;\\r\\n  }\\r\\n  80% {\\r\\n    transform: perspective(400px) rotate3d(1, 0, 0, -5deg);\\r\\n  }\\r\\n  to {\\r\\n    transform: perspective(400px);\\r\\n  }\\r\\n}\\r\\n@keyframes Toastify__flipOut {\\r\\n  from {\\r\\n    transform: perspective(400px);\\r\\n  }\\r\\n  30% {\\r\\n    transform: perspective(400px) rotate3d(1, 0, 0, -20deg);\\r\\n    opacity: 1;\\r\\n  }\\r\\n  to {\\r\\n    transform: perspective(400px) rotate3d(1, 0, 0, 90deg);\\r\\n    opacity: 0;\\r\\n  }\\r\\n}\\r\\n.Toastify__flip-enter {\\r\\n  animation-name: Toastify__flipIn;\\r\\n}\\r\\n\\r\\n.Toastify__flip-exit {\\r\\n  animation-name: Toastify__flipOut;\\r\\n}\\r\\n\\r\\n@keyframes Toastify__slideInRight {\\r\\n  from {\\r\\n    transform: translate3d(110%, 0, 0);\\r\\n    visibility: visible;\\r\\n  }\\r\\n  to {\\r\\n    transform: translate3d(0, 0, 0);\\r\\n  }\\r\\n}\\r\\n@keyframes Toastify__slideInLeft {\\r\\n  from {\\r\\n    transform: translate3d(-110%, 0, 0);\\r\\n    visibility: visible;\\r\\n  }\\r\\n  to {\\r\\n    transform: translate3d(0, 0, 0);\\r\\n  }\\r\\n}\\r\\n@keyframes Toastify__slideInUp {\\r\\n  from {\\r\\n    transform: translate3d(0, 110%, 0);\\r\\n    visibility: visible;\\r\\n  }\\r\\n  to {\\r\\n    transform: translate3d(0, 0, 0);\\r\\n  }\\r\\n}\\r\\n@keyframes Toastify__slideInDown {\\r\\n  from {\\r\\n    transform: translate3d(0, -110%, 0);\\r\\n    visibility: visible;\\r\\n  }\\r\\n  to {\\r\\n    transform: translate3d(0, 0, 0);\\r\\n  }\\r\\n}\\r\\n@keyframes Toastify__slideOutRight {\\r\\n  from {\\r\\n    transform: translate3d(0, 0, 0);\\r\\n  }\\r\\n  to {\\r\\n    visibility: hidden;\\r\\n    transform: translate3d(110%, 0, 0);\\r\\n  }\\r\\n}\\r\\n@keyframes Toastify__slideOutLeft {\\r\\n  from {\\r\\n    transform: translate3d(0, 0, 0);\\r\\n  }\\r\\n  to {\\r\\n    visibility: hidden;\\r\\n    transform: translate3d(-110%, 0, 0);\\r\\n  }\\r\\n}\\r\\n@keyframes Toastify__slideOutDown {\\r\\n  from {\\r\\n    transform: translate3d(0, 0, 0);\\r\\n  }\\r\\n  to {\\r\\n    visibility: hidden;\\r\\n    transform: translate3d(0, 500px, 0);\\r\\n  }\\r\\n}\\r\\n@keyframes Toastify__slideOutUp {\\r\\n  from {\\r\\n    transform: translate3d(0, 0, 0);\\r\\n  }\\r\\n  to {\\r\\n    visibility: hidden;\\r\\n    transform: translate3d(0, -500px, 0);\\r\\n  }\\r\\n}\\r\\n.Toastify__slide-enter--top-left, .Toastify__slide-enter--bottom-left {\\r\\n  animation-name: Toastify__slideInLeft;\\r\\n}\\r\\n.Toastify__slide-enter--top-right, .Toastify__slide-enter--bottom-right {\\r\\n  animation-name: Toastify__slideInRight;\\r\\n}\\r\\n.Toastify__slide-enter--top-center {\\r\\n  animation-name: Toastify__slideInDown;\\r\\n}\\r\\n.Toastify__slide-enter--bottom-center {\\r\\n  animation-name: Toastify__slideInUp;\\r\\n}\\r\\n\\r\\n.Toastify__slide-exit--top-left, .Toastify__slide-exit--bottom-left {\\r\\n  animation-name: Toastify__slideOutLeft;\\r\\n}\\r\\n.Toastify__slide-exit--top-right, .Toastify__slide-exit--bottom-right {\\r\\n  animation-name: Toastify__slideOutRight;\\r\\n}\\r\\n.Toastify__slide-exit--top-center {\\r\\n  animation-name: Toastify__slideOutUp;\\r\\n}\\r\\n.Toastify__slide-exit--bottom-center {\\r\\n  animation-name: Toastify__slideOutDown;\\r\\n}\\r\\n\\r\\n@keyframes Toastify__spin {\\r\\n  from {\\r\\n    transform: rotate(0deg);\\r\\n  }\\r\\n  to {\\r\\n    transform: rotate(360deg);\\r\\n  }\\r\\n}\\r\\n\\r\\n/*# sourceMappingURL=ReactToastify.css.map */\", \"\",{\"version\":3,\"sources\":[\"webpack://node_modules/react-toastify/scss/_variables.scss\",\"webpack://node_modules/react-toastify/dist/ReactToastify.css\",\"webpack://node_modules/react-toastify/scss/_toastContainer.scss\",\"webpack://node_modules/react-toastify/scss/_toast.scss\",\"webpack://node_modules/react-toastify/scss/_theme.scss\",\"webpack://node_modules/react-toastify/scss/_closeButton.scss\",\"webpack://node_modules/react-toastify/scss/_progressBar.scss\",\"webpack://node_modules/react-toastify/scss/_icons.scss\",\"webpack://node_modules/react-toastify/scss/animations/_bounce.scss\",\"webpack://node_modules/react-toastify/scss/animations/_zoom.scss\",\"webpack://node_modules/react-toastify/scss/animations/_flip.scss\",\"webpack://node_modules/react-toastify/scss/animations/_slide.scss\",\"webpack://node_modules/react-toastify/scss/animations/_spin.scss\"],\"names\":[],\"mappings\":\"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\",\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzhdLm9uZU9mWzExXS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbOF0ub25lT2ZbMTFdLnVzZVsyXSEuL25vZGVfbW9kdWxlcy9yZWFjdC10b2FzdGlmeS9kaXN0L1JlYWN0VG9hc3RpZnkuY3NzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQzhHO0FBQzlHLDhCQUE4QixxR0FBMkI7QUFDekQ7QUFDQSxpREFBaUQsbUNBQW1DLHFDQUFxQyxxQ0FBcUMsd0NBQXdDLHdDQUF3QyxzQ0FBc0MsNkRBQTZELDZEQUE2RCxtRUFBbUUsbUVBQW1FLCtEQUErRCxvQ0FBb0Msd0NBQXdDLHdDQUF3Qyx5Q0FBeUMseUNBQXlDLCtCQUErQiwyQ0FBMkMsdUNBQXVDLHVDQUF1QywwQ0FBMEMsMENBQTBDLHdDQUF3Qyx3Q0FBd0MsbURBQW1ELCtLQUErSyw4Q0FBOEMsaUVBQWlFLHVFQUF1RSx1RUFBdUUsbUVBQW1FLEtBQUssb0NBQW9DLHVDQUF1QyxvRUFBb0Usc0JBQXNCLG1CQUFtQix5Q0FBeUMsNkJBQTZCLGtCQUFrQixLQUFLLDBDQUEwQyxlQUFlLGdCQUFnQixLQUFLLDRDQUE0QyxlQUFlLGdCQUFnQixrQ0FBa0MsS0FBSywyQ0FBMkMsZUFBZSxpQkFBaUIsS0FBSyw2Q0FBNkMsa0JBQWtCLGdCQUFnQixLQUFLLCtDQUErQyxrQkFBa0IsZ0JBQWdCLGtDQUFrQyxLQUFLLDhDQUE4QyxrQkFBa0IsaUJBQWlCLEtBQUssb0RBQW9ELGtDQUFrQyxxQkFBcUIsbUJBQW1CLGdCQUFnQixrQkFBa0IsT0FBTywySEFBMkgsZUFBZSxpQ0FBaUMsT0FB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LFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFVBQVUsV0FBVyxVQUFVLE1BQU0sTUFBTSxVQUFVLE1BQU0sTUFBTSxVQUFVLE1BQU0sTUFBTSxVQUFVLFVBQVUsVUFBVSxVQUFVLFdBQVcsTUFBTSxNQUFNLFdBQVcsVUFBVSxNQUFNLE1BQU0sV0FBVyxVQUFVLFVBQVUsVUFBVSxPQUFPLE1BQU0sV0FBVyxXQUFXLE9BQU8sTUFBTSxXQUFXLFdBQVcsT0FBTyxNQUFNLEtBQUssV0FBVyxXQUFXLE1BQU0sS0FBSyxNQUFNLFdBQVcsV0FBVyxNQUFNLE1BQU0sV0FBVyxXQUFXLE1BQU0sTUFBTSxXQUFXLFdBQVcsTUFBTSxNQUFNLFdBQVcsV0FBVyxNQUFNLE1BQU0sV0FBVyxXQUFXLE1BQU0sTUFBTSxXQUFXLFdBQVcsTUFBTSxNQUFNLFdBQVcsV0FBVyxPQUFPLE1BQU0sV0FBVyxNQUFNLE1BQU0sV0FBVyxNQUFNLE1BQU0sV0FBVyxNQUFNLE1BQU0sV0FBVyxNQUFNLE1BQU0sV0FBVyxNQUFNLE1BQU0sV0FBVyxNQUFNLE1BQU0sV0FBVyxPQUFPLE1BQU0sVUFBVSxXQUFXLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxXQUFXLFdBQVcsTUFBTSxNQUFNLFVBQVUsVUFBVSxNQUFNLE1BQU0sV0FBVyxVQUFVLFVBQVUsTUFBTSxNQUFNLFVBQVUsT0FBTyxNQUFNLEtBQUssV0FBVyxNQUFNLE1BQU0sV0FBVyxNQUFNLEtBQUssTUFBTSxXQUFXLFVBQVUsVUFBVSxVQUFVLFVBQVUsV0FBVyxVQUFVLFdBQVcsTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLFVBQVUsVUFBVSxXQUFXLE9BQU8sTUFBTSxVQUFVLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsT0FBTyxNQUFNLEtBQUssV0FBVyxNQUFNLE1BQU0sVUFBVSxXQUFXLE1BQU0sTUFBTSxVQUFVLFdBQVcsTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLFVBQVUsTUFBTSxLQUFLLE1BQU0sS0FBSyxVQUFVLFdBQVcsTUFBTSxNQUFNLFVBQVUsV0FBVyxNQUFNLEtBQUssTUFBTSxLQUFLLFlBQVksTUFBTSxNQUFNLFVBQVUsV0FBVyxNQUFNLE1BQU0sVUFBVSxXQUFXLE1BQU0sTUFBTSxXQUFXLE1BQU0sTUFBTSxXQUFXLE1BQU0sTUFBTSxVQUFVLE1BQU0sS0FBSyxNQUFNLEtBQUssVUFBVSxXQUFXLE1BQU0sTUFBTSxVQUFVLFdBQVcsTUFBTSxLQUFLLE1BQU0sS0FBSyxZQUFZLE1BQU0sTUFBTSxVQUFVLFdBQVcsTUFBTSxNQUFNLFVBQVUsV0FBVyxNQUFNLE1BQU0sV0FBVyxNQUFNLE1BQU0sV0FBVyxNQUFNLE1BQU0sV0FBVyxNQUFNLEtBQUssTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLFVBQVUsV0FBVyxNQUFNLE1BQU0sVUFBVSxXQUFXLE1BQU0sS0FBSyxNQUFNLEtBQUssWUFBWSxNQUFNLE1BQU0sVUFBVSxXQUFXLE1BQU0sTUFBTSxVQUFVLFdBQVcsTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLFVBQVUsTUFBTSxLQUFLLE1BQU0sS0FBSyxXQUFXLE1BQU0sTUFBTSxVQUFVLFdBQVcsTUFBTSxNQUFNLFVBQVUsV0FBVyxNQUFNLEtBQUssTUFBTSxXQUFXLE1BQU0sTUFBTSxXQUFXLE1BQU0sTUFBTSxXQUFXLE1BQU0sTUFBTSxXQUFXLE9BQU8sTUFBTSxXQUFXLE1BQU0sTUFBTSxXQUFXLE1BQU0sTUFBTSxXQUFXLE1BQU0sTUFBTSxXQUFXLE9BQU8sTUFBTSxLQUFLLFVBQVUsV0FBVyxNQUFNLE1BQU0sVUFBVSxNQUFNLEtBQUssTUFBTSxLQUFLLFVBQVUsTUFBTSxNQUFNLFVBQVUsV0FBVyxNQUFNLE1BQU0sVUFBVSxNQUFNLEtBQUssTUFBTSxXQUFXLE9BQU8sTUFBTSxXQUFXLE9BQU8sTUFBTSxLQUFLLFdBQVcsV0FBVyxVQUFVLE1BQU0sTUFBTSxXQUFXLFdBQVcsTUFBTSxNQUFNLFdBQVcsVUFBVSxNQUFNLE1BQU0sV0FBVyxNQUFNLE1BQU0sV0FBVyxNQUFNLEtBQUssTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLFdBQVcsVUFBVSxNQUFNLE1BQU0sV0FBVyxVQUFVLE1BQU0sS0FBSyxNQUFNLFdBQVcsT0FBTyxNQUFNLFdBQVcsT0FBTyxNQUFNLEtBQUssV0FBVyxXQUFXLE1BQU0sTUFBTSxXQUFXLE1BQU0sS0FBSyxNQUFNLEtBQUssV0FBVyxXQUFXLE1BQU0sTUFBTSxZQUFZLE9BQU8sS0FBSyxNQUFNLEtBQUssV0FBVyxXQUFXLE1BQU0sTUFBTSxZQUFZLE9BQU8sS0FBSyxNQUFNLEtBQUssV0FBVyxXQUFXLE1BQU0sTUFBTSxZQUFZLE9BQU8sS0FBSyxNQUFNLEtBQUssWUFBWSxPQUFPLE1BQU0sV0FBVyxXQUFXLE1BQU0sS0FBSyxNQUFNLEtBQUssWUFBWSxPQUFPLE1BQU0sV0FBVyxXQUFXLE1BQU0sS0FBSyxNQUFNLEtBQUssWUFBWSxPQUFPLE1BQU0sV0FBVyxXQUFXLE1BQU0sS0FBSyxNQUFNLEtBQUssWUFBWSxPQUFPLE1BQU0sV0FBVyxXQUFXLE1BQU0sS0FBSyxNQUFNLFdBQVcsTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLFdBQVcsT0FBTyxNQUFNLFdBQVcsTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLFdBQVcsT0FBTyxPQUFPLEtBQUssV0FBVyxPQUFPLE9BQU8sV0FBVyxPQUFPLE1BQU0sNkJBQTZCO0FBQzErcEI7QUFDQSxpRUFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVhY3QtdG9hc3RpZnlcXGRpc3RcXFJlYWN0VG9hc3RpZnkuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIjpyb290IHtcXHJcXG4gIC0tdG9hc3RpZnktY29sb3ItbGlnaHQ6ICNmZmY7XFxyXFxuICAtLXRvYXN0aWZ5LWNvbG9yLWRhcms6ICMxMjEyMTI7XFxyXFxuICAtLXRvYXN0aWZ5LWNvbG9yLWluZm86ICMzNDk4ZGI7XFxyXFxuICAtLXRvYXN0aWZ5LWNvbG9yLXN1Y2Nlc3M6ICMwN2JjMGM7XFxyXFxuICAtLXRvYXN0aWZ5LWNvbG9yLXdhcm5pbmc6ICNmMWM0MGY7XFxyXFxuICAtLXRvYXN0aWZ5LWNvbG9yLWVycm9yOiAjZTc0YzNjO1xcclxcbiAgLS10b2FzdGlmeS1jb2xvci10cmFuc3BhcmVudDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpO1xcclxcbiAgLS10b2FzdGlmeS1pY29uLWNvbG9yLWluZm86IHZhcigtLXRvYXN0aWZ5LWNvbG9yLWluZm8pO1xcclxcbiAgLS10b2FzdGlmeS1pY29uLWNvbG9yLXN1Y2Nlc3M6IHZhcigtLXRvYXN0aWZ5LWNvbG9yLXN1Y2Nlc3MpO1xcclxcbiAgLS10b2FzdGlmeS1pY29uLWNvbG9yLXdhcm5pbmc6IHZhcigtLXRvYXN0aWZ5LWNvbG9yLXdhcm5pbmcpO1xcclxcbiAgLS10b2FzdGlmeS1pY29uLWNvbG9yLWVycm9yOiB2YXIoLS10b2FzdGlmeS1jb2xvci1lcnJvcik7XFxyXFxuICAtLXRvYXN0aWZ5LXRvYXN0LXdpZHRoOiAzMjBweDtcXHJcXG4gIC0tdG9hc3RpZnktdG9hc3QtYmFja2dyb3VuZDogI2ZmZjtcXHJcXG4gIC0tdG9hc3RpZnktdG9hc3QtbWluLWhlaWdodDogNjRweDtcXHJcXG4gIC0tdG9hc3RpZnktdG9hc3QtbWF4LWhlaWdodDogODAwcHg7XFxyXFxuICAtLXRvYXN0aWZ5LWZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xcclxcbiAgLS10b2FzdGlmeS16LWluZGV4OiA5OTk5O1xcclxcbiAgLS10b2FzdGlmeS10ZXh0LWNvbG9yLWxpZ2h0OiAjNzU3NTc1O1xcclxcbiAgLS10b2FzdGlmeS10ZXh0LWNvbG9yLWRhcms6ICNmZmY7XFxyXFxuICAtLXRvYXN0aWZ5LXRleHQtY29sb3ItaW5mbzogI2ZmZjtcXHJcXG4gIC0tdG9hc3RpZnktdGV4dC1jb2xvci1zdWNjZXNzOiAjZmZmO1xcclxcbiAgLS10b2FzdGlmeS10ZXh0LWNvbG9yLXdhcm5pbmc6ICNmZmY7XFxyXFxuICAtLXRvYXN0aWZ5LXRleHQtY29sb3ItZXJyb3I6ICNmZmY7XFxyXFxuICAtLXRvYXN0aWZ5LXNwaW5uZXItY29sb3I6ICM2MTYxNjE7XFxyXFxuICAtLXRvYXN0aWZ5LXNwaW5uZXItY29sb3ItZW1wdHktYXJlYTogI2UwZTBlMDtcXHJcXG4gIC0tdG9hc3RpZnktY29sb3ItcHJvZ3Jlc3MtbGlnaHQ6IGxpbmVhci1ncmFkaWVudChcXHJcXG4gICAgdG8gcmlnaHQsXFxyXFxuICAgICM0Y2Q5NjQsXFxyXFxuICAgICM1YWM4ZmEsXFxyXFxuICAgICMwMDdhZmYsXFxyXFxuICAgICMzNGFhZGMsXFxyXFxuICAgICM1ODU2ZDYsXFxyXFxuICAgICNmZjJkNTVcXHJcXG4gICk7XFxyXFxuICAtLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLWRhcms6ICNiYjg2ZmM7XFxyXFxuICAtLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLWluZm86IHZhcigtLXRvYXN0aWZ5LWNvbG9yLWluZm8pO1xcclxcbiAgLS10b2FzdGlmeS1jb2xvci1wcm9ncmVzcy1zdWNjZXNzOiB2YXIoLS10b2FzdGlmeS1jb2xvci1zdWNjZXNzKTtcXHJcXG4gIC0tdG9hc3RpZnktY29sb3ItcHJvZ3Jlc3Mtd2FybmluZzogdmFyKC0tdG9hc3RpZnktY29sb3Itd2FybmluZyk7XFxyXFxuICAtLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLWVycm9yOiB2YXIoLS10b2FzdGlmeS1jb2xvci1lcnJvcik7XFxyXFxufVxcclxcblxcclxcbi5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyIHtcXHJcXG4gIHotaW5kZXg6IHZhcigtLXRvYXN0aWZ5LXotaW5kZXgpO1xcclxcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIHZhcigtLXRvYXN0aWZ5LXotaW5kZXgpKTtcXHJcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXHJcXG4gIHBhZGRpbmc6IDRweDtcXHJcXG4gIHdpZHRoOiB2YXIoLS10b2FzdGlmeS10b2FzdC13aWR0aCk7XFxyXFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgY29sb3I6ICNmZmY7XFxyXFxufVxcclxcbi5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS10b3AtbGVmdCB7XFxyXFxuICB0b3A6IDFlbTtcXHJcXG4gIGxlZnQ6IDFlbTtcXHJcXG59XFxyXFxuLlRvYXN0aWZ5X190b2FzdC1jb250YWluZXItLXRvcC1jZW50ZXIge1xcclxcbiAgdG9wOiAxZW07XFxyXFxuICBsZWZ0OiA1MCU7XFxyXFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XFxyXFxufVxcclxcbi5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS10b3AtcmlnaHQge1xcclxcbiAgdG9wOiAxZW07XFxyXFxuICByaWdodDogMWVtO1xcclxcbn1cXHJcXG4uVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lci0tYm90dG9tLWxlZnQge1xcclxcbiAgYm90dG9tOiAxZW07XFxyXFxuICBsZWZ0OiAxZW07XFxyXFxufVxcclxcbi5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS1ib3R0b20tY2VudGVyIHtcXHJcXG4gIGJvdHRvbTogMWVtO1xcclxcbiAgbGVmdDogNTAlO1xcclxcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xcclxcbn1cXHJcXG4uVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lci0tYm90dG9tLXJpZ2h0IHtcXHJcXG4gIGJvdHRvbTogMWVtO1xcclxcbiAgcmlnaHQ6IDFlbTtcXHJcXG59XFxyXFxuXFxyXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LXdpZHRoIDogNDgwcHgpIHtcXHJcXG4gIC5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyIHtcXHJcXG4gICAgd2lkdGg6IDEwMHZ3O1xcclxcbiAgICBwYWRkaW5nOiAwO1xcclxcbiAgICBsZWZ0OiAwO1xcclxcbiAgICBtYXJnaW46IDA7XFxyXFxuICB9XFxyXFxuICAuVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lci0tdG9wLWxlZnQsIC5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS10b3AtY2VudGVyLCAuVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lci0tdG9wLXJpZ2h0IHtcXHJcXG4gICAgdG9wOiAwO1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxyXFxuICB9XFxyXFxuICAuVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lci0tYm90dG9tLWxlZnQsIC5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS1ib3R0b20tY2VudGVyLCAuVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lci0tYm90dG9tLXJpZ2h0IHtcXHJcXG4gICAgYm90dG9tOiAwO1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxyXFxuICB9XFxyXFxuICAuVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lci0tcnRsIHtcXHJcXG4gICAgcmlnaHQ6IDA7XFxyXFxuICAgIGxlZnQ6IGluaXRpYWw7XFxyXFxuICB9XFxyXFxufVxcclxcbi5Ub2FzdGlmeV9fdG9hc3Qge1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgbWluLWhlaWdodDogdmFyKC0tdG9hc3RpZnktdG9hc3QtbWluLWhlaWdodCk7XFxyXFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXHJcXG4gIHBhZGRpbmc6IDhweDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXHJcXG4gIGJveC1zaGFkb3c6IDAgMXB4IDEwcHggMCByZ2JhKDAsIDAsIDAsIDAuMSksIDAgMnB4IDE1cHggMCByZ2JhKDAsIDAsIDAsIDAuMDUpO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXHJcXG4gIG1heC1oZWlnaHQ6IHZhcigtLXRvYXN0aWZ5LXRvYXN0LW1heC1oZWlnaHQpO1xcclxcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS10b2FzdGlmeS1mb250LWZhbWlseSk7XFxyXFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxyXFxuICBkaXJlY3Rpb246IGx0cjtcXHJcXG4gIC8qIHdlYmtpdCBvbmx5IGlzc3VlICM3OTEgKi9cXHJcXG4gIHotaW5kZXg6IDA7XFxyXFxufVxcclxcbi5Ub2FzdGlmeV9fdG9hc3QtLXJ0bCB7XFxyXFxuICBkaXJlY3Rpb246IHJ0bDtcXHJcXG59XFxyXFxuLlRvYXN0aWZ5X190b2FzdC0tY2xvc2Utb24tY2xpY2sge1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG4uVG9hc3RpZnlfX3RvYXN0LWJvZHkge1xcclxcbiAgbWFyZ2luOiBhdXRvIDA7XFxyXFxuICBmbGV4OiAxIDEgYXV0bztcXHJcXG4gIHBhZGRpbmc6IDZweDtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbn1cXHJcXG4uVG9hc3RpZnlfX3RvYXN0LWJvZHkgPiBkaXY6bGFzdC1jaGlsZCB7XFxyXFxuICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xcclxcbiAgZmxleDogMTtcXHJcXG59XFxyXFxuLlRvYXN0aWZ5X190b2FzdC1pY29uIHtcXHJcXG4gIG1hcmdpbi1pbmxpbmUtZW5kOiAxMHB4O1xcclxcbiAgd2lkdGg6IDIwcHg7XFxyXFxuICBmbGV4LXNocmluazogMDtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxufVxcclxcblxcclxcbi5Ub2FzdGlmeS0tYW5pbWF0ZSB7XFxyXFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcclxcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjdzO1xcclxcbn1cXHJcXG5cXHJcXG4uVG9hc3RpZnktLWFuaW1hdGUtaWNvbiB7XFxyXFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcclxcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcclxcbn1cXHJcXG5cXHJcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGggOiA0ODBweCkge1xcclxcbiAgLlRvYXN0aWZ5X190b2FzdCB7XFxyXFxuICAgIG1hcmdpbi1ib3R0b206IDA7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDA7XFxyXFxuICB9XFxyXFxufVxcclxcbi5Ub2FzdGlmeV9fdG9hc3QtdGhlbWUtLWRhcmsge1xcclxcbiAgYmFja2dyb3VuZDogdmFyKC0tdG9hc3RpZnktY29sb3ItZGFyayk7XFxyXFxuICBjb2xvcjogdmFyKC0tdG9hc3RpZnktdGV4dC1jb2xvci1kYXJrKTtcXHJcXG59XFxyXFxuLlRvYXN0aWZ5X190b2FzdC10aGVtZS0tbGlnaHQge1xcclxcbiAgYmFja2dyb3VuZDogdmFyKC0tdG9hc3RpZnktY29sb3ItbGlnaHQpO1xcclxcbiAgY29sb3I6IHZhcigtLXRvYXN0aWZ5LXRleHQtY29sb3ItbGlnaHQpO1xcclxcbn1cXHJcXG4uVG9hc3RpZnlfX3RvYXN0LXRoZW1lLS1jb2xvcmVkLlRvYXN0aWZ5X190b2FzdC0tZGVmYXVsdCB7XFxyXFxuICBiYWNrZ3JvdW5kOiB2YXIoLS10b2FzdGlmeS1jb2xvci1saWdodCk7XFxyXFxuICBjb2xvcjogdmFyKC0tdG9hc3RpZnktdGV4dC1jb2xvci1saWdodCk7XFxyXFxufVxcclxcbi5Ub2FzdGlmeV9fdG9hc3QtdGhlbWUtLWNvbG9yZWQuVG9hc3RpZnlfX3RvYXN0LS1pbmZvIHtcXHJcXG4gIGNvbG9yOiB2YXIoLS10b2FzdGlmeS10ZXh0LWNvbG9yLWluZm8pO1xcclxcbiAgYmFja2dyb3VuZDogdmFyKC0tdG9hc3RpZnktY29sb3ItaW5mbyk7XFxyXFxufVxcclxcbi5Ub2FzdGlmeV9fdG9hc3QtdGhlbWUtLWNvbG9yZWQuVG9hc3RpZnlfX3RvYXN0LS1zdWNjZXNzIHtcXHJcXG4gIGNvbG9yOiB2YXIoLS10b2FzdGlmeS10ZXh0LWNvbG9yLXN1Y2Nlc3MpO1xcclxcbiAgYmFja2dyb3VuZDogdmFyKC0tdG9hc3RpZnktY29sb3Itc3VjY2Vzcyk7XFxyXFxufVxcclxcbi5Ub2FzdGlmeV9fdG9hc3QtdGhlbWUtLWNvbG9yZWQuVG9hc3RpZnlfX3RvYXN0LS13YXJuaW5nIHtcXHJcXG4gIGNvbG9yOiB2YXIoLS10b2FzdGlmeS10ZXh0LWNvbG9yLXdhcm5pbmcpO1xcclxcbiAgYmFja2dyb3VuZDogdmFyKC0tdG9hc3RpZnktY29sb3Itd2FybmluZyk7XFxyXFxufVxcclxcbi5Ub2FzdGlmeV9fdG9hc3QtdGhlbWUtLWNvbG9yZWQuVG9hc3RpZnlfX3RvYXN0LS1lcnJvciB7XFxyXFxuICBjb2xvcjogdmFyKC0tdG9hc3RpZnktdGV4dC1jb2xvci1lcnJvcik7XFxyXFxuICBiYWNrZ3JvdW5kOiB2YXIoLS10b2FzdGlmeS1jb2xvci1lcnJvcik7XFxyXFxufVxcclxcblxcclxcbi5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLXRoZW1lLS1saWdodCB7XFxyXFxuICBiYWNrZ3JvdW5kOiB2YXIoLS10b2FzdGlmeS1jb2xvci1wcm9ncmVzcy1saWdodCk7XFxyXFxufVxcclxcbi5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLXRoZW1lLS1kYXJrIHtcXHJcXG4gIGJhY2tncm91bmQ6IHZhcigtLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLWRhcmspO1xcclxcbn1cXHJcXG4uVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0taW5mbyB7XFxyXFxuICBiYWNrZ3JvdW5kOiB2YXIoLS10b2FzdGlmeS1jb2xvci1wcm9ncmVzcy1pbmZvKTtcXHJcXG59XFxyXFxuLlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLXN1Y2Nlc3Mge1xcclxcbiAgYmFja2dyb3VuZDogdmFyKC0tdG9hc3RpZnktY29sb3ItcHJvZ3Jlc3Mtc3VjY2Vzcyk7XFxyXFxufVxcclxcbi5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS13YXJuaW5nIHtcXHJcXG4gIGJhY2tncm91bmQ6IHZhcigtLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLXdhcm5pbmcpO1xcclxcbn1cXHJcXG4uVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0tZXJyb3Ige1xcclxcbiAgYmFja2dyb3VuZDogdmFyKC0tdG9hc3RpZnktY29sb3ItcHJvZ3Jlc3MtZXJyb3IpO1xcclxcbn1cXHJcXG4uVG9hc3RpZnlfX3Byb2dyZXNzLWJhci10aGVtZS0tY29sb3JlZC5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS1pbmZvLCAuVG9hc3RpZnlfX3Byb2dyZXNzLWJhci10aGVtZS0tY29sb3JlZC5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS1zdWNjZXNzLCAuVG9hc3RpZnlfX3Byb2dyZXNzLWJhci10aGVtZS0tY29sb3JlZC5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS13YXJuaW5nLCAuVG9hc3RpZnlfX3Byb2dyZXNzLWJhci10aGVtZS0tY29sb3JlZC5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS1lcnJvciB7XFxyXFxuICBiYWNrZ3JvdW5kOiB2YXIoLS10b2FzdGlmeS1jb2xvci10cmFuc3BhcmVudCk7XFxyXFxufVxcclxcblxcclxcbi5Ub2FzdGlmeV9fY2xvc2UtYnV0dG9uIHtcXHJcXG4gIGNvbG9yOiAjZmZmO1xcclxcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxyXFxuICBvdXRsaW5lOiBub25lO1xcclxcbiAgYm9yZGVyOiBub25lO1xcclxcbiAgcGFkZGluZzogMDtcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gIG9wYWNpdHk6IDAuNztcXHJcXG4gIHRyYW5zaXRpb246IDAuM3MgZWFzZTtcXHJcXG4gIGFsaWduLXNlbGY6IGZsZXgtc3RhcnQ7XFxyXFxufVxcclxcbi5Ub2FzdGlmeV9fY2xvc2UtYnV0dG9uLS1saWdodCB7XFxyXFxuICBjb2xvcjogIzAwMDtcXHJcXG4gIG9wYWNpdHk6IDAuMztcXHJcXG59XFxyXFxuLlRvYXN0aWZ5X19jbG9zZS1idXR0b24gPiBzdmcge1xcclxcbiAgZmlsbDogY3VycmVudENvbG9yO1xcclxcbiAgaGVpZ2h0OiAxNnB4O1xcclxcbiAgd2lkdGg6IDE0cHg7XFxyXFxufVxcclxcbi5Ub2FzdGlmeV9fY2xvc2UtYnV0dG9uOmhvdmVyLCAuVG9hc3RpZnlfX2Nsb3NlLWJ1dHRvbjpmb2N1cyB7XFxyXFxuICBvcGFjaXR5OiAxO1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X190cmFja1Byb2dyZXNzIHtcXHJcXG4gIDAlIHtcXHJcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVgoMSk7XFxyXFxuICB9XFxyXFxuICAxMDAlIHtcXHJcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVgoMCk7XFxyXFxuICB9XFxyXFxufVxcclxcbi5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyIHtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIGJvdHRvbTogMDtcXHJcXG4gIGxlZnQ6IDA7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIGhlaWdodDogNXB4O1xcclxcbiAgei1pbmRleDogdmFyKC0tdG9hc3RpZnktei1pbmRleCk7XFxyXFxuICBvcGFjaXR5OiAwLjc7XFxyXFxuICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0O1xcclxcbn1cXHJcXG4uVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0tYW5pbWF0ZWQge1xcclxcbiAgYW5pbWF0aW9uOiBUb2FzdGlmeV9fdHJhY2tQcm9ncmVzcyBsaW5lYXIgMSBmb3J3YXJkcztcXHJcXG59XFxyXFxuLlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLWNvbnRyb2xsZWQge1xcclxcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMnM7XFxyXFxufVxcclxcbi5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS1ydGwge1xcclxcbiAgcmlnaHQ6IDA7XFxyXFxuICBsZWZ0OiBpbml0aWFsO1xcclxcbiAgdHJhbnNmb3JtLW9yaWdpbjogcmlnaHQ7XFxyXFxufVxcclxcblxcclxcbi5Ub2FzdGlmeV9fc3Bpbm5lciB7XFxyXFxuICB3aWR0aDogMjBweDtcXHJcXG4gIGhlaWdodDogMjBweDtcXHJcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuICBib3JkZXI6IDJweCBzb2xpZDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDEwMCU7XFxyXFxuICBib3JkZXItY29sb3I6IHZhcigtLXRvYXN0aWZ5LXNwaW5uZXItY29sb3ItZW1wdHktYXJlYSk7XFxyXFxuICBib3JkZXItcmlnaHQtY29sb3I6IHZhcigtLXRvYXN0aWZ5LXNwaW5uZXItY29sb3IpO1xcclxcbiAgYW5pbWF0aW9uOiBUb2FzdGlmeV9fc3BpbiAwLjY1cyBsaW5lYXIgaW5maW5pdGU7XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX2JvdW5jZUluUmlnaHQge1xcclxcbiAgZnJvbSwgNjAlLCA3NSUsIDkwJSwgdG8ge1xcclxcbiAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMTUsIDAuNjEsIDAuMzU1LCAxKTtcXHJcXG4gIH1cXHJcXG4gIGZyb20ge1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDMwMDBweCwgMCwgMCk7XFxyXFxuICB9XFxyXFxuICA2MCUge1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC0yNXB4LCAwLCAwKTtcXHJcXG4gIH1cXHJcXG4gIDc1JSB7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMTBweCwgMCwgMCk7XFxyXFxuICB9XFxyXFxuICA5MCUge1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC01cHgsIDAsIDApO1xcclxcbiAgfVxcclxcbiAgdG8ge1xcclxcbiAgICB0cmFuc2Zvcm06IG5vbmU7XFxyXFxuICB9XFxyXFxufVxcclxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX2JvdW5jZU91dFJpZ2h0IHtcXHJcXG4gIDIwJSB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLTIwcHgsIDAsIDApO1xcclxcbiAgfVxcclxcbiAgdG8ge1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDIwMDBweCwgMCwgMCk7XFxyXFxuICB9XFxyXFxufVxcclxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX2JvdW5jZUluTGVmdCB7XFxyXFxuICBmcm9tLCA2MCUsIDc1JSwgOTAlLCB0byB7XFxyXFxuICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIxNSwgMC42MSwgMC4zNTUsIDEpO1xcclxcbiAgfVxcclxcbiAgMCUge1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC0zMDAwcHgsIDAsIDApO1xcclxcbiAgfVxcclxcbiAgNjAlIHtcXHJcXG4gICAgb3BhY2l0eTogMTtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgyNXB4LCAwLCAwKTtcXHJcXG4gIH1cXHJcXG4gIDc1JSB7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLTEwcHgsIDAsIDApO1xcclxcbiAgfVxcclxcbiAgOTAlIHtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCg1cHgsIDAsIDApO1xcclxcbiAgfVxcclxcbiAgdG8ge1xcclxcbiAgICB0cmFuc2Zvcm06IG5vbmU7XFxyXFxuICB9XFxyXFxufVxcclxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX2JvdW5jZU91dExlZnQge1xcclxcbiAgMjAlIHtcXHJcXG4gICAgb3BhY2l0eTogMTtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgyMHB4LCAwLCAwKTtcXHJcXG4gIH1cXHJcXG4gIHRvIHtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgtMjAwMHB4LCAwLCAwKTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuQGtleWZyYW1lcyBUb2FzdGlmeV9fYm91bmNlSW5VcCB7XFxyXFxuICBmcm9tLCA2MCUsIDc1JSwgOTAlLCB0byB7XFxyXFxuICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIxNSwgMC42MSwgMC4zNTUsIDEpO1xcclxcbiAgfVxcclxcbiAgZnJvbSB7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMzAwMHB4LCAwKTtcXHJcXG4gIH1cXHJcXG4gIDYwJSB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgLTIwcHgsIDApO1xcclxcbiAgfVxcclxcbiAgNzUlIHtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAxMHB4LCAwKTtcXHJcXG4gIH1cXHJcXG4gIDkwJSB7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgLTVweCwgMCk7XFxyXFxuICB9XFxyXFxuICB0byB7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XFxyXFxuICB9XFxyXFxufVxcclxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX2JvdW5jZU91dFVwIHtcXHJcXG4gIDIwJSB7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgLTEwcHgsIDApO1xcclxcbiAgfVxcclxcbiAgNDAlLCA0NSUge1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDIwcHgsIDApO1xcclxcbiAgfVxcclxcbiAgdG8ge1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIC0yMDAwcHgsIDApO1xcclxcbiAgfVxcclxcbn1cXHJcXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19ib3VuY2VJbkRvd24ge1xcclxcbiAgZnJvbSwgNjAlLCA3NSUsIDkwJSwgdG8ge1xcclxcbiAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMTUsIDAuNjEsIDAuMzU1LCAxKTtcXHJcXG4gIH1cXHJcXG4gIDAlIHtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAtMzAwMHB4LCAwKTtcXHJcXG4gIH1cXHJcXG4gIDYwJSB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMjVweCwgMCk7XFxyXFxuICB9XFxyXFxuICA3NSUge1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIC0xMHB4LCAwKTtcXHJcXG4gIH1cXHJcXG4gIDkwJSB7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgNXB4LCAwKTtcXHJcXG4gIH1cXHJcXG4gIHRvIHtcXHJcXG4gICAgdHJhbnNmb3JtOiBub25lO1xcclxcbiAgfVxcclxcbn1cXHJcXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19ib3VuY2VPdXREb3duIHtcXHJcXG4gIDIwJSB7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMTBweCwgMCk7XFxyXFxuICB9XFxyXFxuICA0MCUsIDQ1JSB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgLTIwcHgsIDApO1xcclxcbiAgfVxcclxcbiAgdG8ge1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDIwMDBweCwgMCk7XFxyXFxuICB9XFxyXFxufVxcclxcbi5Ub2FzdGlmeV9fYm91bmNlLWVudGVyLS10b3AtbGVmdCwgLlRvYXN0aWZ5X19ib3VuY2UtZW50ZXItLWJvdHRvbS1sZWZ0IHtcXHJcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fYm91bmNlSW5MZWZ0O1xcclxcbn1cXHJcXG4uVG9hc3RpZnlfX2JvdW5jZS1lbnRlci0tdG9wLXJpZ2h0LCAuVG9hc3RpZnlfX2JvdW5jZS1lbnRlci0tYm90dG9tLXJpZ2h0IHtcXHJcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fYm91bmNlSW5SaWdodDtcXHJcXG59XFxyXFxuLlRvYXN0aWZ5X19ib3VuY2UtZW50ZXItLXRvcC1jZW50ZXIge1xcclxcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X19ib3VuY2VJbkRvd247XFxyXFxufVxcclxcbi5Ub2FzdGlmeV9fYm91bmNlLWVudGVyLS1ib3R0b20tY2VudGVyIHtcXHJcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fYm91bmNlSW5VcDtcXHJcXG59XFxyXFxuXFxyXFxuLlRvYXN0aWZ5X19ib3VuY2UtZXhpdC0tdG9wLWxlZnQsIC5Ub2FzdGlmeV9fYm91bmNlLWV4aXQtLWJvdHRvbS1sZWZ0IHtcXHJcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fYm91bmNlT3V0TGVmdDtcXHJcXG59XFxyXFxuLlRvYXN0aWZ5X19ib3VuY2UtZXhpdC0tdG9wLXJpZ2h0LCAuVG9hc3RpZnlfX2JvdW5jZS1leGl0LS1ib3R0b20tcmlnaHQge1xcclxcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X19ib3VuY2VPdXRSaWdodDtcXHJcXG59XFxyXFxuLlRvYXN0aWZ5X19ib3VuY2UtZXhpdC0tdG9wLWNlbnRlciB7XFxyXFxuICBhbmltYXRpb24tbmFtZTogVG9hc3RpZnlfX2JvdW5jZU91dFVwO1xcclxcbn1cXHJcXG4uVG9hc3RpZnlfX2JvdW5jZS1leGl0LS1ib3R0b20tY2VudGVyIHtcXHJcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fYm91bmNlT3V0RG93bjtcXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBUb2FzdGlmeV9fem9vbUluIHtcXHJcXG4gIGZyb20ge1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgICB0cmFuc2Zvcm06IHNjYWxlM2QoMC4zLCAwLjMsIDAuMyk7XFxyXFxuICB9XFxyXFxuICA1MCUge1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgfVxcclxcbn1cXHJcXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X196b29tT3V0IHtcXHJcXG4gIGZyb20ge1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgfVxcclxcbiAgNTAlIHtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gICAgdHJhbnNmb3JtOiBzY2FsZTNkKDAuMywgMC4zLCAwLjMpO1xcclxcbiAgfVxcclxcbiAgdG8ge1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgfVxcclxcbn1cXHJcXG4uVG9hc3RpZnlfX3pvb20tZW50ZXIge1xcclxcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X196b29tSW47XFxyXFxufVxcclxcblxcclxcbi5Ub2FzdGlmeV9fem9vbS1leGl0IHtcXHJcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fem9vbU91dDtcXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBUb2FzdGlmeV9fZmxpcEluIHtcXHJcXG4gIGZyb20ge1xcclxcbiAgICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDQwMHB4KSByb3RhdGUzZCgxLCAwLCAwLCA5MGRlZyk7XFxyXFxuICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2UtaW47XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICB9XFxyXFxuICA0MCUge1xcclxcbiAgICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDQwMHB4KSByb3RhdGUzZCgxLCAwLCAwLCAtMjBkZWcpO1xcclxcbiAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLWluO1xcclxcbiAgfVxcclxcbiAgNjAlIHtcXHJcXG4gICAgdHJhbnNmb3JtOiBwZXJzcGVjdGl2ZSg0MDBweCkgcm90YXRlM2QoMSwgMCwgMCwgMTBkZWcpO1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgfVxcclxcbiAgODAlIHtcXHJcXG4gICAgdHJhbnNmb3JtOiBwZXJzcGVjdGl2ZSg0MDBweCkgcm90YXRlM2QoMSwgMCwgMCwgLTVkZWcpO1xcclxcbiAgfVxcclxcbiAgdG8ge1xcclxcbiAgICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDQwMHB4KTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuQGtleWZyYW1lcyBUb2FzdGlmeV9fZmxpcE91dCB7XFxyXFxuICBmcm9tIHtcXHJcXG4gICAgdHJhbnNmb3JtOiBwZXJzcGVjdGl2ZSg0MDBweCk7XFxyXFxuICB9XFxyXFxuICAzMCUge1xcclxcbiAgICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDQwMHB4KSByb3RhdGUzZCgxLCAwLCAwLCAtMjBkZWcpO1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgfVxcclxcbiAgdG8ge1xcclxcbiAgICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDQwMHB4KSByb3RhdGUzZCgxLCAwLCAwLCA5MGRlZyk7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICB9XFxyXFxufVxcclxcbi5Ub2FzdGlmeV9fZmxpcC1lbnRlciB7XFxyXFxuICBhbmltYXRpb24tbmFtZTogVG9hc3RpZnlfX2ZsaXBJbjtcXHJcXG59XFxyXFxuXFxyXFxuLlRvYXN0aWZ5X19mbGlwLWV4aXQge1xcclxcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X19mbGlwT3V0O1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19zbGlkZUluUmlnaHQge1xcclxcbiAgZnJvbSB7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMTEwJSwgMCwgMCk7XFxyXFxuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XFxyXFxuICB9XFxyXFxuICB0byB7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XFxyXFxuICB9XFxyXFxufVxcclxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX3NsaWRlSW5MZWZ0IHtcXHJcXG4gIGZyb20ge1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC0xMTAlLCAwLCAwKTtcXHJcXG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXHJcXG4gIH1cXHJcXG4gIHRvIHtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuQGtleWZyYW1lcyBUb2FzdGlmeV9fc2xpZGVJblVwIHtcXHJcXG4gIGZyb20ge1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDExMCUsIDApO1xcclxcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcclxcbiAgfVxcclxcbiAgdG8ge1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xcclxcbiAgfVxcclxcbn1cXHJcXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19zbGlkZUluRG93biB7XFxyXFxuICBmcm9tIHtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAtMTEwJSwgMCk7XFxyXFxuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XFxyXFxuICB9XFxyXFxuICB0byB7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XFxyXFxuICB9XFxyXFxufVxcclxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX3NsaWRlT3V0UmlnaHQge1xcclxcbiAgZnJvbSB7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XFxyXFxuICB9XFxyXFxuICB0byB7XFxyXFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgxMTAlLCAwLCAwKTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuQGtleWZyYW1lcyBUb2FzdGlmeV9fc2xpZGVPdXRMZWZ0IHtcXHJcXG4gIGZyb20ge1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xcclxcbiAgfVxcclxcbiAgdG8ge1xcclxcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLTExMCUsIDAsIDApO1xcclxcbiAgfVxcclxcbn1cXHJcXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19zbGlkZU91dERvd24ge1xcclxcbiAgZnJvbSB7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XFxyXFxuICB9XFxyXFxuICB0byB7XFxyXFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCA1MDBweCwgMCk7XFxyXFxuICB9XFxyXFxufVxcclxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX3NsaWRlT3V0VXAge1xcclxcbiAgZnJvbSB7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XFxyXFxuICB9XFxyXFxuICB0byB7XFxyXFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAtNTAwcHgsIDApO1xcclxcbiAgfVxcclxcbn1cXHJcXG4uVG9hc3RpZnlfX3NsaWRlLWVudGVyLS10b3AtbGVmdCwgLlRvYXN0aWZ5X19zbGlkZS1lbnRlci0tYm90dG9tLWxlZnQge1xcclxcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X19zbGlkZUluTGVmdDtcXHJcXG59XFxyXFxuLlRvYXN0aWZ5X19zbGlkZS1lbnRlci0tdG9wLXJpZ2h0LCAuVG9hc3RpZnlfX3NsaWRlLWVudGVyLS1ib3R0b20tcmlnaHQge1xcclxcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X19zbGlkZUluUmlnaHQ7XFxyXFxufVxcclxcbi5Ub2FzdGlmeV9fc2xpZGUtZW50ZXItLXRvcC1jZW50ZXIge1xcclxcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X19zbGlkZUluRG93bjtcXHJcXG59XFxyXFxuLlRvYXN0aWZ5X19zbGlkZS1lbnRlci0tYm90dG9tLWNlbnRlciB7XFxyXFxuICBhbmltYXRpb24tbmFtZTogVG9hc3RpZnlfX3NsaWRlSW5VcDtcXHJcXG59XFxyXFxuXFxyXFxuLlRvYXN0aWZ5X19zbGlkZS1leGl0LS10b3AtbGVmdCwgLlRvYXN0aWZ5X19zbGlkZS1leGl0LS1ib3R0b20tbGVmdCB7XFxyXFxuICBhbmltYXRpb24tbmFtZTogVG9hc3RpZnlfX3NsaWRlT3V0TGVmdDtcXHJcXG59XFxyXFxuLlRvYXN0aWZ5X19zbGlkZS1leGl0LS10b3AtcmlnaHQsIC5Ub2FzdGlmeV9fc2xpZGUtZXhpdC0tYm90dG9tLXJpZ2h0IHtcXHJcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fc2xpZGVPdXRSaWdodDtcXHJcXG59XFxyXFxuLlRvYXN0aWZ5X19zbGlkZS1leGl0LS10b3AtY2VudGVyIHtcXHJcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fc2xpZGVPdXRVcDtcXHJcXG59XFxyXFxuLlRvYXN0aWZ5X19zbGlkZS1leGl0LS1ib3R0b20tY2VudGVyIHtcXHJcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fc2xpZGVPdXREb3duO1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19zcGluIHtcXHJcXG4gIGZyb20ge1xcclxcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXHJcXG4gIH1cXHJcXG4gIHRvIHtcXHJcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9UmVhY3RUb2FzdGlmeS5jc3MubWFwICovXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL25vZGVfbW9kdWxlcy9yZWFjdC10b2FzdGlmeS9zY3NzL192YXJpYWJsZXMuc2Nzc1wiLFwid2VicGFjazovL25vZGVfbW9kdWxlcy9yZWFjdC10b2FzdGlmeS9kaXN0L1JlYWN0VG9hc3RpZnkuY3NzXCIsXCJ3ZWJwYWNrOi8vbm9kZV9tb2R1bGVzL3JlYWN0LXRvYXN0aWZ5L3Njc3MvX3RvYXN0Q29udGFpbmVyLnNjc3NcIixcIndlYnBhY2s6Ly9ub2RlX21vZHVsZXMvcmVhY3QtdG9hc3RpZnkvc2Nzcy9fdG9hc3Quc2Nzc1wiLFwid2VicGFjazovL25vZGVfbW9kdWxlcy9yZWFjdC10b2FzdGlmeS9zY3NzL190aGVtZS5zY3NzXCIsXCJ3ZWJwYWNrOi8vbm9kZV9tb2R1bGVzL3JlYWN0LXRvYXN0aWZ5L3Njc3MvX2Nsb3NlQnV0dG9uLnNjc3NcIixcIndlYnBhY2s6Ly9ub2RlX21vZHVsZXMvcmVhY3QtdG9hc3RpZnkvc2Nzcy9fcHJvZ3Jlc3NCYXIuc2Nzc1wiLFwid2VicGFjazovL25vZGVfbW9kdWxlcy9yZWFjdC10b2FzdGlmeS9zY3NzL19pY29ucy5zY3NzXCIsXCJ3ZWJwYWNrOi8vbm9kZV9tb2R1bGVzL3JlYWN0LXRvYXN0aWZ5L3Njc3MvYW5pbWF0aW9ucy9fYm91bmNlLnNjc3NcIixcIndlYnBhY2s6Ly9ub2RlX21vZHVsZXMvcmVhY3QtdG9hc3RpZnkvc2Nzcy9hbmltYXRpb25zL196b29tLnNjc3NcIixcIndlYnBhY2s6Ly9ub2RlX21vZHVsZXMvcmVhY3QtdG9hc3RpZnkvc2Nzcy9hbmltYXRpb25zL19mbGlwLnNjc3NcIixcIndlYnBhY2s6Ly9ub2RlX21vZHVsZXMvcmVhY3QtdG9hc3RpZnkvc2Nzcy9hbmltYXRpb25zL19zbGlkZS5zY3NzXCIsXCJ3ZWJwYWNrOi8vbm9kZV9tb2R1bGVzL3JlYWN0LXRvYXN0aWZ5L3Njc3Mv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VjhlRjtBQUNGO0FVM2VBO0VBQ0U7SUExRUEsK0JBQUE7RVZ3akJBO0VVM2VBO0lBQ0Usa0JBQUE7SUFDQSxvQ0FBQTtFVjZlRjtBQUNGO0FVemVFO0VBRUUscUNBQUE7QVYwZUo7QVV4ZUU7RUFFRSxzQ0FBQTtBVnllSjtBVXZlRTtFQUNFLHFDQUFBO0FWeWVKO0FVdmVFO0VBQ0UsbUNBQUE7QVZ5ZUo7O0FVcGVFO0VBRUUsc0NBQUE7QVZzZUo7QVVwZUU7RUFFRSx1Q0FBQTtBVnFlSjtBVW5lRTtFQUNFLG9DQUFBO0FWcWVKO0FVbmVFO0VBQ0Usc0NBQUE7QVZxZUo7O0FXdmxCQTtFQUNFO0lBQ0UsdUJBQUE7RVgwbEJGO0VXeGxCQTtJQUNFLHlCQUFBO0VYMGxCRjtBQUNGOztBQVlBLDRDQUE0Q1wiLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[11].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[11].use[2]!./node_modules/react-toastify/dist/ReactToastify.css\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./src/styles/globals.css":
/*!**************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./src/styles/globals.css ***!
  \**************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"*, ::before, ::after {\\r\\n  --tw-border-spacing-x: 0;\\r\\n  --tw-border-spacing-y: 0;\\r\\n  --tw-translate-x: 0;\\r\\n  --tw-translate-y: 0;\\r\\n  --tw-rotate: 0;\\r\\n  --tw-skew-x: 0;\\r\\n  --tw-skew-y: 0;\\r\\n  --tw-scale-x: 1;\\r\\n  --tw-scale-y: 1;\\r\\n  --tw-pan-x:  ;\\r\\n  --tw-pan-y:  ;\\r\\n  --tw-pinch-zoom:  ;\\r\\n  --tw-scroll-snap-strictness: proximity;\\r\\n  --tw-gradient-from-position:  ;\\r\\n  --tw-gradient-via-position:  ;\\r\\n  --tw-gradient-to-position:  ;\\r\\n  --tw-ordinal:  ;\\r\\n  --tw-slashed-zero:  ;\\r\\n  --tw-numeric-figure:  ;\\r\\n  --tw-numeric-spacing:  ;\\r\\n  --tw-numeric-fraction:  ;\\r\\n  --tw-ring-inset:  ;\\r\\n  --tw-ring-offset-width: 0px;\\r\\n  --tw-ring-offset-color: #fff;\\r\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\r\\n  --tw-ring-offset-shadow: 0 0 #0000;\\r\\n  --tw-ring-shadow: 0 0 #0000;\\r\\n  --tw-shadow: 0 0 #0000;\\r\\n  --tw-shadow-colored: 0 0 #0000;\\r\\n  --tw-blur:  ;\\r\\n  --tw-brightness:  ;\\r\\n  --tw-contrast:  ;\\r\\n  --tw-grayscale:  ;\\r\\n  --tw-hue-rotate:  ;\\r\\n  --tw-invert:  ;\\r\\n  --tw-saturate:  ;\\r\\n  --tw-sepia:  ;\\r\\n  --tw-drop-shadow:  ;\\r\\n  --tw-backdrop-blur:  ;\\r\\n  --tw-backdrop-brightness:  ;\\r\\n  --tw-backdrop-contrast:  ;\\r\\n  --tw-backdrop-grayscale:  ;\\r\\n  --tw-backdrop-hue-rotate:  ;\\r\\n  --tw-backdrop-invert:  ;\\r\\n  --tw-backdrop-opacity:  ;\\r\\n  --tw-backdrop-saturate:  ;\\r\\n  --tw-backdrop-sepia:  ;\\r\\n  --tw-contain-size:  ;\\r\\n  --tw-contain-layout:  ;\\r\\n  --tw-contain-paint:  ;\\r\\n  --tw-contain-style:  ;\\r\\n}\\r\\n\\r\\n::backdrop {\\r\\n  --tw-border-spacing-x: 0;\\r\\n  --tw-border-spacing-y: 0;\\r\\n  --tw-translate-x: 0;\\r\\n  --tw-translate-y: 0;\\r\\n  --tw-rotate: 0;\\r\\n  --tw-skew-x: 0;\\r\\n  --tw-skew-y: 0;\\r\\n  --tw-scale-x: 1;\\r\\n  --tw-scale-y: 1;\\r\\n  --tw-pan-x:  ;\\r\\n  --tw-pan-y:  ;\\r\\n  --tw-pinch-zoom:  ;\\r\\n  --tw-scroll-snap-strictness: proximity;\\r\\n  --tw-gradient-from-position:  ;\\r\\n  --tw-gradient-via-position:  ;\\r\\n  --tw-gradient-to-position:  ;\\r\\n  --tw-ordinal:  ;\\r\\n  --tw-slashed-zero:  ;\\r\\n  --tw-numeric-figure:  ;\\r\\n  --tw-numeric-spacing:  ;\\r\\n  --tw-numeric-fraction:  ;\\r\\n  --tw-ring-inset:  ;\\r\\n  --tw-ring-offset-width: 0px;\\r\\n  --tw-ring-offset-color: #fff;\\r\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\r\\n  --tw-ring-offset-shadow: 0 0 #0000;\\r\\n  --tw-ring-shadow: 0 0 #0000;\\r\\n  --tw-shadow: 0 0 #0000;\\r\\n  --tw-shadow-colored: 0 0 #0000;\\r\\n  --tw-blur:  ;\\r\\n  --tw-brightness:  ;\\r\\n  --tw-contrast:  ;\\r\\n  --tw-grayscale:  ;\\r\\n  --tw-hue-rotate:  ;\\r\\n  --tw-invert:  ;\\r\\n  --tw-saturate:  ;\\r\\n  --tw-sepia:  ;\\r\\n  --tw-drop-shadow:  ;\\r\\n  --tw-backdrop-blur:  ;\\r\\n  --tw-backdrop-brightness:  ;\\r\\n  --tw-backdrop-contrast:  ;\\r\\n  --tw-backdrop-grayscale:  ;\\r\\n  --tw-backdrop-hue-rotate:  ;\\r\\n  --tw-backdrop-invert:  ;\\r\\n  --tw-backdrop-opacity:  ;\\r\\n  --tw-backdrop-saturate:  ;\\r\\n  --tw-backdrop-sepia:  ;\\r\\n  --tw-contain-size:  ;\\r\\n  --tw-contain-layout:  ;\\r\\n  --tw-contain-paint:  ;\\r\\n  --tw-contain-style:  ;\\r\\n}/*\\r\\n! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com\\r\\n*//*\\r\\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\\r\\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\\r\\n*/\\r\\n\\r\\n*,\\r\\n::before,\\r\\n::after {\\r\\n  box-sizing: border-box; /* 1 */\\r\\n  border-width: 0; /* 2 */\\r\\n  border-style: solid; /* 2 */\\r\\n  border-color: #e5e7eb; /* 2 */\\r\\n}\\r\\n\\r\\n::before,\\r\\n::after {\\r\\n  --tw-content: '';\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Use a consistent sensible line-height in all browsers.\\r\\n2. Prevent adjustments of font size after orientation changes in iOS.\\r\\n3. Use a more readable tab size.\\r\\n4. Use the user's configured `sans` font-family by default.\\r\\n5. Use the user's configured `sans` font-feature-settings by default.\\r\\n6. Use the user's configured `sans` font-variation-settings by default.\\r\\n7. Disable tap highlights on iOS\\r\\n*/\\r\\n\\r\\nhtml,\\r\\n:host {\\r\\n  line-height: 1.5; /* 1 */\\r\\n  -webkit-text-size-adjust: 100%; /* 2 */\\r\\n  -moz-tab-size: 4; /* 3 */\\r\\n  -o-tab-size: 4;\\r\\n     tab-size: 4; /* 3 */\\r\\n  font-family: ui-sans-serif, system-ui, sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\"; /* 4 */\\r\\n  font-feature-settings: normal; /* 5 */\\r\\n  font-variation-settings: normal; /* 6 */\\r\\n  -webkit-tap-highlight-color: transparent; /* 7 */\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Remove the margin in all browsers.\\r\\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\\r\\n*/\\r\\n\\r\\nbody {\\r\\n  margin: 0; /* 1 */\\r\\n  line-height: inherit; /* 2 */\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Add the correct height in Firefox.\\r\\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\\r\\n3. Ensure horizontal rules are visible by default.\\r\\n*/\\r\\n\\r\\nhr {\\r\\n  height: 0; /* 1 */\\r\\n  color: inherit; /* 2 */\\r\\n  border-top-width: 1px; /* 3 */\\r\\n}\\r\\n\\r\\n/*\\r\\nAdd the correct text decoration in Chrome, Edge, and Safari.\\r\\n*/\\r\\n\\r\\nabbr:where([title]) {\\r\\n  -webkit-text-decoration: underline dotted;\\r\\n          text-decoration: underline dotted;\\r\\n}\\r\\n\\r\\n/*\\r\\nRemove the default font size and weight for headings.\\r\\n*/\\r\\n\\r\\nh1,\\r\\nh2,\\r\\nh3,\\r\\nh4,\\r\\nh5,\\r\\nh6 {\\r\\n  font-size: inherit;\\r\\n  font-weight: inherit;\\r\\n}\\r\\n\\r\\n/*\\r\\nReset links to optimize for opt-in styling instead of opt-out.\\r\\n*/\\r\\n\\r\\na {\\r\\n  color: inherit;\\r\\n  text-decoration: inherit;\\r\\n}\\r\\n\\r\\n/*\\r\\nAdd the correct font weight in Edge and Safari.\\r\\n*/\\r\\n\\r\\nb,\\r\\nstrong {\\r\\n  font-weight: bolder;\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Use the user's configured `mono` font-family by default.\\r\\n2. Use the user's configured `mono` font-feature-settings by default.\\r\\n3. Use the user's configured `mono` font-variation-settings by default.\\r\\n4. Correct the odd `em` font sizing in all browsers.\\r\\n*/\\r\\n\\r\\ncode,\\r\\nkbd,\\r\\nsamp,\\r\\npre {\\r\\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\", \\\"Courier New\\\", monospace; /* 1 */\\r\\n  font-feature-settings: normal; /* 2 */\\r\\n  font-variation-settings: normal; /* 3 */\\r\\n  font-size: 1em; /* 4 */\\r\\n}\\r\\n\\r\\n/*\\r\\nAdd the correct font size in all browsers.\\r\\n*/\\r\\n\\r\\nsmall {\\r\\n  font-size: 80%;\\r\\n}\\r\\n\\r\\n/*\\r\\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\\r\\n*/\\r\\n\\r\\nsub,\\r\\nsup {\\r\\n  font-size: 75%;\\r\\n  line-height: 0;\\r\\n  position: relative;\\r\\n  vertical-align: baseline;\\r\\n}\\r\\n\\r\\nsub {\\r\\n  bottom: -0.25em;\\r\\n}\\r\\n\\r\\nsup {\\r\\n  top: -0.5em;\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\\r\\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\\r\\n3. Remove gaps between table borders by default.\\r\\n*/\\r\\n\\r\\ntable {\\r\\n  text-indent: 0; /* 1 */\\r\\n  border-color: inherit; /* 2 */\\r\\n  border-collapse: collapse; /* 3 */\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Change the font styles in all browsers.\\r\\n2. Remove the margin in Firefox and Safari.\\r\\n3. Remove default padding in all browsers.\\r\\n*/\\r\\n\\r\\nbutton,\\r\\ninput,\\r\\noptgroup,\\r\\nselect,\\r\\ntextarea {\\r\\n  font-family: inherit; /* 1 */\\r\\n  font-feature-settings: inherit; /* 1 */\\r\\n  font-variation-settings: inherit; /* 1 */\\r\\n  font-size: 100%; /* 1 */\\r\\n  font-weight: inherit; /* 1 */\\r\\n  line-height: inherit; /* 1 */\\r\\n  letter-spacing: inherit; /* 1 */\\r\\n  color: inherit; /* 1 */\\r\\n  margin: 0; /* 2 */\\r\\n  padding: 0; /* 3 */\\r\\n}\\r\\n\\r\\n/*\\r\\nRemove the inheritance of text transform in Edge and Firefox.\\r\\n*/\\r\\n\\r\\nbutton,\\r\\nselect {\\r\\n  text-transform: none;\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Correct the inability to style clickable types in iOS and Safari.\\r\\n2. Remove default button styles.\\r\\n*/\\r\\n\\r\\nbutton,\\r\\ninput:where([type='button']),\\r\\ninput:where([type='reset']),\\r\\ninput:where([type='submit']) {\\r\\n  -webkit-appearance: button; /* 1 */\\r\\n  background-color: transparent; /* 2 */\\r\\n  background-image: none; /* 2 */\\r\\n}\\r\\n\\r\\n/*\\r\\nUse the modern Firefox focus style for all focusable elements.\\r\\n*/\\r\\n\\r\\n:-moz-focusring {\\r\\n  outline: auto;\\r\\n}\\r\\n\\r\\n/*\\r\\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\\r\\n*/\\r\\n\\r\\n:-moz-ui-invalid {\\r\\n  box-shadow: none;\\r\\n}\\r\\n\\r\\n/*\\r\\nAdd the correct vertical alignment in Chrome and Firefox.\\r\\n*/\\r\\n\\r\\nprogress {\\r\\n  vertical-align: baseline;\\r\\n}\\r\\n\\r\\n/*\\r\\nCorrect the cursor style of increment and decrement buttons in Safari.\\r\\n*/\\r\\n\\r\\n::-webkit-inner-spin-button,\\r\\n::-webkit-outer-spin-button {\\r\\n  height: auto;\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Correct the odd appearance in Chrome and Safari.\\r\\n2. Correct the outline style in Safari.\\r\\n*/\\r\\n\\r\\n[type='search'] {\\r\\n  -webkit-appearance: textfield; /* 1 */\\r\\n  outline-offset: -2px; /* 2 */\\r\\n}\\r\\n\\r\\n/*\\r\\nRemove the inner padding in Chrome and Safari on macOS.\\r\\n*/\\r\\n\\r\\n::-webkit-search-decoration {\\r\\n  -webkit-appearance: none;\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Correct the inability to style clickable types in iOS and Safari.\\r\\n2. Change font properties to `inherit` in Safari.\\r\\n*/\\r\\n\\r\\n::-webkit-file-upload-button {\\r\\n  -webkit-appearance: button; /* 1 */\\r\\n  font: inherit; /* 2 */\\r\\n}\\r\\n\\r\\n/*\\r\\nAdd the correct display in Chrome and Safari.\\r\\n*/\\r\\n\\r\\nsummary {\\r\\n  display: list-item;\\r\\n}\\r\\n\\r\\n/*\\r\\nRemoves the default spacing and border for appropriate elements.\\r\\n*/\\r\\n\\r\\nblockquote,\\r\\ndl,\\r\\ndd,\\r\\nh1,\\r\\nh2,\\r\\nh3,\\r\\nh4,\\r\\nh5,\\r\\nh6,\\r\\nhr,\\r\\nfigure,\\r\\np,\\r\\npre {\\r\\n  margin: 0;\\r\\n}\\r\\n\\r\\nfieldset {\\r\\n  margin: 0;\\r\\n  padding: 0;\\r\\n}\\r\\n\\r\\nlegend {\\r\\n  padding: 0;\\r\\n}\\r\\n\\r\\nol,\\r\\nul,\\r\\nmenu {\\r\\n  list-style: none;\\r\\n  margin: 0;\\r\\n  padding: 0;\\r\\n}\\r\\n\\r\\n/*\\r\\nReset default styling for dialogs.\\r\\n*/\\r\\ndialog {\\r\\n  padding: 0;\\r\\n}\\r\\n\\r\\n/*\\r\\nPrevent resizing textareas horizontally by default.\\r\\n*/\\r\\n\\r\\ntextarea {\\r\\n  resize: vertical;\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\\r\\n2. Set the default placeholder color to the user's configured gray 400 color.\\r\\n*/\\r\\n\\r\\ninput::-moz-placeholder, textarea::-moz-placeholder {\\r\\n  opacity: 1; /* 1 */\\r\\n  color: #9ca3af; /* 2 */\\r\\n}\\r\\n\\r\\ninput::placeholder,\\r\\ntextarea::placeholder {\\r\\n  opacity: 1; /* 1 */\\r\\n  color: #9ca3af; /* 2 */\\r\\n}\\r\\n\\r\\n/*\\r\\nSet the default cursor for buttons.\\r\\n*/\\r\\n\\r\\nbutton,\\r\\n[role=\\\"button\\\"] {\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n/*\\r\\nMake sure disabled buttons don't get the pointer cursor.\\r\\n*/\\r\\n:disabled {\\r\\n  cursor: default;\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\\r\\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\\r\\n   This can trigger a poorly considered lint error in some tools but is included by design.\\r\\n*/\\r\\n\\r\\nimg,\\r\\nsvg,\\r\\nvideo,\\r\\ncanvas,\\r\\naudio,\\r\\niframe,\\r\\nembed,\\r\\nobject {\\r\\n  display: block; /* 1 */\\r\\n  vertical-align: middle; /* 2 */\\r\\n}\\r\\n\\r\\n/*\\r\\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\\r\\n*/\\r\\n\\r\\nimg,\\r\\nvideo {\\r\\n  max-width: 100%;\\r\\n  height: auto;\\r\\n}\\r\\n\\r\\n/* Make elements with the HTML hidden attribute stay hidden by default */\\r\\n[hidden]:where(:not([hidden=\\\"until-found\\\"])) {\\r\\n  display: none;\\r\\n}\\r\\n.container {\\r\\n  width: 100%;\\r\\n}\\r\\n@media (min-width: 640px) {\\r\\n\\r\\n  .container {\\r\\n    max-width: 640px;\\r\\n  }\\r\\n}\\r\\n@media (min-width: 768px) {\\r\\n\\r\\n  .container {\\r\\n    max-width: 768px;\\r\\n  }\\r\\n}\\r\\n@media (min-width: 1024px) {\\r\\n\\r\\n  .container {\\r\\n    max-width: 1024px;\\r\\n  }\\r\\n}\\r\\n@media (min-width: 1280px) {\\r\\n\\r\\n  .container {\\r\\n    max-width: 1280px;\\r\\n  }\\r\\n}\\r\\n@media (min-width: 1536px) {\\r\\n\\r\\n  .container {\\r\\n    max-width: 1536px;\\r\\n  }\\r\\n}\\r\\n.fixed {\\r\\n  position: fixed;\\r\\n}\\r\\n.absolute {\\r\\n  position: absolute;\\r\\n}\\r\\n.relative {\\r\\n  position: relative;\\r\\n}\\r\\n.sticky {\\r\\n  position: sticky;\\r\\n}\\r\\n.inset-0 {\\r\\n  inset: 0px;\\r\\n}\\r\\n.right-2 {\\r\\n  right: 0.5rem;\\r\\n}\\r\\n.right-4 {\\r\\n  right: 1rem;\\r\\n}\\r\\n.top-0 {\\r\\n  top: 0px;\\r\\n}\\r\\n.top-1\\\\/2 {\\r\\n  top: 50%;\\r\\n}\\r\\n.top-4 {\\r\\n  top: 1rem;\\r\\n}\\r\\n.z-50 {\\r\\n  z-index: 50;\\r\\n}\\r\\n.mx-auto {\\r\\n  margin-left: auto;\\r\\n  margin-right: auto;\\r\\n}\\r\\n.mb-1 {\\r\\n  margin-bottom: 0.25rem;\\r\\n}\\r\\n.mb-2 {\\r\\n  margin-bottom: 0.5rem;\\r\\n}\\r\\n.mb-4 {\\r\\n  margin-bottom: 1rem;\\r\\n}\\r\\n.mb-6 {\\r\\n  margin-bottom: 1.5rem;\\r\\n}\\r\\n.mt-1 {\\r\\n  margin-top: 0.25rem;\\r\\n}\\r\\n.mt-2 {\\r\\n  margin-top: 0.5rem;\\r\\n}\\r\\n.mt-3 {\\r\\n  margin-top: 0.75rem;\\r\\n}\\r\\n.flex {\\r\\n  display: flex;\\r\\n}\\r\\n.inline-flex {\\r\\n  display: inline-flex;\\r\\n}\\r\\n.grid {\\r\\n  display: grid;\\r\\n}\\r\\n.hidden {\\r\\n  display: none;\\r\\n}\\r\\n.h-10 {\\r\\n  height: 2.5rem;\\r\\n}\\r\\n.h-11 {\\r\\n  height: 2.75rem;\\r\\n}\\r\\n.h-12 {\\r\\n  height: 3rem;\\r\\n}\\r\\n.h-16 {\\r\\n  height: 4rem;\\r\\n}\\r\\n.h-4 {\\r\\n  height: 1rem;\\r\\n}\\r\\n.h-6 {\\r\\n  height: 1.5rem;\\r\\n}\\r\\n.h-8 {\\r\\n  height: 2rem;\\r\\n}\\r\\n.h-80 {\\r\\n  height: 20rem;\\r\\n}\\r\\n.h-9 {\\r\\n  height: 2.25rem;\\r\\n}\\r\\n.h-full {\\r\\n  height: 100%;\\r\\n}\\r\\n.min-h-screen {\\r\\n  min-height: 100vh;\\r\\n}\\r\\n.w-10 {\\r\\n  width: 2.5rem;\\r\\n}\\r\\n.w-12 {\\r\\n  width: 3rem;\\r\\n}\\r\\n.w-16 {\\r\\n  width: 4rem;\\r\\n}\\r\\n.w-4 {\\r\\n  width: 1rem;\\r\\n}\\r\\n.w-6 {\\r\\n  width: 1.5rem;\\r\\n}\\r\\n.w-8 {\\r\\n  width: 2rem;\\r\\n}\\r\\n.w-80 {\\r\\n  width: 20rem;\\r\\n}\\r\\n.w-full {\\r\\n  width: 100%;\\r\\n}\\r\\n.max-w-2xl {\\r\\n  max-width: 42rem;\\r\\n}\\r\\n.max-w-md {\\r\\n  max-width: 28rem;\\r\\n}\\r\\n.flex-1 {\\r\\n  flex: 1 1 0%;\\r\\n}\\r\\n.-translate-y-1\\\\/2 {\\r\\n  --tw-translate-y: -50%;\\r\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\r\\n}\\r\\n.translate-x-0 {\\r\\n  --tw-translate-x: 0px;\\r\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\r\\n}\\r\\n.translate-x-full {\\r\\n  --tw-translate-x: 100%;\\r\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\r\\n}\\r\\n.transform {\\r\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\r\\n}\\r\\n@keyframes spin {\\r\\n\\r\\n  to {\\r\\n    transform: rotate(360deg);\\r\\n  }\\r\\n}\\r\\n.animate-spin {\\r\\n  animation: spin 1s linear infinite;\\r\\n}\\r\\n.cursor-not-allowed {\\r\\n  cursor: not-allowed;\\r\\n}\\r\\n.grid-cols-1 {\\r\\n  grid-template-columns: repeat(1, minmax(0, 1fr));\\r\\n}\\r\\n.grid-cols-2 {\\r\\n  grid-template-columns: repeat(2, minmax(0, 1fr));\\r\\n}\\r\\n.grid-cols-3 {\\r\\n  grid-template-columns: repeat(3, minmax(0, 1fr));\\r\\n}\\r\\n.flex-col {\\r\\n  flex-direction: column;\\r\\n}\\r\\n.items-start {\\r\\n  align-items: flex-start;\\r\\n}\\r\\n.items-center {\\r\\n  align-items: center;\\r\\n}\\r\\n.justify-center {\\r\\n  justify-content: center;\\r\\n}\\r\\n.justify-between {\\r\\n  justify-content: space-between;\\r\\n}\\r\\n.gap-2 {\\r\\n  gap: 0.5rem;\\r\\n}\\r\\n.gap-4 {\\r\\n  gap: 1rem;\\r\\n}\\r\\n.gap-6 {\\r\\n  gap: 1.5rem;\\r\\n}\\r\\n.space-x-2 > :not([hidden]) ~ :not([hidden]) {\\r\\n  --tw-space-x-reverse: 0;\\r\\n  margin-right: calc(0.5rem * var(--tw-space-x-reverse));\\r\\n  margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));\\r\\n}\\r\\n.space-x-3 > :not([hidden]) ~ :not([hidden]) {\\r\\n  --tw-space-x-reverse: 0;\\r\\n  margin-right: calc(0.75rem * var(--tw-space-x-reverse));\\r\\n  margin-left: calc(0.75rem * calc(1 - var(--tw-space-x-reverse)));\\r\\n}\\r\\n.space-x-4 > :not([hidden]) ~ :not([hidden]) {\\r\\n  --tw-space-x-reverse: 0;\\r\\n  margin-right: calc(1rem * var(--tw-space-x-reverse));\\r\\n  margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)));\\r\\n}\\r\\n.space-y-1 > :not([hidden]) ~ :not([hidden]) {\\r\\n  --tw-space-y-reverse: 0;\\r\\n  margin-top: calc(0.25rem * calc(1 - var(--tw-space-y-reverse)));\\r\\n  margin-bottom: calc(0.25rem * var(--tw-space-y-reverse));\\r\\n}\\r\\n.space-y-1\\\\.5 > :not([hidden]) ~ :not([hidden]) {\\r\\n  --tw-space-y-reverse: 0;\\r\\n  margin-top: calc(0.375rem * calc(1 - var(--tw-space-y-reverse)));\\r\\n  margin-bottom: calc(0.375rem * var(--tw-space-y-reverse));\\r\\n}\\r\\n.space-y-2 > :not([hidden]) ~ :not([hidden]) {\\r\\n  --tw-space-y-reverse: 0;\\r\\n  margin-top: calc(0.5rem * calc(1 - var(--tw-space-y-reverse)));\\r\\n  margin-bottom: calc(0.5rem * var(--tw-space-y-reverse));\\r\\n}\\r\\n.space-y-3 > :not([hidden]) ~ :not([hidden]) {\\r\\n  --tw-space-y-reverse: 0;\\r\\n  margin-top: calc(0.75rem * calc(1 - var(--tw-space-y-reverse)));\\r\\n  margin-bottom: calc(0.75rem * var(--tw-space-y-reverse));\\r\\n}\\r\\n.space-y-6 > :not([hidden]) ~ :not([hidden]) {\\r\\n  --tw-space-y-reverse: 0;\\r\\n  margin-top: calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));\\r\\n  margin-bottom: calc(1.5rem * var(--tw-space-y-reverse));\\r\\n}\\r\\n.space-y-8 > :not([hidden]) ~ :not([hidden]) {\\r\\n  --tw-space-y-reverse: 0;\\r\\n  margin-top: calc(2rem * calc(1 - var(--tw-space-y-reverse)));\\r\\n  margin-bottom: calc(2rem * var(--tw-space-y-reverse));\\r\\n}\\r\\n.overflow-hidden {\\r\\n  overflow: hidden;\\r\\n}\\r\\n.whitespace-nowrap {\\r\\n  white-space: nowrap;\\r\\n}\\r\\n.rounded-full {\\r\\n  border-radius: 9999px;\\r\\n}\\r\\n.rounded-lg {\\r\\n  border-radius: 0.5rem;\\r\\n}\\r\\n.rounded-md {\\r\\n  border-radius: 0.375rem;\\r\\n}\\r\\n.rounded-xl {\\r\\n  border-radius: 0.75rem;\\r\\n}\\r\\n.border {\\r\\n  border-width: 1px;\\r\\n}\\r\\n.border-0 {\\r\\n  border-width: 0px;\\r\\n}\\r\\n.border-2 {\\r\\n  border-width: 2px;\\r\\n}\\r\\n.border-4 {\\r\\n  border-width: 4px;\\r\\n}\\r\\n.border-b {\\r\\n  border-bottom-width: 1px;\\r\\n}\\r\\n.border-l-4 {\\r\\n  border-left-width: 4px;\\r\\n}\\r\\n.border-blue-200 {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(191 219 254 / var(--tw-border-opacity, 1));\\r\\n}\\r\\n.border-blue-500 {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(59 130 246 / var(--tw-border-opacity, 1));\\r\\n}\\r\\n.border-current {\\r\\n  border-color: currentColor;\\r\\n}\\r\\n.border-gray-200 {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(229 231 235 / var(--tw-border-opacity, 1));\\r\\n}\\r\\n.border-gray-300 {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(209 213 219 / var(--tw-border-opacity, 1));\\r\\n}\\r\\n.border-green-200 {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(187 247 208 / var(--tw-border-opacity, 1));\\r\\n}\\r\\n.border-green-500 {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(34 197 94 / var(--tw-border-opacity, 1));\\r\\n}\\r\\n.border-indigo-200 {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(199 210 254 / var(--tw-border-opacity, 1));\\r\\n}\\r\\n.border-red-200 {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(254 202 202 / var(--tw-border-opacity, 1));\\r\\n}\\r\\n.border-red-500 {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(239 68 68 / var(--tw-border-opacity, 1));\\r\\n}\\r\\n.border-white {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(255 255 255 / var(--tw-border-opacity, 1));\\r\\n}\\r\\n.border-yellow-200 {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(254 240 138 / var(--tw-border-opacity, 1));\\r\\n}\\r\\n.border-t-transparent {\\r\\n  border-top-color: transparent;\\r\\n}\\r\\n.bg-background {\\r\\n  background-color: var(--background);\\r\\n}\\r\\n.bg-black\\\\/50 {\\r\\n  background-color: rgb(0 0 0 / 0.5);\\r\\n}\\r\\n.bg-blue-50 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(239 246 255 / var(--tw-bg-opacity, 1));\\r\\n}\\r\\n.bg-gray-300 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(209 213 219 / var(--tw-bg-opacity, 1));\\r\\n}\\r\\n.bg-gray-400 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(156 163 175 / var(--tw-bg-opacity, 1));\\r\\n}\\r\\n.bg-gray-50 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(249 250 251 / var(--tw-bg-opacity, 1));\\r\\n}\\r\\n.bg-green-50 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(240 253 244 / var(--tw-bg-opacity, 1));\\r\\n}\\r\\n.bg-green-500 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(34 197 94 / var(--tw-bg-opacity, 1));\\r\\n}\\r\\n.bg-purple-50 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(250 245 255 / var(--tw-bg-opacity, 1));\\r\\n}\\r\\n.bg-red-50 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(254 242 242 / var(--tw-bg-opacity, 1));\\r\\n}\\r\\n.bg-red-500 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(239 68 68 / var(--tw-bg-opacity, 1));\\r\\n}\\r\\n.bg-white {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1));\\r\\n}\\r\\n.bg-white\\\\/50 {\\r\\n  background-color: rgb(255 255 255 / 0.5);\\r\\n}\\r\\n.bg-white\\\\/80 {\\r\\n  background-color: rgb(255 255 255 / 0.8);\\r\\n}\\r\\n.bg-yellow-50 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(254 252 232 / var(--tw-bg-opacity, 1));\\r\\n}\\r\\n.bg-gradient-to-br {\\r\\n  background-image: linear-gradient(to bottom right, var(--tw-gradient-stops));\\r\\n}\\r\\n.bg-gradient-to-r {\\r\\n  background-image: linear-gradient(to right, var(--tw-gradient-stops));\\r\\n}\\r\\n.from-blue-50 {\\r\\n  --tw-gradient-from: #eff6ff var(--tw-gradient-from-position);\\r\\n  --tw-gradient-to: rgb(239 246 255 / 0) var(--tw-gradient-to-position);\\r\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\r\\n}\\r\\n.from-blue-500 {\\r\\n  --tw-gradient-from: #3b82f6 var(--tw-gradient-from-position);\\r\\n  --tw-gradient-to: rgb(59 130 246 / 0) var(--tw-gradient-to-position);\\r\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\r\\n}\\r\\n.from-blue-600 {\\r\\n  --tw-gradient-from: #2563eb var(--tw-gradient-from-position);\\r\\n  --tw-gradient-to: rgb(37 99 235 / 0) var(--tw-gradient-to-position);\\r\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\r\\n}\\r\\n.from-green-50 {\\r\\n  --tw-gradient-from: #f0fdf4 var(--tw-gradient-from-position);\\r\\n  --tw-gradient-to: rgb(240 253 244 / 0) var(--tw-gradient-to-position);\\r\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\r\\n}\\r\\n.from-green-500 {\\r\\n  --tw-gradient-from: #22c55e var(--tw-gradient-from-position);\\r\\n  --tw-gradient-to: rgb(34 197 94 / 0) var(--tw-gradient-to-position);\\r\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\r\\n}\\r\\n.from-indigo-50 {\\r\\n  --tw-gradient-from: #eef2ff var(--tw-gradient-from-position);\\r\\n  --tw-gradient-to: rgb(238 242 255 / 0) var(--tw-gradient-to-position);\\r\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\r\\n}\\r\\n.from-purple-500 {\\r\\n  --tw-gradient-from: #a855f7 var(--tw-gradient-from-position);\\r\\n  --tw-gradient-to: rgb(168 85 247 / 0) var(--tw-gradient-to-position);\\r\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\r\\n}\\r\\n.from-red-50 {\\r\\n  --tw-gradient-from: #fef2f2 var(--tw-gradient-from-position);\\r\\n  --tw-gradient-to: rgb(254 242 242 / 0) var(--tw-gradient-to-position);\\r\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\r\\n}\\r\\n.from-red-500 {\\r\\n  --tw-gradient-from: #ef4444 var(--tw-gradient-from-position);\\r\\n  --tw-gradient-to: rgb(239 68 68 / 0) var(--tw-gradient-to-position);\\r\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\r\\n}\\r\\n.from-yellow-500 {\\r\\n  --tw-gradient-from: #eab308 var(--tw-gradient-from-position);\\r\\n  --tw-gradient-to: rgb(234 179 8 / 0) var(--tw-gradient-to-position);\\r\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\r\\n}\\r\\n.via-white {\\r\\n  --tw-gradient-to: rgb(255 255 255 / 0)  var(--tw-gradient-to-position);\\r\\n  --tw-gradient-stops: var(--tw-gradient-from), #fff var(--tw-gradient-via-position), var(--tw-gradient-to);\\r\\n}\\r\\n.to-blue-600 {\\r\\n  --tw-gradient-to: #2563eb var(--tw-gradient-to-position);\\r\\n}\\r\\n.to-cyan-500 {\\r\\n  --tw-gradient-to: #06b6d4 var(--tw-gradient-to-position);\\r\\n}\\r\\n.to-emerald-50 {\\r\\n  --tw-gradient-to: #ecfdf5 var(--tw-gradient-to-position);\\r\\n}\\r\\n.to-green-600 {\\r\\n  --tw-gradient-to: #16a34a var(--tw-gradient-to-position);\\r\\n}\\r\\n.to-orange-50 {\\r\\n  --tw-gradient-to: #fff7ed var(--tw-gradient-to-position);\\r\\n}\\r\\n.to-orange-500 {\\r\\n  --tw-gradient-to: #f97316 var(--tw-gradient-to-position);\\r\\n}\\r\\n.to-pink-500 {\\r\\n  --tw-gradient-to: #ec4899 var(--tw-gradient-to-position);\\r\\n}\\r\\n.to-purple-50 {\\r\\n  --tw-gradient-to: #faf5ff var(--tw-gradient-to-position);\\r\\n}\\r\\n.to-purple-600 {\\r\\n  --tw-gradient-to: #9333ea var(--tw-gradient-to-position);\\r\\n}\\r\\n.to-red-600 {\\r\\n  --tw-gradient-to: #dc2626 var(--tw-gradient-to-position);\\r\\n}\\r\\n.to-rose-50 {\\r\\n  --tw-gradient-to: #fff1f2 var(--tw-gradient-to-position);\\r\\n}\\r\\n.bg-clip-text {\\r\\n  -webkit-background-clip: text;\\r\\n          background-clip: text;\\r\\n}\\r\\n.p-3 {\\r\\n  padding: 0.75rem;\\r\\n}\\r\\n.p-4 {\\r\\n  padding: 1rem;\\r\\n}\\r\\n.p-6 {\\r\\n  padding: 1.5rem;\\r\\n}\\r\\n.px-3 {\\r\\n  padding-left: 0.75rem;\\r\\n  padding-right: 0.75rem;\\r\\n}\\r\\n.px-4 {\\r\\n  padding-left: 1rem;\\r\\n  padding-right: 1rem;\\r\\n}\\r\\n.px-8 {\\r\\n  padding-left: 2rem;\\r\\n  padding-right: 2rem;\\r\\n}\\r\\n.py-12 {\\r\\n  padding-top: 3rem;\\r\\n  padding-bottom: 3rem;\\r\\n}\\r\\n.py-2 {\\r\\n  padding-top: 0.5rem;\\r\\n  padding-bottom: 0.5rem;\\r\\n}\\r\\n.py-4 {\\r\\n  padding-top: 1rem;\\r\\n  padding-bottom: 1rem;\\r\\n}\\r\\n.py-8 {\\r\\n  padding-top: 2rem;\\r\\n  padding-bottom: 2rem;\\r\\n}\\r\\n.pb-3 {\\r\\n  padding-bottom: 0.75rem;\\r\\n}\\r\\n.pb-4 {\\r\\n  padding-bottom: 1rem;\\r\\n}\\r\\n.pr-20 {\\r\\n  padding-right: 5rem;\\r\\n}\\r\\n.pt-0 {\\r\\n  padding-top: 0px;\\r\\n}\\r\\n.text-center {\\r\\n  text-align: center;\\r\\n}\\r\\n.text-right {\\r\\n  text-align: right;\\r\\n}\\r\\n.font-mono {\\r\\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\", \\\"Courier New\\\", monospace;\\r\\n}\\r\\n.text-2xl {\\r\\n  font-size: 1.5rem;\\r\\n  line-height: 2rem;\\r\\n}\\r\\n.text-3xl {\\r\\n  font-size: 1.875rem;\\r\\n  line-height: 2.25rem;\\r\\n}\\r\\n.text-4xl {\\r\\n  font-size: 2.25rem;\\r\\n  line-height: 2.5rem;\\r\\n}\\r\\n.text-lg {\\r\\n  font-size: 1.125rem;\\r\\n  line-height: 1.75rem;\\r\\n}\\r\\n.text-sm {\\r\\n  font-size: 0.875rem;\\r\\n  line-height: 1.25rem;\\r\\n}\\r\\n.text-xl {\\r\\n  font-size: 1.25rem;\\r\\n  line-height: 1.75rem;\\r\\n}\\r\\n.text-xs {\\r\\n  font-size: 0.75rem;\\r\\n  line-height: 1rem;\\r\\n}\\r\\n.font-bold {\\r\\n  font-weight: 700;\\r\\n}\\r\\n.font-medium {\\r\\n  font-weight: 500;\\r\\n}\\r\\n.font-semibold {\\r\\n  font-weight: 600;\\r\\n}\\r\\n.leading-none {\\r\\n  line-height: 1;\\r\\n}\\r\\n.tracking-tight {\\r\\n  letter-spacing: -0.025em;\\r\\n}\\r\\n.text-black {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(0 0 0 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-blue-600 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(37 99 235 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-blue-600\\\\/70 {\\r\\n  color: rgb(37 99 235 / 0.7);\\r\\n}\\r\\n.text-blue-700 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(29 78 216 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-blue-800 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(30 64 175 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-gray-400 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(156 163 175 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-gray-500 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(107 114 128 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-gray-600 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(75 85 99 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-gray-600\\\\/70 {\\r\\n  color: rgb(75 85 99 / 0.7);\\r\\n}\\r\\n.text-gray-700 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(55 65 81 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-gray-800 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(31 41 55 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-gray-900 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(17 24 39 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-green-600 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(22 163 74 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-green-600\\\\/70 {\\r\\n  color: rgb(22 163 74 / 0.7);\\r\\n}\\r\\n.text-green-700 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(21 128 61 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-green-800 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(22 101 52 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-indigo-800 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(55 48 163 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-purple-600 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(147 51 234 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-purple-600\\\\/70 {\\r\\n  color: rgb(147 51 234 / 0.7);\\r\\n}\\r\\n.text-red-500 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(239 68 68 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-red-600 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(220 38 38 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-red-600\\\\/70 {\\r\\n  color: rgb(220 38 38 / 0.7);\\r\\n}\\r\\n.text-red-700 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(185 28 28 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-red-800 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(153 27 27 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-transparent {\\r\\n  color: transparent;\\r\\n}\\r\\n.text-white {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(255 255 255 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-yellow-500 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(234 179 8 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-yellow-600 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(202 138 4 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.text-yellow-800 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(133 77 14 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n.underline-offset-4 {\\r\\n  text-underline-offset: 4px;\\r\\n}\\r\\n.opacity-0 {\\r\\n  opacity: 0;\\r\\n}\\r\\n.opacity-100 {\\r\\n  opacity: 1;\\r\\n}\\r\\n.opacity-75 {\\r\\n  opacity: 0.75;\\r\\n}\\r\\n.shadow-2xl {\\r\\n  --tw-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);\\r\\n  --tw-shadow-colored: 0 25px 50px -12px var(--tw-shadow-color);\\r\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\r\\n}\\r\\n.shadow-lg {\\r\\n  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);\\r\\n  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);\\r\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\r\\n}\\r\\n.shadow-sm {\\r\\n  --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);\\r\\n  --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);\\r\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\r\\n}\\r\\n.outline {\\r\\n  outline-style: solid;\\r\\n}\\r\\n.ring-offset-background {\\r\\n  --tw-ring-offset-color: var(--background);\\r\\n}\\r\\n.filter {\\r\\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\\r\\n}\\r\\n.backdrop-blur-sm {\\r\\n  --tw-backdrop-blur: blur(4px);\\r\\n  backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);\\r\\n}\\r\\n.transition-all {\\r\\n  transition-property: all;\\r\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\r\\n  transition-duration: 150ms;\\r\\n}\\r\\n.transition-colors {\\r\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;\\r\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\r\\n  transition-duration: 150ms;\\r\\n}\\r\\n.duration-300 {\\r\\n  transition-duration: 300ms;\\r\\n}\\r\\n\\r\\n:root {\\r\\n  --foreground-rgb: 0, 0, 0;\\r\\n  --background-start-rgb: 214, 219, 220;\\r\\n  --background-end-rgb: 255, 255, 255;\\r\\n}\\r\\n\\r\\n@media (prefers-color-scheme: dark) {\\r\\n  :root {\\r\\n    --foreground-rgb: 255, 255, 255;\\r\\n    --background-start-rgb: 0, 0, 0;\\r\\n    --background-end-rgb: 0, 0, 0;\\r\\n  }\\r\\n}\\r\\n\\r\\nbody {\\r\\n  color: rgb(var(--foreground-rgb));\\r\\n  background: linear-gradient(\\r\\n      to bottom,\\r\\n      transparent,\\r\\n      rgb(var(--background-end-rgb))\\r\\n    )\\r\\n    rgb(var(--background-start-rgb));\\r\\n}\\r\\n\\r\\n.placeholder\\\\:text-gray-400::-moz-placeholder {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(156 163 175 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n\\r\\n.placeholder\\\\:text-gray-400::placeholder {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(156 163 175 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n\\r\\n.hover\\\\:border-blue-300:hover {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(147 197 253 / var(--tw-border-opacity, 1));\\r\\n}\\r\\n\\r\\n.hover\\\\:bg-blue-50:hover {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(239 246 255 / var(--tw-bg-opacity, 1));\\r\\n}\\r\\n\\r\\n.hover\\\\:bg-green-50:hover {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(240 253 244 / var(--tw-bg-opacity, 1));\\r\\n}\\r\\n\\r\\n.hover\\\\:from-blue-600:hover {\\r\\n  --tw-gradient-from: #2563eb var(--tw-gradient-from-position);\\r\\n  --tw-gradient-to: rgb(37 99 235 / 0) var(--tw-gradient-to-position);\\r\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\r\\n}\\r\\n\\r\\n.hover\\\\:from-green-600:hover {\\r\\n  --tw-gradient-from: #16a34a var(--tw-gradient-from-position);\\r\\n  --tw-gradient-to: rgb(22 163 74 / 0) var(--tw-gradient-to-position);\\r\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\r\\n}\\r\\n\\r\\n.hover\\\\:from-purple-600:hover {\\r\\n  --tw-gradient-from: #9333ea var(--tw-gradient-from-position);\\r\\n  --tw-gradient-to: rgb(147 51 234 / 0) var(--tw-gradient-to-position);\\r\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\r\\n}\\r\\n\\r\\n.hover\\\\:from-red-600:hover {\\r\\n  --tw-gradient-from: #dc2626 var(--tw-gradient-from-position);\\r\\n  --tw-gradient-to: rgb(220 38 38 / 0) var(--tw-gradient-to-position);\\r\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\r\\n}\\r\\n\\r\\n.hover\\\\:to-blue-700:hover {\\r\\n  --tw-gradient-to: #1d4ed8 var(--tw-gradient-to-position);\\r\\n}\\r\\n\\r\\n.hover\\\\:to-green-700:hover {\\r\\n  --tw-gradient-to: #15803d var(--tw-gradient-to-position);\\r\\n}\\r\\n\\r\\n.hover\\\\:to-purple-700:hover {\\r\\n  --tw-gradient-to: #7e22ce var(--tw-gradient-to-position);\\r\\n}\\r\\n\\r\\n.hover\\\\:to-red-700:hover {\\r\\n  --tw-gradient-to: #b91c1c var(--tw-gradient-to-position);\\r\\n}\\r\\n\\r\\n.hover\\\\:text-gray-600:hover {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(75 85 99 / var(--tw-text-opacity, 1));\\r\\n}\\r\\n\\r\\n.hover\\\\:underline:hover {\\r\\n  text-decoration-line: underline;\\r\\n}\\r\\n\\r\\n.hover\\\\:shadow-lg:hover {\\r\\n  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);\\r\\n  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);\\r\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\r\\n}\\r\\n\\r\\n.hover\\\\:shadow-xl:hover {\\r\\n  --tw-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);\\r\\n  --tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);\\r\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\r\\n}\\r\\n\\r\\n.focus\\\\:border-transparent:focus {\\r\\n  border-color: transparent;\\r\\n}\\r\\n\\r\\n.focus\\\\:outline-none:focus {\\r\\n  outline: 2px solid transparent;\\r\\n  outline-offset: 2px;\\r\\n}\\r\\n\\r\\n.focus\\\\:ring-2:focus {\\r\\n  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\\r\\n  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);\\r\\n  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);\\r\\n}\\r\\n\\r\\n.focus\\\\:ring-blue-500:focus {\\r\\n  --tw-ring-opacity: 1;\\r\\n  --tw-ring-color: rgb(59 130 246 / var(--tw-ring-opacity, 1));\\r\\n}\\r\\n\\r\\n.focus-visible\\\\:outline-none:focus-visible {\\r\\n  outline: 2px solid transparent;\\r\\n  outline-offset: 2px;\\r\\n}\\r\\n\\r\\n.focus-visible\\\\:ring-2:focus-visible {\\r\\n  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\\r\\n  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);\\r\\n  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);\\r\\n}\\r\\n\\r\\n.focus-visible\\\\:ring-offset-2:focus-visible {\\r\\n  --tw-ring-offset-width: 2px;\\r\\n}\\r\\n\\r\\n.disabled\\\\:pointer-events-none:disabled {\\r\\n  pointer-events: none;\\r\\n}\\r\\n\\r\\n.disabled\\\\:cursor-not-allowed:disabled {\\r\\n  cursor: not-allowed;\\r\\n}\\r\\n\\r\\n.disabled\\\\:opacity-50:disabled {\\r\\n  opacity: 0.5;\\r\\n}\\r\\n\\r\\n.peer:disabled ~ .peer-disabled\\\\:cursor-not-allowed {\\r\\n  cursor: not-allowed;\\r\\n}\\r\\n\\r\\n.peer:disabled ~ .peer-disabled\\\\:opacity-70 {\\r\\n  opacity: 0.7;\\r\\n}\\r\\n\\r\\n@media (min-width: 640px) {\\r\\n\\r\\n  .sm\\\\:block {\\r\\n    display: block;\\r\\n  }\\r\\n}\\r\\n\\r\\n@media (min-width: 768px) {\\r\\n\\r\\n  .md\\\\:grid-cols-3 {\\r\\n    grid-template-columns: repeat(3, minmax(0, 1fr));\\r\\n  }\\r\\n}\\r\\n\\r\\n@media (min-width: 1024px) {\\r\\n\\r\\n  .lg\\\\:grid-cols-2 {\\r\\n    grid-template-columns: repeat(2, minmax(0, 1fr));\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://src/styles/globals.css\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"@tailwind base;\\r\\n@tailwind components;\\r\\n@tailwind utilities;\\r\\n\\r\\n:root {\\r\\n  --foreground-rgb: 0, 0, 0;\\r\\n  --background-start-rgb: 214, 219, 220;\\r\\n  --background-end-rgb: 255, 255, 255;\\r\\n}\\r\\n\\r\\n@media (prefers-color-scheme: dark) {\\r\\n  :root {\\r\\n    --foreground-rgb: 255, 255, 255;\\r\\n    --background-start-rgb: 0, 0, 0;\\r\\n    --background-end-rgb: 0, 0, 0;\\r\\n  }\\r\\n}\\r\\n\\r\\nbody {\\r\\n  color: rgb(var(--foreground-rgb));\\r\\n  background: linear-gradient(\\r\\n      to bottom,\\r\\n      transparent,\\r\\n      rgb(var(--background-end-rgb))\\r\\n    )\\r\\n    rgb(var(--background-start-rgb));\\r\\n}\\r\\n\\r\\n@layer utilities {\\r\\n  .text-balance {\\r\\n    text-wrap: balance;\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzhdLm9uZU9mWzEzXS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbOF0ub25lT2ZbMTNdLnVzZVsyXSEuL3NyYy9zdHlsZXMvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDMkg7QUFDM0gsOEJBQThCLGtIQUEyQjtBQUN6RDtBQUNBLGdFQUFnRSwrQkFBK0IsK0JBQStCLDBCQUEwQiwwQkFBMEIscUJBQXFCLHFCQUFxQixxQkFBcUIsc0JBQXNCLHNCQUFzQixvQkFBb0Isb0JBQW9CLHlCQUF5Qiw2Q0FBNkMscUNBQXFDLG9DQUFvQyxtQ0FBbUMsc0JBQXNCLDJCQUEyQiw2QkFBNkIsOEJBQThCLCtCQUErQix5QkFBeUIsa0NBQWtDLG1DQUFtQyw2Q0FBNkMseUNBQXlDLGtDQUFrQyw2QkFBNkIscUNBQXFDLG1CQUFtQix5QkFBeUIsdUJBQXVCLHdCQUF3Qix5QkFBeUIscUJBQXFCLHVCQUF1QixvQkFBb0IsMEJBQTBCLDRCQUE0QixrQ0FBa0MsZ0NBQWdDLGlDQUFpQyxrQ0FBa0MsOEJBQThCLCtCQUErQixnQ0FBZ0MsNkJBQTZCLDJCQUEyQiw2QkFBNkIsNEJBQTRCLDRCQUE0QixLQUFLLG9CQUFvQiwrQkFBK0IsK0JBQStCLDBCQUEwQiwwQkFBMEIscUJBQXFCLHFCQUFxQixxQkFBcUIsc0JBQXNCLHNCQUFzQixvQkFBb0Isb0JBQW9CLHlCQUF5Qiw2Q0FBNkMscUNBQXFDLG9DQUFvQyxtQ0FBbUMsc0JBQXNCLDJCQUEyQiw2QkFBNkIsOEJBQThCLCtCQUErQix5QkFBeUIsa0NBQWtDLG1DQUFtQyw2Q0FBNkMs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LFdBQVcsV0FBVyxXQUFXLFdBQVcsS0FBSyxNQUFNLEtBQUssV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLEtBQUssV0FBVyxZQUFZLE1BQU0sT0FBTyxxQkFBcUIsb0JBQW9CLHFCQUFxQixxQkFBcUIsTUFBTSxNQUFNLFdBQVcsTUFBTSxZQUFZLE1BQU0sTUFBTSxxQkFBcUIscUJBQXFCLHFCQUFxQixVQUFVLG9CQUFvQixxQkFBcUIscUJBQXFCLHFCQUFxQixxQkFBcUIsTUFBTSxPQUFPLE1BQU0sS0FBSyxvQkFBb0IscUJBQXFCLE1BQU0sUUFBUSxNQUFNLEtBQUssb0JBQW9CLG9CQUFvQixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLFdBQVcsTUFBTSxNQUFNLE1BQU0sVUFBVSxXQUFXLFdBQVcsTUFBTSxNQUFNLE1BQU0sS0FBSyxVQUFVLFdBQVcsTUFBTSxNQUFNLE1BQU0sTUFBTSxXQUFXLE1BQU0sU0FBUyxNQUFNLFFBQVEscUJBQXFCLHFCQUFxQixxQkFBcUIsb0JBQW9CLE1BQU0sTUFBTSxNQUFNLEtBQUssVUFBVSxNQUFNLE1BQU0sTUFBTSxNQUFNLFVBQVUsVUFBVSxXQUFXLFdBQVcsTUFBTSxLQUFLLFVBQVUsTUFBTSxLQUFLLFVBQVUsTUFBTSxRQUFRLE1BQU0sS0FBSyxvQkFBb0IscUJBQXFCLHFCQUFxQixNQUFNLFFBQVEsTUFBTSxTQUFTLHFCQUFxQixxQkFBcUIscUJBQXFCLG9CQUFvQixxQkFBcUIscUJBQXFCLHFCQUFxQixvQkFBb0Isb0JBQW9CLG9CQUFvQixNQUFNLE1BQU0sTUFBTSxNQUFNLFdBQVcsTUFBTSxPQUFPLE1BQU0sUUFBUSxxQkFBcUIscUJBQXFCLHFCQUFxQixNQUFNLE1BQU0sTUFBTSxLQUFLLFVBQVUsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxNQUFNLE1BQU0sTUFBTSxNQUFNLFVBQVUsTUFBTSxPQUFPLE1BQU0sS0FBSyxxQkFBcUIscUJBQXFCLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxNQUFNLE9BQU8sTUFBTSxLQUFLLHFCQUFxQixvQkFBb0IsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sTUFBTSxNQUFNLGlCQUFpQixVQUFVLE1BQU0sS0FBSyxVQUFVLFVBQVUsTUFBTSxLQUFLLFVBQVUsTUFBTSxPQUFPLFdBQVcsVUFBVSxVQUFVLE1BQU0sTUFBTSxLQUFLLEtBQUssVUFBVSxNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxPQUFPLE1BQU0sS0FBSyxvQkFBb0Isb0JBQW9CLE1BQU0sTUFBTSxvQkFBb0Isb0JBQW9CLE1BQU0sTUFBTSxNQUFNLE1BQU0sVUFBVSxNQUFNLE1BQU0sS0FBSyxLQUFLLFVBQVUsTUFBTSxRQUFRLE1BQU0sWUFBWSxvQkFBb0IscUJBQXFCLE1BQU0sTUFBTSxNQUFNLE1BQU0sVUFBVSxVQUFVLE1BQU0sV0FBVyxLQUFLLFVBQVUsS0FBSyxLQUFLLEtBQUssTUFBTSxPQUFPLEtBQUssS0FBSyxNQUFNLEtBQUssT0FBTyxLQUFLLEtBQUssTUFBTSxLQUFLLE9BQU8sS0FBSyxLQUFLLE1BQU0sS0FBSyxPQUFPLEtBQUssS0FBSyxNQUFNLEtBQUssT0FBTyxLQUFLLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sT0FBTyxLQUFLLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLEtBQUssT0FBTyxNQUFNLFlBQVksYUFBYSxhQUFhLE9BQU8sS0FBSyxLQUFLLFlBQVksYUFBYSxhQUFhLE1BQU0sTUFBTSxLQUFLLFlBQVksVUFBVSxPQUFPLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxhQUFhLE1BQU0sT0FBTyxNQUFNLFlBQVksYUFBYSxNQUFNLE9BQU8sTUFBTSxZQUFZLGFBQWEsTUFBTSxPQUFPLE1BQU0sWUFBWSxhQUFhLE1BQU0sT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sWUFBWSxhQUFhLE1BQU0sT0FBTyxNQUFNLFlBQVksYUFBYSxNQUFNLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksYUFBYSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxhQUFhLE1BQU0sT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxPQUFPLEtBQUssS0FBSyxNQUFNLE1BQU0sT0FBTyxLQUFLLEtBQUssTUFBTSxNQUFNLE9BQU8sS0FBSyxLQUFLLE1BQU0sd0NBQXdDLHlCQUF5Qix3QkFBd0IsZUFBZSxnQ0FBZ0MsNENBQTRDLDBDQUEwQyxLQUFLLDZDQUE2QyxhQUFhLHdDQUF3Qyx3Q0FBd0Msc0NBQXNDLE9BQU8sS0FBSyxjQUFjLHdDQUF3QyxzS0FBc0ssS0FBSywwQkFBMEIscUJBQXFCLDJCQUEyQixPQUFPLEtBQUssK0JBQStCO0FBQ3BtK0M7QUFDQSxpRUFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXHNyY1xcc3R5bGVzXFxnbG9iYWxzLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiKiwgOjpiZWZvcmUsIDo6YWZ0ZXIge1xcclxcbiAgLS10dy1ib3JkZXItc3BhY2luZy14OiAwO1xcclxcbiAgLS10dy1ib3JkZXItc3BhY2luZy15OiAwO1xcclxcbiAgLS10dy10cmFuc2xhdGUteDogMDtcXHJcXG4gIC0tdHctdHJhbnNsYXRlLXk6IDA7XFxyXFxuICAtLXR3LXJvdGF0ZTogMDtcXHJcXG4gIC0tdHctc2tldy14OiAwO1xcclxcbiAgLS10dy1za2V3LXk6IDA7XFxyXFxuICAtLXR3LXNjYWxlLXg6IDE7XFxyXFxuICAtLXR3LXNjYWxlLXk6IDE7XFxyXFxuICAtLXR3LXBhbi14OiAgO1xcclxcbiAgLS10dy1wYW4teTogIDtcXHJcXG4gIC0tdHctcGluY2gtem9vbTogIDtcXHJcXG4gIC0tdHctc2Nyb2xsLXNuYXAtc3RyaWN0bmVzczogcHJveGltaXR5O1xcclxcbiAgLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uOiAgO1xcclxcbiAgLS10dy1ncmFkaWVudC12aWEtcG9zaXRpb246ICA7XFxyXFxuICAtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uOiAgO1xcclxcbiAgLS10dy1vcmRpbmFsOiAgO1xcclxcbiAgLS10dy1zbGFzaGVkLXplcm86ICA7XFxyXFxuICAtLXR3LW51bWVyaWMtZmlndXJlOiAgO1xcclxcbiAgLS10dy1udW1lcmljLXNwYWNpbmc6ICA7XFxyXFxuICAtLXR3LW51bWVyaWMtZnJhY3Rpb246ICA7XFxyXFxuICAtLXR3LXJpbmctaW5zZXQ6ICA7XFxyXFxuICAtLXR3LXJpbmctb2Zmc2V0LXdpZHRoOiAwcHg7XFxyXFxuICAtLXR3LXJpbmctb2Zmc2V0LWNvbG9yOiAjZmZmO1xcclxcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoNTkgMTMwIDI0NiAvIDAuNSk7XFxyXFxuICAtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdzogMCAwICMwMDAwO1xcclxcbiAgLS10dy1yaW5nLXNoYWRvdzogMCAwICMwMDAwO1xcclxcbiAgLS10dy1zaGFkb3c6IDAgMCAjMDAwMDtcXHJcXG4gIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMCAjMDAwMDtcXHJcXG4gIC0tdHctYmx1cjogIDtcXHJcXG4gIC0tdHctYnJpZ2h0bmVzczogIDtcXHJcXG4gIC0tdHctY29udHJhc3Q6ICA7XFxyXFxuICAtLXR3LWdyYXlzY2FsZTogIDtcXHJcXG4gIC0tdHctaHVlLXJvdGF0ZTogIDtcXHJcXG4gIC0tdHctaW52ZXJ0OiAgO1xcclxcbiAgLS10dy1zYXR1cmF0ZTogIDtcXHJcXG4gIC0tdHctc2VwaWE6ICA7XFxyXFxuICAtLXR3LWRyb3Atc2hhZG93OiAgO1xcclxcbiAgLS10dy1iYWNrZHJvcC1ibHVyOiAgO1xcclxcbiAgLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzOiAgO1xcclxcbiAgLS10dy1iYWNrZHJvcC1jb250cmFzdDogIDtcXHJcXG4gIC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlOiAgO1xcclxcbiAgLS10dy1iYWNrZHJvcC1odWUtcm90YXRlOiAgO1xcclxcbiAgLS10dy1iYWNrZHJvcC1pbnZlcnQ6ICA7XFxyXFxuICAtLXR3LWJhY2tkcm9wLW9wYWNpdHk6ICA7XFxyXFxuICAtLXR3LWJhY2tkcm9wLXNhdHVyYXRlOiAgO1xcclxcbiAgLS10dy1iYWNrZHJvcC1zZXBpYTogIDtcXHJcXG4gIC0tdHctY29udGFpbi1zaXplOiAgO1xcclxcbiAgLS10dy1jb250YWluLWxheW91dDogIDtcXHJcXG4gIC0tdHctY29udGFpbi1wYWludDogIDtcXHJcXG4gIC0tdHctY29udGFpbi1zdHlsZTogIDtcXHJcXG59XFxyXFxuXFxyXFxuOjpiYWNrZHJvcCB7XFxyXFxuICAtLXR3LWJvcmRlci1zcGFjaW5nLXg6IDA7XFxyXFxuICAtLXR3LWJvcmRlci1zcGFjaW5nLXk6IDA7XFxyXFxuICAtLXR3LXRyYW5zbGF0ZS14OiAwO1xcclxcbiAgLS10dy10cmFuc2xhdGUteTogMDtcXHJcXG4gIC0tdHctcm90YXRlOiAwO1xcclxcbiAgLS10dy1za2V3LXg6IDA7XFxyXFxuICAtLXR3LXNrZXcteTogMDtcXHJcXG4gIC0tdHctc2NhbGUteDogMTtcXHJcXG4gIC0tdHctc2NhbGUteTogMTtcXHJcXG4gIC0tdHctcGFuLXg6ICA7XFxyXFxuICAtLXR3LXBhbi15OiAgO1xcclxcbiAgLS10dy1waW5jaC16b29tOiAgO1xcclxcbiAgLS10dy1zY3JvbGwtc25hcC1zdHJpY3RuZXNzOiBwcm94aW1pdHk7XFxyXFxuICAtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb246ICA7XFxyXFxuICAtLXR3LWdyYWRpZW50LXZpYS1wb3NpdGlvbjogIDtcXHJcXG4gIC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb246ICA7XFxyXFxuICAtLXR3LW9yZGluYWw6ICA7XFxyXFxuICAtLXR3LXNsYXNoZWQtemVybzogIDtcXHJcXG4gIC0tdHctbnVtZXJpYy1maWd1cmU6ICA7XFxyXFxuICAtLXR3LW51bWVyaWMtc3BhY2luZzogIDtcXHJcXG4gIC0tdHctbnVtZXJpYy1mcmFjdGlvbjogIDtcXHJcXG4gIC0tdHctcmluZy1pbnNldDogIDtcXHJcXG4gIC0tdHctcmluZy1vZmZzZXQtd2lkdGg6IDBweDtcXHJcXG4gIC0tdHctcmluZy1vZmZzZXQtY29sb3I6ICNmZmY7XFxyXFxuICAtLXR3LXJpbmctY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gMC41KTtcXHJcXG4gIC0tdHctcmluZy1vZmZzZXQtc2hhZG93OiAwIDAgIzAwMDA7XFxyXFxuICAtLXR3LXJpbmctc2hhZG93OiAwIDAgIzAwMDA7XFxyXFxuICAtLXR3LXNoYWRvdzogMCAwICMwMDAwO1xcclxcbiAgLS10dy1zaGFkb3ctY29sb3JlZDogMCAwICMwMDAwO1xcclxcbiAgLS10dy1ibHVyOiAgO1xcclxcbiAgLS10dy1icmlnaHRuZXNzOiAgO1xcclxcbiAgLS10dy1jb250cmFzdDogIDtcXHJcXG4gIC0tdHctZ3JheXNjYWxlOiAgO1xcclxcbiAgLS10dy1odWUtcm90YXRlOiAgO1xcclxcbiAgLS10dy1pbnZlcnQ6ICA7XFxyXFxuICAtLXR3LXNhdHVyYXRlOiAgO1xcclxcbiAgLS10dy1zZXBpYTogIDtcXHJcXG4gIC0tdHctZHJvcC1zaGFkb3c6ICA7XFxyXFxuICAtLXR3LWJhY2tkcm9wLWJsdXI6ICA7XFxyXFxuICAtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3M6ICA7XFxyXFxuICAtLXR3LWJhY2tkcm9wLWNvbnRyYXN0OiAgO1xcclxcbiAgLS10dy1iYWNrZHJvcC1ncmF5c2NhbGU6ICA7XFxyXFxuICAtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGU6ICA7XFxyXFxuICAtLXR3LWJhY2tkcm9wLWludmVydDogIDtcXHJcXG4gIC0tdHctYmFja2Ryb3Atb3BhY2l0eTogIDtcXHJcXG4gIC0tdHctYmFja2Ryb3Atc2F0dXJhdGU6ICA7XFxyXFxuICAtLXR3LWJhY2tkcm9wLXNlcGlhOiAgO1xcclxcbiAgLS10dy1jb250YWluLXNpemU6ICA7XFxyXFxuICAtLXR3LWNvbnRhaW4tbGF5b3V0OiAgO1xcclxcbiAgLS10dy1jb250YWluLXBhaW50OiAgO1xcclxcbiAgLS10dy1jb250YWluLXN0eWxlOiAgO1xcclxcbn0vKlxcclxcbiEgdGFpbHdpbmRjc3MgdjMuNC4xNyB8IE1JVCBMaWNlbnNlIHwgaHR0cHM6Ly90YWlsd2luZGNzcy5jb21cXHJcXG4qLy8qXFxyXFxuMS4gUHJldmVudCBwYWRkaW5nIGFuZCBib3JkZXIgZnJvbSBhZmZlY3RpbmcgZWxlbWVudCB3aWR0aC4gKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3pkZXZzL2Nzc3JlbWVkeS9pc3N1ZXMvNClcXHJcXG4yLiBBbGxvdyBhZGRpbmcgYSBib3JkZXIgdG8gYW4gZWxlbWVudCBieSBqdXN0IGFkZGluZyBhIGJvcmRlci13aWR0aC4gKGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGNzcy90YWlsd2luZGNzcy9wdWxsLzExNilcXHJcXG4qL1xcclxcblxcclxcbiosXFxyXFxuOjpiZWZvcmUsXFxyXFxuOjphZnRlciB7XFxyXFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyAvKiAxICovXFxyXFxuICBib3JkZXItd2lkdGg6IDA7IC8qIDIgKi9cXHJcXG4gIGJvcmRlci1zdHlsZTogc29saWQ7IC8qIDIgKi9cXHJcXG4gIGJvcmRlci1jb2xvcjogI2U1ZTdlYjsgLyogMiAqL1xcclxcbn1cXHJcXG5cXHJcXG46OmJlZm9yZSxcXHJcXG46OmFmdGVyIHtcXHJcXG4gIC0tdHctY29udGVudDogJyc7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuMS4gVXNlIGEgY29uc2lzdGVudCBzZW5zaWJsZSBsaW5lLWhlaWdodCBpbiBhbGwgYnJvd3NlcnMuXFxyXFxuMi4gUHJldmVudCBhZGp1c3RtZW50cyBvZiBmb250IHNpemUgYWZ0ZXIgb3JpZW50YXRpb24gY2hhbmdlcyBpbiBpT1MuXFxyXFxuMy4gVXNlIGEgbW9yZSByZWFkYWJsZSB0YWIgc2l6ZS5cXHJcXG40LiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIGBzYW5zYCBmb250LWZhbWlseSBieSBkZWZhdWx0LlxcclxcbjUuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYHNhbnNgIGZvbnQtZmVhdHVyZS1zZXR0aW5ncyBieSBkZWZhdWx0LlxcclxcbjYuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYHNhbnNgIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzIGJ5IGRlZmF1bHQuXFxyXFxuNy4gRGlzYWJsZSB0YXAgaGlnaGxpZ2h0cyBvbiBpT1NcXHJcXG4qL1xcclxcblxcclxcbmh0bWwsXFxyXFxuOmhvc3Qge1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuNTsgLyogMSAqL1xcclxcbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlOyAvKiAyICovXFxyXFxuICAtbW96LXRhYi1zaXplOiA0OyAvKiAzICovXFxyXFxuICAtby10YWItc2l6ZTogNDtcXHJcXG4gICAgIHRhYi1zaXplOiA0OyAvKiAzICovXFxyXFxuICBmb250LWZhbWlseTogdWktc2Fucy1zZXJpZiwgc3lzdGVtLXVpLCBzYW5zLXNlcmlmLCBcXFwiQXBwbGUgQ29sb3IgRW1vamlcXFwiLCBcXFwiU2Vnb2UgVUkgRW1vamlcXFwiLCBcXFwiU2Vnb2UgVUkgU3ltYm9sXFxcIiwgXFxcIk5vdG8gQ29sb3IgRW1vamlcXFwiOyAvKiA0ICovXFxyXFxuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IG5vcm1hbDsgLyogNSAqL1xcclxcbiAgZm9udC12YXJpYXRpb24tc2V0dGluZ3M6IG5vcm1hbDsgLyogNiAqL1xcclxcbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDsgLyogNyAqL1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbjEuIFJlbW92ZSB0aGUgbWFyZ2luIGluIGFsbCBicm93c2Vycy5cXHJcXG4yLiBJbmhlcml0IGxpbmUtaGVpZ2h0IGZyb20gYGh0bWxgIHNvIHVzZXJzIGNhbiBzZXQgdGhlbSBhcyBhIGNsYXNzIGRpcmVjdGx5IG9uIHRoZSBgaHRtbGAgZWxlbWVudC5cXHJcXG4qL1xcclxcblxcclxcbmJvZHkge1xcclxcbiAgbWFyZ2luOiAwOyAvKiAxICovXFxyXFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgLyogMiAqL1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbjEuIEFkZCB0aGUgY29ycmVjdCBoZWlnaHQgaW4gRmlyZWZveC5cXHJcXG4yLiBDb3JyZWN0IHRoZSBpbmhlcml0YW5jZSBvZiBib3JkZXIgY29sb3IgaW4gRmlyZWZveC4gKGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE5MDY1NSlcXHJcXG4zLiBFbnN1cmUgaG9yaXpvbnRhbCBydWxlcyBhcmUgdmlzaWJsZSBieSBkZWZhdWx0LlxcclxcbiovXFxyXFxuXFxyXFxuaHIge1xcclxcbiAgaGVpZ2h0OiAwOyAvKiAxICovXFxyXFxuICBjb2xvcjogaW5oZXJpdDsgLyogMiAqL1xcclxcbiAgYm9yZGVyLXRvcC13aWR0aDogMXB4OyAvKiAzICovXFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuQWRkIHRoZSBjb3JyZWN0IHRleHQgZGVjb3JhdGlvbiBpbiBDaHJvbWUsIEVkZ2UsIGFuZCBTYWZhcmkuXFxyXFxuKi9cXHJcXG5cXHJcXG5hYmJyOndoZXJlKFt0aXRsZV0pIHtcXHJcXG4gIC13ZWJraXQtdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcclxcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuUmVtb3ZlIHRoZSBkZWZhdWx0IGZvbnQgc2l6ZSBhbmQgd2VpZ2h0IGZvciBoZWFkaW5ncy5cXHJcXG4qL1xcclxcblxcclxcbmgxLFxcclxcbmgyLFxcclxcbmgzLFxcclxcbmg0LFxcclxcbmg1LFxcclxcbmg2IHtcXHJcXG4gIGZvbnQtc2l6ZTogaW5oZXJpdDtcXHJcXG4gIGZvbnQtd2VpZ2h0OiBpbmhlcml0O1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcblJlc2V0IGxpbmtzIHRvIG9wdGltaXplIGZvciBvcHQtaW4gc3R5bGluZyBpbnN0ZWFkIG9mIG9wdC1vdXQuXFxyXFxuKi9cXHJcXG5cXHJcXG5hIHtcXHJcXG4gIGNvbG9yOiBpbmhlcml0O1xcclxcbiAgdGV4dC1kZWNvcmF0aW9uOiBpbmhlcml0O1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbkFkZCB0aGUgY29ycmVjdCBmb250IHdlaWdodCBpbiBFZGdlIGFuZCBTYWZhcmkuXFxyXFxuKi9cXHJcXG5cXHJcXG5iLFxcclxcbnN0cm9uZyB7XFxyXFxuICBmb250LXdlaWdodDogYm9sZGVyO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbjEuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYG1vbm9gIGZvbnQtZmFtaWx5IGJ5IGRlZmF1bHQuXFxyXFxuMi4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBgbW9ub2AgZm9udC1mZWF0dXJlLXNldHRpbmdzIGJ5IGRlZmF1bHQuXFxyXFxuMy4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBgbW9ub2AgZm9udC12YXJpYXRpb24tc2V0dGluZ3MgYnkgZGVmYXVsdC5cXHJcXG40LiBDb3JyZWN0IHRoZSBvZGQgYGVtYCBmb250IHNpemluZyBpbiBhbGwgYnJvd3NlcnMuXFxyXFxuKi9cXHJcXG5cXHJcXG5jb2RlLFxcclxcbmtiZCxcXHJcXG5zYW1wLFxcclxcbnByZSB7XFxyXFxuICBmb250LWZhbWlseTogdWktbW9ub3NwYWNlLCBTRk1vbm8tUmVndWxhciwgTWVubG8sIE1vbmFjbywgQ29uc29sYXMsIFxcXCJMaWJlcmF0aW9uIE1vbm9cXFwiLCBcXFwiQ291cmllciBOZXdcXFwiLCBtb25vc3BhY2U7IC8qIDEgKi9cXHJcXG4gIGZvbnQtZmVhdHVyZS1zZXR0aW5nczogbm9ybWFsOyAvKiAyICovXFxyXFxuICBmb250LXZhcmlhdGlvbi1zZXR0aW5nczogbm9ybWFsOyAvKiAzICovXFxyXFxuICBmb250LXNpemU6IDFlbTsgLyogNCAqL1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbkFkZCB0aGUgY29ycmVjdCBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxcclxcbiovXFxyXFxuXFxyXFxuc21hbGwge1xcclxcbiAgZm9udC1zaXplOiA4MCU7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuUHJldmVudCBgc3ViYCBhbmQgYHN1cGAgZWxlbWVudHMgZnJvbSBhZmZlY3RpbmcgdGhlIGxpbmUgaGVpZ2h0IGluIGFsbCBicm93c2Vycy5cXHJcXG4qL1xcclxcblxcclxcbnN1YixcXHJcXG5zdXAge1xcclxcbiAgZm9udC1zaXplOiA3NSU7XFxyXFxuICBsaW5lLWhlaWdodDogMDtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXHJcXG59XFxyXFxuXFxyXFxuc3ViIHtcXHJcXG4gIGJvdHRvbTogLTAuMjVlbTtcXHJcXG59XFxyXFxuXFxyXFxuc3VwIHtcXHJcXG4gIHRvcDogLTAuNWVtO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbjEuIFJlbW92ZSB0ZXh0IGluZGVudGF0aW9uIGZyb20gdGFibGUgY29udGVudHMgaW4gQ2hyb21lIGFuZCBTYWZhcmkuIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05OTkwODgsIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDEyOTcpXFxyXFxuMi4gQ29ycmVjdCB0YWJsZSBib3JkZXIgY29sb3IgaW5oZXJpdGFuY2UgaW4gYWxsIENocm9tZSBhbmQgU2FmYXJpLiAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTM1NzI5LCBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTk1MDE2KVxcclxcbjMuIFJlbW92ZSBnYXBzIGJldHdlZW4gdGFibGUgYm9yZGVycyBieSBkZWZhdWx0LlxcclxcbiovXFxyXFxuXFxyXFxudGFibGUge1xcclxcbiAgdGV4dC1pbmRlbnQ6IDA7IC8qIDEgKi9cXHJcXG4gIGJvcmRlci1jb2xvcjogaW5oZXJpdDsgLyogMiAqL1xcclxcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTsgLyogMyAqL1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbjEuIENoYW5nZSB0aGUgZm9udCBzdHlsZXMgaW4gYWxsIGJyb3dzZXJzLlxcclxcbjIuIFJlbW92ZSB0aGUgbWFyZ2luIGluIEZpcmVmb3ggYW5kIFNhZmFyaS5cXHJcXG4zLiBSZW1vdmUgZGVmYXVsdCBwYWRkaW5nIGluIGFsbCBicm93c2Vycy5cXHJcXG4qL1xcclxcblxcclxcbmJ1dHRvbixcXHJcXG5pbnB1dCxcXHJcXG5vcHRncm91cCxcXHJcXG5zZWxlY3QsXFxyXFxudGV4dGFyZWEge1xcclxcbiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7IC8qIDEgKi9cXHJcXG4gIGZvbnQtZmVhdHVyZS1zZXR0aW5nczogaW5oZXJpdDsgLyogMSAqL1xcclxcbiAgZm9udC12YXJpYXRpb24tc2V0dGluZ3M6IGluaGVyaXQ7IC8qIDEgKi9cXHJcXG4gIGZvbnQtc2l6ZTogMTAwJTsgLyogMSAqL1xcclxcbiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7IC8qIDEgKi9cXHJcXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyAvKiAxICovXFxyXFxuICBsZXR0ZXItc3BhY2luZzogaW5oZXJpdDsgLyogMSAqL1xcclxcbiAgY29sb3I6IGluaGVyaXQ7IC8qIDEgKi9cXHJcXG4gIG1hcmdpbjogMDsgLyogMiAqL1xcclxcbiAgcGFkZGluZzogMDsgLyogMyAqL1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcblJlbW92ZSB0aGUgaW5oZXJpdGFuY2Ugb2YgdGV4dCB0cmFuc2Zvcm0gaW4gRWRnZSBhbmQgRmlyZWZveC5cXHJcXG4qL1xcclxcblxcclxcbmJ1dHRvbixcXHJcXG5zZWxlY3Qge1xcclxcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuMS4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXHJcXG4yLiBSZW1vdmUgZGVmYXVsdCBidXR0b24gc3R5bGVzLlxcclxcbiovXFxyXFxuXFxyXFxuYnV0dG9uLFxcclxcbmlucHV0OndoZXJlKFt0eXBlPSdidXR0b24nXSksXFxyXFxuaW5wdXQ6d2hlcmUoW3R5cGU9J3Jlc2V0J10pLFxcclxcbmlucHV0OndoZXJlKFt0eXBlPSdzdWJtaXQnXSkge1xcclxcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247IC8qIDEgKi9cXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyAvKiAyICovXFxyXFxuICBiYWNrZ3JvdW5kLWltYWdlOiBub25lOyAvKiAyICovXFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuVXNlIHRoZSBtb2Rlcm4gRmlyZWZveCBmb2N1cyBzdHlsZSBmb3IgYWxsIGZvY3VzYWJsZSBlbGVtZW50cy5cXHJcXG4qL1xcclxcblxcclxcbjotbW96LWZvY3VzcmluZyB7XFxyXFxuICBvdXRsaW5lOiBhdXRvO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcblJlbW92ZSB0aGUgYWRkaXRpb25hbCBgOmludmFsaWRgIHN0eWxlcyBpbiBGaXJlZm94LiAoaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvZ2Vja28tZGV2L2Jsb2IvMmY5ZWFjZDlkM2Q5OTVjOTM3YjQyNTFhNTU1N2Q5NWQ0OTRjOWJlMS9sYXlvdXQvc3R5bGUvcmVzL2Zvcm1zLmNzcyNMNzI4LUw3MzcpXFxyXFxuKi9cXHJcXG5cXHJcXG46LW1vei11aS1pbnZhbGlkIHtcXHJcXG4gIGJveC1zaGFkb3c6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuQWRkIHRoZSBjb3JyZWN0IHZlcnRpY2FsIGFsaWdubWVudCBpbiBDaHJvbWUgYW5kIEZpcmVmb3guXFxyXFxuKi9cXHJcXG5cXHJcXG5wcm9ncmVzcyB7XFxyXFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuQ29ycmVjdCB0aGUgY3Vyc29yIHN0eWxlIG9mIGluY3JlbWVudCBhbmQgZGVjcmVtZW50IGJ1dHRvbnMgaW4gU2FmYXJpLlxcclxcbiovXFxyXFxuXFxyXFxuOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFxcclxcbjo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XFxyXFxuICBoZWlnaHQ6IGF1dG87XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuMS4gQ29ycmVjdCB0aGUgb2RkIGFwcGVhcmFuY2UgaW4gQ2hyb21lIGFuZCBTYWZhcmkuXFxyXFxuMi4gQ29ycmVjdCB0aGUgb3V0bGluZSBzdHlsZSBpbiBTYWZhcmkuXFxyXFxuKi9cXHJcXG5cXHJcXG5bdHlwZT0nc2VhcmNoJ10ge1xcclxcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7IC8qIDEgKi9cXHJcXG4gIG91dGxpbmUtb2Zmc2V0OiAtMnB4OyAvKiAyICovXFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuUmVtb3ZlIHRoZSBpbm5lciBwYWRkaW5nIGluIENocm9tZSBhbmQgU2FmYXJpIG9uIG1hY09TLlxcclxcbiovXFxyXFxuXFxyXFxuOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcXHJcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG4xLiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxcclxcbjIuIENoYW5nZSBmb250IHByb3BlcnRpZXMgdG8gYGluaGVyaXRgIGluIFNhZmFyaS5cXHJcXG4qL1xcclxcblxcclxcbjo6LXdlYmtpdC1maWxlLXVwbG9hZC1idXR0b24ge1xcclxcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247IC8qIDEgKi9cXHJcXG4gIGZvbnQ6IGluaGVyaXQ7IC8qIDIgKi9cXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG5BZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBDaHJvbWUgYW5kIFNhZmFyaS5cXHJcXG4qL1xcclxcblxcclxcbnN1bW1hcnkge1xcclxcbiAgZGlzcGxheTogbGlzdC1pdGVtO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcblJlbW92ZXMgdGhlIGRlZmF1bHQgc3BhY2luZyBhbmQgYm9yZGVyIGZvciBhcHByb3ByaWF0ZSBlbGVtZW50cy5cXHJcXG4qL1xcclxcblxcclxcbmJsb2NrcXVvdGUsXFxyXFxuZGwsXFxyXFxuZGQsXFxyXFxuaDEsXFxyXFxuaDIsXFxyXFxuaDMsXFxyXFxuaDQsXFxyXFxuaDUsXFxyXFxuaDYsXFxyXFxuaHIsXFxyXFxuZmlndXJlLFxcclxcbnAsXFxyXFxucHJlIHtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG59XFxyXFxuXFxyXFxuZmllbGRzZXQge1xcclxcbiAgbWFyZ2luOiAwO1xcclxcbiAgcGFkZGluZzogMDtcXHJcXG59XFxyXFxuXFxyXFxubGVnZW5kIHtcXHJcXG4gIHBhZGRpbmc6IDA7XFxyXFxufVxcclxcblxcclxcbm9sLFxcclxcbnVsLFxcclxcbm1lbnUge1xcclxcbiAgbGlzdC1zdHlsZTogbm9uZTtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG4gIHBhZGRpbmc6IDA7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuUmVzZXQgZGVmYXVsdCBzdHlsaW5nIGZvciBkaWFsb2dzLlxcclxcbiovXFxyXFxuZGlhbG9nIHtcXHJcXG4gIHBhZGRpbmc6IDA7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuUHJldmVudCByZXNpemluZyB0ZXh0YXJlYXMgaG9yaXpvbnRhbGx5IGJ5IGRlZmF1bHQuXFxyXFxuKi9cXHJcXG5cXHJcXG50ZXh0YXJlYSB7XFxyXFxuICByZXNpemU6IHZlcnRpY2FsO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbjEuIFJlc2V0IHRoZSBkZWZhdWx0IHBsYWNlaG9sZGVyIG9wYWNpdHkgaW4gRmlyZWZveC4gKGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGxhYnMvdGFpbHdpbmRjc3MvaXNzdWVzLzMzMDApXFxyXFxuMi4gU2V0IHRoZSBkZWZhdWx0IHBsYWNlaG9sZGVyIGNvbG9yIHRvIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBncmF5IDQwMCBjb2xvci5cXHJcXG4qL1xcclxcblxcclxcbmlucHV0OjotbW96LXBsYWNlaG9sZGVyLCB0ZXh0YXJlYTo6LW1vei1wbGFjZWhvbGRlciB7XFxyXFxuICBvcGFjaXR5OiAxOyAvKiAxICovXFxyXFxuICBjb2xvcjogIzljYTNhZjsgLyogMiAqL1xcclxcbn1cXHJcXG5cXHJcXG5pbnB1dDo6cGxhY2Vob2xkZXIsXFxyXFxudGV4dGFyZWE6OnBsYWNlaG9sZGVyIHtcXHJcXG4gIG9wYWNpdHk6IDE7IC8qIDEgKi9cXHJcXG4gIGNvbG9yOiAjOWNhM2FmOyAvKiAyICovXFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuU2V0IHRoZSBkZWZhdWx0IGN1cnNvciBmb3IgYnV0dG9ucy5cXHJcXG4qL1xcclxcblxcclxcbmJ1dHRvbixcXHJcXG5bcm9sZT1cXFwiYnV0dG9uXFxcIl0ge1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbk1ha2Ugc3VyZSBkaXNhYmxlZCBidXR0b25zIGRvbid0IGdldCB0aGUgcG9pbnRlciBjdXJzb3IuXFxyXFxuKi9cXHJcXG46ZGlzYWJsZWQge1xcclxcbiAgY3Vyc29yOiBkZWZhdWx0O1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbjEuIE1ha2UgcmVwbGFjZWQgZWxlbWVudHMgYGRpc3BsYXk6IGJsb2NrYCBieSBkZWZhdWx0LiAoaHR0cHM6Ly9naXRodWIuY29tL21vemRldnMvY3NzcmVtZWR5L2lzc3Vlcy8xNClcXHJcXG4yLiBBZGQgYHZlcnRpY2FsLWFsaWduOiBtaWRkbGVgIHRvIGFsaWduIHJlcGxhY2VkIGVsZW1lbnRzIG1vcmUgc2Vuc2libHkgYnkgZGVmYXVsdC4gKGh0dHBzOi8vZ2l0aHViLmNvbS9qZW5zaW1tb25zL2Nzc3JlbWVkeS9pc3N1ZXMvMTQjaXNzdWVjb21tZW50LTYzNDkzNDIxMClcXHJcXG4gICBUaGlzIGNhbiB0cmlnZ2VyIGEgcG9vcmx5IGNvbnNpZGVyZWQgbGludCBlcnJvciBpbiBzb21lIHRvb2xzIGJ1dCBpcyBpbmNsdWRlZCBieSBkZXNpZ24uXFxyXFxuKi9cXHJcXG5cXHJcXG5pbWcsXFxyXFxuc3ZnLFxcclxcbnZpZGVvLFxcclxcbmNhbnZhcyxcXHJcXG5hdWRpbyxcXHJcXG5pZnJhbWUsXFxyXFxuZW1iZWQsXFxyXFxub2JqZWN0IHtcXHJcXG4gIGRpc3BsYXk6IGJsb2NrOyAvKiAxICovXFxyXFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyAvKiAyICovXFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuQ29uc3RyYWluIGltYWdlcyBhbmQgdmlkZW9zIHRvIHRoZSBwYXJlbnQgd2lkdGggYW5kIHByZXNlcnZlIHRoZWlyIGludHJpbnNpYyBhc3BlY3QgcmF0aW8uIChodHRwczovL2dpdGh1Yi5jb20vbW96ZGV2cy9jc3NyZW1lZHkvaXNzdWVzLzE0KVxcclxcbiovXFxyXFxuXFxyXFxuaW1nLFxcclxcbnZpZGVvIHtcXHJcXG4gIG1heC13aWR0aDogMTAwJTtcXHJcXG4gIGhlaWdodDogYXV0bztcXHJcXG59XFxyXFxuXFxyXFxuLyogTWFrZSBlbGVtZW50cyB3aXRoIHRoZSBIVE1MIGhpZGRlbiBhdHRyaWJ1dGUgc3RheSBoaWRkZW4gYnkgZGVmYXVsdCAqL1xcclxcbltoaWRkZW5dOndoZXJlKDpub3QoW2hpZGRlbj1cXFwidW50aWwtZm91bmRcXFwiXSkpIHtcXHJcXG4gIGRpc3BsYXk6IG5vbmU7XFxyXFxufVxcclxcbi5jb250YWluZXIge1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxufVxcclxcbkBtZWRpYSAobWluLXdpZHRoOiA2NDBweCkge1xcclxcblxcclxcbiAgLmNvbnRhaW5lciB7XFxyXFxuICAgIG1heC13aWR0aDogNjQwcHg7XFxyXFxuICB9XFxyXFxufVxcclxcbkBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkge1xcclxcblxcclxcbiAgLmNvbnRhaW5lciB7XFxyXFxuICAgIG1heC13aWR0aDogNzY4cHg7XFxyXFxuICB9XFxyXFxufVxcclxcbkBtZWRpYSAobWluLXdpZHRoOiAxMDI0cHgpIHtcXHJcXG5cXHJcXG4gIC5jb250YWluZXIge1xcclxcbiAgICBtYXgtd2lkdGg6IDEwMjRweDtcXHJcXG4gIH1cXHJcXG59XFxyXFxuQG1lZGlhIChtaW4td2lkdGg6IDEyODBweCkge1xcclxcblxcclxcbiAgLmNvbnRhaW5lciB7XFxyXFxuICAgIG1heC13aWR0aDogMTI4MHB4O1xcclxcbiAgfVxcclxcbn1cXHJcXG5AbWVkaWEgKG1pbi13aWR0aDogMTUzNnB4KSB7XFxyXFxuXFxyXFxuICAuY29udGFpbmVyIHtcXHJcXG4gICAgbWF4LXdpZHRoOiAxNTM2cHg7XFxyXFxuICB9XFxyXFxufVxcclxcbi5maXhlZCB7XFxyXFxuICBwb3NpdGlvbjogZml4ZWQ7XFxyXFxufVxcclxcbi5hYnNvbHV0ZSB7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxufVxcclxcbi5yZWxhdGl2ZSB7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxufVxcclxcbi5zdGlja3kge1xcclxcbiAgcG9zaXRpb246IHN0aWNreTtcXHJcXG59XFxyXFxuLmluc2V0LTAge1xcclxcbiAgaW5zZXQ6IDBweDtcXHJcXG59XFxyXFxuLnJpZ2h0LTIge1xcclxcbiAgcmlnaHQ6IDAuNXJlbTtcXHJcXG59XFxyXFxuLnJpZ2h0LTQge1xcclxcbiAgcmlnaHQ6IDFyZW07XFxyXFxufVxcclxcbi50b3AtMCB7XFxyXFxuICB0b3A6IDBweDtcXHJcXG59XFxyXFxuLnRvcC0xXFxcXC8yIHtcXHJcXG4gIHRvcDogNTAlO1xcclxcbn1cXHJcXG4udG9wLTQge1xcclxcbiAgdG9wOiAxcmVtO1xcclxcbn1cXHJcXG4uei01MCB7XFxyXFxuICB6LWluZGV4OiA1MDtcXHJcXG59XFxyXFxuLm14LWF1dG8ge1xcclxcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XFxyXFxuICBtYXJnaW4tcmlnaHQ6IGF1dG87XFxyXFxufVxcclxcbi5tYi0xIHtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDAuMjVyZW07XFxyXFxufVxcclxcbi5tYi0yIHtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXHJcXG59XFxyXFxuLm1iLTQge1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXHJcXG59XFxyXFxuLm1iLTYge1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMS41cmVtO1xcclxcbn1cXHJcXG4ubXQtMSB7XFxyXFxuICBtYXJnaW4tdG9wOiAwLjI1cmVtO1xcclxcbn1cXHJcXG4ubXQtMiB7XFxyXFxuICBtYXJnaW4tdG9wOiAwLjVyZW07XFxyXFxufVxcclxcbi5tdC0zIHtcXHJcXG4gIG1hcmdpbi10b3A6IDAuNzVyZW07XFxyXFxufVxcclxcbi5mbGV4IHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxufVxcclxcbi5pbmxpbmUtZmxleCB7XFxyXFxuICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcXHJcXG59XFxyXFxuLmdyaWQge1xcclxcbiAgZGlzcGxheTogZ3JpZDtcXHJcXG59XFxyXFxuLmhpZGRlbiB7XFxyXFxuICBkaXNwbGF5OiBub25lO1xcclxcbn1cXHJcXG4uaC0xMCB7XFxyXFxuICBoZWlnaHQ6IDIuNXJlbTtcXHJcXG59XFxyXFxuLmgtMTEge1xcclxcbiAgaGVpZ2h0OiAyLjc1cmVtO1xcclxcbn1cXHJcXG4uaC0xMiB7XFxyXFxuICBoZWlnaHQ6IDNyZW07XFxyXFxufVxcclxcbi5oLTE2IHtcXHJcXG4gIGhlaWdodDogNHJlbTtcXHJcXG59XFxyXFxuLmgtNCB7XFxyXFxuICBoZWlnaHQ6IDFyZW07XFxyXFxufVxcclxcbi5oLTYge1xcclxcbiAgaGVpZ2h0OiAxLjVyZW07XFxyXFxufVxcclxcbi5oLTgge1xcclxcbiAgaGVpZ2h0OiAycmVtO1xcclxcbn1cXHJcXG4uaC04MCB7XFxyXFxuICBoZWlnaHQ6IDIwcmVtO1xcclxcbn1cXHJcXG4uaC05IHtcXHJcXG4gIGhlaWdodDogMi4yNXJlbTtcXHJcXG59XFxyXFxuLmgtZnVsbCB7XFxyXFxuICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcbi5taW4taC1zY3JlZW4ge1xcclxcbiAgbWluLWhlaWdodDogMTAwdmg7XFxyXFxufVxcclxcbi53LTEwIHtcXHJcXG4gIHdpZHRoOiAyLjVyZW07XFxyXFxufVxcclxcbi53LTEyIHtcXHJcXG4gIHdpZHRoOiAzcmVtO1xcclxcbn1cXHJcXG4udy0xNiB7XFxyXFxuICB3aWR0aDogNHJlbTtcXHJcXG59XFxyXFxuLnctNCB7XFxyXFxuICB3aWR0aDogMXJlbTtcXHJcXG59XFxyXFxuLnctNiB7XFxyXFxuICB3aWR0aDogMS41cmVtO1xcclxcbn1cXHJcXG4udy04IHtcXHJcXG4gIHdpZHRoOiAycmVtO1xcclxcbn1cXHJcXG4udy04MCB7XFxyXFxuICB3aWR0aDogMjByZW07XFxyXFxufVxcclxcbi53LWZ1bGwge1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxufVxcclxcbi5tYXgtdy0yeGwge1xcclxcbiAgbWF4LXdpZHRoOiA0MnJlbTtcXHJcXG59XFxyXFxuLm1heC13LW1kIHtcXHJcXG4gIG1heC13aWR0aDogMjhyZW07XFxyXFxufVxcclxcbi5mbGV4LTEge1xcclxcbiAgZmxleDogMSAxIDAlO1xcclxcbn1cXHJcXG4uLXRyYW5zbGF0ZS15LTFcXFxcLzIge1xcclxcbiAgLS10dy10cmFuc2xhdGUteTogLTUwJTtcXHJcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKHZhcigtLXR3LXRyYW5zbGF0ZS14KSwgdmFyKC0tdHctdHJhbnNsYXRlLXkpKSByb3RhdGUodmFyKC0tdHctcm90YXRlKSkgc2tld1godmFyKC0tdHctc2tldy14KSkgc2tld1kodmFyKC0tdHctc2tldy15KSkgc2NhbGVYKHZhcigtLXR3LXNjYWxlLXgpKSBzY2FsZVkodmFyKC0tdHctc2NhbGUteSkpO1xcclxcbn1cXHJcXG4udHJhbnNsYXRlLXgtMCB7XFxyXFxuICAtLXR3LXRyYW5zbGF0ZS14OiAwcHg7XFxyXFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSh2YXIoLS10dy10cmFuc2xhdGUteCksIHZhcigtLXR3LXRyYW5zbGF0ZS15KSkgcm90YXRlKHZhcigtLXR3LXJvdGF0ZSkpIHNrZXdYKHZhcigtLXR3LXNrZXcteCkpIHNrZXdZKHZhcigtLXR3LXNrZXcteSkpIHNjYWxlWCh2YXIoLS10dy1zY2FsZS14KSkgc2NhbGVZKHZhcigtLXR3LXNjYWxlLXkpKTtcXHJcXG59XFxyXFxuLnRyYW5zbGF0ZS14LWZ1bGwge1xcclxcbiAgLS10dy10cmFuc2xhdGUteDogMTAwJTtcXHJcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKHZhcigtLXR3LXRyYW5zbGF0ZS14KSwgdmFyKC0tdHctdHJhbnNsYXRlLXkpKSByb3RhdGUodmFyKC0tdHctcm90YXRlKSkgc2tld1godmFyKC0tdHctc2tldy14KSkgc2tld1kodmFyKC0tdHctc2tldy15KSkgc2NhbGVYKHZhcigtLXR3LXNjYWxlLXgpKSBzY2FsZVkodmFyKC0tdHctc2NhbGUteSkpO1xcclxcbn1cXHJcXG4udHJhbnNmb3JtIHtcXHJcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKHZhcigtLXR3LXRyYW5zbGF0ZS14KSwgdmFyKC0tdHctdHJhbnNsYXRlLXkpKSByb3RhdGUodmFyKC0tdHctcm90YXRlKSkgc2tld1godmFyKC0tdHctc2tldy14KSkgc2tld1kodmFyKC0tdHctc2tldy15KSkgc2NhbGVYKHZhcigtLXR3LXNjYWxlLXgpKSBzY2FsZVkodmFyKC0tdHctc2NhbGUteSkpO1xcclxcbn1cXHJcXG5Aa2V5ZnJhbWVzIHNwaW4ge1xcclxcblxcclxcbiAgdG8ge1xcclxcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcclxcbiAgfVxcclxcbn1cXHJcXG4uYW5pbWF0ZS1zcGluIHtcXHJcXG4gIGFuaW1hdGlvbjogc3BpbiAxcyBsaW5lYXIgaW5maW5pdGU7XFxyXFxufVxcclxcbi5jdXJzb3Itbm90LWFsbG93ZWQge1xcclxcbiAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXHJcXG59XFxyXFxuLmdyaWQtY29scy0xIHtcXHJcXG4gIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDEsIG1pbm1heCgwLCAxZnIpKTtcXHJcXG59XFxyXFxuLmdyaWQtY29scy0yIHtcXHJcXG4gIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDIsIG1pbm1heCgwLCAxZnIpKTtcXHJcXG59XFxyXFxuLmdyaWQtY29scy0zIHtcXHJcXG4gIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDMsIG1pbm1heCgwLCAxZnIpKTtcXHJcXG59XFxyXFxuLmZsZXgtY29sIHtcXHJcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxufVxcclxcbi5pdGVtcy1zdGFydCB7XFxyXFxuICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcXHJcXG59XFxyXFxuLml0ZW1zLWNlbnRlciB7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbn1cXHJcXG4uanVzdGlmeS1jZW50ZXIge1xcclxcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxufVxcclxcbi5qdXN0aWZ5LWJldHdlZW4ge1xcclxcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcclxcbn1cXHJcXG4uZ2FwLTIge1xcclxcbiAgZ2FwOiAwLjVyZW07XFxyXFxufVxcclxcbi5nYXAtNCB7XFxyXFxuICBnYXA6IDFyZW07XFxyXFxufVxcclxcbi5nYXAtNiB7XFxyXFxuICBnYXA6IDEuNXJlbTtcXHJcXG59XFxyXFxuLnNwYWNlLXgtMiA+IDpub3QoW2hpZGRlbl0pIH4gOm5vdChbaGlkZGVuXSkge1xcclxcbiAgLS10dy1zcGFjZS14LXJldmVyc2U6IDA7XFxyXFxuICBtYXJnaW4tcmlnaHQ6IGNhbGMoMC41cmVtICogdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSk7XFxyXFxuICBtYXJnaW4tbGVmdDogY2FsYygwLjVyZW0gKiBjYWxjKDEgLSB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKSk7XFxyXFxufVxcclxcbi5zcGFjZS14LTMgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXHJcXG4gIC0tdHctc3BhY2UteC1yZXZlcnNlOiAwO1xcclxcbiAgbWFyZ2luLXJpZ2h0OiBjYWxjKDAuNzVyZW0gKiB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKTtcXHJcXG4gIG1hcmdpbi1sZWZ0OiBjYWxjKDAuNzVyZW0gKiBjYWxjKDEgLSB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKSk7XFxyXFxufVxcclxcbi5zcGFjZS14LTQgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXHJcXG4gIC0tdHctc3BhY2UteC1yZXZlcnNlOiAwO1xcclxcbiAgbWFyZ2luLXJpZ2h0OiBjYWxjKDFyZW0gKiB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKTtcXHJcXG4gIG1hcmdpbi1sZWZ0OiBjYWxjKDFyZW0gKiBjYWxjKDEgLSB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKSk7XFxyXFxufVxcclxcbi5zcGFjZS15LTEgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXHJcXG4gIC0tdHctc3BhY2UteS1yZXZlcnNlOiAwO1xcclxcbiAgbWFyZ2luLXRvcDogY2FsYygwLjI1cmVtICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSkpO1xcclxcbiAgbWFyZ2luLWJvdHRvbTogY2FsYygwLjI1cmVtICogdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSk7XFxyXFxufVxcclxcbi5zcGFjZS15LTFcXFxcLjUgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXHJcXG4gIC0tdHctc3BhY2UteS1yZXZlcnNlOiAwO1xcclxcbiAgbWFyZ2luLXRvcDogY2FsYygwLjM3NXJlbSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpKTtcXHJcXG4gIG1hcmdpbi1ib3R0b206IGNhbGMoMC4zNzVyZW0gKiB2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKTtcXHJcXG59XFxyXFxuLnNwYWNlLXktMiA+IDpub3QoW2hpZGRlbl0pIH4gOm5vdChbaGlkZGVuXSkge1xcclxcbiAgLS10dy1zcGFjZS15LXJldmVyc2U6IDA7XFxyXFxuICBtYXJnaW4tdG9wOiBjYWxjKDAuNXJlbSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpKTtcXHJcXG4gIG1hcmdpbi1ib3R0b206IGNhbGMoMC41cmVtICogdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSk7XFxyXFxufVxcclxcbi5zcGFjZS15LTMgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXHJcXG4gIC0tdHctc3BhY2UteS1yZXZlcnNlOiAwO1xcclxcbiAgbWFyZ2luLXRvcDogY2FsYygwLjc1cmVtICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSkpO1xcclxcbiAgbWFyZ2luLWJvdHRvbTogY2FsYygwLjc1cmVtICogdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSk7XFxyXFxufVxcclxcbi5zcGFjZS15LTYgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXHJcXG4gIC0tdHctc3BhY2UteS1yZXZlcnNlOiAwO1xcclxcbiAgbWFyZ2luLXRvcDogY2FsYygxLjVyZW0gKiBjYWxjKDEgLSB2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKSk7XFxyXFxuICBtYXJnaW4tYm90dG9tOiBjYWxjKDEuNXJlbSAqIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpO1xcclxcbn1cXHJcXG4uc3BhY2UteS04ID4gOm5vdChbaGlkZGVuXSkgfiA6bm90KFtoaWRkZW5dKSB7XFxyXFxuICAtLXR3LXNwYWNlLXktcmV2ZXJzZTogMDtcXHJcXG4gIG1hcmdpbi10b3A6IGNhbGMoMnJlbSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpKTtcXHJcXG4gIG1hcmdpbi1ib3R0b206IGNhbGMoMnJlbSAqIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpO1xcclxcbn1cXHJcXG4ub3ZlcmZsb3ctaGlkZGVuIHtcXHJcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxyXFxufVxcclxcbi53aGl0ZXNwYWNlLW5vd3JhcCB7XFxyXFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcclxcbn1cXHJcXG4ucm91bmRlZC1mdWxsIHtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDk5OTlweDtcXHJcXG59XFxyXFxuLnJvdW5kZWQtbGcge1xcclxcbiAgYm9yZGVyLXJhZGl1czogMC41cmVtO1xcclxcbn1cXHJcXG4ucm91bmRlZC1tZCB7XFxyXFxuICBib3JkZXItcmFkaXVzOiAwLjM3NXJlbTtcXHJcXG59XFxyXFxuLnJvdW5kZWQteGwge1xcclxcbiAgYm9yZGVyLXJhZGl1czogMC43NXJlbTtcXHJcXG59XFxyXFxuLmJvcmRlciB7XFxyXFxuICBib3JkZXItd2lkdGg6IDFweDtcXHJcXG59XFxyXFxuLmJvcmRlci0wIHtcXHJcXG4gIGJvcmRlci13aWR0aDogMHB4O1xcclxcbn1cXHJcXG4uYm9yZGVyLTIge1xcclxcbiAgYm9yZGVyLXdpZHRoOiAycHg7XFxyXFxufVxcclxcbi5ib3JkZXItNCB7XFxyXFxuICBib3JkZXItd2lkdGg6IDRweDtcXHJcXG59XFxyXFxuLmJvcmRlci1iIHtcXHJcXG4gIGJvcmRlci1ib3R0b20td2lkdGg6IDFweDtcXHJcXG59XFxyXFxuLmJvcmRlci1sLTQge1xcclxcbiAgYm9yZGVyLWxlZnQtd2lkdGg6IDRweDtcXHJcXG59XFxyXFxuLmJvcmRlci1ibHVlLTIwMCB7XFxyXFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcclxcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMTkxIDIxOSAyNTQgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSwgMSkpO1xcclxcbn1cXHJcXG4uYm9yZGVyLWJsdWUtNTAwIHtcXHJcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxyXFxuICBib3JkZXItY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuLmJvcmRlci1jdXJyZW50IHtcXHJcXG4gIGJvcmRlci1jb2xvcjogY3VycmVudENvbG9yO1xcclxcbn1cXHJcXG4uYm9yZGVyLWdyYXktMjAwIHtcXHJcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxyXFxuICBib3JkZXItY29sb3I6IHJnYigyMjkgMjMxIDIzNSAvIHZhcigtLXR3LWJvcmRlci1vcGFjaXR5LCAxKSk7XFxyXFxufVxcclxcbi5ib3JkZXItZ3JheS0zMDAge1xcclxcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXHJcXG4gIGJvcmRlci1jb2xvcjogcmdiKDIwOSAyMTMgMjE5IC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuLmJvcmRlci1ncmVlbi0yMDAge1xcclxcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXHJcXG4gIGJvcmRlci1jb2xvcjogcmdiKDE4NyAyNDcgMjA4IC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuLmJvcmRlci1ncmVlbi01MDAge1xcclxcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXHJcXG4gIGJvcmRlci1jb2xvcjogcmdiKDM0IDE5NyA5NCAvIHZhcigtLXR3LWJvcmRlci1vcGFjaXR5LCAxKSk7XFxyXFxufVxcclxcbi5ib3JkZXItaW5kaWdvLTIwMCB7XFxyXFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcclxcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMTk5IDIxMCAyNTQgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSwgMSkpO1xcclxcbn1cXHJcXG4uYm9yZGVyLXJlZC0yMDAge1xcclxcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXHJcXG4gIGJvcmRlci1jb2xvcjogcmdiKDI1NCAyMDIgMjAyIC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuLmJvcmRlci1yZWQtNTAwIHtcXHJcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxyXFxuICBib3JkZXItY29sb3I6IHJnYigyMzkgNjggNjggLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSwgMSkpO1xcclxcbn1cXHJcXG4uYm9yZGVyLXdoaXRlIHtcXHJcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxyXFxuICBib3JkZXItY29sb3I6IHJnYigyNTUgMjU1IDI1NSAvIHZhcigtLXR3LWJvcmRlci1vcGFjaXR5LCAxKSk7XFxyXFxufVxcclxcbi5ib3JkZXIteWVsbG93LTIwMCB7XFxyXFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcclxcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMjU0IDI0MCAxMzggLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSwgMSkpO1xcclxcbn1cXHJcXG4uYm9yZGVyLXQtdHJhbnNwYXJlbnQge1xcclxcbiAgYm9yZGVyLXRvcC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxyXFxufVxcclxcbi5iZy1iYWNrZ3JvdW5kIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWJhY2tncm91bmQpO1xcclxcbn1cXHJcXG4uYmctYmxhY2tcXFxcLzUwIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigwIDAgMCAvIDAuNSk7XFxyXFxufVxcclxcbi5iZy1ibHVlLTUwIHtcXHJcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMzkgMjQ2IDI1NSAvIHZhcigtLXR3LWJnLW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuLmJnLWdyYXktMzAwIHtcXHJcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMDkgMjEzIDIxOSAvIHZhcigtLXR3LWJnLW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuLmJnLWdyYXktNDAwIHtcXHJcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigxNTYgMTYzIDE3NSAvIHZhcigtLXR3LWJnLW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuLmJnLWdyYXktNTAge1xcclxcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI0OSAyNTAgMjUxIC8gdmFyKC0tdHctYmctb3BhY2l0eSwgMSkpO1xcclxcbn1cXHJcXG4uYmctZ3JlZW4tNTAge1xcclxcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI0MCAyNTMgMjQ0IC8gdmFyKC0tdHctYmctb3BhY2l0eSwgMSkpO1xcclxcbn1cXHJcXG4uYmctZ3JlZW4tNTAwIHtcXHJcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigzNCAxOTcgOTQgLyB2YXIoLS10dy1iZy1vcGFjaXR5LCAxKSk7XFxyXFxufVxcclxcbi5iZy1wdXJwbGUtNTAge1xcclxcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1MCAyNDUgMjU1IC8gdmFyKC0tdHctYmctb3BhY2l0eSwgMSkpO1xcclxcbn1cXHJcXG4uYmctcmVkLTUwIHtcXHJcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNTQgMjQyIDI0MiAvIHZhcigtLXR3LWJnLW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuLmJnLXJlZC01MDAge1xcclxcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIzOSA2OCA2OCAvIHZhcigtLXR3LWJnLW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuLmJnLXdoaXRlIHtcXHJcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNTUgMjU1IDI1NSAvIHZhcigtLXR3LWJnLW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuLmJnLXdoaXRlXFxcXC81MCB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjU1IDI1NSAyNTUgLyAwLjUpO1xcclxcbn1cXHJcXG4uYmctd2hpdGVcXFxcLzgwIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNTUgMjU1IDI1NSAvIDAuOCk7XFxyXFxufVxcclxcbi5iZy15ZWxsb3ctNTAge1xcclxcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1NCAyNTIgMjMyIC8gdmFyKC0tdHctYmctb3BhY2l0eSwgMSkpO1xcclxcbn1cXHJcXG4uYmctZ3JhZGllbnQtdG8tYnIge1xcclxcbiAgYmFja2dyb3VuZC1pbWFnZTogbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSByaWdodCwgdmFyKC0tdHctZ3JhZGllbnQtc3RvcHMpKTtcXHJcXG59XFxyXFxuLmJnLWdyYWRpZW50LXRvLXIge1xcclxcbiAgYmFja2dyb3VuZC1pbWFnZTogbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCB2YXIoLS10dy1ncmFkaWVudC1zdG9wcykpO1xcclxcbn1cXHJcXG4uZnJvbS1ibHVlLTUwIHtcXHJcXG4gIC0tdHctZ3JhZGllbnQtZnJvbTogI2VmZjZmZiB2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKTtcXHJcXG4gIC0tdHctZ3JhZGllbnQtdG86IHJnYigyMzkgMjQ2IDI1NSAvIDApIHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTtcXHJcXG4gIC0tdHctZ3JhZGllbnQtc3RvcHM6IHZhcigtLXR3LWdyYWRpZW50LWZyb20pLCB2YXIoLS10dy1ncmFkaWVudC10byk7XFxyXFxufVxcclxcbi5mcm9tLWJsdWUtNTAwIHtcXHJcXG4gIC0tdHctZ3JhZGllbnQtZnJvbTogIzNiODJmNiB2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKTtcXHJcXG4gIC0tdHctZ3JhZGllbnQtdG86IHJnYig1OSAxMzAgMjQ2IC8gMCkgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pO1xcclxcbiAgLS10dy1ncmFkaWVudC1zdG9wczogdmFyKC0tdHctZ3JhZGllbnQtZnJvbSksIHZhcigtLXR3LWdyYWRpZW50LXRvKTtcXHJcXG59XFxyXFxuLmZyb20tYmx1ZS02MDAge1xcclxcbiAgLS10dy1ncmFkaWVudC1mcm9tOiAjMjU2M2ViIHZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pO1xcclxcbiAgLS10dy1ncmFkaWVudC10bzogcmdiKDM3IDk5IDIzNSAvIDApIHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTtcXHJcXG4gIC0tdHctZ3JhZGllbnQtc3RvcHM6IHZhcigtLXR3LWdyYWRpZW50LWZyb20pLCB2YXIoLS10dy1ncmFkaWVudC10byk7XFxyXFxufVxcclxcbi5mcm9tLWdyZWVuLTUwIHtcXHJcXG4gIC0tdHctZ3JhZGllbnQtZnJvbTogI2YwZmRmNCB2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKTtcXHJcXG4gIC0tdHctZ3JhZGllbnQtdG86IHJnYigyNDAgMjUzIDI0NCAvIDApIHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTtcXHJcXG4gIC0tdHctZ3JhZGllbnQtc3RvcHM6IHZhcigtLXR3LWdyYWRpZW50LWZyb20pLCB2YXIoLS10dy1ncmFkaWVudC10byk7XFxyXFxufVxcclxcbi5mcm9tLWdyZWVuLTUwMCB7XFxyXFxuICAtLXR3LWdyYWRpZW50LWZyb206ICMyMmM1NWUgdmFyKC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbik7XFxyXFxuICAtLXR3LWdyYWRpZW50LXRvOiByZ2IoMzQgMTk3IDk0IC8gMCkgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pO1xcclxcbiAgLS10dy1ncmFkaWVudC1zdG9wczogdmFyKC0tdHctZ3JhZGllbnQtZnJvbSksIHZhcigtLXR3LWdyYWRpZW50LXRvKTtcXHJcXG59XFxyXFxuLmZyb20taW5kaWdvLTUwIHtcXHJcXG4gIC0tdHctZ3JhZGllbnQtZnJvbTogI2VlZjJmZiB2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKTtcXHJcXG4gIC0tdHctZ3JhZGllbnQtdG86IHJnYigyMzggMjQyIDI1NSAvIDApIHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTtcXHJcXG4gIC0tdHctZ3JhZGllbnQtc3RvcHM6IHZhcigtLXR3LWdyYWRpZW50LWZyb20pLCB2YXIoLS10dy1ncmFkaWVudC10byk7XFxyXFxufVxcclxcbi5mcm9tLXB1cnBsZS01MDAge1xcclxcbiAgLS10dy1ncmFkaWVudC1mcm9tOiAjYTg1NWY3IHZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pO1xcclxcbiAgLS10dy1ncmFkaWVudC10bzogcmdiKDE2OCA4NSAyNDcgLyAwKSB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbik7XFxyXFxuICAtLXR3LWdyYWRpZW50LXN0b3BzOiB2YXIoLS10dy1ncmFkaWVudC1mcm9tKSwgdmFyKC0tdHctZ3JhZGllbnQtdG8pO1xcclxcbn1cXHJcXG4uZnJvbS1yZWQtNTAge1xcclxcbiAgLS10dy1ncmFkaWVudC1mcm9tOiAjZmVmMmYyIHZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pO1xcclxcbiAgLS10dy1ncmFkaWVudC10bzogcmdiKDI1NCAyNDIgMjQyIC8gMCkgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pO1xcclxcbiAgLS10dy1ncmFkaWVudC1zdG9wczogdmFyKC0tdHctZ3JhZGllbnQtZnJvbSksIHZhcigtLXR3LWdyYWRpZW50LXRvKTtcXHJcXG59XFxyXFxuLmZyb20tcmVkLTUwMCB7XFxyXFxuICAtLXR3LWdyYWRpZW50LWZyb206ICNlZjQ0NDQgdmFyKC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbik7XFxyXFxuICAtLXR3LWdyYWRpZW50LXRvOiByZ2IoMjM5IDY4IDY4IC8gMCkgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pO1xcclxcbiAgLS10dy1ncmFkaWVudC1zdG9wczogdmFyKC0tdHctZ3JhZGllbnQtZnJvbSksIHZhcigtLXR3LWdyYWRpZW50LXRvKTtcXHJcXG59XFxyXFxuLmZyb20teWVsbG93LTUwMCB7XFxyXFxuICAtLXR3LWdyYWRpZW50LWZyb206ICNlYWIzMDggdmFyKC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbik7XFxyXFxuICAtLXR3LWdyYWRpZW50LXRvOiByZ2IoMjM0IDE3OSA4IC8gMCkgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pO1xcclxcbiAgLS10dy1ncmFkaWVudC1zdG9wczogdmFyKC0tdHctZ3JhZGllbnQtZnJvbSksIHZhcigtLXR3LWdyYWRpZW50LXRvKTtcXHJcXG59XFxyXFxuLnZpYS13aGl0ZSB7XFxyXFxuICAtLXR3LWdyYWRpZW50LXRvOiByZ2IoMjU1IDI1NSAyNTUgLyAwKSAgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pO1xcclxcbiAgLS10dy1ncmFkaWVudC1zdG9wczogdmFyKC0tdHctZ3JhZGllbnQtZnJvbSksICNmZmYgdmFyKC0tdHctZ3JhZGllbnQtdmlhLXBvc2l0aW9uKSwgdmFyKC0tdHctZ3JhZGllbnQtdG8pO1xcclxcbn1cXHJcXG4udG8tYmx1ZS02MDAge1xcclxcbiAgLS10dy1ncmFkaWVudC10bzogIzI1NjNlYiB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbik7XFxyXFxufVxcclxcbi50by1jeWFuLTUwMCB7XFxyXFxuICAtLXR3LWdyYWRpZW50LXRvOiAjMDZiNmQ0IHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTtcXHJcXG59XFxyXFxuLnRvLWVtZXJhbGQtNTAge1xcclxcbiAgLS10dy1ncmFkaWVudC10bzogI2VjZmRmNSB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbik7XFxyXFxufVxcclxcbi50by1ncmVlbi02MDAge1xcclxcbiAgLS10dy1ncmFkaWVudC10bzogIzE2YTM0YSB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbik7XFxyXFxufVxcclxcbi50by1vcmFuZ2UtNTAge1xcclxcbiAgLS10dy1ncmFkaWVudC10bzogI2ZmZjdlZCB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbik7XFxyXFxufVxcclxcbi50by1vcmFuZ2UtNTAwIHtcXHJcXG4gIC0tdHctZ3JhZGllbnQtdG86ICNmOTczMTYgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pO1xcclxcbn1cXHJcXG4udG8tcGluay01MDAge1xcclxcbiAgLS10dy1ncmFkaWVudC10bzogI2VjNDg5OSB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbik7XFxyXFxufVxcclxcbi50by1wdXJwbGUtNTAge1xcclxcbiAgLS10dy1ncmFkaWVudC10bzogI2ZhZjVmZiB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbik7XFxyXFxufVxcclxcbi50by1wdXJwbGUtNjAwIHtcXHJcXG4gIC0tdHctZ3JhZGllbnQtdG86ICM5MzMzZWEgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pO1xcclxcbn1cXHJcXG4udG8tcmVkLTYwMCB7XFxyXFxuICAtLXR3LWdyYWRpZW50LXRvOiAjZGMyNjI2IHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTtcXHJcXG59XFxyXFxuLnRvLXJvc2UtNTAge1xcclxcbiAgLS10dy1ncmFkaWVudC10bzogI2ZmZjFmMiB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbik7XFxyXFxufVxcclxcbi5iZy1jbGlwLXRleHQge1xcclxcbiAgLXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XFxyXFxuICAgICAgICAgIGJhY2tncm91bmQtY2xpcDogdGV4dDtcXHJcXG59XFxyXFxuLnAtMyB7XFxyXFxuICBwYWRkaW5nOiAwLjc1cmVtO1xcclxcbn1cXHJcXG4ucC00IHtcXHJcXG4gIHBhZGRpbmc6IDFyZW07XFxyXFxufVxcclxcbi5wLTYge1xcclxcbiAgcGFkZGluZzogMS41cmVtO1xcclxcbn1cXHJcXG4ucHgtMyB7XFxyXFxuICBwYWRkaW5nLWxlZnQ6IDAuNzVyZW07XFxyXFxuICBwYWRkaW5nLXJpZ2h0OiAwLjc1cmVtO1xcclxcbn1cXHJcXG4ucHgtNCB7XFxyXFxuICBwYWRkaW5nLWxlZnQ6IDFyZW07XFxyXFxuICBwYWRkaW5nLXJpZ2h0OiAxcmVtO1xcclxcbn1cXHJcXG4ucHgtOCB7XFxyXFxuICBwYWRkaW5nLWxlZnQ6IDJyZW07XFxyXFxuICBwYWRkaW5nLXJpZ2h0OiAycmVtO1xcclxcbn1cXHJcXG4ucHktMTIge1xcclxcbiAgcGFkZGluZy10b3A6IDNyZW07XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogM3JlbTtcXHJcXG59XFxyXFxuLnB5LTIge1xcclxcbiAgcGFkZGluZy10b3A6IDAuNXJlbTtcXHJcXG4gIHBhZGRpbmctYm90dG9tOiAwLjVyZW07XFxyXFxufVxcclxcbi5weS00IHtcXHJcXG4gIHBhZGRpbmctdG9wOiAxcmVtO1xcclxcbiAgcGFkZGluZy1ib3R0b206IDFyZW07XFxyXFxufVxcclxcbi5weS04IHtcXHJcXG4gIHBhZGRpbmctdG9wOiAycmVtO1xcclxcbiAgcGFkZGluZy1ib3R0b206IDJyZW07XFxyXFxufVxcclxcbi5wYi0zIHtcXHJcXG4gIHBhZGRpbmctYm90dG9tOiAwLjc1cmVtO1xcclxcbn1cXHJcXG4ucGItNCB7XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogMXJlbTtcXHJcXG59XFxyXFxuLnByLTIwIHtcXHJcXG4gIHBhZGRpbmctcmlnaHQ6IDVyZW07XFxyXFxufVxcclxcbi5wdC0wIHtcXHJcXG4gIHBhZGRpbmctdG9wOiAwcHg7XFxyXFxufVxcclxcbi50ZXh0LWNlbnRlciB7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxufVxcclxcbi50ZXh0LXJpZ2h0IHtcXHJcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcclxcbn1cXHJcXG4uZm9udC1tb25vIHtcXHJcXG4gIGZvbnQtZmFtaWx5OiB1aS1tb25vc3BhY2UsIFNGTW9uby1SZWd1bGFyLCBNZW5sbywgTW9uYWNvLCBDb25zb2xhcywgXFxcIkxpYmVyYXRpb24gTW9ub1xcXCIsIFxcXCJDb3VyaWVyIE5ld1xcXCIsIG1vbm9zcGFjZTtcXHJcXG59XFxyXFxuLnRleHQtMnhsIHtcXHJcXG4gIGZvbnQtc2l6ZTogMS41cmVtO1xcclxcbiAgbGluZS1oZWlnaHQ6IDJyZW07XFxyXFxufVxcclxcbi50ZXh0LTN4bCB7XFxyXFxuICBmb250LXNpemU6IDEuODc1cmVtO1xcclxcbiAgbGluZS1oZWlnaHQ6IDIuMjVyZW07XFxyXFxufVxcclxcbi50ZXh0LTR4bCB7XFxyXFxuICBmb250LXNpemU6IDIuMjVyZW07XFxyXFxuICBsaW5lLWhlaWdodDogMi41cmVtO1xcclxcbn1cXHJcXG4udGV4dC1sZyB7XFxyXFxuICBmb250LXNpemU6IDEuMTI1cmVtO1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuNzVyZW07XFxyXFxufVxcclxcbi50ZXh0LXNtIHtcXHJcXG4gIGZvbnQtc2l6ZTogMC44NzVyZW07XFxyXFxuICBsaW5lLWhlaWdodDogMS4yNXJlbTtcXHJcXG59XFxyXFxuLnRleHQteGwge1xcclxcbiAgZm9udC1zaXplOiAxLjI1cmVtO1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuNzVyZW07XFxyXFxufVxcclxcbi50ZXh0LXhzIHtcXHJcXG4gIGZvbnQtc2l6ZTogMC43NXJlbTtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxcmVtO1xcclxcbn1cXHJcXG4uZm9udC1ib2xkIHtcXHJcXG4gIGZvbnQtd2VpZ2h0OiA3MDA7XFxyXFxufVxcclxcbi5mb250LW1lZGl1bSB7XFxyXFxuICBmb250LXdlaWdodDogNTAwO1xcclxcbn1cXHJcXG4uZm9udC1zZW1pYm9sZCB7XFxyXFxuICBmb250LXdlaWdodDogNjAwO1xcclxcbn1cXHJcXG4ubGVhZGluZy1ub25lIHtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxO1xcclxcbn1cXHJcXG4udHJhY2tpbmctdGlnaHQge1xcclxcbiAgbGV0dGVyLXNwYWNpbmc6IC0wLjAyNWVtO1xcclxcbn1cXHJcXG4udGV4dC1ibGFjayB7XFxyXFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXHJcXG4gIGNvbG9yOiByZ2IoMCAwIDAgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuLnRleHQtYmx1ZS02MDAge1xcclxcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxyXFxuICBjb2xvcjogcmdiKDM3IDk5IDIzNSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSwgMSkpO1xcclxcbn1cXHJcXG4udGV4dC1ibHVlLTYwMFxcXFwvNzAge1xcclxcbiAgY29sb3I6IHJnYigzNyA5OSAyMzUgLyAwLjcpO1xcclxcbn1cXHJcXG4udGV4dC1ibHVlLTcwMCB7XFxyXFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXHJcXG4gIGNvbG9yOiByZ2IoMjkgNzggMjE2IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5LCAxKSk7XFxyXFxufVxcclxcbi50ZXh0LWJsdWUtODAwIHtcXHJcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcclxcbiAgY29sb3I6IHJnYigzMCA2NCAxNzUgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuLnRleHQtZ3JheS00MDAge1xcclxcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxyXFxuICBjb2xvcjogcmdiKDE1NiAxNjMgMTc1IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5LCAxKSk7XFxyXFxufVxcclxcbi50ZXh0LWdyYXktNTAwIHtcXHJcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcclxcbiAgY29sb3I6IHJnYigxMDcgMTE0IDEyOCAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSwgMSkpO1xcclxcbn1cXHJcXG4udGV4dC1ncmF5LTYwMCB7XFxyXFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXHJcXG4gIGNvbG9yOiByZ2IoNzUgODUgOTkgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuLnRleHQtZ3JheS02MDBcXFxcLzcwIHtcXHJcXG4gIGNvbG9yOiByZ2IoNzUgODUgOTkgLyAwLjcpO1xcclxcbn1cXHJcXG4udGV4dC1ncmF5LTcwMCB7XFxyXFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXHJcXG4gIGNvbG9yOiByZ2IoNTUgNjUgODEgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuLnRleHQtZ3JheS04MDAge1xcclxcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxyXFxuICBjb2xvcjogcmdiKDMxIDQxIDU1IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5LCAxKSk7XFxyXFxufVxcclxcbi50ZXh0LWdyYXktOTAwIHtcXHJcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcclxcbiAgY29sb3I6IHJnYigxNyAyNCAzOSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSwgMSkpO1xcclxcbn1cXHJcXG4udGV4dC1ncmVlbi02MDAge1xcclxcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxyXFxuICBjb2xvcjogcmdiKDIyIDE2MyA3NCAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSwgMSkpO1xcclxcbn1cXHJcXG4udGV4dC1ncmVlbi02MDBcXFxcLzcwIHtcXHJcXG4gIGNvbG9yOiByZ2IoMjIgMTYzIDc0IC8gMC43KTtcXHJcXG59XFxyXFxuLnRleHQtZ3JlZW4tNzAwIHtcXHJcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcclxcbiAgY29sb3I6IHJnYigyMSAxMjggNjEgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuLnRleHQtZ3JlZW4tODAwIHtcXHJcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcclxcbiAgY29sb3I6IHJnYigyMiAxMDEgNTIgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuLnRleHQtaW5kaWdvLTgwMCB7XFxyXFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXHJcXG4gIGNvbG9yOiByZ2IoNTUgNDggMTYzIC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5LCAxKSk7XFxyXFxufVxcclxcbi50ZXh0LXB1cnBsZS02MDAge1xcclxcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxyXFxuICBjb2xvcjogcmdiKDE0NyA1MSAyMzQgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuLnRleHQtcHVycGxlLTYwMFxcXFwvNzAge1xcclxcbiAgY29sb3I6IHJnYigxNDcgNTEgMjM0IC8gMC43KTtcXHJcXG59XFxyXFxuLnRleHQtcmVkLTUwMCB7XFxyXFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXHJcXG4gIGNvbG9yOiByZ2IoMjM5IDY4IDY4IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5LCAxKSk7XFxyXFxufVxcclxcbi50ZXh0LXJlZC02MDAge1xcclxcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxyXFxuICBjb2xvcjogcmdiKDIyMCAzOCAzOCAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSwgMSkpO1xcclxcbn1cXHJcXG4udGV4dC1yZWQtNjAwXFxcXC83MCB7XFxyXFxuICBjb2xvcjogcmdiKDIyMCAzOCAzOCAvIDAuNyk7XFxyXFxufVxcclxcbi50ZXh0LXJlZC03MDAge1xcclxcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxyXFxuICBjb2xvcjogcmdiKDE4NSAyOCAyOCAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSwgMSkpO1xcclxcbn1cXHJcXG4udGV4dC1yZWQtODAwIHtcXHJcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcclxcbiAgY29sb3I6IHJnYigxNTMgMjcgMjcgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuLnRleHQtdHJhbnNwYXJlbnQge1xcclxcbiAgY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbn1cXHJcXG4udGV4dC13aGl0ZSB7XFxyXFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXHJcXG4gIGNvbG9yOiByZ2IoMjU1IDI1NSAyNTUgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuLnRleHQteWVsbG93LTUwMCB7XFxyXFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXHJcXG4gIGNvbG9yOiByZ2IoMjM0IDE3OSA4IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5LCAxKSk7XFxyXFxufVxcclxcbi50ZXh0LXllbGxvdy02MDAge1xcclxcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxyXFxuICBjb2xvcjogcmdiKDIwMiAxMzggNCAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSwgMSkpO1xcclxcbn1cXHJcXG4udGV4dC15ZWxsb3ctODAwIHtcXHJcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcclxcbiAgY29sb3I6IHJnYigxMzMgNzcgMTQgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuLnVuZGVybGluZS1vZmZzZXQtNCB7XFxyXFxuICB0ZXh0LXVuZGVybGluZS1vZmZzZXQ6IDRweDtcXHJcXG59XFxyXFxuLm9wYWNpdHktMCB7XFxyXFxuICBvcGFjaXR5OiAwO1xcclxcbn1cXHJcXG4ub3BhY2l0eS0xMDAge1xcclxcbiAgb3BhY2l0eTogMTtcXHJcXG59XFxyXFxuLm9wYWNpdHktNzUge1xcclxcbiAgb3BhY2l0eTogMC43NTtcXHJcXG59XFxyXFxuLnNoYWRvdy0yeGwge1xcclxcbiAgLS10dy1zaGFkb3c6IDAgMjVweCA1MHB4IC0xMnB4IHJnYigwIDAgMCAvIDAuMjUpO1xcclxcbiAgLS10dy1zaGFkb3ctY29sb3JlZDogMCAyNXB4IDUwcHggLTEycHggdmFyKC0tdHctc2hhZG93LWNvbG9yKTtcXHJcXG4gIGJveC1zaGFkb3c6IHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdywgMCAwICMwMDAwKSwgdmFyKC0tdHctcmluZy1zaGFkb3csIDAgMCAjMDAwMCksIHZhcigtLXR3LXNoYWRvdyk7XFxyXFxufVxcclxcbi5zaGFkb3ctbGcge1xcclxcbiAgLS10dy1zaGFkb3c6IDAgMTBweCAxNXB4IC0zcHggcmdiKDAgMCAwIC8gMC4xKSwgMCA0cHggNnB4IC00cHggcmdiKDAgMCAwIC8gMC4xKTtcXHJcXG4gIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMTBweCAxNXB4IC0zcHggdmFyKC0tdHctc2hhZG93LWNvbG9yKSwgMCA0cHggNnB4IC00cHggdmFyKC0tdHctc2hhZG93LWNvbG9yKTtcXHJcXG4gIGJveC1zaGFkb3c6IHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdywgMCAwICMwMDAwKSwgdmFyKC0tdHctcmluZy1zaGFkb3csIDAgMCAjMDAwMCksIHZhcigtLXR3LXNoYWRvdyk7XFxyXFxufVxcclxcbi5zaGFkb3ctc20ge1xcclxcbiAgLS10dy1zaGFkb3c6IDAgMXB4IDJweCAwIHJnYigwIDAgMCAvIDAuMDUpO1xcclxcbiAgLS10dy1zaGFkb3ctY29sb3JlZDogMCAxcHggMnB4IDAgdmFyKC0tdHctc2hhZG93LWNvbG9yKTtcXHJcXG4gIGJveC1zaGFkb3c6IHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdywgMCAwICMwMDAwKSwgdmFyKC0tdHctcmluZy1zaGFkb3csIDAgMCAjMDAwMCksIHZhcigtLXR3LXNoYWRvdyk7XFxyXFxufVxcclxcbi5vdXRsaW5lIHtcXHJcXG4gIG91dGxpbmUtc3R5bGU6IHNvbGlkO1xcclxcbn1cXHJcXG4ucmluZy1vZmZzZXQtYmFja2dyb3VuZCB7XFxyXFxuICAtLXR3LXJpbmctb2Zmc2V0LWNvbG9yOiB2YXIoLS1iYWNrZ3JvdW5kKTtcXHJcXG59XFxyXFxuLmZpbHRlciB7XFxyXFxuICBmaWx0ZXI6IHZhcigtLXR3LWJsdXIpIHZhcigtLXR3LWJyaWdodG5lc3MpIHZhcigtLXR3LWNvbnRyYXN0KSB2YXIoLS10dy1ncmF5c2NhbGUpIHZhcigtLXR3LWh1ZS1yb3RhdGUpIHZhcigtLXR3LWludmVydCkgdmFyKC0tdHctc2F0dXJhdGUpIHZhcigtLXR3LXNlcGlhKSB2YXIoLS10dy1kcm9wLXNoYWRvdyk7XFxyXFxufVxcclxcbi5iYWNrZHJvcC1ibHVyLXNtIHtcXHJcXG4gIC0tdHctYmFja2Ryb3AtYmx1cjogYmx1cig0cHgpO1xcclxcbiAgYmFja2Ryb3AtZmlsdGVyOiB2YXIoLS10dy1iYWNrZHJvcC1ibHVyKSB2YXIoLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzKSB2YXIoLS10dy1iYWNrZHJvcC1jb250cmFzdCkgdmFyKC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlKSB2YXIoLS10dy1iYWNrZHJvcC1odWUtcm90YXRlKSB2YXIoLS10dy1iYWNrZHJvcC1pbnZlcnQpIHZhcigtLXR3LWJhY2tkcm9wLW9wYWNpdHkpIHZhcigtLXR3LWJhY2tkcm9wLXNhdHVyYXRlKSB2YXIoLS10dy1iYWNrZHJvcC1zZXBpYSk7XFxyXFxufVxcclxcbi50cmFuc2l0aW9uLWFsbCB7XFxyXFxuICB0cmFuc2l0aW9uLXByb3BlcnR5OiBhbGw7XFxyXFxuICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTtcXHJcXG4gIHRyYW5zaXRpb24tZHVyYXRpb246IDE1MG1zO1xcclxcbn1cXHJcXG4udHJhbnNpdGlvbi1jb2xvcnMge1xcclxcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogY29sb3IsIGJhY2tncm91bmQtY29sb3IsIGJvcmRlci1jb2xvciwgdGV4dC1kZWNvcmF0aW9uLWNvbG9yLCBmaWxsLCBzdHJva2U7XFxyXFxuICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTtcXHJcXG4gIHRyYW5zaXRpb24tZHVyYXRpb246IDE1MG1zO1xcclxcbn1cXHJcXG4uZHVyYXRpb24tMzAwIHtcXHJcXG4gIHRyYW5zaXRpb24tZHVyYXRpb246IDMwMG1zO1xcclxcbn1cXHJcXG5cXHJcXG46cm9vdCB7XFxyXFxuICAtLWZvcmVncm91bmQtcmdiOiAwLCAwLCAwO1xcclxcbiAgLS1iYWNrZ3JvdW5kLXN0YXJ0LXJnYjogMjE0LCAyMTksIDIyMDtcXHJcXG4gIC0tYmFja2dyb3VuZC1lbmQtcmdiOiAyNTUsIDI1NSwgMjU1O1xcclxcbn1cXHJcXG5cXHJcXG5AbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSB7XFxyXFxuICA6cm9vdCB7XFxyXFxuICAgIC0tZm9yZWdyb3VuZC1yZ2I6IDI1NSwgMjU1LCAyNTU7XFxyXFxuICAgIC0tYmFja2dyb3VuZC1zdGFydC1yZ2I6IDAsIDAsIDA7XFxyXFxuICAgIC0tYmFja2dyb3VuZC1lbmQtcmdiOiAwLCAwLCAwO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG5ib2R5IHtcXHJcXG4gIGNvbG9yOiByZ2IodmFyKC0tZm9yZWdyb3VuZC1yZ2IpKTtcXHJcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChcXHJcXG4gICAgICB0byBib3R0b20sXFxyXFxuICAgICAgdHJhbnNwYXJlbnQsXFxyXFxuICAgICAgcmdiKHZhcigtLWJhY2tncm91bmQtZW5kLXJnYikpXFxyXFxuICAgIClcXHJcXG4gICAgcmdiKHZhcigtLWJhY2tncm91bmQtc3RhcnQtcmdiKSk7XFxyXFxufVxcclxcblxcclxcbi5wbGFjZWhvbGRlclxcXFw6dGV4dC1ncmF5LTQwMDo6LW1vei1wbGFjZWhvbGRlciB7XFxyXFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXHJcXG4gIGNvbG9yOiByZ2IoMTU2IDE2MyAxNzUgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuXFxyXFxuLnBsYWNlaG9sZGVyXFxcXDp0ZXh0LWdyYXktNDAwOjpwbGFjZWhvbGRlciB7XFxyXFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXHJcXG4gIGNvbG9yOiByZ2IoMTU2IDE2MyAxNzUgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuXFxyXFxuLmhvdmVyXFxcXDpib3JkZXItYmx1ZS0zMDA6aG92ZXIge1xcclxcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXHJcXG4gIGJvcmRlci1jb2xvcjogcmdiKDE0NyAxOTcgMjUzIC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuXFxyXFxuLmhvdmVyXFxcXDpiZy1ibHVlLTUwOmhvdmVyIHtcXHJcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMzkgMjQ2IDI1NSAvIHZhcigtLXR3LWJnLW9wYWNpdHksIDEpKTtcXHJcXG59XFxyXFxuXFxyXFxuLmhvdmVyXFxcXDpiZy1ncmVlbi01MDpob3ZlciB7XFxyXFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjQwIDI1MyAyNDQgLyB2YXIoLS10dy1iZy1vcGFjaXR5LCAxKSk7XFxyXFxufVxcclxcblxcclxcbi5ob3ZlclxcXFw6ZnJvbS1ibHVlLTYwMDpob3ZlciB7XFxyXFxuICAtLXR3LWdyYWRpZW50LWZyb206ICMyNTYzZWIgdmFyKC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbik7XFxyXFxuICAtLXR3LWdyYWRpZW50LXRvOiByZ2IoMzcgOTkgMjM1IC8gMCkgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pO1xcclxcbiAgLS10dy1ncmFkaWVudC1zdG9wczogdmFyKC0tdHctZ3JhZGllbnQtZnJvbSksIHZhcigtLXR3LWdyYWRpZW50LXRvKTtcXHJcXG59XFxyXFxuXFxyXFxuLmhvdmVyXFxcXDpmcm9tLWdyZWVuLTYwMDpob3ZlciB7XFxyXFxuICAtLXR3LWdyYWRpZW50LWZyb206ICMxNmEzNGEgdmFyKC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbik7XFxyXFxuICAtLXR3LWdyYWRpZW50LXRvOiByZ2IoMjIgMTYzIDc0IC8gMCkgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pO1xcclxcbiAgLS10dy1ncmFkaWVudC1zdG9wczogdmFyKC0tdHctZ3JhZGllbnQtZnJvbSksIHZhcigtLXR3LWdyYWRpZW50LXRvKTtcXHJcXG59XFxyXFxuXFxyXFxuLmhvdmVyXFxcXDpmcm9tLXB1cnBsZS02MDA6aG92ZXIge1xcclxcbiAgLS10dy1ncmFkaWVudC1mcm9tOiAjOTMzM2VhIHZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pO1xcclxcbiAgLS10dy1ncmFkaWVudC10bzogcmdiKDE0NyA1MSAyMzQgLyAwKSB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbik7XFxyXFxuICAtLXR3LWdyYWRpZW50LXN0b3BzOiB2YXIoLS10dy1ncmFkaWVudC1mcm9tKSwgdmFyKC0tdHctZ3JhZGllbnQtdG8pO1xcclxcbn1cXHJcXG5cXHJcXG4uaG92ZXJcXFxcOmZyb20tcmVkLTYwMDpob3ZlciB7XFxyXFxuICAtLXR3LWdyYWRpZW50LWZyb206ICNkYzI2MjYgdmFyKC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbik7XFxyXFxuICAtLXR3LWdyYWRpZW50LXRvOiByZ2IoMjIwIDM4IDM4IC8gMCkgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pO1xcclxcbiAgLS10dy1ncmFkaWVudC1zdG9wczogdmFyKC0tdHctZ3JhZGllbnQtZnJvbSksIHZhcigtLXR3LWdyYWRpZW50LXRvKTtcXHJcXG59XFxyXFxuXFxyXFxuLmhvdmVyXFxcXDp0by1ibHVlLTcwMDpob3ZlciB7XFxyXFxuICAtLXR3LWdyYWRpZW50LXRvOiAjMWQ0ZWQ4IHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTtcXHJcXG59XFxyXFxuXFxyXFxuLmhvdmVyXFxcXDp0by1ncmVlbi03MDA6aG92ZXIge1xcclxcbiAgLS10dy1ncmFkaWVudC10bzogIzE1ODAzZCB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbik7XFxyXFxufVxcclxcblxcclxcbi5ob3ZlclxcXFw6dG8tcHVycGxlLTcwMDpob3ZlciB7XFxyXFxuICAtLXR3LWdyYWRpZW50LXRvOiAjN2UyMmNlIHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTtcXHJcXG59XFxyXFxuXFxyXFxuLmhvdmVyXFxcXDp0by1yZWQtNzAwOmhvdmVyIHtcXHJcXG4gIC0tdHctZ3JhZGllbnQtdG86ICNiOTFjMWMgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pO1xcclxcbn1cXHJcXG5cXHJcXG4uaG92ZXJcXFxcOnRleHQtZ3JheS02MDA6aG92ZXIge1xcclxcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxyXFxuICBjb2xvcjogcmdiKDc1IDg1IDk5IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5LCAxKSk7XFxyXFxufVxcclxcblxcclxcbi5ob3ZlclxcXFw6dW5kZXJsaW5lOmhvdmVyIHtcXHJcXG4gIHRleHQtZGVjb3JhdGlvbi1saW5lOiB1bmRlcmxpbmU7XFxyXFxufVxcclxcblxcclxcbi5ob3ZlclxcXFw6c2hhZG93LWxnOmhvdmVyIHtcXHJcXG4gIC0tdHctc2hhZG93OiAwIDEwcHggMTVweCAtM3B4IHJnYigwIDAgMCAvIDAuMSksIDAgNHB4IDZweCAtNHB4IHJnYigwIDAgMCAvIDAuMSk7XFxyXFxuICAtLXR3LXNoYWRvdy1jb2xvcmVkOiAwIDEwcHggMTVweCAtM3B4IHZhcigtLXR3LXNoYWRvdy1jb2xvciksIDAgNHB4IDZweCAtNHB4IHZhcigtLXR3LXNoYWRvdy1jb2xvcik7XFxyXFxuICBib3gtc2hhZG93OiB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3csIDAgMCAjMDAwMCksIHZhcigtLXR3LXJpbmctc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1zaGFkb3cpO1xcclxcbn1cXHJcXG5cXHJcXG4uaG92ZXJcXFxcOnNoYWRvdy14bDpob3ZlciB7XFxyXFxuICAtLXR3LXNoYWRvdzogMCAyMHB4IDI1cHggLTVweCByZ2IoMCAwIDAgLyAwLjEpLCAwIDhweCAxMHB4IC02cHggcmdiKDAgMCAwIC8gMC4xKTtcXHJcXG4gIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMjBweCAyNXB4IC01cHggdmFyKC0tdHctc2hhZG93LWNvbG9yKSwgMCA4cHggMTBweCAtNnB4IHZhcigtLXR3LXNoYWRvdy1jb2xvcik7XFxyXFxuICBib3gtc2hhZG93OiB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3csIDAgMCAjMDAwMCksIHZhcigtLXR3LXJpbmctc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1zaGFkb3cpO1xcclxcbn1cXHJcXG5cXHJcXG4uZm9jdXNcXFxcOmJvcmRlci10cmFuc3BhcmVudDpmb2N1cyB7XFxyXFxuICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbn1cXHJcXG5cXHJcXG4uZm9jdXNcXFxcOm91dGxpbmUtbm9uZTpmb2N1cyB7XFxyXFxuICBvdXRsaW5lOiAycHggc29saWQgdHJhbnNwYXJlbnQ7XFxyXFxuICBvdXRsaW5lLW9mZnNldDogMnB4O1xcclxcbn1cXHJcXG5cXHJcXG4uZm9jdXNcXFxcOnJpbmctMjpmb2N1cyB7XFxyXFxuICAtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdzogdmFyKC0tdHctcmluZy1pbnNldCkgMCAwIDAgdmFyKC0tdHctcmluZy1vZmZzZXQtd2lkdGgpIHZhcigtLXR3LXJpbmctb2Zmc2V0LWNvbG9yKTtcXHJcXG4gIC0tdHctcmluZy1zaGFkb3c6IHZhcigtLXR3LXJpbmctaW5zZXQpIDAgMCAwIGNhbGMoMnB4ICsgdmFyKC0tdHctcmluZy1vZmZzZXQtd2lkdGgpKSB2YXIoLS10dy1yaW5nLWNvbG9yKTtcXHJcXG4gIGJveC1zaGFkb3c6IHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdyksIHZhcigtLXR3LXJpbmctc2hhZG93KSwgdmFyKC0tdHctc2hhZG93LCAwIDAgIzAwMDApO1xcclxcbn1cXHJcXG5cXHJcXG4uZm9jdXNcXFxcOnJpbmctYmx1ZS01MDA6Zm9jdXMge1xcclxcbiAgLS10dy1yaW5nLW9wYWNpdHk6IDE7XFxyXFxuICAtLXR3LXJpbmctY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gdmFyKC0tdHctcmluZy1vcGFjaXR5LCAxKSk7XFxyXFxufVxcclxcblxcclxcbi5mb2N1cy12aXNpYmxlXFxcXDpvdXRsaW5lLW5vbmU6Zm9jdXMtdmlzaWJsZSB7XFxyXFxuICBvdXRsaW5lOiAycHggc29saWQgdHJhbnNwYXJlbnQ7XFxyXFxuICBvdXRsaW5lLW9mZnNldDogMnB4O1xcclxcbn1cXHJcXG5cXHJcXG4uZm9jdXMtdmlzaWJsZVxcXFw6cmluZy0yOmZvY3VzLXZpc2libGUge1xcclxcbiAgLS10dy1yaW5nLW9mZnNldC1zaGFkb3c6IHZhcigtLXR3LXJpbmctaW5zZXQpIDAgMCAwIHZhcigtLXR3LXJpbmctb2Zmc2V0LXdpZHRoKSB2YXIoLS10dy1yaW5nLW9mZnNldC1jb2xvcik7XFxyXFxuICAtLXR3LXJpbmctc2hhZG93OiB2YXIoLS10dy1yaW5nLWluc2V0KSAwIDAgMCBjYWxjKDJweCArIHZhcigtLXR3LXJpbmctb2Zmc2V0LXdpZHRoKSkgdmFyKC0tdHctcmluZy1jb2xvcik7XFxyXFxuICBib3gtc2hhZG93OiB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3cpLCB2YXIoLS10dy1yaW5nLXNoYWRvdyksIHZhcigtLXR3LXNoYWRvdywgMCAwICMwMDAwKTtcXHJcXG59XFxyXFxuXFxyXFxuLmZvY3VzLXZpc2libGVcXFxcOnJpbmctb2Zmc2V0LTI6Zm9jdXMtdmlzaWJsZSB7XFxyXFxuICAtLXR3LXJpbmctb2Zmc2V0LXdpZHRoOiAycHg7XFxyXFxufVxcclxcblxcclxcbi5kaXNhYmxlZFxcXFw6cG9pbnRlci1ldmVudHMtbm9uZTpkaXNhYmxlZCB7XFxyXFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLmRpc2FibGVkXFxcXDpjdXJzb3Itbm90LWFsbG93ZWQ6ZGlzYWJsZWQge1xcclxcbiAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXHJcXG59XFxyXFxuXFxyXFxuLmRpc2FibGVkXFxcXDpvcGFjaXR5LTUwOmRpc2FibGVkIHtcXHJcXG4gIG9wYWNpdHk6IDAuNTtcXHJcXG59XFxyXFxuXFxyXFxuLnBlZXI6ZGlzYWJsZWQgfiAucGVlci1kaXNhYmxlZFxcXFw6Y3Vyc29yLW5vdC1hbGxvd2VkIHtcXHJcXG4gIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxyXFxufVxcclxcblxcclxcbi5wZWVyOmRpc2FibGVkIH4gLnBlZXItZGlzYWJsZWRcXFxcOm9wYWNpdHktNzAge1xcclxcbiAgb3BhY2l0eTogMC43O1xcclxcbn1cXHJcXG5cXHJcXG5AbWVkaWEgKG1pbi13aWR0aDogNjQwcHgpIHtcXHJcXG5cXHJcXG4gIC5zbVxcXFw6YmxvY2sge1xcclxcbiAgICBkaXNwbGF5OiBibG9jaztcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XFxyXFxuXFxyXFxuICAubWRcXFxcOmdyaWQtY29scy0zIHtcXHJcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMywgbWlubWF4KDAsIDFmcikpO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG5AbWVkaWEgKG1pbi13aWR0aDogMTAyNHB4KSB7XFxyXFxuXFxyXFxuICAubGdcXFxcOmdyaWQtY29scy0yIHtcXHJcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMiwgbWlubWF4KDAsIDFmcikpO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG5cXHJcXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vc3JjL3N0eWxlcy9nbG9iYWxzLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUFBLHdCQUFjO0VBQWQsd0JBQWM7RUFBZCxtQkFBYztFQUFkLG1CQUFjO0VBQWQsY0FBYztFQUFkLGNBQWM7RUFBZCxjQUFjO0VBQWQsZUFBYztFQUFkLGVBQWM7RUFBZCxhQUFjO0VBQWQsYUFBYztFQUFkLGtCQUFjO0VBQWQsc0NBQWM7RUFBZCw4QkFBYztFQUFkLDZCQUFjO0VBQWQsNEJBQWM7RUFBZCxlQUFjO0VBQWQsb0JBQWM7RUFBZCxzQkFBYztFQUFkLHVCQUFjO0VBQWQsd0JBQWM7RUFBZCxrQkFBYztFQUFkLDJCQUFjO0VBQWQsNEJBQWM7RUFBZCxzQ0FBYztFQUFkLGtDQUFjO0VBQWQsMkJBQWM7RUFBZCxzQkFBYztFQUFkLDhCQUFjO0VBQWQsWUFBYztFQUFkLGtCQUFjO0VBQWQsZ0JBQWM7RUFBZCxpQkFBYztFQUFkLGtCQUFjO0VBQWQsY0FBYztFQUFkLGdCQUFjO0VBQWQsYUFBYztFQUFkLG1CQUFjO0VBQWQscUJBQWM7RUFBZCwyQkFBYztFQUFkLHlCQUFjO0VBQWQsMEJBQWM7RUFBZCwyQkFBYztFQUFkLHVCQUFjO0VBQWQsd0JBQWM7RUFBZCx5QkFBYztFQUFkLHNCQUFjO0VBQWQsb0JBQWM7RUFBZCxzQkFBYztFQUFkLHFCQUFjO0VBQWQ7QUFBYzs7QUFBZDtFQUFBLHdCQUFjO0VBQWQsd0JBQWM7RUFBZCxtQkFBYztFQUFkLG1CQUFjO0VBQWQsY0FBYztFQUFkLGNBQWM7RUFBZCxjQUFjO0VBQWQsZUFBYztFQUFkLGVBQWM7RUFBZCxhQUFjO0VBQWQsYUFBYztFQUFkLGtCQUFjO0VBQWQsc0NBQWM7RUFBZCw4QkFBYztFQUFkLDZCQUFjO0VBQWQsNEJBQWM7RUFBZCxlQUFjO0VBQWQsb0JBQWM7RUFBZCxzQkFBYztFQUFkLHVCQUFjO0VBQWQsd0JBQWM7RUFBZCxrQkFBYztFQUFkLDJCQUFjO0VBQWQsNEJBQWM7RUFBZCxzQ0FBYztFQUFkLGtDQUFjO0VBQWQsMkJBQWM7RUFBZCxzQkFBYztFQUFkLDhCQUFjO0VBQWQsWUFBYztFQUFkLGtCQUFjO0VBQWQsZ0JBQWM7RUFBZCxpQkFBYztFQUFkLGtCQUFjO0VBQWQsY0FBYztFQUFkLGdCQUFjO0VBQWQsYUFBYztFQUFkLG1CQUFjO0VBQWQscUJBQWM7RUFBZCwyQkFBYztFQUFkLHlCQUFjO0VBQWQsMEJBQWM7RUFBZCwyQkFBYztFQUFkLHVCQUFjO0VBQWQsd0JBQWM7RUFBZCx5QkFBYztFQUFkLHNCQUFjO0VBQWQsb0JBQWM7RUFBZCxzQkFBYztFQUFkLHFC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O0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHFCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5COztFQUFBO0lBQUE7RUFBbUI7QUFBQTtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsdUJBQW1CO0VBQW5CLHNEQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtFQUFuQix1REFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSx1QkFBbUI7RUFBbkIsb0RBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsdUJBQW1CO0VBQW5CLCtEQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtFQUFuQixnRUFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSx1QkFBbUI7RUFBbkIsOERBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsdUJBQW1CO0VBQW5CLCtEQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtFQUFuQiw4REFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSx1QkFBbUI7RUFBbkIsNERBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsc0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsc0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLDREQUFtQjtFQUFuQixxRUFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSw0REFBbUI7RUFBbkIsb0VBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsNERBQW1CO0VBQW5CLG1FQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDREQUFtQjtFQUFuQixxRUFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSw0REFBbUI7RUFBbkIsbUVBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsNERBQW1CO0VBQW5CLHFFQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDREQUFtQjtFQUFuQixvRUFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSw0REFBbUI7RUFBbkIscUVBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsNERBQW1CO0VBQW5CLG1FQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDREQUFtQjtFQUFuQixtRUFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxzRUFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsNkJBQW1CO1VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEscUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsaUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsbUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsaUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsaUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxnREFBbUI7RUFBbkIsNkRBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsK0VBQW1CO0VBQW5CLG1HQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDBDQUFtQjtFQUFuQix1REFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSw2QkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSx3QkFBbUI7RUFBbkIsd0RBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsK0ZBQW1CO0VBQW5CLHdEQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1COztBQUVuQjtFQUNFLHlCQUF5QjtFQUN6QixxQ0FBcUM7RUFDckMsbUNBQW1DO0FBQ3JDOztBQUVBO0VBQ0U7SUFDRSwrQkFBK0I7SUFDL0IsK0JBQStCO0lBQy9CLDZCQUE2QjtFQUMvQjtBQUNGOztBQUVBO0VBQ0UsaUNBQWlDO0VBQ2pDOzs7OztvQ0FLa0M7QUFDcEM7O0FBMUJBO0VBQUEsb0JBbUNBO0VBbkNBO0FBbUNBOztBQW5DQTtFQUFBLG9CQW1DQTtFQW5DQTtBQW1DQTs7QUFuQ0E7RUFBQSxzQkFtQ0E7RUFuQ0E7QUFtQ0E7O0FBbkNBO0VBQUEsa0JBbUNBO0VBbkNBO0FBbUNBOztBQW5DQTtFQUFBLGtCQW1DQTtFQW5DQTtBQW1DQTs7QUFuQ0E7RUFBQSw0REFtQ0E7RUFuQ0EsbUVBbUNBO0VBbkNBO0FBbUNBOztBQW5DQTtFQUFBLDREQW1DQTtFQW5DQSxtRUFtQ0E7RUFuQ0E7QUFtQ0E7O0FBbkNBO0VBQUEsNERBbUNBO0VBbkNBLG9FQW1DQTtFQW5DQTtBQW1DQTs7QUFuQ0E7RUFBQSw0REFtQ0E7RUFuQ0EsbUVBbUNBO0VBbkNBO0FBbUNBOztBQW5DQTtFQUFBO0FBbUNBOztBQW5DQTtFQUFBO0FBbUNBOztBQW5DQTtFQUFBO0FBbUNBOztBQW5DQTtFQUFBO0FBbUNBOztBQW5DQTtFQUFBLG9CQW1DQTtFQW5DQTtBQW1DQTs7QUFuQ0E7RUFBQTtBQW1DQTs7QUFuQ0E7RUFBQSwrRUFtQ0E7RUFuQ0EsbUdBbUNBO0VBbkNBO0FBbUNBOztBQW5DQTtFQUFBLGdGQW1DQTtFQW5DQSxvR0FtQ0E7RUFuQ0E7QUFtQ0E7O0FBbkNBO0VBQUE7QUFtQ0E7O0FBbkNBO0VBQUEsOEJBbUNBO0VBbkNBO0FBbUNBOztBQW5DQTtFQUFBLDJHQW1DQTtFQW5DQSx5R0FtQ0E7RUFuQ0E7QUFtQ0E7O0FBbkNBO0VBQUEsb0JBbUNBO0VBbkNBO0FBbUNBOztBQW5DQTtFQUFBLDhCQW1DQTtFQW5DQTtBQW1DQTs7QUFuQ0E7RUFBQSwyR0FtQ0E7RUFuQ0EseUdBbUNBO0VBbkNBO0FBbUNBOztBQW5DQTtFQUFBO0FBbUNBOztBQW5DQTtFQUFBO0FBbUNBOztBQW5DQTtFQUFBO0FBbUNBOztBQW5DQTtFQUFBO0FBbUNBOztBQW5DQTtFQUFBO0FBbUNBOztBQW5DQTtFQUFBO0FBbUNBOztBQW5DQTs7RUFBQTtJQUFBO0VBbUNBO0FBQUE7O0FBbkNBOztFQUFBO0lBQUE7RUFtQ0E7QUFBQTs7QUFuQ0E7O0VBQUE7SUFBQTtFQW1DQTtBQUFBXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIkB0YWlsd2luZCBiYXNlO1xcclxcbkB0YWlsd2luZCBjb21wb25lbnRzO1xcclxcbkB0YWlsd2luZCB1dGlsaXRpZXM7XFxyXFxuXFxyXFxuOnJvb3Qge1xcclxcbiAgLS1mb3JlZ3JvdW5kLXJnYjogMCwgMCwgMDtcXHJcXG4gIC0tYmFja2dyb3VuZC1zdGFydC1yZ2I6IDIxNCwgMjE5LCAyMjA7XFxyXFxuICAtLWJhY2tncm91bmQtZW5kLXJnYjogMjU1LCAyNTUsIDI1NTtcXHJcXG59XFxyXFxuXFxyXFxuQG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaykge1xcclxcbiAgOnJvb3Qge1xcclxcbiAgICAtLWZvcmVncm91bmQtcmdiOiAyNTUsIDI1NSwgMjU1O1xcclxcbiAgICAtLWJhY2tncm91bmQtc3RhcnQtcmdiOiAwLCAwLCAwO1xcclxcbiAgICAtLWJhY2tncm91bmQtZW5kLXJnYjogMCwgMCwgMDtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuYm9keSB7XFxyXFxuICBjb2xvcjogcmdiKHZhcigtLWZvcmVncm91bmQtcmdiKSk7XFxyXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoXFxyXFxuICAgICAgdG8gYm90dG9tLFxcclxcbiAgICAgIHRyYW5zcGFyZW50LFxcclxcbiAgICAgIHJnYih2YXIoLS1iYWNrZ3JvdW5kLWVuZC1yZ2IpKVxcclxcbiAgICApXFxyXFxuICAgIHJnYih2YXIoLS1iYWNrZ3JvdW5kLXN0YXJ0LXJnYikpO1xcclxcbn1cXHJcXG5cXHJcXG5AbGF5ZXIgdXRpbGl0aWVzIHtcXHJcXG4gIC50ZXh0LWJhbGFuY2Uge1xcclxcbiAgICB0ZXh0LXdyYXA6IGJhbGFuY2U7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcblxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./src/styles/globals.css\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/*\r\n  MIT License http://www.opensource.org/licenses/mit-license.php\r\n  Author Tobias Koppers @sokra\r\n*/ // css base code, injected by the css-loader\r\n// eslint-disable-next-line func-names\r\n\r\nmodule.exports = function(useSourceMap) {\r\n    var list = [] // return the list of modules as css string\r\n    ;\r\n    list.toString = function toString() {\r\n        return this.map(function(item) {\r\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n            var content = cssWithMappingToString(item, useSourceMap);\r\n            if (item[2]) {\r\n                return '@media '.concat(item[2], ' {').concat(content, '}');\r\n            }\r\n            return content;\r\n        }).join('');\r\n    } // import a list of modules into the list\r\n    ;\r\n    // eslint-disable-next-line func-names\r\n    // @ts-expect-error TODO: fix type\r\n    list.i = function(modules, mediaQuery, dedupe) {\r\n        if (typeof modules === 'string') {\r\n            // eslint-disable-next-line no-param-reassign\r\n            modules = [\r\n                [\r\n                    null,\r\n                    modules,\r\n                    ''\r\n                ]\r\n            ];\r\n        }\r\n        var alreadyImportedModules = {};\r\n        if (dedupe) {\r\n            for(var i = 0; i < this.length; i++){\r\n                // eslint-disable-next-line prefer-destructuring\r\n                var id = this[i][0];\r\n                if (id != null) {\r\n                    alreadyImportedModules[id] = true;\r\n                }\r\n            }\r\n        }\r\n        for(var _i = 0; _i < modules.length; _i++){\r\n            var item = [].concat(modules[_i]);\r\n            if (dedupe && alreadyImportedModules[item[0]]) {\r\n                continue;\r\n            }\r\n            if (mediaQuery) {\r\n                if (!item[2]) {\r\n                    item[2] = mediaQuery;\r\n                } else {\r\n                    item[2] = ''.concat(mediaQuery, ' and ').concat(item[2]);\r\n                }\r\n            }\r\n            list.push(item);\r\n        }\r\n    };\r\n    return list;\r\n};\r\nfunction cssWithMappingToString(item, useSourceMap) {\r\n    var content = item[1] || '' // eslint-disable-next-line prefer-destructuring\r\n    ;\r\n    var cssMapping = item[3];\r\n    if (!cssMapping) {\r\n        return content;\r\n    }\r\n    if (useSourceMap && typeof btoa === 'function') {\r\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n        var sourceMapping = toComment(cssMapping);\r\n        var sourceURLs = cssMapping.sources.map(function(source) {\r\n            return '/*# sourceURL='.concat(cssMapping.sourceRoot || '').concat(source, ' */');\r\n        });\r\n        return [\r\n            content\r\n        ].concat(sourceURLs).concat([\r\n            sourceMapping\r\n        ]).join('\\n');\r\n    }\r\n    return [\r\n        content\r\n    ].join('\\n');\r\n} // Adapted from convert-source-map (MIT)\r\nfunction toComment(sourceMap) {\r\n    // eslint-disable-next-line no-undef\r\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\r\n    var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,'.concat(base64);\r\n    return '/*# '.concat(data, ' */');\r\n}\r\n\r\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL3J1bnRpbWUvYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QscUJBQXFCO0FBQ3pFO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXGJ1aWxkXFx3ZWJwYWNrXFxsb2FkZXJzXFxjc3MtbG9hZGVyXFxzcmNcXHJ1bnRpbWVcXGFwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qLyAvLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xyXG5cInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcclxuICAgIHZhciBsaXN0ID0gW10gLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG4gICAgO1xyXG4gICAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcclxuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XHJcbiAgICAgICAgICAgIGlmIChpdGVtWzJdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0BtZWRpYSAnLmNvbmNhdChpdGVtWzJdLCAnIHsnKS5jb25jYXQoY29udGVudCwgJ30nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcclxuICAgICAgICB9KS5qb2luKCcnKTtcclxuICAgIH0gLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcclxuICAgIDtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IGZpeCB0eXBlXHJcbiAgICBsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgICAgICBtb2R1bGVzID0gW1xyXG4gICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlcyxcclxuICAgICAgICAgICAgICAgICAgICAnJ1xyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xyXG4gICAgICAgIGlmIChkZWR1cGUpIHtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXHJcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspe1xyXG4gICAgICAgICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pXSk7XHJcbiAgICAgICAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXRlbVsyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtWzJdID0gJycuY29uY2F0KG1lZGlhUXVlcnksICcgYW5kICcpLmNvbmNhdChpdGVtWzJdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsaXN0LnB1c2goaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBsaXN0O1xyXG59O1xyXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xyXG4gICAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xyXG4gICAgO1xyXG4gICAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xyXG4gICAgaWYgKCFjc3NNYXBwaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgICB9XHJcbiAgICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxyXG4gICAgICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xyXG4gICAgICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbihzb3VyY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcvKiMgc291cmNlVVJMPScuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCAnJykuY29uY2F0KHNvdXJjZSwgJyAqLycpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIGNvbnRlbnRcclxuICAgICAgICBdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW1xyXG4gICAgICAgICAgICBzb3VyY2VNYXBwaW5nXHJcbiAgICAgICAgXSkuam9pbignXFxuJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIGNvbnRlbnRcclxuICAgIF0uam9pbignXFxuJyk7XHJcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxyXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcclxuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xyXG4gICAgdmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJy5jb25jYXQoYmFzZTY0KTtcclxuICAgIHJldHVybiAnLyojICcuY29uY2F0KGRhdGEsICcgKi8nKTtcclxufVxyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app! ***!
  \*******************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return __webpack_require__(/*! private-next-pages/_app */ \"(pages-dir-browser)/./src/pages/_app.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_app\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtY2xpZW50LXBhZ2VzLWxvYWRlci5qcz9hYnNvbHV0ZVBhZ2VQYXRoPXByaXZhdGUtbmV4dC1wYWdlcyUyRl9hcHAmcGFnZT0lMkZfYXBwISIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHlFQUF5QjtBQUNoRDtBQUNBO0FBQ0EsT0FBTyxJQUFVO0FBQ2pCLE1BQU0sVUFBVTtBQUNoQjtBQUNBLE9BQU87QUFDUDtBQUNBIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9fYXBwXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwicHJpdmF0ZS1uZXh0LXBhZ2VzL19hcHBcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL19hcHBcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/// <reference types=\"webpack/module.d.ts\" />\r\n\r\nconst isOldIE = function isOldIE() {\r\n    let memo;\r\n    return function memorize() {\r\n        if (typeof memo === 'undefined') {\r\n            // Test for IE <= 9 as proposed by Browserhacks\r\n            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\r\n            // Tests for existence of standard globals is to allow style-loader\r\n            // to operate correctly into non-standard environments\r\n            // @see https://github.com/webpack-contrib/style-loader/issues/177\r\n            memo = Boolean(window && document && document.all && !window.atob);\r\n        }\r\n        return memo;\r\n    };\r\n}();\r\nconst getTargetElement = function() {\r\n    const memo = {};\r\n    return function memorize(target) {\r\n        if (typeof memo[target] === 'undefined') {\r\n            let styleTarget = document.querySelector(target);\r\n            // Special case to return head of iframe instead of iframe itself\r\n            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\r\n                try {\r\n                    // This will throw an exception if access to iframe is blocked\r\n                    // due to cross-origin restrictions\r\n                    styleTarget = styleTarget.contentDocument.head;\r\n                } catch (e) {\r\n                    // istanbul ignore next\r\n                    styleTarget = null;\r\n                }\r\n            }\r\n            memo[target] = styleTarget;\r\n        }\r\n        return memo[target];\r\n    };\r\n}();\r\nconst stylesInDom = [];\r\nfunction getIndexByIdentifier(identifier) {\r\n    let result = -1;\r\n    for(let i = 0; i < stylesInDom.length; i++){\r\n        if (stylesInDom[i].identifier === identifier) {\r\n            result = i;\r\n            break;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction modulesToDom(list, options) {\r\n    const idCountMap = {};\r\n    const identifiers = [];\r\n    for(let i = 0; i < list.length; i++){\r\n        const item = list[i];\r\n        const id = options.base ? item[0] + options.base : item[0];\r\n        const count = idCountMap[id] || 0;\r\n        const identifier = id + ' ' + count.toString();\r\n        idCountMap[id] = count + 1;\r\n        const index = getIndexByIdentifier(identifier);\r\n        const obj = {\r\n            css: item[1],\r\n            media: item[2],\r\n            sourceMap: item[3]\r\n        };\r\n        if (index !== -1) {\r\n            stylesInDom[index].references++;\r\n            stylesInDom[index].updater(obj);\r\n        } else {\r\n            stylesInDom.push({\r\n                identifier: identifier,\r\n                // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n                updater: addStyle(obj, options),\r\n                references: 1\r\n            });\r\n        }\r\n        identifiers.push(identifier);\r\n    }\r\n    return identifiers;\r\n}\r\nfunction insertStyleElement(options) {\r\n    const style = document.createElement('style');\r\n    const attributes = options.attributes || {};\r\n    if (typeof attributes.nonce === 'undefined') {\r\n        const nonce = // eslint-disable-next-line no-undef\r\n         true ? __webpack_require__.nc : 0;\r\n        if (nonce) {\r\n            attributes.nonce = nonce;\r\n        }\r\n    }\r\n    Object.keys(attributes).forEach(function(key) {\r\n        style.setAttribute(key, attributes[key]);\r\n    });\r\n    if (typeof options.insert === 'function') {\r\n        options.insert(style);\r\n    } else {\r\n        const target = getTargetElement(options.insert || 'head');\r\n        if (!target) {\r\n            throw Object.defineProperty(new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\"), \"__NEXT_ERROR_CODE\", {\r\n                value: \"E245\",\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n        }\r\n        target.appendChild(style);\r\n    }\r\n    return style;\r\n}\r\nfunction removeStyleElement(style) {\r\n    // istanbul ignore if\r\n    if (style.parentNode === null) {\r\n        return false;\r\n    }\r\n    style.parentNode.removeChild(style);\r\n}\r\n/* istanbul ignore next  */ const replaceText = function replaceText() {\r\n    const textStore = [];\r\n    return function replace(index, replacement) {\r\n        textStore[index] = replacement;\r\n        return textStore.filter(Boolean).join('\\n');\r\n    };\r\n}();\r\nfunction applyToSingletonTag(style, index, remove, obj) {\r\n    const css = remove ? '' : obj.media ? '@media ' + obj.media + ' {' + obj.css + '}' : obj.css;\r\n    // For old IE\r\n    /* istanbul ignore if  */ if (style.styleSheet) {\r\n        style.styleSheet.cssText = replaceText(index, css);\r\n    } else {\r\n        const cssNode = document.createTextNode(css);\r\n        const childNodes = style.childNodes;\r\n        if (childNodes[index]) {\r\n            style.removeChild(childNodes[index]);\r\n        }\r\n        if (childNodes.length) {\r\n            style.insertBefore(cssNode, childNodes[index]);\r\n        } else {\r\n            style.appendChild(cssNode);\r\n        }\r\n    }\r\n}\r\nfunction applyToTag(style, _options, obj) {\r\n    let css = obj.css;\r\n    const media = obj.media;\r\n    const sourceMap = obj.sourceMap;\r\n    if (media) {\r\n        style.setAttribute('media', media);\r\n    } else {\r\n        style.removeAttribute('media');\r\n    }\r\n    if (sourceMap && typeof btoa !== 'undefined') {\r\n        css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */';\r\n    }\r\n    // For old IE\r\n    /* istanbul ignore if  */ if (style.styleSheet) {\r\n        style.styleSheet.cssText = css;\r\n    } else {\r\n        while(style.firstChild){\r\n            style.removeChild(style.firstChild);\r\n        }\r\n        style.appendChild(document.createTextNode(css));\r\n    }\r\n}\r\nlet singleton = null;\r\nlet singletonCounter = 0;\r\nfunction addStyle(obj, options) {\r\n    let style;\r\n    let update;\r\n    let remove;\r\n    if (options.singleton) {\r\n        const styleIndex = singletonCounter++;\r\n        style = singleton || (singleton = insertStyleElement(options));\r\n        update = applyToSingletonTag.bind(null, style, styleIndex, false);\r\n        remove = applyToSingletonTag.bind(null, style, styleIndex, true);\r\n    } else {\r\n        style = insertStyleElement(options);\r\n        update = applyToTag.bind(null, style, options);\r\n        remove = function() {\r\n            removeStyleElement(style);\r\n        };\r\n    }\r\n    update(obj);\r\n    return function updateStyle(newObj) {\r\n        if (newObj) {\r\n            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\r\n                return;\r\n            }\r\n            update(obj = newObj);\r\n        } else {\r\n            remove();\r\n        }\r\n    };\r\n}\r\nmodule.exports = function(list, options) {\r\n    options = options || {};\r\n    // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n    // tags it will allow on a page\r\n    if (!options.singleton && typeof options.singleton !== 'boolean') {\r\n        options.singleton = isOldIE();\r\n    }\r\n    list = list || [];\r\n    let lastIdentifiers = modulesToDom(list, options);\r\n    return function update(newList) {\r\n        newList = newList || [];\r\n        if (Object.prototype.toString.call(newList) !== '[object Array]') {\r\n            return;\r\n        }\r\n        for(let i = 0; i < lastIdentifiers.length; i++){\r\n            const identifier = lastIdentifiers[i];\r\n            const index = getIndexByIdentifier(identifier);\r\n            stylesInDom[index].references--;\r\n        }\r\n        const newLastIdentifiers = modulesToDom(newList, options);\r\n        for(let i = 0; i < lastIdentifiers.length; i++){\r\n            const identifier = lastIdentifiers[i];\r\n            const index = getIndexByIdentifier(identifier);\r\n            if (stylesInDom[index].references === 0) {\r\n                stylesInDom[index].updater();\r\n                stylesInDom.splice(index, 1);\r\n            }\r\n        }\r\n        lastIdentifiers = newLastIdentifiers;\r\n    };\r\n};\r\n\r\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUF3QyxHQUFHLHNCQUFpQixHQUFHLENBQUk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHFFQUFxRSxnQkFBZ0I7QUFDckY7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxidWlsZFxcd2VicGFja1xcbG9hZGVyc1xcbmV4dC1zdHlsZS1sb2FkZXJcXHJ1bnRpbWVcXGluamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSB0eXBlcz1cIndlYnBhY2svbW9kdWxlLmQudHNcIiAvPlxyXG5cInVzZSBzdHJpY3RcIjtcclxuY29uc3QgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XHJcbiAgICBsZXQgbWVtbztcclxuICAgIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG1lbW8gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXHJcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcclxuICAgICAgICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxyXG4gICAgICAgICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcclxuICAgICAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XHJcbiAgICAgICAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1lbW87XHJcbiAgICB9O1xyXG59KCk7XHJcbmNvbnN0IGdldFRhcmdldEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcclxuICAgIGNvbnN0IG1lbW8gPSB7fTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgbGV0IHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xyXG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxyXG4gICAgICAgICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xyXG4gICAgfTtcclxufSgpO1xyXG5jb25zdCBzdHlsZXNJbkRvbSA9IFtdO1xyXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gLTE7XHJcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGlkQ291bnRNYXAgPSB7fTtcclxuICAgIGNvbnN0IGlkZW50aWZpZXJzID0gW107XHJcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgY29uc3QgaXRlbSA9IGxpc3RbaV07XHJcbiAgICAgICAgY29uc3QgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcclxuICAgICAgICBjb25zdCBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XHJcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGlkICsgJyAnICsgY291bnQudG9TdHJpbmcoKTtcclxuICAgICAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xyXG4gICAgICAgIGNvbnN0IG9iaiA9IHtcclxuICAgICAgICAgICAgY3NzOiBpdGVtWzFdLFxyXG4gICAgICAgICAgICBtZWRpYTogaXRlbVsyXSxcclxuICAgICAgICAgICAgc291cmNlTWFwOiBpdGVtWzNdXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzKys7XHJcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlcjogYWRkU3R5bGUob2JqLCBvcHRpb25zKSxcclxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IDFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaWRlbnRpZmllcnM7XHJcbn1cclxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcclxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMgfHwge307XHJcbiAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgY29uc3Qgbm9uY2UgPSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcclxuICAgICAgICB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xyXG4gICAgICAgIGlmIChub25jZSkge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xyXG4gICAgfSk7XHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgb3B0aW9ucy5pbnNlcnQoc3R5bGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgdGhyb3cgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIiksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiRTI0NVwiLFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3R5bGU7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XHJcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcclxuICAgIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XHJcbn1cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovIGNvbnN0IHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XHJcbiAgICBjb25zdCB0ZXh0U3RvcmUgPSBbXTtcclxuICAgIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xyXG4gICAgICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcclxuICAgICAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcclxuICAgIH07XHJcbn0oKTtcclxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XHJcbiAgICBjb25zdCBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5tZWRpYSA/ICdAbWVkaWEgJyArIG9iai5tZWRpYSArICcgeycgKyBvYmouY3NzICsgJ30nIDogb2JqLmNzcztcclxuICAgIC8vIEZvciBvbGQgSUVcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcclxuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XHJcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XHJcbiAgICAgICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIF9vcHRpb25zLCBvYmopIHtcclxuICAgIGxldCBjc3MgPSBvYmouY3NzO1xyXG4gICAgY29uc3QgbWVkaWEgPSBvYmoubWVkaWE7XHJcbiAgICBjb25zdCBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xyXG4gICAgaWYgKG1lZGlhKSB7XHJcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdtZWRpYScpO1xyXG4gICAgfVxyXG4gICAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJztcclxuICAgIH1cclxuICAgIC8vIEZvciBvbGQgSUVcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcclxuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpe1xyXG4gICAgICAgICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XHJcbiAgICB9XHJcbn1cclxubGV0IHNpbmdsZXRvbiA9IG51bGw7XHJcbmxldCBzaW5nbGV0b25Db3VudGVyID0gMDtcclxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XHJcbiAgICBsZXQgc3R5bGU7XHJcbiAgICBsZXQgdXBkYXRlO1xyXG4gICAgbGV0IHJlbW92ZTtcclxuICAgIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xyXG4gICAgICAgIGNvbnN0IHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XHJcbiAgICAgICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XHJcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XHJcbiAgICAgICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XHJcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcclxuICAgICAgICByZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKG9iaik7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XHJcbiAgICAgICAgaWYgKG5ld09iaikge1xyXG4gICAgICAgICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XHJcbiAgICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcbiAgICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XHJcbiAgICB9XHJcbiAgICBsaXN0ID0gbGlzdCB8fCBbXTtcclxuICAgIGxldCBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcclxuICAgICAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgaWYgKHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcigpO1xyXG4gICAgICAgICAgICAgICAgc3R5bGVzSW5Eb20uc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XHJcbiAgICB9O1xyXG59O1xyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/react-toastify/dist/ReactToastify.css":
/*!************************************************************!*\
  !*** ./node_modules/react-toastify/dist/ReactToastify.css ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../../next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[11].use[1]!../../next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[11].use[2]!./ReactToastify.css */ \"(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[11].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[11].use[2]!./node_modules/react-toastify/dist/ReactToastify.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\r\n                    // By default, style-loader injects CSS into the bottom\r\n                    // of <head>. This causes ordering problems between dev\r\n                    // and prod. To fix this, we render a <noscript> tag as\r\n                    // an anchor for the styles to be placed before. These\r\n                    // styles will be applied _before_ <style jsx global>.\r\n                    // These elements should always exist. If they do not,\r\n                    // this code should fail.\r\n                    var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');\r\n                    var parentNode = anchorElement.parentNode// Normally <head>\r\n                    ;\r\n                    // Each style tag should be placed right before our\r\n                    // anchor. By inserting before and not after, we do not\r\n                    // need to track the last inserted element.\r\n                    parentNode.insertBefore(element, anchorElement);\r\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\r\n    if (!a && b || a && !b) {\r\n        return false;\r\n    }\r\n    let p;\r\n    for(p in a){\r\n        if (isNamedExport && p === 'default') {\r\n            continue;\r\n        }\r\n        if (a[p] !== b[p]) {\r\n            return false;\r\n        }\r\n    }\r\n    for(p in b){\r\n        if (isNamedExport && p === 'default') {\r\n            continue;\r\n        }\r\n        if (!a[p]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[11].use[1]!../../next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[11].use[2]!./ReactToastify.css */ \"(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[11].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[11].use[2]!./node_modules/react-toastify/dist/ReactToastify.css\",\n      function () {\n        content = __webpack_require__(/*! !!../../next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[11].use[1]!../../next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[11].use[2]!./ReactToastify.css */ \"(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[11].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[11].use[2]!./node_modules/react-toastify/dist/ReactToastify.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC10b2FzdGlmeS9kaXN0L1JlYWN0VG9hc3RpZnkuY3NzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyw4TkFBOEY7QUFDaEgsMEJBQTBCLG1CQUFPLENBQUMsaWhCQUFtTzs7QUFFclE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLElBQUksSUFBVTtBQUNkLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlCQUFpQjtBQUNyQixNQUFNLGloQkFBbU87QUFDek87QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxpaEJBQW1POztBQUU3UDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLFVBQVU7QUFDWjtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVhY3QtdG9hc3RpZnlcXGRpc3RcXFJlYWN0VG9hc3RpZnkuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbOF0ub25lT2ZbMTFdLnVzZVsxXSEuLi8uLi9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s4XS5vbmVPZlsxMV0udXNlWzJdIS4vUmVhY3RUb2FzdGlmeS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgc3R5bGUtbG9hZGVyIGluamVjdHMgQ1NTIGludG8gdGhlIGJvdHRvbVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIDxoZWFkPi4gVGhpcyBjYXVzZXMgb3JkZXJpbmcgcHJvYmxlbXMgYmV0d2VlbiBkZXZcclxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcHJvZC4gVG8gZml4IHRoaXMsIHdlIHJlbmRlciBhIDxub3NjcmlwdD4gdGFnIGFzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gYW5jaG9yIGZvciB0aGUgc3R5bGVzIHRvIGJlIHBsYWNlZCBiZWZvcmUuIFRoZXNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBfYmVmb3JlXyA8c3R5bGUganN4IGdsb2JhbD4uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcclxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYW5jaG9yRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XHJcbiAgICBpZiAoIWEgJiYgYiB8fCBhICYmICFiKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbGV0IHA7XHJcbiAgICBmb3IocCBpbiBhKXtcclxuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IocCBpbiBiKXtcclxuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYVtwXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s4XS5vbmVPZlsxMV0udXNlWzFdIS4uLy4uL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzhdLm9uZU9mWzExXS51c2VbMl0hLi9SZWFjdFRvYXN0aWZ5LmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s4XS5vbmVPZlsxMV0udXNlWzFdIS4uLy4uL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzhdLm9uZU9mWzExXS51c2VbMl0hLi9SZWFjdFRvYXN0aWZ5LmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/react-toastify/dist/ReactToastify.css\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/react-toastify/dist/react-toastify.esm.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/react-toastify/dist/react-toastify.esm.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bounce: () => (/* binding */ R),\n/* harmony export */   Flip: () => (/* binding */ $),\n/* harmony export */   Icons: () => (/* binding */ E),\n/* harmony export */   Slide: () => (/* binding */ w),\n/* harmony export */   ToastContainer: () => (/* binding */ k),\n/* harmony export */   Zoom: () => (/* binding */ x),\n/* harmony export */   collapseToast: () => (/* binding */ g),\n/* harmony export */   cssTransition: () => (/* binding */ h),\n/* harmony export */   toast: () => (/* binding */ Q),\n/* harmony export */   useToast: () => (/* binding */ _),\n/* harmony export */   useToastContainer: () => (/* binding */ C)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(pages-dir-browser)/./node_modules/react-toastify/node_modules/clsx/dist/clsx.m.js\");\n'use client';\r\nconst u=t=>\"number\"==typeof t&&!isNaN(t),d=t=>\"string\"==typeof t,p=t=>\"function\"==typeof t,m=t=>d(t)||p(t)?t:null,f=t=>(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(t)||d(t)||p(t)||u(t);function g(t,e,n){void 0===n&&(n=300);const{scrollHeight:o,style:s}=t;requestAnimationFrame(()=>{s.minHeight=\"initial\",s.height=o+\"px\",s.transition=`all ${n}ms`,requestAnimationFrame(()=>{s.height=\"0\",s.padding=\"0\",s.margin=\"0\",setTimeout(e,n)})})}function h(e){let{enter:a,exit:r,appendPosition:i=!1,collapse:l=!0,collapseDuration:c=300}=e;return function(e){let{children:u,position:d,preventExitTransition:p,done:m,nodeRef:f,isIn:h}=e;const y=i?`${a}--${d}`:a,v=i?`${r}--${d}`:r,T=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);return (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{const t=f.current,e=y.split(\" \"),n=o=>{o.target===f.current&&(t.dispatchEvent(new Event(\"d\")),t.removeEventListener(\"animationend\",n),t.removeEventListener(\"animationcancel\",n),0===T.current&&\"animationcancel\"!==o.type&&t.classList.remove(...e))};t.classList.add(...e),t.addEventListener(\"animationend\",n),t.addEventListener(\"animationcancel\",n)},[]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{const t=f.current,e=()=>{t.removeEventListener(\"animationend\",e),l?g(t,m,c):m()};h||(p?e():(T.current=1,t.className+=` ${v}`,t.addEventListener(\"animationend\",e)))},[h]),react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,u)}}function y(t,e){return null!=t?{content:t.content,containerId:t.props.containerId,id:t.props.toastId,theme:t.props.theme,type:t.props.type,data:t.props.data||{},isLoading:t.props.isLoading,icon:t.props.icon,status:e}:{}}const v={list:new Map,emitQueue:new Map,on(t,e){return this.list.has(t)||this.list.set(t,[]),this.list.get(t).push(e),this},off(t,e){if(e){const n=this.list.get(t).filter(t=>t!==e);return this.list.set(t,n),this}return this.list.delete(t),this},cancelEmit(t){const e=this.emitQueue.get(t);return e&&(e.forEach(clearTimeout),this.emitQueue.delete(t)),this},emit(t){this.list.has(t)&&this.list.get(t).forEach(e=>{const n=setTimeout(()=>{e(...[].slice.call(arguments,1))},0);this.emitQueue.has(t)||this.emitQueue.set(t,[]),this.emitQueue.get(t).push(n)})}},T=e=>{let{theme:n,type:o,...s}=e;return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\",{viewBox:\"0 0 24 24\",width:\"100%\",height:\"100%\",fill:\"colored\"===n?\"currentColor\":`var(--toastify-icon-color-${o})`,...s})},E={info:function(e){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(T,{...e},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\",{d:\"M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z\"}))},warning:function(e){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(T,{...e},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\",{d:\"M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z\"}))},success:function(e){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(T,{...e},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\",{d:\"M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z\"}))},error:function(e){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(T,{...e},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\",{d:\"M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z\"}))},spinner:function(){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{className:\"Toastify__spinner\"})}};function C(t){const[,o]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(t=>t+1,0),[l,c]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]),g=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),h=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map).current,T=t=>-1!==l.indexOf(t),C=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({toastKey:1,displayedToast:0,count:0,queue:[],props:t,containerId:null,isToastActive:T,getToast:t=>h.get(t)}).current;function b(t){let{containerId:e}=t;const{limit:n}=C.props;!n||e&&C.containerId!==e||(C.count-=C.queue.length,C.queue=[])}function I(t){c(e=>null==t?[]:e.filter(e=>e!==t))}function _(){const{toastContent:t,toastProps:e,staleId:n}=C.queue.shift();O(t,e,n)}function L(t,n){let{delay:s,staleId:r,...i}=n;if(!f(t)||function(t){return!g.current||C.props.enableMultiContainer&&t.containerId!==C.props.containerId||h.has(t.toastId)&&null==t.updateId}(i))return;const{toastId:l,updateId:c,data:T}=i,{props:b}=C,L=()=>I(l),N=null==c;N&&C.count++;const M={...b,style:b.toastStyle,key:C.toastKey++,...Object.fromEntries(Object.entries(i).filter(t=>{let[e,n]=t;return null!=n})),toastId:l,updateId:c,data:T,closeToast:L,isIn:!1,className:m(i.className||b.toastClassName),bodyClassName:m(i.bodyClassName||b.bodyClassName),progressClassName:m(i.progressClassName||b.progressClassName),autoClose:!i.isLoading&&(R=i.autoClose,w=b.autoClose,!1===R||u(R)&&R>0?R:w),deleteToast(){const t=y(h.get(l),\"removed\");h.delete(l),v.emit(4,t);const e=C.queue.length;if(C.count=null==l?C.count-C.displayedToast:C.count-1,C.count<0&&(C.count=0),e>0){const t=null==l?C.props.limit:1;if(1===e||1===t)C.displayedToast++,_();else{const n=t>e?e:t;C.displayedToast=n;for(let t=0;t<n;t++)_()}}else o()}};var R,w;M.iconOut=function(t){let{theme:n,type:o,isLoading:s,icon:r}=t,i=null;const l={theme:n,type:o};return!1===r||(p(r)?i=r(l):(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(r)?i=(0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(r,l):d(r)||u(r)?i=r:s?i=E.spinner():(t=>t in E)(o)&&(i=E[o](l))),i}(M),p(i.onOpen)&&(M.onOpen=i.onOpen),p(i.onClose)&&(M.onClose=i.onClose),M.closeButton=b.closeButton,!1===i.closeButton||f(i.closeButton)?M.closeButton=i.closeButton:!0===i.closeButton&&(M.closeButton=!f(b.closeButton)||b.closeButton);let x=t;(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(t)&&!d(t.type)?x=(0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(t,{closeToast:L,toastProps:M,data:T}):p(t)&&(x=t({closeToast:L,toastProps:M,data:T})),b.limit&&b.limit>0&&C.count>b.limit&&N?C.queue.push({toastContent:x,toastProps:M,staleId:r}):u(s)?setTimeout(()=>{O(x,M,r)},s):O(x,M,r)}function O(t,e,n){const{toastId:o}=e;n&&h.delete(n);const s={content:t,props:e};h.set(o,s),c(t=>[...t,o].filter(t=>t!==n)),v.emit(4,y(s,null==s.props.updateId?\"added\":\"updated\"))}return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>(C.containerId=t.containerId,v.cancelEmit(3).on(0,L).on(1,t=>g.current&&I(t)).on(5,b).emit(2,C),()=>{h.clear(),v.emit(3,C)}),[]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{C.props=t,C.isToastActive=T,C.displayedToast=l.length}),{getToastToRender:function(e){const n=new Map,o=Array.from(h.values());return t.newestOnTop&&o.reverse(),o.forEach(t=>{const{position:e}=t.props;n.has(e)||n.set(e,[]),n.get(e).push(t)}),Array.from(n,t=>e(t[0],t[1]))},containerRef:g,isToastActive:T}}function b(t){return t.targetTouches&&t.targetTouches.length>=1?t.targetTouches[0].clientX:t.clientX}function I(t){return t.targetTouches&&t.targetTouches.length>=1?t.targetTouches[0].clientY:t.clientY}function _(t){const[o,a]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1),[r,l]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1),c=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),u=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({start:0,x:0,y:0,delta:0,removalDistance:0,canCloseOnClick:!0,canDrag:!1,boundingRect:null,didMove:!1}).current,d=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(t),{autoClose:m,pauseOnHover:f,closeToast:g,onClick:h,closeOnClick:y}=t;function v(e){if(t.draggable){\"touchstart\"===e.nativeEvent.type&&e.nativeEvent.preventDefault(),u.didMove=!1,document.addEventListener(\"mousemove\",_),document.addEventListener(\"mouseup\",L),document.addEventListener(\"touchmove\",_),document.addEventListener(\"touchend\",L);const n=c.current;u.canCloseOnClick=!0,u.canDrag=!0,u.boundingRect=n.getBoundingClientRect(),n.style.transition=\"\",u.x=b(e.nativeEvent),u.y=I(e.nativeEvent),\"x\"===t.draggableDirection?(u.start=u.x,u.removalDistance=n.offsetWidth*(t.draggablePercent/100)):(u.start=u.y,u.removalDistance=n.offsetHeight*(80===t.draggablePercent?1.5*t.draggablePercent:t.draggablePercent/100))}}function T(e){if(u.boundingRect){const{top:n,bottom:o,left:s,right:a}=u.boundingRect;\"touchend\"!==e.nativeEvent.type&&t.pauseOnHover&&u.x>=s&&u.x<=a&&u.y>=n&&u.y<=o?C():E()}}function E(){a(!0)}function C(){a(!1)}function _(e){const n=c.current;u.canDrag&&n&&(u.didMove=!0,o&&C(),u.x=b(e),u.y=I(e),u.delta=\"x\"===t.draggableDirection?u.x-u.start:u.y-u.start,u.start!==u.x&&(u.canCloseOnClick=!1),n.style.transform=`translate${t.draggableDirection}(${u.delta}px)`,n.style.opacity=\"\"+(1-Math.abs(u.delta/u.removalDistance)))}function L(){document.removeEventListener(\"mousemove\",_),document.removeEventListener(\"mouseup\",L),document.removeEventListener(\"touchmove\",_),document.removeEventListener(\"touchend\",L);const e=c.current;if(u.canDrag&&u.didMove&&e){if(u.canDrag=!1,Math.abs(u.delta)>u.removalDistance)return l(!0),void t.closeToast();e.style.transition=\"transform 0.2s, opacity 0.2s\",e.style.transform=`translate${t.draggableDirection}(0)`,e.style.opacity=\"1\"}}(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{d.current=t}),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>(c.current&&c.current.addEventListener(\"d\",E,{once:!0}),p(t.onOpen)&&t.onOpen((0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(t.children)&&t.children.props),()=>{const t=d.current;p(t.onClose)&&t.onClose((0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(t.children)&&t.children.props)}),[]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>(t.pauseOnFocusLoss&&(document.hasFocus()||C(),window.addEventListener(\"focus\",E),window.addEventListener(\"blur\",C)),()=>{t.pauseOnFocusLoss&&(window.removeEventListener(\"focus\",E),window.removeEventListener(\"blur\",C))}),[t.pauseOnFocusLoss]);const O={onMouseDown:v,onTouchStart:v,onMouseUp:T,onTouchEnd:T};return m&&f&&(O.onMouseEnter=C,O.onMouseLeave=E),y&&(O.onClick=t=>{h&&h(t),u.canCloseOnClick&&g()}),{playToast:E,pauseToast:C,isRunning:o,preventExitTransition:r,toastRef:c,eventHandlers:O}}function L(e){let{closeToast:n,theme:o,ariaLabel:s=\"close\"}=e;return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\",{className:`Toastify__close-button Toastify__close-button--${o}`,type:\"button\",onClick:t=>{t.stopPropagation(),n(t)},\"aria-label\":s},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\",{\"aria-hidden\":\"true\",viewBox:\"0 0 14 16\"},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\",{fillRule:\"evenodd\",d:\"M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z\"})))}function O(e){let{delay:n,isRunning:o,closeToast:s,type:a=\"default\",hide:r,className:i,style:l,controlledProgress:u,progress:d,rtl:m,isIn:f,theme:g}=e;const h=r||u&&0===d,y={...l,animationDuration:`${n}ms`,animationPlayState:o?\"running\":\"paused\",opacity:h?0:1};u&&(y.transform=`scaleX(${d})`);const v=(0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"Toastify__progress-bar\",u?\"Toastify__progress-bar--controlled\":\"Toastify__progress-bar--animated\",`Toastify__progress-bar-theme--${g}`,`Toastify__progress-bar--${a}`,{\"Toastify__progress-bar--rtl\":m}),T=p(i)?i({rtl:m,type:a,defaultClassName:v}):(0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(v,i);return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{role:\"progressbar\",\"aria-hidden\":h?\"true\":\"false\",\"aria-label\":\"notification timer\",className:T,style:y,[u&&d>=1?\"onTransitionEnd\":\"onAnimationEnd\"]:u&&d<1?null:()=>{f&&s()}})}const N=n=>{const{isRunning:o,preventExitTransition:s,toastRef:r,eventHandlers:i}=_(n),{closeButton:l,children:u,autoClose:d,onClick:m,type:f,hideProgressBar:g,closeToast:h,transition:y,position:v,className:T,style:E,bodyClassName:C,bodyStyle:b,progressClassName:I,progressStyle:N,updateId:M,role:R,progress:w,rtl:x,toastId:$,deleteToast:k,isIn:P,isLoading:B,iconOut:D,closeOnClick:A,theme:z}=n,F=(0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"Toastify__toast\",`Toastify__toast-theme--${z}`,`Toastify__toast--${f}`,{\"Toastify__toast--rtl\":x},{\"Toastify__toast--close-on-click\":A}),H=p(T)?T({rtl:x,position:v,type:f,defaultClassName:F}):(0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(F,T),S=!!w||!d,q={closeToast:h,type:f,theme:z};let Q=null;return!1===l||(Q=p(l)?l(q):(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(l)?(0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(l,q):L(q)),react__WEBPACK_IMPORTED_MODULE_0__.createElement(y,{isIn:P,done:k,position:v,preventExitTransition:s,nodeRef:r},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{id:$,onClick:m,className:H,...i,style:E,ref:r},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{...P&&{role:R},className:p(C)?C({type:f}):(0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"Toastify__toast-body\",C),style:b},null!=D&&react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{className:(0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"Toastify__toast-icon\",{\"Toastify--animate-icon Toastify__zoom-enter\":!B})},D),react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",null,u)),Q,react__WEBPACK_IMPORTED_MODULE_0__.createElement(O,{...M&&!S?{key:`pb-${M}`}:{},rtl:x,theme:z,delay:d,isRunning:o,isIn:P,closeToast:h,hide:g,type:f,style:N,className:I,controlledProgress:S,progress:w||0})))},M=function(t,e){return void 0===e&&(e=!1),{enter:`Toastify--animate Toastify__${t}-enter`,exit:`Toastify--animate Toastify__${t}-exit`,appendPosition:e}},R=h(M(\"bounce\",!0)),w=h(M(\"slide\",!0)),x=h(M(\"zoom\")),$=h(M(\"flip\")),k=(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e,n)=>{const{getToastToRender:o,containerRef:a,isToastActive:r}=C(e),{className:i,style:l,rtl:u,containerId:d}=e;function f(t){const e=(0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"Toastify__toast-container\",`Toastify__toast-container--${t}`,{\"Toastify__toast-container--rtl\":u});return p(i)?i({position:t,rtl:u,defaultClassName:e}):(0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(e,m(i))}return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{n&&(n.current=a.current)},[]),react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{ref:a,className:\"Toastify\",id:d},o((e,n)=>{const o=n.length?{...l}:{...l,pointerEvents:\"none\"};return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{className:f(e),style:o,key:`container-${e}`},n.map((e,o)=>{let{content:s,props:a}=e;return react__WEBPACK_IMPORTED_MODULE_0__.createElement(N,{...a,isIn:r(a.toastId),style:{...a.style,\"--nth\":o+1,\"--len\":n.length},key:`toast-${a.key}`},s)}))}))});k.displayName=\"ToastContainer\",k.defaultProps={position:\"top-right\",transition:R,autoClose:5e3,closeButton:L,pauseOnHover:!0,pauseOnFocusLoss:!0,closeOnClick:!0,draggable:!0,draggablePercent:80,draggableDirection:\"x\",role:\"alert\",theme:\"light\"};let P,B=new Map,D=[],A=1;function z(){return\"\"+A++}function F(t){return t&&(d(t.toastId)||u(t.toastId))?t.toastId:z()}function H(t,e){return B.size>0?v.emit(0,t,e):D.push({content:t,options:e}),e.toastId}function S(t,e){return{...e,type:e&&e.type||t,toastId:F(e)}}function q(t){return(e,n)=>H(e,S(t,n))}function Q(t,e){return H(t,S(\"default\",e))}Q.loading=(t,e)=>H(t,S(\"default\",{isLoading:!0,autoClose:!1,closeOnClick:!1,closeButton:!1,draggable:!1,...e})),Q.promise=function(t,e,n){let o,{pending:s,error:a,success:r}=e;s&&(o=d(s)?Q.loading(s,n):Q.loading(s.render,{...n,...s}));const i={isLoading:null,autoClose:null,closeOnClick:null,closeButton:null,draggable:null},l=(t,e,s)=>{if(null==e)return void Q.dismiss(o);const a={type:t,...i,...n,data:s},r=d(e)?{render:e}:e;return o?Q.update(o,{...a,...r}):Q(r.render,{...a,...r}),s},c=p(t)?t():t;return c.then(t=>l(\"success\",r,t)).catch(t=>l(\"error\",a,t)),c},Q.success=q(\"success\"),Q.info=q(\"info\"),Q.error=q(\"error\"),Q.warning=q(\"warning\"),Q.warn=Q.warning,Q.dark=(t,e)=>H(t,S(\"default\",{theme:\"dark\",...e})),Q.dismiss=t=>{B.size>0?v.emit(1,t):D=D.filter(e=>null!=t&&e.options.toastId!==t)},Q.clearWaitingQueue=function(t){return void 0===t&&(t={}),v.emit(5,t)},Q.isActive=t=>{let e=!1;return B.forEach(n=>{n.isToastActive&&n.isToastActive(t)&&(e=!0)}),e},Q.update=function(t,e){void 0===e&&(e={}),setTimeout(()=>{const n=function(t,e){let{containerId:n}=e;const o=B.get(n||P);return o&&o.getToast(t)}(t,e);if(n){const{props:o,content:s}=n,a={delay:100,...o,...e,toastId:e.toastId||t,updateId:z()};a.toastId!==t&&(a.staleId=t);const r=a.render||s;delete a.render,H(r,a)}},0)},Q.done=t=>{Q.update(t,{progress:1})},Q.onChange=t=>(v.on(4,t),()=>{v.off(4,t)}),Q.POSITION={TOP_LEFT:\"top-left\",TOP_RIGHT:\"top-right\",TOP_CENTER:\"top-center\",BOTTOM_LEFT:\"bottom-left\",BOTTOM_RIGHT:\"bottom-right\",BOTTOM_CENTER:\"bottom-center\"},Q.TYPE={INFO:\"info\",SUCCESS:\"success\",WARNING:\"warning\",ERROR:\"error\",DEFAULT:\"default\"},v.on(2,t=>{P=t.containerId||t,B.set(P,t),D.forEach(t=>{v.emit(0,t.content,t.options)}),D=[]}).on(3,t=>{B.delete(t.containerId||t),0===B.size&&v.off(0).off(1).off(5)});\r\n//# sourceMappingURL=react-toastify.esm.mjs.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC10b2FzdGlmeS9kaXN0L3JlYWN0LXRvYXN0aWZ5LmVzbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQzhLLHVIQUF1SCxxREFBQyxzQkFBc0Isa0JBQWtCLG9CQUFvQixNQUFNLHVCQUF1QixHQUFHLDJCQUEyQiwwREFBMEQsRUFBRSwrQkFBK0Isd0RBQXdELEVBQUUsRUFBRSxjQUFjLElBQUksd0VBQXdFLEdBQUcsbUJBQW1CLElBQUksc0VBQXNFLEdBQUcsYUFBYSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLE1BQU0sNkNBQUMsSUFBSSxPQUFPLHNEQUFDLE1BQU0sdUNBQXVDLGdOQUFnTixtR0FBbUcsS0FBSyxnREFBQyxNQUFNLHlCQUF5Qix3REFBd0Qsd0NBQXdDLEVBQUUseUNBQXlDLE1BQU0sZ0RBQWUsQ0FBQywyQ0FBVSxVQUFVLGdCQUFnQixnQkFBZ0IsZ0lBQWdJLHdEQUF3RCxJQUFJLFNBQVMsdUNBQXVDLDJFQUEyRSxVQUFVLE1BQU0sMENBQTBDLCtCQUErQixnQ0FBZ0MsZUFBZSw4QkFBOEIsa0VBQWtFLFNBQVMsK0NBQStDLHdCQUF3QixpQ0FBaUMsSUFBSSw4RUFBOEUsR0FBRyxPQUFPLElBQUksb0JBQW9CLEdBQUcsT0FBTyxnREFBZSxRQUFRLDhHQUE4RyxFQUFFLFFBQVEsRUFBRSxJQUFJLGlCQUFpQixPQUFPLGdEQUFlLElBQUksS0FBSyxDQUFDLGdEQUFlLFNBQVMsa1BBQWtQLEdBQUcscUJBQXFCLE9BQU8sZ0RBQWUsSUFBSSxLQUFLLENBQUMsZ0RBQWUsU0FBUywrZUFBK2UsR0FBRyxxQkFBcUIsT0FBTyxnREFBZSxJQUFJLEtBQUssQ0FBQyxnREFBZSxTQUFTLCtLQUErSyxHQUFHLG1CQUFtQixPQUFPLGdEQUFlLElBQUksS0FBSyxDQUFDLGdEQUFlLFNBQVMsdVVBQXVVLEdBQUcsb0JBQW9CLE9BQU8sZ0RBQWUs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LDhEQUE4RCxFQUEwSztBQUN2c2UiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlYWN0LXRvYXN0aWZ5XFxkaXN0XFxyZWFjdC10b2FzdGlmeS5lc20ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuaW1wb3J0IHQse2lzVmFsaWRFbGVtZW50IGFzIGUsdXNlUmVmIGFzIG4sdXNlTGF5b3V0RWZmZWN0IGFzIG8sdXNlRWZmZWN0IGFzIHMsY2xvbmVFbGVtZW50IGFzIGEsdXNlUmVkdWNlciBhcyByLHVzZVN0YXRlIGFzIGksZm9yd2FyZFJlZiBhcyBsfWZyb21cInJlYWN0XCI7aW1wb3J0IGMgZnJvbVwiY2xzeFwiO2NvbnN0IHU9dD0+XCJudW1iZXJcIj09dHlwZW9mIHQmJiFpc05hTih0KSxkPXQ9Plwic3RyaW5nXCI9PXR5cGVvZiB0LHA9dD0+XCJmdW5jdGlvblwiPT10eXBlb2YgdCxtPXQ9PmQodCl8fHAodCk/dDpudWxsLGY9dD0+ZSh0KXx8ZCh0KXx8cCh0KXx8dSh0KTtmdW5jdGlvbiBnKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0zMDApO2NvbnN0e3Njcm9sbEhlaWdodDpvLHN0eWxlOnN9PXQ7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57cy5taW5IZWlnaHQ9XCJpbml0aWFsXCIscy5oZWlnaHQ9bytcInB4XCIscy50cmFuc2l0aW9uPWBhbGwgJHtufW1zYCxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PntzLmhlaWdodD1cIjBcIixzLnBhZGRpbmc9XCIwXCIscy5tYXJnaW49XCIwXCIsc2V0VGltZW91dChlLG4pfSl9KX1mdW5jdGlvbiBoKGUpe2xldHtlbnRlcjphLGV4aXQ6cixhcHBlbmRQb3NpdGlvbjppPSExLGNvbGxhcHNlOmw9ITAsY29sbGFwc2VEdXJhdGlvbjpjPTMwMH09ZTtyZXR1cm4gZnVuY3Rpb24oZSl7bGV0e2NoaWxkcmVuOnUscG9zaXRpb246ZCxwcmV2ZW50RXhpdFRyYW5zaXRpb246cCxkb25lOm0sbm9kZVJlZjpmLGlzSW46aH09ZTtjb25zdCB5PWk/YCR7YX0tLSR7ZH1gOmEsdj1pP2Ake3J9LS0ke2R9YDpyLFQ9bigwKTtyZXR1cm4gbygoKT0+e2NvbnN0IHQ9Zi5jdXJyZW50LGU9eS5zcGxpdChcIiBcIiksbj1vPT57by50YXJnZXQ9PT1mLmN1cnJlbnQmJih0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiZFwiKSksdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsbiksdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uY2FuY2VsXCIsbiksMD09PVQuY3VycmVudCYmXCJhbmltYXRpb25jYW5jZWxcIiE9PW8udHlwZSYmdC5jbGFzc0xpc3QucmVtb3ZlKC4uLmUpKX07dC5jbGFzc0xpc3QuYWRkKC4uLmUpLHQuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLG4pLHQuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmNhbmNlbFwiLG4pfSxbXSkscygoKT0+e2NvbnN0IHQ9Zi5jdXJyZW50LGU9KCk9Pnt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIixlKSxsP2codCxtLGMpOm0oKX07aHx8KHA/ZSgpOihULmN1cnJlbnQ9MSx0LmNsYXNzTmFtZSs9YCAke3Z9YCx0LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIixlKSkpfSxbaF0pLHQuY3JlYXRlRWxlbWVudCh0LkZyYWdtZW50LG51bGwsdSl9fWZ1bmN0aW9uIHkodCxlKXtyZXR1cm4gbnVsbCE9dD97Y29udGVudDp0LmNvbnRlbnQsY29udGFpbmVySWQ6dC5wcm9wcy5jb250YWluZXJJZCxpZDp0LnByb3BzLnRvYXN0SWQsdGhlbWU6dC5wcm9wcy50aGVtZSx0eXBlOnQucHJvcHMudHlwZSxkYXRhOnQucHJvcHMuZGF0YXx8e30saXNMb2FkaW5nOnQucHJvcHMuaXNMb2FkaW5nLGljb246dC5wcm9wcy5pY29uLHN0YXR1czplfTp7fX1jb25zdCB2PXtsaXN0Om5ldyBNYXAsZW1pdFF1ZXVlOm5ldyBNYXAsb24odCxlKXtyZXR1cm4gdGhpcy5saXN0Lmhhcyh0KXx8dGhpcy5saXN0LnNldCh0LFtdKSx0aGlzLmxpc3QuZ2V0KHQpLnB1c2goZSksdGhpc30sb2ZmKHQsZSl7aWYoZSl7Y29uc3Qgbj10aGlzLmxpc3QuZ2V0KHQpLmZpbHRlcih0PT50IT09ZSk7cmV0dXJuIHRoaXMubGlzdC5zZXQodCxuKSx0aGlzfXJldHVybiB0aGlzLmxpc3QuZGVsZXRlKHQpLHRoaXN9LGNhbmNlbEVtaXQodCl7Y29uc3QgZT10aGlzLmVtaXRRdWV1ZS5nZXQodCk7cmV0dXJuIGUmJihlLmZvckVhY2goY2xlYXJUaW1lb3V0KSx0aGlzLmVtaXRRdWV1ZS5kZWxldGUodCkpLHRoaXN9LGVtaXQodCl7dGhpcy5saXN0Lmhhcyh0KSYmdGhpcy5saXN0LmdldCh0KS5mb3JFYWNoKGU9Pntjb25zdCBuPXNldFRpbWVvdXQoKCk9PntlKC4uLltdLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKX0sMCk7dGhpcy5lbWl0UXVldWUuaGFzKHQpfHx0aGlzLmVtaXRRdWV1ZS5zZXQodCxbXSksdGhpcy5lbWl0UXVldWUuZ2V0KHQpLnB1c2gobil9KX19LFQ9ZT0+e2xldHt0aGVtZTpuLHR5cGU6bywuLi5zfT1lO3JldHVybiB0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIix7dmlld0JveDpcIjAgMCAyNCAyNFwiLHdpZHRoOlwiMTAwJVwiLGhlaWdodDpcIjEwMCVcIixmaWxsOlwiY29sb3JlZFwiPT09bj9cImN1cnJlbnRDb2xvclwiOmB2YXIoLS10b2FzdGlmeS1pY29uLWNvbG9yLSR7b30pYCwuLi5zfSl9LEU9e2luZm86ZnVuY3Rpb24oZSl7cmV0dXJuIHQuY3JlYXRlRWxlbWVudChULHsuLi5lfSx0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIse2Q6XCJNMTIgMGExMiAxMiAwIDEwMTIgMTJBMTIuMDEzIDEyLjAxMyAwIDAwMTIgMHptLjI1IDVhMS41IDEuNSAwIDExLTEuNSAxLjUgMS41IDEuNSAwIDAxMS41LTEuNXptMi4yNSAxMy41aC00YTEgMSAwIDAxMC0yaC43NWEuMjUuMjUgMCAwMC4yNS0uMjV2LTQuNWEuMjUuMjUgMCAwMC0uMjUtLjI1aC0uNzVhMSAxIDAgMDEwLTJoMWEyIDIgMCAwMTIgMnY0Ljc1YS4yNS4yNSAwIDAwLjI1LjI1aC43NWExIDEgMCAxMTAgMnpcIn0pKX0sd2FybmluZzpmdW5jdGlvbihlKXtyZXR1cm4gdC5jcmVhdGVFbGVtZW50KFQsey4uLmV9LHQuY3JlYXRlRWxlbWVudChcInBhdGhcIix7ZDpcIk0yMy4zMiAxNy4xOTFMMTUuNDM4IDIuMTg0QzE0LjcyOC44MzMgMTMuNDE2IDAgMTEuOTk2IDBjLTEuNDIgMC0yLjczMy44MzMtMy40NDMgMi4xODRMLjUzMyAxNy40NDhhNC43NDQgNC43NDQgMCAwMDAgNC4zNjhDMS4yNDMgMjMuMTY3IDIuNTU1IDI0IDMuOTc1IDI0aDE2LjA1QzIyLjIyIDI0IDI0IDIyLjA0NCAyNCAxOS42MzJjMC0uOTA0LS4yNTEtMS43NDYtLjY4LTIuNDR6bS05LjYyMiAxLjQ2YzAgMS4wMzMtLjcyNCAxLjgyMy0xLjY5OCAxLjgyM3MtMS42OTgtLjc5LTEuNjk4LTEuODIydi0uMDQzYzAtMS4wMjguNzI0LTEuODIyIDEuNjk4LTEuODIyczEuNjk4Ljc5IDEuNjk4IDEuODIydi4wNDN6bS4wMzktMTIuMjg1bC0uODQgOC4wNmMtLjA1Ny41ODEtLjQwOC45NDMtLjg5Ny45NDMtLjQ5IDAtLjg0LS4zNjctLjg5Ni0uOTQybC0uODQtOC4wNjVjLS4wNTctLjYyNC4yNS0xLjA5NS43NzktMS4wOTVoMS45MWMuNTI4LjAwNS44NC40NzYuNzg0IDEuMXpcIn0pKX0sc3VjY2VzczpmdW5jdGlvbihlKXtyZXR1cm4gdC5jcmVhdGVFbGVtZW50KFQsey4uLmV9LHQuY3JlYXRlRWxlbWVudChcInBhdGhcIix7ZDpcIk0xMiAwYTEyIDEyIDAgMTAxMiAxMkExMi4wMTQgMTIuMDE0IDAgMDAxMiAwem02LjkyNyA4LjJsLTYuODQ1IDkuMjg5YTEuMDExIDEuMDExIDAgMDEtMS40My4xODhsLTQuODg4LTMuOTA4YTEgMSAwIDExMS4yNS0xLjU2Mmw0LjA3NiAzLjI2MSA2LjIyNy04LjQ1MWExIDEgMCAxMTEuNjEgMS4xODN6XCJ9KSl9LGVycm9yOmZ1bmN0aW9uKGUpe3JldHVybiB0LmNyZWF0ZUVsZW1lbnQoVCx7Li4uZX0sdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtkOlwiTTExLjk4MyAwYTEyLjIwNiAxMi4yMDYgMCAwMC04LjUxIDMuNjUzQTExLjggMTEuOCAwIDAwMCAxMi4yMDcgMTEuNzc5IDExLjc3OSAwIDAwMTEuOCAyNGguMjE0QTEyLjExMSAxMi4xMTEgMCAwMDI0IDExLjc5MSAxMS43NjYgMTEuNzY2IDAgMDAxMS45ODMgMHpNMTAuNSAxNi41NDJhMS40NzYgMS40NzYgMCAwMTEuNDQ5LTEuNTNoLjAyN2ExLjUyNyAxLjUyNyAwIDAxMS41MjMgMS40NyAxLjQ3NSAxLjQ3NSAwIDAxLTEuNDQ5IDEuNTNoLS4wMjdhMS41MjkgMS41MjkgMCAwMS0xLjUyMy0xLjQ3ek0xMSAxMi41di02YTEgMSAwIDAxMiAwdjZhMSAxIDAgMTEtMiAwelwifSkpfSxzcGlubmVyOmZ1bmN0aW9uKCl7cmV0dXJuIHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJUb2FzdGlmeV9fc3Bpbm5lclwifSl9fTtmdW5jdGlvbiBDKHQpe2NvbnN0WyxvXT1yKHQ9PnQrMSwwKSxbbCxjXT1pKFtdKSxnPW4obnVsbCksaD1uKG5ldyBNYXApLmN1cnJlbnQsVD10PT4tMSE9PWwuaW5kZXhPZih0KSxDPW4oe3RvYXN0S2V5OjEsZGlzcGxheWVkVG9hc3Q6MCxjb3VudDowLHF1ZXVlOltdLHByb3BzOnQsY29udGFpbmVySWQ6bnVsbCxpc1RvYXN0QWN0aXZlOlQsZ2V0VG9hc3Q6dD0+aC5nZXQodCl9KS5jdXJyZW50O2Z1bmN0aW9uIGIodCl7bGV0e2NvbnRhaW5lcklkOmV9PXQ7Y29uc3R7bGltaXQ6bn09Qy5wcm9wczshbnx8ZSYmQy5jb250YWluZXJJZCE9PWV8fChDLmNvdW50LT1DLnF1ZXVlLmxlbmd0aCxDLnF1ZXVlPVtdKX1mdW5jdGlvbiBJKHQpe2MoZT0+bnVsbD09dD9bXTplLmZpbHRlcihlPT5lIT09dCkpfWZ1bmN0aW9uIF8oKXtjb25zdHt0b2FzdENvbnRlbnQ6dCx0b2FzdFByb3BzOmUsc3RhbGVJZDpufT1DLnF1ZXVlLnNoaWZ0KCk7Tyh0LGUsbil9ZnVuY3Rpb24gTCh0LG4pe2xldHtkZWxheTpzLHN0YWxlSWQ6ciwuLi5pfT1uO2lmKCFmKHQpfHxmdW5jdGlvbih0KXtyZXR1cm4hZy5jdXJyZW50fHxDLnByb3BzLmVuYWJsZU11bHRpQ29udGFpbmVyJiZ0LmNvbnRhaW5lcklkIT09Qy5wcm9wcy5jb250YWluZXJJZHx8aC5oYXModC50b2FzdElkKSYmbnVsbD09dC51cGRhdGVJZH0oaSkpcmV0dXJuO2NvbnN0e3RvYXN0SWQ6bCx1cGRhdGVJZDpjLGRhdGE6VH09aSx7cHJvcHM6Yn09QyxMPSgpPT5JKGwpLE49bnVsbD09YztOJiZDLmNvdW50Kys7Y29uc3QgTT17Li4uYixzdHlsZTpiLnRvYXN0U3R5bGUsa2V5OkMudG9hc3RLZXkrKywuLi5PYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoaSkuZmlsdGVyKHQ9PntsZXRbZSxuXT10O3JldHVybiBudWxsIT1ufSkpLHRvYXN0SWQ6bCx1cGRhdGVJZDpjLGRhdGE6VCxjbG9zZVRvYXN0OkwsaXNJbjohMSxjbGFzc05hbWU6bShpLmNsYXNzTmFtZXx8Yi50b2FzdENsYXNzTmFtZSksYm9keUNsYXNzTmFtZTptKGkuYm9keUNsYXNzTmFtZXx8Yi5ib2R5Q2xhc3NOYW1lKSxwcm9ncmVzc0NsYXNzTmFtZTptKGkucHJvZ3Jlc3NDbGFzc05hbWV8fGIucHJvZ3Jlc3NDbGFzc05hbWUpLGF1dG9DbG9zZTohaS5pc0xvYWRpbmcmJihSPWkuYXV0b0Nsb3NlLHc9Yi5hdXRvQ2xvc2UsITE9PT1SfHx1KFIpJiZSPjA/Ujp3KSxkZWxldGVUb2FzdCgpe2NvbnN0IHQ9eShoLmdldChsKSxcInJlbW92ZWRcIik7aC5kZWxldGUobCksdi5lbWl0KDQsdCk7Y29uc3QgZT1DLnF1ZXVlLmxlbmd0aDtpZihDLmNvdW50PW51bGw9PWw/Qy5jb3VudC1DLmRpc3BsYXllZFRvYXN0OkMuY291bnQtMSxDLmNvdW50PDAmJihDLmNvdW50PTApLGU+MCl7Y29uc3QgdD1udWxsPT1sP0MucHJvcHMubGltaXQ6MTtpZigxPT09ZXx8MT09PXQpQy5kaXNwbGF5ZWRUb2FzdCsrLF8oKTtlbHNle2NvbnN0IG49dD5lP2U6dDtDLmRpc3BsYXllZFRvYXN0PW47Zm9yKGxldCB0PTA7dDxuO3QrKylfKCl9fWVsc2UgbygpfX07dmFyIFIsdztNLmljb25PdXQ9ZnVuY3Rpb24odCl7bGV0e3RoZW1lOm4sdHlwZTpvLGlzTG9hZGluZzpzLGljb246cn09dCxpPW51bGw7Y29uc3QgbD17dGhlbWU6bix0eXBlOm99O3JldHVybiExPT09cnx8KHAocik/aT1yKGwpOmUocik/aT1hKHIsbCk6ZChyKXx8dShyKT9pPXI6cz9pPUUuc3Bpbm5lcigpOih0PT50IGluIEUpKG8pJiYoaT1FW29dKGwpKSksaX0oTSkscChpLm9uT3BlbikmJihNLm9uT3Blbj1pLm9uT3BlbikscChpLm9uQ2xvc2UpJiYoTS5vbkNsb3NlPWkub25DbG9zZSksTS5jbG9zZUJ1dHRvbj1iLmNsb3NlQnV0dG9uLCExPT09aS5jbG9zZUJ1dHRvbnx8ZihpLmNsb3NlQnV0dG9uKT9NLmNsb3NlQnV0dG9uPWkuY2xvc2VCdXR0b246ITA9PT1pLmNsb3NlQnV0dG9uJiYoTS5jbG9zZUJ1dHRvbj0hZihiLmNsb3NlQnV0dG9uKXx8Yi5jbG9zZUJ1dHRvbik7bGV0IHg9dDtlKHQpJiYhZCh0LnR5cGUpP3g9YSh0LHtjbG9zZVRvYXN0OkwsdG9hc3RQcm9wczpNLGRhdGE6VH0pOnAodCkmJih4PXQoe2Nsb3NlVG9hc3Q6TCx0b2FzdFByb3BzOk0sZGF0YTpUfSkpLGIubGltaXQmJmIubGltaXQ+MCYmQy5jb3VudD5iLmxpbWl0JiZOP0MucXVldWUucHVzaCh7dG9hc3RDb250ZW50OngsdG9hc3RQcm9wczpNLHN0YWxlSWQ6cn0pOnUocyk/c2V0VGltZW91dCgoKT0+e08oeCxNLHIpfSxzKTpPKHgsTSxyKX1mdW5jdGlvbiBPKHQsZSxuKXtjb25zdHt0b2FzdElkOm99PWU7biYmaC5kZWxldGUobik7Y29uc3Qgcz17Y29udGVudDp0LHByb3BzOmV9O2guc2V0KG8scyksYyh0PT5bLi4udCxvXS5maWx0ZXIodD0+dCE9PW4pKSx2LmVtaXQoNCx5KHMsbnVsbD09cy5wcm9wcy51cGRhdGVJZD9cImFkZGVkXCI6XCJ1cGRhdGVkXCIpKX1yZXR1cm4gcygoKT0+KEMuY29udGFpbmVySWQ9dC5jb250YWluZXJJZCx2LmNhbmNlbEVtaXQoMykub24oMCxMKS5vbigxLHQ9PmcuY3VycmVudCYmSSh0KSkub24oNSxiKS5lbWl0KDIsQyksKCk9PntoLmNsZWFyKCksdi5lbWl0KDMsQyl9KSxbXSkscygoKT0+e0MucHJvcHM9dCxDLmlzVG9hc3RBY3RpdmU9VCxDLmRpc3BsYXllZFRvYXN0PWwubGVuZ3RofSkse2dldFRvYXN0VG9SZW5kZXI6ZnVuY3Rpb24oZSl7Y29uc3Qgbj1uZXcgTWFwLG89QXJyYXkuZnJvbShoLnZhbHVlcygpKTtyZXR1cm4gdC5uZXdlc3RPblRvcCYmby5yZXZlcnNlKCksby5mb3JFYWNoKHQ9Pntjb25zdHtwb3NpdGlvbjplfT10LnByb3BzO24uaGFzKGUpfHxuLnNldChlLFtdKSxuLmdldChlKS5wdXNoKHQpfSksQXJyYXkuZnJvbShuLHQ9PmUodFswXSx0WzFdKSl9LGNvbnRhaW5lclJlZjpnLGlzVG9hc3RBY3RpdmU6VH19ZnVuY3Rpb24gYih0KXtyZXR1cm4gdC50YXJnZXRUb3VjaGVzJiZ0LnRhcmdldFRvdWNoZXMubGVuZ3RoPj0xP3QudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRYOnQuY2xpZW50WH1mdW5jdGlvbiBJKHQpe3JldHVybiB0LnRhcmdldFRvdWNoZXMmJnQudGFyZ2V0VG91Y2hlcy5sZW5ndGg+PTE/dC50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFk6dC5jbGllbnRZfWZ1bmN0aW9uIF8odCl7Y29uc3RbbyxhXT1pKCExKSxbcixsXT1pKCExKSxjPW4obnVsbCksdT1uKHtzdGFydDowLHg6MCx5OjAsZGVsdGE6MCxyZW1vdmFsRGlzdGFuY2U6MCxjYW5DbG9zZU9uQ2xpY2s6ITAsY2FuRHJhZzohMSxib3VuZGluZ1JlY3Q6bnVsbCxkaWRNb3ZlOiExfSkuY3VycmVudCxkPW4odCkse2F1dG9DbG9zZTptLHBhdXNlT25Ib3ZlcjpmLGNsb3NlVG9hc3Q6ZyxvbkNsaWNrOmgsY2xvc2VPbkNsaWNrOnl9PXQ7ZnVuY3Rpb24gdihlKXtpZih0LmRyYWdnYWJsZSl7XCJ0b3VjaHN0YXJ0XCI9PT1lLm5hdGl2ZUV2ZW50LnR5cGUmJmUubmF0aXZlRXZlbnQucHJldmVudERlZmF1bHQoKSx1LmRpZE1vdmU9ITEsZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLF8pLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsTCksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLF8pLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLEwpO2NvbnN0IG49Yy5jdXJyZW50O3UuY2FuQ2xvc2VPbkNsaWNrPSEwLHUuY2FuRHJhZz0hMCx1LmJvdW5kaW5nUmVjdD1uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG4uc3R5bGUudHJhbnNpdGlvbj1cIlwiLHUueD1iKGUubmF0aXZlRXZlbnQpLHUueT1JKGUubmF0aXZlRXZlbnQpLFwieFwiPT09dC5kcmFnZ2FibGVEaXJlY3Rpb24/KHUuc3RhcnQ9dS54LHUucmVtb3ZhbERpc3RhbmNlPW4ub2Zmc2V0V2lkdGgqKHQuZHJhZ2dhYmxlUGVyY2VudC8xMDApKToodS5zdGFydD11LnksdS5yZW1vdmFsRGlzdGFuY2U9bi5vZmZzZXRIZWlnaHQqKDgwPT09dC5kcmFnZ2FibGVQZXJjZW50PzEuNSp0LmRyYWdnYWJsZVBlcmNlbnQ6dC5kcmFnZ2FibGVQZXJjZW50LzEwMCkpfX1mdW5jdGlvbiBUKGUpe2lmKHUuYm91bmRpbmdSZWN0KXtjb25zdHt0b3A6bixib3R0b206byxsZWZ0OnMscmlnaHQ6YX09dS5ib3VuZGluZ1JlY3Q7XCJ0b3VjaGVuZFwiIT09ZS5uYXRpdmVFdmVudC50eXBlJiZ0LnBhdXNlT25Ib3ZlciYmdS54Pj1zJiZ1Lng8PWEmJnUueT49biYmdS55PD1vP0MoKTpFKCl9fWZ1bmN0aW9uIEUoKXthKCEwKX1mdW5jdGlvbiBDKCl7YSghMSl9ZnVuY3Rpb24gXyhlKXtjb25zdCBuPWMuY3VycmVudDt1LmNhbkRyYWcmJm4mJih1LmRpZE1vdmU9ITAsbyYmQygpLHUueD1iKGUpLHUueT1JKGUpLHUuZGVsdGE9XCJ4XCI9PT10LmRyYWdnYWJsZURpcmVjdGlvbj91LngtdS5zdGFydDp1LnktdS5zdGFydCx1LnN0YXJ0IT09dS54JiYodS5jYW5DbG9zZU9uQ2xpY2s9ITEpLG4uc3R5bGUudHJhbnNmb3JtPWB0cmFuc2xhdGUke3QuZHJhZ2dhYmxlRGlyZWN0aW9ufSgke3UuZGVsdGF9cHgpYCxuLnN0eWxlLm9wYWNpdHk9XCJcIisoMS1NYXRoLmFicyh1LmRlbHRhL3UucmVtb3ZhbERpc3RhbmNlKSkpfWZ1bmN0aW9uIEwoKXtkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsXyksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIixMKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsXyksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsTCk7Y29uc3QgZT1jLmN1cnJlbnQ7aWYodS5jYW5EcmFnJiZ1LmRpZE1vdmUmJmUpe2lmKHUuY2FuRHJhZz0hMSxNYXRoLmFicyh1LmRlbHRhKT51LnJlbW92YWxEaXN0YW5jZSlyZXR1cm4gbCghMCksdm9pZCB0LmNsb3NlVG9hc3QoKTtlLnN0eWxlLnRyYW5zaXRpb249XCJ0cmFuc2Zvcm0gMC4ycywgb3BhY2l0eSAwLjJzXCIsZS5zdHlsZS50cmFuc2Zvcm09YHRyYW5zbGF0ZSR7dC5kcmFnZ2FibGVEaXJlY3Rpb259KDApYCxlLnN0eWxlLm9wYWNpdHk9XCIxXCJ9fXMoKCk9PntkLmN1cnJlbnQ9dH0pLHMoKCk9PihjLmN1cnJlbnQmJmMuY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZFwiLEUse29uY2U6ITB9KSxwKHQub25PcGVuKSYmdC5vbk9wZW4oZSh0LmNoaWxkcmVuKSYmdC5jaGlsZHJlbi5wcm9wcyksKCk9Pntjb25zdCB0PWQuY3VycmVudDtwKHQub25DbG9zZSkmJnQub25DbG9zZShlKHQuY2hpbGRyZW4pJiZ0LmNoaWxkcmVuLnByb3BzKX0pLFtdKSxzKCgpPT4odC5wYXVzZU9uRm9jdXNMb3NzJiYoZG9jdW1lbnQuaGFzRm9jdXMoKXx8QygpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIixFKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIixDKSksKCk9Pnt0LnBhdXNlT25Gb2N1c0xvc3MmJih3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsRSksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsQykpfSksW3QucGF1c2VPbkZvY3VzTG9zc10pO2NvbnN0IE89e29uTW91c2VEb3duOnYsb25Ub3VjaFN0YXJ0OnYsb25Nb3VzZVVwOlQsb25Ub3VjaEVuZDpUfTtyZXR1cm4gbSYmZiYmKE8ub25Nb3VzZUVudGVyPUMsTy5vbk1vdXNlTGVhdmU9RSkseSYmKE8ub25DbGljaz10PT57aCYmaCh0KSx1LmNhbkNsb3NlT25DbGljayYmZygpfSkse3BsYXlUb2FzdDpFLHBhdXNlVG9hc3Q6Qyxpc1J1bm5pbmc6byxwcmV2ZW50RXhpdFRyYW5zaXRpb246cix0b2FzdFJlZjpjLGV2ZW50SGFuZGxlcnM6T319ZnVuY3Rpb24gTChlKXtsZXR7Y2xvc2VUb2FzdDpuLHRoZW1lOm8sYXJpYUxhYmVsOnM9XCJjbG9zZVwifT1lO3JldHVybiB0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIix7Y2xhc3NOYW1lOmBUb2FzdGlmeV9fY2xvc2UtYnV0dG9uIFRvYXN0aWZ5X19jbG9zZS1idXR0b24tLSR7b31gLHR5cGU6XCJidXR0b25cIixvbkNsaWNrOnQ9Pnt0LnN0b3BQcm9wYWdhdGlvbigpLG4odCl9LFwiYXJpYS1sYWJlbFwiOnN9LHQuY3JlYXRlRWxlbWVudChcInN2Z1wiLHtcImFyaWEtaGlkZGVuXCI6XCJ0cnVlXCIsdmlld0JveDpcIjAgMCAxNCAxNlwifSx0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIse2ZpbGxSdWxlOlwiZXZlbm9kZFwiLGQ6XCJNNy43MSA4LjIzbDMuNzUgMy43NS0xLjQ4IDEuNDgtMy43NS0zLjc1LTMuNzUgMy43NUwxIDExLjk4bDMuNzUtMy43NUwxIDQuNDggMi40OCAzbDMuNzUgMy43NUw5Ljk4IDNsMS40OCAxLjQ4LTMuNzUgMy43NXpcIn0pKSl9ZnVuY3Rpb24gTyhlKXtsZXR7ZGVsYXk6bixpc1J1bm5pbmc6byxjbG9zZVRvYXN0OnMsdHlwZTphPVwiZGVmYXVsdFwiLGhpZGU6cixjbGFzc05hbWU6aSxzdHlsZTpsLGNvbnRyb2xsZWRQcm9ncmVzczp1LHByb2dyZXNzOmQscnRsOm0saXNJbjpmLHRoZW1lOmd9PWU7Y29uc3QgaD1yfHx1JiYwPT09ZCx5PXsuLi5sLGFuaW1hdGlvbkR1cmF0aW9uOmAke259bXNgLGFuaW1hdGlvblBsYXlTdGF0ZTpvP1wicnVubmluZ1wiOlwicGF1c2VkXCIsb3BhY2l0eTpoPzA6MX07dSYmKHkudHJhbnNmb3JtPWBzY2FsZVgoJHtkfSlgKTtjb25zdCB2PWMoXCJUb2FzdGlmeV9fcHJvZ3Jlc3MtYmFyXCIsdT9cIlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLWNvbnRyb2xsZWRcIjpcIlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLWFuaW1hdGVkXCIsYFRvYXN0aWZ5X19wcm9ncmVzcy1iYXItdGhlbWUtLSR7Z31gLGBUb2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS0ke2F9YCx7XCJUb2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS1ydGxcIjptfSksVD1wKGkpP2koe3J0bDptLHR5cGU6YSxkZWZhdWx0Q2xhc3NOYW1lOnZ9KTpjKHYsaSk7cmV0dXJuIHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtyb2xlOlwicHJvZ3Jlc3NiYXJcIixcImFyaWEtaGlkZGVuXCI6aD9cInRydWVcIjpcImZhbHNlXCIsXCJhcmlhLWxhYmVsXCI6XCJub3RpZmljYXRpb24gdGltZXJcIixjbGFzc05hbWU6VCxzdHlsZTp5LFt1JiZkPj0xP1wib25UcmFuc2l0aW9uRW5kXCI6XCJvbkFuaW1hdGlvbkVuZFwiXTp1JiZkPDE/bnVsbDooKT0+e2YmJnMoKX19KX1jb25zdCBOPW49Pntjb25zdHtpc1J1bm5pbmc6byxwcmV2ZW50RXhpdFRyYW5zaXRpb246cyx0b2FzdFJlZjpyLGV2ZW50SGFuZGxlcnM6aX09XyhuKSx7Y2xvc2VCdXR0b246bCxjaGlsZHJlbjp1LGF1dG9DbG9zZTpkLG9uQ2xpY2s6bSx0eXBlOmYsaGlkZVByb2dyZXNzQmFyOmcsY2xvc2VUb2FzdDpoLHRyYW5zaXRpb246eSxwb3NpdGlvbjp2LGNsYXNzTmFtZTpULHN0eWxlOkUsYm9keUNsYXNzTmFtZTpDLGJvZHlTdHlsZTpiLHByb2dyZXNzQ2xhc3NOYW1lOkkscHJvZ3Jlc3NTdHlsZTpOLHVwZGF0ZUlkOk0scm9sZTpSLHByb2dyZXNzOncscnRsOngsdG9hc3RJZDokLGRlbGV0ZVRvYXN0OmssaXNJbjpQLGlzTG9hZGluZzpCLGljb25PdXQ6RCxjbG9zZU9uQ2xpY2s6QSx0aGVtZTp6fT1uLEY9YyhcIlRvYXN0aWZ5X190b2FzdFwiLGBUb2FzdGlmeV9fdG9hc3QtdGhlbWUtLSR7en1gLGBUb2FzdGlmeV9fdG9hc3QtLSR7Zn1gLHtcIlRvYXN0aWZ5X190b2FzdC0tcnRsXCI6eH0se1wiVG9hc3RpZnlfX3RvYXN0LS1jbG9zZS1vbi1jbGlja1wiOkF9KSxIPXAoVCk/VCh7cnRsOngscG9zaXRpb246dix0eXBlOmYsZGVmYXVsdENsYXNzTmFtZTpGfSk6YyhGLFQpLFM9ISF3fHwhZCxxPXtjbG9zZVRvYXN0OmgsdHlwZTpmLHRoZW1lOnp9O2xldCBRPW51bGw7cmV0dXJuITE9PT1sfHwoUT1wKGwpP2wocSk6ZShsKT9hKGwscSk6TChxKSksdC5jcmVhdGVFbGVtZW50KHkse2lzSW46UCxkb25lOmsscG9zaXRpb246dixwcmV2ZW50RXhpdFRyYW5zaXRpb246cyxub2RlUmVmOnJ9LHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtpZDokLG9uQ2xpY2s6bSxjbGFzc05hbWU6SCwuLi5pLHN0eWxlOkUscmVmOnJ9LHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHsuLi5QJiZ7cm9sZTpSfSxjbGFzc05hbWU6cChDKT9DKHt0eXBlOmZ9KTpjKFwiVG9hc3RpZnlfX3RvYXN0LWJvZHlcIixDKSxzdHlsZTpifSxudWxsIT1EJiZ0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOmMoXCJUb2FzdGlmeV9fdG9hc3QtaWNvblwiLHtcIlRvYXN0aWZ5LS1hbmltYXRlLWljb24gVG9hc3RpZnlfX3pvb20tZW50ZXJcIjohQn0pfSxEKSx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIixudWxsLHUpKSxRLHQuY3JlYXRlRWxlbWVudChPLHsuLi5NJiYhUz97a2V5OmBwYi0ke019YH06e30scnRsOngsdGhlbWU6eixkZWxheTpkLGlzUnVubmluZzpvLGlzSW46UCxjbG9zZVRvYXN0OmgsaGlkZTpnLHR5cGU6ZixzdHlsZTpOLGNsYXNzTmFtZTpJLGNvbnRyb2xsZWRQcm9ncmVzczpTLHByb2dyZXNzOnd8fDB9KSkpfSxNPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPSExKSx7ZW50ZXI6YFRvYXN0aWZ5LS1hbmltYXRlIFRvYXN0aWZ5X18ke3R9LWVudGVyYCxleGl0OmBUb2FzdGlmeS0tYW5pbWF0ZSBUb2FzdGlmeV9fJHt0fS1leGl0YCxhcHBlbmRQb3NpdGlvbjplfX0sUj1oKE0oXCJib3VuY2VcIiwhMCkpLHc9aChNKFwic2xpZGVcIiwhMCkpLHg9aChNKFwiem9vbVwiKSksJD1oKE0oXCJmbGlwXCIpKSxrPWwoKGUsbik9Pntjb25zdHtnZXRUb2FzdFRvUmVuZGVyOm8sY29udGFpbmVyUmVmOmEsaXNUb2FzdEFjdGl2ZTpyfT1DKGUpLHtjbGFzc05hbWU6aSxzdHlsZTpsLHJ0bDp1LGNvbnRhaW5lcklkOmR9PWU7ZnVuY3Rpb24gZih0KXtjb25zdCBlPWMoXCJUb2FzdGlmeV9fdG9hc3QtY29udGFpbmVyXCIsYFRvYXN0aWZ5X190b2FzdC1jb250YWluZXItLSR7dH1gLHtcIlRvYXN0aWZ5X190b2FzdC1jb250YWluZXItLXJ0bFwiOnV9KTtyZXR1cm4gcChpKT9pKHtwb3NpdGlvbjp0LHJ0bDp1LGRlZmF1bHRDbGFzc05hbWU6ZX0pOmMoZSxtKGkpKX1yZXR1cm4gcygoKT0+e24mJihuLmN1cnJlbnQ9YS5jdXJyZW50KX0sW10pLHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtyZWY6YSxjbGFzc05hbWU6XCJUb2FzdGlmeVwiLGlkOmR9LG8oKGUsbik9Pntjb25zdCBvPW4ubGVuZ3RoP3suLi5sfTp7Li4ubCxwb2ludGVyRXZlbnRzOlwibm9uZVwifTtyZXR1cm4gdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpmKGUpLHN0eWxlOm8sa2V5OmBjb250YWluZXItJHtlfWB9LG4ubWFwKChlLG8pPT57bGV0e2NvbnRlbnQ6cyxwcm9wczphfT1lO3JldHVybiB0LmNyZWF0ZUVsZW1lbnQoTix7Li4uYSxpc0luOnIoYS50b2FzdElkKSxzdHlsZTp7Li4uYS5zdHlsZSxcIi0tbnRoXCI6bysxLFwiLS1sZW5cIjpuLmxlbmd0aH0sa2V5OmB0b2FzdC0ke2Eua2V5fWB9LHMpfSkpfSkpfSk7ay5kaXNwbGF5TmFtZT1cIlRvYXN0Q29udGFpbmVyXCIsay5kZWZhdWx0UHJvcHM9e3Bvc2l0aW9uOlwidG9wLXJpZ2h0XCIsdHJhbnNpdGlvbjpSLGF1dG9DbG9zZTo1ZTMsY2xvc2VCdXR0b246TCxwYXVzZU9uSG92ZXI6ITAscGF1c2VPbkZvY3VzTG9zczohMCxjbG9zZU9uQ2xpY2s6ITAsZHJhZ2dhYmxlOiEwLGRyYWdnYWJsZVBlcmNlbnQ6ODAsZHJhZ2dhYmxlRGlyZWN0aW9uOlwieFwiLHJvbGU6XCJhbGVydFwiLHRoZW1lOlwibGlnaHRcIn07bGV0IFAsQj1uZXcgTWFwLEQ9W10sQT0xO2Z1bmN0aW9uIHooKXtyZXR1cm5cIlwiK0ErK31mdW5jdGlvbiBGKHQpe3JldHVybiB0JiYoZCh0LnRvYXN0SWQpfHx1KHQudG9hc3RJZCkpP3QudG9hc3RJZDp6KCl9ZnVuY3Rpb24gSCh0LGUpe3JldHVybiBCLnNpemU+MD92LmVtaXQoMCx0LGUpOkQucHVzaCh7Y29udGVudDp0LG9wdGlvbnM6ZX0pLGUudG9hc3RJZH1mdW5jdGlvbiBTKHQsZSl7cmV0dXJuey4uLmUsdHlwZTplJiZlLnR5cGV8fHQsdG9hc3RJZDpGKGUpfX1mdW5jdGlvbiBxKHQpe3JldHVybihlLG4pPT5IKGUsUyh0LG4pKX1mdW5jdGlvbiBRKHQsZSl7cmV0dXJuIEgodCxTKFwiZGVmYXVsdFwiLGUpKX1RLmxvYWRpbmc9KHQsZSk9PkgodCxTKFwiZGVmYXVsdFwiLHtpc0xvYWRpbmc6ITAsYXV0b0Nsb3NlOiExLGNsb3NlT25DbGljazohMSxjbG9zZUJ1dHRvbjohMSxkcmFnZ2FibGU6ITEsLi4uZX0pKSxRLnByb21pc2U9ZnVuY3Rpb24odCxlLG4pe2xldCBvLHtwZW5kaW5nOnMsZXJyb3I6YSxzdWNjZXNzOnJ9PWU7cyYmKG89ZChzKT9RLmxvYWRpbmcocyxuKTpRLmxvYWRpbmcocy5yZW5kZXIsey4uLm4sLi4uc30pKTtjb25zdCBpPXtpc0xvYWRpbmc6bnVsbCxhdXRvQ2xvc2U6bnVsbCxjbG9zZU9uQ2xpY2s6bnVsbCxjbG9zZUJ1dHRvbjpudWxsLGRyYWdnYWJsZTpudWxsfSxsPSh0LGUscyk9PntpZihudWxsPT1lKXJldHVybiB2b2lkIFEuZGlzbWlzcyhvKTtjb25zdCBhPXt0eXBlOnQsLi4uaSwuLi5uLGRhdGE6c30scj1kKGUpP3tyZW5kZXI6ZX06ZTtyZXR1cm4gbz9RLnVwZGF0ZShvLHsuLi5hLC4uLnJ9KTpRKHIucmVuZGVyLHsuLi5hLC4uLnJ9KSxzfSxjPXAodCk/dCgpOnQ7cmV0dXJuIGMudGhlbih0PT5sKFwic3VjY2Vzc1wiLHIsdCkpLmNhdGNoKHQ9PmwoXCJlcnJvclwiLGEsdCkpLGN9LFEuc3VjY2Vzcz1xKFwic3VjY2Vzc1wiKSxRLmluZm89cShcImluZm9cIiksUS5lcnJvcj1xKFwiZXJyb3JcIiksUS53YXJuaW5nPXEoXCJ3YXJuaW5nXCIpLFEud2Fybj1RLndhcm5pbmcsUS5kYXJrPSh0LGUpPT5IKHQsUyhcImRlZmF1bHRcIix7dGhlbWU6XCJkYXJrXCIsLi4uZX0pKSxRLmRpc21pc3M9dD0+e0Iuc2l6ZT4wP3YuZW1pdCgxLHQpOkQ9RC5maWx0ZXIoZT0+bnVsbCE9dCYmZS5vcHRpb25zLnRvYXN0SWQhPT10KX0sUS5jbGVhcldhaXRpbmdRdWV1ZT1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9e30pLHYuZW1pdCg1LHQpfSxRLmlzQWN0aXZlPXQ9PntsZXQgZT0hMTtyZXR1cm4gQi5mb3JFYWNoKG49PntuLmlzVG9hc3RBY3RpdmUmJm4uaXNUb2FzdEFjdGl2ZSh0KSYmKGU9ITApfSksZX0sUS51cGRhdGU9ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT17fSksc2V0VGltZW91dCgoKT0+e2NvbnN0IG49ZnVuY3Rpb24odCxlKXtsZXR7Y29udGFpbmVySWQ6bn09ZTtjb25zdCBvPUIuZ2V0KG58fFApO3JldHVybiBvJiZvLmdldFRvYXN0KHQpfSh0LGUpO2lmKG4pe2NvbnN0e3Byb3BzOm8sY29udGVudDpzfT1uLGE9e2RlbGF5OjEwMCwuLi5vLC4uLmUsdG9hc3RJZDplLnRvYXN0SWR8fHQsdXBkYXRlSWQ6eigpfTthLnRvYXN0SWQhPT10JiYoYS5zdGFsZUlkPXQpO2NvbnN0IHI9YS5yZW5kZXJ8fHM7ZGVsZXRlIGEucmVuZGVyLEgocixhKX19LDApfSxRLmRvbmU9dD0+e1EudXBkYXRlKHQse3Byb2dyZXNzOjF9KX0sUS5vbkNoYW5nZT10PT4odi5vbig0LHQpLCgpPT57di5vZmYoNCx0KX0pLFEuUE9TSVRJT049e1RPUF9MRUZUOlwidG9wLWxlZnRcIixUT1BfUklHSFQ6XCJ0b3AtcmlnaHRcIixUT1BfQ0VOVEVSOlwidG9wLWNlbnRlclwiLEJPVFRPTV9MRUZUOlwiYm90dG9tLWxlZnRcIixCT1RUT01fUklHSFQ6XCJib3R0b20tcmlnaHRcIixCT1RUT01fQ0VOVEVSOlwiYm90dG9tLWNlbnRlclwifSxRLlRZUEU9e0lORk86XCJpbmZvXCIsU1VDQ0VTUzpcInN1Y2Nlc3NcIixXQVJOSU5HOlwid2FybmluZ1wiLEVSUk9SOlwiZXJyb3JcIixERUZBVUxUOlwiZGVmYXVsdFwifSx2Lm9uKDIsdD0+e1A9dC5jb250YWluZXJJZHx8dCxCLnNldChQLHQpLEQuZm9yRWFjaCh0PT57di5lbWl0KDAsdC5jb250ZW50LHQub3B0aW9ucyl9KSxEPVtdfSkub24oMyx0PT57Qi5kZWxldGUodC5jb250YWluZXJJZHx8dCksMD09PUIuc2l6ZSYmdi5vZmYoMCkub2ZmKDEpLm9mZig1KX0pO2V4cG9ydHtSIGFzIEJvdW5jZSwkIGFzIEZsaXAsRSBhcyBJY29ucyx3IGFzIFNsaWRlLGsgYXMgVG9hc3RDb250YWluZXIseCBhcyBab29tLGcgYXMgY29sbGFwc2VUb2FzdCxoIGFzIGNzc1RyYW5zaXRpb24sUSBhcyB0b2FzdCxfIGFzIHVzZVRvYXN0LEMgYXMgdXNlVG9hc3RDb250YWluZXJ9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC10b2FzdGlmeS5lc20ubWpzLm1hcFxyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/react-toastify/dist/react-toastify.esm.mjs\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/react-toastify/node_modules/clsx/dist/clsx.m.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-toastify/node_modules/clsx/dist/clsx.m.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clsx: () => (/* binding */ clsx),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f);else for(t in e)e[t]&&(n&&(n+=\" \"),n+=t);return n}function clsx(){for(var e,t,f=0,n=\"\";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clsx);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC10b2FzdGlmeS9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLGNBQWMsYUFBYSwrQ0FBK0MsdURBQXVELFdBQVcsMENBQTBDLHlDQUF5QyxTQUFnQixnQkFBZ0IscUJBQXFCLG1CQUFtQixrREFBa0QsU0FBUyxpRUFBZSxJQUFJIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWFjdC10b2FzdGlmeVxcbm9kZV9tb2R1bGVzXFxjbHN4XFxkaXN0XFxjbHN4Lm0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gcihlKXt2YXIgdCxmLG49XCJcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGUpbis9ZTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpZm9yKHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdJiYoZj1yKGVbdF0pKSYmKG4mJihuKz1cIiBcIiksbis9Zik7ZWxzZSBmb3IodCBpbiBlKWVbdF0mJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBmdW5jdGlvbiBjbHN4KCl7Zm9yKHZhciBlLHQsZj0wLG49XCJcIjtmPGFyZ3VtZW50cy5sZW5ndGg7KShlPWFyZ3VtZW50c1tmKytdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/react-toastify/node_modules/clsx/dist/clsx.m.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\r\n * @license React\r\n * react-jsx-dev-runtime.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n\r\n\r\nif (true) {\r\n  (function() {\r\n'use strict';\r\n\r\nvar React = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\r\n\r\n// ATTENTION\r\n// When adding new symbols to this file,\r\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\r\n// The Symbol used to tag the ReactElement-like types.\r\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\r\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\r\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\r\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\r\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\r\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\r\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\r\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\r\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\r\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\r\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\r\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\r\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\r\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\r\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\r\nfunction getIteratorFn(maybeIterable) {\r\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\r\n    return null;\r\n  }\r\n\r\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\r\n\r\n  if (typeof maybeIterator === 'function') {\r\n    return maybeIterator;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\r\n\r\nfunction error(format) {\r\n  {\r\n    {\r\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\r\n        args[_key2 - 1] = arguments[_key2];\r\n      }\r\n\r\n      printWarning('error', format, args);\r\n    }\r\n  }\r\n}\r\n\r\nfunction printWarning(level, format, args) {\r\n  // When changing this logic, you might want to also\r\n  // update consoleWithStackDev.www.js as well.\r\n  {\r\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\r\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\r\n\r\n    if (stack !== '') {\r\n      format += '%s';\r\n      args = args.concat([stack]);\r\n    } // eslint-disable-next-line react-internal/safe-string-coercion\r\n\r\n\r\n    var argsWithFormat = args.map(function (item) {\r\n      return String(item);\r\n    }); // Careful: RN currently depends on this prefix\r\n\r\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\r\n    // breaks IE9: https://github.com/facebook/react/issues/13610\r\n    // eslint-disable-next-line react-internal/no-production-logging\r\n\r\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\r\n  }\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n\r\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\r\nvar enableCacheElement = false;\r\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\r\n\r\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\r\n// stuff. Intended to enable React core members to more easily debug scheduling\r\n// issues in DEV builds.\r\n\r\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\r\n\r\nvar REACT_MODULE_REFERENCE;\r\n\r\n{\r\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\r\n}\r\n\r\nfunction isValidElementType(type) {\r\n  if (typeof type === 'string' || typeof type === 'function') {\r\n    return true;\r\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\r\n\r\n\r\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\r\n    return true;\r\n  }\r\n\r\n  if (typeof type === 'object' && type !== null) {\r\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\r\n    // types supported by any Flight configuration anywhere since\r\n    // we don't know which Flight build this will end up being used\r\n    // with.\r\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction getWrappedName(outerType, innerType, wrapperName) {\r\n  var displayName = outerType.displayName;\r\n\r\n  if (displayName) {\r\n    return displayName;\r\n  }\r\n\r\n  var functionName = innerType.displayName || innerType.name || '';\r\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\r\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\r\n\r\n\r\nfunction getContextName(type) {\r\n  return type.displayName || 'Context';\r\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\r\n\r\n\r\nfunction getComponentNameFromType(type) {\r\n  if (type == null) {\r\n    // Host root, text node or just invalid type.\r\n    return null;\r\n  }\r\n\r\n  {\r\n    if (typeof type.tag === 'number') {\r\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\r\n    }\r\n  }\r\n\r\n  if (typeof type === 'function') {\r\n    return type.displayName || type.name || null;\r\n  }\r\n\r\n  if (typeof type === 'string') {\r\n    return type;\r\n  }\r\n\r\n  switch (type) {\r\n    case REACT_FRAGMENT_TYPE:\r\n      return 'Fragment';\r\n\r\n    case REACT_PORTAL_TYPE:\r\n      return 'Portal';\r\n\r\n    case REACT_PROFILER_TYPE:\r\n      return 'Profiler';\r\n\r\n    case REACT_STRICT_MODE_TYPE:\r\n      return 'StrictMode';\r\n\r\n    case REACT_SUSPENSE_TYPE:\r\n      return 'Suspense';\r\n\r\n    case REACT_SUSPENSE_LIST_TYPE:\r\n      return 'SuspenseList';\r\n\r\n  }\r\n\r\n  if (typeof type === 'object') {\r\n    switch (type.$$typeof) {\r\n      case REACT_CONTEXT_TYPE:\r\n        var context = type;\r\n        return getContextName(context) + '.Consumer';\r\n\r\n      case REACT_PROVIDER_TYPE:\r\n        var provider = type;\r\n        return getContextName(provider._context) + '.Provider';\r\n\r\n      case REACT_FORWARD_REF_TYPE:\r\n        return getWrappedName(type, type.render, 'ForwardRef');\r\n\r\n      case REACT_MEMO_TYPE:\r\n        var outerName = type.displayName || null;\r\n\r\n        if (outerName !== null) {\r\n          return outerName;\r\n        }\r\n\r\n        return getComponentNameFromType(type.type) || 'Memo';\r\n\r\n      case REACT_LAZY_TYPE:\r\n        {\r\n          var lazyComponent = type;\r\n          var payload = lazyComponent._payload;\r\n          var init = lazyComponent._init;\r\n\r\n          try {\r\n            return getComponentNameFromType(init(payload));\r\n          } catch (x) {\r\n            return null;\r\n          }\r\n        }\r\n\r\n      // eslint-disable-next-line no-fallthrough\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nvar assign = Object.assign;\r\n\r\n// Helpers to patch console.logs to avoid logging during side-effect free\r\n// replaying on render function. This currently only patches the object\r\n// lazily which won't cover if the log function was extracted eagerly.\r\n// We could also eagerly patch the method.\r\nvar disabledDepth = 0;\r\nvar prevLog;\r\nvar prevInfo;\r\nvar prevWarn;\r\nvar prevError;\r\nvar prevGroup;\r\nvar prevGroupCollapsed;\r\nvar prevGroupEnd;\r\n\r\nfunction disabledLog() {}\r\n\r\ndisabledLog.__reactDisabledLog = true;\r\nfunction disableLogs() {\r\n  {\r\n    if (disabledDepth === 0) {\r\n      /* eslint-disable react-internal/no-production-logging */\r\n      prevLog = console.log;\r\n      prevInfo = console.info;\r\n      prevWarn = console.warn;\r\n      prevError = console.error;\r\n      prevGroup = console.group;\r\n      prevGroupCollapsed = console.groupCollapsed;\r\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\r\n\r\n      var props = {\r\n        configurable: true,\r\n        enumerable: true,\r\n        value: disabledLog,\r\n        writable: true\r\n      }; // $FlowFixMe Flow thinks console is immutable.\r\n\r\n      Object.defineProperties(console, {\r\n        info: props,\r\n        log: props,\r\n        warn: props,\r\n        error: props,\r\n        group: props,\r\n        groupCollapsed: props,\r\n        groupEnd: props\r\n      });\r\n      /* eslint-enable react-internal/no-production-logging */\r\n    }\r\n\r\n    disabledDepth++;\r\n  }\r\n}\r\nfunction reenableLogs() {\r\n  {\r\n    disabledDepth--;\r\n\r\n    if (disabledDepth === 0) {\r\n      /* eslint-disable react-internal/no-production-logging */\r\n      var props = {\r\n        configurable: true,\r\n        enumerable: true,\r\n        writable: true\r\n      }; // $FlowFixMe Flow thinks console is immutable.\r\n\r\n      Object.defineProperties(console, {\r\n        log: assign({}, props, {\r\n          value: prevLog\r\n        }),\r\n        info: assign({}, props, {\r\n          value: prevInfo\r\n        }),\r\n        warn: assign({}, props, {\r\n          value: prevWarn\r\n        }),\r\n        error: assign({}, props, {\r\n          value: prevError\r\n        }),\r\n        group: assign({}, props, {\r\n          value: prevGroup\r\n        }),\r\n        groupCollapsed: assign({}, props, {\r\n          value: prevGroupCollapsed\r\n        }),\r\n        groupEnd: assign({}, props, {\r\n          value: prevGroupEnd\r\n        })\r\n      });\r\n      /* eslint-enable react-internal/no-production-logging */\r\n    }\r\n\r\n    if (disabledDepth < 0) {\r\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\r\n    }\r\n  }\r\n}\r\n\r\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\r\nvar prefix;\r\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\r\n  {\r\n    if (prefix === undefined) {\r\n      // Extract the VM specific prefix used by each line.\r\n      try {\r\n        throw Error();\r\n      } catch (x) {\r\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\r\n        prefix = match && match[1] || '';\r\n      }\r\n    } // We use the prefix to ensure our stacks line up with native stack frames.\r\n\r\n\r\n    return '\\n' + prefix + name;\r\n  }\r\n}\r\nvar reentry = false;\r\nvar componentFrameCache;\r\n\r\n{\r\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\r\n  componentFrameCache = new PossiblyWeakMap();\r\n}\r\n\r\nfunction describeNativeComponentFrame(fn, construct) {\r\n  // If something asked for a stack inside a fake render, it should get ignored.\r\n  if ( !fn || reentry) {\r\n    return '';\r\n  }\r\n\r\n  {\r\n    var frame = componentFrameCache.get(fn);\r\n\r\n    if (frame !== undefined) {\r\n      return frame;\r\n    }\r\n  }\r\n\r\n  var control;\r\n  reentry = true;\r\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\r\n\r\n  Error.prepareStackTrace = undefined;\r\n  var previousDispatcher;\r\n\r\n  {\r\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\r\n    // for warnings.\r\n\r\n    ReactCurrentDispatcher.current = null;\r\n    disableLogs();\r\n  }\r\n\r\n  try {\r\n    // This should throw.\r\n    if (construct) {\r\n      // Something should be setting the props in the constructor.\r\n      var Fake = function () {\r\n        throw Error();\r\n      }; // $FlowFixMe\r\n\r\n\r\n      Object.defineProperty(Fake.prototype, 'props', {\r\n        set: function () {\r\n          // We use a throwing setter instead of frozen or non-writable props\r\n          // because that won't throw in a non-strict mode function.\r\n          throw Error();\r\n        }\r\n      });\r\n\r\n      if (typeof Reflect === 'object' && Reflect.construct) {\r\n        // We construct a different control for this case to include any extra\r\n        // frames added by the construct call.\r\n        try {\r\n          Reflect.construct(Fake, []);\r\n        } catch (x) {\r\n          control = x;\r\n        }\r\n\r\n        Reflect.construct(fn, [], Fake);\r\n      } else {\r\n        try {\r\n          Fake.call();\r\n        } catch (x) {\r\n          control = x;\r\n        }\r\n\r\n        fn.call(Fake.prototype);\r\n      }\r\n    } else {\r\n      try {\r\n        throw Error();\r\n      } catch (x) {\r\n        control = x;\r\n      }\r\n\r\n      fn();\r\n    }\r\n  } catch (sample) {\r\n    // This is inlined manually because closure doesn't do it for us.\r\n    if (sample && control && typeof sample.stack === 'string') {\r\n      // This extracts the first frame from the sample that isn't also in the control.\r\n      // Skipping one frame that we assume is the frame that calls the two.\r\n      var sampleLines = sample.stack.split('\\n');\r\n      var controlLines = control.stack.split('\\n');\r\n      var s = sampleLines.length - 1;\r\n      var c = controlLines.length - 1;\r\n\r\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\r\n        // We expect at least one stack frame to be shared.\r\n        // Typically this will be the root most one. However, stack frames may be\r\n        // cut off due to maximum stack limits. In this case, one maybe cut off\r\n        // earlier than the other. We assume that the sample is longer or the same\r\n        // and there for cut off earlier. So we should find the root most frame in\r\n        // the sample somewhere in the control.\r\n        c--;\r\n      }\r\n\r\n      for (; s >= 1 && c >= 0; s--, c--) {\r\n        // Next we find the first one that isn't the same which should be the\r\n        // frame that called our sample function and the control.\r\n        if (sampleLines[s] !== controlLines[c]) {\r\n          // In V8, the first line is describing the message but other VMs don't.\r\n          // If we're about to return the first line, and the control is also on the same\r\n          // line, that's a pretty good indicator that our sample threw at same line as\r\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\r\n          // This can happen if you passed a class to function component, or non-function.\r\n          if (s !== 1 || c !== 1) {\r\n            do {\r\n              s--;\r\n              c--; // We may still have similar intermediate frames from the construct call.\r\n              // The next one that isn't the same should be our match though.\r\n\r\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\r\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\r\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\r\n                // but we have a user-provided \"displayName\"\r\n                // splice it in to make the stack more readable.\r\n\r\n\r\n                if (fn.displayName && _frame.includes('<anonymous>')) {\r\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\r\n                }\r\n\r\n                {\r\n                  if (typeof fn === 'function') {\r\n                    componentFrameCache.set(fn, _frame);\r\n                  }\r\n                } // Return the line we found.\r\n\r\n\r\n                return _frame;\r\n              }\r\n            } while (s >= 1 && c >= 0);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  } finally {\r\n    reentry = false;\r\n\r\n    {\r\n      ReactCurrentDispatcher.current = previousDispatcher;\r\n      reenableLogs();\r\n    }\r\n\r\n    Error.prepareStackTrace = previousPrepareStackTrace;\r\n  } // Fallback to just using the name if we couldn't make it throw.\r\n\r\n\r\n  var name = fn ? fn.displayName || fn.name : '';\r\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\r\n\r\n  {\r\n    if (typeof fn === 'function') {\r\n      componentFrameCache.set(fn, syntheticFrame);\r\n    }\r\n  }\r\n\r\n  return syntheticFrame;\r\n}\r\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\r\n  {\r\n    return describeNativeComponentFrame(fn, false);\r\n  }\r\n}\r\n\r\nfunction shouldConstruct(Component) {\r\n  var prototype = Component.prototype;\r\n  return !!(prototype && prototype.isReactComponent);\r\n}\r\n\r\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\r\n\r\n  if (type == null) {\r\n    return '';\r\n  }\r\n\r\n  if (typeof type === 'function') {\r\n    {\r\n      return describeNativeComponentFrame(type, shouldConstruct(type));\r\n    }\r\n  }\r\n\r\n  if (typeof type === 'string') {\r\n    return describeBuiltInComponentFrame(type);\r\n  }\r\n\r\n  switch (type) {\r\n    case REACT_SUSPENSE_TYPE:\r\n      return describeBuiltInComponentFrame('Suspense');\r\n\r\n    case REACT_SUSPENSE_LIST_TYPE:\r\n      return describeBuiltInComponentFrame('SuspenseList');\r\n  }\r\n\r\n  if (typeof type === 'object') {\r\n    switch (type.$$typeof) {\r\n      case REACT_FORWARD_REF_TYPE:\r\n        return describeFunctionComponentFrame(type.render);\r\n\r\n      case REACT_MEMO_TYPE:\r\n        // Memo may contain any component type so we recursively resolve it.\r\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\r\n\r\n      case REACT_LAZY_TYPE:\r\n        {\r\n          var lazyComponent = type;\r\n          var payload = lazyComponent._payload;\r\n          var init = lazyComponent._init;\r\n\r\n          try {\r\n            // Lazy may contain any component type so we recursively resolve it.\r\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\r\n          } catch (x) {}\r\n        }\r\n    }\r\n  }\r\n\r\n  return '';\r\n}\r\n\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\nvar loggedTypeFailures = {};\r\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\r\n\r\nfunction setCurrentlyValidatingElement(element) {\r\n  {\r\n    if (element) {\r\n      var owner = element._owner;\r\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\r\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\r\n    } else {\r\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\r\n    }\r\n  }\r\n}\r\n\r\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\r\n  {\r\n    // $FlowFixMe This is okay but Flow doesn't know it.\r\n    var has = Function.call.bind(hasOwnProperty);\r\n\r\n    for (var typeSpecName in typeSpecs) {\r\n      if (has(typeSpecs, typeSpecName)) {\r\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\r\n        // fail the render phase where it didn't fail before. So we log it.\r\n        // After these have been cleaned up, we'll let them throw.\r\n\r\n        try {\r\n          // This is intentionally an invariant that gets caught. It's the same\r\n          // behavior as without this statement except with a better message.\r\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\r\n            // eslint-disable-next-line react-internal/prod-error-codes\r\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\r\n            err.name = 'Invariant Violation';\r\n            throw err;\r\n          }\r\n\r\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\r\n        } catch (ex) {\r\n          error$1 = ex;\r\n        }\r\n\r\n        if (error$1 && !(error$1 instanceof Error)) {\r\n          setCurrentlyValidatingElement(element);\r\n\r\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\r\n\r\n          setCurrentlyValidatingElement(null);\r\n        }\r\n\r\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\r\n          // Only monitor this failure once because there tends to be a lot of the\r\n          // same error.\r\n          loggedTypeFailures[error$1.message] = true;\r\n          setCurrentlyValidatingElement(element);\r\n\r\n          error('Failed %s type: %s', location, error$1.message);\r\n\r\n          setCurrentlyValidatingElement(null);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\r\n\r\nfunction isArray(a) {\r\n  return isArrayImpl(a);\r\n}\r\n\r\n/*\r\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\r\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\r\n *\r\n * The functions in this module will throw an easier-to-understand,\r\n * easier-to-debug exception with a clear errors message message explaining the\r\n * problem. (Instead of a confusing exception thrown inside the implementation\r\n * of the `value` object).\r\n */\r\n// $FlowFixMe only called in DEV, so void return is not possible.\r\nfunction typeName(value) {\r\n  {\r\n    // toStringTag is needed for namespaced types like Temporal.Instant\r\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\r\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\r\n    return type;\r\n  }\r\n} // $FlowFixMe only called in DEV, so void return is not possible.\r\n\r\n\r\nfunction willCoercionThrow(value) {\r\n  {\r\n    try {\r\n      testStringCoercion(value);\r\n      return false;\r\n    } catch (e) {\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction testStringCoercion(value) {\r\n  // If you ended up here by following an exception call stack, here's what's\r\n  // happened: you supplied an object or symbol value to React (as a prop, key,\r\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\r\n  // coerce it to a string using `'' + value`, an exception was thrown.\r\n  //\r\n  // The most common types that will cause this exception are `Symbol` instances\r\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\r\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\r\n  // exception. (Library authors do this to prevent users from using built-in\r\n  // numeric operators like `+` or comparison operators like `>=` because custom\r\n  // methods are needed to perform accurate arithmetic or comparison.)\r\n  //\r\n  // To fix the problem, coerce this object or symbol value to a string before\r\n  // passing it to React. The most reliable way is usually `String(value)`.\r\n  //\r\n  // To find which value is throwing, check the browser or debugger console.\r\n  // Before this exception was thrown, there should be `console.error` output\r\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\r\n  // problem and how that type was used: key, atrribute, input value prop, etc.\r\n  // In most cases, this console output also shows the component and its\r\n  // ancestor components where the exception happened.\r\n  //\r\n  // eslint-disable-next-line react-internal/safe-string-coercion\r\n  return '' + value;\r\n}\r\nfunction checkKeyStringCoercion(value) {\r\n  {\r\n    if (willCoercionThrow(value)) {\r\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\r\n\r\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\r\n    }\r\n  }\r\n}\r\n\r\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\r\nvar RESERVED_PROPS = {\r\n  key: true,\r\n  ref: true,\r\n  __self: true,\r\n  __source: true\r\n};\r\nvar specialPropKeyWarningShown;\r\nvar specialPropRefWarningShown;\r\nvar didWarnAboutStringRefs;\r\n\r\n{\r\n  didWarnAboutStringRefs = {};\r\n}\r\n\r\nfunction hasValidRef(config) {\r\n  {\r\n    if (hasOwnProperty.call(config, 'ref')) {\r\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\r\n\r\n      if (getter && getter.isReactWarning) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return config.ref !== undefined;\r\n}\r\n\r\nfunction hasValidKey(config) {\r\n  {\r\n    if (hasOwnProperty.call(config, 'key')) {\r\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\r\n\r\n      if (getter && getter.isReactWarning) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return config.key !== undefined;\r\n}\r\n\r\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\r\n  {\r\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\r\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\r\n\r\n      if (!didWarnAboutStringRefs[componentName]) {\r\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\r\n\r\n        didWarnAboutStringRefs[componentName] = true;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction defineKeyPropWarningGetter(props, displayName) {\r\n  {\r\n    var warnAboutAccessingKey = function () {\r\n      if (!specialPropKeyWarningShown) {\r\n        specialPropKeyWarningShown = true;\r\n\r\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\r\n      }\r\n    };\r\n\r\n    warnAboutAccessingKey.isReactWarning = true;\r\n    Object.defineProperty(props, 'key', {\r\n      get: warnAboutAccessingKey,\r\n      configurable: true\r\n    });\r\n  }\r\n}\r\n\r\nfunction defineRefPropWarningGetter(props, displayName) {\r\n  {\r\n    var warnAboutAccessingRef = function () {\r\n      if (!specialPropRefWarningShown) {\r\n        specialPropRefWarningShown = true;\r\n\r\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\r\n      }\r\n    };\r\n\r\n    warnAboutAccessingRef.isReactWarning = true;\r\n    Object.defineProperty(props, 'ref', {\r\n      get: warnAboutAccessingRef,\r\n      configurable: true\r\n    });\r\n  }\r\n}\r\n/**\r\n * Factory method to create a new React element. This no longer adheres to\r\n * the class pattern, so do not use new to call it. Also, instanceof check\r\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\r\n * if something is a React Element.\r\n *\r\n * @param {*} type\r\n * @param {*} props\r\n * @param {*} key\r\n * @param {string|object} ref\r\n * @param {*} owner\r\n * @param {*} self A *temporary* helper to detect places where `this` is\r\n * different from the `owner` when React.createElement is called, so that we\r\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\r\n * functions, and as long as `this` and owner are the same, there will be no\r\n * change in behavior.\r\n * @param {*} source An annotation object (added by a transpiler or otherwise)\r\n * indicating filename, line number, and/or other information.\r\n * @internal\r\n */\r\n\r\n\r\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\r\n  var element = {\r\n    // This tag allows us to uniquely identify this as a React Element\r\n    $$typeof: REACT_ELEMENT_TYPE,\r\n    // Built-in properties that belong on the element\r\n    type: type,\r\n    key: key,\r\n    ref: ref,\r\n    props: props,\r\n    // Record the component responsible for creating this element.\r\n    _owner: owner\r\n  };\r\n\r\n  {\r\n    // The validation flag is currently mutative. We put it on\r\n    // an external backing store so that we can freeze the whole object.\r\n    // This can be replaced with a WeakMap once they are implemented in\r\n    // commonly used development environments.\r\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\r\n    // the validation flag non-enumerable (where possible, which should\r\n    // include every environment we run tests in), so the test framework\r\n    // ignores it.\r\n\r\n    Object.defineProperty(element._store, 'validated', {\r\n      configurable: false,\r\n      enumerable: false,\r\n      writable: true,\r\n      value: false\r\n    }); // self and source are DEV only properties.\r\n\r\n    Object.defineProperty(element, '_self', {\r\n      configurable: false,\r\n      enumerable: false,\r\n      writable: false,\r\n      value: self\r\n    }); // Two elements created in two different places should be considered\r\n    // equal for testing purposes and therefore we hide it from enumeration.\r\n\r\n    Object.defineProperty(element, '_source', {\r\n      configurable: false,\r\n      enumerable: false,\r\n      writable: false,\r\n      value: source\r\n    });\r\n\r\n    if (Object.freeze) {\r\n      Object.freeze(element.props);\r\n      Object.freeze(element);\r\n    }\r\n  }\r\n\r\n  return element;\r\n};\r\n/**\r\n * https://github.com/reactjs/rfcs/pull/107\r\n * @param {*} type\r\n * @param {object} props\r\n * @param {string} key\r\n */\r\n\r\nfunction jsxDEV(type, config, maybeKey, source, self) {\r\n  {\r\n    var propName; // Reserved names are extracted\r\n\r\n    var props = {};\r\n    var key = null;\r\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\r\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\r\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\r\n    // but as an intermediary step, we will use jsxDEV for everything except\r\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\r\n    // key is explicitly declared to be undefined or not.\r\n\r\n    if (maybeKey !== undefined) {\r\n      {\r\n        checkKeyStringCoercion(maybeKey);\r\n      }\r\n\r\n      key = '' + maybeKey;\r\n    }\r\n\r\n    if (hasValidKey(config)) {\r\n      {\r\n        checkKeyStringCoercion(config.key);\r\n      }\r\n\r\n      key = '' + config.key;\r\n    }\r\n\r\n    if (hasValidRef(config)) {\r\n      ref = config.ref;\r\n      warnIfStringRefCannotBeAutoConverted(config, self);\r\n    } // Remaining properties are added to a new props object\r\n\r\n\r\n    for (propName in config) {\r\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\r\n        props[propName] = config[propName];\r\n      }\r\n    } // Resolve default props\r\n\r\n\r\n    if (type && type.defaultProps) {\r\n      var defaultProps = type.defaultProps;\r\n\r\n      for (propName in defaultProps) {\r\n        if (props[propName] === undefined) {\r\n          props[propName] = defaultProps[propName];\r\n        }\r\n      }\r\n    }\r\n\r\n    if (key || ref) {\r\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\r\n\r\n      if (key) {\r\n        defineKeyPropWarningGetter(props, displayName);\r\n      }\r\n\r\n      if (ref) {\r\n        defineRefPropWarningGetter(props, displayName);\r\n      }\r\n    }\r\n\r\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\r\n  }\r\n}\r\n\r\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\r\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\r\n\r\nfunction setCurrentlyValidatingElement$1(element) {\r\n  {\r\n    if (element) {\r\n      var owner = element._owner;\r\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\r\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\r\n    } else {\r\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\r\n    }\r\n  }\r\n}\r\n\r\nvar propTypesMisspellWarningShown;\r\n\r\n{\r\n  propTypesMisspellWarningShown = false;\r\n}\r\n/**\r\n * Verifies the object is a ReactElement.\r\n * See https://reactjs.org/docs/react-api.html#isvalidelement\r\n * @param {?object} object\r\n * @return {boolean} True if `object` is a ReactElement.\r\n * @final\r\n */\r\n\r\n\r\nfunction isValidElement(object) {\r\n  {\r\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\r\n  }\r\n}\r\n\r\nfunction getDeclarationErrorAddendum() {\r\n  {\r\n    if (ReactCurrentOwner$1.current) {\r\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\r\n\r\n      if (name) {\r\n        return '\\n\\nCheck the render method of `' + name + '`.';\r\n      }\r\n    }\r\n\r\n    return '';\r\n  }\r\n}\r\n\r\nfunction getSourceInfoErrorAddendum(source) {\r\n  {\r\n    if (source !== undefined) {\r\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\r\n      var lineNumber = source.lineNumber;\r\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\r\n    }\r\n\r\n    return '';\r\n  }\r\n}\r\n/**\r\n * Warn if there's no key explicitly set on dynamic arrays of children or\r\n * object keys are not valid. This allows us to keep track of children between\r\n * updates.\r\n */\r\n\r\n\r\nvar ownerHasKeyUseWarning = {};\r\n\r\nfunction getCurrentComponentErrorInfo(parentType) {\r\n  {\r\n    var info = getDeclarationErrorAddendum();\r\n\r\n    if (!info) {\r\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\r\n\r\n      if (parentName) {\r\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\r\n      }\r\n    }\r\n\r\n    return info;\r\n  }\r\n}\r\n/**\r\n * Warn if the element doesn't have an explicit key assigned to it.\r\n * This element is in an array. The array could grow and shrink or be\r\n * reordered. All children that haven't already been validated are required to\r\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\r\n * will only be shown once.\r\n *\r\n * @internal\r\n * @param {ReactElement} element Element that requires a key.\r\n * @param {*} parentType element's parent's type.\r\n */\r\n\r\n\r\nfunction validateExplicitKey(element, parentType) {\r\n  {\r\n    if (!element._store || element._store.validated || element.key != null) {\r\n      return;\r\n    }\r\n\r\n    element._store.validated = true;\r\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\r\n\r\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\r\n      return;\r\n    }\r\n\r\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\r\n    // property, it may be the creator of the child that's responsible for\r\n    // assigning it a key.\r\n\r\n    var childOwner = '';\r\n\r\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\r\n      // Give the component that originally created this child.\r\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\r\n    }\r\n\r\n    setCurrentlyValidatingElement$1(element);\r\n\r\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\r\n\r\n    setCurrentlyValidatingElement$1(null);\r\n  }\r\n}\r\n/**\r\n * Ensure that every element either is passed in a static location, in an\r\n * array with an explicit keys property defined, or in an object literal\r\n * with valid key property.\r\n *\r\n * @internal\r\n * @param {ReactNode} node Statically passed child of any type.\r\n * @param {*} parentType node's parent's type.\r\n */\r\n\r\n\r\nfunction validateChildKeys(node, parentType) {\r\n  {\r\n    if (typeof node !== 'object') {\r\n      return;\r\n    }\r\n\r\n    if (isArray(node)) {\r\n      for (var i = 0; i < node.length; i++) {\r\n        var child = node[i];\r\n\r\n        if (isValidElement(child)) {\r\n          validateExplicitKey(child, parentType);\r\n        }\r\n      }\r\n    } else if (isValidElement(node)) {\r\n      // This element was passed in a valid location.\r\n      if (node._store) {\r\n        node._store.validated = true;\r\n      }\r\n    } else if (node) {\r\n      var iteratorFn = getIteratorFn(node);\r\n\r\n      if (typeof iteratorFn === 'function') {\r\n        // Entry iterators used to provide implicit keys,\r\n        // but now we print a separate warning for them later.\r\n        if (iteratorFn !== node.entries) {\r\n          var iterator = iteratorFn.call(node);\r\n          var step;\r\n\r\n          while (!(step = iterator.next()).done) {\r\n            if (isValidElement(step.value)) {\r\n              validateExplicitKey(step.value, parentType);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n/**\r\n * Given an element, validate that its props follow the propTypes definition,\r\n * provided by the type.\r\n *\r\n * @param {ReactElement} element\r\n */\r\n\r\n\r\nfunction validatePropTypes(element) {\r\n  {\r\n    var type = element.type;\r\n\r\n    if (type === null || type === undefined || typeof type === 'string') {\r\n      return;\r\n    }\r\n\r\n    var propTypes;\r\n\r\n    if (typeof type === 'function') {\r\n      propTypes = type.propTypes;\r\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\r\n    // Inner props are checked in the reconciler.\r\n    type.$$typeof === REACT_MEMO_TYPE)) {\r\n      propTypes = type.propTypes;\r\n    } else {\r\n      return;\r\n    }\r\n\r\n    if (propTypes) {\r\n      // Intentionally inside to avoid triggering lazy initializers:\r\n      var name = getComponentNameFromType(type);\r\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\r\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\r\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\r\n\r\n      var _name = getComponentNameFromType(type);\r\n\r\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\r\n    }\r\n\r\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\r\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\r\n    }\r\n  }\r\n}\r\n/**\r\n * Given a fragment, validate that it can only be provided with fragment props\r\n * @param {ReactElement} fragment\r\n */\r\n\r\n\r\nfunction validateFragmentProps(fragment) {\r\n  {\r\n    var keys = Object.keys(fragment.props);\r\n\r\n    for (var i = 0; i < keys.length; i++) {\r\n      var key = keys[i];\r\n\r\n      if (key !== 'children' && key !== 'key') {\r\n        setCurrentlyValidatingElement$1(fragment);\r\n\r\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\r\n\r\n        setCurrentlyValidatingElement$1(null);\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (fragment.ref !== null) {\r\n      setCurrentlyValidatingElement$1(fragment);\r\n\r\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\r\n\r\n      setCurrentlyValidatingElement$1(null);\r\n    }\r\n  }\r\n}\r\n\r\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\r\n  {\r\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\r\n    // succeed and there will likely be errors in render.\r\n\r\n    if (!validType) {\r\n      var info = '';\r\n\r\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\r\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\r\n      }\r\n\r\n      var sourceInfo = getSourceInfoErrorAddendum(source);\r\n\r\n      if (sourceInfo) {\r\n        info += sourceInfo;\r\n      } else {\r\n        info += getDeclarationErrorAddendum();\r\n      }\r\n\r\n      var typeString;\r\n\r\n      if (type === null) {\r\n        typeString = 'null';\r\n      } else if (isArray(type)) {\r\n        typeString = 'array';\r\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\r\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\r\n        info = ' Did you accidentally export a JSX literal instead of a component?';\r\n      } else {\r\n        typeString = typeof type;\r\n      }\r\n\r\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\r\n    }\r\n\r\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\r\n    // TODO: Drop this when these are no longer allowed as the type argument.\r\n\r\n    if (element == null) {\r\n      return element;\r\n    } // Skip key warning if the type isn't valid since our key validation logic\r\n    // doesn't expect a non-string/function type and can throw confusing errors.\r\n    // We don't want exception behavior to differ between dev and prod.\r\n    // (Rendering will throw with a helpful message and as soon as the type is\r\n    // fixed, the key warnings will appear.)\r\n\r\n\r\n    if (validType) {\r\n      var children = props.children;\r\n\r\n      if (children !== undefined) {\r\n        if (isStaticChildren) {\r\n          if (isArray(children)) {\r\n            for (var i = 0; i < children.length; i++) {\r\n              validateChildKeys(children[i], type);\r\n            }\r\n\r\n            if (Object.freeze) {\r\n              Object.freeze(children);\r\n            }\r\n          } else {\r\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\r\n          }\r\n        } else {\r\n          validateChildKeys(children, type);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (type === REACT_FRAGMENT_TYPE) {\r\n      validateFragmentProps(element);\r\n    } else {\r\n      validatePropTypes(element);\r\n    }\r\n\r\n    return element;\r\n  }\r\n} // These two functions exist to still get child warnings in dev\r\n\r\nvar jsxDEV$1 =  jsxWithValidation ;\r\n\r\nexports.Fragment = REACT_FRAGMENT_TYPE;\r\nexports.jsxDEV = jsxDEV$1;\r\n  })();\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYjtBQUNBLElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLGdFQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQztBQUNyQztBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FB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QTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLDJEQUEyRCxVQUFVO0FBQ3JFLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWFjdFxcY2pzXFxyZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBsaWNlbnNlIFJlYWN0XHJcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgKGZ1bmN0aW9uKCkge1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG5cclxuLy8gQVRURU5USU9OXHJcbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcclxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xyXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cclxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcclxudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XHJcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcclxudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xyXG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XHJcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcclxudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcclxudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xyXG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XHJcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XHJcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XHJcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XHJcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xyXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xyXG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XHJcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xyXG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XHJcblxyXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XHJcblxyXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcclxuICB7XHJcbiAgICB7XHJcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XHJcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xyXG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xyXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxyXG4gIHtcclxuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcclxuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xyXG5cclxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcclxuICAgICAgZm9ybWF0ICs9ICclcyc7XHJcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcclxuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXHJcblxyXG5cclxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XHJcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcclxuXHJcbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcclxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcclxuXHJcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXHJcbnZhciBlbmFibGVDYWNoZUVsZW1lbnQgPSBmYWxzZTtcclxudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXHJcblxyXG52YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXHJcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxyXG5cclxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cclxuXHJcbnZhciBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFO1xyXG5cclxue1xyXG4gIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5tb2R1bGUucmVmZXJlbmNlJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XHJcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxyXG5cclxuXHJcbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgZW5hYmxlQ2FjaGVFbGVtZW50ICB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XHJcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcclxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcclxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxyXG4gICAgLy8gd2l0aC5cclxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcclxuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XHJcblxyXG4gIGlmIChkaXNwbGF5TmFtZSkge1xyXG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xyXG4gIH1cclxuXHJcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcclxuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xyXG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcclxuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XHJcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XHJcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xyXG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHtcclxuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIHR5cGU7XHJcbiAgfVxyXG5cclxuICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcclxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XHJcblxyXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcclxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xyXG5cclxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcclxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XHJcblxyXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxyXG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xyXG5cclxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcclxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XHJcblxyXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XHJcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcclxuXHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcclxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xyXG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xyXG5cclxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxyXG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XHJcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xyXG5cclxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxyXG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcclxuXHJcbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxyXG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcclxuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xyXG5cclxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xyXG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xyXG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xyXG5cclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XHJcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xyXG5cclxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxyXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxyXG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXHJcbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxyXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XHJcbnZhciBwcmV2TG9nO1xyXG52YXIgcHJldkluZm87XHJcbnZhciBwcmV2V2FybjtcclxudmFyIHByZXZFcnJvcjtcclxudmFyIHByZXZHcm91cDtcclxudmFyIHByZXZHcm91cENvbGxhcHNlZDtcclxudmFyIHByZXZHcm91cEVuZDtcclxuXHJcbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cclxuXHJcbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XHJcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xyXG4gIHtcclxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XHJcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xyXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XHJcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xyXG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcclxuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcclxuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcclxuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcclxuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxyXG5cclxuICAgICAgdmFyIHByb3BzID0ge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcclxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xyXG4gICAgICAgIGluZm86IHByb3BzLFxyXG4gICAgICAgIGxvZzogcHJvcHMsXHJcbiAgICAgICAgd2FybjogcHJvcHMsXHJcbiAgICAgICAgZXJyb3I6IHByb3BzLFxyXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcclxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXHJcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXHJcbiAgICAgIH0pO1xyXG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xyXG4gICAgfVxyXG5cclxuICAgIGRpc2FibGVkRGVwdGgrKztcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xyXG4gIHtcclxuICAgIGRpc2FibGVkRGVwdGgtLTtcclxuXHJcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xyXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cclxuICAgICAgdmFyIHByb3BzID0ge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XHJcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XHJcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcclxuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcclxuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XHJcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcclxuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcclxuICAgICAgICB9KSxcclxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xyXG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XHJcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXHJcbiAgICAgICAgfSlcclxuICAgICAgfSk7XHJcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XHJcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcclxudmFyIHByZWZpeDtcclxuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XHJcbiAge1xyXG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0aHJvdyBFcnJvcigpO1xyXG4gICAgICB9IGNhdGNoICh4KSB7XHJcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcclxuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcclxuICAgICAgfVxyXG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cclxuXHJcblxyXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcclxuICB9XHJcbn1cclxudmFyIHJlZW50cnkgPSBmYWxzZTtcclxudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XHJcblxyXG57XHJcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcclxuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcclxuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cclxuICBpZiAoICFmbiB8fCByZWVudHJ5KSB7XHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfVxyXG5cclxuICB7XHJcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XHJcblxyXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIGZyYW1lO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIGNvbnRyb2w7XHJcbiAgcmVlbnRyeSA9IHRydWU7XHJcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXHJcblxyXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xyXG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XHJcblxyXG4gIHtcclxuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXHJcbiAgICAvLyBmb3Igd2FybmluZ3MuXHJcblxyXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcclxuICAgIGRpc2FibGVMb2dzKCk7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXHJcbiAgICBpZiAoY29uc3RydWN0KSB7XHJcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxyXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aHJvdyBFcnJvcigpO1xyXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXHJcblxyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXHJcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXHJcbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XHJcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxyXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcclxuICAgICAgICB9IGNhdGNoICh4KSB7XHJcbiAgICAgICAgICBjb250cm9sID0geDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIEZha2UuY2FsbCgpO1xyXG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgICAgIGNvbnRyb2wgPSB4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcclxuICAgICAgfSBjYXRjaCAoeCkge1xyXG4gICAgICAgIGNvbnRyb2wgPSB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmbigpO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xyXG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cclxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xyXG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxyXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cclxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcclxuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xyXG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XHJcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XHJcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXHJcbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxyXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXHJcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcclxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxyXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxyXG4gICAgICAgIGMtLTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XHJcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXHJcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXHJcbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcclxuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXHJcbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXHJcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xyXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxyXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cclxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgIHMtLTtcclxuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cclxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cclxuXHJcbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcclxuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxyXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXHJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXHJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xyXG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIHJlZW50cnkgPSBmYWxzZTtcclxuXHJcbiAgICB7XHJcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcclxuICAgICAgcmVlbmFibGVMb2dzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xyXG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxyXG5cclxuXHJcbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcclxuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcclxuXHJcbiAge1xyXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xyXG59XHJcbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XHJcbiAge1xyXG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcclxuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcclxuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xyXG5cclxuICBpZiAodHlwZSA9PSBudWxsKSB7XHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHtcclxuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcclxuICB9XHJcblxyXG4gIHN3aXRjaCAodHlwZSkge1xyXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxyXG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XHJcblxyXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XHJcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcclxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxyXG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xyXG5cclxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XHJcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cclxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcclxuXHJcbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcclxuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcclxuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcclxuXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxyXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XHJcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiAnJztcclxufVxyXG5cclxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuXHJcbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcclxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xyXG5cclxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xyXG4gIHtcclxuICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xyXG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xyXG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xyXG4gIHtcclxuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cclxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xyXG5cclxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcclxuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcclxuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cclxuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXHJcbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXHJcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXHJcbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXHJcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xyXG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICBlcnJvciQxID0gZXg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcclxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xyXG5cclxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XHJcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcclxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXHJcbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XHJcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcclxuXHJcbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XHJcblxyXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXHJcblxyXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcclxuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XHJcbn1cclxuXHJcbi8qXHJcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxyXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxyXG4gKlxyXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXHJcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcclxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXHJcbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXHJcbiAqL1xyXG4vLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxyXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xyXG4gIHtcclxuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcclxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xyXG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7XHJcbiAgICByZXR1cm4gdHlwZTtcclxuICB9XHJcbn0gLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cclxuXHJcblxyXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xyXG4gIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcclxuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcclxuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxyXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cclxuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cclxuICAvL1xyXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xyXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXHJcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXHJcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXHJcbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXHJcbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcclxuICAvL1xyXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcclxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXHJcbiAgLy9cclxuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxyXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxyXG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcclxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxyXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcclxuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXHJcbiAgLy9cclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cclxuICByZXR1cm4gJycgKyB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XHJcbiAge1xyXG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xyXG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xyXG5cclxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcclxudmFyIFJFU0VSVkVEX1BST1BTID0ge1xyXG4gIGtleTogdHJ1ZSxcclxuICByZWY6IHRydWUsXHJcbiAgX19zZWxmOiB0cnVlLFxyXG4gIF9fc291cmNlOiB0cnVlXHJcbn07XHJcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcclxudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xyXG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcclxuXHJcbntcclxuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xyXG4gIHtcclxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XHJcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcclxuXHJcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcclxuICB7XHJcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xyXG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XHJcblxyXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcclxufVxyXG5cclxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xyXG4gIHtcclxuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XHJcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XHJcblxyXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcclxuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XHJcblxyXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcclxuICB7XHJcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XHJcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xyXG5cclxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcclxuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcclxuICB7XHJcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XHJcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xyXG5cclxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcclxuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xyXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xyXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcclxuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHsqfSB0eXBlXHJcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcclxuICogQHBhcmFtIHsqfSBrZXlcclxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcclxuICogQHBhcmFtIHsqfSBvd25lclxyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcclxuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxyXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xyXG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXHJcbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cclxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXHJcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuXHJcblxyXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xyXG4gIHZhciBlbGVtZW50ID0ge1xyXG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XHJcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxyXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxyXG4gICAgdHlwZTogdHlwZSxcclxuICAgIGtleToga2V5LFxyXG4gICAgcmVmOiByZWYsXHJcbiAgICBwcm9wczogcHJvcHMsXHJcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxyXG4gICAgX293bmVyOiBvd25lclxyXG4gIH07XHJcblxyXG4gIHtcclxuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cclxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXHJcbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXHJcbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cclxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXHJcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXHJcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xyXG4gICAgLy8gaWdub3JlcyBpdC5cclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgIHZhbHVlOiBzZWxmXHJcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcclxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcclxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgdmFsdWU6IHNvdXJjZVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcclxuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcclxuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBlbGVtZW50O1xyXG59O1xyXG4vKipcclxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xyXG4gKiBAcGFyYW0geyp9IHR5cGVcclxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcclxuICovXHJcblxyXG5mdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XHJcbiAge1xyXG4gICAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXHJcblxyXG4gICAgdmFyIHByb3BzID0ge307XHJcbiAgICB2YXIga2V5ID0gbnVsbDtcclxuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcclxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxyXG4gICAgLy8gb3IgPGRpdiBrZXk9XCJIaVwiIHsuLi5wcm9wc30gLz4gKS4gV2Ugd2FudCB0byBkZXByZWNhdGUga2V5IHNwcmVhZCxcclxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxyXG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcclxuICAgIC8vIGtleSBpcyBleHBsaWNpdGx5IGRlY2xhcmVkIHRvIGJlIHVuZGVmaW5lZCBvciBub3QuXHJcblxyXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAge1xyXG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XHJcbiAgICAgIHtcclxuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcclxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcclxuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XHJcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcclxuXHJcblxyXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcclxuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xyXG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XHJcbiAgICAgIH1cclxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXHJcblxyXG5cclxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XHJcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcclxuXHJcbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XHJcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChrZXkgfHwgcmVmKSB7XHJcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcclxuXHJcbiAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVmKSB7XHJcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcclxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XHJcblxyXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcclxuICB7XHJcbiAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcclxuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcclxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xyXG5cclxue1xyXG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XHJcbn1cclxuLyoqXHJcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXHJcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcclxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcclxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cclxuICogQGZpbmFsXHJcbiAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xyXG4gIHtcclxuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XHJcbiAge1xyXG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xyXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XHJcblxyXG4gICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAnJztcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xyXG4gIHtcclxuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xyXG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xyXG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAnJztcclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXHJcbiAqIHVwZGF0ZXMuXHJcbiAqL1xyXG5cclxuXHJcbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xyXG4gIHtcclxuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XHJcblxyXG4gICAgaWYgKCFpbmZvKSB7XHJcbiAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xyXG5cclxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcclxuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaW5mbztcclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cclxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXHJcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xyXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcclxuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXHJcbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XHJcbiAge1xyXG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcclxuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcclxuXHJcbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxyXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxyXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxyXG5cclxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XHJcblxyXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xyXG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cclxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcclxuXHJcbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcclxuXHJcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xyXG4gIH1cclxufVxyXG4vKipcclxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxyXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcclxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cclxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxyXG4gKi9cclxuXHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XHJcbiAge1xyXG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcclxuXHJcbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xyXG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XHJcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXHJcbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xyXG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobm9kZSkge1xyXG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXHJcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXHJcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xyXG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xyXG4gICAgICAgICAgdmFyIHN0ZXA7XHJcblxyXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxyXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cclxuICpcclxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xyXG4gIHtcclxuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xyXG5cclxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwcm9wVHlwZXM7XHJcblxyXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxyXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXHJcbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XHJcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwcm9wVHlwZXMpIHtcclxuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcclxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XHJcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcclxuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcclxuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxyXG5cclxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xyXG5cclxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcclxuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xyXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XHJcbiAge1xyXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG5cclxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XHJcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XHJcblxyXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcclxuXHJcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcclxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XHJcblxyXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcclxuXHJcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcclxuICB7XHJcbiAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xyXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cclxuXHJcbiAgICBpZiAoIXZhbGlkVHlwZSkge1xyXG4gICAgICB2YXIgaW5mbyA9ICcnO1xyXG5cclxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XHJcblxyXG4gICAgICBpZiAoc291cmNlSW5mbykge1xyXG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgdHlwZVN0cmluZztcclxuXHJcbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XHJcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcclxuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XHJcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xyXG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcclxuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXHJcbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXHJcblxyXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcclxuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cclxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cclxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXHJcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXHJcblxyXG5cclxuICAgIGlmICh2YWxpZFR5cGUpIHtcclxuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XHJcblxyXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcclxuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xyXG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxuICB9XHJcbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XHJcblxyXG52YXIganN4REVWJDEgPSAganN4V2l0aFZhbGlkYXRpb24gO1xyXG5cclxuZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XHJcbmV4cG9ydHMuanN4REVWID0ganN4REVWJDE7XHJcbiAgfSkoKTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\r\n\r\nif (false) {} else {\r\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(pages-dir-browser)/./node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSwyS0FBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlYWN0XFxqc3gtZGV2LXJ1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xyXG59IGVsc2Uge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/abis/DAIToken.json":
/*!********************************!*\
  !*** ./src/abis/DAIToken.json ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"abi":[{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}]}');

/***/ }),

/***/ "(pages-dir-browser)/./src/abis/LendingHelper.json":
/*!*************************************!*\
  !*** ./src/abis/LendingHelper.json ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"abi":[{"inputs":[{"internalType":"address","name":"asset","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"getAmountInUSD","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"getTokensPerUSDAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}]}');

/***/ }),

/***/ "(pages-dir-browser)/./src/abis/LendingPool.json":
/*!***********************************!*\
  !*** ./src/abis/LendingPool.json ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"abi":[{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getAccountData","outputs":[{"internalType":"uint256","name":"collateralValue1e18","type":"uint256"},{"internalType":"uint256","name":"debtValue1e18","type":"uint256"},{"internalType":"uint256","name":"healthFactor1e18","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"asset","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"lend","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"asset","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"asset","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"borrow","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"asset","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"repay","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getLenderAssets","outputs":[{"components":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"lentQty","type":"uint256"},{"internalType":"uint256","name":"lentApy","type":"uint256"}],"internalType":"struct LendingPool.LenderAsset[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getBorrowerAssets","outputs":[{"components":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"borrowQty","type":"uint256"},{"internalType":"uint256","name":"borrowApy","type":"uint256"}],"internalType":"struct LendingPool.BorrowerAsset[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getAssetsToBorrow","outputs":[{"components":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"borrowQty","type":"uint256"},{"internalType":"uint256","name":"borrowApy","type":"uint256"}],"internalType":"struct LendingPool.BorrowerAsset[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"assetType","type":"uint256"}],"name":"getUserTotalAvailableBalanceInUSD","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"address","name":"asset","type":"address"}],"name":"getUserReserve","outputs":[{"components":[{"components":[{"internalType":"uint128","name":"principal","type":"uint128"},{"internalType":"uint128","name":"index","type":"uint128"}],"internalType":"struct LendingPool.UserReserveData","name":"supply","type":"tuple"},{"components":[{"internalType":"uint128","name":"principal","type":"uint128"},{"internalType":"uint128","name":"index","type":"uint128"}],"internalType":"struct LendingPool.UserReserveData","name":"borrow","type":"tuple"}],"internalType":"struct LendingPool.UserReserve","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"asset","type":"address"}],"name":"accruePublic","outputs":[],"stateMutability":"nonpayable","type":"function"}]}');

/***/ }),

/***/ "(pages-dir-browser)/./src/abis/index.js":
/*!***************************!*\
  !*** ./src/abis/index.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nconst TokenABI = __webpack_require__(/*! ./DAIToken.json */ \"(pages-dir-browser)/./src/abis/DAIToken.json\");\nconst LendingPoolABI = __webpack_require__(/*! ./LendingPool.json */ \"(pages-dir-browser)/./src/abis/LendingPool.json\");\nconst LendingHelperABI = __webpack_require__(/*! ./LendingHelper.json */ \"(pages-dir-browser)/./src/abis/LendingHelper.json\");\nmodule.exports = {\n    TokenABI,\n    LendingPoolABI,\n    LendingHelperABI\n};\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9hYmlzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxXQUFXQyxtQkFBT0EsQ0FBQyxxRUFBaUI7QUFDMUMsTUFBTUMsaUJBQWlCRCxtQkFBT0EsQ0FBQywyRUFBb0I7QUFDbkQsTUFBTUUsbUJBQW1CRixtQkFBT0EsQ0FBQywrRUFBc0I7QUFFdkRHLE9BQU9DLE9BQU8sR0FBRztJQUNmTDtJQUNBRTtJQUNBQztBQUNGIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcc3JjXFxhYmlzXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBUb2tlbkFCSSA9IHJlcXVpcmUoJy4vREFJVG9rZW4uanNvbicpO1xyXG5jb25zdCBMZW5kaW5nUG9vbEFCSSA9IHJlcXVpcmUoJy4vTGVuZGluZ1Bvb2wuanNvbicpO1xyXG5jb25zdCBMZW5kaW5nSGVscGVyQUJJID0gcmVxdWlyZSgnLi9MZW5kaW5nSGVscGVyLmpzb24nKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIFRva2VuQUJJLFxyXG4gIExlbmRpbmdQb29sQUJJLFxyXG4gIExlbmRpbmdIZWxwZXJBQkksXHJcbn07XHJcblxyXG5cclxuIl0sIm5hbWVzIjpbIlRva2VuQUJJIiwicmVxdWlyZSIsIkxlbmRpbmdQb29sQUJJIiwiTGVuZGluZ0hlbHBlckFCSSIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/abis/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/addresses.js":
/*!**************************!*\
  !*** ./src/addresses.js ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DAIAddress: () => (/* binding */ DAIAddress),\n/* harmony export */   ETHAddress: () => (/* binding */ ETHAddress),\n/* harmony export */   InterestRateModelAddress: () => (/* binding */ InterestRateModelAddress),\n/* harmony export */   LINKAddress: () => (/* binding */ LINKAddress),\n/* harmony export */   LendingHelperAddress: () => (/* binding */ LendingHelperAddress),\n/* harmony export */   LendingPoolAddress: () => (/* binding */ LendingPoolAddress),\n/* harmony export */   MockV3AggregatorAddress: () => (/* binding */ MockV3AggregatorAddress),\n/* harmony export */   PriceOracleAddress: () => (/* binding */ PriceOracleAddress),\n/* harmony export */   USDCAddress: () => (/* binding */ USDCAddress),\n/* harmony export */   WETHAddress: () => (/* binding */ WETHAddress)\n/* harmony export */ });\n// Contract addresses (auto-updated by deploy script)\nconst ETHAddress = \"0x0000000000000000000000000000000000000000\";\nconst LendingPoolAddress = \"0x6A390857c83B00c915101ba92e85390F3D092Da4\";\nconst InterestRateModelAddress = \"0x886B0BCCAa9787e6253A34FCbb0B0C41515fC1ad\";\nconst LendingHelperAddress = \"0x0000000000000000000000000000000000000000\"; // Not deployed\nconst WETHAddress = \"0x5dbaA510902A078Fb07D828a779b4a1CCD931FCe\";\nconst DAIAddress = \"0xA9333DE801626733a8C4996F0A55C279817c1481\";\nconst USDCAddress = \"0xE69772C639d168EF8e252C17EB591E43E5B0D914\";\nconst LINKAddress = \"0xa24b76c2BE9B2AA65048Acc1dAF7be920d2AEf29\";\nconst PriceOracleAddress = \"0xd49Ffcb8507478C3b35886a0A6F7a0C75eC730e0\";\nconst MockV3AggregatorAddress = \"0x3814c61Cdd91708fc8391AF266Bf1e28CB2a43a5\";\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9hZGRyZXNzZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBLHFEQUFxRDtBQUM5QyxNQUFNQSxhQUFhLDZDQUE2QztBQUNoRSxNQUFNQyxxQkFBcUIsNkNBQTZDO0FBQ3hFLE1BQU1DLDJCQUEyQiw2Q0FBNkM7QUFDOUUsTUFBTUMsdUJBQXVCLDZDQUE2QyxDQUFDLGVBQWU7QUFDMUYsTUFBTUMsY0FBYyw2Q0FBNkM7QUFDakUsTUFBTUMsYUFBYSw2Q0FBNkM7QUFDaEUsTUFBTUMsY0FBYyw2Q0FBNkM7QUFDakUsTUFBTUMsY0FBYyw2Q0FBNkM7QUFDakUsTUFBTUMscUJBQXFCLDZDQUE2QztBQUN4RSxNQUFNQywwQkFBMEIsNkNBQTZDIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcc3JjXFxhZGRyZXNzZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29udHJhY3QgYWRkcmVzc2VzIChhdXRvLXVwZGF0ZWQgYnkgZGVwbG95IHNjcmlwdClcbmV4cG9ydCBjb25zdCBFVEhBZGRyZXNzID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbmV4cG9ydCBjb25zdCBMZW5kaW5nUG9vbEFkZHJlc3MgPSBcIjB4NkEzOTA4NTdjODNCMDBjOTE1MTAxYmE5MmU4NTM5MEYzRDA5MkRhNFwiO1xuZXhwb3J0IGNvbnN0IEludGVyZXN0UmF0ZU1vZGVsQWRkcmVzcyA9IFwiMHg4ODZCMEJDQ0FhOTc4N2U2MjUzQTM0RkNiYjBCMEM0MTUxNWZDMWFkXCI7XG5leHBvcnQgY29uc3QgTGVuZGluZ0hlbHBlckFkZHJlc3MgPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiOyAvLyBOb3QgZGVwbG95ZWRcbmV4cG9ydCBjb25zdCBXRVRIQWRkcmVzcyA9IFwiMHg1ZGJhQTUxMDkwMkEwNzhGYjA3RDgyOGE3NzliNGExQ0NEOTMxRkNlXCI7XG5leHBvcnQgY29uc3QgREFJQWRkcmVzcyA9IFwiMHhBOTMzM0RFODAxNjI2NzMzYThDNDk5NkYwQTU1QzI3OTgxN2MxNDgxXCI7XG5leHBvcnQgY29uc3QgVVNEQ0FkZHJlc3MgPSBcIjB4RTY5NzcyQzYzOWQxNjhFRjhlMjUyQzE3RUI1OTFFNDNFNUIwRDkxNFwiO1xuZXhwb3J0IGNvbnN0IExJTktBZGRyZXNzID0gXCIweGEyNGI3NmMyQkU5QjJBQTY1MDQ4QWNjMWRBRjdiZTkyMGQyQUVmMjlcIjtcbmV4cG9ydCBjb25zdCBQcmljZU9yYWNsZUFkZHJlc3MgPSBcIjB4ZDQ5RmZjYjg1MDc0NzhDM2IzNTg4NmEwQTZGN2EwQzc1ZUM3MzBlMFwiO1xuZXhwb3J0IGNvbnN0IE1vY2tWM0FnZ3JlZ2F0b3JBZGRyZXNzID0gXCIweDM4MTRjNjFDZGQ5MTcwOGZjODM5MUFGMjY2QmYxZTI4Q0IyYTQzYTVcIjtcbiJdLCJuYW1lcyI6WyJFVEhBZGRyZXNzIiwiTGVuZGluZ1Bvb2xBZGRyZXNzIiwiSW50ZXJlc3RSYXRlTW9kZWxBZGRyZXNzIiwiTGVuZGluZ0hlbHBlckFkZHJlc3MiLCJXRVRIQWRkcmVzcyIsIkRBSUFkZHJlc3MiLCJVU0RDQWRkcmVzcyIsIkxJTktBZGRyZXNzIiwiUHJpY2VPcmFjbGVBZGRyZXNzIiwiTW9ja1YzQWdncmVnYXRvckFkZHJlc3MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/addresses.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/config/abis.ts":
/*!****************************!*\
  !*** ./src/config/abis.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ERC20_ABI: () => (/* binding */ ERC20_ABI),\n/* harmony export */   INTEREST_RATE_MODEL_ABI: () => (/* binding */ INTEREST_RATE_MODEL_ABI),\n/* harmony export */   ORACLE_ABI: () => (/* binding */ ORACLE_ABI),\n/* harmony export */   POOL_ABI: () => (/* binding */ POOL_ABI)\n/* harmony export */ });\n// Contract ABIs for LendHub v2\nconst POOL_ABI = [\n    // View functions\n    'function getAccountData(address user) external view returns (uint256 collateralValue1e18, uint256 debtValue1e18, uint256 healthFactor1e18)',\n    'function getReserveData(address asset) external view returns (uint256 reserveCash, uint256 totalDebt, uint256 utilizationWad, uint256 liquidityRateRayPerSec, uint256 variableBorrowRateRayPerSec, uint256 liquidityIndexRay, uint256 variableBorrowIndexRay, uint8 decimals, bool isBorrowable, uint16 liquidationThreshold, uint16 ltv, uint16 reserveFactor, uint16 liquidationBonus, uint16 closeFactor)',\n    'function getUserReserveData(address user, address asset) external view returns (uint256 supplyBalance1e18, uint256 borrowBalance1e18, bool isCollateral)',\n    'function reserves(address asset) external view returns (uint256 reserveCash, uint256 totalDebt, uint256 utilizationWad, uint256 liquidityRateRayPerSec, uint256 variableBorrowRateRayPerSec, uint256 liquidityIndexRay, uint256 variableBorrowIndexRay, uint8 decimals, bool isBorrowable, uint16 liquidationThreshold, uint16 ltv, uint16 reserveFactor, uint16 liquidationBonus, uint16 closeFactor)',\n    'function userReserves(address user, address asset) external view returns (uint256 supplyBalance1e18, uint256 borrowBalance1e18, bool isCollateral)',\n    // Write functions\n    'function lend(address asset, uint256 amount) external',\n    'function withdraw(address asset, uint256 amount) external',\n    'function borrow(address asset, uint256 amount) external',\n    'function repay(address asset, uint256 amount, address onBehalfOf) external returns (uint256)',\n    'function liquidationCall(address debtAsset, address collateralAsset, address user, uint256 debtAmount) external',\n    'function accruePublic(address asset) external',\n    // Events\n    'event ReserveDataUpdated(address indexed asset, uint256 utilizationWad, uint256 liquidityRateRayPerSec, uint256 variableBorrowRateRayPerSec, uint256 liquidityIndexRay, uint256 variableBorrowIndexRay)',\n    'event Supplied(address indexed user, address indexed asset, uint256 amount)',\n    'event Withdrawn(address indexed user, address indexed asset, uint256 amount)',\n    'event Borrowed(address indexed user, address indexed asset, uint256 amount)',\n    'event Repaid(address indexed user, address indexed onBehalfOf, address indexed asset, uint256 amount)',\n    'event Liquidated(address indexed liquidator, address indexed user, address indexed debtAsset, address indexed collateralAsset, uint256 debtAmount, uint256 collateralAmount)'\n];\nconst ERC20_ABI = [\n    // View functions\n    'function balanceOf(address owner) external view returns (uint256)',\n    'function allowance(address owner, address spender) external view returns (uint256)',\n    'function decimals() external view returns (uint8)',\n    'function symbol() external view returns (string)',\n    'function name() external view returns (string)',\n    'function totalSupply() external view returns (uint256)',\n    // Write functions\n    'function approve(address spender, uint256 amount) external returns (bool)',\n    'function transfer(address to, uint256 amount) external returns (bool)',\n    'function transferFrom(address from, address to, uint256 amount) external returns (bool)',\n    // Events\n    'event Transfer(address indexed from, address indexed to, uint256 value)',\n    'event Approval(address indexed owner, address indexed spender, uint256 value)'\n];\nconst ORACLE_ABI = [\n    // View functions\n    'function getAssetPrice1e18(address asset) external view returns (uint256)',\n    'function getAssetPrice(address asset) external view returns (uint256)',\n    // Write functions (for testing)\n    'function setAssetPrice(address asset, uint256 price) external',\n    // Events\n    'event AssetPriceUpdated(address indexed asset, uint256 oldPrice, uint256 newPrice)'\n];\n// Interest Rate Model ABI (if needed)\nconst INTEREST_RATE_MODEL_ABI = [\n    'function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) external view returns (uint256)',\n    'function getSupplyRate(uint256 cash, uint256 borrows, uint256 reserves, uint256 reserveFactorMantissa) external view returns (uint256)'\n];\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9jb25maWcvYWJpcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsK0JBQStCO0FBRXhCLE1BQU1BLFdBQVc7SUFDdEIsaUJBQWlCO0lBQ2pCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFFQSxrQkFBa0I7SUFDbEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBRUEsU0FBUztJQUNUO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNELENBQVU7QUFFSixNQUFNQyxZQUFZO0lBQ3ZCLGlCQUFpQjtJQUNqQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFFQSxrQkFBa0I7SUFDbEI7SUFDQTtJQUNBO0lBRUEsU0FBUztJQUNUO0lBQ0E7Q0FDRCxDQUFVO0FBRUosTUFBTUMsYUFBYTtJQUN4QixpQkFBaUI7SUFDakI7SUFDQTtJQUVBLGdDQUFnQztJQUNoQztJQUVBLFNBQVM7SUFDVDtDQUNELENBQVU7QUFFWCxzQ0FBc0M7QUFDL0IsTUFBTUMsMEJBQTBCO0lBQ3JDO0lBQ0E7Q0FDRCxDQUFVIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcc3JjXFxjb25maWdcXGFiaXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29udHJhY3QgQUJJcyBmb3IgTGVuZEh1YiB2MlxyXG5cclxuZXhwb3J0IGNvbnN0IFBPT0xfQUJJID0gW1xyXG4gIC8vIFZpZXcgZnVuY3Rpb25zXHJcbiAgJ2Z1bmN0aW9uIGdldEFjY291bnREYXRhKGFkZHJlc3MgdXNlcikgZXh0ZXJuYWwgdmlldyByZXR1cm5zICh1aW50MjU2IGNvbGxhdGVyYWxWYWx1ZTFlMTgsIHVpbnQyNTYgZGVidFZhbHVlMWUxOCwgdWludDI1NiBoZWFsdGhGYWN0b3IxZTE4KScsXHJcbiAgJ2Z1bmN0aW9uIGdldFJlc2VydmVEYXRhKGFkZHJlc3MgYXNzZXQpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAodWludDI1NiByZXNlcnZlQ2FzaCwgdWludDI1NiB0b3RhbERlYnQsIHVpbnQyNTYgdXRpbGl6YXRpb25XYWQsIHVpbnQyNTYgbGlxdWlkaXR5UmF0ZVJheVBlclNlYywgdWludDI1NiB2YXJpYWJsZUJvcnJvd1JhdGVSYXlQZXJTZWMsIHVpbnQyNTYgbGlxdWlkaXR5SW5kZXhSYXksIHVpbnQyNTYgdmFyaWFibGVCb3Jyb3dJbmRleFJheSwgdWludDggZGVjaW1hbHMsIGJvb2wgaXNCb3Jyb3dhYmxlLCB1aW50MTYgbGlxdWlkYXRpb25UaHJlc2hvbGQsIHVpbnQxNiBsdHYsIHVpbnQxNiByZXNlcnZlRmFjdG9yLCB1aW50MTYgbGlxdWlkYXRpb25Cb251cywgdWludDE2IGNsb3NlRmFjdG9yKScsXHJcbiAgJ2Z1bmN0aW9uIGdldFVzZXJSZXNlcnZlRGF0YShhZGRyZXNzIHVzZXIsIGFkZHJlc3MgYXNzZXQpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAodWludDI1NiBzdXBwbHlCYWxhbmNlMWUxOCwgdWludDI1NiBib3Jyb3dCYWxhbmNlMWUxOCwgYm9vbCBpc0NvbGxhdGVyYWwpJyxcclxuICAnZnVuY3Rpb24gcmVzZXJ2ZXMoYWRkcmVzcyBhc3NldCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zICh1aW50MjU2IHJlc2VydmVDYXNoLCB1aW50MjU2IHRvdGFsRGVidCwgdWludDI1NiB1dGlsaXphdGlvbldhZCwgdWludDI1NiBsaXF1aWRpdHlSYXRlUmF5UGVyU2VjLCB1aW50MjU2IHZhcmlhYmxlQm9ycm93UmF0ZVJheVBlclNlYywgdWludDI1NiBsaXF1aWRpdHlJbmRleFJheSwgdWludDI1NiB2YXJpYWJsZUJvcnJvd0luZGV4UmF5LCB1aW50OCBkZWNpbWFscywgYm9vbCBpc0JvcnJvd2FibGUsIHVpbnQxNiBsaXF1aWRhdGlvblRocmVzaG9sZCwgdWludDE2IGx0diwgdWludDE2IHJlc2VydmVGYWN0b3IsIHVpbnQxNiBsaXF1aWRhdGlvbkJvbnVzLCB1aW50MTYgY2xvc2VGYWN0b3IpJyxcclxuICAnZnVuY3Rpb24gdXNlclJlc2VydmVzKGFkZHJlc3MgdXNlciwgYWRkcmVzcyBhc3NldCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zICh1aW50MjU2IHN1cHBseUJhbGFuY2UxZTE4LCB1aW50MjU2IGJvcnJvd0JhbGFuY2UxZTE4LCBib29sIGlzQ29sbGF0ZXJhbCknLFxyXG4gIFxyXG4gIC8vIFdyaXRlIGZ1bmN0aW9uc1xyXG4gICdmdW5jdGlvbiBsZW5kKGFkZHJlc3MgYXNzZXQsIHVpbnQyNTYgYW1vdW50KSBleHRlcm5hbCcsXHJcbiAgJ2Z1bmN0aW9uIHdpdGhkcmF3KGFkZHJlc3MgYXNzZXQsIHVpbnQyNTYgYW1vdW50KSBleHRlcm5hbCcsXHJcbiAgJ2Z1bmN0aW9uIGJvcnJvdyhhZGRyZXNzIGFzc2V0LCB1aW50MjU2IGFtb3VudCkgZXh0ZXJuYWwnLFxyXG4gICdmdW5jdGlvbiByZXBheShhZGRyZXNzIGFzc2V0LCB1aW50MjU2IGFtb3VudCwgYWRkcmVzcyBvbkJlaGFsZk9mKSBleHRlcm5hbCByZXR1cm5zICh1aW50MjU2KScsXHJcbiAgJ2Z1bmN0aW9uIGxpcXVpZGF0aW9uQ2FsbChhZGRyZXNzIGRlYnRBc3NldCwgYWRkcmVzcyBjb2xsYXRlcmFsQXNzZXQsIGFkZHJlc3MgdXNlciwgdWludDI1NiBkZWJ0QW1vdW50KSBleHRlcm5hbCcsXHJcbiAgJ2Z1bmN0aW9uIGFjY3J1ZVB1YmxpYyhhZGRyZXNzIGFzc2V0KSBleHRlcm5hbCcsXHJcbiAgXHJcbiAgLy8gRXZlbnRzXHJcbiAgJ2V2ZW50IFJlc2VydmVEYXRhVXBkYXRlZChhZGRyZXNzIGluZGV4ZWQgYXNzZXQsIHVpbnQyNTYgdXRpbGl6YXRpb25XYWQsIHVpbnQyNTYgbGlxdWlkaXR5UmF0ZVJheVBlclNlYywgdWludDI1NiB2YXJpYWJsZUJvcnJvd1JhdGVSYXlQZXJTZWMsIHVpbnQyNTYgbGlxdWlkaXR5SW5kZXhSYXksIHVpbnQyNTYgdmFyaWFibGVCb3Jyb3dJbmRleFJheSknLFxyXG4gICdldmVudCBTdXBwbGllZChhZGRyZXNzIGluZGV4ZWQgdXNlciwgYWRkcmVzcyBpbmRleGVkIGFzc2V0LCB1aW50MjU2IGFtb3VudCknLFxyXG4gICdldmVudCBXaXRoZHJhd24oYWRkcmVzcyBpbmRleGVkIHVzZXIsIGFkZHJlc3MgaW5kZXhlZCBhc3NldCwgdWludDI1NiBhbW91bnQpJyxcclxuICAnZXZlbnQgQm9ycm93ZWQoYWRkcmVzcyBpbmRleGVkIHVzZXIsIGFkZHJlc3MgaW5kZXhlZCBhc3NldCwgdWludDI1NiBhbW91bnQpJyxcclxuICAnZXZlbnQgUmVwYWlkKGFkZHJlc3MgaW5kZXhlZCB1c2VyLCBhZGRyZXNzIGluZGV4ZWQgb25CZWhhbGZPZiwgYWRkcmVzcyBpbmRleGVkIGFzc2V0LCB1aW50MjU2IGFtb3VudCknLFxyXG4gICdldmVudCBMaXF1aWRhdGVkKGFkZHJlc3MgaW5kZXhlZCBsaXF1aWRhdG9yLCBhZGRyZXNzIGluZGV4ZWQgdXNlciwgYWRkcmVzcyBpbmRleGVkIGRlYnRBc3NldCwgYWRkcmVzcyBpbmRleGVkIGNvbGxhdGVyYWxBc3NldCwgdWludDI1NiBkZWJ0QW1vdW50LCB1aW50MjU2IGNvbGxhdGVyYWxBbW91bnQpJyxcclxuXSBhcyBjb25zdDtcclxuXHJcbmV4cG9ydCBjb25zdCBFUkMyMF9BQkkgPSBbXHJcbiAgLy8gVmlldyBmdW5jdGlvbnNcclxuICAnZnVuY3Rpb24gYmFsYW5jZU9mKGFkZHJlc3Mgb3duZXIpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAodWludDI1NiknLFxyXG4gICdmdW5jdGlvbiBhbGxvd2FuY2UoYWRkcmVzcyBvd25lciwgYWRkcmVzcyBzcGVuZGVyKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKHVpbnQyNTYpJyxcclxuICAnZnVuY3Rpb24gZGVjaW1hbHMoKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKHVpbnQ4KScsXHJcbiAgJ2Z1bmN0aW9uIHN5bWJvbCgpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAoc3RyaW5nKScsXHJcbiAgJ2Z1bmN0aW9uIG5hbWUoKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKHN0cmluZyknLFxyXG4gICdmdW5jdGlvbiB0b3RhbFN1cHBseSgpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAodWludDI1NiknLFxyXG4gIFxyXG4gIC8vIFdyaXRlIGZ1bmN0aW9uc1xyXG4gICdmdW5jdGlvbiBhcHByb3ZlKGFkZHJlc3Mgc3BlbmRlciwgdWludDI1NiBhbW91bnQpIGV4dGVybmFsIHJldHVybnMgKGJvb2wpJyxcclxuICAnZnVuY3Rpb24gdHJhbnNmZXIoYWRkcmVzcyB0bywgdWludDI1NiBhbW91bnQpIGV4dGVybmFsIHJldHVybnMgKGJvb2wpJyxcclxuICAnZnVuY3Rpb24gdHJhbnNmZXJGcm9tKGFkZHJlc3MgZnJvbSwgYWRkcmVzcyB0bywgdWludDI1NiBhbW91bnQpIGV4dGVybmFsIHJldHVybnMgKGJvb2wpJyxcclxuICBcclxuICAvLyBFdmVudHNcclxuICAnZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBpbmRleGVkIGZyb20sIGFkZHJlc3MgaW5kZXhlZCB0bywgdWludDI1NiB2YWx1ZSknLFxyXG4gICdldmVudCBBcHByb3ZhbChhZGRyZXNzIGluZGV4ZWQgb3duZXIsIGFkZHJlc3MgaW5kZXhlZCBzcGVuZGVyLCB1aW50MjU2IHZhbHVlKScsXHJcbl0gYXMgY29uc3Q7XHJcblxyXG5leHBvcnQgY29uc3QgT1JBQ0xFX0FCSSA9IFtcclxuICAvLyBWaWV3IGZ1bmN0aW9uc1xyXG4gICdmdW5jdGlvbiBnZXRBc3NldFByaWNlMWUxOChhZGRyZXNzIGFzc2V0KSBleHRlcm5hbCB2aWV3IHJldHVybnMgKHVpbnQyNTYpJyxcclxuICAnZnVuY3Rpb24gZ2V0QXNzZXRQcmljZShhZGRyZXNzIGFzc2V0KSBleHRlcm5hbCB2aWV3IHJldHVybnMgKHVpbnQyNTYpJyxcclxuICBcclxuICAvLyBXcml0ZSBmdW5jdGlvbnMgKGZvciB0ZXN0aW5nKVxyXG4gICdmdW5jdGlvbiBzZXRBc3NldFByaWNlKGFkZHJlc3MgYXNzZXQsIHVpbnQyNTYgcHJpY2UpIGV4dGVybmFsJyxcclxuICBcclxuICAvLyBFdmVudHNcclxuICAnZXZlbnQgQXNzZXRQcmljZVVwZGF0ZWQoYWRkcmVzcyBpbmRleGVkIGFzc2V0LCB1aW50MjU2IG9sZFByaWNlLCB1aW50MjU2IG5ld1ByaWNlKScsXHJcbl0gYXMgY29uc3Q7XHJcblxyXG4vLyBJbnRlcmVzdCBSYXRlIE1vZGVsIEFCSSAoaWYgbmVlZGVkKVxyXG5leHBvcnQgY29uc3QgSU5URVJFU1RfUkFURV9NT0RFTF9BQkkgPSBbXHJcbiAgJ2Z1bmN0aW9uIGdldEJvcnJvd1JhdGUodWludDI1NiBjYXNoLCB1aW50MjU2IGJvcnJvd3MsIHVpbnQyNTYgcmVzZXJ2ZXMpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAodWludDI1NiknLFxyXG4gICdmdW5jdGlvbiBnZXRTdXBwbHlSYXRlKHVpbnQyNTYgY2FzaCwgdWludDI1NiBib3Jyb3dzLCB1aW50MjU2IHJlc2VydmVzLCB1aW50MjU2IHJlc2VydmVGYWN0b3JNYW50aXNzYSkgZXh0ZXJuYWwgdmlldyByZXR1cm5zICh1aW50MjU2KScsXHJcbl0gYXMgY29uc3Q7XHJcbiJdLCJuYW1lcyI6WyJQT09MX0FCSSIsIkVSQzIwX0FCSSIsIk9SQUNMRV9BQkkiLCJJTlRFUkVTVF9SQVRFX01PREVMX0FCSSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/config/abis.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/config/contracts.ts":
/*!*********************************!*\
  !*** ./src/config/contracts.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONFIG: () => (/* binding */ CONFIG),\n/* harmony export */   NETWORK_CONFIG: () => (/* binding */ NETWORK_CONFIG),\n/* harmony export */   getTokenByAddress: () => (/* binding */ getTokenByAddress),\n/* harmony export */   getTokenBySymbol: () => (/* binding */ getTokenBySymbol),\n/* harmony export */   isTokenBorrowable: () => (/* binding */ isTokenBorrowable),\n/* harmony export */   isTokenCollateral: () => (/* binding */ isTokenCollateral)\n/* harmony export */ });\n/* harmony import */ var _addresses__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../addresses */ \"(pages-dir-browser)/./src/addresses.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n// Contract configuration from environment variables\nconst CONFIG = {\n    RPC_URL: \"http://localhost:8545\" || 0,\n    CHAIN_ID: parseInt(\"1337\" || 0, 10),\n    CHAIN_ID_HEX: process.env.NEXT_PUBLIC_CHAIN_ID_HEX || '0x539',\n    // Contract addresses (auto-imported from addresses.js)\n    LENDING_POOL: _addresses__WEBPACK_IMPORTED_MODULE_0__.LendingPoolAddress,\n    PRICE_ORACLE: _addresses__WEBPACK_IMPORTED_MODULE_0__.PriceOracleAddress,\n    WETH: _addresses__WEBPACK_IMPORTED_MODULE_0__.WETHAddress,\n    // Token configuration\n    TOKENS: [\n        {\n            address: '0x0000000000000000000000000000000000000000',\n            symbol: 'ETH',\n            name: 'Ethereum',\n            decimals: 18,\n            isBorrowable: false,\n            isCollateral: false,\n            isNative: true\n        },\n        {\n            address: _addresses__WEBPACK_IMPORTED_MODULE_0__.WETHAddress,\n            symbol: 'WETH',\n            name: 'Wrapped Ethereum',\n            decimals: 18,\n            isBorrowable: false,\n            isCollateral: true\n        },\n        {\n            address: _addresses__WEBPACK_IMPORTED_MODULE_0__.DAIAddress,\n            symbol: 'DAI',\n            name: 'Dai Stablecoin',\n            decimals: 18,\n            isBorrowable: true,\n            isCollateral: false\n        },\n        {\n            address: _addresses__WEBPACK_IMPORTED_MODULE_0__.USDCAddress,\n            symbol: 'USDC',\n            name: 'USD Coin',\n            decimals: 6,\n            isBorrowable: true,\n            isCollateral: false\n        },\n        {\n            address: _addresses__WEBPACK_IMPORTED_MODULE_0__.LINKAddress,\n            symbol: 'LINK',\n            name: 'Chainlink',\n            decimals: 18,\n            isBorrowable: true,\n            isCollateral: false\n        }\n    ]\n};\n// Network configuration\nconst NETWORK_CONFIG = {\n    chainId: CONFIG.CHAIN_ID,\n    chainName: 'Ganache Local',\n    nativeCurrency: {\n        name: 'Ethereum',\n        symbol: 'ETH',\n        decimals: 18\n    },\n    rpcUrls: [\n        CONFIG.RPC_URL\n    ],\n    blockExplorerUrls: null\n};\n// Helper functions\nfunction getTokenByAddress(address) {\n    return CONFIG.TOKENS.find((token)=>token.address.toLowerCase() === address.toLowerCase());\n}\nfunction getTokenBySymbol(symbol) {\n    return CONFIG.TOKENS.find((token)=>token.symbol.toLowerCase() === symbol.toLowerCase());\n}\nfunction isTokenBorrowable(address) {\n    const token = getTokenByAddress(address);\n    return (token === null || token === void 0 ? void 0 : token.isBorrowable) || false;\n}\nfunction isTokenCollateral(address) {\n    const token = getTokenByAddress(address);\n    return (token === null || token === void 0 ? void 0 : token.isCollateral) || false;\n}\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9jb25maWcvY29udHJhY3RzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBT3NCO0FBRXRCLG9EQUFvRDtBQUM3QyxNQUFNTSxTQUFTO0lBQ3BCQyxTQUFTQyx1QkFBK0IsSUFBSSxDQUF1QjtJQUNuRUcsVUFBVUMsU0FBU0osTUFBZ0MsSUFBSSxDQUFNLEVBQUU7SUFDL0RNLGNBQWNOLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ00sd0JBQXdCLElBQUk7SUFFdEQsdURBQXVEO0lBQ3ZEQyxjQUFjaEIsMERBQWtCQTtJQUNoQ2lCLGNBQWNoQiwwREFBa0JBO0lBQ2hDaUIsTUFBTWhCLG1EQUFXQTtJQUVqQixzQkFBc0I7SUFDdEJpQixRQUFRO1FBQ047WUFDRUMsU0FBUztZQUNUQyxRQUFRO1lBQ1JDLE1BQU07WUFDTkMsVUFBVTtZQUNWQyxjQUFjO1lBQ2RDLGNBQWM7WUFDZEMsVUFBVTtRQUNaO1FBQ0E7WUFDRU4sU0FBU2xCLG1EQUFXQTtZQUNwQm1CLFFBQVE7WUFDUkMsTUFBTTtZQUNOQyxVQUFVO1lBQ1ZDLGNBQWM7WUFDZEMsY0FBYztRQUNoQjtRQUNBO1lBQ0VMLFNBQVNqQixrREFBVUE7WUFDbkJrQixRQUFRO1lBQ1JDLE1BQU07WUFDTkMsVUFBVTtZQUNWQyxjQUFjO1lBQ2RDLGNBQWM7UUFDaEI7UUFDQTtZQUNFTCxTQUFTaEIsbURBQVdBO1lBQ3BCaUIsUUFBUTtZQUNSQyxNQUFNO1lBQ05DLFVBQVU7WUFDVkMsY0FBYztZQUNkQyxjQUFjO1FBQ2hCO1FBQ0E7WUFDRUwsU0FBU2YsbURBQVdBO1lBQ3BCZ0IsUUFBUTtZQUNSQyxNQUFNO1lBQ05DLFVBQVU7WUFDVkMsY0FBYztZQUNkQyxjQUFjO1FBQ2hCO0tBQ0Q7QUFDSCxFQUFXO0FBRVgsd0JBQXdCO0FBQ2pCLE1BQU1FLGlCQUFpQjtJQUM1QkMsU0FBU3RCLE9BQU9LLFFBQVE7SUFDeEJrQixXQUFXO0lBQ1hDLGdCQUFnQjtRQUNkUixNQUFNO1FBQ05ELFFBQVE7UUFDUkUsVUFBVTtJQUNaO0lBQ0FRLFNBQVM7UUFBQ3pCLE9BQU9DLE9BQU87S0FBQztJQUN6QnlCLG1CQUFtQjtBQUNyQixFQUFFO0FBRUYsbUJBQW1CO0FBQ1osU0FBU0Msa0JBQWtCYixPQUFlO0lBQy9DLE9BQU9kLE9BQU9hLE1BQU0sQ0FBQ2UsSUFBSSxDQUFDQyxDQUFBQSxRQUN4QkEsTUFBTWYsT0FBTyxDQUFDZ0IsV0FBVyxPQUFPaEIsUUFBUWdCLFdBQVc7QUFFdkQ7QUFFTyxTQUFTQyxpQkFBaUJoQixNQUFjO0lBQzdDLE9BQU9mLE9BQU9hLE1BQU0sQ0FBQ2UsSUFBSSxDQUFDQyxDQUFBQSxRQUN4QkEsTUFBTWQsTUFBTSxDQUFDZSxXQUFXLE9BQU9mLE9BQU9lLFdBQVc7QUFFckQ7QUFFTyxTQUFTRSxrQkFBa0JsQixPQUFlO0lBQy9DLE1BQU1lLFFBQVFGLGtCQUFrQmI7SUFDaEMsT0FBT2UsQ0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPWCxZQUFZLEtBQUk7QUFDaEM7QUFFTyxTQUFTZSxrQkFBa0JuQixPQUFlO0lBQy9DLE1BQU1lLFFBQVFGLGtCQUFrQmI7SUFDaEMsT0FBT2UsQ0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPVixZQUFZLEtBQUk7QUFDaEMiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxzcmNcXGNvbmZpZ1xcY29udHJhY3RzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFxuICBMZW5kaW5nUG9vbEFkZHJlc3MsIFxuICBQcmljZU9yYWNsZUFkZHJlc3MsIFxuICBXRVRIQWRkcmVzcywgXG4gIERBSUFkZHJlc3MsIFxuICBVU0RDQWRkcmVzcywgXG4gIExJTktBZGRyZXNzIFxufSBmcm9tICcuLi9hZGRyZXNzZXMnO1xuXG4vLyBDb250cmFjdCBjb25maWd1cmF0aW9uIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzXG5leHBvcnQgY29uc3QgQ09ORklHID0ge1xuICBSUENfVVJMOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19SUENfVVJMIHx8ICdodHRwOi8vMTI3LjAuMC4xOjc1NDUnLFxuICBDSEFJTl9JRDogcGFyc2VJbnQocHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQ0hBSU5fSUQgfHwgJzEzMzcnLCAxMCksIC8vIDEzMzdcbiAgQ0hBSU5fSURfSEVYOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19DSEFJTl9JRF9IRVggfHwgJzB4NTM5JyxcbiAgXG4gIC8vIENvbnRyYWN0IGFkZHJlc3NlcyAoYXV0by1pbXBvcnRlZCBmcm9tIGFkZHJlc3Nlcy5qcylcbiAgTEVORElOR19QT09MOiBMZW5kaW5nUG9vbEFkZHJlc3MsXG4gIFBSSUNFX09SQUNMRTogUHJpY2VPcmFjbGVBZGRyZXNzLFxuICBXRVRIOiBXRVRIQWRkcmVzcyxcbiAgXG4gIC8vIFRva2VuIGNvbmZpZ3VyYXRpb25cbiAgVE9LRU5TOiBbXG4gICAge1xuICAgICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsIC8vIEVUSCBuYXRpdmUgdG9rZW5cbiAgICAgIHN5bWJvbDogJ0VUSCcsXG4gICAgICBuYW1lOiAnRXRoZXJldW0nLFxuICAgICAgZGVjaW1hbHM6IDE4LFxuICAgICAgaXNCb3Jyb3dhYmxlOiBmYWxzZSxcbiAgICAgIGlzQ29sbGF0ZXJhbDogZmFsc2UsXG4gICAgICBpc05hdGl2ZTogdHJ1ZSxcbiAgICB9LFxuICAgIHtcbiAgICAgIGFkZHJlc3M6IFdFVEhBZGRyZXNzLCAvLyBBdXRvLWltcG9ydGVkIGZyb20gYWRkcmVzc2VzLmpzXG4gICAgICBzeW1ib2w6ICdXRVRIJyxcbiAgICAgIG5hbWU6ICdXcmFwcGVkIEV0aGVyZXVtJyxcbiAgICAgIGRlY2ltYWxzOiAxOCxcbiAgICAgIGlzQm9ycm93YWJsZTogZmFsc2UsXG4gICAgICBpc0NvbGxhdGVyYWw6IHRydWUsXG4gICAgfSxcbiAgICB7XG4gICAgICBhZGRyZXNzOiBEQUlBZGRyZXNzLCAvLyBBdXRvLWltcG9ydGVkIGZyb20gYWRkcmVzc2VzLmpzXG4gICAgICBzeW1ib2w6ICdEQUknLFxuICAgICAgbmFtZTogJ0RhaSBTdGFibGVjb2luJyxcbiAgICAgIGRlY2ltYWxzOiAxOCxcbiAgICAgIGlzQm9ycm93YWJsZTogdHJ1ZSxcbiAgICAgIGlzQ29sbGF0ZXJhbDogZmFsc2UsXG4gICAgfSxcbiAgICB7XG4gICAgICBhZGRyZXNzOiBVU0RDQWRkcmVzcywgLy8gQXV0by1pbXBvcnRlZCBmcm9tIGFkZHJlc3Nlcy5qc1xuICAgICAgc3ltYm9sOiAnVVNEQycsXG4gICAgICBuYW1lOiAnVVNEIENvaW4nLFxuICAgICAgZGVjaW1hbHM6IDYsXG4gICAgICBpc0JvcnJvd2FibGU6IHRydWUsXG4gICAgICBpc0NvbGxhdGVyYWw6IGZhbHNlLFxuICAgIH0sXG4gICAge1xuICAgICAgYWRkcmVzczogTElOS0FkZHJlc3MsIC8vIEF1dG8taW1wb3J0ZWQgZnJvbSBhZGRyZXNzZXMuanNcbiAgICAgIHN5bWJvbDogJ0xJTksnLFxuICAgICAgbmFtZTogJ0NoYWlubGluaycsXG4gICAgICBkZWNpbWFsczogMTgsXG4gICAgICBpc0JvcnJvd2FibGU6IHRydWUsXG4gICAgICBpc0NvbGxhdGVyYWw6IGZhbHNlLFxuICAgIH0sXG4gIF0sXG59IGFzIGNvbnN0O1xuXG4vLyBOZXR3b3JrIGNvbmZpZ3VyYXRpb25cbmV4cG9ydCBjb25zdCBORVRXT1JLX0NPTkZJRyA9IHtcbiAgY2hhaW5JZDogQ09ORklHLkNIQUlOX0lELFxuICBjaGFpbk5hbWU6ICdHYW5hY2hlIExvY2FsJyxcbiAgbmF0aXZlQ3VycmVuY3k6IHtcbiAgICBuYW1lOiAnRXRoZXJldW0nLFxuICAgIHN5bWJvbDogJ0VUSCcsXG4gICAgZGVjaW1hbHM6IDE4LFxuICB9LFxuICBycGNVcmxzOiBbQ09ORklHLlJQQ19VUkxdLFxuICBibG9ja0V4cGxvcmVyVXJsczogbnVsbCxcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiBnZXRUb2tlbkJ5QWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpIHtcbiAgcmV0dXJuIENPTkZJRy5UT0tFTlMuZmluZCh0b2tlbiA9PiBcbiAgICB0b2tlbi5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9rZW5CeVN5bWJvbChzeW1ib2w6IHN0cmluZykge1xuICByZXR1cm4gQ09ORklHLlRPS0VOUy5maW5kKHRva2VuID0+IFxuICAgIHRva2VuLnN5bWJvbC50b0xvd2VyQ2FzZSgpID09PSBzeW1ib2wudG9Mb3dlckNhc2UoKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUb2tlbkJvcnJvd2FibGUoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IHRva2VuID0gZ2V0VG9rZW5CeUFkZHJlc3MoYWRkcmVzcyk7XG4gIHJldHVybiB0b2tlbj8uaXNCb3Jyb3dhYmxlIHx8IGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUb2tlbkNvbGxhdGVyYWwoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IHRva2VuID0gZ2V0VG9rZW5CeUFkZHJlc3MoYWRkcmVzcyk7XG4gIHJldHVybiB0b2tlbj8uaXNDb2xsYXRlcmFsIHx8IGZhbHNlO1xufVxuIl0sIm5hbWVzIjpbIkxlbmRpbmdQb29sQWRkcmVzcyIsIlByaWNlT3JhY2xlQWRkcmVzcyIsIldFVEhBZGRyZXNzIiwiREFJQWRkcmVzcyIsIlVTRENBZGRyZXNzIiwiTElOS0FkZHJlc3MiLCJDT05GSUciLCJSUENfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1JQQ19VUkwiLCJDSEFJTl9JRCIsInBhcnNlSW50IiwiTkVYVF9QVUJMSUNfQ0hBSU5fSUQiLCJDSEFJTl9JRF9IRVgiLCJORVhUX1BVQkxJQ19DSEFJTl9JRF9IRVgiLCJMRU5ESU5HX1BPT0wiLCJQUklDRV9PUkFDTEUiLCJXRVRIIiwiVE9LRU5TIiwiYWRkcmVzcyIsInN5bWJvbCIsIm5hbWUiLCJkZWNpbWFscyIsImlzQm9ycm93YWJsZSIsImlzQ29sbGF0ZXJhbCIsImlzTmF0aXZlIiwiTkVUV09SS19DT05GSUciLCJjaGFpbklkIiwiY2hhaW5OYW1lIiwibmF0aXZlQ3VycmVuY3kiLCJycGNVcmxzIiwiYmxvY2tFeHBsb3JlclVybHMiLCJnZXRUb2tlbkJ5QWRkcmVzcyIsImZpbmQiLCJ0b2tlbiIsInRvTG93ZXJDYXNlIiwiZ2V0VG9rZW5CeVN5bWJvbCIsImlzVG9rZW5Cb3Jyb3dhYmxlIiwiaXNUb2tlbkNvbGxhdGVyYWwiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/config/contracts.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/context/LendState.js":
/*!**********************************!*\
  !*** ./src/context/LendState.js ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lendContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lendContext */ \"(pages-dir-browser)/./src/context/lendContext.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _config_contracts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config/contracts */ \"(pages-dir-browser)/./src/config/contracts.ts\");\n/* harmony import */ var _lib_tx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/tx */ \"(pages-dir-browser)/./src/lib/tx.ts\");\n/* harmony import */ var _addresses__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../addresses */ \"(pages-dir-browser)/./src/addresses.js\");\n/* harmony import */ var _abis__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../abis */ \"(pages-dir-browser)/./src/abis/index.js\");\n/* harmony import */ var _abis__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_abis__WEBPACK_IMPORTED_MODULE_6__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n// Utility functions\nconst numberToEthers = (number)=>{\n    return ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseEther(number.toString());\n};\nconst reportError = (error)=>{\n    console.error(\"LendState Error:\", JSON.stringify(error));\n    console.error(\"Error details:\", error);\n};\nconst LendState = (props)=>{\n    _s();\n    //* Declaring all the states\n    // Set metamask details\n    const [metamaskDetails, setMetamaskDetails] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        provider: null,\n        networkName: null,\n        signer: null,\n        currentAccount: null,\n        chainId: null\n    });\n    // User assets and balances\n    const [userAssets, setUserAssets] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [supplyAssets, setSupplyAssets] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [assetsToBorrow, setAssetsToBorrow] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [yourBorrows, setYourBorrows] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Contract details\n    const [contract, setContract] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        lendingPoolContract: null,\n        oracleContract: null\n    });\n    // Summary data\n    const [supplySummary, setSupplySummary] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        totalUSDBalance: 0,\n        weightedAvgAPY: 0,\n        totalUSDCollateral: 0\n    });\n    const [borrowSummary, setBorrowSummary] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        totalUSDBalance: 0,\n        weightedAvgAPY: 0,\n        totalBorrowPowerUsed: 0\n    });\n    // Account data\n    const [accountData, setAccountData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        collateralUSD: \"0\",\n        debtUSD: \"0\",\n        healthFactor: \"0\"\n    });\n    // Connect wallet\n    // const connectWallet = useCallback(async () => {\n    //   console.log(\"1. Connecting to wallet...\");\n    //   const { ethereum } = window;\n    //   const failMessage = \"Please install Metamask & connect your Metamask\";\n    //   try {\n    //     if (!ethereum) {\n    //       alert(failMessage);\n    //       return;\n    //     }\n    //     const accounts = await ethereum.request({\n    //       method: \"eth_requestAccounts\",\n    //     });\n    //     // Listen for account and chain changes\n    //     ethereum.on(\"chainChanged\", () => {\n    //       window.location.reload();\n    //     });\n    //     ethereum.on(\"accountsChanged\", () => {\n    //       window.location.reload();\n    //     });\n    //     const provider = new ethers.BrowserProvider(ethereum);\n    //     const network = await provider.getNetwork();\n    //     const networkName = network.name;\n    //     const signer = await provider.getSigner();\n    //     if (accounts.length) {\n    //       let currentAddress = accounts[0];\n    //       setMetamaskDetails({\n    //         provider: provider,\n    //         networkName: networkName,\n    //         signer: signer,\n    //         currentAccount: currentAddress,\n    //         chainId: Number(network.chainId),\n    //       });\n    //       console.log(\"Connected to wallet:\", currentAddress);\n    //     } else {\n    //       alert(failMessage);\n    //       return;\n    //     }\n    //   } catch (error) {\n    //     reportError(error);\n    //   }\n    // }, []);\n    const connectWallet = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[connectWallet]\": async ()=>{\n            console.log(\"1. Connecting to wallet...\");\n            const { ethereum } = window;\n            const failMessage = \"Please install Metamask & connect your Metamask\";\n            try {\n                if (!ethereum) {\n                    alert(failMessage);\n                    return;\n                }\n                const accounts = await ethereum.request({\n                    method: \"eth_requestAccounts\"\n                });\n                // Listen for account and chain changes\n                ethereum.on(\"chainChanged\", {\n                    \"LendState.useCallback[connectWallet]\": ()=>{\n                        window.location.reload();\n                    }\n                }[\"LendState.useCallback[connectWallet]\"]);\n                ethereum.on(\"accountsChanged\", {\n                    \"LendState.useCallback[connectWallet]\": ()=>{\n                        window.location.reload();\n                    }\n                }[\"LendState.useCallback[connectWallet]\"]);\n                const provider = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.BrowserProvider(ethereum);\n                const network = await provider.getNetwork();\n                const networkName = network.name;\n                const signer = await provider.getSigner();\n                if (accounts.length) {\n                    let currentAddress = accounts[0];\n                    setMetamaskDetails({\n                        provider: provider,\n                        networkName: networkName,\n                        signer: signer,\n                        currentAccount: currentAddress,\n                        chainId: Number(network.chainId)\n                    });\n                    console.log(\"Connected to wallet++++++++++++++++++++++++++++++++++:\", currentAddress);\n                } else {\n                    alert(failMessage);\n                    return;\n                }\n            } catch (error) {\n                reportError(error);\n            }\n        }\n    }[\"LendState.useCallback[connectWallet]\"], []);\n    // Get contract instance\n    const getContract = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getContract]\": async (address, abi)=>{\n            if (!metamaskDetails.provider) return null;\n            const contract = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(address, abi, metamaskDetails.provider);\n            return contract;\n        }\n    }[\"LendState.useCallback[getContract]\"], [\n        metamaskDetails.provider\n    ]);\n    // Get user assets (balances)\n    const getUserAssets = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getUserAssets]\": async ()=>{\n            console.log(\"2. Getting user assets...\");\n            try {\n                if (!metamaskDetails.provider || !metamaskDetails.currentAccount) return [];\n                const assets = await Promise.all(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.map({\n                    \"LendState.useCallback[getUserAssets]\": async (token)=>{\n                        let balance = \"0\";\n                        let balanceUSD = 0;\n                        try {\n                            if (token.isNative) {\n                                // ETH native balance\n                                const bal = await metamaskDetails.provider.getBalance(metamaskDetails.currentAccount);\n                                balance = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatEther(bal);\n                            } else {\n                                // ERC20 token balance\n                                balance = await (0,_lib_tx__WEBPACK_IMPORTED_MODULE_4__.getTokenBalance)(metamaskDetails.provider, token.address, metamaskDetails.currentAccount, token.decimals);\n                            }\n                            // Get USD value\n                            const price = await getPriceUSD(token.address);\n                            balanceUSD = parseFloat(balance) * parseFloat(price);\n                            return {\n                                address: token.address,\n                                symbol: token.symbol,\n                                name: token.name,\n                                decimals: token.decimals,\n                                isNative: token.isNative,\n                                balance: balance,\n                                balanceUSD: balanceUSD,\n                                priceUSD: price\n                            };\n                        } catch (error) {\n                            console.warn(\"Error getting balance for \".concat(token.symbol, \":\"), error);\n                            return {\n                                address: token.address,\n                                symbol: token.symbol,\n                                name: token.name,\n                                decimals: token.decimals,\n                                isNative: token.isNative,\n                                balance: \"0\",\n                                balanceUSD: 0,\n                                priceUSD: \"0\"\n                            };\n                        }\n                    }\n                }[\"LendState.useCallback[getUserAssets]\"]));\n                setUserAssets(assets);\n                console.log(\"Got user assets:\", assets);\n                return assets;\n            } catch (error) {\n                reportError(error);\n                return [];\n            }\n        }\n    }[\"LendState.useCallback[getUserAssets]\"], [\n        metamaskDetails.provider,\n        metamaskDetails.currentAccount\n    ]);\n    // Get price in USD\n    const getPriceUSD = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getPriceUSD]\": async (asset)=>{\n            if (!metamaskDetails.provider) return \"0\";\n            try {\n                const abi = [\n                    'function getAssetPrice1e18(address asset) view returns (uint256)'\n                ];\n                const oracle = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.PRICE_ORACLE, abi, metamaskDetails.provider);\n                const price = await oracle.getAssetPrice1e18(asset);\n                return ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(price, 18);\n            } catch (error) {\n                console.warn(\"Error getting price for \".concat(asset, \":\"), error);\n                return \"0\";\n            }\n        }\n    }[\"LendState.useCallback[getPriceUSD]\"], [\n        metamaskDetails.provider\n    ]);\n    // Get amount in USD\n    const getAmountInUSD = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getAmountInUSD]\": async (address, amount)=>{\n            try {\n                const price = await getPriceUSD(address);\n                const amountInUSD = parseFloat(amount) * parseFloat(price);\n                return amountInUSD;\n            } catch (error) {\n                reportError(error);\n                return 0;\n            }\n        }\n    }[\"LendState.useCallback[getAmountInUSD]\"], [\n        getPriceUSD\n    ]);\n    // Approve tokens\n    const ApproveToContinue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[ApproveToContinue]\": async (tokenAddress, approveAmount)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const token = _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.find({\n                    \"LendState.useCallback[ApproveToContinue].token\": (t)=>t.address.toLowerCase() === tokenAddress.toLowerCase()\n                }[\"LendState.useCallback[ApproveToContinue].token\"]);\n                if (!token) throw new Error(\"Token not found\");\n                await (0,_lib_tx__WEBPACK_IMPORTED_MODULE_4__.approveIfNeeded)(metamaskDetails.signer, tokenAddress, _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.LENDING_POOL, approveAmount, token.decimals);\n                console.log(\"Token approved:\", tokenAddress);\n                return {\n                    status: 200,\n                    message: \"Transaction Successful...\"\n                };\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[ApproveToContinue]\"], [\n        metamaskDetails.signer\n    ]);\n    // Lend asset\n    const LendAsset = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[LendAsset]\": async (token, supplyAmount)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const tokenInfo = _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.find({\n                    \"LendState.useCallback[LendAsset].tokenInfo\": (t)=>t.address.toLowerCase() === token.toLowerCase()\n                }[\"LendState.useCallback[LendAsset].tokenInfo\"]);\n                if (!tokenInfo) throw new Error(\"Token not found\");\n                const amount = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(supplyAmount, tokenInfo.decimals);\n                const tx = await (0,_lib_tx__WEBPACK_IMPORTED_MODULE_4__.lend)(metamaskDetails.signer, token, amount);\n                if (tx) {\n                    console.log(\"Asset lent successfully:\", token, supplyAmount);\n                    return {\n                        status: 200,\n                        message: \"Transaction Successful...\",\n                        hash: tx.hash\n                    };\n                }\n                throw new Error(\"Transaction failed\");\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[LendAsset]\"], [\n        metamaskDetails.signer\n    ]);\n    // Withdraw asset\n    const WithdrawAsset = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[WithdrawAsset]\": async (tokenAddress, withdrawAmount)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const tokenInfo = _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.find({\n                    \"LendState.useCallback[WithdrawAsset].tokenInfo\": (t)=>t.address.toLowerCase() === tokenAddress.toLowerCase()\n                }[\"LendState.useCallback[WithdrawAsset].tokenInfo\"]);\n                if (!tokenInfo) throw new Error(\"Token not found\");\n                const amount = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(withdrawAmount, tokenInfo.decimals);\n                const tx = await (0,_lib_tx__WEBPACK_IMPORTED_MODULE_4__.withdraw)(metamaskDetails.signer, tokenAddress, amount);\n                if (tx) {\n                    console.log(\"Asset withdrawn successfully:\", tokenAddress, withdrawAmount);\n                    return {\n                        status: 200,\n                        message: \"Transaction Successful...\",\n                        hash: tx.hash\n                    };\n                }\n                throw new Error(\"Transaction failed\");\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[WithdrawAsset]\"], [\n        metamaskDetails.signer\n    ]);\n    // Borrow asset\n    const borrowAsset = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[borrowAsset]\": async (token, borrowAmount)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const tokenInfo = _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.find({\n                    \"LendState.useCallback[borrowAsset].tokenInfo\": (t)=>t.address.toLowerCase() === token.toLowerCase()\n                }[\"LendState.useCallback[borrowAsset].tokenInfo\"]);\n                if (!tokenInfo) throw new Error(\"Token not found\");\n                const amount = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(borrowAmount, tokenInfo.decimals);\n                const tx = await (0,_lib_tx__WEBPACK_IMPORTED_MODULE_4__.borrow)(metamaskDetails.signer, token, amount);\n                if (tx) {\n                    console.log(\"Asset borrowed successfully:\", token, borrowAmount);\n                    return {\n                        status: 200,\n                        message: \"Transaction Successful...\",\n                        hash: tx.hash\n                    };\n                }\n                throw new Error(\"Transaction failed\");\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[borrowAsset]\"], [\n        metamaskDetails.signer\n    ]);\n    // Repay asset\n    const repayAsset = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[repayAsset]\": async (tokenAddress, repayAmount)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const tokenInfo = _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.find({\n                    \"LendState.useCallback[repayAsset].tokenInfo\": (t)=>t.address.toLowerCase() === tokenAddress.toLowerCase()\n                }[\"LendState.useCallback[repayAsset].tokenInfo\"]);\n                if (!tokenInfo) throw new Error(\"Token not found\");\n                const amount = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(repayAmount, tokenInfo.decimals);\n                const tx = await (0,_lib_tx__WEBPACK_IMPORTED_MODULE_4__.repay)(metamaskDetails.signer, tokenAddress, amount);\n                if (tx) {\n                    console.log(\"Asset repaid successfully:\", tokenAddress, repayAmount);\n                    return {\n                        status: 200,\n                        message: \"Transaction Successful...\",\n                        hash: tx.hash\n                    };\n                }\n                throw new Error(\"Transaction failed\");\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[repayAsset]\"], [\n        metamaskDetails.signer\n    ]);\n    // Get account data (collateral, debt, health factor)\n    const getAccountData = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getAccountData]\": async (user)=>{\n            try {\n                if (!metamaskDetails.provider) return null;\n                const pool = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_addresses__WEBPACK_IMPORTED_MODULE_5__.LendingPoolAddress, _abis__WEBPACK_IMPORTED_MODULE_6__.LendingPoolABI.abi, metamaskDetails.provider);\n                const wallet = user || metamaskDetails.currentAccount || ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.ZeroAddress;\n                // Add error handling for empty response\n                let col, debt, hf;\n                try {\n                    [col, debt, hf] = await pool.getAccountData(wallet);\n                } catch (contractError) {\n                    console.log('Contract getAccountData failed, using defaults:', contractError.message);\n                    // Return default values for new users\n                    col = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(\"0\", 18);\n                    debt = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(\"0\", 18);\n                    hf = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(\"115792089237316195423570985008687907853269984665640564039457.584007913129639935\", 18); // Max uint256\n                }\n                const accountData = {\n                    collateralUSD: ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(col, 18),\n                    debtUSD: ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(debt, 18),\n                    healthFactor: ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(hf, 18)\n                };\n                setAccountData(accountData);\n                return accountData;\n            } catch (error) {\n                console.log('getAccountData error, using defaults:', error.message);\n                // Return default values on any error\n                const accountData = {\n                    collateralUSD: \"0\",\n                    debtUSD: \"0\",\n                    healthFactor: \"115792089237316195423570985008687907853269984665640564039457.584007913129639935\"\n                };\n                setAccountData(accountData);\n                return accountData;\n            }\n        }\n    }[\"LendState.useCallback[getAccountData]\"], [\n        metamaskDetails.provider,\n        metamaskDetails.currentAccount\n    ]);\n    // Get your supplies\n    const getYourSupplies = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getYourSupplies]\": async ()=>{\n            console.log(\"3. Getting your supplies...\");\n            try {\n                if (!metamaskDetails.provider || !metamaskDetails.currentAccount) return [];\n                const abi = [\n                    'function getUserReserve(address user, address asset) view returns (tuple(uint128 principal,uint128 index) supply, tuple(uint128 principal,uint128 index) borrow)'\n                ];\n                const pool = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.LENDING_POOL, abi, metamaskDetails.provider);\n                const supplies = await Promise.all(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.filter({\n                    \"LendState.useCallback[getYourSupplies]\": (t)=>!t.isNative\n                }[\"LendState.useCallback[getYourSupplies]\"]).map({\n                    \"LendState.useCallback[getYourSupplies]\": async (token)=>{\n                        try {\n                            const userReserve = await pool.getUserReserve(metamaskDetails.currentAccount, token.address);\n                            const supplyPrincipal = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(userReserve.supply.principal, 18);\n                            const supplyIndex = userReserve.supply.index.toString();\n                            if (parseFloat(supplyPrincipal) > 0) {\n                                const price = await getPriceUSD(token.address);\n                                const balanceUSD = parseFloat(supplyPrincipal) * parseFloat(price);\n                                return {\n                                    address: token.address,\n                                    symbol: token.symbol,\n                                    name: token.name,\n                                    decimals: token.decimals,\n                                    supplyPrincipal: supplyPrincipal,\n                                    supplyIndex: supplyIndex,\n                                    balanceUSD: balanceUSD,\n                                    priceUSD: price\n                                };\n                            }\n                            return null;\n                        } catch (error) {\n                            console.warn(\"Error getting supply for \".concat(token.symbol, \":\"), error);\n                            return null;\n                        }\n                    }\n                }[\"LendState.useCallback[getYourSupplies]\"]));\n                const validSupplies = supplies.filter({\n                    \"LendState.useCallback[getYourSupplies].validSupplies\": (s)=>s !== null\n                }[\"LendState.useCallback[getYourSupplies].validSupplies\"]);\n                setSupplyAssets(validSupplies);\n                // Calculate summary\n                const totalUSDBalance = validSupplies.reduce({\n                    \"LendState.useCallback[getYourSupplies].totalUSDBalance\": (sum, asset)=>sum + asset.balanceUSD\n                }[\"LendState.useCallback[getYourSupplies].totalUSDBalance\"], 0);\n                const weightedAvgAPY = validSupplies.length > 0 ? validSupplies.reduce({\n                    \"LendState.useCallback[getYourSupplies]\": (sum, asset)=>sum + (asset.apy || 0)\n                }[\"LendState.useCallback[getYourSupplies]\"], 0) / validSupplies.length : 0;\n                const totalUSDCollateral = validSupplies.reduce({\n                    \"LendState.useCallback[getYourSupplies].totalUSDCollateral\": (sum, asset)=>sum + asset.balanceUSD\n                }[\"LendState.useCallback[getYourSupplies].totalUSDCollateral\"], 0);\n                setSupplySummary({\n                    totalUSDBalance,\n                    weightedAvgAPY,\n                    totalUSDCollateral\n                });\n                console.log(\"Got your supplies:\", validSupplies);\n                return validSupplies;\n            } catch (error) {\n                reportError(error);\n                return [];\n            }\n        }\n    }[\"LendState.useCallback[getYourSupplies]\"], [\n        metamaskDetails.provider,\n        metamaskDetails.currentAccount,\n        getPriceUSD\n    ]);\n    // Get your borrows\n    const getYourBorrows = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getYourBorrows]\": async ()=>{\n            console.log(\"4. Getting your borrows...\");\n            try {\n                if (!metamaskDetails.provider || !metamaskDetails.currentAccount) return [];\n                const abi = [\n                    'function getUserReserve(address user, address asset) view returns (tuple(uint128 principal,uint128 index) supply, tuple(uint128 principal,uint128 index) borrow)'\n                ];\n                const pool = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.LENDING_POOL, abi, metamaskDetails.provider);\n                const borrows = await Promise.all(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.filter({\n                    \"LendState.useCallback[getYourBorrows]\": (t)=>!t.isNative\n                }[\"LendState.useCallback[getYourBorrows]\"]).map({\n                    \"LendState.useCallback[getYourBorrows]\": async (token)=>{\n                        try {\n                            const userReserve = await pool.getUserReserve(metamaskDetails.currentAccount, token.address);\n                            const borrowPrincipal = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(userReserve.borrow.principal, 18);\n                            const borrowIndex = userReserve.borrow.index.toString();\n                            if (parseFloat(borrowPrincipal) > 0) {\n                                const price = await getPriceUSD(token.address);\n                                const balanceUSD = parseFloat(borrowPrincipal) * parseFloat(price);\n                                return {\n                                    address: token.address,\n                                    symbol: token.symbol,\n                                    name: token.name,\n                                    decimals: token.decimals,\n                                    borrowPrincipal: borrowPrincipal,\n                                    borrowIndex: borrowIndex,\n                                    balanceUSD: balanceUSD,\n                                    priceUSD: price\n                                };\n                            }\n                            return null;\n                        } catch (error) {\n                            console.warn(\"Error getting borrow for \".concat(token.symbol, \":\"), error);\n                            return null;\n                        }\n                    }\n                }[\"LendState.useCallback[getYourBorrows]\"]));\n                const validBorrows = borrows.filter({\n                    \"LendState.useCallback[getYourBorrows].validBorrows\": (b)=>b !== null\n                }[\"LendState.useCallback[getYourBorrows].validBorrows\"]);\n                setYourBorrows(validBorrows);\n                // Calculate summary\n                const totalUSDBalance = validBorrows.reduce({\n                    \"LendState.useCallback[getYourBorrows].totalUSDBalance\": (sum, asset)=>sum + asset.balanceUSD\n                }[\"LendState.useCallback[getYourBorrows].totalUSDBalance\"], 0);\n                const weightedAvgAPY = validBorrows.length > 0 ? validBorrows.reduce({\n                    \"LendState.useCallback[getYourBorrows]\": (sum, asset)=>sum + (asset.apy || 0)\n                }[\"LendState.useCallback[getYourBorrows]\"], 0) / validBorrows.length : 0;\n                const totalBorrowPowerUsed = totalUSDBalance;\n                setBorrowSummary({\n                    totalUSDBalance,\n                    weightedAvgAPY,\n                    totalBorrowPowerUsed\n                });\n                console.log(\"Got your borrows:\", validBorrows);\n                return validBorrows;\n            } catch (error) {\n                reportError(error);\n                return [];\n            }\n        }\n    }[\"LendState.useCallback[getYourBorrows]\"], [\n        metamaskDetails.provider,\n        metamaskDetails.currentAccount,\n        getPriceUSD\n    ]);\n    // Get assets to borrow\n    const getAssetsToBorrow = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getAssetsToBorrow]\": async ()=>{\n            console.log(\"5. Getting assets to borrow...\");\n            try {\n                if (!metamaskDetails.provider) return [];\n                const abi = [\n                    'function reserves(address) view returns (uint128 reserveCash, uint128 totalDebtPrincipal, uint128 liquidityIndex, uint128 variableBorrowIndex, uint64 liquidityRateRayPerSec, uint64 variableBorrowRateRayPerSec, uint16 reserveFactorBps, uint16 ltvBps, uint16 liqThresholdBps, uint16 liqBonusBps, uint16 closeFactorBps, uint8 decimals, bool isBorrowable, uint16 optimalUBps, uint64 baseRateRayPerSec, uint64 slope1RayPerSec, uint64 slope2RayPerSec, uint40 lastUpdate)'\n                ];\n                const pool = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.LENDING_POOL, abi, metamaskDetails.provider);\n                const assets = await Promise.all(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.filter({\n                    \"LendState.useCallback[getAssetsToBorrow]\": (t)=>!t.isNative\n                }[\"LendState.useCallback[getAssetsToBorrow]\"]).map({\n                    \"LendState.useCallback[getAssetsToBorrow]\": async (token)=>{\n                        try {\n                            const reserve = await pool.reserves(token.address);\n                            const isBorrowable = Boolean(reserve.isBorrowable);\n                            const reserveCash = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(reserve.reserveCash, 18);\n                            const price = await getPriceUSD(token.address);\n                            if (isBorrowable && parseFloat(reserveCash) > 0) {\n                                return {\n                                    address: token.address,\n                                    symbol: token.symbol,\n                                    name: token.name,\n                                    decimals: token.decimals,\n                                    reserveCash: reserveCash,\n                                    isBorrowable: isBorrowable,\n                                    priceUSD: price,\n                                    ltvBps: Number(reserve.ltvBps),\n                                    liqThresholdBps: Number(reserve.liqThresholdBps)\n                                };\n                            }\n                            return null;\n                        } catch (error) {\n                            console.warn(\"Error getting borrow asset \".concat(token.symbol, \":\"), error);\n                            return null;\n                        }\n                    }\n                }[\"LendState.useCallback[getAssetsToBorrow]\"]));\n                const validAssets = assets.filter({\n                    \"LendState.useCallback[getAssetsToBorrow].validAssets\": (a)=>a !== null\n                }[\"LendState.useCallback[getAssetsToBorrow].validAssets\"]);\n                setAssetsToBorrow(validAssets);\n                console.log(\"Got assets to borrow:\", validAssets);\n                return validAssets;\n            } catch (error) {\n                reportError(error);\n                return [];\n            }\n        }\n    }[\"LendState.useCallback[getAssetsToBorrow]\"], [\n        metamaskDetails.provider,\n        getPriceUSD\n    ]);\n    // Wrap ETH to WETH\n    const wrapEth = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[wrapEth]\": async (amountEth)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const data = '0xd0e30db0'; // deposit()\n                console.log('wrapEth  using WETH address:', _addresses__WEBPACK_IMPORTED_MODULE_5__.WETHAddress);\n                const tx = await metamaskDetails.signer.sendTransaction({\n                    to: _addresses__WEBPACK_IMPORTED_MODULE_5__.WETHAddress,\n                    value: ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseEther(amountEth),\n                    data\n                });\n                await tx.wait();\n                console.log(\"ETH wrapped to WETH:\", amountEth);\n                return {\n                    status: 200,\n                    message: \"Transaction Successful...\",\n                    hash: tx.hash\n                };\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[wrapEth]\"], [\n        metamaskDetails.signer\n    ]);\n    // Unwrap WETH to ETH\n    const unwrapWeth = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[unwrapWeth]\": async (amountEth)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const abi = [\n                    'function withdraw(uint256 wad)'\n                ];\n                console.log('unwrapWeth  using WETH address:', _addresses__WEBPACK_IMPORTED_MODULE_5__.WETHAddress);\n                const weth = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_addresses__WEBPACK_IMPORTED_MODULE_5__.WETHAddress, abi, metamaskDetails.signer);\n                const tx = await weth.withdraw(ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseEther(amountEth));\n                await tx.wait();\n                console.log(\"WETH unwrapped to ETH:\", amountEth);\n                return {\n                    status: 200,\n                    message: \"Transaction Successful...\",\n                    hash: tx.hash\n                };\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[unwrapWeth]\"], [\n        metamaskDetails.signer\n    ]);\n    // Withdraw token to ETH (for all tokens with withdraw function)\n    const withdrawToken = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[withdrawToken]\": async (tokenAddress, amount)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const abi = [\n                    'function withdraw(uint256 amount)'\n                ];\n                console.log('withdrawToken  using address:', tokenAddress);\n                const token = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(tokenAddress, abi, metamaskDetails.signer);\n                const tx = await token.withdraw(ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseEther(amount));\n                await tx.wait();\n                console.log(\"Token withdrawn to ETH:\", amount);\n                return {\n                    status: 200,\n                    message: \"Withdraw Successful...\",\n                    hash: tx.hash\n                };\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[withdrawToken]\"], [\n        metamaskDetails.signer\n    ]);\n    // Deposit ETH to get token (for all tokens with deposit function)\n    const depositToToken = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[depositToToken]\": async (tokenAddress, amountEth)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const abi = [\n                    'function deposit() payable'\n                ];\n                console.log('depositToToken  using address:', tokenAddress);\n                const token = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(tokenAddress, abi, metamaskDetails.signer);\n                const tx = await token.deposit({\n                    value: ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseEther(amountEth)\n                });\n                await tx.wait();\n                console.log(\"ETH deposited to token:\", amountEth);\n                return {\n                    status: 200,\n                    message: \"Deposit Successful...\",\n                    hash: tx.hash\n                };\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[depositToToken]\"], [\n        metamaskDetails.signer\n    ]);\n    // Refresh all data\n    const refresh = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[refresh]\": async ()=>{\n            try {\n                await Promise.all([\n                    getUserAssets(),\n                    getYourSupplies(),\n                    getYourBorrows(),\n                    getAssetsToBorrow(),\n                    getAccountData()\n                ]);\n                console.log(\"All data refreshed\");\n            } catch (error) {\n                reportError(error);\n            }\n        }\n    }[\"LendState.useCallback[refresh]\"], [\n        getUserAssets,\n        getYourSupplies,\n        getYourBorrows,\n        getAssetsToBorrow,\n        getAccountData\n    ]);\n    // Update interests (accrue)\n    const updateInterests = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[updateInterests]\": async (asset)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const abi = [\n                    'function accruePublic(address asset)'\n                ];\n                const pool = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.LENDING_POOL, abi, metamaskDetails.signer);\n                const tx = await pool.accruePublic(asset);\n                await tx.wait();\n                console.log(\"Interests updated for asset:\", asset);\n                return {\n                    status: 200,\n                    message: \"Transaction Successful...\"\n                };\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[updateInterests]\"], [\n        metamaskDetails.signer\n    ]);\n    // Get user total available balance\n    const getUserTotalAvailableBalance = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getUserTotalAvailableBalance]\": async ()=>{\n            try {\n                if (!metamaskDetails.provider || !metamaskDetails.currentAccount) return 0;\n                const abi = [\n                    'function getUserTotalAvailableBalanceInUSD(address user, uint256 assetType) view returns (uint256)'\n                ];\n                const pool = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.LENDING_POOL, abi, metamaskDetails.provider);\n                const maxAmount = await pool.getUserTotalAvailableBalanceInUSD(metamaskDetails.currentAccount, 1);\n                return Number(ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(maxAmount, 18));\n            } catch (error) {\n                reportError(error);\n                return 0;\n            }\n        }\n    }[\"LendState.useCallback[getUserTotalAvailableBalance]\"], [\n        metamaskDetails.provider,\n        metamaskDetails.currentAccount\n    ]);\n    // Get tokens per USD amount\n    const getTokensPerUSDAmount = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getTokensPerUSDAmount]\": async (token, amount)=>{\n            try {\n                if (!metamaskDetails.provider) return 0;\n                const abi = [\n                    'function getTokensPerUSDAmount(address token, uint256 amount) view returns (uint256)'\n                ];\n                const helper = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.PRICE_ORACLE, abi, metamaskDetails.provider);\n                const maxQty = await helper.getTokensPerUSDAmount(token, ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(amount.toString(), 18));\n                return Number(ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(maxQty, 18));\n            } catch (error) {\n                reportError(error);\n                return 0;\n            }\n        }\n    }[\"LendState.useCallback[getTokensPerUSDAmount]\"], [\n        metamaskDetails.provider\n    ]);\n    // Objectify supplied assets (format data)\n    const objectifySuppliedAssets = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[objectifySuppliedAssets]\": async (assets)=>{\n            const assetsList = [];\n            for(let i = 0; i < assets.length; i++){\n                const token = assets[i].token;\n                let lendQty = assets[i].lentQty;\n                const amountInUSD = await getAmountInUSD(token, lendQty);\n                lendQty = Number(assets[i].lentQty) / 1e18;\n                const maxSupplyAmount = await getUserTotalAvailableBalance();\n                const maxQty = await getTokensPerUSDAmount(token, maxSupplyAmount);\n                const qty = lendQty <= maxQty ? lendQty : maxQty;\n                assetsList.push({\n                    token: assets[i].token,\n                    balance: lendQty,\n                    apy: Number(assets[i].lentApy),\n                    balanceInUSD: amountInUSD,\n                    maxSupply: qty\n                });\n            }\n            return assetsList;\n        }\n    }[\"LendState.useCallback[objectifySuppliedAssets]\"], [\n        getAmountInUSD,\n        getUserTotalAvailableBalance,\n        getTokensPerUSDAmount\n    ]);\n    // Objectify borrowed assets (format data)\n    const objectifyBorrowedAssets = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[objectifyBorrowedAssets]\": async (assets)=>{\n            const borrowsList = [];\n            for(let i = 0; i < assets.length; i++){\n                const token = assets[i].token;\n                const borrowQty = assets[i].borrowQty;\n                const borrowApy = assets[i].borrowApy;\n                const amountInUSD = await getAmountInUSD(token, borrowQty);\n                borrowsList.push({\n                    token: token,\n                    borrowQty: Number(borrowQty),\n                    borrowApy: Number(borrowApy),\n                    borrowedBalInUSD: amountInUSD\n                });\n            }\n            return borrowsList;\n        }\n    }[\"LendState.useCallback[objectifyBorrowedAssets]\"], [\n        getAmountInUSD\n    ]);\n    // Merge objectified assets with token info\n    const mergeObjectifiedAssets = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[mergeObjectifiedAssets]\": (assets)=>{\n            const result = _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.filter({\n                \"LendState.useCallback[mergeObjectifiedAssets].result\": (tokenList)=>{\n                    return assets.some({\n                        \"LendState.useCallback[mergeObjectifiedAssets].result\": (assetList)=>{\n                            return tokenList.address.toLowerCase() === assetList.token.toLowerCase();\n                        }\n                    }[\"LendState.useCallback[mergeObjectifiedAssets].result\"]);\n                }\n            }[\"LendState.useCallback[mergeObjectifiedAssets].result\"]).map({\n                \"LendState.useCallback[mergeObjectifiedAssets].result\": (assetObj)=>({\n                        ...assets.find({\n                            \"LendState.useCallback[mergeObjectifiedAssets].result\": (item)=>item.token.toLowerCase() === assetObj.address.toLowerCase()\n                        }[\"LendState.useCallback[mergeObjectifiedAssets].result\"]),\n                        ...assetObj\n                    })\n            }[\"LendState.useCallback[mergeObjectifiedAssets].result\"]);\n            return result;\n        }\n    }[\"LendState.useCallback[mergeObjectifiedAssets]\"], []);\n    // Context value\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"LendState.useMemo[contextValue]\": ()=>({\n                // State\n                metamaskDetails,\n                userAssets,\n                supplyAssets,\n                assetsToBorrow,\n                yourBorrows,\n                supplySummary,\n                borrowSummary,\n                accountData,\n                contract,\n                // Wallet functions\n                connectWallet,\n                refresh,\n                // Asset functions\n                getUserAssets,\n                getYourSupplies,\n                getYourBorrows,\n                getAssetsToBorrow,\n                // Transaction functions\n                ApproveToContinue,\n                LendAsset,\n                WithdrawAsset,\n                borrowAsset,\n                repayAsset,\n                // Utility functions\n                getContract,\n                getPriceUSD,\n                getAmountInUSD,\n                numberToEthers,\n                reportError,\n                // ETH/WETH functions\n                wrapEth,\n                unwrapWeth,\n                // Account functions\n                getAccountData,\n                getUserTotalAvailableBalance,\n                getTokensPerUSDAmount,\n                // Data processing functions\n                objectifySuppliedAssets,\n                objectifyBorrowedAssets,\n                mergeObjectifiedAssets,\n                // Interest functions\n                updateInterests,\n                // Token withdraw/deposit functions\n                withdrawToken,\n                depositToToken\n            })\n    }[\"LendState.useMemo[contextValue]\"], [\n        metamaskDetails,\n        userAssets,\n        supplyAssets,\n        assetsToBorrow,\n        yourBorrows,\n        supplySummary,\n        borrowSummary,\n        accountData,\n        contract,\n        connectWallet,\n        refresh,\n        getUserAssets,\n        getYourSupplies,\n        getYourBorrows,\n        getAssetsToBorrow,\n        ApproveToContinue,\n        LendAsset,\n        WithdrawAsset,\n        borrowAsset,\n        repayAsset,\n        getContract,\n        getPriceUSD,\n        getAmountInUSD,\n        wrapEth,\n        unwrapWeth,\n        getAccountData,\n        getUserTotalAvailableBalance,\n        getTokensPerUSDAmount,\n        objectifySuppliedAssets,\n        objectifyBorrowedAssets,\n        mergeObjectifiedAssets,\n        updateInterests\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lendContext__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Provider, {\n        value: contextValue,\n        children: props.children\n    }, void 0, false, {\n        fileName: \"D:\\\\Do_an2\\\\lendhub_v2\\\\lendhub-frontend-nextjs\\\\src\\\\context\\\\LendState.js\",\n        lineNumber: 898,\n        columnNumber: 5\n    }, undefined);\n};\n_s(LendState, \"VmZhE1ZTOhq434hcVdJavoagcY4=\");\n_c = LendState;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LendState);\nvar _c;\n$RefreshReg$(_c, \"LendState\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9jb250ZXh0L0xlbmRTdGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUE4RDtBQUN0QjtBQUNSO0FBQ2E7QUFDaUg7QUFDN0Q7QUFDNUI7QUFFckUsb0JBQW9CO0FBQ3BCLE1BQU15QixpQkFBaUIsQ0FBQ0M7SUFDdEIsT0FBT3JCLDBDQUFNQSxDQUFDc0IsVUFBVSxDQUFDRCxPQUFPRSxRQUFRO0FBQzFDO0FBRUEsTUFBTUMsY0FBYyxDQUFDQztJQUNuQkMsUUFBUUQsS0FBSyxDQUFDLG9CQUFvQkUsS0FBS0MsU0FBUyxDQUFDSDtJQUNqREMsUUFBUUQsS0FBSyxDQUFDLGtCQUFrQkE7QUFDbEM7QUFFQSxNQUFNSSxZQUFZLENBQUNDOztJQUNqQiw0QkFBNEI7SUFFNUIsdUJBQXVCO0lBQ3ZCLE1BQU0sQ0FBQ0MsaUJBQWlCQyxtQkFBbUIsR0FBR3BDLCtDQUFRQSxDQUFDO1FBQ3JEcUMsVUFBVTtRQUNWQyxhQUFhO1FBQ2JDLFFBQVE7UUFDUkMsZ0JBQWdCO1FBQ2hCQyxTQUFTO0lBQ1g7SUFFQSwyQkFBMkI7SUFDM0IsTUFBTSxDQUFDQyxZQUFZQyxjQUFjLEdBQUczQywrQ0FBUUEsQ0FBQyxFQUFFO0lBQy9DLE1BQU0sQ0FBQzRDLGNBQWNDLGdCQUFnQixHQUFHN0MsK0NBQVFBLENBQUMsRUFBRTtJQUNuRCxNQUFNLENBQUM4QyxnQkFBZ0JDLGtCQUFrQixHQUFHL0MsK0NBQVFBLENBQUMsRUFBRTtJQUN2RCxNQUFNLENBQUNnRCxhQUFhQyxlQUFlLEdBQUdqRCwrQ0FBUUEsQ0FBQyxFQUFFO0lBRWpELG1CQUFtQjtJQUNuQixNQUFNLENBQUNrRCxVQUFVQyxZQUFZLEdBQUduRCwrQ0FBUUEsQ0FBQztRQUN2Q29ELHFCQUFxQjtRQUNyQkMsZ0JBQWdCO0lBQ2xCO0lBRUEsZUFBZTtJQUNmLE1BQU0sQ0FBQ0MsZUFBZUMsaUJBQWlCLEdBQUd2RCwrQ0FBUUEsQ0FBQztRQUNqRHdELGlCQUFpQjtRQUNqQkMsZ0JBQWdCO1FBQ2hCQyxvQkFBb0I7SUFDdEI7SUFFQSxNQUFNLENBQUNDLGVBQWVDLGlCQUFpQixHQUFHNUQsK0NBQVFBLENBQUM7UUFDakR3RCxpQkFBaUI7UUFDakJDLGdCQUFnQjtRQUNoQkksc0JBQXNCO0lBQ3hCO0lBRUEsZUFBZTtJQUNmLE1BQU0sQ0FBQ0MsYUFBYUMsZUFBZSxHQUFHL0QsK0NBQVFBLENBQUM7UUFDN0NnRSxlQUFlO1FBQ2ZDLFNBQVM7UUFDVEMsY0FBYztJQUNoQjtJQUVBLGlCQUFpQjtJQUNqQixrREFBa0Q7SUFDbEQsK0NBQStDO0lBQy9DLGlDQUFpQztJQUNqQywyRUFBMkU7SUFFM0UsVUFBVTtJQUNWLHVCQUF1QjtJQUN2Qiw0QkFBNEI7SUFDNUIsZ0JBQWdCO0lBQ2hCLFFBQVE7SUFFUixnREFBZ0Q7SUFDaEQsdUNBQXVDO0lBQ3ZDLFVBQVU7SUFFViw4Q0FBOEM7SUFDOUMsMENBQTBDO0lBQzFDLGtDQUFrQztJQUNsQyxVQUFVO0lBQ1YsNkNBQTZDO0lBQzdDLGtDQUFrQztJQUNsQyxVQUFVO0lBRVYsNkRBQTZEO0lBQzdELG1EQUFtRDtJQUNuRCx3Q0FBd0M7SUFDeEMsaURBQWlEO0lBRWpELDZCQUE2QjtJQUM3QiwwQ0FBMEM7SUFDMUMsNkJBQTZCO0lBQzdCLDhCQUE4QjtJQUM5QixvQ0FBb0M7SUFDcEMsMEJBQTBCO0lBQzFCLDBDQUEwQztJQUMxQyw0Q0FBNEM7SUFDNUMsWUFBWTtJQUNaLDZEQUE2RDtJQUM3RCxlQUFlO0lBQ2YsNEJBQTRCO0lBQzVCLGdCQUFnQjtJQUNoQixRQUFRO0lBQ1Isc0JBQXNCO0lBQ3RCLDBCQUEwQjtJQUMxQixNQUFNO0lBQ04sVUFBVTtJQUVWLE1BQU1DLGdCQUFnQmxFLGtEQUFXQTtnREFBQztZQUNoQzZCLFFBQVFzQyxHQUFHLENBQUM7WUFDWixNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHQztZQUNyQixNQUFNQyxjQUFjO1lBQ3BCLElBQUk7Z0JBQ0YsSUFBSSxDQUFDRixVQUFVO29CQUNiRyxNQUFNRDtvQkFDTjtnQkFDRjtnQkFFQSxNQUFNRSxXQUFXLE1BQU1KLFNBQVNLLE9BQU8sQ0FBQztvQkFBRUMsUUFBUTtnQkFBc0I7Z0JBRXhFLHVDQUF1QztnQkFDdkNOLFNBQVNPLEVBQUUsQ0FBQzs0REFBZ0I7d0JBQzFCTixPQUFPTyxRQUFRLENBQUNDLE1BQU07b0JBQ3hCOztnQkFDQVQsU0FBU08sRUFBRSxDQUFDOzREQUFtQjt3QkFDN0JOLE9BQU9PLFFBQVEsQ0FBQ0MsTUFBTTtvQkFDeEI7O2dCQUVBLE1BQU16QyxXQUFXLElBQUlqQywwQ0FBTUEsQ0FBQzJFLGVBQWUsQ0FBQ1Y7Z0JBQzVDLE1BQU1XLFVBQVUsTUFBTTNDLFNBQVM0QyxVQUFVO2dCQUN6QyxNQUFNM0MsY0FBYzBDLFFBQVFFLElBQUk7Z0JBQ2hDLE1BQU0zQyxTQUFTLE1BQU1GLFNBQVM4QyxTQUFTO2dCQUV2QyxJQUFJVixTQUFTVyxNQUFNLEVBQUU7b0JBQ25CLElBQUlDLGlCQUFpQlosUUFBUSxDQUFDLEVBQUU7b0JBQ2hDckMsbUJBQW1CO3dCQUNqQkMsVUFBVUE7d0JBQ1ZDLGFBQWFBO3dCQUNiQyxRQUFRQTt3QkFDUkMsZ0JBQWdCNkM7d0JBQ2hCNUMsU0FBUzZDLE9BQU9OLFFBQVF2QyxPQUFPO29CQUNqQztvQkFDQVgsUUFBUXNDLEdBQUcsQ0FBQywwREFBMERpQjtnQkFDeEUsT0FBTztvQkFDTGIsTUFBTUQ7b0JBQ047Z0JBQ0Y7WUFDRixFQUFFLE9BQU8xQyxPQUFPO2dCQUNkRCxZQUFZQztZQUNkO1FBQ0Y7K0NBQUcsRUFBRTtJQUVMLHdCQUF3QjtJQUN4QixNQUFNMEQsY0FBY3RGLGtEQUFXQTs4Q0FBQyxPQUFPdUYsU0FBU0M7WUFDOUMsSUFBSSxDQUFDdEQsZ0JBQWdCRSxRQUFRLEVBQUUsT0FBTztZQUN0QyxNQUFNYSxXQUFXLElBQUk5QywwQ0FBTUEsQ0FBQ3NGLFFBQVEsQ0FBQ0YsU0FBU0MsS0FBS3RELGdCQUFnQkUsUUFBUTtZQUMzRSxPQUFPYTtRQUNUOzZDQUFHO1FBQUNmLGdCQUFnQkUsUUFBUTtLQUFDO0lBRTdCLDZCQUE2QjtJQUM3QixNQUFNc0QsZ0JBQWdCMUYsa0RBQVdBO2dEQUFDO1lBQ2hDNkIsUUFBUXNDLEdBQUcsQ0FBQztZQUNaLElBQUk7Z0JBQ0YsSUFBSSxDQUFDakMsZ0JBQWdCRSxRQUFRLElBQUksQ0FBQ0YsZ0JBQWdCSyxjQUFjLEVBQUUsT0FBTyxFQUFFO2dCQUUzRSxNQUFNb0QsU0FBUyxNQUFNQyxRQUFRQyxHQUFHLENBQzlCekYscURBQU1BLENBQUMwRixNQUFNLENBQUNDLEdBQUc7NERBQUMsT0FBT0M7d0JBQ3ZCLElBQUlDLFVBQVU7d0JBQ2QsSUFBSUMsYUFBYTt3QkFFakIsSUFBSTs0QkFDRixJQUFJRixNQUFNRyxRQUFRLEVBQUU7Z0NBQ2xCLHFCQUFxQjtnQ0FDckIsTUFBTUMsTUFBTSxNQUFNbEUsZ0JBQWdCRSxRQUFRLENBQUNpRSxVQUFVLENBQUNuRSxnQkFBZ0JLLGNBQWM7Z0NBQ3BGMEQsVUFBVTlGLDBDQUFNQSxDQUFDbUcsV0FBVyxDQUFDRjs0QkFDL0IsT0FBTztnQ0FDTCxzQkFBc0I7Z0NBQ3RCSCxVQUFVLE1BQU01Rix3REFBZUEsQ0FDN0I2QixnQkFBZ0JFLFFBQVEsRUFDeEI0RCxNQUFNVCxPQUFPLEVBQ2JyRCxnQkFBZ0JLLGNBQWMsRUFDOUJ5RCxNQUFNTyxRQUFROzRCQUVsQjs0QkFFQSxnQkFBZ0I7NEJBQ2hCLE1BQU1DLFFBQVEsTUFBTUMsWUFBWVQsTUFBTVQsT0FBTzs0QkFDN0NXLGFBQWFRLFdBQVdULFdBQVdTLFdBQVdGOzRCQUU5QyxPQUFPO2dDQUNMakIsU0FBU1MsTUFBTVQsT0FBTztnQ0FDdEJvQixRQUFRWCxNQUFNVyxNQUFNO2dDQUNwQjFCLE1BQU1lLE1BQU1mLElBQUk7Z0NBQ2hCc0IsVUFBVVAsTUFBTU8sUUFBUTtnQ0FDeEJKLFVBQVVILE1BQU1HLFFBQVE7Z0NBQ3hCRixTQUFTQTtnQ0FDVEMsWUFBWUE7Z0NBQ1pVLFVBQVVKOzRCQUNaO3dCQUNGLEVBQUUsT0FBTzVFLE9BQU87NEJBQ2RDLFFBQVFnRixJQUFJLENBQUMsNkJBQTBDLE9BQWJiLE1BQU1XLE1BQU0sRUFBQyxNQUFJL0U7NEJBQzNELE9BQU87Z0NBQ0wyRCxTQUFTUyxNQUFNVCxPQUFPO2dDQUN0Qm9CLFFBQVFYLE1BQU1XLE1BQU07Z0NBQ3BCMUIsTUFBTWUsTUFBTWYsSUFBSTtnQ0FDaEJzQixVQUFVUCxNQUFNTyxRQUFRO2dDQUN4QkosVUFBVUgsTUFBTUcsUUFBUTtnQ0FDeEJGLFNBQVM7Z0NBQ1RDLFlBQVk7Z0NBQ1pVLFVBQVU7NEJBQ1o7d0JBQ0Y7b0JBQ0Y7O2dCQUdGbEUsY0FBY2lEO2dCQUNkOUQsUUFBUXNDLEdBQUcsQ0FBQyxvQkFBb0J3QjtnQkFDaEMsT0FBT0E7WUFDVCxFQUFFLE9BQU8vRCxPQUFPO2dCQUNkRCxZQUFZQztnQkFDWixPQUFPLEVBQUU7WUFDWDtRQUNGOytDQUFHO1FBQUNNLGdCQUFnQkUsUUFBUTtRQUFFRixnQkFBZ0JLLGNBQWM7S0FBQztJQUU3RCxtQkFBbUI7SUFDbkIsTUFBTWtFLGNBQWN6RyxrREFBV0E7OENBQUMsT0FBTzhHO1lBQ3JDLElBQUksQ0FBQzVFLGdCQUFnQkUsUUFBUSxFQUFFLE9BQU87WUFDdEMsSUFBSTtnQkFDRixNQUFNb0QsTUFBTTtvQkFBQztpQkFBbUU7Z0JBQ2hGLE1BQU11QixTQUFTLElBQUk1RywwQ0FBTUEsQ0FBQ3NGLFFBQVEsQ0FBQ3JGLHFEQUFNQSxDQUFDNEcsWUFBWSxFQUFFeEIsS0FBS3RELGdCQUFnQkUsUUFBUTtnQkFDckYsTUFBTW9FLFFBQVEsTUFBTU8sT0FBT0UsaUJBQWlCLENBQUNIO2dCQUM3QyxPQUFPM0csMENBQU1BLENBQUMrRyxXQUFXLENBQUNWLE9BQU87WUFDbkMsRUFBRSxPQUFPNUUsT0FBTztnQkFDZEMsUUFBUWdGLElBQUksQ0FBQywyQkFBaUMsT0FBTkMsT0FBTSxNQUFJbEY7Z0JBQ2xELE9BQU87WUFDVDtRQUNGOzZDQUFHO1FBQUNNLGdCQUFnQkUsUUFBUTtLQUFDO0lBRTdCLG9CQUFvQjtJQUNwQixNQUFNK0UsaUJBQWlCbkgsa0RBQVdBO2lEQUFDLE9BQU91RixTQUFTNkI7WUFDakQsSUFBSTtnQkFDRixNQUFNWixRQUFRLE1BQU1DLFlBQVlsQjtnQkFDaEMsTUFBTThCLGNBQWNYLFdBQVdVLFVBQVVWLFdBQVdGO2dCQUNwRCxPQUFPYTtZQUNULEVBQUUsT0FBT3pGLE9BQU87Z0JBQ2RELFlBQVlDO2dCQUNaLE9BQU87WUFDVDtRQUNGO2dEQUFHO1FBQUM2RTtLQUFZO0lBRWhCLGlCQUFpQjtJQUNqQixNQUFNYSxvQkFBb0J0SCxrREFBV0E7b0RBQUMsT0FBT3VILGNBQWNDO1lBQ3pELElBQUksQ0FBQ3RGLGdCQUFnQkksTUFBTSxFQUFFO2dCQUMzQixNQUFNLElBQUltRixNQUFNO1lBQ2xCO1lBRUEsSUFBSTtnQkFDRixNQUFNekIsUUFBUTVGLHFEQUFNQSxDQUFDMEYsTUFBTSxDQUFDNEIsSUFBSTtzRUFBQ0MsQ0FBQUEsSUFBS0EsRUFBRXBDLE9BQU8sQ0FBQ3FDLFdBQVcsT0FBT0wsYUFBYUssV0FBVzs7Z0JBQzFGLElBQUksQ0FBQzVCLE9BQU8sTUFBTSxJQUFJeUIsTUFBTTtnQkFFNUIsTUFBTWxILHdEQUFlQSxDQUNuQjJCLGdCQUFnQkksTUFBTSxFQUN0QmlGLGNBQ0FuSCxxREFBTUEsQ0FBQ3lILFlBQVksRUFDbkJMLGVBQ0F4QixNQUFNTyxRQUFRO2dCQUdoQjFFLFFBQVFzQyxHQUFHLENBQUMsbUJBQW1Cb0Q7Z0JBQy9CLE9BQU87b0JBQUVPLFFBQVE7b0JBQUtDLFNBQVM7Z0JBQTRCO1lBQzdELEVBQUUsT0FBT25HLE9BQU87Z0JBQ2RELFlBQVlDO2dCQUNaLE9BQU87b0JBQUVrRyxRQUFRO29CQUFLQyxTQUFTbkcsTUFBTW1HLE9BQU8sSUFBSW5HLE1BQU1vRyxNQUFNO2dCQUFDO1lBQy9EO1FBQ0Y7bURBQUc7UUFBQzlGLGdCQUFnQkksTUFBTTtLQUFDO0lBRTNCLGFBQWE7SUFDYixNQUFNMkYsWUFBWWpJLGtEQUFXQTs0Q0FBQyxPQUFPZ0csT0FBT2tDO1lBQzFDLElBQUksQ0FBQ2hHLGdCQUFnQkksTUFBTSxFQUFFO2dCQUMzQixNQUFNLElBQUltRixNQUFNO1lBQ2xCO1lBRUEsSUFBSTtnQkFDRixNQUFNVSxZQUFZL0gscURBQU1BLENBQUMwRixNQUFNLENBQUM0QixJQUFJO2tFQUFDQyxDQUFBQSxJQUFLQSxFQUFFcEMsT0FBTyxDQUFDcUMsV0FBVyxPQUFPNUIsTUFBTTRCLFdBQVc7O2dCQUN2RixJQUFJLENBQUNPLFdBQVcsTUFBTSxJQUFJVixNQUFNO2dCQUVoQyxNQUFNTCxTQUFTakgsMENBQU1BLENBQUNpSSxVQUFVLENBQUNGLGNBQWNDLFVBQVU1QixRQUFRO2dCQUNqRSxNQUFNOEIsS0FBSyxNQUFNNUgsNkNBQU1BLENBQUN5QixnQkFBZ0JJLE1BQU0sRUFBRTBELE9BQU9vQjtnQkFFdkQsSUFBSWlCLElBQUk7b0JBQ054RyxRQUFRc0MsR0FBRyxDQUFDLDRCQUE0QjZCLE9BQU9rQztvQkFDL0MsT0FBTzt3QkFBRUosUUFBUTt3QkFBS0MsU0FBUzt3QkFBNkJPLE1BQU1ELEdBQUdDLElBQUk7b0JBQUM7Z0JBQzVFO2dCQUNBLE1BQU0sSUFBSWIsTUFBTTtZQUNsQixFQUFFLE9BQU83RixPQUFPO2dCQUNkRCxZQUFZQztnQkFDWixPQUFPO29CQUFFa0csUUFBUTtvQkFBS0MsU0FBU25HLE1BQU1tRyxPQUFPLElBQUluRyxNQUFNb0csTUFBTTtnQkFBQztZQUMvRDtRQUNGOzJDQUFHO1FBQUM5RixnQkFBZ0JJLE1BQU07S0FBQztJQUUzQixpQkFBaUI7SUFDakIsTUFBTWlHLGdCQUFnQnZJLGtEQUFXQTtnREFBQyxPQUFPdUgsY0FBY2lCO1lBQ3JELElBQUksQ0FBQ3RHLGdCQUFnQkksTUFBTSxFQUFFO2dCQUMzQixNQUFNLElBQUltRixNQUFNO1lBQ2xCO1lBRUEsSUFBSTtnQkFDRixNQUFNVSxZQUFZL0gscURBQU1BLENBQUMwRixNQUFNLENBQUM0QixJQUFJO3NFQUFDQyxDQUFBQSxJQUFLQSxFQUFFcEMsT0FBTyxDQUFDcUMsV0FBVyxPQUFPTCxhQUFhSyxXQUFXOztnQkFDOUYsSUFBSSxDQUFDTyxXQUFXLE1BQU0sSUFBSVYsTUFBTTtnQkFFaEMsTUFBTUwsU0FBU2pILDBDQUFNQSxDQUFDaUksVUFBVSxDQUFDSSxnQkFBZ0JMLFVBQVU1QixRQUFRO2dCQUNuRSxNQUFNOEIsS0FBSyxNQUFNMUgsaURBQVVBLENBQUN1QixnQkFBZ0JJLE1BQU0sRUFBRWlGLGNBQWNIO2dCQUVsRSxJQUFJaUIsSUFBSTtvQkFDTnhHLFFBQVFzQyxHQUFHLENBQUMsaUNBQWlDb0QsY0FBY2lCO29CQUMzRCxPQUFPO3dCQUFFVixRQUFRO3dCQUFLQyxTQUFTO3dCQUE2Qk8sTUFBTUQsR0FBR0MsSUFBSTtvQkFBQztnQkFDNUU7Z0JBQ0EsTUFBTSxJQUFJYixNQUFNO1lBQ2xCLEVBQUUsT0FBTzdGLE9BQU87Z0JBQ2RELFlBQVlDO2dCQUNaLE9BQU87b0JBQUVrRyxRQUFRO29CQUFLQyxTQUFTbkcsTUFBTW1HLE9BQU8sSUFBSW5HLE1BQU1vRyxNQUFNO2dCQUFDO1lBQy9EO1FBQ0Y7K0NBQUc7UUFBQzlGLGdCQUFnQkksTUFBTTtLQUFDO0lBRTNCLGVBQWU7SUFDZixNQUFNbUcsY0FBY3pJLGtEQUFXQTs4Q0FBQyxPQUFPZ0csT0FBTzBDO1lBQzVDLElBQUksQ0FBQ3hHLGdCQUFnQkksTUFBTSxFQUFFO2dCQUMzQixNQUFNLElBQUltRixNQUFNO1lBQ2xCO1lBRUEsSUFBSTtnQkFDRixNQUFNVSxZQUFZL0gscURBQU1BLENBQUMwRixNQUFNLENBQUM0QixJQUFJO29FQUFDQyxDQUFBQSxJQUFLQSxFQUFFcEMsT0FBTyxDQUFDcUMsV0FBVyxPQUFPNUIsTUFBTTRCLFdBQVc7O2dCQUN2RixJQUFJLENBQUNPLFdBQVcsTUFBTSxJQUFJVixNQUFNO2dCQUVoQyxNQUFNTCxTQUFTakgsMENBQU1BLENBQUNpSSxVQUFVLENBQUNNLGNBQWNQLFVBQVU1QixRQUFRO2dCQUNqRSxNQUFNOEIsS0FBSyxNQUFNeEgsK0NBQVFBLENBQUNxQixnQkFBZ0JJLE1BQU0sRUFBRTBELE9BQU9vQjtnQkFFekQsSUFBSWlCLElBQUk7b0JBQ054RyxRQUFRc0MsR0FBRyxDQUFDLGdDQUFnQzZCLE9BQU8wQztvQkFDbkQsT0FBTzt3QkFBRVosUUFBUTt3QkFBS0MsU0FBUzt3QkFBNkJPLE1BQU1ELEdBQUdDLElBQUk7b0JBQUM7Z0JBQzVFO2dCQUNBLE1BQU0sSUFBSWIsTUFBTTtZQUNsQixFQUFFLE9BQU83RixPQUFPO2dCQUNkRCxZQUFZQztnQkFDWixPQUFPO29CQUFFa0csUUFBUTtvQkFBS0MsU0FBU25HLE1BQU1tRyxPQUFPLElBQUluRyxNQUFNb0csTUFBTTtnQkFBQztZQUMvRDtRQUNGOzZDQUFHO1FBQUM5RixnQkFBZ0JJLE1BQU07S0FBQztJQUUzQixjQUFjO0lBQ2QsTUFBTXFHLGFBQWEzSSxrREFBV0E7NkNBQUMsT0FBT3VILGNBQWNxQjtZQUNsRCxJQUFJLENBQUMxRyxnQkFBZ0JJLE1BQU0sRUFBRTtnQkFDM0IsTUFBTSxJQUFJbUYsTUFBTTtZQUNsQjtZQUVBLElBQUk7Z0JBQ0YsTUFBTVUsWUFBWS9ILHFEQUFNQSxDQUFDMEYsTUFBTSxDQUFDNEIsSUFBSTttRUFBQ0MsQ0FBQUEsSUFBS0EsRUFBRXBDLE9BQU8sQ0FBQ3FDLFdBQVcsT0FBT0wsYUFBYUssV0FBVzs7Z0JBQzlGLElBQUksQ0FBQ08sV0FBVyxNQUFNLElBQUlWLE1BQU07Z0JBRWhDLE1BQU1MLFNBQVNqSCwwQ0FBTUEsQ0FBQ2lJLFVBQVUsQ0FBQ1EsYUFBYVQsVUFBVTVCLFFBQVE7Z0JBQ2hFLE1BQU04QixLQUFLLE1BQU10SCw4Q0FBT0EsQ0FBQ21CLGdCQUFnQkksTUFBTSxFQUFFaUYsY0FBY0g7Z0JBRS9ELElBQUlpQixJQUFJO29CQUNOeEcsUUFBUXNDLEdBQUcsQ0FBQyw4QkFBOEJvRCxjQUFjcUI7b0JBQ3hELE9BQU87d0JBQUVkLFFBQVE7d0JBQUtDLFNBQVM7d0JBQTZCTyxNQUFNRCxHQUFHQyxJQUFJO29CQUFDO2dCQUM1RTtnQkFDQSxNQUFNLElBQUliLE1BQU07WUFDbEIsRUFBRSxPQUFPN0YsT0FBTztnQkFDZEQsWUFBWUM7Z0JBQ1osT0FBTztvQkFBRWtHLFFBQVE7b0JBQUtDLFNBQVNuRyxNQUFNbUcsT0FBTyxJQUFJbkcsTUFBTW9HLE1BQU07Z0JBQUM7WUFDL0Q7UUFDRjs0Q0FBRztRQUFDOUYsZ0JBQWdCSSxNQUFNO0tBQUM7SUFFM0IscURBQXFEO0lBQ3JELE1BQU11RyxpQkFBaUI3SSxrREFBV0E7aURBQUMsT0FBTzhJO1lBQ3hDLElBQUk7Z0JBQ0YsSUFBSSxDQUFDNUcsZ0JBQWdCRSxRQUFRLEVBQUUsT0FBTztnQkFFdEMsTUFBTTJHLE9BQU8sSUFBSTVJLDBDQUFNQSxDQUFDc0YsUUFBUSxDQUFDeEUsMERBQWtCQSxFQUFFSSxpREFBY0EsQ0FBQ21FLEdBQUcsRUFBRXRELGdCQUFnQkUsUUFBUTtnQkFDakcsTUFBTTRHLFNBQVNGLFFBQVE1RyxnQkFBZ0JLLGNBQWMsSUFBSXBDLDBDQUFNQSxDQUFDOEksV0FBVztnQkFFM0Usd0NBQXdDO2dCQUN4QyxJQUFJQyxLQUFLQyxNQUFNQztnQkFDZixJQUFJO29CQUNGLENBQUNGLEtBQUtDLE1BQU1DLEdBQUcsR0FBRyxNQUFNTCxLQUFLRixjQUFjLENBQUNHO2dCQUM5QyxFQUFFLE9BQU9LLGVBQWU7b0JBQ3RCeEgsUUFBUXNDLEdBQUcsQ0FBQyxtREFBbURrRixjQUFjdEIsT0FBTztvQkFDcEYsc0NBQXNDO29CQUN0Q21CLE1BQU0vSSwwQ0FBTUEsQ0FBQ2lJLFVBQVUsQ0FBQyxLQUFLO29CQUM3QmUsT0FBT2hKLDBDQUFNQSxDQUFDaUksVUFBVSxDQUFDLEtBQUs7b0JBQzlCZ0IsS0FBS2pKLDBDQUFNQSxDQUFDaUksVUFBVSxDQUFDLG1GQUFtRixLQUFLLGNBQWM7Z0JBQy9IO2dCQUVBLE1BQU12RSxjQUFjO29CQUNsQkUsZUFBZTVELDBDQUFNQSxDQUFDK0csV0FBVyxDQUFDZ0MsS0FBSztvQkFDdkNsRixTQUFTN0QsMENBQU1BLENBQUMrRyxXQUFXLENBQUNpQyxNQUFNO29CQUNsQ2xGLGNBQWM5RCwwQ0FBTUEsQ0FBQytHLFdBQVcsQ0FBQ2tDLElBQUk7Z0JBQ3ZDO2dCQUVBdEYsZUFBZUQ7Z0JBQ2YsT0FBT0E7WUFDVCxFQUFFLE9BQU9qQyxPQUFPO2dCQUNkQyxRQUFRc0MsR0FBRyxDQUFDLHlDQUF5Q3ZDLE1BQU1tRyxPQUFPO2dCQUNsRSxxQ0FBcUM7Z0JBQ3JDLE1BQU1sRSxjQUFjO29CQUNsQkUsZUFBZTtvQkFDZkMsU0FBUztvQkFDVEMsY0FBYztnQkFDaEI7Z0JBQ0FILGVBQWVEO2dCQUNmLE9BQU9BO1lBQ1Q7UUFDRjtnREFBRztRQUFDM0IsZ0JBQWdCRSxRQUFRO1FBQUVGLGdCQUFnQkssY0FBYztLQUFDO0lBRTdELG9CQUFvQjtJQUNwQixNQUFNK0csa0JBQWtCdEosa0RBQVdBO2tEQUFDO1lBQ2xDNkIsUUFBUXNDLEdBQUcsQ0FBQztZQUNaLElBQUk7Z0JBQ0YsSUFBSSxDQUFDakMsZ0JBQWdCRSxRQUFRLElBQUksQ0FBQ0YsZ0JBQWdCSyxjQUFjLEVBQUUsT0FBTyxFQUFFO2dCQUUzRSxNQUFNaUQsTUFBTTtvQkFDVjtpQkFDRDtnQkFDRCxNQUFNdUQsT0FBTyxJQUFJNUksMENBQU1BLENBQUNzRixRQUFRLENBQUNyRixxREFBTUEsQ0FBQ3lILFlBQVksRUFBRXJDLEtBQUt0RCxnQkFBZ0JFLFFBQVE7Z0JBRW5GLE1BQU1tSCxXQUFXLE1BQU0zRCxRQUFRQyxHQUFHLENBQ2hDekYscURBQU1BLENBQUMwRixNQUFNLENBQUMwRCxNQUFNOzhEQUFDN0IsQ0FBQUEsSUFBSyxDQUFDQSxFQUFFeEIsUUFBUTs2REFBRUosR0FBRzs4REFBQyxPQUFPQzt3QkFDaEQsSUFBSTs0QkFDRixNQUFNeUQsY0FBYyxNQUFNVixLQUFLVyxjQUFjLENBQUN4SCxnQkFBZ0JLLGNBQWMsRUFBRXlELE1BQU1ULE9BQU87NEJBQzNGLE1BQU1vRSxrQkFBa0J4SiwwQ0FBTUEsQ0FBQytHLFdBQVcsQ0FBQ3VDLFlBQVlHLE1BQU0sQ0FBQ0MsU0FBUyxFQUFFOzRCQUN6RSxNQUFNQyxjQUFjTCxZQUFZRyxNQUFNLENBQUNHLEtBQUssQ0FBQ3JJLFFBQVE7NEJBRXJELElBQUlnRixXQUFXaUQsbUJBQW1CLEdBQUc7Z0NBQ25DLE1BQU1uRCxRQUFRLE1BQU1DLFlBQVlULE1BQU1ULE9BQU87Z0NBQzdDLE1BQU1XLGFBQWFRLFdBQVdpRCxtQkFBbUJqRCxXQUFXRjtnQ0FFNUQsT0FBTztvQ0FDTGpCLFNBQVNTLE1BQU1ULE9BQU87b0NBQ3RCb0IsUUFBUVgsTUFBTVcsTUFBTTtvQ0FDcEIxQixNQUFNZSxNQUFNZixJQUFJO29DQUNoQnNCLFVBQVVQLE1BQU1PLFFBQVE7b0NBQ3hCb0QsaUJBQWlCQTtvQ0FDakJHLGFBQWFBO29DQUNiNUQsWUFBWUE7b0NBQ1pVLFVBQVVKO2dDQUNaOzRCQUNGOzRCQUNBLE9BQU87d0JBQ1QsRUFBRSxPQUFPNUUsT0FBTzs0QkFDZEMsUUFBUWdGLElBQUksQ0FBQyw0QkFBeUMsT0FBYmIsTUFBTVcsTUFBTSxFQUFDLE1BQUkvRTs0QkFDMUQsT0FBTzt3QkFDVDtvQkFDRjs7Z0JBR0YsTUFBTW9JLGdCQUFnQlQsU0FBU0MsTUFBTTs0RUFBQ1MsQ0FBQUEsSUFBS0EsTUFBTTs7Z0JBQ2pEckgsZ0JBQWdCb0g7Z0JBRWhCLG9CQUFvQjtnQkFDcEIsTUFBTXpHLGtCQUFrQnlHLGNBQWNFLE1BQU07OEVBQUMsQ0FBQ0MsS0FBS3JELFFBQVVxRCxNQUFNckQsTUFBTVosVUFBVTs2RUFBRTtnQkFDckYsTUFBTTFDLGlCQUFpQndHLGNBQWM3RSxNQUFNLEdBQUcsSUFDNUM2RSxjQUFjRSxNQUFNOzhEQUFDLENBQUNDLEtBQUtyRCxRQUFVcUQsTUFBT3JELENBQUFBLE1BQU1zRCxHQUFHLElBQUk7NkRBQUksS0FBS0osY0FBYzdFLE1BQU0sR0FBRztnQkFDM0YsTUFBTTFCLHFCQUFxQnVHLGNBQWNFLE1BQU07aUZBQUMsQ0FBQ0MsS0FBS3JELFFBQVVxRCxNQUFNckQsTUFBTVosVUFBVTtnRkFBRTtnQkFFeEY1QyxpQkFBaUI7b0JBQ2ZDO29CQUNBQztvQkFDQUM7Z0JBQ0Y7Z0JBRUE1QixRQUFRc0MsR0FBRyxDQUFDLHNCQUFzQjZGO2dCQUNsQyxPQUFPQTtZQUNULEVBQUUsT0FBT3BJLE9BQU87Z0JBQ2RELFlBQVlDO2dCQUNaLE9BQU8sRUFBRTtZQUNYO1FBQ0Y7aURBQUc7UUFBQ00sZ0JBQWdCRSxRQUFRO1FBQUVGLGdCQUFnQkssY0FBYztRQUFFa0U7S0FBWTtJQUUxRSxtQkFBbUI7SUFDbkIsTUFBTTRELGlCQUFpQnJLLGtEQUFXQTtpREFBQztZQUNqQzZCLFFBQVFzQyxHQUFHLENBQUM7WUFDWixJQUFJO2dCQUNGLElBQUksQ0FBQ2pDLGdCQUFnQkUsUUFBUSxJQUFJLENBQUNGLGdCQUFnQkssY0FBYyxFQUFFLE9BQU8sRUFBRTtnQkFFM0UsTUFBTWlELE1BQU07b0JBQ1Y7aUJBQ0Q7Z0JBQ0QsTUFBTXVELE9BQU8sSUFBSTVJLDBDQUFNQSxDQUFDc0YsUUFBUSxDQUFDckYscURBQU1BLENBQUN5SCxZQUFZLEVBQUVyQyxLQUFLdEQsZ0JBQWdCRSxRQUFRO2dCQUVuRixNQUFNa0ksVUFBVSxNQUFNMUUsUUFBUUMsR0FBRyxDQUMvQnpGLHFEQUFNQSxDQUFDMEYsTUFBTSxDQUFDMEQsTUFBTTs2REFBQzdCLENBQUFBLElBQUssQ0FBQ0EsRUFBRXhCLFFBQVE7NERBQUVKLEdBQUc7NkRBQUMsT0FBT0M7d0JBQ2hELElBQUk7NEJBQ0YsTUFBTXlELGNBQWMsTUFBTVYsS0FBS1csY0FBYyxDQUFDeEgsZ0JBQWdCSyxjQUFjLEVBQUV5RCxNQUFNVCxPQUFPOzRCQUMzRixNQUFNZ0Ysa0JBQWtCcEssMENBQU1BLENBQUMrRyxXQUFXLENBQUN1QyxZQUFZN0ksTUFBTSxDQUFDaUosU0FBUyxFQUFFOzRCQUN6RSxNQUFNVyxjQUFjZixZQUFZN0ksTUFBTSxDQUFDbUosS0FBSyxDQUFDckksUUFBUTs0QkFFckQsSUFBSWdGLFdBQVc2RCxtQkFBbUIsR0FBRztnQ0FDbkMsTUFBTS9ELFFBQVEsTUFBTUMsWUFBWVQsTUFBTVQsT0FBTztnQ0FDN0MsTUFBTVcsYUFBYVEsV0FBVzZELG1CQUFtQjdELFdBQVdGO2dDQUU1RCxPQUFPO29DQUNMakIsU0FBU1MsTUFBTVQsT0FBTztvQ0FDdEJvQixRQUFRWCxNQUFNVyxNQUFNO29DQUNwQjFCLE1BQU1lLE1BQU1mLElBQUk7b0NBQ2hCc0IsVUFBVVAsTUFBTU8sUUFBUTtvQ0FDeEJnRSxpQkFBaUJBO29DQUNqQkMsYUFBYUE7b0NBQ2J0RSxZQUFZQTtvQ0FDWlUsVUFBVUo7Z0NBQ1o7NEJBQ0Y7NEJBQ0EsT0FBTzt3QkFDVCxFQUFFLE9BQU81RSxPQUFPOzRCQUNkQyxRQUFRZ0YsSUFBSSxDQUFDLDRCQUF5QyxPQUFiYixNQUFNVyxNQUFNLEVBQUMsTUFBSS9FOzRCQUMxRCxPQUFPO3dCQUNUO29CQUNGOztnQkFHRixNQUFNNkksZUFBZUgsUUFBUWQsTUFBTTswRUFBQ2tCLENBQUFBLElBQUtBLE1BQU07O2dCQUMvQzFILGVBQWV5SDtnQkFFZixvQkFBb0I7Z0JBQ3BCLE1BQU1sSCxrQkFBa0JrSCxhQUFhUCxNQUFNOzZFQUFDLENBQUNDLEtBQUtyRCxRQUFVcUQsTUFBTXJELE1BQU1aLFVBQVU7NEVBQUU7Z0JBQ3BGLE1BQU0xQyxpQkFBaUJpSCxhQUFhdEYsTUFBTSxHQUFHLElBQzNDc0YsYUFBYVAsTUFBTTs2REFBQyxDQUFDQyxLQUFLckQsUUFBVXFELE1BQU9yRCxDQUFBQSxNQUFNc0QsR0FBRyxJQUFJOzREQUFJLEtBQUtLLGFBQWF0RixNQUFNLEdBQUc7Z0JBQ3pGLE1BQU12Qix1QkFBdUJMO2dCQUU3QkksaUJBQWlCO29CQUNmSjtvQkFDQUM7b0JBQ0FJO2dCQUNGO2dCQUVBL0IsUUFBUXNDLEdBQUcsQ0FBQyxxQkFBcUJzRztnQkFDakMsT0FBT0E7WUFDVCxFQUFFLE9BQU83SSxPQUFPO2dCQUNkRCxZQUFZQztnQkFDWixPQUFPLEVBQUU7WUFDWDtRQUNGO2dEQUFHO1FBQUNNLGdCQUFnQkUsUUFBUTtRQUFFRixnQkFBZ0JLLGNBQWM7UUFBRWtFO0tBQVk7SUFFMUUsdUJBQXVCO0lBQ3ZCLE1BQU1rRSxvQkFBb0IzSyxrREFBV0E7b0RBQUM7WUFDcEM2QixRQUFRc0MsR0FBRyxDQUFDO1lBQ1osSUFBSTtnQkFDRixJQUFJLENBQUNqQyxnQkFBZ0JFLFFBQVEsRUFBRSxPQUFPLEVBQUU7Z0JBRXhDLE1BQU1vRCxNQUFNO29CQUNWO2lCQUNEO2dCQUNELE1BQU11RCxPQUFPLElBQUk1SSwwQ0FBTUEsQ0FBQ3NGLFFBQVEsQ0FBQ3JGLHFEQUFNQSxDQUFDeUgsWUFBWSxFQUFFckMsS0FBS3RELGdCQUFnQkUsUUFBUTtnQkFFbkYsTUFBTXVELFNBQVMsTUFBTUMsUUFBUUMsR0FBRyxDQUM5QnpGLHFEQUFNQSxDQUFDMEYsTUFBTSxDQUFDMEQsTUFBTTtnRUFBQzdCLENBQUFBLElBQUssQ0FBQ0EsRUFBRXhCLFFBQVE7K0RBQUVKLEdBQUc7Z0VBQUMsT0FBT0M7d0JBQ2hELElBQUk7NEJBQ0YsTUFBTTRFLFVBQVUsTUFBTTdCLEtBQUs4QixRQUFRLENBQUM3RSxNQUFNVCxPQUFPOzRCQUNqRCxNQUFNdUYsZUFBZUMsUUFBUUgsUUFBUUUsWUFBWTs0QkFDakQsTUFBTUUsY0FBYzdLLDBDQUFNQSxDQUFDK0csV0FBVyxDQUFDMEQsUUFBUUksV0FBVyxFQUFFOzRCQUM1RCxNQUFNeEUsUUFBUSxNQUFNQyxZQUFZVCxNQUFNVCxPQUFPOzRCQUU3QyxJQUFJdUYsZ0JBQWdCcEUsV0FBV3NFLGVBQWUsR0FBRztnQ0FDL0MsT0FBTztvQ0FDTHpGLFNBQVNTLE1BQU1ULE9BQU87b0NBQ3RCb0IsUUFBUVgsTUFBTVcsTUFBTTtvQ0FDcEIxQixNQUFNZSxNQUFNZixJQUFJO29DQUNoQnNCLFVBQVVQLE1BQU1PLFFBQVE7b0NBQ3hCeUUsYUFBYUE7b0NBQ2JGLGNBQWNBO29DQUNkbEUsVUFBVUo7b0NBQ1Z5RSxRQUFRNUYsT0FBT3VGLFFBQVFLLE1BQU07b0NBQzdCQyxpQkFBaUI3RixPQUFPdUYsUUFBUU0sZUFBZTtnQ0FDakQ7NEJBQ0Y7NEJBQ0EsT0FBTzt3QkFDVCxFQUFFLE9BQU90SixPQUFPOzRCQUNkQyxRQUFRZ0YsSUFBSSxDQUFDLDhCQUEyQyxPQUFiYixNQUFNVyxNQUFNLEVBQUMsTUFBSS9FOzRCQUM1RCxPQUFPO3dCQUNUO29CQUNGOztnQkFHRixNQUFNdUosY0FBY3hGLE9BQU82RCxNQUFNOzRFQUFDNEIsQ0FBQUEsSUFBS0EsTUFBTTs7Z0JBQzdDdEksa0JBQWtCcUk7Z0JBQ2xCdEosUUFBUXNDLEdBQUcsQ0FBQyx5QkFBeUJnSDtnQkFDckMsT0FBT0E7WUFDVCxFQUFFLE9BQU92SixPQUFPO2dCQUNkRCxZQUFZQztnQkFDWixPQUFPLEVBQUU7WUFDWDtRQUNGO21EQUFHO1FBQUNNLGdCQUFnQkUsUUFBUTtRQUFFcUU7S0FBWTtJQUUxQyxtQkFBbUI7SUFDbkIsTUFBTTRFLFVBQVVyTCxrREFBV0E7MENBQUMsT0FBT3NMO1lBQ2pDLElBQUksQ0FBQ3BKLGdCQUFnQkksTUFBTSxFQUFFO2dCQUMzQixNQUFNLElBQUltRixNQUFNO1lBQ2xCO1lBRUEsSUFBSTtnQkFDRixNQUFNOEQsT0FBTyxjQUFjLFlBQVk7Z0JBQ3ZDMUosUUFBUXNDLEdBQUcsQ0FBQyxpQ0FBaUNoRCxtREFBV0E7Z0JBQ3hELE1BQU1rSCxLQUFLLE1BQU1uRyxnQkFBZ0JJLE1BQU0sQ0FBQ2tKLGVBQWUsQ0FBQztvQkFDdERDLElBQUl0SyxtREFBV0E7b0JBQ2Z1SyxPQUFPdkwsMENBQU1BLENBQUNzQixVQUFVLENBQUM2SjtvQkFDekJDO2dCQUNGO2dCQUNBLE1BQU1sRCxHQUFHc0QsSUFBSTtnQkFDYjlKLFFBQVFzQyxHQUFHLENBQUMsd0JBQXdCbUg7Z0JBQ3BDLE9BQU87b0JBQUV4RCxRQUFRO29CQUFLQyxTQUFTO29CQUE2Qk8sTUFBTUQsR0FBR0MsSUFBSTtnQkFBQztZQUM1RSxFQUFFLE9BQU8xRyxPQUFPO2dCQUNkRCxZQUFZQztnQkFDWixPQUFPO29CQUFFa0csUUFBUTtvQkFBS0MsU0FBU25HLE1BQU1tRyxPQUFPLElBQUluRyxNQUFNb0csTUFBTTtnQkFBQztZQUMvRDtRQUNGO3lDQUFHO1FBQUM5RixnQkFBZ0JJLE1BQU07S0FBQztJQUUzQixxQkFBcUI7SUFDckIsTUFBTXNKLGFBQWE1TCxrREFBV0E7NkNBQUMsT0FBT3NMO1lBQ3BDLElBQUksQ0FBQ3BKLGdCQUFnQkksTUFBTSxFQUFFO2dCQUMzQixNQUFNLElBQUltRixNQUFNO1lBQ2xCO1lBRUEsSUFBSTtnQkFDRixNQUFNakMsTUFBTTtvQkFBQztpQkFBaUM7Z0JBQzlDM0QsUUFBUXNDLEdBQUcsQ0FBQyxvQ0FBb0NoRCxtREFBV0E7Z0JBQzNELE1BQU0wSyxPQUFPLElBQUkxTCwwQ0FBTUEsQ0FBQ3NGLFFBQVEsQ0FBQ3RFLG1EQUFXQSxFQUFFcUUsS0FBS3RELGdCQUFnQkksTUFBTTtnQkFDekUsTUFBTStGLEtBQUssTUFBTXdELEtBQUtuTCxRQUFRLENBQUNQLDBDQUFNQSxDQUFDc0IsVUFBVSxDQUFDNko7Z0JBQ2pELE1BQU1qRCxHQUFHc0QsSUFBSTtnQkFDYjlKLFFBQVFzQyxHQUFHLENBQUMsMEJBQTBCbUg7Z0JBQ3RDLE9BQU87b0JBQUV4RCxRQUFRO29CQUFLQyxTQUFTO29CQUE2Qk8sTUFBTUQsR0FBR0MsSUFBSTtnQkFBQztZQUM1RSxFQUFFLE9BQU8xRyxPQUFPO2dCQUNkRCxZQUFZQztnQkFDWixPQUFPO29CQUFFa0csUUFBUTtvQkFBS0MsU0FBU25HLE1BQU1tRyxPQUFPLElBQUluRyxNQUFNb0csTUFBTTtnQkFBQztZQUMvRDtRQUNGOzRDQUFHO1FBQUM5RixnQkFBZ0JJLE1BQU07S0FBQztJQUUzQixnRUFBZ0U7SUFDaEUsTUFBTXdKLGdCQUFnQjlMLGtEQUFXQTtnREFBQyxPQUFPdUgsY0FBY0g7WUFDckQsSUFBSSxDQUFDbEYsZ0JBQWdCSSxNQUFNLEVBQUU7Z0JBQzNCLE1BQU0sSUFBSW1GLE1BQU07WUFDbEI7WUFFQSxJQUFJO2dCQUNGLE1BQU1qQyxNQUFNO29CQUFDO2lCQUFvQztnQkFDakQzRCxRQUFRc0MsR0FBRyxDQUFDLGtDQUFrQ29EO2dCQUM5QyxNQUFNdkIsUUFBUSxJQUFJN0YsMENBQU1BLENBQUNzRixRQUFRLENBQUM4QixjQUFjL0IsS0FBS3RELGdCQUFnQkksTUFBTTtnQkFDM0UsTUFBTStGLEtBQUssTUFBTXJDLE1BQU10RixRQUFRLENBQUNQLDBDQUFNQSxDQUFDc0IsVUFBVSxDQUFDMkY7Z0JBQ2xELE1BQU1pQixHQUFHc0QsSUFBSTtnQkFDYjlKLFFBQVFzQyxHQUFHLENBQUMsMkJBQTJCaUQ7Z0JBQ3ZDLE9BQU87b0JBQUVVLFFBQVE7b0JBQUtDLFNBQVM7b0JBQTBCTyxNQUFNRCxHQUFHQyxJQUFJO2dCQUFDO1lBQ3pFLEVBQUUsT0FBTzFHLE9BQU87Z0JBQ2RELFlBQVlDO2dCQUNaLE9BQU87b0JBQUVrRyxRQUFRO29CQUFLQyxTQUFTbkcsTUFBTW1HLE9BQU8sSUFBSW5HLE1BQU1vRyxNQUFNO2dCQUFDO1lBQy9EO1FBQ0Y7K0NBQUc7UUFBQzlGLGdCQUFnQkksTUFBTTtLQUFDO0lBRTNCLGtFQUFrRTtJQUNsRSxNQUFNeUosaUJBQWlCL0wsa0RBQVdBO2lEQUFDLE9BQU91SCxjQUFjK0Q7WUFDdEQsSUFBSSxDQUFDcEosZ0JBQWdCSSxNQUFNLEVBQUU7Z0JBQzNCLE1BQU0sSUFBSW1GLE1BQU07WUFDbEI7WUFFQSxJQUFJO2dCQUNGLE1BQU1qQyxNQUFNO29CQUFDO2lCQUE2QjtnQkFDMUMzRCxRQUFRc0MsR0FBRyxDQUFDLG1DQUFtQ29EO2dCQUMvQyxNQUFNdkIsUUFBUSxJQUFJN0YsMENBQU1BLENBQUNzRixRQUFRLENBQUM4QixjQUFjL0IsS0FBS3RELGdCQUFnQkksTUFBTTtnQkFDM0UsTUFBTStGLEtBQUssTUFBTXJDLE1BQU1nRyxPQUFPLENBQUM7b0JBQUVOLE9BQU92TCwwQ0FBTUEsQ0FBQ3NCLFVBQVUsQ0FBQzZKO2dCQUFXO2dCQUNyRSxNQUFNakQsR0FBR3NELElBQUk7Z0JBQ2I5SixRQUFRc0MsR0FBRyxDQUFDLDJCQUEyQm1IO2dCQUN2QyxPQUFPO29CQUFFeEQsUUFBUTtvQkFBS0MsU0FBUztvQkFBeUJPLE1BQU1ELEdBQUdDLElBQUk7Z0JBQUM7WUFDeEUsRUFBRSxPQUFPMUcsT0FBTztnQkFDZEQsWUFBWUM7Z0JBQ1osT0FBTztvQkFBRWtHLFFBQVE7b0JBQUtDLFNBQVNuRyxNQUFNbUcsT0FBTyxJQUFJbkcsTUFBTW9HLE1BQU07Z0JBQUM7WUFDL0Q7UUFDRjtnREFBRztRQUFDOUYsZ0JBQWdCSSxNQUFNO0tBQUM7SUFFM0IsbUJBQW1CO0lBQ25CLE1BQU0ySixVQUFVak0sa0RBQVdBOzBDQUFDO1lBQzFCLElBQUk7Z0JBQ0YsTUFBTTRGLFFBQVFDLEdBQUcsQ0FBQztvQkFDaEJIO29CQUNBNEQ7b0JBQ0FlO29CQUNBTTtvQkFDQTlCO2lCQUNEO2dCQUNEaEgsUUFBUXNDLEdBQUcsQ0FBQztZQUNkLEVBQUUsT0FBT3ZDLE9BQU87Z0JBQ2RELFlBQVlDO1lBQ2Q7UUFDRjt5Q0FBRztRQUFDOEQ7UUFBZTREO1FBQWlCZTtRQUFnQk07UUFBbUI5QjtLQUFlO0lBRXRGLDRCQUE0QjtJQUM1QixNQUFNcUQsa0JBQWtCbE0sa0RBQVdBO2tEQUFDLE9BQU84RztZQUN6QyxJQUFJLENBQUM1RSxnQkFBZ0JJLE1BQU0sRUFBRTtnQkFDM0IsTUFBTSxJQUFJbUYsTUFBTTtZQUNsQjtZQUVBLElBQUk7Z0JBQ0YsTUFBTWpDLE1BQU07b0JBQUM7aUJBQXVDO2dCQUNwRCxNQUFNdUQsT0FBTyxJQUFJNUksMENBQU1BLENBQUNzRixRQUFRLENBQUNyRixxREFBTUEsQ0FBQ3lILFlBQVksRUFBRXJDLEtBQUt0RCxnQkFBZ0JJLE1BQU07Z0JBQ2pGLE1BQU0rRixLQUFLLE1BQU1VLEtBQUtvRCxZQUFZLENBQUNyRjtnQkFDbkMsTUFBTXVCLEdBQUdzRCxJQUFJO2dCQUNiOUosUUFBUXNDLEdBQUcsQ0FBQyxnQ0FBZ0MyQztnQkFDNUMsT0FBTztvQkFBRWdCLFFBQVE7b0JBQUtDLFNBQVM7Z0JBQTRCO1lBQzdELEVBQUUsT0FBT25HLE9BQU87Z0JBQ2RELFlBQVlDO2dCQUNaLE9BQU87b0JBQUVrRyxRQUFRO29CQUFLQyxTQUFTbkcsTUFBTW1HLE9BQU8sSUFBSW5HLE1BQU1vRyxNQUFNO2dCQUFDO1lBQy9EO1FBQ0Y7aURBQUc7UUFBQzlGLGdCQUFnQkksTUFBTTtLQUFDO0lBRTNCLG1DQUFtQztJQUNuQyxNQUFNOEosK0JBQStCcE0sa0RBQVdBOytEQUFDO1lBQy9DLElBQUk7Z0JBQ0YsSUFBSSxDQUFDa0MsZ0JBQWdCRSxRQUFRLElBQUksQ0FBQ0YsZ0JBQWdCSyxjQUFjLEVBQUUsT0FBTztnQkFFekUsTUFBTWlELE1BQU07b0JBQ1Y7aUJBQ0Q7Z0JBQ0QsTUFBTXVELE9BQU8sSUFBSTVJLDBDQUFNQSxDQUFDc0YsUUFBUSxDQUFDckYscURBQU1BLENBQUN5SCxZQUFZLEVBQUVyQyxLQUFLdEQsZ0JBQWdCRSxRQUFRO2dCQUNuRixNQUFNaUssWUFBWSxNQUFNdEQsS0FBS3VELGlDQUFpQyxDQUFDcEssZ0JBQWdCSyxjQUFjLEVBQUU7Z0JBQy9GLE9BQU84QyxPQUFPbEYsMENBQU1BLENBQUMrRyxXQUFXLENBQUNtRixXQUFXO1lBQzlDLEVBQUUsT0FBT3pLLE9BQU87Z0JBQ2RELFlBQVlDO2dCQUNaLE9BQU87WUFDVDtRQUNGOzhEQUFHO1FBQUNNLGdCQUFnQkUsUUFBUTtRQUFFRixnQkFBZ0JLLGNBQWM7S0FBQztJQUU3RCw0QkFBNEI7SUFDNUIsTUFBTWdLLHdCQUF3QnZNLGtEQUFXQTt3REFBQyxPQUFPZ0csT0FBT29CO1lBQ3RELElBQUk7Z0JBQ0YsSUFBSSxDQUFDbEYsZ0JBQWdCRSxRQUFRLEVBQUUsT0FBTztnQkFFdEMsTUFBTW9ELE1BQU07b0JBQ1Y7aUJBQ0Q7Z0JBQ0QsTUFBTWdILFNBQVMsSUFBSXJNLDBDQUFNQSxDQUFDc0YsUUFBUSxDQUFDckYscURBQU1BLENBQUM0RyxZQUFZLEVBQUV4QixLQUFLdEQsZ0JBQWdCRSxRQUFRO2dCQUNyRixNQUFNcUssU0FBUyxNQUFNRCxPQUFPRCxxQkFBcUIsQ0FBQ3ZHLE9BQU83RiwwQ0FBTUEsQ0FBQ2lJLFVBQVUsQ0FBQ2hCLE9BQU8xRixRQUFRLElBQUk7Z0JBQzlGLE9BQU8yRCxPQUFPbEYsMENBQU1BLENBQUMrRyxXQUFXLENBQUN1RixRQUFRO1lBQzNDLEVBQUUsT0FBTzdLLE9BQU87Z0JBQ2RELFlBQVlDO2dCQUNaLE9BQU87WUFDVDtRQUNGO3VEQUFHO1FBQUNNLGdCQUFnQkUsUUFBUTtLQUFDO0lBRTdCLDBDQUEwQztJQUMxQyxNQUFNc0ssMEJBQTBCMU0sa0RBQVdBOzBEQUFDLE9BQU8yRjtZQUNqRCxNQUFNZ0gsYUFBYSxFQUFFO1lBQ3JCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJakgsT0FBT1IsTUFBTSxFQUFFeUgsSUFBSztnQkFDdEMsTUFBTTVHLFFBQVFMLE1BQU0sQ0FBQ2lILEVBQUUsQ0FBQzVHLEtBQUs7Z0JBQzdCLElBQUk2RyxVQUFVbEgsTUFBTSxDQUFDaUgsRUFBRSxDQUFDRSxPQUFPO2dCQUUvQixNQUFNekYsY0FBYyxNQUFNRixlQUFlbkIsT0FBTzZHO2dCQUNoREEsVUFBVXhILE9BQU9NLE1BQU0sQ0FBQ2lILEVBQUUsQ0FBQ0UsT0FBTyxJQUFJO2dCQUV0QyxNQUFNQyxrQkFBa0IsTUFBTVg7Z0JBQzlCLE1BQU1LLFNBQVMsTUFBTUYsc0JBQXNCdkcsT0FBTytHO2dCQUNsRCxNQUFNQyxNQUFNSCxXQUFXSixTQUFTSSxVQUFVSjtnQkFFMUNFLFdBQVdNLElBQUksQ0FBQztvQkFDZGpILE9BQU9MLE1BQU0sQ0FBQ2lILEVBQUUsQ0FBQzVHLEtBQUs7b0JBQ3RCQyxTQUFTNEc7b0JBQ1R6QyxLQUFLL0UsT0FBT00sTUFBTSxDQUFDaUgsRUFBRSxDQUFDTSxPQUFPO29CQUM3QkMsY0FBYzlGO29CQUNkK0YsV0FBV0o7Z0JBQ2I7WUFDRjtZQUNBLE9BQU9MO1FBQ1Q7eURBQUc7UUFBQ3hGO1FBQWdCaUY7UUFBOEJHO0tBQXNCO0lBRXhFLDBDQUEwQztJQUMxQyxNQUFNYywwQkFBMEJyTixrREFBV0E7MERBQUMsT0FBTzJGO1lBQ2pELE1BQU0ySCxjQUFjLEVBQUU7WUFDdEIsSUFBSyxJQUFJVixJQUFJLEdBQUdBLElBQUlqSCxPQUFPUixNQUFNLEVBQUV5SCxJQUFLO2dCQUN0QyxNQUFNNUcsUUFBUUwsTUFBTSxDQUFDaUgsRUFBRSxDQUFDNUcsS0FBSztnQkFDN0IsTUFBTXVILFlBQVk1SCxNQUFNLENBQUNpSCxFQUFFLENBQUNXLFNBQVM7Z0JBQ3JDLE1BQU1DLFlBQVk3SCxNQUFNLENBQUNpSCxFQUFFLENBQUNZLFNBQVM7Z0JBQ3JDLE1BQU1uRyxjQUFjLE1BQU1GLGVBQWVuQixPQUFPdUg7Z0JBRWhERCxZQUFZTCxJQUFJLENBQUM7b0JBQ2ZqSCxPQUFPQTtvQkFDUHVILFdBQVdsSSxPQUFPa0k7b0JBQ2xCQyxXQUFXbkksT0FBT21JO29CQUNsQkMsa0JBQWtCcEc7Z0JBQ3BCO1lBQ0Y7WUFDQSxPQUFPaUc7UUFDVDt5REFBRztRQUFDbkc7S0FBZTtJQUVuQiwyQ0FBMkM7SUFDM0MsTUFBTXVHLHlCQUF5QjFOLGtEQUFXQTt5REFBQyxDQUFDMkY7WUFDMUMsTUFBTWdJLFNBQVN2TixxREFBTUEsQ0FBQzBGLE1BQU0sQ0FDekIwRCxNQUFNO3dFQUFDLENBQUNvRTtvQkFDUCxPQUFPakksT0FBT2tJLElBQUk7Z0ZBQUMsQ0FBQ0M7NEJBQ2xCLE9BQU9GLFVBQVVySSxPQUFPLENBQUNxQyxXQUFXLE9BQU9rRyxVQUFVOUgsS0FBSyxDQUFDNEIsV0FBVzt3QkFDeEU7O2dCQUNGO3VFQUNDN0IsR0FBRzt3RUFBQyxDQUFDZ0ksV0FBYzt3QkFDbEIsR0FBR3BJLE9BQU8rQixJQUFJO29GQUFDLENBQUNzRyxPQUFTQSxLQUFLaEksS0FBSyxDQUFDNEIsV0FBVyxPQUFPbUcsU0FBU3hJLE9BQU8sQ0FBQ3FDLFdBQVc7a0ZBQUc7d0JBQ3JGLEdBQUdtRyxRQUFRO29CQUNiOztZQUNGLE9BQU9KO1FBQ1Q7d0RBQUcsRUFBRTtJQUVMLGdCQUFnQjtJQUNoQixNQUFNTSxlQUFlaE8sOENBQU9BOzJDQUFDLElBQU87Z0JBQ2xDLFFBQVE7Z0JBQ1JpQztnQkFDQU87Z0JBQ0FFO2dCQUNBRTtnQkFDQUU7Z0JBQ0FNO2dCQUNBSztnQkFDQUc7Z0JBQ0FaO2dCQUVBLG1CQUFtQjtnQkFDbkJpQjtnQkFDQStIO2dCQUVBLGtCQUFrQjtnQkFDbEJ2RztnQkFDQTREO2dCQUNBZTtnQkFDQU07Z0JBRUEsd0JBQXdCO2dCQUN4QnJEO2dCQUNBVztnQkFDQU07Z0JBQ0FFO2dCQUNBRTtnQkFFQSxvQkFBb0I7Z0JBQ3BCckQ7Z0JBQ0FtQjtnQkFDQVU7Z0JBQ0E1RjtnQkFDQUk7Z0JBRUEscUJBQXFCO2dCQUNyQjBKO2dCQUNBTztnQkFFQSxvQkFBb0I7Z0JBQ3BCL0M7Z0JBQ0F1RDtnQkFDQUc7Z0JBRUEsNEJBQTRCO2dCQUM1Qkc7Z0JBQ0FXO2dCQUNBSztnQkFFQSxxQkFBcUI7Z0JBQ3JCeEI7Z0JBRUEsbUNBQW1DO2dCQUNuQ0o7Z0JBQ0FDO1lBQ0Y7MENBQUk7UUFDRjdKO1FBQ0FPO1FBQ0FFO1FBQ0FFO1FBQ0FFO1FBQ0FNO1FBQ0FLO1FBQ0FHO1FBQ0FaO1FBQ0FpQjtRQUNBK0g7UUFDQXZHO1FBQ0E0RDtRQUNBZTtRQUNBTTtRQUNBckQ7UUFDQVc7UUFDQU07UUFDQUU7UUFDQUU7UUFDQXJEO1FBQ0FtQjtRQUNBVTtRQUNBa0U7UUFDQU87UUFDQS9DO1FBQ0F1RDtRQUNBRztRQUNBRztRQUNBVztRQUNBSztRQUNBeEI7S0FDRDtJQUVELHFCQUNFLDhEQUFDaE0sNkRBQW9CO1FBQUN3TCxPQUFPdUM7a0JBQzFCaE0sTUFBTWtNLFFBQVE7Ozs7OztBQUdyQjtHQW4zQk1uTTtLQUFBQTtBQXEzQk4saUVBQWVBLFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxzcmNcXGNvbnRleHRcXExlbmRTdGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgbGVuZENvbnRleHQgZnJvbSBcIi4vbGVuZENvbnRleHRcIjtcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gXCJldGhlcnNcIjtcbmltcG9ydCB7IENPTkZJRyB9IGZyb20gXCIuLi9jb25maWcvY29udHJhY3RzXCI7XG5pbXBvcnQgeyBnZXRUb2tlbkJhbGFuY2UsIGdldFRva2VuQWxsb3dhbmNlLCBhcHByb3ZlSWZOZWVkZWQsIGxlbmQgYXMgbGVuZFR4LCB3aXRoZHJhdyBhcyB3aXRoZHJhd1R4LCBib3Jyb3cgYXMgYm9ycm93VHgsIHJlcGF5IGFzIHJlcGF5VHggfSBmcm9tIFwiLi4vbGliL3R4XCI7XG5pbXBvcnQgeyBFVEhBZGRyZXNzLCBMZW5kaW5nUG9vbEFkZHJlc3MsIExlbmRpbmdIZWxwZXJBZGRyZXNzLCBXRVRIQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzZXNcIjtcbmltcG9ydCB7IFRva2VuQUJJLCBMZW5kaW5nUG9vbEFCSSwgTGVuZGluZ0hlbHBlckFCSSB9IGZyb20gXCIuLi9hYmlzXCI7XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zXG5jb25zdCBudW1iZXJUb0V0aGVycyA9IChudW1iZXIpID0+IHtcbiAgcmV0dXJuIGV0aGVycy5wYXJzZUV0aGVyKG51bWJlci50b1N0cmluZygpKTtcbn07XG5cbmNvbnN0IHJlcG9ydEVycm9yID0gKGVycm9yKSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoXCJMZW5kU3RhdGUgRXJyb3I6XCIsIEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XG4gIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkZXRhaWxzOlwiLCBlcnJvcik7XG59O1xuXG5jb25zdCBMZW5kU3RhdGUgPSAocHJvcHMpID0+IHtcbiAgLy8qIERlY2xhcmluZyBhbGwgdGhlIHN0YXRlc1xuXG4gIC8vIFNldCBtZXRhbWFzayBkZXRhaWxzXG4gIGNvbnN0IFttZXRhbWFza0RldGFpbHMsIHNldE1ldGFtYXNrRGV0YWlsc10gPSB1c2VTdGF0ZSh7XG4gICAgcHJvdmlkZXI6IG51bGwsXG4gICAgbmV0d29ya05hbWU6IG51bGwsXG4gICAgc2lnbmVyOiBudWxsLFxuICAgIGN1cnJlbnRBY2NvdW50OiBudWxsLFxuICAgIGNoYWluSWQ6IG51bGwsXG4gIH0pO1xuXG4gIC8vIFVzZXIgYXNzZXRzIGFuZCBiYWxhbmNlc1xuICBjb25zdCBbdXNlckFzc2V0cywgc2V0VXNlckFzc2V0c10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtzdXBwbHlBc3NldHMsIHNldFN1cHBseUFzc2V0c10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFthc3NldHNUb0JvcnJvdywgc2V0QXNzZXRzVG9Cb3Jyb3ddID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbeW91ckJvcnJvd3MsIHNldFlvdXJCb3Jyb3dzXSA9IHVzZVN0YXRlKFtdKTtcblxuICAvLyBDb250cmFjdCBkZXRhaWxzXG4gIGNvbnN0IFtjb250cmFjdCwgc2V0Q29udHJhY3RdID0gdXNlU3RhdGUoe1xuICAgIGxlbmRpbmdQb29sQ29udHJhY3Q6IG51bGwsXG4gICAgb3JhY2xlQ29udHJhY3Q6IG51bGwsXG4gIH0pO1xuXG4gIC8vIFN1bW1hcnkgZGF0YVxuICBjb25zdCBbc3VwcGx5U3VtbWFyeSwgc2V0U3VwcGx5U3VtbWFyeV0gPSB1c2VTdGF0ZSh7XG4gICAgdG90YWxVU0RCYWxhbmNlOiAwLFxuICAgIHdlaWdodGVkQXZnQVBZOiAwLFxuICAgIHRvdGFsVVNEQ29sbGF0ZXJhbDogMCxcbiAgfSk7XG5cbiAgY29uc3QgW2JvcnJvd1N1bW1hcnksIHNldEJvcnJvd1N1bW1hcnldID0gdXNlU3RhdGUoe1xuICAgIHRvdGFsVVNEQmFsYW5jZTogMCxcbiAgICB3ZWlnaHRlZEF2Z0FQWTogMCxcbiAgICB0b3RhbEJvcnJvd1Bvd2VyVXNlZDogMCxcbiAgfSk7XG5cbiAgLy8gQWNjb3VudCBkYXRhXG4gIGNvbnN0IFthY2NvdW50RGF0YSwgc2V0QWNjb3VudERhdGFdID0gdXNlU3RhdGUoe1xuICAgIGNvbGxhdGVyYWxVU0Q6IFwiMFwiLFxuICAgIGRlYnRVU0Q6IFwiMFwiLFxuICAgIGhlYWx0aEZhY3RvcjogXCIwXCIsXG4gIH0pO1xuXG4gIC8vIENvbm5lY3Qgd2FsbGV0XG4gIC8vIGNvbnN0IGNvbm5lY3RXYWxsZXQgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gIC8vICAgY29uc29sZS5sb2coXCIxLiBDb25uZWN0aW5nIHRvIHdhbGxldC4uLlwiKTtcbiAgLy8gICBjb25zdCB7IGV0aGVyZXVtIH0gPSB3aW5kb3c7XG4gIC8vICAgY29uc3QgZmFpbE1lc3NhZ2UgPSBcIlBsZWFzZSBpbnN0YWxsIE1ldGFtYXNrICYgY29ubmVjdCB5b3VyIE1ldGFtYXNrXCI7XG4gICAgXG4gIC8vICAgdHJ5IHtcbiAgLy8gICAgIGlmICghZXRoZXJldW0pIHtcbiAgLy8gICAgICAgYWxlcnQoZmFpbE1lc3NhZ2UpO1xuICAvLyAgICAgICByZXR1cm47XG4gIC8vICAgICB9XG5cbiAgLy8gICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgZXRoZXJldW0ucmVxdWVzdCh7XG4gIC8vICAgICAgIG1ldGhvZDogXCJldGhfcmVxdWVzdEFjY291bnRzXCIsXG4gIC8vICAgICB9KTtcblxuICAvLyAgICAgLy8gTGlzdGVuIGZvciBhY2NvdW50IGFuZCBjaGFpbiBjaGFuZ2VzXG4gIC8vICAgICBldGhlcmV1bS5vbihcImNoYWluQ2hhbmdlZFwiLCAoKSA9PiB7XG4gIC8vICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgLy8gICAgIH0pO1xuICAvLyAgICAgZXRoZXJldW0ub24oXCJhY2NvdW50c0NoYW5nZWRcIiwgKCkgPT4ge1xuICAvLyAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gIC8vICAgICB9KTtcblxuICAvLyAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkJyb3dzZXJQcm92aWRlcihldGhlcmV1bSk7XG4gIC8vICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgcHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAvLyAgICAgY29uc3QgbmV0d29ya05hbWUgPSBuZXR3b3JrLm5hbWU7XG4gIC8vICAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcblxuICAvLyAgICAgaWYgKGFjY291bnRzLmxlbmd0aCkge1xuICAvLyAgICAgICBsZXQgY3VycmVudEFkZHJlc3MgPSBhY2NvdW50c1swXTtcbiAgLy8gICAgICAgc2V0TWV0YW1hc2tEZXRhaWxzKHtcbiAgLy8gICAgICAgICBwcm92aWRlcjogcHJvdmlkZXIsXG4gIC8vICAgICAgICAgbmV0d29ya05hbWU6IG5ldHdvcmtOYW1lLFxuICAvLyAgICAgICAgIHNpZ25lcjogc2lnbmVyLFxuICAvLyAgICAgICAgIGN1cnJlbnRBY2NvdW50OiBjdXJyZW50QWRkcmVzcyxcbiAgLy8gICAgICAgICBjaGFpbklkOiBOdW1iZXIobmV0d29yay5jaGFpbklkKSxcbiAgLy8gICAgICAgfSk7XG4gIC8vICAgICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdGVkIHRvIHdhbGxldDpcIiwgY3VycmVudEFkZHJlc3MpO1xuICAvLyAgICAgfSBlbHNlIHtcbiAgLy8gICAgICAgYWxlcnQoZmFpbE1lc3NhZ2UpO1xuICAvLyAgICAgICByZXR1cm47XG4gIC8vICAgICB9XG4gIC8vICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgLy8gICAgIHJlcG9ydEVycm9yKGVycm9yKTtcbiAgLy8gICB9XG4gIC8vIH0sIFtdKTtcblxuICBjb25zdCBjb25uZWN0V2FsbGV0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiMS4gQ29ubmVjdGluZyB0byB3YWxsZXQuLi5cIik7XG4gICAgY29uc3QgeyBldGhlcmV1bSB9ID0gd2luZG93O1xuICAgIGNvbnN0IGZhaWxNZXNzYWdlID0gXCJQbGVhc2UgaW5zdGFsbCBNZXRhbWFzayAmIGNvbm5lY3QgeW91ciBNZXRhbWFza1wiO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWV0aGVyZXVtKSB7XG4gICAgICAgIGFsZXJ0KGZhaWxNZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGV0aGVyZXVtLnJlcXVlc3QoeyBtZXRob2Q6IFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiIH0pO1xuXG4gICAgICAvLyBMaXN0ZW4gZm9yIGFjY291bnQgYW5kIGNoYWluIGNoYW5nZXNcbiAgICAgIGV0aGVyZXVtLm9uKFwiY2hhaW5DaGFuZ2VkXCIsICgpID0+IHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgfSk7XG4gICAgICBldGhlcmV1bS5vbihcImFjY291bnRzQ2hhbmdlZFwiLCAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuQnJvd3NlclByb3ZpZGVyKGV0aGVyZXVtKTtcbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBwcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICBjb25zdCBuZXR3b3JrTmFtZSA9IG5ldHdvcmsubmFtZTtcbiAgICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xuXG4gICAgICBpZiAoYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBjdXJyZW50QWRkcmVzcyA9IGFjY291bnRzWzBdO1xuICAgICAgICBzZXRNZXRhbWFza0RldGFpbHMoe1xuICAgICAgICAgIHByb3ZpZGVyOiBwcm92aWRlcixcbiAgICAgICAgICBuZXR3b3JrTmFtZTogbmV0d29ya05hbWUsXG4gICAgICAgICAgc2lnbmVyOiBzaWduZXIsXG4gICAgICAgICAgY3VycmVudEFjY291bnQ6IGN1cnJlbnRBZGRyZXNzLFxuICAgICAgICAgIGNoYWluSWQ6IE51bWJlcihuZXR3b3JrLmNoYWluSWQpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0ZWQgdG8gd2FsbGV0KysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKzpcIiwgY3VycmVudEFkZHJlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxlcnQoZmFpbE1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydEVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBHZXQgY29udHJhY3QgaW5zdGFuY2VcbiAgY29uc3QgZ2V0Q29udHJhY3QgPSB1c2VDYWxsYmFjayhhc3luYyAoYWRkcmVzcywgYWJpKSA9PiB7XG4gICAgaWYgKCFtZXRhbWFza0RldGFpbHMucHJvdmlkZXIpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChhZGRyZXNzLCBhYmksIG1ldGFtYXNrRGV0YWlscy5wcm92aWRlcik7XG4gICAgcmV0dXJuIGNvbnRyYWN0O1xuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyXSk7XG5cbiAgLy8gR2V0IHVzZXIgYXNzZXRzIChiYWxhbmNlcylcbiAgY29uc3QgZ2V0VXNlckFzc2V0cyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIjIuIEdldHRpbmcgdXNlciBhc3NldHMuLi5cIik7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyIHx8ICFtZXRhbWFza0RldGFpbHMuY3VycmVudEFjY291bnQpIHJldHVybiBbXTtcblxuICAgICAgY29uc3QgYXNzZXRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIENPTkZJRy5UT0tFTlMubWFwKGFzeW5jICh0b2tlbikgPT4ge1xuICAgICAgICAgIGxldCBiYWxhbmNlID0gXCIwXCI7XG4gICAgICAgICAgbGV0IGJhbGFuY2VVU0QgPSAwO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0b2tlbi5pc05hdGl2ZSkge1xuICAgICAgICAgICAgICAvLyBFVEggbmF0aXZlIGJhbGFuY2VcbiAgICAgICAgICAgICAgY29uc3QgYmFsID0gYXdhaXQgbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyLmdldEJhbGFuY2UobWV0YW1hc2tEZXRhaWxzLmN1cnJlbnRBY2NvdW50KTtcbiAgICAgICAgICAgICAgYmFsYW5jZSA9IGV0aGVycy5mb3JtYXRFdGhlcihiYWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gRVJDMjAgdG9rZW4gYmFsYW5jZVxuICAgICAgICAgICAgICBiYWxhbmNlID0gYXdhaXQgZ2V0VG9rZW5CYWxhbmNlKFxuICAgICAgICAgICAgICAgIG1ldGFtYXNrRGV0YWlscy5wcm92aWRlcixcbiAgICAgICAgICAgICAgICB0b2tlbi5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIG1ldGFtYXNrRGV0YWlscy5jdXJyZW50QWNjb3VudCxcbiAgICAgICAgICAgICAgICB0b2tlbi5kZWNpbWFsc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgVVNEIHZhbHVlXG4gICAgICAgICAgICBjb25zdCBwcmljZSA9IGF3YWl0IGdldFByaWNlVVNEKHRva2VuLmFkZHJlc3MpO1xuICAgICAgICAgICAgYmFsYW5jZVVTRCA9IHBhcnNlRmxvYXQoYmFsYW5jZSkgKiBwYXJzZUZsb2F0KHByaWNlKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgYWRkcmVzczogdG9rZW4uYWRkcmVzcyxcbiAgICAgICAgICAgICAgc3ltYm9sOiB0b2tlbi5zeW1ib2wsXG4gICAgICAgICAgICAgIG5hbWU6IHRva2VuLm5hbWUsXG4gICAgICAgICAgICAgIGRlY2ltYWxzOiB0b2tlbi5kZWNpbWFscyxcbiAgICAgICAgICAgICAgaXNOYXRpdmU6IHRva2VuLmlzTmF0aXZlLFxuICAgICAgICAgICAgICBiYWxhbmNlOiBiYWxhbmNlLFxuICAgICAgICAgICAgICBiYWxhbmNlVVNEOiBiYWxhbmNlVVNELFxuICAgICAgICAgICAgICBwcmljZVVTRDogcHJpY2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEVycm9yIGdldHRpbmcgYmFsYW5jZSBmb3IgJHt0b2tlbi5zeW1ib2x9OmAsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGFkZHJlc3M6IHRva2VuLmFkZHJlc3MsXG4gICAgICAgICAgICAgIHN5bWJvbDogdG9rZW4uc3ltYm9sLFxuICAgICAgICAgICAgICBuYW1lOiB0b2tlbi5uYW1lLFxuICAgICAgICAgICAgICBkZWNpbWFsczogdG9rZW4uZGVjaW1hbHMsXG4gICAgICAgICAgICAgIGlzTmF0aXZlOiB0b2tlbi5pc05hdGl2ZSxcbiAgICAgICAgICAgICAgYmFsYW5jZTogXCIwXCIsXG4gICAgICAgICAgICAgIGJhbGFuY2VVU0Q6IDAsXG4gICAgICAgICAgICAgIHByaWNlVVNEOiBcIjBcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgc2V0VXNlckFzc2V0cyhhc3NldHMpO1xuICAgICAgY29uc29sZS5sb2coXCJHb3QgdXNlciBhc3NldHM6XCIsIGFzc2V0cyk7XG4gICAgICByZXR1cm4gYXNzZXRzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyLCBtZXRhbWFza0RldGFpbHMuY3VycmVudEFjY291bnRdKTtcblxuICAvLyBHZXQgcHJpY2UgaW4gVVNEXG4gIGNvbnN0IGdldFByaWNlVVNEID0gdXNlQ2FsbGJhY2soYXN5bmMgKGFzc2V0KSA9PiB7XG4gICAgaWYgKCFtZXRhbWFza0RldGFpbHMucHJvdmlkZXIpIHJldHVybiBcIjBcIjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYWJpID0gWydmdW5jdGlvbiBnZXRBc3NldFByaWNlMWUxOChhZGRyZXNzIGFzc2V0KSB2aWV3IHJldHVybnMgKHVpbnQyNTYpJ107XG4gICAgICBjb25zdCBvcmFjbGUgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KENPTkZJRy5QUklDRV9PUkFDTEUsIGFiaSwgbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyKTtcbiAgICAgIGNvbnN0IHByaWNlID0gYXdhaXQgb3JhY2xlLmdldEFzc2V0UHJpY2UxZTE4KGFzc2V0KTtcbiAgICAgIHJldHVybiBldGhlcnMuZm9ybWF0VW5pdHMocHJpY2UsIDE4KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKGBFcnJvciBnZXR0aW5nIHByaWNlIGZvciAke2Fzc2V0fTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gXCIwXCI7XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyXSk7XG5cbiAgLy8gR2V0IGFtb3VudCBpbiBVU0RcbiAgY29uc3QgZ2V0QW1vdW50SW5VU0QgPSB1c2VDYWxsYmFjayhhc3luYyAoYWRkcmVzcywgYW1vdW50KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByaWNlID0gYXdhaXQgZ2V0UHJpY2VVU0QoYWRkcmVzcyk7XG4gICAgICBjb25zdCBhbW91bnRJblVTRCA9IHBhcnNlRmxvYXQoYW1vdW50KSAqIHBhcnNlRmxvYXQocHJpY2UpO1xuICAgICAgcmV0dXJuIGFtb3VudEluVVNEO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sIFtnZXRQcmljZVVTRF0pO1xuXG4gIC8vIEFwcHJvdmUgdG9rZW5zXG4gIGNvbnN0IEFwcHJvdmVUb0NvbnRpbnVlID0gdXNlQ2FsbGJhY2soYXN5bmMgKHRva2VuQWRkcmVzcywgYXBwcm92ZUFtb3VudCkgPT4ge1xuICAgIGlmICghbWV0YW1hc2tEZXRhaWxzLnNpZ25lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmVyIGF2YWlsYWJsZVwiKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdG9rZW4gPSBDT05GSUcuVE9LRU5TLmZpbmQodCA9PiB0LmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gdG9rZW5BZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKCF0b2tlbikgdGhyb3cgbmV3IEVycm9yKFwiVG9rZW4gbm90IGZvdW5kXCIpO1xuXG4gICAgICBhd2FpdCBhcHByb3ZlSWZOZWVkZWQoXG4gICAgICAgIG1ldGFtYXNrRGV0YWlscy5zaWduZXIsXG4gICAgICAgIHRva2VuQWRkcmVzcyxcbiAgICAgICAgQ09ORklHLkxFTkRJTkdfUE9PTCxcbiAgICAgICAgYXBwcm92ZUFtb3VudCxcbiAgICAgICAgdG9rZW4uZGVjaW1hbHNcbiAgICAgICk7XG5cbiAgICAgIGNvbnNvbGUubG9nKFwiVG9rZW4gYXBwcm92ZWQ6XCIsIHRva2VuQWRkcmVzcyk7XG4gICAgICByZXR1cm4geyBzdGF0dXM6IDIwMCwgbWVzc2FnZTogXCJUcmFuc2FjdGlvbiBTdWNjZXNzZnVsLi4uXCIgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiA1MDAsIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IucmVhc29uIH07XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnNpZ25lcl0pO1xuXG4gIC8vIExlbmQgYXNzZXRcbiAgY29uc3QgTGVuZEFzc2V0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKHRva2VuLCBzdXBwbHlBbW91bnQpID0+IHtcbiAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5zaWduZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRva2VuSW5mbyA9IENPTkZJRy5UT0tFTlMuZmluZCh0ID0+IHQuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSB0b2tlbi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIGlmICghdG9rZW5JbmZvKSB0aHJvdyBuZXcgRXJyb3IoXCJUb2tlbiBub3QgZm91bmRcIik7XG5cbiAgICAgIGNvbnN0IGFtb3VudCA9IGV0aGVycy5wYXJzZVVuaXRzKHN1cHBseUFtb3VudCwgdG9rZW5JbmZvLmRlY2ltYWxzKTtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgbGVuZFR4KG1ldGFtYXNrRGV0YWlscy5zaWduZXIsIHRva2VuLCBhbW91bnQpO1xuICAgICAgXG4gICAgICBpZiAodHgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJBc3NldCBsZW50IHN1Y2Nlc3NmdWxseTpcIiwgdG9rZW4sIHN1cHBseUFtb3VudCk7XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogMjAwLCBtZXNzYWdlOiBcIlRyYW5zYWN0aW9uIFN1Y2Nlc3NmdWwuLi5cIiwgaGFzaDogdHguaGFzaCB9O1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gZmFpbGVkXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4geyBzdGF0dXM6IDUwMCwgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB8fCBlcnJvci5yZWFzb24gfTtcbiAgICB9XG4gIH0sIFttZXRhbWFza0RldGFpbHMuc2lnbmVyXSk7XG5cbiAgLy8gV2l0aGRyYXcgYXNzZXRcbiAgY29uc3QgV2l0aGRyYXdBc3NldCA9IHVzZUNhbGxiYWNrKGFzeW5jICh0b2tlbkFkZHJlc3MsIHdpdGhkcmF3QW1vdW50KSA9PiB7XG4gICAgaWYgKCFtZXRhbWFza0RldGFpbHMuc2lnbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0b2tlbkluZm8gPSBDT05GSUcuVE9LRU5TLmZpbmQodCA9PiB0LmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gdG9rZW5BZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKCF0b2tlbkluZm8pIHRocm93IG5ldyBFcnJvcihcIlRva2VuIG5vdCBmb3VuZFwiKTtcblxuICAgICAgY29uc3QgYW1vdW50ID0gZXRoZXJzLnBhcnNlVW5pdHMod2l0aGRyYXdBbW91bnQsIHRva2VuSW5mby5kZWNpbWFscyk7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IHdpdGhkcmF3VHgobWV0YW1hc2tEZXRhaWxzLnNpZ25lciwgdG9rZW5BZGRyZXNzLCBhbW91bnQpO1xuICAgICAgXG4gICAgICBpZiAodHgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJBc3NldCB3aXRoZHJhd24gc3VjY2Vzc2Z1bGx5OlwiLCB0b2tlbkFkZHJlc3MsIHdpdGhkcmF3QW1vdW50KTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAyMDAsIG1lc3NhZ2U6IFwiVHJhbnNhY3Rpb24gU3VjY2Vzc2Z1bC4uLlwiLCBoYXNoOiB0eC5oYXNoIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2FjdGlvbiBmYWlsZWRcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydEVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogNTAwLCBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8IGVycm9yLnJlYXNvbiB9O1xuICAgIH1cbiAgfSwgW21ldGFtYXNrRGV0YWlscy5zaWduZXJdKTtcblxuICAvLyBCb3Jyb3cgYXNzZXRcbiAgY29uc3QgYm9ycm93QXNzZXQgPSB1c2VDYWxsYmFjayhhc3luYyAodG9rZW4sIGJvcnJvd0Ftb3VudCkgPT4ge1xuICAgIGlmICghbWV0YW1hc2tEZXRhaWxzLnNpZ25lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmVyIGF2YWlsYWJsZVwiKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdG9rZW5JbmZvID0gQ09ORklHLlRPS0VOUy5maW5kKHQgPT4gdC5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IHRva2VuLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKCF0b2tlbkluZm8pIHRocm93IG5ldyBFcnJvcihcIlRva2VuIG5vdCBmb3VuZFwiKTtcblxuICAgICAgY29uc3QgYW1vdW50ID0gZXRoZXJzLnBhcnNlVW5pdHMoYm9ycm93QW1vdW50LCB0b2tlbkluZm8uZGVjaW1hbHMpO1xuICAgICAgY29uc3QgdHggPSBhd2FpdCBib3Jyb3dUeChtZXRhbWFza0RldGFpbHMuc2lnbmVyLCB0b2tlbiwgYW1vdW50KTtcbiAgICAgIFxuICAgICAgaWYgKHR4KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQXNzZXQgYm9ycm93ZWQgc3VjY2Vzc2Z1bGx5OlwiLCB0b2tlbiwgYm9ycm93QW1vdW50KTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAyMDAsIG1lc3NhZ2U6IFwiVHJhbnNhY3Rpb24gU3VjY2Vzc2Z1bC4uLlwiLCBoYXNoOiB0eC5oYXNoIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2FjdGlvbiBmYWlsZWRcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydEVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogNTAwLCBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8IGVycm9yLnJlYXNvbiB9O1xuICAgIH1cbiAgfSwgW21ldGFtYXNrRGV0YWlscy5zaWduZXJdKTtcblxuICAvLyBSZXBheSBhc3NldFxuICBjb25zdCByZXBheUFzc2V0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKHRva2VuQWRkcmVzcywgcmVwYXlBbW91bnQpID0+IHtcbiAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5zaWduZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRva2VuSW5mbyA9IENPTkZJRy5UT0tFTlMuZmluZCh0ID0+IHQuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSB0b2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICBpZiAoIXRva2VuSW5mbykgdGhyb3cgbmV3IEVycm9yKFwiVG9rZW4gbm90IGZvdW5kXCIpO1xuXG4gICAgICBjb25zdCBhbW91bnQgPSBldGhlcnMucGFyc2VVbml0cyhyZXBheUFtb3VudCwgdG9rZW5JbmZvLmRlY2ltYWxzKTtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcmVwYXlUeChtZXRhbWFza0RldGFpbHMuc2lnbmVyLCB0b2tlbkFkZHJlc3MsIGFtb3VudCk7XG4gICAgICBcbiAgICAgIGlmICh0eCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFzc2V0IHJlcGFpZCBzdWNjZXNzZnVsbHk6XCIsIHRva2VuQWRkcmVzcywgcmVwYXlBbW91bnQpO1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IDIwMCwgbWVzc2FnZTogXCJUcmFuc2FjdGlvbiBTdWNjZXNzZnVsLi4uXCIsIGhhc2g6IHR4Lmhhc2ggfTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIGZhaWxlZFwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiA1MDAsIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IucmVhc29uIH07XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnNpZ25lcl0pO1xuXG4gIC8vIEdldCBhY2NvdW50IGRhdGEgKGNvbGxhdGVyYWwsIGRlYnQsIGhlYWx0aCBmYWN0b3IpXG4gIGNvbnN0IGdldEFjY291bnREYXRhID0gdXNlQ2FsbGJhY2soYXN5bmMgKHVzZXIpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFtZXRhbWFza0RldGFpbHMucHJvdmlkZXIpIHJldHVybiBudWxsO1xuXG4gICAgICBjb25zdCBwb29sID0gbmV3IGV0aGVycy5Db250cmFjdChMZW5kaW5nUG9vbEFkZHJlc3MsIExlbmRpbmdQb29sQUJJLmFiaSwgbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyKTtcbiAgICAgIGNvbnN0IHdhbGxldCA9IHVzZXIgfHwgbWV0YW1hc2tEZXRhaWxzLmN1cnJlbnRBY2NvdW50IHx8IGV0aGVycy5aZXJvQWRkcmVzcztcbiAgICAgIFxuICAgICAgLy8gQWRkIGVycm9yIGhhbmRsaW5nIGZvciBlbXB0eSByZXNwb25zZVxuICAgICAgbGV0IGNvbCwgZGVidCwgaGY7XG4gICAgICB0cnkge1xuICAgICAgICBbY29sLCBkZWJ0LCBoZl0gPSBhd2FpdCBwb29sLmdldEFjY291bnREYXRhKHdhbGxldCk7XG4gICAgICB9IGNhdGNoIChjb250cmFjdEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCBnZXRBY2NvdW50RGF0YSBmYWlsZWQsIHVzaW5nIGRlZmF1bHRzOicsIGNvbnRyYWN0RXJyb3IubWVzc2FnZSk7XG4gICAgICAgIC8vIFJldHVybiBkZWZhdWx0IHZhbHVlcyBmb3IgbmV3IHVzZXJzXG4gICAgICAgIGNvbCA9IGV0aGVycy5wYXJzZVVuaXRzKFwiMFwiLCAxOCk7XG4gICAgICAgIGRlYnQgPSBldGhlcnMucGFyc2VVbml0cyhcIjBcIiwgMTgpO1xuICAgICAgICBoZiA9IGV0aGVycy5wYXJzZVVuaXRzKFwiMTE1NzkyMDg5MjM3MzE2MTk1NDIzNTcwOTg1MDA4Njg3OTA3ODUzMjY5OTg0NjY1NjQwNTY0MDM5NDU3LjU4NDAwNzkxMzEyOTYzOTkzNVwiLCAxOCk7IC8vIE1heCB1aW50MjU2XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGFjY291bnREYXRhID0ge1xuICAgICAgICBjb2xsYXRlcmFsVVNEOiBldGhlcnMuZm9ybWF0VW5pdHMoY29sLCAxOCksXG4gICAgICAgIGRlYnRVU0Q6IGV0aGVycy5mb3JtYXRVbml0cyhkZWJ0LCAxOCksXG4gICAgICAgIGhlYWx0aEZhY3RvcjogZXRoZXJzLmZvcm1hdFVuaXRzKGhmLCAxOClcbiAgICAgIH07XG5cbiAgICAgIHNldEFjY291bnREYXRhKGFjY291bnREYXRhKTtcbiAgICAgIHJldHVybiBhY2NvdW50RGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coJ2dldEFjY291bnREYXRhIGVycm9yLCB1c2luZyBkZWZhdWx0czonLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIC8vIFJldHVybiBkZWZhdWx0IHZhbHVlcyBvbiBhbnkgZXJyb3JcbiAgICAgIGNvbnN0IGFjY291bnREYXRhID0ge1xuICAgICAgICBjb2xsYXRlcmFsVVNEOiBcIjBcIixcbiAgICAgICAgZGVidFVTRDogXCIwXCIsIFxuICAgICAgICBoZWFsdGhGYWN0b3I6IFwiMTE1NzkyMDg5MjM3MzE2MTk1NDIzNTcwOTg1MDA4Njg3OTA3ODUzMjY5OTg0NjY1NjQwNTY0MDM5NDU3LjU4NDAwNzkxMzEyOTYzOTkzNVwiXG4gICAgICB9O1xuICAgICAgc2V0QWNjb3VudERhdGEoYWNjb3VudERhdGEpO1xuICAgICAgcmV0dXJuIGFjY291bnREYXRhO1xuICAgIH1cbiAgfSwgW21ldGFtYXNrRGV0YWlscy5wcm92aWRlciwgbWV0YW1hc2tEZXRhaWxzLmN1cnJlbnRBY2NvdW50XSk7XG5cbiAgLy8gR2V0IHlvdXIgc3VwcGxpZXNcbiAgY29uc3QgZ2V0WW91clN1cHBsaWVzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiMy4gR2V0dGluZyB5b3VyIHN1cHBsaWVzLi4uXCIpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5wcm92aWRlciB8fCAhbWV0YW1hc2tEZXRhaWxzLmN1cnJlbnRBY2NvdW50KSByZXR1cm4gW107XG5cbiAgICAgIGNvbnN0IGFiaSA9IFtcbiAgICAgICAgJ2Z1bmN0aW9uIGdldFVzZXJSZXNlcnZlKGFkZHJlc3MgdXNlciwgYWRkcmVzcyBhc3NldCkgdmlldyByZXR1cm5zICh0dXBsZSh1aW50MTI4IHByaW5jaXBhbCx1aW50MTI4IGluZGV4KSBzdXBwbHksIHR1cGxlKHVpbnQxMjggcHJpbmNpcGFsLHVpbnQxMjggaW5kZXgpIGJvcnJvdyknXG4gICAgICBdO1xuICAgICAgY29uc3QgcG9vbCA9IG5ldyBldGhlcnMuQ29udHJhY3QoQ09ORklHLkxFTkRJTkdfUE9PTCwgYWJpLCBtZXRhbWFza0RldGFpbHMucHJvdmlkZXIpO1xuXG4gICAgICBjb25zdCBzdXBwbGllcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBDT05GSUcuVE9LRU5TLmZpbHRlcih0ID0+ICF0LmlzTmF0aXZlKS5tYXAoYXN5bmMgKHRva2VuKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJSZXNlcnZlID0gYXdhaXQgcG9vbC5nZXRVc2VyUmVzZXJ2ZShtZXRhbWFza0RldGFpbHMuY3VycmVudEFjY291bnQsIHRva2VuLmFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3Qgc3VwcGx5UHJpbmNpcGFsID0gZXRoZXJzLmZvcm1hdFVuaXRzKHVzZXJSZXNlcnZlLnN1cHBseS5wcmluY2lwYWwsIDE4KTtcbiAgICAgICAgICAgIGNvbnN0IHN1cHBseUluZGV4ID0gdXNlclJlc2VydmUuc3VwcGx5LmluZGV4LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KHN1cHBseVByaW5jaXBhbCkgPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHByaWNlID0gYXdhaXQgZ2V0UHJpY2VVU0QodG9rZW4uYWRkcmVzcyk7XG4gICAgICAgICAgICAgIGNvbnN0IGJhbGFuY2VVU0QgPSBwYXJzZUZsb2F0KHN1cHBseVByaW5jaXBhbCkgKiBwYXJzZUZsb2F0KHByaWNlKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdG9rZW4uYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzeW1ib2w6IHRva2VuLnN5bWJvbCxcbiAgICAgICAgICAgICAgICBuYW1lOiB0b2tlbi5uYW1lLFxuICAgICAgICAgICAgICAgIGRlY2ltYWxzOiB0b2tlbi5kZWNpbWFscyxcbiAgICAgICAgICAgICAgICBzdXBwbHlQcmluY2lwYWw6IHN1cHBseVByaW5jaXBhbCxcbiAgICAgICAgICAgICAgICBzdXBwbHlJbmRleDogc3VwcGx5SW5kZXgsXG4gICAgICAgICAgICAgICAgYmFsYW5jZVVTRDogYmFsYW5jZVVTRCxcbiAgICAgICAgICAgICAgICBwcmljZVVTRDogcHJpY2UsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBFcnJvciBnZXR0aW5nIHN1cHBseSBmb3IgJHt0b2tlbi5zeW1ib2x9OmAsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHZhbGlkU3VwcGxpZXMgPSBzdXBwbGllcy5maWx0ZXIocyA9PiBzICE9PSBudWxsKTtcbiAgICAgIHNldFN1cHBseUFzc2V0cyh2YWxpZFN1cHBsaWVzKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHN1bW1hcnlcbiAgICAgIGNvbnN0IHRvdGFsVVNEQmFsYW5jZSA9IHZhbGlkU3VwcGxpZXMucmVkdWNlKChzdW0sIGFzc2V0KSA9PiBzdW0gKyBhc3NldC5iYWxhbmNlVVNELCAwKTtcbiAgICAgIGNvbnN0IHdlaWdodGVkQXZnQVBZID0gdmFsaWRTdXBwbGllcy5sZW5ndGggPiAwID8gXG4gICAgICAgIHZhbGlkU3VwcGxpZXMucmVkdWNlKChzdW0sIGFzc2V0KSA9PiBzdW0gKyAoYXNzZXQuYXB5IHx8IDApLCAwKSAvIHZhbGlkU3VwcGxpZXMubGVuZ3RoIDogMDtcbiAgICAgIGNvbnN0IHRvdGFsVVNEQ29sbGF0ZXJhbCA9IHZhbGlkU3VwcGxpZXMucmVkdWNlKChzdW0sIGFzc2V0KSA9PiBzdW0gKyBhc3NldC5iYWxhbmNlVVNELCAwKTtcblxuICAgICAgc2V0U3VwcGx5U3VtbWFyeSh7XG4gICAgICAgIHRvdGFsVVNEQmFsYW5jZSxcbiAgICAgICAgd2VpZ2h0ZWRBdmdBUFksXG4gICAgICAgIHRvdGFsVVNEQ29sbGF0ZXJhbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZyhcIkdvdCB5b3VyIHN1cHBsaWVzOlwiLCB2YWxpZFN1cHBsaWVzKTtcbiAgICAgIHJldHVybiB2YWxpZFN1cHBsaWVzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyLCBtZXRhbWFza0RldGFpbHMuY3VycmVudEFjY291bnQsIGdldFByaWNlVVNEXSk7XG5cbiAgLy8gR2V0IHlvdXIgYm9ycm93c1xuICBjb25zdCBnZXRZb3VyQm9ycm93cyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIjQuIEdldHRpbmcgeW91ciBib3Jyb3dzLi4uXCIpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5wcm92aWRlciB8fCAhbWV0YW1hc2tEZXRhaWxzLmN1cnJlbnRBY2NvdW50KSByZXR1cm4gW107XG5cbiAgICAgIGNvbnN0IGFiaSA9IFtcbiAgICAgICAgJ2Z1bmN0aW9uIGdldFVzZXJSZXNlcnZlKGFkZHJlc3MgdXNlciwgYWRkcmVzcyBhc3NldCkgdmlldyByZXR1cm5zICh0dXBsZSh1aW50MTI4IHByaW5jaXBhbCx1aW50MTI4IGluZGV4KSBzdXBwbHksIHR1cGxlKHVpbnQxMjggcHJpbmNpcGFsLHVpbnQxMjggaW5kZXgpIGJvcnJvdyknXG4gICAgICBdO1xuICAgICAgY29uc3QgcG9vbCA9IG5ldyBldGhlcnMuQ29udHJhY3QoQ09ORklHLkxFTkRJTkdfUE9PTCwgYWJpLCBtZXRhbWFza0RldGFpbHMucHJvdmlkZXIpO1xuXG4gICAgICBjb25zdCBib3Jyb3dzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIENPTkZJRy5UT0tFTlMuZmlsdGVyKHQgPT4gIXQuaXNOYXRpdmUpLm1hcChhc3luYyAodG9rZW4pID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXNlclJlc2VydmUgPSBhd2FpdCBwb29sLmdldFVzZXJSZXNlcnZlKG1ldGFtYXNrRGV0YWlscy5jdXJyZW50QWNjb3VudCwgdG9rZW4uYWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBib3Jyb3dQcmluY2lwYWwgPSBldGhlcnMuZm9ybWF0VW5pdHModXNlclJlc2VydmUuYm9ycm93LnByaW5jaXBhbCwgMTgpO1xuICAgICAgICAgICAgY29uc3QgYm9ycm93SW5kZXggPSB1c2VyUmVzZXJ2ZS5ib3Jyb3cuaW5kZXgudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQoYm9ycm93UHJpbmNpcGFsKSA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgcHJpY2UgPSBhd2FpdCBnZXRQcmljZVVTRCh0b2tlbi5hZGRyZXNzKTtcbiAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZVVTRCA9IHBhcnNlRmxvYXQoYm9ycm93UHJpbmNpcGFsKSAqIHBhcnNlRmxvYXQocHJpY2UpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0b2tlbi5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIHN5bWJvbDogdG9rZW4uc3ltYm9sLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRva2VuLm5hbWUsXG4gICAgICAgICAgICAgICAgZGVjaW1hbHM6IHRva2VuLmRlY2ltYWxzLFxuICAgICAgICAgICAgICAgIGJvcnJvd1ByaW5jaXBhbDogYm9ycm93UHJpbmNpcGFsLFxuICAgICAgICAgICAgICAgIGJvcnJvd0luZGV4OiBib3Jyb3dJbmRleCxcbiAgICAgICAgICAgICAgICBiYWxhbmNlVVNEOiBiYWxhbmNlVVNELFxuICAgICAgICAgICAgICAgIHByaWNlVVNEOiBwcmljZSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEVycm9yIGdldHRpbmcgYm9ycm93IGZvciAke3Rva2VuLnN5bWJvbH06YCwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgY29uc3QgdmFsaWRCb3Jyb3dzID0gYm9ycm93cy5maWx0ZXIoYiA9PiBiICE9PSBudWxsKTtcbiAgICAgIHNldFlvdXJCb3Jyb3dzKHZhbGlkQm9ycm93cyk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBzdW1tYXJ5XG4gICAgICBjb25zdCB0b3RhbFVTREJhbGFuY2UgPSB2YWxpZEJvcnJvd3MucmVkdWNlKChzdW0sIGFzc2V0KSA9PiBzdW0gKyBhc3NldC5iYWxhbmNlVVNELCAwKTtcbiAgICAgIGNvbnN0IHdlaWdodGVkQXZnQVBZID0gdmFsaWRCb3Jyb3dzLmxlbmd0aCA+IDAgPyBcbiAgICAgICAgdmFsaWRCb3Jyb3dzLnJlZHVjZSgoc3VtLCBhc3NldCkgPT4gc3VtICsgKGFzc2V0LmFweSB8fCAwKSwgMCkgLyB2YWxpZEJvcnJvd3MubGVuZ3RoIDogMDtcbiAgICAgIGNvbnN0IHRvdGFsQm9ycm93UG93ZXJVc2VkID0gdG90YWxVU0RCYWxhbmNlO1xuXG4gICAgICBzZXRCb3Jyb3dTdW1tYXJ5KHtcbiAgICAgICAgdG90YWxVU0RCYWxhbmNlLFxuICAgICAgICB3ZWlnaHRlZEF2Z0FQWSxcbiAgICAgICAgdG90YWxCb3Jyb3dQb3dlclVzZWQsXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coXCJHb3QgeW91ciBib3Jyb3dzOlwiLCB2YWxpZEJvcnJvd3MpO1xuICAgICAgcmV0dXJuIHZhbGlkQm9ycm93cztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSwgW21ldGFtYXNrRGV0YWlscy5wcm92aWRlciwgbWV0YW1hc2tEZXRhaWxzLmN1cnJlbnRBY2NvdW50LCBnZXRQcmljZVVTRF0pO1xuXG4gIC8vIEdldCBhc3NldHMgdG8gYm9ycm93XG4gIGNvbnN0IGdldEFzc2V0c1RvQm9ycm93ID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiNS4gR2V0dGluZyBhc3NldHMgdG8gYm9ycm93Li4uXCIpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5wcm92aWRlcikgcmV0dXJuIFtdO1xuXG4gICAgICBjb25zdCBhYmkgPSBbXG4gICAgICAgICdmdW5jdGlvbiByZXNlcnZlcyhhZGRyZXNzKSB2aWV3IHJldHVybnMgKHVpbnQxMjggcmVzZXJ2ZUNhc2gsIHVpbnQxMjggdG90YWxEZWJ0UHJpbmNpcGFsLCB1aW50MTI4IGxpcXVpZGl0eUluZGV4LCB1aW50MTI4IHZhcmlhYmxlQm9ycm93SW5kZXgsIHVpbnQ2NCBsaXF1aWRpdHlSYXRlUmF5UGVyU2VjLCB1aW50NjQgdmFyaWFibGVCb3Jyb3dSYXRlUmF5UGVyU2VjLCB1aW50MTYgcmVzZXJ2ZUZhY3RvckJwcywgdWludDE2IGx0dkJwcywgdWludDE2IGxpcVRocmVzaG9sZEJwcywgdWludDE2IGxpcUJvbnVzQnBzLCB1aW50MTYgY2xvc2VGYWN0b3JCcHMsIHVpbnQ4IGRlY2ltYWxzLCBib29sIGlzQm9ycm93YWJsZSwgdWludDE2IG9wdGltYWxVQnBzLCB1aW50NjQgYmFzZVJhdGVSYXlQZXJTZWMsIHVpbnQ2NCBzbG9wZTFSYXlQZXJTZWMsIHVpbnQ2NCBzbG9wZTJSYXlQZXJTZWMsIHVpbnQ0MCBsYXN0VXBkYXRlKSdcbiAgICAgIF07XG4gICAgICBjb25zdCBwb29sID0gbmV3IGV0aGVycy5Db250cmFjdChDT05GSUcuTEVORElOR19QT09MLCBhYmksIG1ldGFtYXNrRGV0YWlscy5wcm92aWRlcik7XG5cbiAgICAgIGNvbnN0IGFzc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBDT05GSUcuVE9LRU5TLmZpbHRlcih0ID0+ICF0LmlzTmF0aXZlKS5tYXAoYXN5bmMgKHRva2VuKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc2VydmUgPSBhd2FpdCBwb29sLnJlc2VydmVzKHRva2VuLmFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgaXNCb3Jyb3dhYmxlID0gQm9vbGVhbihyZXNlcnZlLmlzQm9ycm93YWJsZSk7XG4gICAgICAgICAgICBjb25zdCByZXNlcnZlQ2FzaCA9IGV0aGVycy5mb3JtYXRVbml0cyhyZXNlcnZlLnJlc2VydmVDYXNoLCAxOCk7XG4gICAgICAgICAgICBjb25zdCBwcmljZSA9IGF3YWl0IGdldFByaWNlVVNEKHRva2VuLmFkZHJlc3MpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaXNCb3Jyb3dhYmxlICYmIHBhcnNlRmxvYXQocmVzZXJ2ZUNhc2gpID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRva2VuLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgc3ltYm9sOiB0b2tlbi5zeW1ib2wsXG4gICAgICAgICAgICAgICAgbmFtZTogdG9rZW4ubmFtZSxcbiAgICAgICAgICAgICAgICBkZWNpbWFsczogdG9rZW4uZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgcmVzZXJ2ZUNhc2g6IHJlc2VydmVDYXNoLFxuICAgICAgICAgICAgICAgIGlzQm9ycm93YWJsZTogaXNCb3Jyb3dhYmxlLFxuICAgICAgICAgICAgICAgIHByaWNlVVNEOiBwcmljZSxcbiAgICAgICAgICAgICAgICBsdHZCcHM6IE51bWJlcihyZXNlcnZlLmx0dkJwcyksXG4gICAgICAgICAgICAgICAgbGlxVGhyZXNob2xkQnBzOiBOdW1iZXIocmVzZXJ2ZS5saXFUaHJlc2hvbGRCcHMpLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRXJyb3IgZ2V0dGluZyBib3Jyb3cgYXNzZXQgJHt0b2tlbi5zeW1ib2x9OmAsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHZhbGlkQXNzZXRzID0gYXNzZXRzLmZpbHRlcihhID0+IGEgIT09IG51bGwpO1xuICAgICAgc2V0QXNzZXRzVG9Cb3Jyb3codmFsaWRBc3NldHMpO1xuICAgICAgY29uc29sZS5sb2coXCJHb3QgYXNzZXRzIHRvIGJvcnJvdzpcIiwgdmFsaWRBc3NldHMpO1xuICAgICAgcmV0dXJuIHZhbGlkQXNzZXRzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyLCBnZXRQcmljZVVTRF0pO1xuXG4gIC8vIFdyYXAgRVRIIHRvIFdFVEhcbiAgY29uc3Qgd3JhcEV0aCA9IHVzZUNhbGxiYWNrKGFzeW5jIChhbW91bnRFdGgpID0+IHtcbiAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5zaWduZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSAnMHhkMGUzMGRiMCc7IC8vIGRlcG9zaXQoKVxuICAgICAgY29uc29sZS5sb2coJ3dyYXBFdGgg4oaSIHVzaW5nIFdFVEggYWRkcmVzczonLCBXRVRIQWRkcmVzcyk7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IG1ldGFtYXNrRGV0YWlscy5zaWduZXIuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgdG86IFdFVEhBZGRyZXNzLFxuICAgICAgICB2YWx1ZTogZXRoZXJzLnBhcnNlRXRoZXIoYW1vdW50RXRoKSxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgICBjb25zb2xlLmxvZyhcIkVUSCB3cmFwcGVkIHRvIFdFVEg6XCIsIGFtb3VudEV0aCk7XG4gICAgICByZXR1cm4geyBzdGF0dXM6IDIwMCwgbWVzc2FnZTogXCJUcmFuc2FjdGlvbiBTdWNjZXNzZnVsLi4uXCIsIGhhc2g6IHR4Lmhhc2ggfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiA1MDAsIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IucmVhc29uIH07XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnNpZ25lcl0pO1xuXG4gIC8vIFVud3JhcCBXRVRIIHRvIEVUSFxuICBjb25zdCB1bndyYXBXZXRoID0gdXNlQ2FsbGJhY2soYXN5bmMgKGFtb3VudEV0aCkgPT4ge1xuICAgIGlmICghbWV0YW1hc2tEZXRhaWxzLnNpZ25lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmVyIGF2YWlsYWJsZVwiKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYWJpID0gWydmdW5jdGlvbiB3aXRoZHJhdyh1aW50MjU2IHdhZCknXTtcbiAgICAgIGNvbnNvbGUubG9nKCd1bndyYXBXZXRoIOKGkiB1c2luZyBXRVRIIGFkZHJlc3M6JywgV0VUSEFkZHJlc3MpO1xuICAgICAgY29uc3Qgd2V0aCA9IG5ldyBldGhlcnMuQ29udHJhY3QoV0VUSEFkZHJlc3MsIGFiaSwgbWV0YW1hc2tEZXRhaWxzLnNpZ25lcik7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IHdldGgud2l0aGRyYXcoZXRoZXJzLnBhcnNlRXRoZXIoYW1vdW50RXRoKSk7XG4gICAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgICBjb25zb2xlLmxvZyhcIldFVEggdW53cmFwcGVkIHRvIEVUSDpcIiwgYW1vdW50RXRoKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogMjAwLCBtZXNzYWdlOiBcIlRyYW5zYWN0aW9uIFN1Y2Nlc3NmdWwuLi5cIiwgaGFzaDogdHguaGFzaCB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4geyBzdGF0dXM6IDUwMCwgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB8fCBlcnJvci5yZWFzb24gfTtcbiAgICB9XG4gIH0sIFttZXRhbWFza0RldGFpbHMuc2lnbmVyXSk7XG5cbiAgLy8gV2l0aGRyYXcgdG9rZW4gdG8gRVRIIChmb3IgYWxsIHRva2VucyB3aXRoIHdpdGhkcmF3IGZ1bmN0aW9uKVxuICBjb25zdCB3aXRoZHJhd1Rva2VuID0gdXNlQ2FsbGJhY2soYXN5bmMgKHRva2VuQWRkcmVzcywgYW1vdW50KSA9PiB7XG4gICAgaWYgKCFtZXRhbWFza0RldGFpbHMuc2lnbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBhYmkgPSBbJ2Z1bmN0aW9uIHdpdGhkcmF3KHVpbnQyNTYgYW1vdW50KSddO1xuICAgICAgY29uc29sZS5sb2coJ3dpdGhkcmF3VG9rZW4g4oaSIHVzaW5nIGFkZHJlc3M6JywgdG9rZW5BZGRyZXNzKTtcbiAgICAgIGNvbnN0IHRva2VuID0gbmV3IGV0aGVycy5Db250cmFjdCh0b2tlbkFkZHJlc3MsIGFiaSwgbWV0YW1hc2tEZXRhaWxzLnNpZ25lcik7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IHRva2VuLndpdGhkcmF3KGV0aGVycy5wYXJzZUV0aGVyKGFtb3VudCkpO1xuICAgICAgYXdhaXQgdHgud2FpdCgpO1xuICAgICAgY29uc29sZS5sb2coXCJUb2tlbiB3aXRoZHJhd24gdG8gRVRIOlwiLCBhbW91bnQpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiAyMDAsIG1lc3NhZ2U6IFwiV2l0aGRyYXcgU3VjY2Vzc2Z1bC4uLlwiLCBoYXNoOiB0eC5oYXNoIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydEVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogNTAwLCBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8IGVycm9yLnJlYXNvbiB9O1xuICAgIH1cbiAgfSwgW21ldGFtYXNrRGV0YWlscy5zaWduZXJdKTtcblxuICAvLyBEZXBvc2l0IEVUSCB0byBnZXQgdG9rZW4gKGZvciBhbGwgdG9rZW5zIHdpdGggZGVwb3NpdCBmdW5jdGlvbilcbiAgY29uc3QgZGVwb3NpdFRvVG9rZW4gPSB1c2VDYWxsYmFjayhhc3luYyAodG9rZW5BZGRyZXNzLCBhbW91bnRFdGgpID0+IHtcbiAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5zaWduZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFiaSA9IFsnZnVuY3Rpb24gZGVwb3NpdCgpIHBheWFibGUnXTtcbiAgICAgIGNvbnNvbGUubG9nKCdkZXBvc2l0VG9Ub2tlbiDihpIgdXNpbmcgYWRkcmVzczonLCB0b2tlbkFkZHJlc3MpO1xuICAgICAgY29uc3QgdG9rZW4gPSBuZXcgZXRoZXJzLkNvbnRyYWN0KHRva2VuQWRkcmVzcywgYWJpLCBtZXRhbWFza0RldGFpbHMuc2lnbmVyKTtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdG9rZW4uZGVwb3NpdCh7IHZhbHVlOiBldGhlcnMucGFyc2VFdGhlcihhbW91bnRFdGgpIH0pO1xuICAgICAgYXdhaXQgdHgud2FpdCgpO1xuICAgICAgY29uc29sZS5sb2coXCJFVEggZGVwb3NpdGVkIHRvIHRva2VuOlwiLCBhbW91bnRFdGgpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiAyMDAsIG1lc3NhZ2U6IFwiRGVwb3NpdCBTdWNjZXNzZnVsLi4uXCIsIGhhc2g6IHR4Lmhhc2ggfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiA1MDAsIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IucmVhc29uIH07XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnNpZ25lcl0pO1xuXG4gIC8vIFJlZnJlc2ggYWxsIGRhdGFcbiAgY29uc3QgcmVmcmVzaCA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBnZXRVc2VyQXNzZXRzKCksXG4gICAgICAgIGdldFlvdXJTdXBwbGllcygpLFxuICAgICAgICBnZXRZb3VyQm9ycm93cygpLFxuICAgICAgICBnZXRBc3NldHNUb0JvcnJvdygpLFxuICAgICAgICBnZXRBY2NvdW50RGF0YSgpLFxuICAgICAgXSk7XG4gICAgICBjb25zb2xlLmxvZyhcIkFsbCBkYXRhIHJlZnJlc2hlZFwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSwgW2dldFVzZXJBc3NldHMsIGdldFlvdXJTdXBwbGllcywgZ2V0WW91ckJvcnJvd3MsIGdldEFzc2V0c1RvQm9ycm93LCBnZXRBY2NvdW50RGF0YV0pO1xuXG4gIC8vIFVwZGF0ZSBpbnRlcmVzdHMgKGFjY3J1ZSlcbiAgY29uc3QgdXBkYXRlSW50ZXJlc3RzID0gdXNlQ2FsbGJhY2soYXN5bmMgKGFzc2V0KSA9PiB7XG4gICAgaWYgKCFtZXRhbWFza0RldGFpbHMuc2lnbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBhYmkgPSBbJ2Z1bmN0aW9uIGFjY3J1ZVB1YmxpYyhhZGRyZXNzIGFzc2V0KSddO1xuICAgICAgY29uc3QgcG9vbCA9IG5ldyBldGhlcnMuQ29udHJhY3QoQ09ORklHLkxFTkRJTkdfUE9PTCwgYWJpLCBtZXRhbWFza0RldGFpbHMuc2lnbmVyKTtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcG9vbC5hY2NydWVQdWJsaWMoYXNzZXQpO1xuICAgICAgYXdhaXQgdHgud2FpdCgpO1xuICAgICAgY29uc29sZS5sb2coXCJJbnRlcmVzdHMgdXBkYXRlZCBmb3IgYXNzZXQ6XCIsIGFzc2V0KTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogMjAwLCBtZXNzYWdlOiBcIlRyYW5zYWN0aW9uIFN1Y2Nlc3NmdWwuLi5cIiB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4geyBzdGF0dXM6IDUwMCwgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB8fCBlcnJvci5yZWFzb24gfTtcbiAgICB9XG4gIH0sIFttZXRhbWFza0RldGFpbHMuc2lnbmVyXSk7XG5cbiAgLy8gR2V0IHVzZXIgdG90YWwgYXZhaWxhYmxlIGJhbGFuY2VcbiAgY29uc3QgZ2V0VXNlclRvdGFsQXZhaWxhYmxlQmFsYW5jZSA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFtZXRhbWFza0RldGFpbHMucHJvdmlkZXIgfHwgIW1ldGFtYXNrRGV0YWlscy5jdXJyZW50QWNjb3VudCkgcmV0dXJuIDA7XG5cbiAgICAgIGNvbnN0IGFiaSA9IFtcbiAgICAgICAgJ2Z1bmN0aW9uIGdldFVzZXJUb3RhbEF2YWlsYWJsZUJhbGFuY2VJblVTRChhZGRyZXNzIHVzZXIsIHVpbnQyNTYgYXNzZXRUeXBlKSB2aWV3IHJldHVybnMgKHVpbnQyNTYpJ1xuICAgICAgXTtcbiAgICAgIGNvbnN0IHBvb2wgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KENPTkZJRy5MRU5ESU5HX1BPT0wsIGFiaSwgbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyKTtcbiAgICAgIGNvbnN0IG1heEFtb3VudCA9IGF3YWl0IHBvb2wuZ2V0VXNlclRvdGFsQXZhaWxhYmxlQmFsYW5jZUluVVNEKG1ldGFtYXNrRGV0YWlscy5jdXJyZW50QWNjb3VudCwgMSk7XG4gICAgICByZXR1cm4gTnVtYmVyKGV0aGVycy5mb3JtYXRVbml0cyhtYXhBbW91bnQsIDE4KSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydEVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSwgW21ldGFtYXNrRGV0YWlscy5wcm92aWRlciwgbWV0YW1hc2tEZXRhaWxzLmN1cnJlbnRBY2NvdW50XSk7XG5cbiAgLy8gR2V0IHRva2VucyBwZXIgVVNEIGFtb3VudFxuICBjb25zdCBnZXRUb2tlbnNQZXJVU0RBbW91bnQgPSB1c2VDYWxsYmFjayhhc3luYyAodG9rZW4sIGFtb3VudCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5wcm92aWRlcikgcmV0dXJuIDA7XG5cbiAgICAgIGNvbnN0IGFiaSA9IFtcbiAgICAgICAgJ2Z1bmN0aW9uIGdldFRva2Vuc1BlclVTREFtb3VudChhZGRyZXNzIHRva2VuLCB1aW50MjU2IGFtb3VudCkgdmlldyByZXR1cm5zICh1aW50MjU2KSdcbiAgICAgIF07XG4gICAgICBjb25zdCBoZWxwZXIgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KENPTkZJRy5QUklDRV9PUkFDTEUsIGFiaSwgbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyKTtcbiAgICAgIGNvbnN0IG1heFF0eSA9IGF3YWl0IGhlbHBlci5nZXRUb2tlbnNQZXJVU0RBbW91bnQodG9rZW4sIGV0aGVycy5wYXJzZVVuaXRzKGFtb3VudC50b1N0cmluZygpLCAxOCkpO1xuICAgICAgcmV0dXJuIE51bWJlcihldGhlcnMuZm9ybWF0VW5pdHMobWF4UXR5LCAxOCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sIFttZXRhbWFza0RldGFpbHMucHJvdmlkZXJdKTtcblxuICAvLyBPYmplY3RpZnkgc3VwcGxpZWQgYXNzZXRzIChmb3JtYXQgZGF0YSlcbiAgY29uc3Qgb2JqZWN0aWZ5U3VwcGxpZWRBc3NldHMgPSB1c2VDYWxsYmFjayhhc3luYyAoYXNzZXRzKSA9PiB7XG4gICAgY29uc3QgYXNzZXRzTGlzdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXNzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IGFzc2V0c1tpXS50b2tlbjtcbiAgICAgIGxldCBsZW5kUXR5ID0gYXNzZXRzW2ldLmxlbnRRdHk7XG5cbiAgICAgIGNvbnN0IGFtb3VudEluVVNEID0gYXdhaXQgZ2V0QW1vdW50SW5VU0QodG9rZW4sIGxlbmRRdHkpO1xuICAgICAgbGVuZFF0eSA9IE51bWJlcihhc3NldHNbaV0ubGVudFF0eSkgLyAxZTE4O1xuXG4gICAgICBjb25zdCBtYXhTdXBwbHlBbW91bnQgPSBhd2FpdCBnZXRVc2VyVG90YWxBdmFpbGFibGVCYWxhbmNlKCk7XG4gICAgICBjb25zdCBtYXhRdHkgPSBhd2FpdCBnZXRUb2tlbnNQZXJVU0RBbW91bnQodG9rZW4sIG1heFN1cHBseUFtb3VudCk7XG4gICAgICBjb25zdCBxdHkgPSBsZW5kUXR5IDw9IG1heFF0eSA/IGxlbmRRdHkgOiBtYXhRdHk7XG5cbiAgICAgIGFzc2V0c0xpc3QucHVzaCh7XG4gICAgICAgIHRva2VuOiBhc3NldHNbaV0udG9rZW4sXG4gICAgICAgIGJhbGFuY2U6IGxlbmRRdHksXG4gICAgICAgIGFweTogTnVtYmVyKGFzc2V0c1tpXS5sZW50QXB5KSxcbiAgICAgICAgYmFsYW5jZUluVVNEOiBhbW91bnRJblVTRCxcbiAgICAgICAgbWF4U3VwcGx5OiBxdHksXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc2V0c0xpc3Q7XG4gIH0sIFtnZXRBbW91bnRJblVTRCwgZ2V0VXNlclRvdGFsQXZhaWxhYmxlQmFsYW5jZSwgZ2V0VG9rZW5zUGVyVVNEQW1vdW50XSk7XG5cbiAgLy8gT2JqZWN0aWZ5IGJvcnJvd2VkIGFzc2V0cyAoZm9ybWF0IGRhdGEpXG4gIGNvbnN0IG9iamVjdGlmeUJvcnJvd2VkQXNzZXRzID0gdXNlQ2FsbGJhY2soYXN5bmMgKGFzc2V0cykgPT4ge1xuICAgIGNvbnN0IGJvcnJvd3NMaXN0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRva2VuID0gYXNzZXRzW2ldLnRva2VuO1xuICAgICAgY29uc3QgYm9ycm93UXR5ID0gYXNzZXRzW2ldLmJvcnJvd1F0eTtcbiAgICAgIGNvbnN0IGJvcnJvd0FweSA9IGFzc2V0c1tpXS5ib3Jyb3dBcHk7XG4gICAgICBjb25zdCBhbW91bnRJblVTRCA9IGF3YWl0IGdldEFtb3VudEluVVNEKHRva2VuLCBib3Jyb3dRdHkpO1xuICAgICAgXG4gICAgICBib3Jyb3dzTGlzdC5wdXNoKHtcbiAgICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgICBib3Jyb3dRdHk6IE51bWJlcihib3Jyb3dRdHkpLFxuICAgICAgICBib3Jyb3dBcHk6IE51bWJlcihib3Jyb3dBcHkpLFxuICAgICAgICBib3Jyb3dlZEJhbEluVVNEOiBhbW91bnRJblVTRCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYm9ycm93c0xpc3Q7XG4gIH0sIFtnZXRBbW91bnRJblVTRF0pO1xuXG4gIC8vIE1lcmdlIG9iamVjdGlmaWVkIGFzc2V0cyB3aXRoIHRva2VuIGluZm9cbiAgY29uc3QgbWVyZ2VPYmplY3RpZmllZEFzc2V0cyA9IHVzZUNhbGxiYWNrKChhc3NldHMpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBDT05GSUcuVE9LRU5TXG4gICAgICAuZmlsdGVyKCh0b2tlbkxpc3QpID0+IHtcbiAgICAgICAgcmV0dXJuIGFzc2V0cy5zb21lKChhc3NldExpc3QpID0+IHtcbiAgICAgICAgICByZXR1cm4gdG9rZW5MaXN0LmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYXNzZXRMaXN0LnRva2VuLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgIC5tYXAoKGFzc2V0T2JqKSA9PiAoe1xuICAgICAgICAuLi5hc3NldHMuZmluZCgoaXRlbSkgPT4gaXRlbS50b2tlbi50b0xvd2VyQ2FzZSgpID09PSBhc3NldE9iai5hZGRyZXNzLnRvTG93ZXJDYXNlKCkpLFxuICAgICAgICAuLi5hc3NldE9iaixcbiAgICAgIH0pKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBbXSk7XG5cbiAgLy8gQ29udGV4dCB2YWx1ZVxuICBjb25zdCBjb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgLy8gU3RhdGVcbiAgICBtZXRhbWFza0RldGFpbHMsXG4gICAgdXNlckFzc2V0cyxcbiAgICBzdXBwbHlBc3NldHMsXG4gICAgYXNzZXRzVG9Cb3Jyb3csXG4gICAgeW91ckJvcnJvd3MsXG4gICAgc3VwcGx5U3VtbWFyeSxcbiAgICBib3Jyb3dTdW1tYXJ5LFxuICAgIGFjY291bnREYXRhLFxuICAgIGNvbnRyYWN0LFxuXG4gICAgLy8gV2FsbGV0IGZ1bmN0aW9uc1xuICAgIGNvbm5lY3RXYWxsZXQsXG4gICAgcmVmcmVzaCxcblxuICAgIC8vIEFzc2V0IGZ1bmN0aW9uc1xuICAgIGdldFVzZXJBc3NldHMsXG4gICAgZ2V0WW91clN1cHBsaWVzLFxuICAgIGdldFlvdXJCb3Jyb3dzLFxuICAgIGdldEFzc2V0c1RvQm9ycm93LFxuXG4gICAgLy8gVHJhbnNhY3Rpb24gZnVuY3Rpb25zXG4gICAgQXBwcm92ZVRvQ29udGludWUsXG4gICAgTGVuZEFzc2V0LFxuICAgIFdpdGhkcmF3QXNzZXQsXG4gICAgYm9ycm93QXNzZXQsXG4gICAgcmVwYXlBc3NldCxcblxuICAgIC8vIFV0aWxpdHkgZnVuY3Rpb25zXG4gICAgZ2V0Q29udHJhY3QsXG4gICAgZ2V0UHJpY2VVU0QsXG4gICAgZ2V0QW1vdW50SW5VU0QsXG4gICAgbnVtYmVyVG9FdGhlcnMsXG4gICAgcmVwb3J0RXJyb3IsXG5cbiAgICAvLyBFVEgvV0VUSCBmdW5jdGlvbnNcbiAgICB3cmFwRXRoLFxuICAgIHVud3JhcFdldGgsXG5cbiAgICAvLyBBY2NvdW50IGZ1bmN0aW9uc1xuICAgIGdldEFjY291bnREYXRhLFxuICAgIGdldFVzZXJUb3RhbEF2YWlsYWJsZUJhbGFuY2UsXG4gICAgZ2V0VG9rZW5zUGVyVVNEQW1vdW50LFxuXG4gICAgLy8gRGF0YSBwcm9jZXNzaW5nIGZ1bmN0aW9uc1xuICAgIG9iamVjdGlmeVN1cHBsaWVkQXNzZXRzLFxuICAgIG9iamVjdGlmeUJvcnJvd2VkQXNzZXRzLFxuICAgIG1lcmdlT2JqZWN0aWZpZWRBc3NldHMsXG5cbiAgICAvLyBJbnRlcmVzdCBmdW5jdGlvbnNcbiAgICB1cGRhdGVJbnRlcmVzdHMsXG5cbiAgICAvLyBUb2tlbiB3aXRoZHJhdy9kZXBvc2l0IGZ1bmN0aW9uc1xuICAgIHdpdGhkcmF3VG9rZW4sXG4gICAgZGVwb3NpdFRvVG9rZW4sXG4gIH0pLCBbXG4gICAgbWV0YW1hc2tEZXRhaWxzLFxuICAgIHVzZXJBc3NldHMsXG4gICAgc3VwcGx5QXNzZXRzLFxuICAgIGFzc2V0c1RvQm9ycm93LFxuICAgIHlvdXJCb3Jyb3dzLFxuICAgIHN1cHBseVN1bW1hcnksXG4gICAgYm9ycm93U3VtbWFyeSxcbiAgICBhY2NvdW50RGF0YSxcbiAgICBjb250cmFjdCxcbiAgICBjb25uZWN0V2FsbGV0LFxuICAgIHJlZnJlc2gsXG4gICAgZ2V0VXNlckFzc2V0cyxcbiAgICBnZXRZb3VyU3VwcGxpZXMsXG4gICAgZ2V0WW91ckJvcnJvd3MsXG4gICAgZ2V0QXNzZXRzVG9Cb3Jyb3csXG4gICAgQXBwcm92ZVRvQ29udGludWUsXG4gICAgTGVuZEFzc2V0LFxuICAgIFdpdGhkcmF3QXNzZXQsXG4gICAgYm9ycm93QXNzZXQsXG4gICAgcmVwYXlBc3NldCxcbiAgICBnZXRDb250cmFjdCxcbiAgICBnZXRQcmljZVVTRCxcbiAgICBnZXRBbW91bnRJblVTRCxcbiAgICB3cmFwRXRoLFxuICAgIHVud3JhcFdldGgsXG4gICAgZ2V0QWNjb3VudERhdGEsXG4gICAgZ2V0VXNlclRvdGFsQXZhaWxhYmxlQmFsYW5jZSxcbiAgICBnZXRUb2tlbnNQZXJVU0RBbW91bnQsXG4gICAgb2JqZWN0aWZ5U3VwcGxpZWRBc3NldHMsXG4gICAgb2JqZWN0aWZ5Qm9ycm93ZWRBc3NldHMsXG4gICAgbWVyZ2VPYmplY3RpZmllZEFzc2V0cyxcbiAgICB1cGRhdGVJbnRlcmVzdHMsXG4gIF0pO1xuXG4gIHJldHVybiAoXG4gICAgPGxlbmRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0VmFsdWV9PlxuICAgICAge3Byb3BzLmNoaWxkcmVufVxuICAgIDwvbGVuZENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBMZW5kU3RhdGU7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlTWVtbyIsImxlbmRDb250ZXh0IiwiZXRoZXJzIiwiQ09ORklHIiwiZ2V0VG9rZW5CYWxhbmNlIiwiZ2V0VG9rZW5BbGxvd2FuY2UiLCJhcHByb3ZlSWZOZWVkZWQiLCJsZW5kIiwibGVuZFR4Iiwid2l0aGRyYXciLCJ3aXRoZHJhd1R4IiwiYm9ycm93IiwiYm9ycm93VHgiLCJyZXBheSIsInJlcGF5VHgiLCJFVEhBZGRyZXNzIiwiTGVuZGluZ1Bvb2xBZGRyZXNzIiwiTGVuZGluZ0hlbHBlckFkZHJlc3MiLCJXRVRIQWRkcmVzcyIsIlRva2VuQUJJIiwiTGVuZGluZ1Bvb2xBQkkiLCJMZW5kaW5nSGVscGVyQUJJIiwibnVtYmVyVG9FdGhlcnMiLCJudW1iZXIiLCJwYXJzZUV0aGVyIiwidG9TdHJpbmciLCJyZXBvcnRFcnJvciIsImVycm9yIiwiY29uc29sZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJMZW5kU3RhdGUiLCJwcm9wcyIsIm1ldGFtYXNrRGV0YWlscyIsInNldE1ldGFtYXNrRGV0YWlscyIsInByb3ZpZGVyIiwibmV0d29ya05hbWUiLCJzaWduZXIiLCJjdXJyZW50QWNjb3VudCIsImNoYWluSWQiLCJ1c2VyQXNzZXRzIiwic2V0VXNlckFzc2V0cyIsInN1cHBseUFzc2V0cyIsInNldFN1cHBseUFzc2V0cyIsImFzc2V0c1RvQm9ycm93Iiwic2V0QXNzZXRzVG9Cb3Jyb3ciLCJ5b3VyQm9ycm93cyIsInNldFlvdXJCb3Jyb3dzIiwiY29udHJhY3QiLCJzZXRDb250cmFjdCIsImxlbmRpbmdQb29sQ29udHJhY3QiLCJvcmFjbGVDb250cmFjdCIsInN1cHBseVN1bW1hcnkiLCJzZXRTdXBwbHlTdW1tYXJ5IiwidG90YWxVU0RCYWxhbmNlIiwid2VpZ2h0ZWRBdmdBUFkiLCJ0b3RhbFVTRENvbGxhdGVyYWwiLCJib3Jyb3dTdW1tYXJ5Iiwic2V0Qm9ycm93U3VtbWFyeSIsInRvdGFsQm9ycm93UG93ZXJVc2VkIiwiYWNjb3VudERhdGEiLCJzZXRBY2NvdW50RGF0YSIsImNvbGxhdGVyYWxVU0QiLCJkZWJ0VVNEIiwiaGVhbHRoRmFjdG9yIiwiY29ubmVjdFdhbGxldCIsImxvZyIsImV0aGVyZXVtIiwid2luZG93IiwiZmFpbE1lc3NhZ2UiLCJhbGVydCIsImFjY291bnRzIiwicmVxdWVzdCIsIm1ldGhvZCIsIm9uIiwibG9jYXRpb24iLCJyZWxvYWQiLCJCcm93c2VyUHJvdmlkZXIiLCJuZXR3b3JrIiwiZ2V0TmV0d29yayIsIm5hbWUiLCJnZXRTaWduZXIiLCJsZW5ndGgiLCJjdXJyZW50QWRkcmVzcyIsIk51bWJlciIsImdldENvbnRyYWN0IiwiYWRkcmVzcyIsImFiaSIsIkNvbnRyYWN0IiwiZ2V0VXNlckFzc2V0cyIsImFzc2V0cyIsIlByb21pc2UiLCJhbGwiLCJUT0tFTlMiLCJtYXAiLCJ0b2tlbiIsImJhbGFuY2UiLCJiYWxhbmNlVVNEIiwiaXNOYXRpdmUiLCJiYWwiLCJnZXRCYWxhbmNlIiwiZm9ybWF0RXRoZXIiLCJkZWNpbWFscyIsInByaWNlIiwiZ2V0UHJpY2VVU0QiLCJwYXJzZUZsb2F0Iiwic3ltYm9sIiwicHJpY2VVU0QiLCJ3YXJuIiwiYXNzZXQiLCJvcmFjbGUiLCJQUklDRV9PUkFDTEUiLCJnZXRBc3NldFByaWNlMWUxOCIsImZvcm1hdFVuaXRzIiwiZ2V0QW1vdW50SW5VU0QiLCJhbW91bnQiLCJhbW91bnRJblVTRCIsIkFwcHJvdmVUb0NvbnRpbnVlIiwidG9rZW5BZGRyZXNzIiwiYXBwcm92ZUFtb3VudCIsIkVycm9yIiwiZmluZCIsInQiLCJ0b0xvd2VyQ2FzZSIsIkxFTkRJTkdfUE9PTCIsInN0YXR1cyIsIm1lc3NhZ2UiLCJyZWFzb24iLCJMZW5kQXNzZXQiLCJzdXBwbHlBbW91bnQiLCJ0b2tlbkluZm8iLCJwYXJzZVVuaXRzIiwidHgiLCJoYXNoIiwiV2l0aGRyYXdBc3NldCIsIndpdGhkcmF3QW1vdW50IiwiYm9ycm93QXNzZXQiLCJib3Jyb3dBbW91bnQiLCJyZXBheUFzc2V0IiwicmVwYXlBbW91bnQiLCJnZXRBY2NvdW50RGF0YSIsInVzZXIiLCJwb29sIiwid2FsbGV0IiwiWmVyb0FkZHJlc3MiLCJjb2wiLCJkZWJ0IiwiaGYiLCJjb250cmFjdEVycm9yIiwiZ2V0WW91clN1cHBsaWVzIiwic3VwcGxpZXMiLCJmaWx0ZXIiLCJ1c2VyUmVzZXJ2ZSIsImdldFVzZXJSZXNlcnZlIiwic3VwcGx5UHJpbmNpcGFsIiwic3VwcGx5IiwicHJpbmNpcGFsIiwic3VwcGx5SW5kZXgiLCJpbmRleCIsInZhbGlkU3VwcGxpZXMiLCJzIiwicmVkdWNlIiwic3VtIiwiYXB5IiwiZ2V0WW91ckJvcnJvd3MiLCJib3Jyb3dzIiwiYm9ycm93UHJpbmNpcGFsIiwiYm9ycm93SW5kZXgiLCJ2YWxpZEJvcnJvd3MiLCJiIiwiZ2V0QXNzZXRzVG9Cb3Jyb3ciLCJyZXNlcnZlIiwicmVzZXJ2ZXMiLCJpc0JvcnJvd2FibGUiLCJCb29sZWFuIiwicmVzZXJ2ZUNhc2giLCJsdHZCcHMiLCJsaXFUaHJlc2hvbGRCcHMiLCJ2YWxpZEFzc2V0cyIsImEiLCJ3cmFwRXRoIiwiYW1vdW50RXRoIiwiZGF0YSIsInNlbmRUcmFuc2FjdGlvbiIsInRvIiwidmFsdWUiLCJ3YWl0IiwidW53cmFwV2V0aCIsIndldGgiLCJ3aXRoZHJhd1Rva2VuIiwiZGVwb3NpdFRvVG9rZW4iLCJkZXBvc2l0IiwicmVmcmVzaCIsInVwZGF0ZUludGVyZXN0cyIsImFjY3J1ZVB1YmxpYyIsImdldFVzZXJUb3RhbEF2YWlsYWJsZUJhbGFuY2UiLCJtYXhBbW91bnQiLCJnZXRVc2VyVG90YWxBdmFpbGFibGVCYWxhbmNlSW5VU0QiLCJnZXRUb2tlbnNQZXJVU0RBbW91bnQiLCJoZWxwZXIiLCJtYXhRdHkiLCJvYmplY3RpZnlTdXBwbGllZEFzc2V0cyIsImFzc2V0c0xpc3QiLCJpIiwibGVuZFF0eSIsImxlbnRRdHkiLCJtYXhTdXBwbHlBbW91bnQiLCJxdHkiLCJwdXNoIiwibGVudEFweSIsImJhbGFuY2VJblVTRCIsIm1heFN1cHBseSIsIm9iamVjdGlmeUJvcnJvd2VkQXNzZXRzIiwiYm9ycm93c0xpc3QiLCJib3Jyb3dRdHkiLCJib3Jyb3dBcHkiLCJib3Jyb3dlZEJhbEluVVNEIiwibWVyZ2VPYmplY3RpZmllZEFzc2V0cyIsInJlc3VsdCIsInRva2VuTGlzdCIsInNvbWUiLCJhc3NldExpc3QiLCJhc3NldE9iaiIsIml0ZW0iLCJjb250ZXh0VmFsdWUiLCJQcm92aWRlciIsImNoaWxkcmVuIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/context/LendState.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/context/lendContext.js":
/*!************************************!*\
  !*** ./src/context/lendContext.js ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst lendContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lendContext);\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9jb250ZXh0L2xlbmRDb250ZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzQztBQUV0QyxNQUFNQyw0QkFBY0Qsb0RBQWFBO0FBRWpDLGlFQUFlQyxXQUFXQSxFQUFDIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcc3JjXFxjb250ZXh0XFxsZW5kQ29udGV4dC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XHJcblxyXG5jb25zdCBsZW5kQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGxlbmRDb250ZXh0O1xyXG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsImxlbmRDb250ZXh0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/context/lendContext.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/lib/tx.ts":
/*!***********************!*\
  !*** ./src/lib/tx.ts ***!
  \***********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   accruePublic: () => (/* binding */ accruePublic),\n/* harmony export */   approveIfNeeded: () => (/* binding */ approveIfNeeded),\n/* harmony export */   borrow: () => (/* binding */ borrow),\n/* harmony export */   formatTokenAmount: () => (/* binding */ formatTokenAmount),\n/* harmony export */   getTokenAllowance: () => (/* binding */ getTokenAllowance),\n/* harmony export */   getTokenBalance: () => (/* binding */ getTokenBalance),\n/* harmony export */   lend: () => (/* binding */ lend),\n/* harmony export */   liquidate: () => (/* binding */ liquidate),\n/* harmony export */   parseTokenAmount: () => (/* binding */ parseTokenAmount),\n/* harmony export */   repay: () => (/* binding */ repay),\n/* harmony export */   sendWithToast: () => (/* binding */ sendWithToast),\n/* harmony export */   withdraw: () => (/* binding */ withdraw)\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _config_abis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/abis */ \"(pages-dir-browser)/./src/config/abis.ts\");\n/* harmony import */ var _config_contracts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config/contracts */ \"(pages-dir-browser)/./src/config/contracts.ts\");\n// Transaction service with toast notifications\n\n\n\n\n/**\n * Send transaction with toast notifications\n */ async function sendWithToast(txPromise, config) {\n    try {\n        var _receipt_gasUsed;\n        // Show pending toast\n        console.log('', config.pending);\n        // Send transaction\n        const tx = await txPromise;\n        console.log(' Transaction sent:', tx.hash);\n        // Show pending with hash\n        console.log('', \"\".concat(config.pending, \" - Hash: \").concat(tx.hash));\n        // Wait for confirmation\n        const receipt = await tx.wait();\n        console.log('', config.success);\n        console.log(' Receipt:', {\n            hash: tx.hash,\n            gasUsed: receipt === null || receipt === void 0 ? void 0 : (_receipt_gasUsed = receipt.gasUsed) === null || _receipt_gasUsed === void 0 ? void 0 : _receipt_gasUsed.toString(),\n            status: receipt === null || receipt === void 0 ? void 0 : receipt.status\n        });\n        return {\n            hash: tx.hash,\n            receipt: receipt\n        };\n    } catch (error) {\n        console.error('', config.error);\n        console.error('Error details:', error);\n        throw error;\n    }\n}\n/**\n * Approve ERC20 token if needed\n */ async function approveIfNeeded(signer, tokenAddress, spender, amount) {\n    const tokenContract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(tokenAddress, _config_abis__WEBPACK_IMPORTED_MODULE_0__.ERC20_ABI, signer);\n    const userAddress = await signer.getAddress();\n    // Check current allowance\n    const currentAllowance = await tokenContract.allowance(userAddress, spender);\n    if (currentAllowance >= amount) {\n        console.log(' Allowance sufficient, skipping approval');\n        return null;\n    }\n    console.log(' Approval needed:', {\n        current: currentAllowance.toString(),\n        required: amount.toString()\n    });\n    // Send approval transaction\n    const txPromise = tokenContract.approve(spender, amount);\n    return await sendWithToast(txPromise, {\n        pending: 'Approving token...',\n        success: 'Token approved successfully!',\n        error: 'Approval failed'\n    });\n}\n/**\n * Lend tokens to the pool\n */ async function lend(signer, tokenAddress, amount) {\n    const poolContract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_1__.CONFIG.LENDING_POOL, _config_abis__WEBPACK_IMPORTED_MODULE_0__.POOL_ABI, signer);\n    // Approve if needed\n    await approveIfNeeded(signer, tokenAddress, _config_contracts__WEBPACK_IMPORTED_MODULE_1__.CONFIG.LENDING_POOL, amount);\n    // Send lend transaction\n    const txPromise = poolContract.lend(tokenAddress, amount);\n    return await sendWithToast(txPromise, {\n        pending: 'Supplying tokens...',\n        success: 'Tokens supplied successfully!',\n        error: 'Supply failed'\n    });\n}\n/**\n * Withdraw tokens from the pool\n */ async function withdraw(signer, tokenAddress, amount) {\n    const poolContract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_1__.CONFIG.LENDING_POOL, _config_abis__WEBPACK_IMPORTED_MODULE_0__.POOL_ABI, signer);\n    const txPromise = poolContract.withdraw(tokenAddress, amount);\n    return await sendWithToast(txPromise, {\n        pending: 'Withdrawing tokens...',\n        success: 'Tokens withdrawn successfully!',\n        error: 'Withdraw failed'\n    });\n}\n/**\n * Borrow tokens from the pool\n */ async function borrow(signer, tokenAddress, amount) {\n    const poolContract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_1__.CONFIG.LENDING_POOL, _config_abis__WEBPACK_IMPORTED_MODULE_0__.POOL_ABI, signer);\n    const txPromise = poolContract.borrow(tokenAddress, amount);\n    return await sendWithToast(txPromise, {\n        pending: 'Borrowing tokens...',\n        success: 'Tokens borrowed successfully!',\n        error: 'Borrow failed'\n    });\n}\n/**\n * Repay borrowed tokens\n */ async function repay(signer, tokenAddress, amount, userAddress) {\n    const poolContract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_1__.CONFIG.LENDING_POOL, _config_abis__WEBPACK_IMPORTED_MODULE_0__.POOL_ABI, signer);\n    const borrower = userAddress || await signer.getAddress();\n    // Approve if needed\n    await approveIfNeeded(signer, tokenAddress, _config_contracts__WEBPACK_IMPORTED_MODULE_1__.CONFIG.LENDING_POOL, amount);\n    const txPromise = poolContract.repay(tokenAddress, amount, borrower);\n    return await sendWithToast(txPromise, {\n        pending: 'Repaying tokens...',\n        success: 'Tokens repaid successfully!',\n        error: 'Repay failed'\n    });\n}\n/**\n * Liquidate a position\n */ async function liquidate(signer, collateralAsset, debtAsset, debtAmount, userAddress) {\n    const poolContract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_1__.CONFIG.LENDING_POOL, _config_abis__WEBPACK_IMPORTED_MODULE_0__.POOL_ABI, signer);\n    const txPromise = poolContract.liquidationCall(collateralAsset, debtAsset, debtAmount, userAddress);\n    return await sendWithToast(txPromise, {\n        pending: 'Liquidating position...',\n        success: 'Position liquidated successfully!',\n        error: 'Liquidation failed'\n    });\n}\n/**\n * Accrue interest for all reserves\n */ async function accruePublic(signer) {\n    const poolContract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_1__.CONFIG.LENDING_POOL, _config_abis__WEBPACK_IMPORTED_MODULE_0__.POOL_ABI, signer);\n    const txPromise = poolContract.accruePublic();\n    return await sendWithToast(txPromise, {\n        pending: 'Accruing interest...',\n        success: 'Interest accrued successfully!',\n        error: 'Accrue failed'\n    });\n}\n/**\n * Get user's token balance\n */ async function getTokenBalance(provider, tokenAddress, userAddress) {\n    let decimals = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 18;\n    const tokenContract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(tokenAddress, _config_abis__WEBPACK_IMPORTED_MODULE_0__.ERC20_ABI, provider);\n    const balance = await tokenContract.balanceOf(userAddress);\n    return (0,ethers__WEBPACK_IMPORTED_MODULE_2__.formatUnits)(balance, decimals);\n}\n/**\n * Get user's token allowance\n */ async function getTokenAllowance(provider, tokenAddress, userAddress, spender) {\n    let decimals = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 18;\n    const tokenContract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(tokenAddress, _config_abis__WEBPACK_IMPORTED_MODULE_0__.ERC20_ABI, provider);\n    const allowance = await tokenContract.allowance(userAddress, spender);\n    return (0,ethers__WEBPACK_IMPORTED_MODULE_2__.formatUnits)(allowance, decimals);\n}\n/**\n * Parse token amount to BigInt\n */ function parseTokenAmount(amount, decimals) {\n    return (0,ethers__WEBPACK_IMPORTED_MODULE_2__.parseUnits)(amount, decimals);\n}\n/**\n * Format token amount from BigInt\n */ function formatTokenAmount(amount, decimals) {\n    return (0,ethers__WEBPACK_IMPORTED_MODULE_2__.formatUnits)(amount, decimals);\n}\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WSxNQUFNTCxjQUFjSyxTQUFTLENBQUNILGFBQWFKO0lBQzdELE9BQU9wQixtREFBV0EsQ0FBQzJCLFdBQVdtQjtBQUNoQztBQUVBOztDQUVDLEdBQ00sU0FBU0ksaUJBQWlCN0IsTUFBYyxFQUFFeUIsUUFBZ0I7SUFDL0QsT0FBTzdDLGtEQUFVQSxDQUFDb0IsUUFBUXlCO0FBQzVCO0FBRUE7O0NBRUMsR0FDTSxTQUFTSyxrQkFBa0I5QixNQUFjLEVBQUV5QixRQUFnQjtJQUNoRSxPQUFPOUMsbURBQVdBLENBQUNxQixRQUFReUI7QUFDN0IiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxzcmNcXGxpYlxcdHgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVHJhbnNhY3Rpb24gc2VydmljZSB3aXRoIHRvYXN0IG5vdGlmaWNhdGlvbnNcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XG5pbXBvcnQgeyBFUkMyMF9BQkksIFBPT0xfQUJJIH0gZnJvbSAnLi4vY29uZmlnL2FiaXMnO1xuaW1wb3J0IHsgQ09ORklHIH0gZnJvbSAnLi4vY29uZmlnL2NvbnRyYWN0cyc7XG5pbXBvcnQgeyBmb3JtYXRVbml0cywgcGFyc2VVbml0cyB9IGZyb20gJ2V0aGVycyc7XG5cbi8vIFRvYXN0IG5vdGlmaWNhdGlvbiB0eXBlc1xuZXhwb3J0IGludGVyZmFjZSBUb2FzdENvbmZpZyB7XG4gIHBlbmRpbmc6IHN0cmluZztcbiAgc3VjY2Vzczogc3RyaW5nO1xuICBlcnJvcjogc3RyaW5nO1xufVxuXG4vLyBUcmFuc2FjdGlvbiByZXN1bHRcbmV4cG9ydCBpbnRlcmZhY2UgVHhSZXN1bHQge1xuICBoYXNoOiBzdHJpbmc7XG4gIHJlY2VpcHQ6IGV0aGVycy5UcmFuc2FjdGlvblJlY2VpcHQ7XG59XG5cbi8qKlxuICogU2VuZCB0cmFuc2FjdGlvbiB3aXRoIHRvYXN0IG5vdGlmaWNhdGlvbnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRXaXRoVG9hc3QoXG4gIHR4UHJvbWlzZTogUHJvbWlzZTxldGhlcnMuVHJhbnNhY3Rpb25SZXNwb25zZT4sXG4gIGNvbmZpZzogVG9hc3RDb25maWdcbik6IFByb21pc2U8VHhSZXN1bHQ+IHtcbiAgdHJ5IHtcbiAgICAvLyBTaG93IHBlbmRpbmcgdG9hc3RcbiAgICBjb25zb2xlLmxvZygn4o+zJywgY29uZmlnLnBlbmRpbmcpO1xuICAgIFxuICAgIC8vIFNlbmQgdHJhbnNhY3Rpb25cbiAgICBjb25zdCB0eCA9IGF3YWl0IHR4UHJvbWlzZTtcbiAgICBjb25zb2xlLmxvZygn8J+TpCBUcmFuc2FjdGlvbiBzZW50OicsIHR4Lmhhc2gpO1xuICAgIFxuICAgIC8vIFNob3cgcGVuZGluZyB3aXRoIGhhc2hcbiAgICBjb25zb2xlLmxvZygn4o+zJywgYCR7Y29uZmlnLnBlbmRpbmd9IC0gSGFzaDogJHt0eC5oYXNofWApO1xuICAgIFxuICAgIC8vIFdhaXQgZm9yIGNvbmZpcm1hdGlvblxuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KCk7XG4gICAgY29uc29sZS5sb2coJ+KchScsIGNvbmZpZy5zdWNjZXNzKTtcbiAgICBjb25zb2xlLmxvZygn8J+TiyBSZWNlaXB0OicsIHtcbiAgICAgIGhhc2g6IHR4Lmhhc2gsXG4gICAgICBnYXNVc2VkOiByZWNlaXB0Py5nYXNVc2VkPy50b1N0cmluZygpLFxuICAgICAgc3RhdHVzOiByZWNlaXB0Py5zdGF0dXNcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgaGFzaDogdHguaGFzaCxcbiAgICAgIHJlY2VpcHQ6IHJlY2VpcHQhXG4gICAgfTtcbiAgICBcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCcsIGNvbmZpZy5lcnJvcik7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGV0YWlsczonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBBcHByb3ZlIEVSQzIwIHRva2VuIGlmIG5lZWRlZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXBwcm92ZUlmTmVlZGVkKFxuICBzaWduZXI6IGV0aGVycy5TaWduZXIsXG4gIHRva2VuQWRkcmVzczogc3RyaW5nLFxuICBzcGVuZGVyOiBzdHJpbmcsXG4gIGFtb3VudDogYmlnaW50XG4pOiBQcm9taXNlPFR4UmVzdWx0IHwgbnVsbD4ge1xuICBjb25zdCB0b2tlbkNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdCh0b2tlbkFkZHJlc3MsIEVSQzIwX0FCSSwgc2lnbmVyKTtcbiAgY29uc3QgdXNlckFkZHJlc3MgPSBhd2FpdCBzaWduZXIuZ2V0QWRkcmVzcygpO1xuICBcbiAgLy8gQ2hlY2sgY3VycmVudCBhbGxvd2FuY2VcbiAgY29uc3QgY3VycmVudEFsbG93YW5jZSA9IGF3YWl0IHRva2VuQ29udHJhY3QuYWxsb3dhbmNlKHVzZXJBZGRyZXNzLCBzcGVuZGVyKTtcbiAgXG4gIGlmIChjdXJyZW50QWxsb3dhbmNlID49IGFtb3VudCkge1xuICAgIGNvbnNvbGUubG9nKCfinIUgQWxsb3dhbmNlIHN1ZmZpY2llbnQsIHNraXBwaW5nIGFwcHJvdmFsJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgXG4gIGNvbnNvbGUubG9nKCfwn5OdIEFwcHJvdmFsIG5lZWRlZDonLCB7XG4gICAgY3VycmVudDogY3VycmVudEFsbG93YW5jZS50b1N0cmluZygpLFxuICAgIHJlcXVpcmVkOiBhbW91bnQudG9TdHJpbmcoKVxuICB9KTtcbiAgXG4gIC8vIFNlbmQgYXBwcm92YWwgdHJhbnNhY3Rpb25cbiAgY29uc3QgdHhQcm9taXNlID0gdG9rZW5Db250cmFjdC5hcHByb3ZlKHNwZW5kZXIsIGFtb3VudCk7XG4gIFxuICByZXR1cm4gYXdhaXQgc2VuZFdpdGhUb2FzdCh0eFByb21pc2UsIHtcbiAgICBwZW5kaW5nOiAnQXBwcm92aW5nIHRva2VuLi4uJyxcbiAgICBzdWNjZXNzOiAnVG9rZW4gYXBwcm92ZWQgc3VjY2Vzc2Z1bGx5IScsXG4gICAgZXJyb3I6ICdBcHByb3ZhbCBmYWlsZWQnXG4gIH0pO1xufVxuXG4vKipcbiAqIExlbmQgdG9rZW5zIHRvIHRoZSBwb29sXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsZW5kKFxuICBzaWduZXI6IGV0aGVycy5TaWduZXIsXG4gIHRva2VuQWRkcmVzczogc3RyaW5nLFxuICBhbW91bnQ6IGJpZ2ludFxuKTogUHJvbWlzZTxUeFJlc3VsdD4ge1xuICBjb25zdCBwb29sQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KENPTkZJRy5MRU5ESU5HX1BPT0wsIFBPT0xfQUJJLCBzaWduZXIpO1xuICBcbiAgLy8gQXBwcm92ZSBpZiBuZWVkZWRcbiAgYXdhaXQgYXBwcm92ZUlmTmVlZGVkKHNpZ25lciwgdG9rZW5BZGRyZXNzLCBDT05GSUcuTEVORElOR19QT09MLCBhbW91bnQpO1xuICBcbiAgLy8gU2VuZCBsZW5kIHRyYW5zYWN0aW9uXG4gIGNvbnN0IHR4UHJvbWlzZSA9IHBvb2xDb250cmFjdC5sZW5kKHRva2VuQWRkcmVzcywgYW1vdW50KTtcbiAgXG4gIHJldHVybiBhd2FpdCBzZW5kV2l0aFRvYXN0KHR4UHJvbWlzZSwge1xuICAgIHBlbmRpbmc6ICdTdXBwbHlpbmcgdG9rZW5zLi4uJyxcbiAgICBzdWNjZXNzOiAnVG9rZW5zIHN1cHBsaWVkIHN1Y2Nlc3NmdWxseSEnLFxuICAgIGVycm9yOiAnU3VwcGx5IGZhaWxlZCdcbiAgfSk7XG59XG5cbi8qKlxuICogV2l0aGRyYXcgdG9rZW5zIGZyb20gdGhlIHBvb2xcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdpdGhkcmF3KFxuICBzaWduZXI6IGV0aGVycy5TaWduZXIsXG4gIHRva2VuQWRkcmVzczogc3RyaW5nLFxuICBhbW91bnQ6IGJpZ2ludFxuKTogUHJvbWlzZTxUeFJlc3VsdD4ge1xuICBjb25zdCBwb29sQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KENPTkZJRy5MRU5ESU5HX1BPT0wsIFBPT0xfQUJJLCBzaWduZXIpO1xuICBcbiAgY29uc3QgdHhQcm9taXNlID0gcG9vbENvbnRyYWN0LndpdGhkcmF3KHRva2VuQWRkcmVzcywgYW1vdW50KTtcbiAgXG4gIHJldHVybiBhd2FpdCBzZW5kV2l0aFRvYXN0KHR4UHJvbWlzZSwge1xuICAgIHBlbmRpbmc6ICdXaXRoZHJhd2luZyB0b2tlbnMuLi4nLFxuICAgIHN1Y2Nlc3M6ICdUb2tlbnMgd2l0aGRyYXduIHN1Y2Nlc3NmdWxseSEnLFxuICAgIGVycm9yOiAnV2l0aGRyYXcgZmFpbGVkJ1xuICB9KTtcbn1cblxuLyoqXG4gKiBCb3Jyb3cgdG9rZW5zIGZyb20gdGhlIHBvb2xcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJvcnJvdyhcbiAgc2lnbmVyOiBldGhlcnMuU2lnbmVyLFxuICB0b2tlbkFkZHJlc3M6IHN0cmluZyxcbiAgYW1vdW50OiBiaWdpbnRcbik6IFByb21pc2U8VHhSZXN1bHQ+IHtcbiAgY29uc3QgcG9vbENvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChDT05GSUcuTEVORElOR19QT09MLCBQT09MX0FCSSwgc2lnbmVyKTtcbiAgXG4gIGNvbnN0IHR4UHJvbWlzZSA9IHBvb2xDb250cmFjdC5ib3Jyb3codG9rZW5BZGRyZXNzLCBhbW91bnQpO1xuICBcbiAgcmV0dXJuIGF3YWl0IHNlbmRXaXRoVG9hc3QodHhQcm9taXNlLCB7XG4gICAgcGVuZGluZzogJ0JvcnJvd2luZyB0b2tlbnMuLi4nLFxuICAgIHN1Y2Nlc3M6ICdUb2tlbnMgYm9ycm93ZWQgc3VjY2Vzc2Z1bGx5IScsXG4gICAgZXJyb3I6ICdCb3Jyb3cgZmFpbGVkJ1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZXBheSBib3Jyb3dlZCB0b2tlbnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlcGF5KFxuICBzaWduZXI6IGV0aGVycy5TaWduZXIsXG4gIHRva2VuQWRkcmVzczogc3RyaW5nLFxuICBhbW91bnQ6IGJpZ2ludCxcbiAgdXNlckFkZHJlc3M/OiBzdHJpbmdcbik6IFByb21pc2U8VHhSZXN1bHQ+IHtcbiAgY29uc3QgcG9vbENvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChDT05GSUcuTEVORElOR19QT09MLCBQT09MX0FCSSwgc2lnbmVyKTtcbiAgY29uc3QgYm9ycm93ZXIgPSB1c2VyQWRkcmVzcyB8fCBhd2FpdCBzaWduZXIuZ2V0QWRkcmVzcygpO1xuICBcbiAgLy8gQXBwcm92ZSBpZiBuZWVkZWRcbiAgYXdhaXQgYXBwcm92ZUlmTmVlZGVkKHNpZ25lciwgdG9rZW5BZGRyZXNzLCBDT05GSUcuTEVORElOR19QT09MLCBhbW91bnQpO1xuICBcbiAgY29uc3QgdHhQcm9taXNlID0gcG9vbENvbnRyYWN0LnJlcGF5KHRva2VuQWRkcmVzcywgYW1vdW50LCBib3Jyb3dlcik7XG4gIFxuICByZXR1cm4gYXdhaXQgc2VuZFdpdGhUb2FzdCh0eFByb21pc2UsIHtcbiAgICBwZW5kaW5nOiAnUmVwYXlpbmcgdG9rZW5zLi4uJyxcbiAgICBzdWNjZXNzOiAnVG9rZW5zIHJlcGFpZCBzdWNjZXNzZnVsbHkhJyxcbiAgICBlcnJvcjogJ1JlcGF5IGZhaWxlZCdcbiAgfSk7XG59XG5cbi8qKlxuICogTGlxdWlkYXRlIGEgcG9zaXRpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxpcXVpZGF0ZShcbiAgc2lnbmVyOiBldGhlcnMuU2lnbmVyLFxuICBjb2xsYXRlcmFsQXNzZXQ6IHN0cmluZyxcbiAgZGVidEFzc2V0OiBzdHJpbmcsXG4gIGRlYnRBbW91bnQ6IGJpZ2ludCxcbiAgdXNlckFkZHJlc3M6IHN0cmluZ1xuKTogUHJvbWlzZTxUeFJlc3VsdD4ge1xuICBjb25zdCBwb29sQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KENPTkZJRy5MRU5ESU5HX1BPT0wsIFBPT0xfQUJJLCBzaWduZXIpO1xuICBcbiAgY29uc3QgdHhQcm9taXNlID0gcG9vbENvbnRyYWN0LmxpcXVpZGF0aW9uQ2FsbChjb2xsYXRlcmFsQXNzZXQsIGRlYnRBc3NldCwgZGVidEFtb3VudCwgdXNlckFkZHJlc3MpO1xuICBcbiAgcmV0dXJuIGF3YWl0IHNlbmRXaXRoVG9hc3QodHhQcm9taXNlLCB7XG4gICAgcGVuZGluZzogJ0xpcXVpZGF0aW5nIHBvc2l0aW9uLi4uJyxcbiAgICBzdWNjZXNzOiAnUG9zaXRpb24gbGlxdWlkYXRlZCBzdWNjZXNzZnVsbHkhJyxcbiAgICBlcnJvcjogJ0xpcXVpZGF0aW9uIGZhaWxlZCdcbiAgfSk7XG59XG5cbi8qKlxuICogQWNjcnVlIGludGVyZXN0IGZvciBhbGwgcmVzZXJ2ZXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFjY3J1ZVB1YmxpYyhzaWduZXI6IGV0aGVycy5TaWduZXIpOiBQcm9taXNlPFR4UmVzdWx0PiB7XG4gIGNvbnN0IHBvb2xDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoQ09ORklHLkxFTkRJTkdfUE9PTCwgUE9PTF9BQkksIHNpZ25lcik7XG4gIFxuICBjb25zdCB0eFByb21pc2UgPSBwb29sQ29udHJhY3QuYWNjcnVlUHVibGljKCk7XG4gIFxuICByZXR1cm4gYXdhaXQgc2VuZFdpdGhUb2FzdCh0eFByb21pc2UsIHtcbiAgICBwZW5kaW5nOiAnQWNjcnVpbmcgaW50ZXJlc3QuLi4nLFxuICAgIHN1Y2Nlc3M6ICdJbnRlcmVzdCBhY2NydWVkIHN1Y2Nlc3NmdWxseSEnLFxuICAgIGVycm9yOiAnQWNjcnVlIGZhaWxlZCdcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHVzZXIncyB0b2tlbiBiYWxhbmNlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUb2tlbkJhbGFuY2UoXG4gIHByb3ZpZGVyOiBldGhlcnMuUHJvdmlkZXIsXG4gIHRva2VuQWRkcmVzczogc3RyaW5nLFxuICB1c2VyQWRkcmVzczogc3RyaW5nLFxuICBkZWNpbWFsczogbnVtYmVyID0gMThcbik6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IHRva2VuQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KHRva2VuQWRkcmVzcywgRVJDMjBfQUJJLCBwcm92aWRlcik7XG4gIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCB0b2tlbkNvbnRyYWN0LmJhbGFuY2VPZih1c2VyQWRkcmVzcyk7XG4gIHJldHVybiBmb3JtYXRVbml0cyhiYWxhbmNlLCBkZWNpbWFscyk7XG59XG5cbi8qKlxuICogR2V0IHVzZXIncyB0b2tlbiBhbGxvd2FuY2VcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRva2VuQWxsb3dhbmNlKFxuICBwcm92aWRlcjogZXRoZXJzLlByb3ZpZGVyLFxuICB0b2tlbkFkZHJlc3M6IHN0cmluZyxcbiAgdXNlckFkZHJlc3M6IHN0cmluZyxcbiAgc3BlbmRlcjogc3RyaW5nLFxuICBkZWNpbWFsczogbnVtYmVyID0gMThcbik6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IHRva2VuQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KHRva2VuQWRkcmVzcywgRVJDMjBfQUJJLCBwcm92aWRlcik7XG4gIGNvbnN0IGFsbG93YW5jZSA9IGF3YWl0IHRva2VuQ29udHJhY3QuYWxsb3dhbmNlKHVzZXJBZGRyZXNzLCBzcGVuZGVyKTtcbiAgcmV0dXJuIGZvcm1hdFVuaXRzKGFsbG93YW5jZSwgZGVjaW1hbHMpO1xufVxuXG4vKipcbiAqIFBhcnNlIHRva2VuIGFtb3VudCB0byBCaWdJbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVG9rZW5BbW91bnQoYW1vdW50OiBzdHJpbmcsIGRlY2ltYWxzOiBudW1iZXIpOiBiaWdpbnQge1xuICByZXR1cm4gcGFyc2VVbml0cyhhbW91bnQsIGRlY2ltYWxzKTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgdG9rZW4gYW1vdW50IGZyb20gQmlnSW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUb2tlbkFtb3VudChhbW91bnQ6IGJpZ2ludCwgZGVjaW1hbHM6IG51bWJlcik6IHN0cmluZyB7XG4gIHJldHVybiBmb3JtYXRVbml0cyhhbW91bnQsIGRlY2ltYWxzKTtcbn1cbiJdLCJuYW1lcyI6WyJldGhlcnMiLCJFUkMyMF9BQkkiLCJQT09MX0FCSSIsIkNPTkZJRyIsImZvcm1hdFVuaXRzIiwicGFyc2VVbml0cyIsInNlbmRXaXRoVG9hc3QiLCJ0eFByb21pc2UiLCJjb25maWciLCJyZWNlaXB0IiwiY29uc29sZSIsImxvZyIsInBlbmRpbmciLCJ0eCIsImhhc2giLCJ3YWl0Iiwic3VjY2VzcyIsImdhc1VzZWQiLCJ0b1N0cmluZyIsInN0YXR1cyIsImVycm9yIiwiYXBwcm92ZUlmTmVlZGVkIiwic2lnbmVyIiwidG9rZW5BZGRyZXNzIiwic3BlbmRlciIsImFtb3VudCIsInRva2VuQ29udHJhY3QiLCJDb250cmFjdCIsInVzZXJBZGRyZXNzIiwiZ2V0QWRkcmVzcyIsImN1cnJlbnRBbGxvd2FuY2UiLCJhbGxvd2FuY2UiLCJjdXJyZW50IiwicmVxdWlyZWQiLCJhcHByb3ZlIiwibGVuZCIsInBvb2xDb250cmFjdCIsIkxFTkRJTkdfUE9PTCIsIndpdGhkcmF3IiwiYm9ycm93IiwicmVwYXkiLCJib3Jyb3dlciIsImxpcXVpZGF0ZSIsImNvbGxhdGVyYWxBc3NldCIsImRlYnRBc3NldCIsImRlYnRBbW91bnQiLCJsaXF1aWRhdGlvbkNhbGwiLCJhY2NydWVQdWJsaWMiLCJnZXRUb2tlbkJhbGFuY2UiLCJwcm92aWRlciIsImRlY2ltYWxzIiwiYmFsYW5jZSIsImJhbGFuY2VPZiIsImdldFRva2VuQWxsb3dhbmNlIiwicGFyc2VUb2tlbkFtb3VudCIsImZvcm1hdFRva2VuQW1vdW50Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/lib/tx.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/pages/_app.tsx":
/*!****************************!*\
  !*** ./src/pages/_app.tsx ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ App)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/styles/globals.css */ \"(pages-dir-browser)/./src/styles/globals.css\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_styles_globals_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_toastify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-toastify */ \"(pages-dir-browser)/./node_modules/react-toastify/dist/react-toastify.esm.mjs\");\n/* harmony import */ var react_toastify_dist_ReactToastify_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-toastify/dist/ReactToastify.css */ \"(pages-dir-browser)/./node_modules/react-toastify/dist/ReactToastify.css\");\n/* harmony import */ var react_toastify_dist_ReactToastify_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_toastify_dist_ReactToastify_css__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _context_LendState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/context/LendState */ \"(pages-dir-browser)/./src/context/LendState.js\");\n\n\n\n\n\nfunction App(param) {\n    let { Component, pageProps } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_context_LendState__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                name: \"viewport\",\n                content: \"width=device-width, initial-scale=1\"\n            }, void 0, false, {\n                fileName: \"D:\\\\Do_an2\\\\lendhub_v2\\\\lendhub-frontend-nextjs\\\\src\\\\pages\\\\_app.tsx\",\n                lineNumber: 11,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, {\n                ...pageProps\n            }, void 0, false, {\n                fileName: \"D:\\\\Do_an2\\\\lendhub_v2\\\\lendhub-frontend-nextjs\\\\src\\\\pages\\\\_app.tsx\",\n                lineNumber: 12,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_toastify__WEBPACK_IMPORTED_MODULE_2__.ToastContainer, {\n                position: \"top-right\",\n                autoClose: 5000,\n                hideProgressBar: false,\n                newestOnTop: false,\n                closeOnClick: true,\n                rtl: false,\n                pauseOnFocusLoss: true,\n                draggable: true,\n                pauseOnHover: true,\n                theme: \"dark\"\n            }, void 0, false, {\n                fileName: \"D:\\\\Do_an2\\\\lendhub_v2\\\\lendhub-frontend-nextjs\\\\src\\\\pages\\\\_app.tsx\",\n                lineNumber: 13,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\Do_an2\\\\lendhub_v2\\\\lendhub-frontend-nextjs\\\\src\\\\pages\\\\_app.tsx\",\n        lineNumber: 9,\n        columnNumber: 5\n    }, this);\n}\n_c = App;\nvar _c;\n$RefreshReg$(_c, \"App\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9wYWdlcy9fYXBwLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQTZCO0FBRWtCO0FBQ0Q7QUFDSDtBQUU1QixTQUFTRSxJQUFJLEtBQWtDO1FBQWxDLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFZLEdBQWxDO0lBQzFCLHFCQUNFLDhEQUFDSCwwREFBU0E7OzBCQUVSLDhEQUFDSTtnQkFBS0MsTUFBSztnQkFBV0MsU0FBUTs7Ozs7OzBCQUM5Qiw4REFBQ0o7Z0JBQVcsR0FBR0MsU0FBUzs7Ozs7OzBCQUN4Qiw4REFBQ0osMERBQWNBO2dCQUNiUSxVQUFTO2dCQUNUQyxXQUFXO2dCQUNYQyxpQkFBaUI7Z0JBQ2pCQyxhQUFhO2dCQUNiQyxZQUFZO2dCQUNaQyxLQUFLO2dCQUNMQyxnQkFBZ0I7Z0JBQ2hCQyxTQUFTO2dCQUNUQyxZQUFZO2dCQUNaQyxPQUFNOzs7Ozs7Ozs7Ozs7QUFJZDtLQXBCd0JmIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcc3JjXFxwYWdlc1xcX2FwcC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdAL3N0eWxlcy9nbG9iYWxzLmNzcydcclxuaW1wb3J0IHR5cGUgeyBBcHBQcm9wcyB9IGZyb20gJ25leHQvYXBwJ1xyXG5pbXBvcnQgeyBUb2FzdENvbnRhaW5lciB9IGZyb20gJ3JlYWN0LXRvYXN0aWZ5J1xyXG5pbXBvcnQgJ3JlYWN0LXRvYXN0aWZ5L2Rpc3QvUmVhY3RUb2FzdGlmeS5jc3MnXHJcbmltcG9ydCBMZW5kU3RhdGUgZnJvbSAnQC9jb250ZXh0L0xlbmRTdGF0ZSdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFwcCh7IENvbXBvbmVudCwgcGFnZVByb3BzIH06IEFwcFByb3BzKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxMZW5kU3RhdGU+XHJcbiAgICAgIHsvKiBOZXh0LmpzIHJlY29tbWVuZHMgdmlld3BvcnQgbWV0YSBpbiBfYXBwICovfVxyXG4gICAgICA8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwid2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTFcIiAvPlxyXG4gICAgICA8Q29tcG9uZW50IHsuLi5wYWdlUHJvcHN9IC8+XHJcbiAgICAgIDxUb2FzdENvbnRhaW5lclxyXG4gICAgICAgIHBvc2l0aW9uPVwidG9wLXJpZ2h0XCJcclxuICAgICAgICBhdXRvQ2xvc2U9ezUwMDB9XHJcbiAgICAgICAgaGlkZVByb2dyZXNzQmFyPXtmYWxzZX1cclxuICAgICAgICBuZXdlc3RPblRvcD17ZmFsc2V9XHJcbiAgICAgICAgY2xvc2VPbkNsaWNrXHJcbiAgICAgICAgcnRsPXtmYWxzZX1cclxuICAgICAgICBwYXVzZU9uRm9jdXNMb3NzXHJcbiAgICAgICAgZHJhZ2dhYmxlXHJcbiAgICAgICAgcGF1c2VPbkhvdmVyXHJcbiAgICAgICAgdGhlbWU9XCJkYXJrXCJcclxuICAgICAgLz5cclxuICAgIDwvTGVuZFN0YXRlPlxyXG4gIClcclxufVxyXG5cclxuXHJcbiJdLCJuYW1lcyI6WyJUb2FzdENvbnRhaW5lciIsIkxlbmRTdGF0ZSIsIkFwcCIsIkNvbXBvbmVudCIsInBhZ2VQcm9wcyIsIm1ldGEiLCJuYW1lIiwiY29udGVudCIsInBvc2l0aW9uIiwiYXV0b0Nsb3NlIiwiaGlkZVByb2dyZXNzQmFyIiwibmV3ZXN0T25Ub3AiLCJjbG9zZU9uQ2xpY2siLCJydGwiLCJwYXVzZU9uRm9jdXNMb3NzIiwiZHJhZ2dhYmxlIiwicGF1c2VPbkhvdmVyIiwidGhlbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/pages/_app.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/styles/globals.css":
/*!********************************!*\
  !*** ./src/styles/globals.css ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./globals.css */ \"(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./src/styles/globals.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\r\n                    // By default, style-loader injects CSS into the bottom\r\n                    // of <head>. This causes ordering problems between dev\r\n                    // and prod. To fix this, we render a <noscript> tag as\r\n                    // an anchor for the styles to be placed before. These\r\n                    // styles will be applied _before_ <style jsx global>.\r\n                    // These elements should always exist. If they do not,\r\n                    // this code should fail.\r\n                    var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');\r\n                    var parentNode = anchorElement.parentNode// Normally <head>\r\n                    ;\r\n                    // Each style tag should be placed right before our\r\n                    // anchor. By inserting before and not after, we do not\r\n                    // need to track the last inserted element.\r\n                    parentNode.insertBefore(element, anchorElement);\r\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\r\n    if (!a && b || a && !b) {\r\n        return false;\r\n    }\r\n    let p;\r\n    for(p in a){\r\n        if (isNamedExport && p === 'default') {\r\n            continue;\r\n        }\r\n        if (a[p] !== b[p]) {\r\n            return false;\r\n        }\r\n    }\r\n    for(p in b){\r\n        if (isNamedExport && p === 'default') {\r\n            continue;\r\n        }\r\n        if (!a[p]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./globals.css */ \"(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./src/styles/globals.css\",\n      function () {\n        content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./globals.css */ \"(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./src/styles/globals.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9zdHlsZXMvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLDJPQUEyRztBQUM3SCwwQkFBMEIsbUJBQU8sQ0FBQyx5Z0JBQXVQOztBQUV6Ujs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2QseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksaUJBQWlCO0FBQ3JCLE1BQU0seWdCQUF1UDtBQUM3UDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHlnQkFBdVA7O0FBRWpSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsVUFBVTtBQUNaO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcc3JjXFxzdHlsZXNcXGdsb2JhbHMuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s4XS5vbmVPZlsxM10udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s4XS5vbmVPZlsxM10udXNlWzJdIS4vZ2xvYmFscy5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgc3R5bGUtbG9hZGVyIGluamVjdHMgQ1NTIGludG8gdGhlIGJvdHRvbVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIDxoZWFkPi4gVGhpcyBjYXVzZXMgb3JkZXJpbmcgcHJvYmxlbXMgYmV0d2VlbiBkZXZcclxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcHJvZC4gVG8gZml4IHRoaXMsIHdlIHJlbmRlciBhIDxub3NjcmlwdD4gdGFnIGFzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gYW5jaG9yIGZvciB0aGUgc3R5bGVzIHRvIGJlIHBsYWNlZCBiZWZvcmUuIFRoZXNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBfYmVmb3JlXyA8c3R5bGUganN4IGdsb2JhbD4uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcclxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYW5jaG9yRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XHJcbiAgICBpZiAoIWEgJiYgYiB8fCBhICYmICFiKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbGV0IHA7XHJcbiAgICBmb3IocCBpbiBhKXtcclxuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IocCBpbiBiKXtcclxuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYVtwXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbOF0ub25lT2ZbMTNdLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbOF0ub25lT2ZbMTNdLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s4XS5vbmVPZlsxM10udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s4XS5vbmVPZlsxM10udXNlWzJdIS4vZ2xvYmFscy5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/styles/globals.css\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main"], () => (__webpack_exec__("(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!"), __webpack_exec__("(pages-dir-browser)/./node_modules/next/dist/client/router.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);