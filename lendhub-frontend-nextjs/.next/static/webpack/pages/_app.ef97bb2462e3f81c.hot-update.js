"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./src/context/LendState.js":
/*!**********************************!*\
  !*** ./src/context/LendState.js ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lendContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lendContext */ \"(pages-dir-browser)/./src/context/lendContext.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _config_contracts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config/contracts */ \"(pages-dir-browser)/./src/config/contracts.ts\");\n/* harmony import */ var _lib_tx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/tx */ \"(pages-dir-browser)/./src/lib/tx.ts\");\n/* harmony import */ var _addresses__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../addresses */ \"(pages-dir-browser)/./src/addresses.js\");\n/* harmony import */ var _abis__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../abis */ \"(pages-dir-browser)/./src/abis/index.js\");\n/* harmony import */ var _abis__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_abis__WEBPACK_IMPORTED_MODULE_6__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n// Utility functions\nconst numberToEthers = (number)=>{\n    return ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseEther(number.toString());\n};\nconst reportError = (error)=>{\n    console.error(\"LendState Error:\", JSON.stringify(error));\n    console.error(\"Error details:\", error);\n};\nconst LendState = (props)=>{\n    _s();\n    //* Declaring all the states\n    // Set metamask details\n    const [metamaskDetails, setMetamaskDetails] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        provider: null,\n        networkName: null,\n        signer: null,\n        currentAccount: null,\n        chainId: null\n    });\n    // User assets and balances\n    const [userAssets, setUserAssets] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [supplyAssets, setSupplyAssets] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [assetsToBorrow, setAssetsToBorrow] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [yourBorrows, setYourBorrows] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Contract details\n    const [contract, setContract] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        lendingPoolContract: null,\n        oracleContract: null\n    });\n    // Summary data\n    const [supplySummary, setSupplySummary] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        totalUSDBalance: 0,\n        weightedAvgAPY: 0,\n        totalUSDCollateral: 0\n    });\n    const [borrowSummary, setBorrowSummary] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        totalUSDBalance: 0,\n        weightedAvgAPY: 0,\n        totalBorrowPowerUsed: 0\n    });\n    // Account data\n    const [accountData, setAccountData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        collateralUSD: \"0\",\n        debtUSD: \"0\",\n        healthFactor: \"0\"\n    });\n    // Connect wallet\n    // const connectWallet = useCallback(async () => {\n    //   console.log(\"1. Connecting to wallet...\");\n    //   const { ethereum } = window;\n    //   const failMessage = \"Please install Metamask & connect your Metamask\";\n    //   try {\n    //     if (!ethereum) {\n    //       alert(failMessage);\n    //       return;\n    //     }\n    //     const accounts = await ethereum.request({\n    //       method: \"eth_requestAccounts\",\n    //     });\n    //     // Listen for account and chain changes\n    //     ethereum.on(\"chainChanged\", () => {\n    //       window.location.reload();\n    //     });\n    //     ethereum.on(\"accountsChanged\", () => {\n    //       window.location.reload();\n    //     });\n    //     const provider = new ethers.BrowserProvider(ethereum);\n    //     const network = await provider.getNetwork();\n    //     const networkName = network.name;\n    //     const signer = await provider.getSigner();\n    //     if (accounts.length) {\n    //       let currentAddress = accounts[0];\n    //       setMetamaskDetails({\n    //         provider: provider,\n    //         networkName: networkName,\n    //         signer: signer,\n    //         currentAccount: currentAddress,\n    //         chainId: Number(network.chainId),\n    //       });\n    //       console.log(\"Connected to wallet:\", currentAddress);\n    //     } else {\n    //       alert(failMessage);\n    //       return;\n    //     }\n    //   } catch (error) {\n    //     reportError(error);\n    //   }\n    // }, []);\n    const connectWallet = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[connectWallet]\": async ()=>{\n            console.log(\"1. Connecting to wallet...\");\n            const { ethereum } = window;\n            const failMessage = \"Please install Metamask & connect your Metamask\";\n            try {\n                if (!ethereum) {\n                    alert(failMessage);\n                    return;\n                }\n                const accounts = await ethereum.request({\n                    method: \"eth_requestAccounts\"\n                });\n                // Listen for account and chain changes\n                ethereum.on(\"chainChanged\", {\n                    \"LendState.useCallback[connectWallet]\": ()=>{\n                        window.location.reload();\n                    }\n                }[\"LendState.useCallback[connectWallet]\"]);\n                ethereum.on(\"accountsChanged\", {\n                    \"LendState.useCallback[connectWallet]\": ()=>{\n                        window.location.reload();\n                    }\n                }[\"LendState.useCallback[connectWallet]\"]);\n                const provider = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.BrowserProvider(ethereum);\n                const network = await provider.getNetwork();\n                const networkName = network.name;\n                const signer = await provider.getSigner();\n                if (accounts.length) {\n                    let currentAddress = accounts[0];\n                    setMetamaskDetails({\n                        provider: provider,\n                        networkName: networkName,\n                        signer: signer,\n                        currentAccount: currentAddress,\n                        chainId: Number(network.chainId)\n                    });\n                    console.log(\"Connected to wallet++++++++++++++++++++++++++++++++++:\", currentAddress);\n                } else {\n                    alert(failMessage);\n                    return;\n                }\n            } catch (error) {\n                reportError(error);\n            }\n        }\n    }[\"LendState.useCallback[connectWallet]\"], []);\n    // Get contract instance\n    const getContract = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getContract]\": async (address, abi)=>{\n            if (!metamaskDetails.provider) return null;\n            const contract = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(address, abi, metamaskDetails.provider);\n            return contract;\n        }\n    }[\"LendState.useCallback[getContract]\"], [\n        metamaskDetails.provider\n    ]);\n    // Get user assets (balances)\n    const getUserAssets = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getUserAssets]\": async ()=>{\n            console.log(\"2. Getting user assets...\");\n            try {\n                if (!metamaskDetails.provider || !metamaskDetails.currentAccount) return [];\n                const assets = await Promise.all(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.map({\n                    \"LendState.useCallback[getUserAssets]\": async (token)=>{\n                        let balance = \"0\";\n                        let balanceUSD = 0;\n                        try {\n                            if (token.isNative) {\n                                // ETH native balance\n                                const bal = await metamaskDetails.provider.getBalance(metamaskDetails.currentAccount);\n                                balance = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatEther(bal);\n                            } else {\n                                // ERC20 token balance\n                                balance = await (0,_lib_tx__WEBPACK_IMPORTED_MODULE_4__.getTokenBalance)(metamaskDetails.provider, token.address, metamaskDetails.currentAccount, token.decimals);\n                            }\n                            // Get USD value\n                            const price = await getPriceUSD(token.address);\n                            balanceUSD = parseFloat(balance) * parseFloat(price);\n                            return {\n                                address: token.address,\n                                symbol: token.symbol,\n                                name: token.name,\n                                decimals: token.decimals,\n                                isNative: token.isNative,\n                                balance: balance,\n                                balanceUSD: balanceUSD,\n                                priceUSD: price\n                            };\n                        } catch (error) {\n                            console.warn(\"Error getting balance for \".concat(token.symbol, \":\"), error);\n                            return {\n                                address: token.address,\n                                symbol: token.symbol,\n                                name: token.name,\n                                decimals: token.decimals,\n                                isNative: token.isNative,\n                                balance: \"0\",\n                                balanceUSD: 0,\n                                priceUSD: \"0\"\n                            };\n                        }\n                    }\n                }[\"LendState.useCallback[getUserAssets]\"]));\n                setUserAssets(assets);\n                console.log(\"Got user assets:\", assets);\n                return assets;\n            } catch (error) {\n                reportError(error);\n                return [];\n            }\n        }\n    }[\"LendState.useCallback[getUserAssets]\"], [\n        metamaskDetails.provider,\n        metamaskDetails.currentAccount\n    ]);\n    // Get price in USD\n    const getPriceUSD = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getPriceUSD]\": async (asset)=>{\n            if (!metamaskDetails.provider) return \"0\";\n            try {\n                const abi = [\n                    'function getAssetPrice1e18(address asset) view returns (uint256)'\n                ];\n                const oracle = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.PRICE_ORACLE, abi, metamaskDetails.provider);\n                const price = await oracle.getAssetPrice1e18(asset);\n                return ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(price, 18);\n            } catch (error) {\n                console.warn(\"Error getting price for \".concat(asset, \":\"), error);\n                return \"0\";\n            }\n        }\n    }[\"LendState.useCallback[getPriceUSD]\"], [\n        metamaskDetails.provider\n    ]);\n    // Get amount in USD\n    const getAmountInUSD = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getAmountInUSD]\": async (address, amount)=>{\n            try {\n                const price = await getPriceUSD(address);\n                const amountInUSD = parseFloat(amount) * parseFloat(price);\n                return amountInUSD;\n            } catch (error) {\n                reportError(error);\n                return 0;\n            }\n        }\n    }[\"LendState.useCallback[getAmountInUSD]\"], [\n        getPriceUSD\n    ]);\n    // Approve tokens\n    const ApproveToContinue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[ApproveToContinue]\": async (tokenAddress, approveAmount)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const token = _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.find({\n                    \"LendState.useCallback[ApproveToContinue].token\": (t)=>t.address.toLowerCase() === tokenAddress.toLowerCase()\n                }[\"LendState.useCallback[ApproveToContinue].token\"]);\n                if (!token) throw new Error(\"Token not found\");\n                await (0,_lib_tx__WEBPACK_IMPORTED_MODULE_4__.approveIfNeeded)(metamaskDetails.signer, tokenAddress, _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.LENDING_POOL, approveAmount, token.decimals);\n                console.log(\"Token approved:\", tokenAddress);\n                return {\n                    status: 200,\n                    message: \"Transaction Successful...\"\n                };\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[ApproveToContinue]\"], [\n        metamaskDetails.signer\n    ]);\n    // Lend asset\n    const LendAsset = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[LendAsset]\": async (token, supplyAmount)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const tokenInfo = _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.find({\n                    \"LendState.useCallback[LendAsset].tokenInfo\": (t)=>t.address.toLowerCase() === token.toLowerCase()\n                }[\"LendState.useCallback[LendAsset].tokenInfo\"]);\n                if (!tokenInfo) throw new Error(\"Token not found\");\n                const amount = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(supplyAmount, tokenInfo.decimals);\n                const tx = await (0,_lib_tx__WEBPACK_IMPORTED_MODULE_4__.lend)(metamaskDetails.signer, token, amount);\n                if (tx) {\n                    console.log(\"Asset lent successfully:\", token, supplyAmount);\n                    return {\n                        status: 200,\n                        message: \"Transaction Successful...\",\n                        hash: tx.hash\n                    };\n                }\n                throw new Error(\"Transaction failed\");\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[LendAsset]\"], [\n        metamaskDetails.signer\n    ]);\n    // Withdraw asset\n    const WithdrawAsset = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[WithdrawAsset]\": async (tokenAddress, withdrawAmount)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const tokenInfo = _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.find({\n                    \"LendState.useCallback[WithdrawAsset].tokenInfo\": (t)=>t.address.toLowerCase() === tokenAddress.toLowerCase()\n                }[\"LendState.useCallback[WithdrawAsset].tokenInfo\"]);\n                if (!tokenInfo) throw new Error(\"Token not found\");\n                const amount = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(withdrawAmount, tokenInfo.decimals);\n                const tx = await (0,_lib_tx__WEBPACK_IMPORTED_MODULE_4__.withdraw)(metamaskDetails.signer, tokenAddress, amount);\n                if (tx) {\n                    console.log(\"Asset withdrawn successfully:\", tokenAddress, withdrawAmount);\n                    return {\n                        status: 200,\n                        message: \"Transaction Successful...\",\n                        hash: tx.hash\n                    };\n                }\n                throw new Error(\"Transaction failed\");\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[WithdrawAsset]\"], [\n        metamaskDetails.signer\n    ]);\n    // Borrow asset\n    const borrowAsset = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[borrowAsset]\": async (token, borrowAmount)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const tokenInfo = _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.find({\n                    \"LendState.useCallback[borrowAsset].tokenInfo\": (t)=>t.address.toLowerCase() === token.toLowerCase()\n                }[\"LendState.useCallback[borrowAsset].tokenInfo\"]);\n                if (!tokenInfo) throw new Error(\"Token not found\");\n                const amount = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(borrowAmount, tokenInfo.decimals);\n                const tx = await (0,_lib_tx__WEBPACK_IMPORTED_MODULE_4__.borrow)(metamaskDetails.signer, token, amount);\n                if (tx) {\n                    console.log(\"Asset borrowed successfully:\", token, borrowAmount);\n                    return {\n                        status: 200,\n                        message: \"Transaction Successful...\",\n                        hash: tx.hash\n                    };\n                }\n                throw new Error(\"Transaction failed\");\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[borrowAsset]\"], [\n        metamaskDetails.signer\n    ]);\n    // Repay asset\n    const repayAsset = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[repayAsset]\": async (tokenAddress, repayAmount)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const tokenInfo = _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.find({\n                    \"LendState.useCallback[repayAsset].tokenInfo\": (t)=>t.address.toLowerCase() === tokenAddress.toLowerCase()\n                }[\"LendState.useCallback[repayAsset].tokenInfo\"]);\n                if (!tokenInfo) throw new Error(\"Token not found\");\n                const amount = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(repayAmount, tokenInfo.decimals);\n                const tx = await (0,_lib_tx__WEBPACK_IMPORTED_MODULE_4__.repay)(metamaskDetails.signer, tokenAddress, amount);\n                if (tx) {\n                    console.log(\"Asset repaid successfully:\", tokenAddress, repayAmount);\n                    return {\n                        status: 200,\n                        message: \"Transaction Successful...\",\n                        hash: tx.hash\n                    };\n                }\n                throw new Error(\"Transaction failed\");\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[repayAsset]\"], [\n        metamaskDetails.signer\n    ]);\n    // Get account data (collateral, debt, health factor)\n    const getAccountData = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getAccountData]\": async (user)=>{\n            try {\n                if (!metamaskDetails.provider) return null;\n                const pool = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_addresses__WEBPACK_IMPORTED_MODULE_5__.LendingPoolAddress, _abis__WEBPACK_IMPORTED_MODULE_6__.LendingPoolABI.abi, metamaskDetails.provider);\n                const wallet = user || metamaskDetails.currentAccount || ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.ZeroAddress;\n                const [col, debt, hf] = await pool.getAccountData(wallet);\n                const accountData = {\n                    collateralUSD: ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(col, 18),\n                    debtUSD: ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(debt, 18),\n                    healthFactor: ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(hf, 18)\n                };\n                setAccountData(accountData);\n                return accountData;\n            } catch (error) {\n                reportError(error);\n                return null;\n            }\n        }\n    }[\"LendState.useCallback[getAccountData]\"], [\n        metamaskDetails.provider,\n        metamaskDetails.currentAccount\n    ]);\n    // Get your supplies\n    const getYourSupplies = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getYourSupplies]\": async ()=>{\n            console.log(\"3. Getting your supplies...\");\n            try {\n                if (!metamaskDetails.provider || !metamaskDetails.currentAccount) return [];\n                const abi = [\n                    'function getUserReserve(address user, address asset) view returns (tuple(uint128 principal,uint128 index) supply, tuple(uint128 principal,uint128 index) borrow)'\n                ];\n                const pool = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.LENDING_POOL, abi, metamaskDetails.provider);\n                const supplies = await Promise.all(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.filter({\n                    \"LendState.useCallback[getYourSupplies]\": (t)=>!t.isNative\n                }[\"LendState.useCallback[getYourSupplies]\"]).map({\n                    \"LendState.useCallback[getYourSupplies]\": async (token)=>{\n                        try {\n                            const userReserve = await pool.getUserReserve(metamaskDetails.currentAccount, token.address);\n                            const supplyPrincipal = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(userReserve.supply.principal, 18);\n                            const supplyIndex = userReserve.supply.index.toString();\n                            if (parseFloat(supplyPrincipal) > 0) {\n                                const price = await getPriceUSD(token.address);\n                                const balanceUSD = parseFloat(supplyPrincipal) * parseFloat(price);\n                                return {\n                                    address: token.address,\n                                    symbol: token.symbol,\n                                    name: token.name,\n                                    decimals: token.decimals,\n                                    supplyPrincipal: supplyPrincipal,\n                                    supplyIndex: supplyIndex,\n                                    balanceUSD: balanceUSD,\n                                    priceUSD: price\n                                };\n                            }\n                            return null;\n                        } catch (error) {\n                            console.warn(\"Error getting supply for \".concat(token.symbol, \":\"), error);\n                            return null;\n                        }\n                    }\n                }[\"LendState.useCallback[getYourSupplies]\"]));\n                const validSupplies = supplies.filter({\n                    \"LendState.useCallback[getYourSupplies].validSupplies\": (s)=>s !== null\n                }[\"LendState.useCallback[getYourSupplies].validSupplies\"]);\n                setSupplyAssets(validSupplies);\n                // Calculate summary\n                const totalUSDBalance = validSupplies.reduce({\n                    \"LendState.useCallback[getYourSupplies].totalUSDBalance\": (sum, asset)=>sum + asset.balanceUSD\n                }[\"LendState.useCallback[getYourSupplies].totalUSDBalance\"], 0);\n                const weightedAvgAPY = validSupplies.length > 0 ? validSupplies.reduce({\n                    \"LendState.useCallback[getYourSupplies]\": (sum, asset)=>sum + (asset.apy || 0)\n                }[\"LendState.useCallback[getYourSupplies]\"], 0) / validSupplies.length : 0;\n                const totalUSDCollateral = validSupplies.reduce({\n                    \"LendState.useCallback[getYourSupplies].totalUSDCollateral\": (sum, asset)=>sum + asset.balanceUSD\n                }[\"LendState.useCallback[getYourSupplies].totalUSDCollateral\"], 0);\n                setSupplySummary({\n                    totalUSDBalance,\n                    weightedAvgAPY,\n                    totalUSDCollateral\n                });\n                console.log(\"Got your supplies:\", validSupplies);\n                return validSupplies;\n            } catch (error) {\n                reportError(error);\n                return [];\n            }\n        }\n    }[\"LendState.useCallback[getYourSupplies]\"], [\n        metamaskDetails.provider,\n        metamaskDetails.currentAccount,\n        getPriceUSD\n    ]);\n    // Get your borrows\n    const getYourBorrows = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getYourBorrows]\": async ()=>{\n            console.log(\"4. Getting your borrows...\");\n            try {\n                if (!metamaskDetails.provider || !metamaskDetails.currentAccount) return [];\n                const abi = [\n                    'function getUserReserve(address user, address asset) view returns (tuple(uint128 principal,uint128 index) supply, tuple(uint128 principal,uint128 index) borrow)'\n                ];\n                const pool = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.LENDING_POOL, abi, metamaskDetails.provider);\n                const borrows = await Promise.all(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.filter({\n                    \"LendState.useCallback[getYourBorrows]\": (t)=>!t.isNative\n                }[\"LendState.useCallback[getYourBorrows]\"]).map({\n                    \"LendState.useCallback[getYourBorrows]\": async (token)=>{\n                        try {\n                            const userReserve = await pool.getUserReserve(metamaskDetails.currentAccount, token.address);\n                            const borrowPrincipal = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(userReserve.borrow.principal, 18);\n                            const borrowIndex = userReserve.borrow.index.toString();\n                            if (parseFloat(borrowPrincipal) > 0) {\n                                const price = await getPriceUSD(token.address);\n                                const balanceUSD = parseFloat(borrowPrincipal) * parseFloat(price);\n                                return {\n                                    address: token.address,\n                                    symbol: token.symbol,\n                                    name: token.name,\n                                    decimals: token.decimals,\n                                    borrowPrincipal: borrowPrincipal,\n                                    borrowIndex: borrowIndex,\n                                    balanceUSD: balanceUSD,\n                                    priceUSD: price\n                                };\n                            }\n                            return null;\n                        } catch (error) {\n                            console.warn(\"Error getting borrow for \".concat(token.symbol, \":\"), error);\n                            return null;\n                        }\n                    }\n                }[\"LendState.useCallback[getYourBorrows]\"]));\n                const validBorrows = borrows.filter({\n                    \"LendState.useCallback[getYourBorrows].validBorrows\": (b)=>b !== null\n                }[\"LendState.useCallback[getYourBorrows].validBorrows\"]);\n                setYourBorrows(validBorrows);\n                // Calculate summary\n                const totalUSDBalance = validBorrows.reduce({\n                    \"LendState.useCallback[getYourBorrows].totalUSDBalance\": (sum, asset)=>sum + asset.balanceUSD\n                }[\"LendState.useCallback[getYourBorrows].totalUSDBalance\"], 0);\n                const weightedAvgAPY = validBorrows.length > 0 ? validBorrows.reduce({\n                    \"LendState.useCallback[getYourBorrows]\": (sum, asset)=>sum + (asset.apy || 0)\n                }[\"LendState.useCallback[getYourBorrows]\"], 0) / validBorrows.length : 0;\n                const totalBorrowPowerUsed = totalUSDBalance;\n                setBorrowSummary({\n                    totalUSDBalance,\n                    weightedAvgAPY,\n                    totalBorrowPowerUsed\n                });\n                console.log(\"Got your borrows:\", validBorrows);\n                return validBorrows;\n            } catch (error) {\n                reportError(error);\n                return [];\n            }\n        }\n    }[\"LendState.useCallback[getYourBorrows]\"], [\n        metamaskDetails.provider,\n        metamaskDetails.currentAccount,\n        getPriceUSD\n    ]);\n    // Get assets to borrow\n    const getAssetsToBorrow = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getAssetsToBorrow]\": async ()=>{\n            console.log(\"5. Getting assets to borrow...\");\n            try {\n                if (!metamaskDetails.provider) return [];\n                const abi = [\n                    'function reserves(address) view returns (uint128 reserveCash, uint128 totalDebtPrincipal, uint128 liquidityIndex, uint128 variableBorrowIndex, uint64 liquidityRateRayPerSec, uint64 variableBorrowRateRayPerSec, uint16 reserveFactorBps, uint16 ltvBps, uint16 liqThresholdBps, uint16 liqBonusBps, uint16 closeFactorBps, uint8 decimals, bool isBorrowable, uint16 optimalUBps, uint64 baseRateRayPerSec, uint64 slope1RayPerSec, uint64 slope2RayPerSec, uint40 lastUpdate)'\n                ];\n                const pool = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.LENDING_POOL, abi, metamaskDetails.provider);\n                const assets = await Promise.all(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.filter({\n                    \"LendState.useCallback[getAssetsToBorrow]\": (t)=>!t.isNative\n                }[\"LendState.useCallback[getAssetsToBorrow]\"]).map({\n                    \"LendState.useCallback[getAssetsToBorrow]\": async (token)=>{\n                        try {\n                            const reserve = await pool.reserves(token.address);\n                            const isBorrowable = Boolean(reserve.isBorrowable);\n                            const reserveCash = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(reserve.reserveCash, 18);\n                            const price = await getPriceUSD(token.address);\n                            if (isBorrowable && parseFloat(reserveCash) > 0) {\n                                return {\n                                    address: token.address,\n                                    symbol: token.symbol,\n                                    name: token.name,\n                                    decimals: token.decimals,\n                                    reserveCash: reserveCash,\n                                    isBorrowable: isBorrowable,\n                                    priceUSD: price,\n                                    ltvBps: Number(reserve.ltvBps),\n                                    liqThresholdBps: Number(reserve.liqThresholdBps)\n                                };\n                            }\n                            return null;\n                        } catch (error) {\n                            console.warn(\"Error getting borrow asset \".concat(token.symbol, \":\"), error);\n                            return null;\n                        }\n                    }\n                }[\"LendState.useCallback[getAssetsToBorrow]\"]));\n                const validAssets = assets.filter({\n                    \"LendState.useCallback[getAssetsToBorrow].validAssets\": (a)=>a !== null\n                }[\"LendState.useCallback[getAssetsToBorrow].validAssets\"]);\n                setAssetsToBorrow(validAssets);\n                console.log(\"Got assets to borrow:\", validAssets);\n                return validAssets;\n            } catch (error) {\n                reportError(error);\n                return [];\n            }\n        }\n    }[\"LendState.useCallback[getAssetsToBorrow]\"], [\n        metamaskDetails.provider,\n        getPriceUSD\n    ]);\n    // Wrap ETH to WETH\n    const wrapEth = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[wrapEth]\": async (amountEth)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const data = '0xd0e30db0'; // deposit()\n                const tx = await metamaskDetails.signer.sendTransaction({\n                    to: _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.WETH,\n                    value: ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseEther(amountEth),\n                    data\n                });\n                await tx.wait();\n                console.log(\"ETH wrapped to WETH:\", amountEth);\n                return {\n                    status: 200,\n                    message: \"Transaction Successful...\",\n                    hash: tx.hash\n                };\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[wrapEth]\"], [\n        metamaskDetails.signer\n    ]);\n    // Unwrap WETH to ETH\n    const unwrapWeth = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[unwrapWeth]\": async (amountEth)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const abi = [\n                    'function withdraw(uint256 wad)'\n                ];\n                const weth = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.WETH, abi, metamaskDetails.signer);\n                const tx = await weth.withdraw(ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseEther(amountEth));\n                await tx.wait();\n                console.log(\"WETH unwrapped to ETH:\", amountEth);\n                return {\n                    status: 200,\n                    message: \"Transaction Successful...\",\n                    hash: tx.hash\n                };\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[unwrapWeth]\"], [\n        metamaskDetails.signer\n    ]);\n    // Refresh all data\n    const refresh = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[refresh]\": async ()=>{\n            try {\n                await Promise.all([\n                    getUserAssets(),\n                    getYourSupplies(),\n                    getYourBorrows(),\n                    getAssetsToBorrow(),\n                    getAccountData()\n                ]);\n                console.log(\"All data refreshed\");\n            } catch (error) {\n                reportError(error);\n            }\n        }\n    }[\"LendState.useCallback[refresh]\"], [\n        getUserAssets,\n        getYourSupplies,\n        getYourBorrows,\n        getAssetsToBorrow,\n        getAccountData\n    ]);\n    // Update interests (accrue)\n    const updateInterests = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[updateInterests]\": async (asset)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const abi = [\n                    'function accruePublic(address asset)'\n                ];\n                const pool = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.LENDING_POOL, abi, metamaskDetails.signer);\n                const tx = await pool.accruePublic(asset);\n                await tx.wait();\n                console.log(\"Interests updated for asset:\", asset);\n                return {\n                    status: 200,\n                    message: \"Transaction Successful...\"\n                };\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[updateInterests]\"], [\n        metamaskDetails.signer\n    ]);\n    // Get user total available balance\n    const getUserTotalAvailableBalance = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getUserTotalAvailableBalance]\": async ()=>{\n            try {\n                if (!metamaskDetails.provider || !metamaskDetails.currentAccount) return 0;\n                const abi = [\n                    'function getUserTotalAvailableBalanceInUSD(address user, uint256 assetType) view returns (uint256)'\n                ];\n                const pool = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.LENDING_POOL, abi, metamaskDetails.provider);\n                const maxAmount = await pool.getUserTotalAvailableBalanceInUSD(metamaskDetails.currentAccount, 1);\n                return Number(ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(maxAmount, 18));\n            } catch (error) {\n                reportError(error);\n                return 0;\n            }\n        }\n    }[\"LendState.useCallback[getUserTotalAvailableBalance]\"], [\n        metamaskDetails.provider,\n        metamaskDetails.currentAccount\n    ]);\n    // Get tokens per USD amount\n    const getTokensPerUSDAmount = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getTokensPerUSDAmount]\": async (token, amount)=>{\n            try {\n                if (!metamaskDetails.provider) return 0;\n                const abi = [\n                    'function getTokensPerUSDAmount(address token, uint256 amount) view returns (uint256)'\n                ];\n                const helper = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.PRICE_ORACLE, abi, metamaskDetails.provider);\n                const maxQty = await helper.getTokensPerUSDAmount(token, ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(amount.toString(), 18));\n                return Number(ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(maxQty, 18));\n            } catch (error) {\n                reportError(error);\n                return 0;\n            }\n        }\n    }[\"LendState.useCallback[getTokensPerUSDAmount]\"], [\n        metamaskDetails.provider\n    ]);\n    // Objectify supplied assets (format data)\n    const objectifySuppliedAssets = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[objectifySuppliedAssets]\": async (assets)=>{\n            const assetsList = [];\n            for(let i = 0; i < assets.length; i++){\n                const token = assets[i].token;\n                let lendQty = assets[i].lentQty;\n                const amountInUSD = await getAmountInUSD(token, lendQty);\n                lendQty = Number(assets[i].lentQty) / 1e18;\n                const maxSupplyAmount = await getUserTotalAvailableBalance();\n                const maxQty = await getTokensPerUSDAmount(token, maxSupplyAmount);\n                const qty = lendQty <= maxQty ? lendQty : maxQty;\n                assetsList.push({\n                    token: assets[i].token,\n                    balance: lendQty,\n                    apy: Number(assets[i].lentApy),\n                    balanceInUSD: amountInUSD,\n                    maxSupply: qty\n                });\n            }\n            return assetsList;\n        }\n    }[\"LendState.useCallback[objectifySuppliedAssets]\"], [\n        getAmountInUSD,\n        getUserTotalAvailableBalance,\n        getTokensPerUSDAmount\n    ]);\n    // Objectify borrowed assets (format data)\n    const objectifyBorrowedAssets = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[objectifyBorrowedAssets]\": async (assets)=>{\n            const borrowsList = [];\n            for(let i = 0; i < assets.length; i++){\n                const token = assets[i].token;\n                const borrowQty = assets[i].borrowQty;\n                const borrowApy = assets[i].borrowApy;\n                const amountInUSD = await getAmountInUSD(token, borrowQty);\n                borrowsList.push({\n                    token: token,\n                    borrowQty: Number(borrowQty),\n                    borrowApy: Number(borrowApy),\n                    borrowedBalInUSD: amountInUSD\n                });\n            }\n            return borrowsList;\n        }\n    }[\"LendState.useCallback[objectifyBorrowedAssets]\"], [\n        getAmountInUSD\n    ]);\n    // Merge objectified assets with token info\n    const mergeObjectifiedAssets = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[mergeObjectifiedAssets]\": (assets)=>{\n            const result = _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.filter({\n                \"LendState.useCallback[mergeObjectifiedAssets].result\": (tokenList)=>{\n                    return assets.some({\n                        \"LendState.useCallback[mergeObjectifiedAssets].result\": (assetList)=>{\n                            return tokenList.address.toLowerCase() === assetList.token.toLowerCase();\n                        }\n                    }[\"LendState.useCallback[mergeObjectifiedAssets].result\"]);\n                }\n            }[\"LendState.useCallback[mergeObjectifiedAssets].result\"]).map({\n                \"LendState.useCallback[mergeObjectifiedAssets].result\": (assetObj)=>({\n                        ...assets.find({\n                            \"LendState.useCallback[mergeObjectifiedAssets].result\": (item)=>item.token.toLowerCase() === assetObj.address.toLowerCase()\n                        }[\"LendState.useCallback[mergeObjectifiedAssets].result\"]),\n                        ...assetObj\n                    })\n            }[\"LendState.useCallback[mergeObjectifiedAssets].result\"]);\n            return result;\n        }\n    }[\"LendState.useCallback[mergeObjectifiedAssets]\"], []);\n    // Context value\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"LendState.useMemo[contextValue]\": ()=>({\n                // State\n                metamaskDetails,\n                userAssets,\n                supplyAssets,\n                assetsToBorrow,\n                yourBorrows,\n                supplySummary,\n                borrowSummary,\n                accountData,\n                contract,\n                // Wallet functions\n                connectWallet,\n                refresh,\n                // Asset functions\n                getUserAssets,\n                getYourSupplies,\n                getYourBorrows,\n                getAssetsToBorrow,\n                // Transaction functions\n                ApproveToContinue,\n                LendAsset,\n                WithdrawAsset,\n                borrowAsset,\n                repayAsset,\n                // Utility functions\n                getContract,\n                getPriceUSD,\n                getAmountInUSD,\n                numberToEthers,\n                reportError,\n                // ETH/WETH functions\n                wrapEth,\n                unwrapWeth,\n                // Account functions\n                getAccountData,\n                getUserTotalAvailableBalance,\n                getTokensPerUSDAmount,\n                // Data processing functions\n                objectifySuppliedAssets,\n                objectifyBorrowedAssets,\n                mergeObjectifiedAssets,\n                // Interest functions\n                updateInterests\n            })\n    }[\"LendState.useMemo[contextValue]\"], [\n        metamaskDetails,\n        userAssets,\n        supplyAssets,\n        assetsToBorrow,\n        yourBorrows,\n        supplySummary,\n        borrowSummary,\n        accountData,\n        contract,\n        connectWallet,\n        refresh,\n        getUserAssets,\n        getYourSupplies,\n        getYourBorrows,\n        getAssetsToBorrow,\n        ApproveToContinue,\n        LendAsset,\n        WithdrawAsset,\n        borrowAsset,\n        repayAsset,\n        getContract,\n        getPriceUSD,\n        getAmountInUSD,\n        wrapEth,\n        unwrapWeth,\n        getAccountData,\n        getUserTotalAvailableBalance,\n        getTokensPerUSDAmount,\n        objectifySuppliedAssets,\n        objectifyBorrowedAssets,\n        mergeObjectifiedAssets,\n        updateInterests\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lendContext__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Provider, {\n        value: contextValue,\n        children: props.children\n    }, void 0, false, {\n        fileName: \"D:\\\\Do_an2\\\\lendhub_v2\\\\lendhub-frontend-nextjs\\\\src\\\\context\\\\LendState.js\",\n        lineNumber: 834,\n        columnNumber: 5\n    }, undefined);\n};\n_s(LendState, \"TN1jeLZaelv9xP2tSeiJRiYdXAs=\");\n_c = LendState;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LendState);\nvar _c;\n$RefreshReg$(_c, \"LendState\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9jb250ZXh0L0xlbmRTdGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUE4RDtBQUN0QjtBQUNSO0FBQ2E7QUFDaUg7QUFDMUU7QUFDZjtBQUVyRSxvQkFBb0I7QUFDcEIsTUFBTXdCLGlCQUFpQixDQUFDQztJQUN0QixPQUFPcEIsMENBQU1BLENBQUNxQixVQUFVLENBQUNELE9BQU9FLFFBQVE7QUFDMUM7QUFFQSxNQUFNQyxjQUFjLENBQUNDO0lBQ25CQyxRQUFRRCxLQUFLLENBQUMsb0JBQW9CRSxLQUFLQyxTQUFTLENBQUNIO0lBQ2pEQyxRQUFRRCxLQUFLLENBQUMsa0JBQWtCQTtBQUNsQztBQUVBLE1BQU1JLFlBQVksQ0FBQ0M7O0lBQ2pCLDRCQUE0QjtJQUU1Qix1QkFBdUI7SUFDdkIsTUFBTSxDQUFDQyxpQkFBaUJDLG1CQUFtQixHQUFHbkMsK0NBQVFBLENBQUM7UUFDckRvQyxVQUFVO1FBQ1ZDLGFBQWE7UUFDYkMsUUFBUTtRQUNSQyxnQkFBZ0I7UUFDaEJDLFNBQVM7SUFDWDtJQUVBLDJCQUEyQjtJQUMzQixNQUFNLENBQUNDLFlBQVlDLGNBQWMsR0FBRzFDLCtDQUFRQSxDQUFDLEVBQUU7SUFDL0MsTUFBTSxDQUFDMkMsY0FBY0MsZ0JBQWdCLEdBQUc1QywrQ0FBUUEsQ0FBQyxFQUFFO0lBQ25ELE1BQU0sQ0FBQzZDLGdCQUFnQkMsa0JBQWtCLEdBQUc5QywrQ0FBUUEsQ0FBQyxFQUFFO0lBQ3ZELE1BQU0sQ0FBQytDLGFBQWFDLGVBQWUsR0FBR2hELCtDQUFRQSxDQUFDLEVBQUU7SUFFakQsbUJBQW1CO0lBQ25CLE1BQU0sQ0FBQ2lELFVBQVVDLFlBQVksR0FBR2xELCtDQUFRQSxDQUFDO1FBQ3ZDbUQscUJBQXFCO1FBQ3JCQyxnQkFBZ0I7SUFDbEI7SUFFQSxlQUFlO0lBQ2YsTUFBTSxDQUFDQyxlQUFlQyxpQkFBaUIsR0FBR3RELCtDQUFRQSxDQUFDO1FBQ2pEdUQsaUJBQWlCO1FBQ2pCQyxnQkFBZ0I7UUFDaEJDLG9CQUFvQjtJQUN0QjtJQUVBLE1BQU0sQ0FBQ0MsZUFBZUMsaUJBQWlCLEdBQUczRCwrQ0FBUUEsQ0FBQztRQUNqRHVELGlCQUFpQjtRQUNqQkMsZ0JBQWdCO1FBQ2hCSSxzQkFBc0I7SUFDeEI7SUFFQSxlQUFlO0lBQ2YsTUFBTSxDQUFDQyxhQUFhQyxlQUFlLEdBQUc5RCwrQ0FBUUEsQ0FBQztRQUM3QytELGVBQWU7UUFDZkMsU0FBUztRQUNUQyxjQUFjO0lBQ2hCO0lBRUEsaUJBQWlCO0lBQ2pCLGtEQUFrRDtJQUNsRCwrQ0FBK0M7SUFDL0MsaUNBQWlDO0lBQ2pDLDJFQUEyRTtJQUUzRSxVQUFVO0lBQ1YsdUJBQXVCO0lBQ3ZCLDRCQUE0QjtJQUM1QixnQkFBZ0I7SUFDaEIsUUFBUTtJQUVSLGdEQUFnRDtJQUNoRCx1Q0FBdUM7SUFDdkMsVUFBVTtJQUVWLDhDQUE4QztJQUM5QywwQ0FBMEM7SUFDMUMsa0NBQWtDO0lBQ2xDLFVBQVU7SUFDViw2Q0FBNkM7SUFDN0Msa0NBQWtDO0lBQ2xDLFVBQVU7SUFFViw2REFBNkQ7SUFDN0QsbURBQW1EO0lBQ25ELHdDQUF3QztJQUN4QyxpREFBaUQ7SUFFakQsNkJBQTZCO0lBQzdCLDBDQUEwQztJQUMxQyw2QkFBNkI7SUFDN0IsOEJBQThCO0lBQzlCLG9DQUFvQztJQUNwQywwQkFBMEI7SUFDMUIsMENBQTBDO0lBQzFDLDRDQUE0QztJQUM1QyxZQUFZO0lBQ1osNkRBQTZEO0lBQzdELGVBQWU7SUFDZiw0QkFBNEI7SUFDNUIsZ0JBQWdCO0lBQ2hCLFFBQVE7SUFDUixzQkFBc0I7SUFDdEIsMEJBQTBCO0lBQzFCLE1BQU07SUFDTixVQUFVO0lBRVYsTUFBTUMsZ0JBQWdCakUsa0RBQVdBO2dEQUFDO1lBQ2hDNEIsUUFBUXNDLEdBQUcsQ0FBQztZQUNaLE1BQU0sRUFBRUMsUUFBUSxFQUFFLEdBQUdDO1lBQ3JCLE1BQU1DLGNBQWM7WUFDcEIsSUFBSTtnQkFDRixJQUFJLENBQUNGLFVBQVU7b0JBQ2JHLE1BQU1EO29CQUNOO2dCQUNGO2dCQUVBLE1BQU1FLFdBQVcsTUFBTUosU0FBU0ssT0FBTyxDQUFDO29CQUFFQyxRQUFRO2dCQUFzQjtnQkFFeEUsdUNBQXVDO2dCQUN2Q04sU0FBU08sRUFBRSxDQUFDOzREQUFnQjt3QkFDMUJOLE9BQU9PLFFBQVEsQ0FBQ0MsTUFBTTtvQkFDeEI7O2dCQUNBVCxTQUFTTyxFQUFFLENBQUM7NERBQW1CO3dCQUM3Qk4sT0FBT08sUUFBUSxDQUFDQyxNQUFNO29CQUN4Qjs7Z0JBRUEsTUFBTXpDLFdBQVcsSUFBSWhDLDBDQUFNQSxDQUFDMEUsZUFBZSxDQUFDVjtnQkFDNUMsTUFBTVcsVUFBVSxNQUFNM0MsU0FBUzRDLFVBQVU7Z0JBQ3pDLE1BQU0zQyxjQUFjMEMsUUFBUUUsSUFBSTtnQkFDaEMsTUFBTTNDLFNBQVMsTUFBTUYsU0FBUzhDLFNBQVM7Z0JBRXZDLElBQUlWLFNBQVNXLE1BQU0sRUFBRTtvQkFDbkIsSUFBSUMsaUJBQWlCWixRQUFRLENBQUMsRUFBRTtvQkFDaENyQyxtQkFBbUI7d0JBQ2pCQyxVQUFVQTt3QkFDVkMsYUFBYUE7d0JBQ2JDLFFBQVFBO3dCQUNSQyxnQkFBZ0I2Qzt3QkFDaEI1QyxTQUFTNkMsT0FBT04sUUFBUXZDLE9BQU87b0JBQ2pDO29CQUNBWCxRQUFRc0MsR0FBRyxDQUFDLDBEQUEwRGlCO2dCQUN4RSxPQUFPO29CQUNMYixNQUFNRDtvQkFDTjtnQkFDRjtZQUNGLEVBQUUsT0FBTzFDLE9BQU87Z0JBQ2RELFlBQVlDO1lBQ2Q7UUFDRjsrQ0FBRyxFQUFFO0lBRUwsd0JBQXdCO0lBQ3hCLE1BQU0wRCxjQUFjckYsa0RBQVdBOzhDQUFDLE9BQU9zRixTQUFTQztZQUM5QyxJQUFJLENBQUN0RCxnQkFBZ0JFLFFBQVEsRUFBRSxPQUFPO1lBQ3RDLE1BQU1hLFdBQVcsSUFBSTdDLDBDQUFNQSxDQUFDcUYsUUFBUSxDQUFDRixTQUFTQyxLQUFLdEQsZ0JBQWdCRSxRQUFRO1lBQzNFLE9BQU9hO1FBQ1Q7NkNBQUc7UUFBQ2YsZ0JBQWdCRSxRQUFRO0tBQUM7SUFFN0IsNkJBQTZCO0lBQzdCLE1BQU1zRCxnQkFBZ0J6RixrREFBV0E7Z0RBQUM7WUFDaEM0QixRQUFRc0MsR0FBRyxDQUFDO1lBQ1osSUFBSTtnQkFDRixJQUFJLENBQUNqQyxnQkFBZ0JFLFFBQVEsSUFBSSxDQUFDRixnQkFBZ0JLLGNBQWMsRUFBRSxPQUFPLEVBQUU7Z0JBRTNFLE1BQU1vRCxTQUFTLE1BQU1DLFFBQVFDLEdBQUcsQ0FDOUJ4RixxREFBTUEsQ0FBQ3lGLE1BQU0sQ0FBQ0MsR0FBRzs0REFBQyxPQUFPQzt3QkFDdkIsSUFBSUMsVUFBVTt3QkFDZCxJQUFJQyxhQUFhO3dCQUVqQixJQUFJOzRCQUNGLElBQUlGLE1BQU1HLFFBQVEsRUFBRTtnQ0FDbEIscUJBQXFCO2dDQUNyQixNQUFNQyxNQUFNLE1BQU1sRSxnQkFBZ0JFLFFBQVEsQ0FBQ2lFLFVBQVUsQ0FBQ25FLGdCQUFnQkssY0FBYztnQ0FDcEYwRCxVQUFVN0YsMENBQU1BLENBQUNrRyxXQUFXLENBQUNGOzRCQUMvQixPQUFPO2dDQUNMLHNCQUFzQjtnQ0FDdEJILFVBQVUsTUFBTTNGLHdEQUFlQSxDQUM3QjRCLGdCQUFnQkUsUUFBUSxFQUN4QjRELE1BQU1ULE9BQU8sRUFDYnJELGdCQUFnQkssY0FBYyxFQUM5QnlELE1BQU1PLFFBQVE7NEJBRWxCOzRCQUVBLGdCQUFnQjs0QkFDaEIsTUFBTUMsUUFBUSxNQUFNQyxZQUFZVCxNQUFNVCxPQUFPOzRCQUM3Q1csYUFBYVEsV0FBV1QsV0FBV1MsV0FBV0Y7NEJBRTlDLE9BQU87Z0NBQ0xqQixTQUFTUyxNQUFNVCxPQUFPO2dDQUN0Qm9CLFFBQVFYLE1BQU1XLE1BQU07Z0NBQ3BCMUIsTUFBTWUsTUFBTWYsSUFBSTtnQ0FDaEJzQixVQUFVUCxNQUFNTyxRQUFRO2dDQUN4QkosVUFBVUgsTUFBTUcsUUFBUTtnQ0FDeEJGLFNBQVNBO2dDQUNUQyxZQUFZQTtnQ0FDWlUsVUFBVUo7NEJBQ1o7d0JBQ0YsRUFBRSxPQUFPNUUsT0FBTzs0QkFDZEMsUUFBUWdGLElBQUksQ0FBQyw2QkFBMEMsT0FBYmIsTUFBTVcsTUFBTSxFQUFDLE1BQUkvRTs0QkFDM0QsT0FBTztnQ0FDTDJELFNBQVNTLE1BQU1ULE9BQU87Z0NBQ3RCb0IsUUFBUVgsTUFBTVcsTUFBTTtnQ0FDcEIxQixNQUFNZSxNQUFNZixJQUFJO2dDQUNoQnNCLFVBQVVQLE1BQU1PLFFBQVE7Z0NBQ3hCSixVQUFVSCxNQUFNRyxRQUFRO2dDQUN4QkYsU0FBUztnQ0FDVEMsWUFBWTtnQ0FDWlUsVUFBVTs0QkFDWjt3QkFDRjtvQkFDRjs7Z0JBR0ZsRSxjQUFjaUQ7Z0JBQ2Q5RCxRQUFRc0MsR0FBRyxDQUFDLG9CQUFvQndCO2dCQUNoQyxPQUFPQTtZQUNULEVBQUUsT0FBTy9ELE9BQU87Z0JBQ2RELFlBQVlDO2dCQUNaLE9BQU8sRUFBRTtZQUNYO1FBQ0Y7K0NBQUc7UUFBQ00sZ0JBQWdCRSxRQUFRO1FBQUVGLGdCQUFnQkssY0FBYztLQUFDO0lBRTdELG1CQUFtQjtJQUNuQixNQUFNa0UsY0FBY3hHLGtEQUFXQTs4Q0FBQyxPQUFPNkc7WUFDckMsSUFBSSxDQUFDNUUsZ0JBQWdCRSxRQUFRLEVBQUUsT0FBTztZQUN0QyxJQUFJO2dCQUNGLE1BQU1vRCxNQUFNO29CQUFDO2lCQUFtRTtnQkFDaEYsTUFBTXVCLFNBQVMsSUFBSTNHLDBDQUFNQSxDQUFDcUYsUUFBUSxDQUFDcEYscURBQU1BLENBQUMyRyxZQUFZLEVBQUV4QixLQUFLdEQsZ0JBQWdCRSxRQUFRO2dCQUNyRixNQUFNb0UsUUFBUSxNQUFNTyxPQUFPRSxpQkFBaUIsQ0FBQ0g7Z0JBQzdDLE9BQU8xRywwQ0FBTUEsQ0FBQzhHLFdBQVcsQ0FBQ1YsT0FBTztZQUNuQyxFQUFFLE9BQU81RSxPQUFPO2dCQUNkQyxRQUFRZ0YsSUFBSSxDQUFDLDJCQUFpQyxPQUFOQyxPQUFNLE1BQUlsRjtnQkFDbEQsT0FBTztZQUNUO1FBQ0Y7NkNBQUc7UUFBQ00sZ0JBQWdCRSxRQUFRO0tBQUM7SUFFN0Isb0JBQW9CO0lBQ3BCLE1BQU0rRSxpQkFBaUJsSCxrREFBV0E7aURBQUMsT0FBT3NGLFNBQVM2QjtZQUNqRCxJQUFJO2dCQUNGLE1BQU1aLFFBQVEsTUFBTUMsWUFBWWxCO2dCQUNoQyxNQUFNOEIsY0FBY1gsV0FBV1UsVUFBVVYsV0FBV0Y7Z0JBQ3BELE9BQU9hO1lBQ1QsRUFBRSxPQUFPekYsT0FBTztnQkFDZEQsWUFBWUM7Z0JBQ1osT0FBTztZQUNUO1FBQ0Y7Z0RBQUc7UUFBQzZFO0tBQVk7SUFFaEIsaUJBQWlCO0lBQ2pCLE1BQU1hLG9CQUFvQnJILGtEQUFXQTtvREFBQyxPQUFPc0gsY0FBY0M7WUFDekQsSUFBSSxDQUFDdEYsZ0JBQWdCSSxNQUFNLEVBQUU7Z0JBQzNCLE1BQU0sSUFBSW1GLE1BQU07WUFDbEI7WUFFQSxJQUFJO2dCQUNGLE1BQU16QixRQUFRM0YscURBQU1BLENBQUN5RixNQUFNLENBQUM0QixJQUFJO3NFQUFDQyxDQUFBQSxJQUFLQSxFQUFFcEMsT0FBTyxDQUFDcUMsV0FBVyxPQUFPTCxhQUFhSyxXQUFXOztnQkFDMUYsSUFBSSxDQUFDNUIsT0FBTyxNQUFNLElBQUl5QixNQUFNO2dCQUU1QixNQUFNakgsd0RBQWVBLENBQ25CMEIsZ0JBQWdCSSxNQUFNLEVBQ3RCaUYsY0FDQWxILHFEQUFNQSxDQUFDd0gsWUFBWSxFQUNuQkwsZUFDQXhCLE1BQU1PLFFBQVE7Z0JBR2hCMUUsUUFBUXNDLEdBQUcsQ0FBQyxtQkFBbUJvRDtnQkFDL0IsT0FBTztvQkFBRU8sUUFBUTtvQkFBS0MsU0FBUztnQkFBNEI7WUFDN0QsRUFBRSxPQUFPbkcsT0FBTztnQkFDZEQsWUFBWUM7Z0JBQ1osT0FBTztvQkFBRWtHLFFBQVE7b0JBQUtDLFNBQVNuRyxNQUFNbUcsT0FBTyxJQUFJbkcsTUFBTW9HLE1BQU07Z0JBQUM7WUFDL0Q7UUFDRjttREFBRztRQUFDOUYsZ0JBQWdCSSxNQUFNO0tBQUM7SUFFM0IsYUFBYTtJQUNiLE1BQU0yRixZQUFZaEksa0RBQVdBOzRDQUFDLE9BQU8rRixPQUFPa0M7WUFDMUMsSUFBSSxDQUFDaEcsZ0JBQWdCSSxNQUFNLEVBQUU7Z0JBQzNCLE1BQU0sSUFBSW1GLE1BQU07WUFDbEI7WUFFQSxJQUFJO2dCQUNGLE1BQU1VLFlBQVk5SCxxREFBTUEsQ0FBQ3lGLE1BQU0sQ0FBQzRCLElBQUk7a0VBQUNDLENBQUFBLElBQUtBLEVBQUVwQyxPQUFPLENBQUNxQyxXQUFXLE9BQU81QixNQUFNNEIsV0FBVzs7Z0JBQ3ZGLElBQUksQ0FBQ08sV0FBVyxNQUFNLElBQUlWLE1BQU07Z0JBRWhDLE1BQU1MLFNBQVNoSCwwQ0FBTUEsQ0FBQ2dJLFVBQVUsQ0FBQ0YsY0FBY0MsVUFBVTVCLFFBQVE7Z0JBQ2pFLE1BQU04QixLQUFLLE1BQU0zSCw2Q0FBTUEsQ0FBQ3dCLGdCQUFnQkksTUFBTSxFQUFFMEQsT0FBT29CO2dCQUV2RCxJQUFJaUIsSUFBSTtvQkFDTnhHLFFBQVFzQyxHQUFHLENBQUMsNEJBQTRCNkIsT0FBT2tDO29CQUMvQyxPQUFPO3dCQUFFSixRQUFRO3dCQUFLQyxTQUFTO3dCQUE2Qk8sTUFBTUQsR0FBR0MsSUFBSTtvQkFBQztnQkFDNUU7Z0JBQ0EsTUFBTSxJQUFJYixNQUFNO1lBQ2xCLEVBQUUsT0FBTzdGLE9BQU87Z0JBQ2RELFlBQVlDO2dCQUNaLE9BQU87b0JBQUVrRyxRQUFRO29CQUFLQyxTQUFTbkcsTUFBTW1HLE9BQU8sSUFBSW5HLE1BQU1vRyxNQUFNO2dCQUFDO1lBQy9EO1FBQ0Y7MkNBQUc7UUFBQzlGLGdCQUFnQkksTUFBTTtLQUFDO0lBRTNCLGlCQUFpQjtJQUNqQixNQUFNaUcsZ0JBQWdCdEksa0RBQVdBO2dEQUFDLE9BQU9zSCxjQUFjaUI7WUFDckQsSUFBSSxDQUFDdEcsZ0JBQWdCSSxNQUFNLEVBQUU7Z0JBQzNCLE1BQU0sSUFBSW1GLE1BQU07WUFDbEI7WUFFQSxJQUFJO2dCQUNGLE1BQU1VLFlBQVk5SCxxREFBTUEsQ0FBQ3lGLE1BQU0sQ0FBQzRCLElBQUk7c0VBQUNDLENBQUFBLElBQUtBLEVBQUVwQyxPQUFPLENBQUNxQyxXQUFXLE9BQU9MLGFBQWFLLFdBQVc7O2dCQUM5RixJQUFJLENBQUNPLFdBQVcsTUFBTSxJQUFJVixNQUFNO2dCQUVoQyxNQUFNTCxTQUFTaEgsMENBQU1BLENBQUNnSSxVQUFVLENBQUNJLGdCQUFnQkwsVUFBVTVCLFFBQVE7Z0JBQ25FLE1BQU04QixLQUFLLE1BQU16SCxpREFBVUEsQ0FBQ3NCLGdCQUFnQkksTUFBTSxFQUFFaUYsY0FBY0g7Z0JBRWxFLElBQUlpQixJQUFJO29CQUNOeEcsUUFBUXNDLEdBQUcsQ0FBQyxpQ0FBaUNvRCxjQUFjaUI7b0JBQzNELE9BQU87d0JBQUVWLFFBQVE7d0JBQUtDLFNBQVM7d0JBQTZCTyxNQUFNRCxHQUFHQyxJQUFJO29CQUFDO2dCQUM1RTtnQkFDQSxNQUFNLElBQUliLE1BQU07WUFDbEIsRUFBRSxPQUFPN0YsT0FBTztnQkFDZEQsWUFBWUM7Z0JBQ1osT0FBTztvQkFBRWtHLFFBQVE7b0JBQUtDLFNBQVNuRyxNQUFNbUcsT0FBTyxJQUFJbkcsTUFBTW9HLE1BQU07Z0JBQUM7WUFDL0Q7UUFDRjsrQ0FBRztRQUFDOUYsZ0JBQWdCSSxNQUFNO0tBQUM7SUFFM0IsZUFBZTtJQUNmLE1BQU1tRyxjQUFjeEksa0RBQVdBOzhDQUFDLE9BQU8rRixPQUFPMEM7WUFDNUMsSUFBSSxDQUFDeEcsZ0JBQWdCSSxNQUFNLEVBQUU7Z0JBQzNCLE1BQU0sSUFBSW1GLE1BQU07WUFDbEI7WUFFQSxJQUFJO2dCQUNGLE1BQU1VLFlBQVk5SCxxREFBTUEsQ0FBQ3lGLE1BQU0sQ0FBQzRCLElBQUk7b0VBQUNDLENBQUFBLElBQUtBLEVBQUVwQyxPQUFPLENBQUNxQyxXQUFXLE9BQU81QixNQUFNNEIsV0FBVzs7Z0JBQ3ZGLElBQUksQ0FBQ08sV0FBVyxNQUFNLElBQUlWLE1BQU07Z0JBRWhDLE1BQU1MLFNBQVNoSCwwQ0FBTUEsQ0FBQ2dJLFVBQVUsQ0FBQ00sY0FBY1AsVUFBVTVCLFFBQVE7Z0JBQ2pFLE1BQU04QixLQUFLLE1BQU12SCwrQ0FBUUEsQ0FBQ29CLGdCQUFnQkksTUFBTSxFQUFFMEQsT0FBT29CO2dCQUV6RCxJQUFJaUIsSUFBSTtvQkFDTnhHLFFBQVFzQyxHQUFHLENBQUMsZ0NBQWdDNkIsT0FBTzBDO29CQUNuRCxPQUFPO3dCQUFFWixRQUFRO3dCQUFLQyxTQUFTO3dCQUE2Qk8sTUFBTUQsR0FBR0MsSUFBSTtvQkFBQztnQkFDNUU7Z0JBQ0EsTUFBTSxJQUFJYixNQUFNO1lBQ2xCLEVBQUUsT0FBTzdGLE9BQU87Z0JBQ2RELFlBQVlDO2dCQUNaLE9BQU87b0JBQUVrRyxRQUFRO29CQUFLQyxTQUFTbkcsTUFBTW1HLE9BQU8sSUFBSW5HLE1BQU1vRyxNQUFNO2dCQUFDO1lBQy9EO1FBQ0Y7NkNBQUc7UUFBQzlGLGdCQUFnQkksTUFBTTtLQUFDO0lBRTNCLGNBQWM7SUFDZCxNQUFNcUcsYUFBYTFJLGtEQUFXQTs2Q0FBQyxPQUFPc0gsY0FBY3FCO1lBQ2xELElBQUksQ0FBQzFHLGdCQUFnQkksTUFBTSxFQUFFO2dCQUMzQixNQUFNLElBQUltRixNQUFNO1lBQ2xCO1lBRUEsSUFBSTtnQkFDRixNQUFNVSxZQUFZOUgscURBQU1BLENBQUN5RixNQUFNLENBQUM0QixJQUFJO21FQUFDQyxDQUFBQSxJQUFLQSxFQUFFcEMsT0FBTyxDQUFDcUMsV0FBVyxPQUFPTCxhQUFhSyxXQUFXOztnQkFDOUYsSUFBSSxDQUFDTyxXQUFXLE1BQU0sSUFBSVYsTUFBTTtnQkFFaEMsTUFBTUwsU0FBU2hILDBDQUFNQSxDQUFDZ0ksVUFBVSxDQUFDUSxhQUFhVCxVQUFVNUIsUUFBUTtnQkFDaEUsTUFBTThCLEtBQUssTUFBTXJILDhDQUFPQSxDQUFDa0IsZ0JBQWdCSSxNQUFNLEVBQUVpRixjQUFjSDtnQkFFL0QsSUFBSWlCLElBQUk7b0JBQ054RyxRQUFRc0MsR0FBRyxDQUFDLDhCQUE4Qm9ELGNBQWNxQjtvQkFDeEQsT0FBTzt3QkFBRWQsUUFBUTt3QkFBS0MsU0FBUzt3QkFBNkJPLE1BQU1ELEdBQUdDLElBQUk7b0JBQUM7Z0JBQzVFO2dCQUNBLE1BQU0sSUFBSWIsTUFBTTtZQUNsQixFQUFFLE9BQU83RixPQUFPO2dCQUNkRCxZQUFZQztnQkFDWixPQUFPO29CQUFFa0csUUFBUTtvQkFBS0MsU0FBU25HLE1BQU1tRyxPQUFPLElBQUluRyxNQUFNb0csTUFBTTtnQkFBQztZQUMvRDtRQUNGOzRDQUFHO1FBQUM5RixnQkFBZ0JJLE1BQU07S0FBQztJQUUzQixxREFBcUQ7SUFDckQsTUFBTXVHLGlCQUFpQjVJLGtEQUFXQTtpREFBQyxPQUFPNkk7WUFDeEMsSUFBSTtnQkFDRixJQUFJLENBQUM1RyxnQkFBZ0JFLFFBQVEsRUFBRSxPQUFPO2dCQUV0QyxNQUFNMkcsT0FBTyxJQUFJM0ksMENBQU1BLENBQUNxRixRQUFRLENBQUN2RSwwREFBa0JBLEVBQUVHLGlEQUFjQSxDQUFDbUUsR0FBRyxFQUFFdEQsZ0JBQWdCRSxRQUFRO2dCQUNqRyxNQUFNNEcsU0FBU0YsUUFBUTVHLGdCQUFnQkssY0FBYyxJQUFJbkMsMENBQU1BLENBQUM2SSxXQUFXO2dCQUMzRSxNQUFNLENBQUNDLEtBQUtDLE1BQU1DLEdBQUcsR0FBRyxNQUFNTCxLQUFLRixjQUFjLENBQUNHO2dCQUVsRCxNQUFNbkYsY0FBYztvQkFDbEJFLGVBQWUzRCwwQ0FBTUEsQ0FBQzhHLFdBQVcsQ0FBQ2dDLEtBQUs7b0JBQ3ZDbEYsU0FBUzVELDBDQUFNQSxDQUFDOEcsV0FBVyxDQUFDaUMsTUFBTTtvQkFDbENsRixjQUFjN0QsMENBQU1BLENBQUM4RyxXQUFXLENBQUNrQyxJQUFJO2dCQUN2QztnQkFFQXRGLGVBQWVEO2dCQUNmLE9BQU9BO1lBQ1QsRUFBRSxPQUFPakMsT0FBTztnQkFDZEQsWUFBWUM7Z0JBQ1osT0FBTztZQUNUO1FBQ0Y7Z0RBQUc7UUFBQ00sZ0JBQWdCRSxRQUFRO1FBQUVGLGdCQUFnQkssY0FBYztLQUFDO0lBRTdELG9CQUFvQjtJQUNwQixNQUFNOEcsa0JBQWtCcEosa0RBQVdBO2tEQUFDO1lBQ2xDNEIsUUFBUXNDLEdBQUcsQ0FBQztZQUNaLElBQUk7Z0JBQ0YsSUFBSSxDQUFDakMsZ0JBQWdCRSxRQUFRLElBQUksQ0FBQ0YsZ0JBQWdCSyxjQUFjLEVBQUUsT0FBTyxFQUFFO2dCQUUzRSxNQUFNaUQsTUFBTTtvQkFDVjtpQkFDRDtnQkFDRCxNQUFNdUQsT0FBTyxJQUFJM0ksMENBQU1BLENBQUNxRixRQUFRLENBQUNwRixxREFBTUEsQ0FBQ3dILFlBQVksRUFBRXJDLEtBQUt0RCxnQkFBZ0JFLFFBQVE7Z0JBRW5GLE1BQU1rSCxXQUFXLE1BQU0xRCxRQUFRQyxHQUFHLENBQ2hDeEYscURBQU1BLENBQUN5RixNQUFNLENBQUN5RCxNQUFNOzhEQUFDNUIsQ0FBQUEsSUFBSyxDQUFDQSxFQUFFeEIsUUFBUTs2REFBRUosR0FBRzs4REFBQyxPQUFPQzt3QkFDaEQsSUFBSTs0QkFDRixNQUFNd0QsY0FBYyxNQUFNVCxLQUFLVSxjQUFjLENBQUN2SCxnQkFBZ0JLLGNBQWMsRUFBRXlELE1BQU1ULE9BQU87NEJBQzNGLE1BQU1tRSxrQkFBa0J0SiwwQ0FBTUEsQ0FBQzhHLFdBQVcsQ0FBQ3NDLFlBQVlHLE1BQU0sQ0FBQ0MsU0FBUyxFQUFFOzRCQUN6RSxNQUFNQyxjQUFjTCxZQUFZRyxNQUFNLENBQUNHLEtBQUssQ0FBQ3BJLFFBQVE7NEJBRXJELElBQUlnRixXQUFXZ0QsbUJBQW1CLEdBQUc7Z0NBQ25DLE1BQU1sRCxRQUFRLE1BQU1DLFlBQVlULE1BQU1ULE9BQU87Z0NBQzdDLE1BQU1XLGFBQWFRLFdBQVdnRCxtQkFBbUJoRCxXQUFXRjtnQ0FFNUQsT0FBTztvQ0FDTGpCLFNBQVNTLE1BQU1ULE9BQU87b0NBQ3RCb0IsUUFBUVgsTUFBTVcsTUFBTTtvQ0FDcEIxQixNQUFNZSxNQUFNZixJQUFJO29DQUNoQnNCLFVBQVVQLE1BQU1PLFFBQVE7b0NBQ3hCbUQsaUJBQWlCQTtvQ0FDakJHLGFBQWFBO29DQUNiM0QsWUFBWUE7b0NBQ1pVLFVBQVVKO2dDQUNaOzRCQUNGOzRCQUNBLE9BQU87d0JBQ1QsRUFBRSxPQUFPNUUsT0FBTzs0QkFDZEMsUUFBUWdGLElBQUksQ0FBQyw0QkFBeUMsT0FBYmIsTUFBTVcsTUFBTSxFQUFDLE1BQUkvRTs0QkFDMUQsT0FBTzt3QkFDVDtvQkFDRjs7Z0JBR0YsTUFBTW1JLGdCQUFnQlQsU0FBU0MsTUFBTTs0RUFBQ1MsQ0FBQUEsSUFBS0EsTUFBTTs7Z0JBQ2pEcEgsZ0JBQWdCbUg7Z0JBRWhCLG9CQUFvQjtnQkFDcEIsTUFBTXhHLGtCQUFrQndHLGNBQWNFLE1BQU07OEVBQUMsQ0FBQ0MsS0FBS3BELFFBQVVvRCxNQUFNcEQsTUFBTVosVUFBVTs2RUFBRTtnQkFDckYsTUFBTTFDLGlCQUFpQnVHLGNBQWM1RSxNQUFNLEdBQUcsSUFDNUM0RSxjQUFjRSxNQUFNOzhEQUFDLENBQUNDLEtBQUtwRCxRQUFVb0QsTUFBT3BELENBQUFBLE1BQU1xRCxHQUFHLElBQUk7NkRBQUksS0FBS0osY0FBYzVFLE1BQU0sR0FBRztnQkFDM0YsTUFBTTFCLHFCQUFxQnNHLGNBQWNFLE1BQU07aUZBQUMsQ0FBQ0MsS0FBS3BELFFBQVVvRCxNQUFNcEQsTUFBTVosVUFBVTtnRkFBRTtnQkFFeEY1QyxpQkFBaUI7b0JBQ2ZDO29CQUNBQztvQkFDQUM7Z0JBQ0Y7Z0JBRUE1QixRQUFRc0MsR0FBRyxDQUFDLHNCQUFzQjRGO2dCQUNsQyxPQUFPQTtZQUNULEVBQUUsT0FBT25JLE9BQU87Z0JBQ2RELFlBQVlDO2dCQUNaLE9BQU8sRUFBRTtZQUNYO1FBQ0Y7aURBQUc7UUFBQ00sZ0JBQWdCRSxRQUFRO1FBQUVGLGdCQUFnQkssY0FBYztRQUFFa0U7S0FBWTtJQUUxRSxtQkFBbUI7SUFDbkIsTUFBTTJELGlCQUFpQm5LLGtEQUFXQTtpREFBQztZQUNqQzRCLFFBQVFzQyxHQUFHLENBQUM7WUFDWixJQUFJO2dCQUNGLElBQUksQ0FBQ2pDLGdCQUFnQkUsUUFBUSxJQUFJLENBQUNGLGdCQUFnQkssY0FBYyxFQUFFLE9BQU8sRUFBRTtnQkFFM0UsTUFBTWlELE1BQU07b0JBQ1Y7aUJBQ0Q7Z0JBQ0QsTUFBTXVELE9BQU8sSUFBSTNJLDBDQUFNQSxDQUFDcUYsUUFBUSxDQUFDcEYscURBQU1BLENBQUN3SCxZQUFZLEVBQUVyQyxLQUFLdEQsZ0JBQWdCRSxRQUFRO2dCQUVuRixNQUFNaUksVUFBVSxNQUFNekUsUUFBUUMsR0FBRyxDQUMvQnhGLHFEQUFNQSxDQUFDeUYsTUFBTSxDQUFDeUQsTUFBTTs2REFBQzVCLENBQUFBLElBQUssQ0FBQ0EsRUFBRXhCLFFBQVE7NERBQUVKLEdBQUc7NkRBQUMsT0FBT0M7d0JBQ2hELElBQUk7NEJBQ0YsTUFBTXdELGNBQWMsTUFBTVQsS0FBS1UsY0FBYyxDQUFDdkgsZ0JBQWdCSyxjQUFjLEVBQUV5RCxNQUFNVCxPQUFPOzRCQUMzRixNQUFNK0Usa0JBQWtCbEssMENBQU1BLENBQUM4RyxXQUFXLENBQUNzQyxZQUFZM0ksTUFBTSxDQUFDK0ksU0FBUyxFQUFFOzRCQUN6RSxNQUFNVyxjQUFjZixZQUFZM0ksTUFBTSxDQUFDaUosS0FBSyxDQUFDcEksUUFBUTs0QkFFckQsSUFBSWdGLFdBQVc0RCxtQkFBbUIsR0FBRztnQ0FDbkMsTUFBTTlELFFBQVEsTUFBTUMsWUFBWVQsTUFBTVQsT0FBTztnQ0FDN0MsTUFBTVcsYUFBYVEsV0FBVzRELG1CQUFtQjVELFdBQVdGO2dDQUU1RCxPQUFPO29DQUNMakIsU0FBU1MsTUFBTVQsT0FBTztvQ0FDdEJvQixRQUFRWCxNQUFNVyxNQUFNO29DQUNwQjFCLE1BQU1lLE1BQU1mLElBQUk7b0NBQ2hCc0IsVUFBVVAsTUFBTU8sUUFBUTtvQ0FDeEIrRCxpQkFBaUJBO29DQUNqQkMsYUFBYUE7b0NBQ2JyRSxZQUFZQTtvQ0FDWlUsVUFBVUo7Z0NBQ1o7NEJBQ0Y7NEJBQ0EsT0FBTzt3QkFDVCxFQUFFLE9BQU81RSxPQUFPOzRCQUNkQyxRQUFRZ0YsSUFBSSxDQUFDLDRCQUF5QyxPQUFiYixNQUFNVyxNQUFNLEVBQUMsTUFBSS9FOzRCQUMxRCxPQUFPO3dCQUNUO29CQUNGOztnQkFHRixNQUFNNEksZUFBZUgsUUFBUWQsTUFBTTswRUFBQ2tCLENBQUFBLElBQUtBLE1BQU07O2dCQUMvQ3pILGVBQWV3SDtnQkFFZixvQkFBb0I7Z0JBQ3BCLE1BQU1qSCxrQkFBa0JpSCxhQUFhUCxNQUFNOzZFQUFDLENBQUNDLEtBQUtwRCxRQUFVb0QsTUFBTXBELE1BQU1aLFVBQVU7NEVBQUU7Z0JBQ3BGLE1BQU0xQyxpQkFBaUJnSCxhQUFhckYsTUFBTSxHQUFHLElBQzNDcUYsYUFBYVAsTUFBTTs2REFBQyxDQUFDQyxLQUFLcEQsUUFBVW9ELE1BQU9wRCxDQUFBQSxNQUFNcUQsR0FBRyxJQUFJOzREQUFJLEtBQUtLLGFBQWFyRixNQUFNLEdBQUc7Z0JBQ3pGLE1BQU12Qix1QkFBdUJMO2dCQUU3QkksaUJBQWlCO29CQUNmSjtvQkFDQUM7b0JBQ0FJO2dCQUNGO2dCQUVBL0IsUUFBUXNDLEdBQUcsQ0FBQyxxQkFBcUJxRztnQkFDakMsT0FBT0E7WUFDVCxFQUFFLE9BQU81SSxPQUFPO2dCQUNkRCxZQUFZQztnQkFDWixPQUFPLEVBQUU7WUFDWDtRQUNGO2dEQUFHO1FBQUNNLGdCQUFnQkUsUUFBUTtRQUFFRixnQkFBZ0JLLGNBQWM7UUFBRWtFO0tBQVk7SUFFMUUsdUJBQXVCO0lBQ3ZCLE1BQU1pRSxvQkFBb0J6SyxrREFBV0E7b0RBQUM7WUFDcEM0QixRQUFRc0MsR0FBRyxDQUFDO1lBQ1osSUFBSTtnQkFDRixJQUFJLENBQUNqQyxnQkFBZ0JFLFFBQVEsRUFBRSxPQUFPLEVBQUU7Z0JBRXhDLE1BQU1vRCxNQUFNO29CQUNWO2lCQUNEO2dCQUNELE1BQU11RCxPQUFPLElBQUkzSSwwQ0FBTUEsQ0FBQ3FGLFFBQVEsQ0FBQ3BGLHFEQUFNQSxDQUFDd0gsWUFBWSxFQUFFckMsS0FBS3RELGdCQUFnQkUsUUFBUTtnQkFFbkYsTUFBTXVELFNBQVMsTUFBTUMsUUFBUUMsR0FBRyxDQUM5QnhGLHFEQUFNQSxDQUFDeUYsTUFBTSxDQUFDeUQsTUFBTTtnRUFBQzVCLENBQUFBLElBQUssQ0FBQ0EsRUFBRXhCLFFBQVE7K0RBQUVKLEdBQUc7Z0VBQUMsT0FBT0M7d0JBQ2hELElBQUk7NEJBQ0YsTUFBTTJFLFVBQVUsTUFBTTVCLEtBQUs2QixRQUFRLENBQUM1RSxNQUFNVCxPQUFPOzRCQUNqRCxNQUFNc0YsZUFBZUMsUUFBUUgsUUFBUUUsWUFBWTs0QkFDakQsTUFBTUUsY0FBYzNLLDBDQUFNQSxDQUFDOEcsV0FBVyxDQUFDeUQsUUFBUUksV0FBVyxFQUFFOzRCQUM1RCxNQUFNdkUsUUFBUSxNQUFNQyxZQUFZVCxNQUFNVCxPQUFPOzRCQUU3QyxJQUFJc0YsZ0JBQWdCbkUsV0FBV3FFLGVBQWUsR0FBRztnQ0FDL0MsT0FBTztvQ0FDTHhGLFNBQVNTLE1BQU1ULE9BQU87b0NBQ3RCb0IsUUFBUVgsTUFBTVcsTUFBTTtvQ0FDcEIxQixNQUFNZSxNQUFNZixJQUFJO29DQUNoQnNCLFVBQVVQLE1BQU1PLFFBQVE7b0NBQ3hCd0UsYUFBYUE7b0NBQ2JGLGNBQWNBO29DQUNkakUsVUFBVUo7b0NBQ1Z3RSxRQUFRM0YsT0FBT3NGLFFBQVFLLE1BQU07b0NBQzdCQyxpQkFBaUI1RixPQUFPc0YsUUFBUU0sZUFBZTtnQ0FDakQ7NEJBQ0Y7NEJBQ0EsT0FBTzt3QkFDVCxFQUFFLE9BQU9ySixPQUFPOzRCQUNkQyxRQUFRZ0YsSUFBSSxDQUFDLDhCQUEyQyxPQUFiYixNQUFNVyxNQUFNLEVBQUMsTUFBSS9FOzRCQUM1RCxPQUFPO3dCQUNUO29CQUNGOztnQkFHRixNQUFNc0osY0FBY3ZGLE9BQU80RCxNQUFNOzRFQUFDNEIsQ0FBQUEsSUFBS0EsTUFBTTs7Z0JBQzdDckksa0JBQWtCb0k7Z0JBQ2xCckosUUFBUXNDLEdBQUcsQ0FBQyx5QkFBeUIrRztnQkFDckMsT0FBT0E7WUFDVCxFQUFFLE9BQU90SixPQUFPO2dCQUNkRCxZQUFZQztnQkFDWixPQUFPLEVBQUU7WUFDWDtRQUNGO21EQUFHO1FBQUNNLGdCQUFnQkUsUUFBUTtRQUFFcUU7S0FBWTtJQUUxQyxtQkFBbUI7SUFDbkIsTUFBTTJFLFVBQVVuTCxrREFBV0E7MENBQUMsT0FBT29MO1lBQ2pDLElBQUksQ0FBQ25KLGdCQUFnQkksTUFBTSxFQUFFO2dCQUMzQixNQUFNLElBQUltRixNQUFNO1lBQ2xCO1lBRUEsSUFBSTtnQkFDRixNQUFNNkQsT0FBTyxjQUFjLFlBQVk7Z0JBQ3ZDLE1BQU1qRCxLQUFLLE1BQU1uRyxnQkFBZ0JJLE1BQU0sQ0FBQ2lKLGVBQWUsQ0FBQztvQkFDdERDLElBQUluTCxxREFBTUEsQ0FBQ29MLElBQUk7b0JBQ2ZDLE9BQU90TCwwQ0FBTUEsQ0FBQ3FCLFVBQVUsQ0FBQzRKO29CQUN6QkM7Z0JBQ0Y7Z0JBQ0EsTUFBTWpELEdBQUdzRCxJQUFJO2dCQUNiOUosUUFBUXNDLEdBQUcsQ0FBQyx3QkFBd0JrSDtnQkFDcEMsT0FBTztvQkFBRXZELFFBQVE7b0JBQUtDLFNBQVM7b0JBQTZCTyxNQUFNRCxHQUFHQyxJQUFJO2dCQUFDO1lBQzVFLEVBQUUsT0FBTzFHLE9BQU87Z0JBQ2RELFlBQVlDO2dCQUNaLE9BQU87b0JBQUVrRyxRQUFRO29CQUFLQyxTQUFTbkcsTUFBTW1HLE9BQU8sSUFBSW5HLE1BQU1vRyxNQUFNO2dCQUFDO1lBQy9EO1FBQ0Y7eUNBQUc7UUFBQzlGLGdCQUFnQkksTUFBTTtLQUFDO0lBRTNCLHFCQUFxQjtJQUNyQixNQUFNc0osYUFBYTNMLGtEQUFXQTs2Q0FBQyxPQUFPb0w7WUFDcEMsSUFBSSxDQUFDbkosZ0JBQWdCSSxNQUFNLEVBQUU7Z0JBQzNCLE1BQU0sSUFBSW1GLE1BQU07WUFDbEI7WUFFQSxJQUFJO2dCQUNGLE1BQU1qQyxNQUFNO29CQUFDO2lCQUFpQztnQkFDOUMsTUFBTXFHLE9BQU8sSUFBSXpMLDBDQUFNQSxDQUFDcUYsUUFBUSxDQUFDcEYscURBQU1BLENBQUNvTCxJQUFJLEVBQUVqRyxLQUFLdEQsZ0JBQWdCSSxNQUFNO2dCQUN6RSxNQUFNK0YsS0FBSyxNQUFNd0QsS0FBS2xMLFFBQVEsQ0FBQ1AsMENBQU1BLENBQUNxQixVQUFVLENBQUM0SjtnQkFDakQsTUFBTWhELEdBQUdzRCxJQUFJO2dCQUNiOUosUUFBUXNDLEdBQUcsQ0FBQywwQkFBMEJrSDtnQkFDdEMsT0FBTztvQkFBRXZELFFBQVE7b0JBQUtDLFNBQVM7b0JBQTZCTyxNQUFNRCxHQUFHQyxJQUFJO2dCQUFDO1lBQzVFLEVBQUUsT0FBTzFHLE9BQU87Z0JBQ2RELFlBQVlDO2dCQUNaLE9BQU87b0JBQUVrRyxRQUFRO29CQUFLQyxTQUFTbkcsTUFBTW1HLE9BQU8sSUFBSW5HLE1BQU1vRyxNQUFNO2dCQUFDO1lBQy9EO1FBQ0Y7NENBQUc7UUFBQzlGLGdCQUFnQkksTUFBTTtLQUFDO0lBRTNCLG1CQUFtQjtJQUNuQixNQUFNd0osVUFBVTdMLGtEQUFXQTswQ0FBQztZQUMxQixJQUFJO2dCQUNGLE1BQU0yRixRQUFRQyxHQUFHLENBQUM7b0JBQ2hCSDtvQkFDQTJEO29CQUNBZTtvQkFDQU07b0JBQ0E3QjtpQkFDRDtnQkFDRGhILFFBQVFzQyxHQUFHLENBQUM7WUFDZCxFQUFFLE9BQU92QyxPQUFPO2dCQUNkRCxZQUFZQztZQUNkO1FBQ0Y7eUNBQUc7UUFBQzhEO1FBQWUyRDtRQUFpQmU7UUFBZ0JNO1FBQW1CN0I7S0FBZTtJQUV0Riw0QkFBNEI7SUFDNUIsTUFBTWtELGtCQUFrQjlMLGtEQUFXQTtrREFBQyxPQUFPNkc7WUFDekMsSUFBSSxDQUFDNUUsZ0JBQWdCSSxNQUFNLEVBQUU7Z0JBQzNCLE1BQU0sSUFBSW1GLE1BQU07WUFDbEI7WUFFQSxJQUFJO2dCQUNGLE1BQU1qQyxNQUFNO29CQUFDO2lCQUF1QztnQkFDcEQsTUFBTXVELE9BQU8sSUFBSTNJLDBDQUFNQSxDQUFDcUYsUUFBUSxDQUFDcEYscURBQU1BLENBQUN3SCxZQUFZLEVBQUVyQyxLQUFLdEQsZ0JBQWdCSSxNQUFNO2dCQUNqRixNQUFNK0YsS0FBSyxNQUFNVSxLQUFLaUQsWUFBWSxDQUFDbEY7Z0JBQ25DLE1BQU11QixHQUFHc0QsSUFBSTtnQkFDYjlKLFFBQVFzQyxHQUFHLENBQUMsZ0NBQWdDMkM7Z0JBQzVDLE9BQU87b0JBQUVnQixRQUFRO29CQUFLQyxTQUFTO2dCQUE0QjtZQUM3RCxFQUFFLE9BQU9uRyxPQUFPO2dCQUNkRCxZQUFZQztnQkFDWixPQUFPO29CQUFFa0csUUFBUTtvQkFBS0MsU0FBU25HLE1BQU1tRyxPQUFPLElBQUluRyxNQUFNb0csTUFBTTtnQkFBQztZQUMvRDtRQUNGO2lEQUFHO1FBQUM5RixnQkFBZ0JJLE1BQU07S0FBQztJQUUzQixtQ0FBbUM7SUFDbkMsTUFBTTJKLCtCQUErQmhNLGtEQUFXQTsrREFBQztZQUMvQyxJQUFJO2dCQUNGLElBQUksQ0FBQ2lDLGdCQUFnQkUsUUFBUSxJQUFJLENBQUNGLGdCQUFnQkssY0FBYyxFQUFFLE9BQU87Z0JBRXpFLE1BQU1pRCxNQUFNO29CQUNWO2lCQUNEO2dCQUNELE1BQU11RCxPQUFPLElBQUkzSSwwQ0FBTUEsQ0FBQ3FGLFFBQVEsQ0FBQ3BGLHFEQUFNQSxDQUFDd0gsWUFBWSxFQUFFckMsS0FBS3RELGdCQUFnQkUsUUFBUTtnQkFDbkYsTUFBTThKLFlBQVksTUFBTW5ELEtBQUtvRCxpQ0FBaUMsQ0FBQ2pLLGdCQUFnQkssY0FBYyxFQUFFO2dCQUMvRixPQUFPOEMsT0FBT2pGLDBDQUFNQSxDQUFDOEcsV0FBVyxDQUFDZ0YsV0FBVztZQUM5QyxFQUFFLE9BQU90SyxPQUFPO2dCQUNkRCxZQUFZQztnQkFDWixPQUFPO1lBQ1Q7UUFDRjs4REFBRztRQUFDTSxnQkFBZ0JFLFFBQVE7UUFBRUYsZ0JBQWdCSyxjQUFjO0tBQUM7SUFFN0QsNEJBQTRCO0lBQzVCLE1BQU02Six3QkFBd0JuTSxrREFBV0E7d0RBQUMsT0FBTytGLE9BQU9vQjtZQUN0RCxJQUFJO2dCQUNGLElBQUksQ0FBQ2xGLGdCQUFnQkUsUUFBUSxFQUFFLE9BQU87Z0JBRXRDLE1BQU1vRCxNQUFNO29CQUNWO2lCQUNEO2dCQUNELE1BQU02RyxTQUFTLElBQUlqTSwwQ0FBTUEsQ0FBQ3FGLFFBQVEsQ0FBQ3BGLHFEQUFNQSxDQUFDMkcsWUFBWSxFQUFFeEIsS0FBS3RELGdCQUFnQkUsUUFBUTtnQkFDckYsTUFBTWtLLFNBQVMsTUFBTUQsT0FBT0QscUJBQXFCLENBQUNwRyxPQUFPNUYsMENBQU1BLENBQUNnSSxVQUFVLENBQUNoQixPQUFPMUYsUUFBUSxJQUFJO2dCQUM5RixPQUFPMkQsT0FBT2pGLDBDQUFNQSxDQUFDOEcsV0FBVyxDQUFDb0YsUUFBUTtZQUMzQyxFQUFFLE9BQU8xSyxPQUFPO2dCQUNkRCxZQUFZQztnQkFDWixPQUFPO1lBQ1Q7UUFDRjt1REFBRztRQUFDTSxnQkFBZ0JFLFFBQVE7S0FBQztJQUU3QiwwQ0FBMEM7SUFDMUMsTUFBTW1LLDBCQUEwQnRNLGtEQUFXQTswREFBQyxPQUFPMEY7WUFDakQsTUFBTTZHLGFBQWEsRUFBRTtZQUNyQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSTlHLE9BQU9SLE1BQU0sRUFBRXNILElBQUs7Z0JBQ3RDLE1BQU16RyxRQUFRTCxNQUFNLENBQUM4RyxFQUFFLENBQUN6RyxLQUFLO2dCQUM3QixJQUFJMEcsVUFBVS9HLE1BQU0sQ0FBQzhHLEVBQUUsQ0FBQ0UsT0FBTztnQkFFL0IsTUFBTXRGLGNBQWMsTUFBTUYsZUFBZW5CLE9BQU8wRztnQkFDaERBLFVBQVVySCxPQUFPTSxNQUFNLENBQUM4RyxFQUFFLENBQUNFLE9BQU8sSUFBSTtnQkFFdEMsTUFBTUMsa0JBQWtCLE1BQU1YO2dCQUM5QixNQUFNSyxTQUFTLE1BQU1GLHNCQUFzQnBHLE9BQU80RztnQkFDbEQsTUFBTUMsTUFBTUgsV0FBV0osU0FBU0ksVUFBVUo7Z0JBRTFDRSxXQUFXTSxJQUFJLENBQUM7b0JBQ2Q5RyxPQUFPTCxNQUFNLENBQUM4RyxFQUFFLENBQUN6RyxLQUFLO29CQUN0QkMsU0FBU3lHO29CQUNUdkMsS0FBSzlFLE9BQU9NLE1BQU0sQ0FBQzhHLEVBQUUsQ0FBQ00sT0FBTztvQkFDN0JDLGNBQWMzRjtvQkFDZDRGLFdBQVdKO2dCQUNiO1lBQ0Y7WUFDQSxPQUFPTDtRQUNUO3lEQUFHO1FBQUNyRjtRQUFnQjhFO1FBQThCRztLQUFzQjtJQUV4RSwwQ0FBMEM7SUFDMUMsTUFBTWMsMEJBQTBCak4sa0RBQVdBOzBEQUFDLE9BQU8wRjtZQUNqRCxNQUFNd0gsY0FBYyxFQUFFO1lBQ3RCLElBQUssSUFBSVYsSUFBSSxHQUFHQSxJQUFJOUcsT0FBT1IsTUFBTSxFQUFFc0gsSUFBSztnQkFDdEMsTUFBTXpHLFFBQVFMLE1BQU0sQ0FBQzhHLEVBQUUsQ0FBQ3pHLEtBQUs7Z0JBQzdCLE1BQU1vSCxZQUFZekgsTUFBTSxDQUFDOEcsRUFBRSxDQUFDVyxTQUFTO2dCQUNyQyxNQUFNQyxZQUFZMUgsTUFBTSxDQUFDOEcsRUFBRSxDQUFDWSxTQUFTO2dCQUNyQyxNQUFNaEcsY0FBYyxNQUFNRixlQUFlbkIsT0FBT29IO2dCQUVoREQsWUFBWUwsSUFBSSxDQUFDO29CQUNmOUcsT0FBT0E7b0JBQ1BvSCxXQUFXL0gsT0FBTytIO29CQUNsQkMsV0FBV2hJLE9BQU9nSTtvQkFDbEJDLGtCQUFrQmpHO2dCQUNwQjtZQUNGO1lBQ0EsT0FBTzhGO1FBQ1Q7eURBQUc7UUFBQ2hHO0tBQWU7SUFFbkIsMkNBQTJDO0lBQzNDLE1BQU1vRyx5QkFBeUJ0TixrREFBV0E7eURBQUMsQ0FBQzBGO1lBQzFDLE1BQU02SCxTQUFTbk4scURBQU1BLENBQUN5RixNQUFNLENBQ3pCeUQsTUFBTTt3RUFBQyxDQUFDa0U7b0JBQ1AsT0FBTzlILE9BQU8rSCxJQUFJO2dGQUFDLENBQUNDOzRCQUNsQixPQUFPRixVQUFVbEksT0FBTyxDQUFDcUMsV0FBVyxPQUFPK0YsVUFBVTNILEtBQUssQ0FBQzRCLFdBQVc7d0JBQ3hFOztnQkFDRjt1RUFDQzdCLEdBQUc7d0VBQUMsQ0FBQzZILFdBQWM7d0JBQ2xCLEdBQUdqSSxPQUFPK0IsSUFBSTtvRkFBQyxDQUFDbUcsT0FBU0EsS0FBSzdILEtBQUssQ0FBQzRCLFdBQVcsT0FBT2dHLFNBQVNySSxPQUFPLENBQUNxQyxXQUFXO2tGQUFHO3dCQUNyRixHQUFHZ0csUUFBUTtvQkFDYjs7WUFDRixPQUFPSjtRQUNUO3dEQUFHLEVBQUU7SUFFTCxnQkFBZ0I7SUFDaEIsTUFBTU0sZUFBZTVOLDhDQUFPQTsyQ0FBQyxJQUFPO2dCQUNsQyxRQUFRO2dCQUNSZ0M7Z0JBQ0FPO2dCQUNBRTtnQkFDQUU7Z0JBQ0FFO2dCQUNBTTtnQkFDQUs7Z0JBQ0FHO2dCQUNBWjtnQkFFQSxtQkFBbUI7Z0JBQ25CaUI7Z0JBQ0E0SDtnQkFFQSxrQkFBa0I7Z0JBQ2xCcEc7Z0JBQ0EyRDtnQkFDQWU7Z0JBQ0FNO2dCQUVBLHdCQUF3QjtnQkFDeEJwRDtnQkFDQVc7Z0JBQ0FNO2dCQUNBRTtnQkFDQUU7Z0JBRUEsb0JBQW9CO2dCQUNwQnJEO2dCQUNBbUI7Z0JBQ0FVO2dCQUNBNUY7Z0JBQ0FJO2dCQUVBLHFCQUFxQjtnQkFDckJ5SjtnQkFDQVE7Z0JBRUEsb0JBQW9CO2dCQUNwQi9DO2dCQUNBb0Q7Z0JBQ0FHO2dCQUVBLDRCQUE0QjtnQkFDNUJHO2dCQUNBVztnQkFDQUs7Z0JBRUEscUJBQXFCO2dCQUNyQnhCO1lBQ0Y7MENBQUk7UUFDRjdKO1FBQ0FPO1FBQ0FFO1FBQ0FFO1FBQ0FFO1FBQ0FNO1FBQ0FLO1FBQ0FHO1FBQ0FaO1FBQ0FpQjtRQUNBNEg7UUFDQXBHO1FBQ0EyRDtRQUNBZTtRQUNBTTtRQUNBcEQ7UUFDQVc7UUFDQU07UUFDQUU7UUFDQUU7UUFDQXJEO1FBQ0FtQjtRQUNBVTtRQUNBaUU7UUFDQVE7UUFDQS9DO1FBQ0FvRDtRQUNBRztRQUNBRztRQUNBVztRQUNBSztRQUNBeEI7S0FDRDtJQUVELHFCQUNFLDhEQUFDNUwsNkRBQW9CO1FBQUN1TCxPQUFPb0M7a0JBQzFCN0wsTUFBTStMLFFBQVE7Ozs7OztBQUdyQjtHQW56Qk1oTTtLQUFBQTtBQXF6Qk4saUVBQWVBLFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxzcmNcXGNvbnRleHRcXExlbmRTdGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgbGVuZENvbnRleHQgZnJvbSBcIi4vbGVuZENvbnRleHRcIjtcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gXCJldGhlcnNcIjtcbmltcG9ydCB7IENPTkZJRyB9IGZyb20gXCIuLi9jb25maWcvY29udHJhY3RzXCI7XG5pbXBvcnQgeyBnZXRUb2tlbkJhbGFuY2UsIGdldFRva2VuQWxsb3dhbmNlLCBhcHByb3ZlSWZOZWVkZWQsIGxlbmQgYXMgbGVuZFR4LCB3aXRoZHJhdyBhcyB3aXRoZHJhd1R4LCBib3Jyb3cgYXMgYm9ycm93VHgsIHJlcGF5IGFzIHJlcGF5VHggfSBmcm9tIFwiLi4vbGliL3R4XCI7XG5pbXBvcnQgeyBFVEhBZGRyZXNzLCBMZW5kaW5nUG9vbEFkZHJlc3MsIExlbmRpbmdIZWxwZXJBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3Nlc1wiO1xuaW1wb3J0IHsgVG9rZW5BQkksIExlbmRpbmdQb29sQUJJLCBMZW5kaW5nSGVscGVyQUJJIH0gZnJvbSBcIi4uL2FiaXNcIjtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnNcbmNvbnN0IG51bWJlclRvRXRoZXJzID0gKG51bWJlcikgPT4ge1xuICByZXR1cm4gZXRoZXJzLnBhcnNlRXRoZXIobnVtYmVyLnRvU3RyaW5nKCkpO1xufTtcblxuY29uc3QgcmVwb3J0RXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgY29uc29sZS5lcnJvcihcIkxlbmRTdGF0ZSBFcnJvcjpcIiwgSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcbiAgY29uc29sZS5lcnJvcihcIkVycm9yIGRldGFpbHM6XCIsIGVycm9yKTtcbn07XG5cbmNvbnN0IExlbmRTdGF0ZSA9IChwcm9wcykgPT4ge1xuICAvLyogRGVjbGFyaW5nIGFsbCB0aGUgc3RhdGVzXG5cbiAgLy8gU2V0IG1ldGFtYXNrIGRldGFpbHNcbiAgY29uc3QgW21ldGFtYXNrRGV0YWlscywgc2V0TWV0YW1hc2tEZXRhaWxzXSA9IHVzZVN0YXRlKHtcbiAgICBwcm92aWRlcjogbnVsbCxcbiAgICBuZXR3b3JrTmFtZTogbnVsbCxcbiAgICBzaWduZXI6IG51bGwsXG4gICAgY3VycmVudEFjY291bnQ6IG51bGwsXG4gICAgY2hhaW5JZDogbnVsbCxcbiAgfSk7XG5cbiAgLy8gVXNlciBhc3NldHMgYW5kIGJhbGFuY2VzXG4gIGNvbnN0IFt1c2VyQXNzZXRzLCBzZXRVc2VyQXNzZXRzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW3N1cHBseUFzc2V0cywgc2V0U3VwcGx5QXNzZXRzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW2Fzc2V0c1RvQm9ycm93LCBzZXRBc3NldHNUb0JvcnJvd10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFt5b3VyQm9ycm93cywgc2V0WW91ckJvcnJvd3NdID0gdXNlU3RhdGUoW10pO1xuXG4gIC8vIENvbnRyYWN0IGRldGFpbHNcbiAgY29uc3QgW2NvbnRyYWN0LCBzZXRDb250cmFjdF0gPSB1c2VTdGF0ZSh7XG4gICAgbGVuZGluZ1Bvb2xDb250cmFjdDogbnVsbCxcbiAgICBvcmFjbGVDb250cmFjdDogbnVsbCxcbiAgfSk7XG5cbiAgLy8gU3VtbWFyeSBkYXRhXG4gIGNvbnN0IFtzdXBwbHlTdW1tYXJ5LCBzZXRTdXBwbHlTdW1tYXJ5XSA9IHVzZVN0YXRlKHtcbiAgICB0b3RhbFVTREJhbGFuY2U6IDAsXG4gICAgd2VpZ2h0ZWRBdmdBUFk6IDAsXG4gICAgdG90YWxVU0RDb2xsYXRlcmFsOiAwLFxuICB9KTtcblxuICBjb25zdCBbYm9ycm93U3VtbWFyeSwgc2V0Qm9ycm93U3VtbWFyeV0gPSB1c2VTdGF0ZSh7XG4gICAgdG90YWxVU0RCYWxhbmNlOiAwLFxuICAgIHdlaWdodGVkQXZnQVBZOiAwLFxuICAgIHRvdGFsQm9ycm93UG93ZXJVc2VkOiAwLFxuICB9KTtcblxuICAvLyBBY2NvdW50IGRhdGFcbiAgY29uc3QgW2FjY291bnREYXRhLCBzZXRBY2NvdW50RGF0YV0gPSB1c2VTdGF0ZSh7XG4gICAgY29sbGF0ZXJhbFVTRDogXCIwXCIsXG4gICAgZGVidFVTRDogXCIwXCIsXG4gICAgaGVhbHRoRmFjdG9yOiBcIjBcIixcbiAgfSk7XG5cbiAgLy8gQ29ubmVjdCB3YWxsZXRcbiAgLy8gY29uc3QgY29ubmVjdFdhbGxldCA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgLy8gICBjb25zb2xlLmxvZyhcIjEuIENvbm5lY3RpbmcgdG8gd2FsbGV0Li4uXCIpO1xuICAvLyAgIGNvbnN0IHsgZXRoZXJldW0gfSA9IHdpbmRvdztcbiAgLy8gICBjb25zdCBmYWlsTWVzc2FnZSA9IFwiUGxlYXNlIGluc3RhbGwgTWV0YW1hc2sgJiBjb25uZWN0IHlvdXIgTWV0YW1hc2tcIjtcbiAgICBcbiAgLy8gICB0cnkge1xuICAvLyAgICAgaWYgKCFldGhlcmV1bSkge1xuICAvLyAgICAgICBhbGVydChmYWlsTWVzc2FnZSk7XG4gIC8vICAgICAgIHJldHVybjtcbiAgLy8gICAgIH1cblxuICAvLyAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBldGhlcmV1bS5yZXF1ZXN0KHtcbiAgLy8gICAgICAgbWV0aG9kOiBcImV0aF9yZXF1ZXN0QWNjb3VudHNcIixcbiAgLy8gICAgIH0pO1xuXG4gIC8vICAgICAvLyBMaXN0ZW4gZm9yIGFjY291bnQgYW5kIGNoYWluIGNoYW5nZXNcbiAgLy8gICAgIGV0aGVyZXVtLm9uKFwiY2hhaW5DaGFuZ2VkXCIsICgpID0+IHtcbiAgLy8gICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAvLyAgICAgfSk7XG4gIC8vICAgICBldGhlcmV1bS5vbihcImFjY291bnRzQ2hhbmdlZFwiLCAoKSA9PiB7XG4gIC8vICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgLy8gICAgIH0pO1xuXG4gIC8vICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuQnJvd3NlclByb3ZpZGVyKGV0aGVyZXVtKTtcbiAgLy8gICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBwcm92aWRlci5nZXROZXR3b3JrKCk7XG4gIC8vICAgICBjb25zdCBuZXR3b3JrTmFtZSA9IG5ldHdvcmsubmFtZTtcbiAgLy8gICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xuXG4gIC8vICAgICBpZiAoYWNjb3VudHMubGVuZ3RoKSB7XG4gIC8vICAgICAgIGxldCBjdXJyZW50QWRkcmVzcyA9IGFjY291bnRzWzBdO1xuICAvLyAgICAgICBzZXRNZXRhbWFza0RldGFpbHMoe1xuICAvLyAgICAgICAgIHByb3ZpZGVyOiBwcm92aWRlcixcbiAgLy8gICAgICAgICBuZXR3b3JrTmFtZTogbmV0d29ya05hbWUsXG4gIC8vICAgICAgICAgc2lnbmVyOiBzaWduZXIsXG4gIC8vICAgICAgICAgY3VycmVudEFjY291bnQ6IGN1cnJlbnRBZGRyZXNzLFxuICAvLyAgICAgICAgIGNoYWluSWQ6IE51bWJlcihuZXR3b3JrLmNoYWluSWQpLFxuICAvLyAgICAgICB9KTtcbiAgLy8gICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0ZWQgdG8gd2FsbGV0OlwiLCBjdXJyZW50QWRkcmVzcyk7XG4gIC8vICAgICB9IGVsc2Uge1xuICAvLyAgICAgICBhbGVydChmYWlsTWVzc2FnZSk7XG4gIC8vICAgICAgIHJldHVybjtcbiAgLy8gICAgIH1cbiAgLy8gICB9IGNhdGNoIChlcnJvcikge1xuICAvLyAgICAgcmVwb3J0RXJyb3IoZXJyb3IpO1xuICAvLyAgIH1cbiAgLy8gfSwgW10pO1xuXG4gIGNvbnN0IGNvbm5lY3RXYWxsZXQgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coXCIxLiBDb25uZWN0aW5nIHRvIHdhbGxldC4uLlwiKTtcbiAgICBjb25zdCB7IGV0aGVyZXVtIH0gPSB3aW5kb3c7XG4gICAgY29uc3QgZmFpbE1lc3NhZ2UgPSBcIlBsZWFzZSBpbnN0YWxsIE1ldGFtYXNrICYgY29ubmVjdCB5b3VyIE1ldGFtYXNrXCI7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghZXRoZXJldW0pIHtcbiAgICAgICAgYWxlcnQoZmFpbE1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgZXRoZXJldW0ucmVxdWVzdCh7IG1ldGhvZDogXCJldGhfcmVxdWVzdEFjY291bnRzXCIgfSk7XG5cbiAgICAgIC8vIExpc3RlbiBmb3IgYWNjb3VudCBhbmQgY2hhaW4gY2hhbmdlc1xuICAgICAgZXRoZXJldW0ub24oXCJjaGFpbkNoYW5nZWRcIiwgKCkgPT4ge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICB9KTtcbiAgICAgIGV0aGVyZXVtLm9uKFwiYWNjb3VudHNDaGFuZ2VkXCIsICgpID0+IHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Ccm93c2VyUHJvdmlkZXIoZXRoZXJldW0pO1xuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHByb3ZpZGVyLmdldE5ldHdvcmsoKTtcbiAgICAgIGNvbnN0IG5ldHdvcmtOYW1lID0gbmV0d29yay5uYW1lO1xuICAgICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XG5cbiAgICAgIGlmIChhY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRBZGRyZXNzID0gYWNjb3VudHNbMF07XG4gICAgICAgIHNldE1ldGFtYXNrRGV0YWlscyh7XG4gICAgICAgICAgcHJvdmlkZXI6IHByb3ZpZGVyLFxuICAgICAgICAgIG5ldHdvcmtOYW1lOiBuZXR3b3JrTmFtZSxcbiAgICAgICAgICBzaWduZXI6IHNpZ25lcixcbiAgICAgICAgICBjdXJyZW50QWNjb3VudDogY3VycmVudEFkZHJlc3MsXG4gICAgICAgICAgY2hhaW5JZDogTnVtYmVyKG5ldHdvcmsuY2hhaW5JZCksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNvbm5lY3RlZCB0byB3YWxsZXQrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrOlwiLCBjdXJyZW50QWRkcmVzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGVydChmYWlsTWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIEdldCBjb250cmFjdCBpbnN0YW5jZVxuICBjb25zdCBnZXRDb250cmFjdCA9IHVzZUNhbGxiYWNrKGFzeW5jIChhZGRyZXNzLCBhYmkpID0+IHtcbiAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5wcm92aWRlcikgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGFkZHJlc3MsIGFiaSwgbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyKTtcbiAgICByZXR1cm4gY29udHJhY3Q7XG4gIH0sIFttZXRhbWFza0RldGFpbHMucHJvdmlkZXJdKTtcblxuICAvLyBHZXQgdXNlciBhc3NldHMgKGJhbGFuY2VzKVxuICBjb25zdCBnZXRVc2VyQXNzZXRzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiMi4gR2V0dGluZyB1c2VyIGFzc2V0cy4uLlwiKTtcbiAgICB0cnkge1xuICAgICAgaWYgKCFtZXRhbWFza0RldGFpbHMucHJvdmlkZXIgfHwgIW1ldGFtYXNrRGV0YWlscy5jdXJyZW50QWNjb3VudCkgcmV0dXJuIFtdO1xuXG4gICAgICBjb25zdCBhc3NldHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgQ09ORklHLlRPS0VOUy5tYXAoYXN5bmMgKHRva2VuKSA9PiB7XG4gICAgICAgICAgbGV0IGJhbGFuY2UgPSBcIjBcIjtcbiAgICAgICAgICBsZXQgYmFsYW5jZVVTRCA9IDA7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRva2VuLmlzTmF0aXZlKSB7XG4gICAgICAgICAgICAgIC8vIEVUSCBuYXRpdmUgYmFsYW5jZVxuICAgICAgICAgICAgICBjb25zdCBiYWwgPSBhd2FpdCBtZXRhbWFza0RldGFpbHMucHJvdmlkZXIuZ2V0QmFsYW5jZShtZXRhbWFza0RldGFpbHMuY3VycmVudEFjY291bnQpO1xuICAgICAgICAgICAgICBiYWxhbmNlID0gZXRoZXJzLmZvcm1hdEV0aGVyKGJhbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBFUkMyMCB0b2tlbiBiYWxhbmNlXG4gICAgICAgICAgICAgIGJhbGFuY2UgPSBhd2FpdCBnZXRUb2tlbkJhbGFuY2UoXG4gICAgICAgICAgICAgICAgbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIHRva2VuLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgbWV0YW1hc2tEZXRhaWxzLmN1cnJlbnRBY2NvdW50LFxuICAgICAgICAgICAgICAgIHRva2VuLmRlY2ltYWxzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCBVU0QgdmFsdWVcbiAgICAgICAgICAgIGNvbnN0IHByaWNlID0gYXdhaXQgZ2V0UHJpY2VVU0QodG9rZW4uYWRkcmVzcyk7XG4gICAgICAgICAgICBiYWxhbmNlVVNEID0gcGFyc2VGbG9hdChiYWxhbmNlKSAqIHBhcnNlRmxvYXQocHJpY2UpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBhZGRyZXNzOiB0b2tlbi5hZGRyZXNzLFxuICAgICAgICAgICAgICBzeW1ib2w6IHRva2VuLnN5bWJvbCxcbiAgICAgICAgICAgICAgbmFtZTogdG9rZW4ubmFtZSxcbiAgICAgICAgICAgICAgZGVjaW1hbHM6IHRva2VuLmRlY2ltYWxzLFxuICAgICAgICAgICAgICBpc05hdGl2ZTogdG9rZW4uaXNOYXRpdmUsXG4gICAgICAgICAgICAgIGJhbGFuY2U6IGJhbGFuY2UsXG4gICAgICAgICAgICAgIGJhbGFuY2VVU0Q6IGJhbGFuY2VVU0QsXG4gICAgICAgICAgICAgIHByaWNlVVNEOiBwcmljZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRXJyb3IgZ2V0dGluZyBiYWxhbmNlIGZvciAke3Rva2VuLnN5bWJvbH06YCwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgYWRkcmVzczogdG9rZW4uYWRkcmVzcyxcbiAgICAgICAgICAgICAgc3ltYm9sOiB0b2tlbi5zeW1ib2wsXG4gICAgICAgICAgICAgIG5hbWU6IHRva2VuLm5hbWUsXG4gICAgICAgICAgICAgIGRlY2ltYWxzOiB0b2tlbi5kZWNpbWFscyxcbiAgICAgICAgICAgICAgaXNOYXRpdmU6IHRva2VuLmlzTmF0aXZlLFxuICAgICAgICAgICAgICBiYWxhbmNlOiBcIjBcIixcbiAgICAgICAgICAgICAgYmFsYW5jZVVTRDogMCxcbiAgICAgICAgICAgICAgcHJpY2VVU0Q6IFwiMFwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICBzZXRVc2VyQXNzZXRzKGFzc2V0cyk7XG4gICAgICBjb25zb2xlLmxvZyhcIkdvdCB1c2VyIGFzc2V0czpcIiwgYXNzZXRzKTtcbiAgICAgIHJldHVybiBhc3NldHM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydEVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0sIFttZXRhbWFza0RldGFpbHMucHJvdmlkZXIsIG1ldGFtYXNrRGV0YWlscy5jdXJyZW50QWNjb3VudF0pO1xuXG4gIC8vIEdldCBwcmljZSBpbiBVU0RcbiAgY29uc3QgZ2V0UHJpY2VVU0QgPSB1c2VDYWxsYmFjayhhc3luYyAoYXNzZXQpID0+IHtcbiAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5wcm92aWRlcikgcmV0dXJuIFwiMFwiO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhYmkgPSBbJ2Z1bmN0aW9uIGdldEFzc2V0UHJpY2UxZTE4KGFkZHJlc3MgYXNzZXQpIHZpZXcgcmV0dXJucyAodWludDI1NiknXTtcbiAgICAgIGNvbnN0IG9yYWNsZSA9IG5ldyBldGhlcnMuQ29udHJhY3QoQ09ORklHLlBSSUNFX09SQUNMRSwgYWJpLCBtZXRhbWFza0RldGFpbHMucHJvdmlkZXIpO1xuICAgICAgY29uc3QgcHJpY2UgPSBhd2FpdCBvcmFjbGUuZ2V0QXNzZXRQcmljZTFlMTgoYXNzZXQpO1xuICAgICAgcmV0dXJuIGV0aGVycy5mb3JtYXRVbml0cyhwcmljZSwgMTgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEVycm9yIGdldHRpbmcgcHJpY2UgZm9yICR7YXNzZXR9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiBcIjBcIjtcbiAgICB9XG4gIH0sIFttZXRhbWFza0RldGFpbHMucHJvdmlkZXJdKTtcblxuICAvLyBHZXQgYW1vdW50IGluIFVTRFxuICBjb25zdCBnZXRBbW91bnRJblVTRCA9IHVzZUNhbGxiYWNrKGFzeW5jIChhZGRyZXNzLCBhbW91bnQpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJpY2UgPSBhd2FpdCBnZXRQcmljZVVTRChhZGRyZXNzKTtcbiAgICAgIGNvbnN0IGFtb3VudEluVVNEID0gcGFyc2VGbG9hdChhbW91bnQpICogcGFyc2VGbG9hdChwcmljZSk7XG4gICAgICByZXR1cm4gYW1vdW50SW5VU0Q7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydEVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSwgW2dldFByaWNlVVNEXSk7XG5cbiAgLy8gQXBwcm92ZSB0b2tlbnNcbiAgY29uc3QgQXBwcm92ZVRvQ29udGludWUgPSB1c2VDYWxsYmFjayhhc3luYyAodG9rZW5BZGRyZXNzLCBhcHByb3ZlQW1vdW50KSA9PiB7XG4gICAgaWYgKCFtZXRhbWFza0RldGFpbHMuc2lnbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0b2tlbiA9IENPTkZJRy5UT0tFTlMuZmluZCh0ID0+IHQuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSB0b2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICBpZiAoIXRva2VuKSB0aHJvdyBuZXcgRXJyb3IoXCJUb2tlbiBub3QgZm91bmRcIik7XG5cbiAgICAgIGF3YWl0IGFwcHJvdmVJZk5lZWRlZChcbiAgICAgICAgbWV0YW1hc2tEZXRhaWxzLnNpZ25lcixcbiAgICAgICAgdG9rZW5BZGRyZXNzLFxuICAgICAgICBDT05GSUcuTEVORElOR19QT09MLFxuICAgICAgICBhcHByb3ZlQW1vdW50LFxuICAgICAgICB0b2tlbi5kZWNpbWFsc1xuICAgICAgKTtcblxuICAgICAgY29uc29sZS5sb2coXCJUb2tlbiBhcHByb3ZlZDpcIiwgdG9rZW5BZGRyZXNzKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogMjAwLCBtZXNzYWdlOiBcIlRyYW5zYWN0aW9uIFN1Y2Nlc3NmdWwuLi5cIiB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4geyBzdGF0dXM6IDUwMCwgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB8fCBlcnJvci5yZWFzb24gfTtcbiAgICB9XG4gIH0sIFttZXRhbWFza0RldGFpbHMuc2lnbmVyXSk7XG5cbiAgLy8gTGVuZCBhc3NldFxuICBjb25zdCBMZW5kQXNzZXQgPSB1c2VDYWxsYmFjayhhc3luYyAodG9rZW4sIHN1cHBseUFtb3VudCkgPT4ge1xuICAgIGlmICghbWV0YW1hc2tEZXRhaWxzLnNpZ25lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmVyIGF2YWlsYWJsZVwiKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdG9rZW5JbmZvID0gQ09ORklHLlRPS0VOUy5maW5kKHQgPT4gdC5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IHRva2VuLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKCF0b2tlbkluZm8pIHRocm93IG5ldyBFcnJvcihcIlRva2VuIG5vdCBmb3VuZFwiKTtcblxuICAgICAgY29uc3QgYW1vdW50ID0gZXRoZXJzLnBhcnNlVW5pdHMoc3VwcGx5QW1vdW50LCB0b2tlbkluZm8uZGVjaW1hbHMpO1xuICAgICAgY29uc3QgdHggPSBhd2FpdCBsZW5kVHgobWV0YW1hc2tEZXRhaWxzLnNpZ25lciwgdG9rZW4sIGFtb3VudCk7XG4gICAgICBcbiAgICAgIGlmICh0eCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFzc2V0IGxlbnQgc3VjY2Vzc2Z1bGx5OlwiLCB0b2tlbiwgc3VwcGx5QW1vdW50KTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAyMDAsIG1lc3NhZ2U6IFwiVHJhbnNhY3Rpb24gU3VjY2Vzc2Z1bC4uLlwiLCBoYXNoOiB0eC5oYXNoIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2FjdGlvbiBmYWlsZWRcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydEVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogNTAwLCBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8IGVycm9yLnJlYXNvbiB9O1xuICAgIH1cbiAgfSwgW21ldGFtYXNrRGV0YWlscy5zaWduZXJdKTtcblxuICAvLyBXaXRoZHJhdyBhc3NldFxuICBjb25zdCBXaXRoZHJhd0Fzc2V0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKHRva2VuQWRkcmVzcywgd2l0aGRyYXdBbW91bnQpID0+IHtcbiAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5zaWduZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRva2VuSW5mbyA9IENPTkZJRy5UT0tFTlMuZmluZCh0ID0+IHQuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSB0b2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICBpZiAoIXRva2VuSW5mbykgdGhyb3cgbmV3IEVycm9yKFwiVG9rZW4gbm90IGZvdW5kXCIpO1xuXG4gICAgICBjb25zdCBhbW91bnQgPSBldGhlcnMucGFyc2VVbml0cyh3aXRoZHJhd0Ftb3VudCwgdG9rZW5JbmZvLmRlY2ltYWxzKTtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgd2l0aGRyYXdUeChtZXRhbWFza0RldGFpbHMuc2lnbmVyLCB0b2tlbkFkZHJlc3MsIGFtb3VudCk7XG4gICAgICBcbiAgICAgIGlmICh0eCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFzc2V0IHdpdGhkcmF3biBzdWNjZXNzZnVsbHk6XCIsIHRva2VuQWRkcmVzcywgd2l0aGRyYXdBbW91bnQpO1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IDIwMCwgbWVzc2FnZTogXCJUcmFuc2FjdGlvbiBTdWNjZXNzZnVsLi4uXCIsIGhhc2g6IHR4Lmhhc2ggfTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIGZhaWxlZFwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiA1MDAsIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IucmVhc29uIH07XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnNpZ25lcl0pO1xuXG4gIC8vIEJvcnJvdyBhc3NldFxuICBjb25zdCBib3Jyb3dBc3NldCA9IHVzZUNhbGxiYWNrKGFzeW5jICh0b2tlbiwgYm9ycm93QW1vdW50KSA9PiB7XG4gICAgaWYgKCFtZXRhbWFza0RldGFpbHMuc2lnbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0b2tlbkluZm8gPSBDT05GSUcuVE9LRU5TLmZpbmQodCA9PiB0LmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gdG9rZW4udG9Mb3dlckNhc2UoKSk7XG4gICAgICBpZiAoIXRva2VuSW5mbykgdGhyb3cgbmV3IEVycm9yKFwiVG9rZW4gbm90IGZvdW5kXCIpO1xuXG4gICAgICBjb25zdCBhbW91bnQgPSBldGhlcnMucGFyc2VVbml0cyhib3Jyb3dBbW91bnQsIHRva2VuSW5mby5kZWNpbWFscyk7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IGJvcnJvd1R4KG1ldGFtYXNrRGV0YWlscy5zaWduZXIsIHRva2VuLCBhbW91bnQpO1xuICAgICAgXG4gICAgICBpZiAodHgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJBc3NldCBib3Jyb3dlZCBzdWNjZXNzZnVsbHk6XCIsIHRva2VuLCBib3Jyb3dBbW91bnQpO1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IDIwMCwgbWVzc2FnZTogXCJUcmFuc2FjdGlvbiBTdWNjZXNzZnVsLi4uXCIsIGhhc2g6IHR4Lmhhc2ggfTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIGZhaWxlZFwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiA1MDAsIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IucmVhc29uIH07XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnNpZ25lcl0pO1xuXG4gIC8vIFJlcGF5IGFzc2V0XG4gIGNvbnN0IHJlcGF5QXNzZXQgPSB1c2VDYWxsYmFjayhhc3luYyAodG9rZW5BZGRyZXNzLCByZXBheUFtb3VudCkgPT4ge1xuICAgIGlmICghbWV0YW1hc2tEZXRhaWxzLnNpZ25lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmVyIGF2YWlsYWJsZVwiKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdG9rZW5JbmZvID0gQ09ORklHLlRPS0VOUy5maW5kKHQgPT4gdC5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IHRva2VuQWRkcmVzcy50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIGlmICghdG9rZW5JbmZvKSB0aHJvdyBuZXcgRXJyb3IoXCJUb2tlbiBub3QgZm91bmRcIik7XG5cbiAgICAgIGNvbnN0IGFtb3VudCA9IGV0aGVycy5wYXJzZVVuaXRzKHJlcGF5QW1vdW50LCB0b2tlbkluZm8uZGVjaW1hbHMpO1xuICAgICAgY29uc3QgdHggPSBhd2FpdCByZXBheVR4KG1ldGFtYXNrRGV0YWlscy5zaWduZXIsIHRva2VuQWRkcmVzcywgYW1vdW50KTtcbiAgICAgIFxuICAgICAgaWYgKHR4KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQXNzZXQgcmVwYWlkIHN1Y2Nlc3NmdWxseTpcIiwgdG9rZW5BZGRyZXNzLCByZXBheUFtb3VudCk7XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogMjAwLCBtZXNzYWdlOiBcIlRyYW5zYWN0aW9uIFN1Y2Nlc3NmdWwuLi5cIiwgaGFzaDogdHguaGFzaCB9O1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gZmFpbGVkXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4geyBzdGF0dXM6IDUwMCwgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB8fCBlcnJvci5yZWFzb24gfTtcbiAgICB9XG4gIH0sIFttZXRhbWFza0RldGFpbHMuc2lnbmVyXSk7XG5cbiAgLy8gR2V0IGFjY291bnQgZGF0YSAoY29sbGF0ZXJhbCwgZGVidCwgaGVhbHRoIGZhY3RvcilcbiAgY29uc3QgZ2V0QWNjb3VudERhdGEgPSB1c2VDYWxsYmFjayhhc3luYyAodXNlcikgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5wcm92aWRlcikgcmV0dXJuIG51bGw7XG5cbiAgICAgIGNvbnN0IHBvb2wgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KExlbmRpbmdQb29sQWRkcmVzcywgTGVuZGluZ1Bvb2xBQkkuYWJpLCBtZXRhbWFza0RldGFpbHMucHJvdmlkZXIpO1xuICAgICAgY29uc3Qgd2FsbGV0ID0gdXNlciB8fCBtZXRhbWFza0RldGFpbHMuY3VycmVudEFjY291bnQgfHwgZXRoZXJzLlplcm9BZGRyZXNzO1xuICAgICAgY29uc3QgW2NvbCwgZGVidCwgaGZdID0gYXdhaXQgcG9vbC5nZXRBY2NvdW50RGF0YSh3YWxsZXQpO1xuICAgICAgXG4gICAgICBjb25zdCBhY2NvdW50RGF0YSA9IHtcbiAgICAgICAgY29sbGF0ZXJhbFVTRDogZXRoZXJzLmZvcm1hdFVuaXRzKGNvbCwgMTgpLFxuICAgICAgICBkZWJ0VVNEOiBldGhlcnMuZm9ybWF0VW5pdHMoZGVidCwgMTgpLFxuICAgICAgICBoZWFsdGhGYWN0b3I6IGV0aGVycy5mb3JtYXRVbml0cyhoZiwgMTgpXG4gICAgICB9O1xuXG4gICAgICBzZXRBY2NvdW50RGF0YShhY2NvdW50RGF0YSk7XG4gICAgICByZXR1cm4gYWNjb3VudERhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydEVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwgW21ldGFtYXNrRGV0YWlscy5wcm92aWRlciwgbWV0YW1hc2tEZXRhaWxzLmN1cnJlbnRBY2NvdW50XSk7XG5cbiAgLy8gR2V0IHlvdXIgc3VwcGxpZXNcbiAgY29uc3QgZ2V0WW91clN1cHBsaWVzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiMy4gR2V0dGluZyB5b3VyIHN1cHBsaWVzLi4uXCIpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5wcm92aWRlciB8fCAhbWV0YW1hc2tEZXRhaWxzLmN1cnJlbnRBY2NvdW50KSByZXR1cm4gW107XG5cbiAgICAgIGNvbnN0IGFiaSA9IFtcbiAgICAgICAgJ2Z1bmN0aW9uIGdldFVzZXJSZXNlcnZlKGFkZHJlc3MgdXNlciwgYWRkcmVzcyBhc3NldCkgdmlldyByZXR1cm5zICh0dXBsZSh1aW50MTI4IHByaW5jaXBhbCx1aW50MTI4IGluZGV4KSBzdXBwbHksIHR1cGxlKHVpbnQxMjggcHJpbmNpcGFsLHVpbnQxMjggaW5kZXgpIGJvcnJvdyknXG4gICAgICBdO1xuICAgICAgY29uc3QgcG9vbCA9IG5ldyBldGhlcnMuQ29udHJhY3QoQ09ORklHLkxFTkRJTkdfUE9PTCwgYWJpLCBtZXRhbWFza0RldGFpbHMucHJvdmlkZXIpO1xuXG4gICAgICBjb25zdCBzdXBwbGllcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBDT05GSUcuVE9LRU5TLmZpbHRlcih0ID0+ICF0LmlzTmF0aXZlKS5tYXAoYXN5bmMgKHRva2VuKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJSZXNlcnZlID0gYXdhaXQgcG9vbC5nZXRVc2VyUmVzZXJ2ZShtZXRhbWFza0RldGFpbHMuY3VycmVudEFjY291bnQsIHRva2VuLmFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3Qgc3VwcGx5UHJpbmNpcGFsID0gZXRoZXJzLmZvcm1hdFVuaXRzKHVzZXJSZXNlcnZlLnN1cHBseS5wcmluY2lwYWwsIDE4KTtcbiAgICAgICAgICAgIGNvbnN0IHN1cHBseUluZGV4ID0gdXNlclJlc2VydmUuc3VwcGx5LmluZGV4LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KHN1cHBseVByaW5jaXBhbCkgPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHByaWNlID0gYXdhaXQgZ2V0UHJpY2VVU0QodG9rZW4uYWRkcmVzcyk7XG4gICAgICAgICAgICAgIGNvbnN0IGJhbGFuY2VVU0QgPSBwYXJzZUZsb2F0KHN1cHBseVByaW5jaXBhbCkgKiBwYXJzZUZsb2F0KHByaWNlKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdG9rZW4uYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzeW1ib2w6IHRva2VuLnN5bWJvbCxcbiAgICAgICAgICAgICAgICBuYW1lOiB0b2tlbi5uYW1lLFxuICAgICAgICAgICAgICAgIGRlY2ltYWxzOiB0b2tlbi5kZWNpbWFscyxcbiAgICAgICAgICAgICAgICBzdXBwbHlQcmluY2lwYWw6IHN1cHBseVByaW5jaXBhbCxcbiAgICAgICAgICAgICAgICBzdXBwbHlJbmRleDogc3VwcGx5SW5kZXgsXG4gICAgICAgICAgICAgICAgYmFsYW5jZVVTRDogYmFsYW5jZVVTRCxcbiAgICAgICAgICAgICAgICBwcmljZVVTRDogcHJpY2UsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBFcnJvciBnZXR0aW5nIHN1cHBseSBmb3IgJHt0b2tlbi5zeW1ib2x9OmAsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHZhbGlkU3VwcGxpZXMgPSBzdXBwbGllcy5maWx0ZXIocyA9PiBzICE9PSBudWxsKTtcbiAgICAgIHNldFN1cHBseUFzc2V0cyh2YWxpZFN1cHBsaWVzKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHN1bW1hcnlcbiAgICAgIGNvbnN0IHRvdGFsVVNEQmFsYW5jZSA9IHZhbGlkU3VwcGxpZXMucmVkdWNlKChzdW0sIGFzc2V0KSA9PiBzdW0gKyBhc3NldC5iYWxhbmNlVVNELCAwKTtcbiAgICAgIGNvbnN0IHdlaWdodGVkQXZnQVBZID0gdmFsaWRTdXBwbGllcy5sZW5ndGggPiAwID8gXG4gICAgICAgIHZhbGlkU3VwcGxpZXMucmVkdWNlKChzdW0sIGFzc2V0KSA9PiBzdW0gKyAoYXNzZXQuYXB5IHx8IDApLCAwKSAvIHZhbGlkU3VwcGxpZXMubGVuZ3RoIDogMDtcbiAgICAgIGNvbnN0IHRvdGFsVVNEQ29sbGF0ZXJhbCA9IHZhbGlkU3VwcGxpZXMucmVkdWNlKChzdW0sIGFzc2V0KSA9PiBzdW0gKyBhc3NldC5iYWxhbmNlVVNELCAwKTtcblxuICAgICAgc2V0U3VwcGx5U3VtbWFyeSh7XG4gICAgICAgIHRvdGFsVVNEQmFsYW5jZSxcbiAgICAgICAgd2VpZ2h0ZWRBdmdBUFksXG4gICAgICAgIHRvdGFsVVNEQ29sbGF0ZXJhbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZyhcIkdvdCB5b3VyIHN1cHBsaWVzOlwiLCB2YWxpZFN1cHBsaWVzKTtcbiAgICAgIHJldHVybiB2YWxpZFN1cHBsaWVzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyLCBtZXRhbWFza0RldGFpbHMuY3VycmVudEFjY291bnQsIGdldFByaWNlVVNEXSk7XG5cbiAgLy8gR2V0IHlvdXIgYm9ycm93c1xuICBjb25zdCBnZXRZb3VyQm9ycm93cyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIjQuIEdldHRpbmcgeW91ciBib3Jyb3dzLi4uXCIpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5wcm92aWRlciB8fCAhbWV0YW1hc2tEZXRhaWxzLmN1cnJlbnRBY2NvdW50KSByZXR1cm4gW107XG5cbiAgICAgIGNvbnN0IGFiaSA9IFtcbiAgICAgICAgJ2Z1bmN0aW9uIGdldFVzZXJSZXNlcnZlKGFkZHJlc3MgdXNlciwgYWRkcmVzcyBhc3NldCkgdmlldyByZXR1cm5zICh0dXBsZSh1aW50MTI4IHByaW5jaXBhbCx1aW50MTI4IGluZGV4KSBzdXBwbHksIHR1cGxlKHVpbnQxMjggcHJpbmNpcGFsLHVpbnQxMjggaW5kZXgpIGJvcnJvdyknXG4gICAgICBdO1xuICAgICAgY29uc3QgcG9vbCA9IG5ldyBldGhlcnMuQ29udHJhY3QoQ09ORklHLkxFTkRJTkdfUE9PTCwgYWJpLCBtZXRhbWFza0RldGFpbHMucHJvdmlkZXIpO1xuXG4gICAgICBjb25zdCBib3Jyb3dzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIENPTkZJRy5UT0tFTlMuZmlsdGVyKHQgPT4gIXQuaXNOYXRpdmUpLm1hcChhc3luYyAodG9rZW4pID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXNlclJlc2VydmUgPSBhd2FpdCBwb29sLmdldFVzZXJSZXNlcnZlKG1ldGFtYXNrRGV0YWlscy5jdXJyZW50QWNjb3VudCwgdG9rZW4uYWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBib3Jyb3dQcmluY2lwYWwgPSBldGhlcnMuZm9ybWF0VW5pdHModXNlclJlc2VydmUuYm9ycm93LnByaW5jaXBhbCwgMTgpO1xuICAgICAgICAgICAgY29uc3QgYm9ycm93SW5kZXggPSB1c2VyUmVzZXJ2ZS5ib3Jyb3cuaW5kZXgudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQoYm9ycm93UHJpbmNpcGFsKSA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgcHJpY2UgPSBhd2FpdCBnZXRQcmljZVVTRCh0b2tlbi5hZGRyZXNzKTtcbiAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZVVTRCA9IHBhcnNlRmxvYXQoYm9ycm93UHJpbmNpcGFsKSAqIHBhcnNlRmxvYXQocHJpY2UpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0b2tlbi5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIHN5bWJvbDogdG9rZW4uc3ltYm9sLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRva2VuLm5hbWUsXG4gICAgICAgICAgICAgICAgZGVjaW1hbHM6IHRva2VuLmRlY2ltYWxzLFxuICAgICAgICAgICAgICAgIGJvcnJvd1ByaW5jaXBhbDogYm9ycm93UHJpbmNpcGFsLFxuICAgICAgICAgICAgICAgIGJvcnJvd0luZGV4OiBib3Jyb3dJbmRleCxcbiAgICAgICAgICAgICAgICBiYWxhbmNlVVNEOiBiYWxhbmNlVVNELFxuICAgICAgICAgICAgICAgIHByaWNlVVNEOiBwcmljZSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEVycm9yIGdldHRpbmcgYm9ycm93IGZvciAke3Rva2VuLnN5bWJvbH06YCwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgY29uc3QgdmFsaWRCb3Jyb3dzID0gYm9ycm93cy5maWx0ZXIoYiA9PiBiICE9PSBudWxsKTtcbiAgICAgIHNldFlvdXJCb3Jyb3dzKHZhbGlkQm9ycm93cyk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBzdW1tYXJ5XG4gICAgICBjb25zdCB0b3RhbFVTREJhbGFuY2UgPSB2YWxpZEJvcnJvd3MucmVkdWNlKChzdW0sIGFzc2V0KSA9PiBzdW0gKyBhc3NldC5iYWxhbmNlVVNELCAwKTtcbiAgICAgIGNvbnN0IHdlaWdodGVkQXZnQVBZID0gdmFsaWRCb3Jyb3dzLmxlbmd0aCA+IDAgPyBcbiAgICAgICAgdmFsaWRCb3Jyb3dzLnJlZHVjZSgoc3VtLCBhc3NldCkgPT4gc3VtICsgKGFzc2V0LmFweSB8fCAwKSwgMCkgLyB2YWxpZEJvcnJvd3MubGVuZ3RoIDogMDtcbiAgICAgIGNvbnN0IHRvdGFsQm9ycm93UG93ZXJVc2VkID0gdG90YWxVU0RCYWxhbmNlO1xuXG4gICAgICBzZXRCb3Jyb3dTdW1tYXJ5KHtcbiAgICAgICAgdG90YWxVU0RCYWxhbmNlLFxuICAgICAgICB3ZWlnaHRlZEF2Z0FQWSxcbiAgICAgICAgdG90YWxCb3Jyb3dQb3dlclVzZWQsXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coXCJHb3QgeW91ciBib3Jyb3dzOlwiLCB2YWxpZEJvcnJvd3MpO1xuICAgICAgcmV0dXJuIHZhbGlkQm9ycm93cztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSwgW21ldGFtYXNrRGV0YWlscy5wcm92aWRlciwgbWV0YW1hc2tEZXRhaWxzLmN1cnJlbnRBY2NvdW50LCBnZXRQcmljZVVTRF0pO1xuXG4gIC8vIEdldCBhc3NldHMgdG8gYm9ycm93XG4gIGNvbnN0IGdldEFzc2V0c1RvQm9ycm93ID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiNS4gR2V0dGluZyBhc3NldHMgdG8gYm9ycm93Li4uXCIpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5wcm92aWRlcikgcmV0dXJuIFtdO1xuXG4gICAgICBjb25zdCBhYmkgPSBbXG4gICAgICAgICdmdW5jdGlvbiByZXNlcnZlcyhhZGRyZXNzKSB2aWV3IHJldHVybnMgKHVpbnQxMjggcmVzZXJ2ZUNhc2gsIHVpbnQxMjggdG90YWxEZWJ0UHJpbmNpcGFsLCB1aW50MTI4IGxpcXVpZGl0eUluZGV4LCB1aW50MTI4IHZhcmlhYmxlQm9ycm93SW5kZXgsIHVpbnQ2NCBsaXF1aWRpdHlSYXRlUmF5UGVyU2VjLCB1aW50NjQgdmFyaWFibGVCb3Jyb3dSYXRlUmF5UGVyU2VjLCB1aW50MTYgcmVzZXJ2ZUZhY3RvckJwcywgdWludDE2IGx0dkJwcywgdWludDE2IGxpcVRocmVzaG9sZEJwcywgdWludDE2IGxpcUJvbnVzQnBzLCB1aW50MTYgY2xvc2VGYWN0b3JCcHMsIHVpbnQ4IGRlY2ltYWxzLCBib29sIGlzQm9ycm93YWJsZSwgdWludDE2IG9wdGltYWxVQnBzLCB1aW50NjQgYmFzZVJhdGVSYXlQZXJTZWMsIHVpbnQ2NCBzbG9wZTFSYXlQZXJTZWMsIHVpbnQ2NCBzbG9wZTJSYXlQZXJTZWMsIHVpbnQ0MCBsYXN0VXBkYXRlKSdcbiAgICAgIF07XG4gICAgICBjb25zdCBwb29sID0gbmV3IGV0aGVycy5Db250cmFjdChDT05GSUcuTEVORElOR19QT09MLCBhYmksIG1ldGFtYXNrRGV0YWlscy5wcm92aWRlcik7XG5cbiAgICAgIGNvbnN0IGFzc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBDT05GSUcuVE9LRU5TLmZpbHRlcih0ID0+ICF0LmlzTmF0aXZlKS5tYXAoYXN5bmMgKHRva2VuKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc2VydmUgPSBhd2FpdCBwb29sLnJlc2VydmVzKHRva2VuLmFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgaXNCb3Jyb3dhYmxlID0gQm9vbGVhbihyZXNlcnZlLmlzQm9ycm93YWJsZSk7XG4gICAgICAgICAgICBjb25zdCByZXNlcnZlQ2FzaCA9IGV0aGVycy5mb3JtYXRVbml0cyhyZXNlcnZlLnJlc2VydmVDYXNoLCAxOCk7XG4gICAgICAgICAgICBjb25zdCBwcmljZSA9IGF3YWl0IGdldFByaWNlVVNEKHRva2VuLmFkZHJlc3MpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaXNCb3Jyb3dhYmxlICYmIHBhcnNlRmxvYXQocmVzZXJ2ZUNhc2gpID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRva2VuLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgc3ltYm9sOiB0b2tlbi5zeW1ib2wsXG4gICAgICAgICAgICAgICAgbmFtZTogdG9rZW4ubmFtZSxcbiAgICAgICAgICAgICAgICBkZWNpbWFsczogdG9rZW4uZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgcmVzZXJ2ZUNhc2g6IHJlc2VydmVDYXNoLFxuICAgICAgICAgICAgICAgIGlzQm9ycm93YWJsZTogaXNCb3Jyb3dhYmxlLFxuICAgICAgICAgICAgICAgIHByaWNlVVNEOiBwcmljZSxcbiAgICAgICAgICAgICAgICBsdHZCcHM6IE51bWJlcihyZXNlcnZlLmx0dkJwcyksXG4gICAgICAgICAgICAgICAgbGlxVGhyZXNob2xkQnBzOiBOdW1iZXIocmVzZXJ2ZS5saXFUaHJlc2hvbGRCcHMpLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRXJyb3IgZ2V0dGluZyBib3Jyb3cgYXNzZXQgJHt0b2tlbi5zeW1ib2x9OmAsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHZhbGlkQXNzZXRzID0gYXNzZXRzLmZpbHRlcihhID0+IGEgIT09IG51bGwpO1xuICAgICAgc2V0QXNzZXRzVG9Cb3Jyb3codmFsaWRBc3NldHMpO1xuICAgICAgY29uc29sZS5sb2coXCJHb3QgYXNzZXRzIHRvIGJvcnJvdzpcIiwgdmFsaWRBc3NldHMpO1xuICAgICAgcmV0dXJuIHZhbGlkQXNzZXRzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyLCBnZXRQcmljZVVTRF0pO1xuXG4gIC8vIFdyYXAgRVRIIHRvIFdFVEhcbiAgY29uc3Qgd3JhcEV0aCA9IHVzZUNhbGxiYWNrKGFzeW5jIChhbW91bnRFdGgpID0+IHtcbiAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5zaWduZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSAnMHhkMGUzMGRiMCc7IC8vIGRlcG9zaXQoKVxuICAgICAgY29uc3QgdHggPSBhd2FpdCBtZXRhbWFza0RldGFpbHMuc2lnbmVyLnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgIHRvOiBDT05GSUcuV0VUSCxcbiAgICAgICAgdmFsdWU6IGV0aGVycy5wYXJzZUV0aGVyKGFtb3VudEV0aCksXG4gICAgICAgIGRhdGFcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgdHgud2FpdCgpO1xuICAgICAgY29uc29sZS5sb2coXCJFVEggd3JhcHBlZCB0byBXRVRIOlwiLCBhbW91bnRFdGgpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiAyMDAsIG1lc3NhZ2U6IFwiVHJhbnNhY3Rpb24gU3VjY2Vzc2Z1bC4uLlwiLCBoYXNoOiB0eC5oYXNoIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydEVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogNTAwLCBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8IGVycm9yLnJlYXNvbiB9O1xuICAgIH1cbiAgfSwgW21ldGFtYXNrRGV0YWlscy5zaWduZXJdKTtcblxuICAvLyBVbndyYXAgV0VUSCB0byBFVEhcbiAgY29uc3QgdW53cmFwV2V0aCA9IHVzZUNhbGxiYWNrKGFzeW5jIChhbW91bnRFdGgpID0+IHtcbiAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5zaWduZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFiaSA9IFsnZnVuY3Rpb24gd2l0aGRyYXcodWludDI1NiB3YWQpJ107XG4gICAgICBjb25zdCB3ZXRoID0gbmV3IGV0aGVycy5Db250cmFjdChDT05GSUcuV0VUSCwgYWJpLCBtZXRhbWFza0RldGFpbHMuc2lnbmVyKTtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgd2V0aC53aXRoZHJhdyhldGhlcnMucGFyc2VFdGhlcihhbW91bnRFdGgpKTtcbiAgICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiV0VUSCB1bndyYXBwZWQgdG8gRVRIOlwiLCBhbW91bnRFdGgpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiAyMDAsIG1lc3NhZ2U6IFwiVHJhbnNhY3Rpb24gU3VjY2Vzc2Z1bC4uLlwiLCBoYXNoOiB0eC5oYXNoIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydEVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogNTAwLCBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8IGVycm9yLnJlYXNvbiB9O1xuICAgIH1cbiAgfSwgW21ldGFtYXNrRGV0YWlscy5zaWduZXJdKTtcblxuICAvLyBSZWZyZXNoIGFsbCBkYXRhXG4gIGNvbnN0IHJlZnJlc2ggPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2V0VXNlckFzc2V0cygpLFxuICAgICAgICBnZXRZb3VyU3VwcGxpZXMoKSxcbiAgICAgICAgZ2V0WW91ckJvcnJvd3MoKSxcbiAgICAgICAgZ2V0QXNzZXRzVG9Cb3Jyb3coKSxcbiAgICAgICAgZ2V0QWNjb3VudERhdGEoKSxcbiAgICAgIF0pO1xuICAgICAgY29uc29sZS5sb2coXCJBbGwgZGF0YSByZWZyZXNoZWRcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydEVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0sIFtnZXRVc2VyQXNzZXRzLCBnZXRZb3VyU3VwcGxpZXMsIGdldFlvdXJCb3Jyb3dzLCBnZXRBc3NldHNUb0JvcnJvdywgZ2V0QWNjb3VudERhdGFdKTtcblxuICAvLyBVcGRhdGUgaW50ZXJlc3RzIChhY2NydWUpXG4gIGNvbnN0IHVwZGF0ZUludGVyZXN0cyA9IHVzZUNhbGxiYWNrKGFzeW5jIChhc3NldCkgPT4ge1xuICAgIGlmICghbWV0YW1hc2tEZXRhaWxzLnNpZ25lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmVyIGF2YWlsYWJsZVwiKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYWJpID0gWydmdW5jdGlvbiBhY2NydWVQdWJsaWMoYWRkcmVzcyBhc3NldCknXTtcbiAgICAgIGNvbnN0IHBvb2wgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KENPTkZJRy5MRU5ESU5HX1BPT0wsIGFiaSwgbWV0YW1hc2tEZXRhaWxzLnNpZ25lcik7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IHBvb2wuYWNjcnVlUHVibGljKGFzc2V0KTtcbiAgICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiSW50ZXJlc3RzIHVwZGF0ZWQgZm9yIGFzc2V0OlwiLCBhc3NldCk7XG4gICAgICByZXR1cm4geyBzdGF0dXM6IDIwMCwgbWVzc2FnZTogXCJUcmFuc2FjdGlvbiBTdWNjZXNzZnVsLi4uXCIgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiA1MDAsIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IucmVhc29uIH07XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnNpZ25lcl0pO1xuXG4gIC8vIEdldCB1c2VyIHRvdGFsIGF2YWlsYWJsZSBiYWxhbmNlXG4gIGNvbnN0IGdldFVzZXJUb3RhbEF2YWlsYWJsZUJhbGFuY2UgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyIHx8ICFtZXRhbWFza0RldGFpbHMuY3VycmVudEFjY291bnQpIHJldHVybiAwO1xuXG4gICAgICBjb25zdCBhYmkgPSBbXG4gICAgICAgICdmdW5jdGlvbiBnZXRVc2VyVG90YWxBdmFpbGFibGVCYWxhbmNlSW5VU0QoYWRkcmVzcyB1c2VyLCB1aW50MjU2IGFzc2V0VHlwZSkgdmlldyByZXR1cm5zICh1aW50MjU2KSdcbiAgICAgIF07XG4gICAgICBjb25zdCBwb29sID0gbmV3IGV0aGVycy5Db250cmFjdChDT05GSUcuTEVORElOR19QT09MLCBhYmksIG1ldGFtYXNrRGV0YWlscy5wcm92aWRlcik7XG4gICAgICBjb25zdCBtYXhBbW91bnQgPSBhd2FpdCBwb29sLmdldFVzZXJUb3RhbEF2YWlsYWJsZUJhbGFuY2VJblVTRChtZXRhbWFza0RldGFpbHMuY3VycmVudEFjY291bnQsIDEpO1xuICAgICAgcmV0dXJuIE51bWJlcihldGhlcnMuZm9ybWF0VW5pdHMobWF4QW1vdW50LCAxOCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sIFttZXRhbWFza0RldGFpbHMucHJvdmlkZXIsIG1ldGFtYXNrRGV0YWlscy5jdXJyZW50QWNjb3VudF0pO1xuXG4gIC8vIEdldCB0b2tlbnMgcGVyIFVTRCBhbW91bnRcbiAgY29uc3QgZ2V0VG9rZW5zUGVyVVNEQW1vdW50ID0gdXNlQ2FsbGJhY2soYXN5bmMgKHRva2VuLCBhbW91bnQpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFtZXRhbWFza0RldGFpbHMucHJvdmlkZXIpIHJldHVybiAwO1xuXG4gICAgICBjb25zdCBhYmkgPSBbXG4gICAgICAgICdmdW5jdGlvbiBnZXRUb2tlbnNQZXJVU0RBbW91bnQoYWRkcmVzcyB0b2tlbiwgdWludDI1NiBhbW91bnQpIHZpZXcgcmV0dXJucyAodWludDI1NiknXG4gICAgICBdO1xuICAgICAgY29uc3QgaGVscGVyID0gbmV3IGV0aGVycy5Db250cmFjdChDT05GSUcuUFJJQ0VfT1JBQ0xFLCBhYmksIG1ldGFtYXNrRGV0YWlscy5wcm92aWRlcik7XG4gICAgICBjb25zdCBtYXhRdHkgPSBhd2FpdCBoZWxwZXIuZ2V0VG9rZW5zUGVyVVNEQW1vdW50KHRva2VuLCBldGhlcnMucGFyc2VVbml0cyhhbW91bnQudG9TdHJpbmcoKSwgMTgpKTtcbiAgICAgIHJldHVybiBOdW1iZXIoZXRoZXJzLmZvcm1hdFVuaXRzKG1heFF0eSwgMTgpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyXSk7XG5cbiAgLy8gT2JqZWN0aWZ5IHN1cHBsaWVkIGFzc2V0cyAoZm9ybWF0IGRhdGEpXG4gIGNvbnN0IG9iamVjdGlmeVN1cHBsaWVkQXNzZXRzID0gdXNlQ2FsbGJhY2soYXN5bmMgKGFzc2V0cykgPT4ge1xuICAgIGNvbnN0IGFzc2V0c0xpc3QgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdG9rZW4gPSBhc3NldHNbaV0udG9rZW47XG4gICAgICBsZXQgbGVuZFF0eSA9IGFzc2V0c1tpXS5sZW50UXR5O1xuXG4gICAgICBjb25zdCBhbW91bnRJblVTRCA9IGF3YWl0IGdldEFtb3VudEluVVNEKHRva2VuLCBsZW5kUXR5KTtcbiAgICAgIGxlbmRRdHkgPSBOdW1iZXIoYXNzZXRzW2ldLmxlbnRRdHkpIC8gMWUxODtcblxuICAgICAgY29uc3QgbWF4U3VwcGx5QW1vdW50ID0gYXdhaXQgZ2V0VXNlclRvdGFsQXZhaWxhYmxlQmFsYW5jZSgpO1xuICAgICAgY29uc3QgbWF4UXR5ID0gYXdhaXQgZ2V0VG9rZW5zUGVyVVNEQW1vdW50KHRva2VuLCBtYXhTdXBwbHlBbW91bnQpO1xuICAgICAgY29uc3QgcXR5ID0gbGVuZFF0eSA8PSBtYXhRdHkgPyBsZW5kUXR5IDogbWF4UXR5O1xuXG4gICAgICBhc3NldHNMaXN0LnB1c2goe1xuICAgICAgICB0b2tlbjogYXNzZXRzW2ldLnRva2VuLFxuICAgICAgICBiYWxhbmNlOiBsZW5kUXR5LFxuICAgICAgICBhcHk6IE51bWJlcihhc3NldHNbaV0ubGVudEFweSksXG4gICAgICAgIGJhbGFuY2VJblVTRDogYW1vdW50SW5VU0QsXG4gICAgICAgIG1heFN1cHBseTogcXR5LFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhc3NldHNMaXN0O1xuICB9LCBbZ2V0QW1vdW50SW5VU0QsIGdldFVzZXJUb3RhbEF2YWlsYWJsZUJhbGFuY2UsIGdldFRva2Vuc1BlclVTREFtb3VudF0pO1xuXG4gIC8vIE9iamVjdGlmeSBib3Jyb3dlZCBhc3NldHMgKGZvcm1hdCBkYXRhKVxuICBjb25zdCBvYmplY3RpZnlCb3Jyb3dlZEFzc2V0cyA9IHVzZUNhbGxiYWNrKGFzeW5jIChhc3NldHMpID0+IHtcbiAgICBjb25zdCBib3Jyb3dzTGlzdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXNzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IGFzc2V0c1tpXS50b2tlbjtcbiAgICAgIGNvbnN0IGJvcnJvd1F0eSA9IGFzc2V0c1tpXS5ib3Jyb3dRdHk7XG4gICAgICBjb25zdCBib3Jyb3dBcHkgPSBhc3NldHNbaV0uYm9ycm93QXB5O1xuICAgICAgY29uc3QgYW1vdW50SW5VU0QgPSBhd2FpdCBnZXRBbW91bnRJblVTRCh0b2tlbiwgYm9ycm93UXR5KTtcbiAgICAgIFxuICAgICAgYm9ycm93c0xpc3QucHVzaCh7XG4gICAgICAgIHRva2VuOiB0b2tlbixcbiAgICAgICAgYm9ycm93UXR5OiBOdW1iZXIoYm9ycm93UXR5KSxcbiAgICAgICAgYm9ycm93QXB5OiBOdW1iZXIoYm9ycm93QXB5KSxcbiAgICAgICAgYm9ycm93ZWRCYWxJblVTRDogYW1vdW50SW5VU0QsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGJvcnJvd3NMaXN0O1xuICB9LCBbZ2V0QW1vdW50SW5VU0RdKTtcblxuICAvLyBNZXJnZSBvYmplY3RpZmllZCBhc3NldHMgd2l0aCB0b2tlbiBpbmZvXG4gIGNvbnN0IG1lcmdlT2JqZWN0aWZpZWRBc3NldHMgPSB1c2VDYWxsYmFjaygoYXNzZXRzKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gQ09ORklHLlRPS0VOU1xuICAgICAgLmZpbHRlcigodG9rZW5MaXN0KSA9PiB7XG4gICAgICAgIHJldHVybiBhc3NldHMuc29tZSgoYXNzZXRMaXN0KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuTGlzdC5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFzc2V0TGlzdC50b2tlbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAubWFwKChhc3NldE9iaikgPT4gKHtcbiAgICAgICAgLi4uYXNzZXRzLmZpbmQoKGl0ZW0pID0+IGl0ZW0udG9rZW4udG9Mb3dlckNhc2UoKSA9PT0gYXNzZXRPYmouYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSxcbiAgICAgICAgLi4uYXNzZXRPYmosXG4gICAgICB9KSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgW10pO1xuXG4gIC8vIENvbnRleHQgdmFsdWVcbiAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIC8vIFN0YXRlXG4gICAgbWV0YW1hc2tEZXRhaWxzLFxuICAgIHVzZXJBc3NldHMsXG4gICAgc3VwcGx5QXNzZXRzLFxuICAgIGFzc2V0c1RvQm9ycm93LFxuICAgIHlvdXJCb3Jyb3dzLFxuICAgIHN1cHBseVN1bW1hcnksXG4gICAgYm9ycm93U3VtbWFyeSxcbiAgICBhY2NvdW50RGF0YSxcbiAgICBjb250cmFjdCxcblxuICAgIC8vIFdhbGxldCBmdW5jdGlvbnNcbiAgICBjb25uZWN0V2FsbGV0LFxuICAgIHJlZnJlc2gsXG5cbiAgICAvLyBBc3NldCBmdW5jdGlvbnNcbiAgICBnZXRVc2VyQXNzZXRzLFxuICAgIGdldFlvdXJTdXBwbGllcyxcbiAgICBnZXRZb3VyQm9ycm93cyxcbiAgICBnZXRBc3NldHNUb0JvcnJvdyxcblxuICAgIC8vIFRyYW5zYWN0aW9uIGZ1bmN0aW9uc1xuICAgIEFwcHJvdmVUb0NvbnRpbnVlLFxuICAgIExlbmRBc3NldCxcbiAgICBXaXRoZHJhd0Fzc2V0LFxuICAgIGJvcnJvd0Fzc2V0LFxuICAgIHJlcGF5QXNzZXQsXG5cbiAgICAvLyBVdGlsaXR5IGZ1bmN0aW9uc1xuICAgIGdldENvbnRyYWN0LFxuICAgIGdldFByaWNlVVNELFxuICAgIGdldEFtb3VudEluVVNELFxuICAgIG51bWJlclRvRXRoZXJzLFxuICAgIHJlcG9ydEVycm9yLFxuXG4gICAgLy8gRVRIL1dFVEggZnVuY3Rpb25zXG4gICAgd3JhcEV0aCxcbiAgICB1bndyYXBXZXRoLFxuXG4gICAgLy8gQWNjb3VudCBmdW5jdGlvbnNcbiAgICBnZXRBY2NvdW50RGF0YSxcbiAgICBnZXRVc2VyVG90YWxBdmFpbGFibGVCYWxhbmNlLFxuICAgIGdldFRva2Vuc1BlclVTREFtb3VudCxcblxuICAgIC8vIERhdGEgcHJvY2Vzc2luZyBmdW5jdGlvbnNcbiAgICBvYmplY3RpZnlTdXBwbGllZEFzc2V0cyxcbiAgICBvYmplY3RpZnlCb3Jyb3dlZEFzc2V0cyxcbiAgICBtZXJnZU9iamVjdGlmaWVkQXNzZXRzLFxuXG4gICAgLy8gSW50ZXJlc3QgZnVuY3Rpb25zXG4gICAgdXBkYXRlSW50ZXJlc3RzLFxuICB9KSwgW1xuICAgIG1ldGFtYXNrRGV0YWlscyxcbiAgICB1c2VyQXNzZXRzLFxuICAgIHN1cHBseUFzc2V0cyxcbiAgICBhc3NldHNUb0JvcnJvdyxcbiAgICB5b3VyQm9ycm93cyxcbiAgICBzdXBwbHlTdW1tYXJ5LFxuICAgIGJvcnJvd1N1bW1hcnksXG4gICAgYWNjb3VudERhdGEsXG4gICAgY29udHJhY3QsXG4gICAgY29ubmVjdFdhbGxldCxcbiAgICByZWZyZXNoLFxuICAgIGdldFVzZXJBc3NldHMsXG4gICAgZ2V0WW91clN1cHBsaWVzLFxuICAgIGdldFlvdXJCb3Jyb3dzLFxuICAgIGdldEFzc2V0c1RvQm9ycm93LFxuICAgIEFwcHJvdmVUb0NvbnRpbnVlLFxuICAgIExlbmRBc3NldCxcbiAgICBXaXRoZHJhd0Fzc2V0LFxuICAgIGJvcnJvd0Fzc2V0LFxuICAgIHJlcGF5QXNzZXQsXG4gICAgZ2V0Q29udHJhY3QsXG4gICAgZ2V0UHJpY2VVU0QsXG4gICAgZ2V0QW1vdW50SW5VU0QsXG4gICAgd3JhcEV0aCxcbiAgICB1bndyYXBXZXRoLFxuICAgIGdldEFjY291bnREYXRhLFxuICAgIGdldFVzZXJUb3RhbEF2YWlsYWJsZUJhbGFuY2UsXG4gICAgZ2V0VG9rZW5zUGVyVVNEQW1vdW50LFxuICAgIG9iamVjdGlmeVN1cHBsaWVkQXNzZXRzLFxuICAgIG9iamVjdGlmeUJvcnJvd2VkQXNzZXRzLFxuICAgIG1lcmdlT2JqZWN0aWZpZWRBc3NldHMsXG4gICAgdXBkYXRlSW50ZXJlc3RzLFxuICBdKTtcblxuICByZXR1cm4gKFxuICAgIDxsZW5kQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dFZhbHVlfT5cbiAgICAgIHtwcm9wcy5jaGlsZHJlbn1cbiAgICA8L2xlbmRDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTGVuZFN0YXRlO1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZU1lbW8iLCJsZW5kQ29udGV4dCIsImV0aGVycyIsIkNPTkZJRyIsImdldFRva2VuQmFsYW5jZSIsImdldFRva2VuQWxsb3dhbmNlIiwiYXBwcm92ZUlmTmVlZGVkIiwibGVuZCIsImxlbmRUeCIsIndpdGhkcmF3Iiwid2l0aGRyYXdUeCIsImJvcnJvdyIsImJvcnJvd1R4IiwicmVwYXkiLCJyZXBheVR4IiwiRVRIQWRkcmVzcyIsIkxlbmRpbmdQb29sQWRkcmVzcyIsIkxlbmRpbmdIZWxwZXJBZGRyZXNzIiwiVG9rZW5BQkkiLCJMZW5kaW5nUG9vbEFCSSIsIkxlbmRpbmdIZWxwZXJBQkkiLCJudW1iZXJUb0V0aGVycyIsIm51bWJlciIsInBhcnNlRXRoZXIiLCJ0b1N0cmluZyIsInJlcG9ydEVycm9yIiwiZXJyb3IiLCJjb25zb2xlIiwiSlNPTiIsInN0cmluZ2lmeSIsIkxlbmRTdGF0ZSIsInByb3BzIiwibWV0YW1hc2tEZXRhaWxzIiwic2V0TWV0YW1hc2tEZXRhaWxzIiwicHJvdmlkZXIiLCJuZXR3b3JrTmFtZSIsInNpZ25lciIsImN1cnJlbnRBY2NvdW50IiwiY2hhaW5JZCIsInVzZXJBc3NldHMiLCJzZXRVc2VyQXNzZXRzIiwic3VwcGx5QXNzZXRzIiwic2V0U3VwcGx5QXNzZXRzIiwiYXNzZXRzVG9Cb3Jyb3ciLCJzZXRBc3NldHNUb0JvcnJvdyIsInlvdXJCb3Jyb3dzIiwic2V0WW91ckJvcnJvd3MiLCJjb250cmFjdCIsInNldENvbnRyYWN0IiwibGVuZGluZ1Bvb2xDb250cmFjdCIsIm9yYWNsZUNvbnRyYWN0Iiwic3VwcGx5U3VtbWFyeSIsInNldFN1cHBseVN1bW1hcnkiLCJ0b3RhbFVTREJhbGFuY2UiLCJ3ZWlnaHRlZEF2Z0FQWSIsInRvdGFsVVNEQ29sbGF0ZXJhbCIsImJvcnJvd1N1bW1hcnkiLCJzZXRCb3Jyb3dTdW1tYXJ5IiwidG90YWxCb3Jyb3dQb3dlclVzZWQiLCJhY2NvdW50RGF0YSIsInNldEFjY291bnREYXRhIiwiY29sbGF0ZXJhbFVTRCIsImRlYnRVU0QiLCJoZWFsdGhGYWN0b3IiLCJjb25uZWN0V2FsbGV0IiwibG9nIiwiZXRoZXJldW0iLCJ3aW5kb3ciLCJmYWlsTWVzc2FnZSIsImFsZXJ0IiwiYWNjb3VudHMiLCJyZXF1ZXN0IiwibWV0aG9kIiwib24iLCJsb2NhdGlvbiIsInJlbG9hZCIsIkJyb3dzZXJQcm92aWRlciIsIm5ldHdvcmsiLCJnZXROZXR3b3JrIiwibmFtZSIsImdldFNpZ25lciIsImxlbmd0aCIsImN1cnJlbnRBZGRyZXNzIiwiTnVtYmVyIiwiZ2V0Q29udHJhY3QiLCJhZGRyZXNzIiwiYWJpIiwiQ29udHJhY3QiLCJnZXRVc2VyQXNzZXRzIiwiYXNzZXRzIiwiUHJvbWlzZSIsImFsbCIsIlRPS0VOUyIsIm1hcCIsInRva2VuIiwiYmFsYW5jZSIsImJhbGFuY2VVU0QiLCJpc05hdGl2ZSIsImJhbCIsImdldEJhbGFuY2UiLCJmb3JtYXRFdGhlciIsImRlY2ltYWxzIiwicHJpY2UiLCJnZXRQcmljZVVTRCIsInBhcnNlRmxvYXQiLCJzeW1ib2wiLCJwcmljZVVTRCIsIndhcm4iLCJhc3NldCIsIm9yYWNsZSIsIlBSSUNFX09SQUNMRSIsImdldEFzc2V0UHJpY2UxZTE4IiwiZm9ybWF0VW5pdHMiLCJnZXRBbW91bnRJblVTRCIsImFtb3VudCIsImFtb3VudEluVVNEIiwiQXBwcm92ZVRvQ29udGludWUiLCJ0b2tlbkFkZHJlc3MiLCJhcHByb3ZlQW1vdW50IiwiRXJyb3IiLCJmaW5kIiwidCIsInRvTG93ZXJDYXNlIiwiTEVORElOR19QT09MIiwic3RhdHVzIiwibWVzc2FnZSIsInJlYXNvbiIsIkxlbmRBc3NldCIsInN1cHBseUFtb3VudCIsInRva2VuSW5mbyIsInBhcnNlVW5pdHMiLCJ0eCIsImhhc2giLCJXaXRoZHJhd0Fzc2V0Iiwid2l0aGRyYXdBbW91bnQiLCJib3Jyb3dBc3NldCIsImJvcnJvd0Ftb3VudCIsInJlcGF5QXNzZXQiLCJyZXBheUFtb3VudCIsImdldEFjY291bnREYXRhIiwidXNlciIsInBvb2wiLCJ3YWxsZXQiLCJaZXJvQWRkcmVzcyIsImNvbCIsImRlYnQiLCJoZiIsImdldFlvdXJTdXBwbGllcyIsInN1cHBsaWVzIiwiZmlsdGVyIiwidXNlclJlc2VydmUiLCJnZXRVc2VyUmVzZXJ2ZSIsInN1cHBseVByaW5jaXBhbCIsInN1cHBseSIsInByaW5jaXBhbCIsInN1cHBseUluZGV4IiwiaW5kZXgiLCJ2YWxpZFN1cHBsaWVzIiwicyIsInJlZHVjZSIsInN1bSIsImFweSIsImdldFlvdXJCb3Jyb3dzIiwiYm9ycm93cyIsImJvcnJvd1ByaW5jaXBhbCIsImJvcnJvd0luZGV4IiwidmFsaWRCb3Jyb3dzIiwiYiIsImdldEFzc2V0c1RvQm9ycm93IiwicmVzZXJ2ZSIsInJlc2VydmVzIiwiaXNCb3Jyb3dhYmxlIiwiQm9vbGVhbiIsInJlc2VydmVDYXNoIiwibHR2QnBzIiwibGlxVGhyZXNob2xkQnBzIiwidmFsaWRBc3NldHMiLCJhIiwid3JhcEV0aCIsImFtb3VudEV0aCIsImRhdGEiLCJzZW5kVHJhbnNhY3Rpb24iLCJ0byIsIldFVEgiLCJ2YWx1ZSIsIndhaXQiLCJ1bndyYXBXZXRoIiwid2V0aCIsInJlZnJlc2giLCJ1cGRhdGVJbnRlcmVzdHMiLCJhY2NydWVQdWJsaWMiLCJnZXRVc2VyVG90YWxBdmFpbGFibGVCYWxhbmNlIiwibWF4QW1vdW50IiwiZ2V0VXNlclRvdGFsQXZhaWxhYmxlQmFsYW5jZUluVVNEIiwiZ2V0VG9rZW5zUGVyVVNEQW1vdW50IiwiaGVscGVyIiwibWF4UXR5Iiwib2JqZWN0aWZ5U3VwcGxpZWRBc3NldHMiLCJhc3NldHNMaXN0IiwiaSIsImxlbmRRdHkiLCJsZW50UXR5IiwibWF4U3VwcGx5QW1vdW50IiwicXR5IiwicHVzaCIsImxlbnRBcHkiLCJiYWxhbmNlSW5VU0QiLCJtYXhTdXBwbHkiLCJvYmplY3RpZnlCb3Jyb3dlZEFzc2V0cyIsImJvcnJvd3NMaXN0IiwiYm9ycm93UXR5IiwiYm9ycm93QXB5IiwiYm9ycm93ZWRCYWxJblVTRCIsIm1lcmdlT2JqZWN0aWZpZWRBc3NldHMiLCJyZXN1bHQiLCJ0b2tlbkxpc3QiLCJzb21lIiwiYXNzZXRMaXN0IiwiYXNzZXRPYmoiLCJpdGVtIiwiY29udGV4dFZhbHVlIiwiUHJvdmlkZXIiLCJjaGlsZHJlbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/context/LendState.js\n"));

/***/ })

});