"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./src/context/LendState.js":
/*!**********************************!*\
  !*** ./src/context/LendState.js ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lendContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lendContext */ \"(pages-dir-browser)/./src/context/lendContext.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(pages-dir-browser)/./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _config_contracts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config/contracts */ \"(pages-dir-browser)/./src/config/contracts.ts\");\n/* harmony import */ var _lib_tx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/tx */ \"(pages-dir-browser)/./src/lib/tx.ts\");\n/* harmony import */ var _addresses__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../addresses */ \"(pages-dir-browser)/./src/addresses.js\");\n/* harmony import */ var _abis__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../abis */ \"(pages-dir-browser)/./src/abis/index.js\");\n/* harmony import */ var _abis__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_abis__WEBPACK_IMPORTED_MODULE_6__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n// Utility functions\nconst numberToEthers = (number)=>{\n    return ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseEther(number.toString());\n};\nconst reportError = (error)=>{\n    console.error(\"LendState Error:\", JSON.stringify(error));\n    console.error(\"Error details:\", error);\n};\nconst LendState = (props)=>{\n    _s();\n    //* Declaring all the states\n    // Set metamask details\n    const [metamaskDetails, setMetamaskDetails] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        provider: null,\n        networkName: null,\n        signer: null,\n        currentAccount: null,\n        chainId: null\n    });\n    // User assets and balances\n    const [userAssets, setUserAssets] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [supplyAssets, setSupplyAssets] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [assetsToBorrow, setAssetsToBorrow] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [yourBorrows, setYourBorrows] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Contract details\n    const [contract, setContract] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        lendingPoolContract: null,\n        oracleContract: null\n    });\n    // Summary data\n    const [supplySummary, setSupplySummary] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        totalUSDBalance: 0,\n        weightedAvgAPY: 0,\n        totalUSDCollateral: 0\n    });\n    const [borrowSummary, setBorrowSummary] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        totalUSDBalance: 0,\n        weightedAvgAPY: 0,\n        totalBorrowPowerUsed: 0\n    });\n    // Account data\n    const [accountData, setAccountData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        collateralUSD: \"0\",\n        debtUSD: \"0\",\n        healthFactor: \"0\"\n    });\n    // Connect wallet\n    // const connectWallet = useCallback(async () => {\n    //   console.log(\"1. Connecting to wallet...\");\n    //   const { ethereum } = window;\n    //   const failMessage = \"Please install Metamask & connect your Metamask\";\n    //   try {\n    //     if (!ethereum) {\n    //       alert(failMessage);\n    //       return;\n    //     }\n    //     const accounts = await ethereum.request({\n    //       method: \"eth_requestAccounts\",\n    //     });\n    //     // Listen for account and chain changes\n    //     ethereum.on(\"chainChanged\", () => {\n    //       window.location.reload();\n    //     });\n    //     ethereum.on(\"accountsChanged\", () => {\n    //       window.location.reload();\n    //     });\n    //     const provider = new ethers.BrowserProvider(ethereum);\n    //     const network = await provider.getNetwork();\n    //     const networkName = network.name;\n    //     const signer = await provider.getSigner();\n    //     if (accounts.length) {\n    //       let currentAddress = accounts[0];\n    //       setMetamaskDetails({\n    //         provider: provider,\n    //         networkName: networkName,\n    //         signer: signer,\n    //         currentAccount: currentAddress,\n    //         chainId: Number(network.chainId),\n    //       });\n    //       console.log(\"Connected to wallet:\", currentAddress);\n    //     } else {\n    //       alert(failMessage);\n    //       return;\n    //     }\n    //   } catch (error) {\n    //     reportError(error);\n    //   }\n    // }, []);\n    const connectWallet = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[connectWallet]\": async ()=>{\n            console.log(\"1. Connecting to wallet...\");\n            const { ethereum } = window;\n            const failMessage = \"Please install Metamask & connect your Metamask\";\n            try {\n                if (!ethereum) {\n                    alert(failMessage);\n                    return;\n                }\n                const accounts = await ethereum.request({\n                    method: \"eth_requestAccounts\"\n                });\n                // Listen for account and chain changes\n                ethereum.on(\"chainChanged\", {\n                    \"LendState.useCallback[connectWallet]\": ()=>{\n                        window.location.reload();\n                    }\n                }[\"LendState.useCallback[connectWallet]\"]);\n                ethereum.on(\"accountsChanged\", {\n                    \"LendState.useCallback[connectWallet]\": ()=>{\n                        window.location.reload();\n                    }\n                }[\"LendState.useCallback[connectWallet]\"]);\n                const provider = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.BrowserProvider(ethereum);\n                const network = await provider.getNetwork();\n                const networkName = network.name;\n                const signer = await provider.getSigner();\n                if (accounts.length) {\n                    let currentAddress = accounts[0];\n                    setMetamaskDetails({\n                        provider: provider,\n                        networkName: networkName,\n                        signer: signer,\n                        currentAccount: currentAddress,\n                        chainId: Number(network.chainId)\n                    });\n                    console.log(\"Connected to wallet++++++++++++++++++++++++++++++++++:\", currentAddress);\n                } else {\n                    alert(failMessage);\n                    return;\n                }\n            } catch (error) {\n                reportError(error);\n            }\n        }\n    }[\"LendState.useCallback[connectWallet]\"], []);\n    // Get contract instance\n    const getContract = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getContract]\": async (address, abi)=>{\n            if (!metamaskDetails.provider) return null;\n            const contract = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(address, abi, metamaskDetails.provider);\n            return contract;\n        }\n    }[\"LendState.useCallback[getContract]\"], [\n        metamaskDetails.provider\n    ]);\n    // Get user assets (balances)\n    const getUserAssets = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getUserAssets]\": async ()=>{\n            console.log(\"2. Getting user assets...\");\n            try {\n                if (!metamaskDetails.provider || !metamaskDetails.currentAccount) return [];\n                const assets = await Promise.all(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.map({\n                    \"LendState.useCallback[getUserAssets]\": async (token)=>{\n                        let balance = \"0\";\n                        let balanceUSD = 0;\n                        try {\n                            if (token.isNative) {\n                                // ETH native balance\n                                const bal = await metamaskDetails.provider.getBalance(metamaskDetails.currentAccount);\n                                balance = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatEther(bal);\n                            } else {\n                                // ERC20 token balance\n                                balance = await (0,_lib_tx__WEBPACK_IMPORTED_MODULE_4__.getTokenBalance)(metamaskDetails.provider, token.address, metamaskDetails.currentAccount, token.decimals);\n                            }\n                            // Get USD value\n                            const price = await getPriceUSD(token.address);\n                            balanceUSD = parseFloat(balance) * parseFloat(price);\n                            return {\n                                address: token.address,\n                                symbol: token.symbol,\n                                name: token.name,\n                                decimals: token.decimals,\n                                isNative: token.isNative,\n                                balance: balance,\n                                balanceUSD: balanceUSD,\n                                priceUSD: price\n                            };\n                        } catch (error) {\n                            console.warn(\"Error getting balance for \".concat(token.symbol, \":\"), error);\n                            return {\n                                address: token.address,\n                                symbol: token.symbol,\n                                name: token.name,\n                                decimals: token.decimals,\n                                isNative: token.isNative,\n                                balance: \"0\",\n                                balanceUSD: 0,\n                                priceUSD: \"0\"\n                            };\n                        }\n                    }\n                }[\"LendState.useCallback[getUserAssets]\"]));\n                setUserAssets(assets);\n                console.log(\"Got user assets:\", assets);\n                return assets;\n            } catch (error) {\n                reportError(error);\n                return [];\n            }\n        }\n    }[\"LendState.useCallback[getUserAssets]\"], [\n        metamaskDetails.provider,\n        metamaskDetails.currentAccount\n    ]);\n    // Get price in USD\n    const getPriceUSD = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getPriceUSD]\": async (asset)=>{\n            if (!metamaskDetails.provider) return \"0\";\n            try {\n                const abi = [\n                    'function getAssetPrice1e18(address asset) view returns (uint256)'\n                ];\n                const oracle = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.PRICE_ORACLE, abi, metamaskDetails.provider);\n                const price = await oracle.getAssetPrice1e18(asset);\n                return ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(price, 18);\n            } catch (error) {\n                console.warn(\"Error getting price for \".concat(asset, \":\"), error);\n                return \"0\";\n            }\n        }\n    }[\"LendState.useCallback[getPriceUSD]\"], [\n        metamaskDetails.provider\n    ]);\n    // Get amount in USD\n    const getAmountInUSD = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getAmountInUSD]\": async (address, amount)=>{\n            try {\n                const price = await getPriceUSD(address);\n                const amountInUSD = parseFloat(amount) * parseFloat(price);\n                return amountInUSD;\n            } catch (error) {\n                reportError(error);\n                return 0;\n            }\n        }\n    }[\"LendState.useCallback[getAmountInUSD]\"], [\n        getPriceUSD\n    ]);\n    // Approve tokens\n    const ApproveToContinue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[ApproveToContinue]\": async (tokenAddress, approveAmount)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const token = _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.find({\n                    \"LendState.useCallback[ApproveToContinue].token\": (t)=>t.address.toLowerCase() === tokenAddress.toLowerCase()\n                }[\"LendState.useCallback[ApproveToContinue].token\"]);\n                if (!token) throw new Error(\"Token not found\");\n                await (0,_lib_tx__WEBPACK_IMPORTED_MODULE_4__.approveIfNeeded)(metamaskDetails.signer, tokenAddress, _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.LENDING_POOL, approveAmount, token.decimals);\n                console.log(\"Token approved:\", tokenAddress);\n                return {\n                    status: 200,\n                    message: \"Transaction Successful...\"\n                };\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[ApproveToContinue]\"], [\n        metamaskDetails.signer\n    ]);\n    // Lend asset\n    const LendAsset = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[LendAsset]\": async (token, supplyAmount)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const tokenInfo = _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.find({\n                    \"LendState.useCallback[LendAsset].tokenInfo\": (t)=>t.address.toLowerCase() === token.toLowerCase()\n                }[\"LendState.useCallback[LendAsset].tokenInfo\"]);\n                if (!tokenInfo) throw new Error(\"Token not found\");\n                const amount = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(supplyAmount, tokenInfo.decimals);\n                const tx = await (0,_lib_tx__WEBPACK_IMPORTED_MODULE_4__.lend)(metamaskDetails.signer, token, amount);\n                if (tx) {\n                    console.log(\"Asset lent successfully:\", token, supplyAmount);\n                    return {\n                        status: 200,\n                        message: \"Transaction Successful...\",\n                        hash: tx.hash\n                    };\n                }\n                throw new Error(\"Transaction failed\");\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[LendAsset]\"], [\n        metamaskDetails.signer\n    ]);\n    // Withdraw asset\n    const WithdrawAsset = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[WithdrawAsset]\": async (tokenAddress, withdrawAmount)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const tokenInfo = _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.find({\n                    \"LendState.useCallback[WithdrawAsset].tokenInfo\": (t)=>t.address.toLowerCase() === tokenAddress.toLowerCase()\n                }[\"LendState.useCallback[WithdrawAsset].tokenInfo\"]);\n                if (!tokenInfo) throw new Error(\"Token not found\");\n                const amount = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(withdrawAmount, tokenInfo.decimals);\n                const tx = await (0,_lib_tx__WEBPACK_IMPORTED_MODULE_4__.withdraw)(metamaskDetails.signer, tokenAddress, amount);\n                if (tx) {\n                    console.log(\"Asset withdrawn successfully:\", tokenAddress, withdrawAmount);\n                    return {\n                        status: 200,\n                        message: \"Transaction Successful...\",\n                        hash: tx.hash\n                    };\n                }\n                throw new Error(\"Transaction failed\");\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[WithdrawAsset]\"], [\n        metamaskDetails.signer\n    ]);\n    // Borrow asset\n    const borrowAsset = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[borrowAsset]\": async (token, borrowAmount)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const tokenInfo = _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.find({\n                    \"LendState.useCallback[borrowAsset].tokenInfo\": (t)=>t.address.toLowerCase() === token.toLowerCase()\n                }[\"LendState.useCallback[borrowAsset].tokenInfo\"]);\n                if (!tokenInfo) throw new Error(\"Token not found\");\n                const amount = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(borrowAmount, tokenInfo.decimals);\n                const tx = await (0,_lib_tx__WEBPACK_IMPORTED_MODULE_4__.borrow)(metamaskDetails.signer, token, amount);\n                if (tx) {\n                    console.log(\"Asset borrowed successfully:\", token, borrowAmount);\n                    return {\n                        status: 200,\n                        message: \"Transaction Successful...\",\n                        hash: tx.hash\n                    };\n                }\n                throw new Error(\"Transaction failed\");\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[borrowAsset]\"], [\n        metamaskDetails.signer\n    ]);\n    // Repay asset\n    const repayAsset = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[repayAsset]\": async (tokenAddress, repayAmount)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const tokenInfo = _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.find({\n                    \"LendState.useCallback[repayAsset].tokenInfo\": (t)=>t.address.toLowerCase() === tokenAddress.toLowerCase()\n                }[\"LendState.useCallback[repayAsset].tokenInfo\"]);\n                if (!tokenInfo) throw new Error(\"Token not found\");\n                const amount = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(repayAmount, tokenInfo.decimals);\n                const tx = await (0,_lib_tx__WEBPACK_IMPORTED_MODULE_4__.repay)(metamaskDetails.signer, tokenAddress, amount);\n                if (tx) {\n                    console.log(\"Asset repaid successfully:\", tokenAddress, repayAmount);\n                    return {\n                        status: 200,\n                        message: \"Transaction Successful...\",\n                        hash: tx.hash\n                    };\n                }\n                throw new Error(\"Transaction failed\");\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[repayAsset]\"], [\n        metamaskDetails.signer\n    ]);\n    // Get account data (collateral, debt, health factor)\n    const getAccountData = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getAccountData]\": async (user)=>{\n            try {\n                if (!metamaskDetails.provider) return null;\n                const pool = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_addresses__WEBPACK_IMPORTED_MODULE_5__.LendingPoolAddress, _abis__WEBPACK_IMPORTED_MODULE_6__.LendingPoolABI.abi, metamaskDetails.provider);\n                const wallet = user || metamaskDetails.currentAccount || ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.ZeroAddress;\n                // Add error handling for empty response\n                let col, debt, hf;\n                try {\n                    [col, debt, hf] = await pool.getAccountData(wallet);\n                } catch (contractError) {\n                    console.log('Contract getAccountData failed, using defaults:', contractError.message);\n                    // Return default values for new users\n                    col = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(\"0\", 18);\n                    debt = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(\"0\", 18);\n                    hf = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(\"115792089237316195423570985008687907853269984665640564039457.584007913129639935\", 18); // Max uint256\n                }\n                const accountData = {\n                    collateralUSD: ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(col, 18),\n                    debtUSD: ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(debt, 18),\n                    healthFactor: ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(hf, 18)\n                };\n                setAccountData(accountData);\n                return accountData;\n            } catch (error) {\n                console.log('getAccountData error, using defaults:', error.message);\n                // Return default values on any error\n                const accountData = {\n                    collateralUSD: \"0\",\n                    debtUSD: \"0\",\n                    healthFactor: \"115792089237316195423570985008687907853269984665640564039457.584007913129639935\"\n                };\n                setAccountData(accountData);\n                return accountData;\n            }\n        }\n    }[\"LendState.useCallback[getAccountData]\"], [\n        metamaskDetails.provider,\n        metamaskDetails.currentAccount\n    ]);\n    // Get your supplies\n    const getYourSupplies = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getYourSupplies]\": async ()=>{\n            console.log(\"3. Getting your supplies...\");\n            try {\n                if (!metamaskDetails.provider || !metamaskDetails.currentAccount) return [];\n                const abi = [\n                    'function getUserReserve(address user, address asset) view returns (tuple(uint128 principal,uint128 index) supply, tuple(uint128 principal,uint128 index) borrow)'\n                ];\n                const pool = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.LENDING_POOL, abi, metamaskDetails.provider);\n                const supplies = await Promise.all(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.filter({\n                    \"LendState.useCallback[getYourSupplies]\": (t)=>!t.isNative\n                }[\"LendState.useCallback[getYourSupplies]\"]).map({\n                    \"LendState.useCallback[getYourSupplies]\": async (token)=>{\n                        try {\n                            const userReserve = await pool.getUserReserve(metamaskDetails.currentAccount, token.address);\n                            const supplyPrincipal = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(userReserve.supply.principal, 18);\n                            const supplyIndex = userReserve.supply.index.toString();\n                            if (parseFloat(supplyPrincipal) > 0) {\n                                const price = await getPriceUSD(token.address);\n                                const balanceUSD = parseFloat(supplyPrincipal) * parseFloat(price);\n                                return {\n                                    address: token.address,\n                                    symbol: token.symbol,\n                                    name: token.name,\n                                    decimals: token.decimals,\n                                    supplyPrincipal: supplyPrincipal,\n                                    supplyIndex: supplyIndex,\n                                    balanceUSD: balanceUSD,\n                                    priceUSD: price\n                                };\n                            }\n                            return null;\n                        } catch (error) {\n                            console.warn(\"Error getting supply for \".concat(token.symbol, \":\"), error);\n                            return null;\n                        }\n                    }\n                }[\"LendState.useCallback[getYourSupplies]\"]));\n                const validSupplies = supplies.filter({\n                    \"LendState.useCallback[getYourSupplies].validSupplies\": (s)=>s !== null\n                }[\"LendState.useCallback[getYourSupplies].validSupplies\"]);\n                setSupplyAssets(validSupplies);\n                // Calculate summary\n                const totalUSDBalance = validSupplies.reduce({\n                    \"LendState.useCallback[getYourSupplies].totalUSDBalance\": (sum, asset)=>sum + asset.balanceUSD\n                }[\"LendState.useCallback[getYourSupplies].totalUSDBalance\"], 0);\n                const weightedAvgAPY = validSupplies.length > 0 ? validSupplies.reduce({\n                    \"LendState.useCallback[getYourSupplies]\": (sum, asset)=>sum + (asset.apy || 0)\n                }[\"LendState.useCallback[getYourSupplies]\"], 0) / validSupplies.length : 0;\n                const totalUSDCollateral = validSupplies.reduce({\n                    \"LendState.useCallback[getYourSupplies].totalUSDCollateral\": (sum, asset)=>sum + asset.balanceUSD\n                }[\"LendState.useCallback[getYourSupplies].totalUSDCollateral\"], 0);\n                setSupplySummary({\n                    totalUSDBalance,\n                    weightedAvgAPY,\n                    totalUSDCollateral\n                });\n                console.log(\"Got your supplies:\", validSupplies);\n                return validSupplies;\n            } catch (error) {\n                reportError(error);\n                return [];\n            }\n        }\n    }[\"LendState.useCallback[getYourSupplies]\"], [\n        metamaskDetails.provider,\n        metamaskDetails.currentAccount,\n        getPriceUSD\n    ]);\n    // Get your borrows\n    const getYourBorrows = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getYourBorrows]\": async ()=>{\n            console.log(\"4. Getting your borrows...\");\n            try {\n                if (!metamaskDetails.provider || !metamaskDetails.currentAccount) return [];\n                const abi = [\n                    'function getUserReserve(address user, address asset) view returns (tuple(uint128 principal,uint128 index) supply, tuple(uint128 principal,uint128 index) borrow)'\n                ];\n                const pool = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.LENDING_POOL, abi, metamaskDetails.provider);\n                const borrows = await Promise.all(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.filter({\n                    \"LendState.useCallback[getYourBorrows]\": (t)=>!t.isNative\n                }[\"LendState.useCallback[getYourBorrows]\"]).map({\n                    \"LendState.useCallback[getYourBorrows]\": async (token)=>{\n                        try {\n                            const userReserve = await pool.getUserReserve(metamaskDetails.currentAccount, token.address);\n                            const borrowPrincipal = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(userReserve.borrow.principal, 18);\n                            const borrowIndex = userReserve.borrow.index.toString();\n                            if (parseFloat(borrowPrincipal) > 0) {\n                                const price = await getPriceUSD(token.address);\n                                const balanceUSD = parseFloat(borrowPrincipal) * parseFloat(price);\n                                return {\n                                    address: token.address,\n                                    symbol: token.symbol,\n                                    name: token.name,\n                                    decimals: token.decimals,\n                                    borrowPrincipal: borrowPrincipal,\n                                    borrowIndex: borrowIndex,\n                                    balanceUSD: balanceUSD,\n                                    priceUSD: price\n                                };\n                            }\n                            return null;\n                        } catch (error) {\n                            console.warn(\"Error getting borrow for \".concat(token.symbol, \":\"), error);\n                            return null;\n                        }\n                    }\n                }[\"LendState.useCallback[getYourBorrows]\"]));\n                const validBorrows = borrows.filter({\n                    \"LendState.useCallback[getYourBorrows].validBorrows\": (b)=>b !== null\n                }[\"LendState.useCallback[getYourBorrows].validBorrows\"]);\n                setYourBorrows(validBorrows);\n                // Calculate summary\n                const totalUSDBalance = validBorrows.reduce({\n                    \"LendState.useCallback[getYourBorrows].totalUSDBalance\": (sum, asset)=>sum + asset.balanceUSD\n                }[\"LendState.useCallback[getYourBorrows].totalUSDBalance\"], 0);\n                const weightedAvgAPY = validBorrows.length > 0 ? validBorrows.reduce({\n                    \"LendState.useCallback[getYourBorrows]\": (sum, asset)=>sum + (asset.apy || 0)\n                }[\"LendState.useCallback[getYourBorrows]\"], 0) / validBorrows.length : 0;\n                const totalBorrowPowerUsed = totalUSDBalance;\n                setBorrowSummary({\n                    totalUSDBalance,\n                    weightedAvgAPY,\n                    totalBorrowPowerUsed\n                });\n                console.log(\"Got your borrows:\", validBorrows);\n                return validBorrows;\n            } catch (error) {\n                reportError(error);\n                return [];\n            }\n        }\n    }[\"LendState.useCallback[getYourBorrows]\"], [\n        metamaskDetails.provider,\n        metamaskDetails.currentAccount,\n        getPriceUSD\n    ]);\n    // Get assets to borrow\n    const getAssetsToBorrow = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getAssetsToBorrow]\": async ()=>{\n            console.log(\"5. Getting assets to borrow...\");\n            try {\n                if (!metamaskDetails.provider) return [];\n                const abi = [\n                    'function reserves(address) view returns (uint128 reserveCash, uint128 totalDebtPrincipal, uint128 liquidityIndex, uint128 variableBorrowIndex, uint64 liquidityRateRayPerSec, uint64 variableBorrowRateRayPerSec, uint16 reserveFactorBps, uint16 ltvBps, uint16 liqThresholdBps, uint16 liqBonusBps, uint16 closeFactorBps, uint8 decimals, bool isBorrowable, uint16 optimalUBps, uint64 baseRateRayPerSec, uint64 slope1RayPerSec, uint64 slope2RayPerSec, uint40 lastUpdate)'\n                ];\n                const pool = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.LENDING_POOL, abi, metamaskDetails.provider);\n                const assets = await Promise.all(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.filter({\n                    \"LendState.useCallback[getAssetsToBorrow]\": (t)=>!t.isNative\n                }[\"LendState.useCallback[getAssetsToBorrow]\"]).map({\n                    \"LendState.useCallback[getAssetsToBorrow]\": async (token)=>{\n                        try {\n                            const reserve = await pool.reserves(token.address);\n                            const isBorrowable = Boolean(reserve.isBorrowable);\n                            const reserveCash = ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(reserve.reserveCash, 18);\n                            const price = await getPriceUSD(token.address);\n                            if (isBorrowable && parseFloat(reserveCash) > 0) {\n                                return {\n                                    address: token.address,\n                                    symbol: token.symbol,\n                                    name: token.name,\n                                    decimals: token.decimals,\n                                    reserveCash: reserveCash,\n                                    isBorrowable: isBorrowable,\n                                    priceUSD: price,\n                                    ltvBps: Number(reserve.ltvBps),\n                                    liqThresholdBps: Number(reserve.liqThresholdBps)\n                                };\n                            }\n                            return null;\n                        } catch (error) {\n                            console.warn(\"Error getting borrow asset \".concat(token.symbol, \":\"), error);\n                            return null;\n                        }\n                    }\n                }[\"LendState.useCallback[getAssetsToBorrow]\"]));\n                const validAssets = assets.filter({\n                    \"LendState.useCallback[getAssetsToBorrow].validAssets\": (a)=>a !== null\n                }[\"LendState.useCallback[getAssetsToBorrow].validAssets\"]);\n                setAssetsToBorrow(validAssets);\n                console.log(\"Got assets to borrow:\", validAssets);\n                return validAssets;\n            } catch (error) {\n                reportError(error);\n                return [];\n            }\n        }\n    }[\"LendState.useCallback[getAssetsToBorrow]\"], [\n        metamaskDetails.provider,\n        getPriceUSD\n    ]);\n    // Wrap ETH to WETH\n    const wrapEth = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[wrapEth]\": async (amountEth)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const data = '0xd0e30db0'; // deposit()\n                console.log('wrapEth → using WETH address:', _addresses__WEBPACK_IMPORTED_MODULE_5__.WETHAddress);\n                const tx = await metamaskDetails.signer.sendTransaction({\n                    to: _addresses__WEBPACK_IMPORTED_MODULE_5__.WETHAddress,\n                    value: ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseEther(amountEth),\n                    data\n                });\n                await tx.wait();\n                console.log(\"ETH wrapped to WETH:\", amountEth);\n                return {\n                    status: 200,\n                    message: \"Transaction Successful...\",\n                    hash: tx.hash\n                };\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[wrapEth]\"], [\n        metamaskDetails.signer\n    ]);\n    // Unwrap WETH to ETH\n    const unwrapWeth = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[unwrapWeth]\": async (amountEth)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const abi = [\n                    'function withdraw(uint256 wad)'\n                ];\n                console.log('unwrapWeth → using WETH address:', _addresses__WEBPACK_IMPORTED_MODULE_5__.WETHAddress);\n                const weth = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_addresses__WEBPACK_IMPORTED_MODULE_5__.WETHAddress, abi, metamaskDetails.signer);\n                const tx = await weth.withdraw(ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseEther(amountEth));\n                await tx.wait();\n                console.log(\"WETH unwrapped to ETH:\", amountEth);\n                return {\n                    status: 200,\n                    message: \"Transaction Successful...\",\n                    hash: tx.hash\n                };\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[unwrapWeth]\"], [\n        metamaskDetails.signer\n    ]);\n    // Withdraw token to ETH (for all tokens with withdraw function)\n    const withdrawToken = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[withdrawToken]\": async (tokenAddress, amount)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const abi = [\n                    'function withdraw(uint256 amount)'\n                ];\n                console.log('withdrawToken → using address:', tokenAddress);\n                const token = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(tokenAddress, abi, metamaskDetails.signer);\n                const tx = await token.withdraw(ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseEther(amount));\n                await tx.wait();\n                console.log(\"Token withdrawn to ETH:\", amount);\n                return {\n                    status: 200,\n                    message: \"Withdraw Successful...\",\n                    hash: tx.hash\n                };\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[withdrawToken]\"], [\n        metamaskDetails.signer\n    ]);\n    // Deposit ETH to get token (for all tokens with deposit function)\n    const depositToToken = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[depositToToken]\": async (tokenAddress, amountEth)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const abi = [\n                    'function deposit() payable'\n                ];\n                console.log('depositToToken → using address:', tokenAddress);\n                const token = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(tokenAddress, abi, metamaskDetails.signer);\n                const tx = await token.deposit({\n                    value: ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseEther(amountEth)\n                });\n                await tx.wait();\n                console.log(\"ETH deposited to token:\", amountEth);\n                return {\n                    status: 200,\n                    message: \"Deposit Successful...\",\n                    hash: tx.hash\n                };\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[depositToToken]\"], [\n        metamaskDetails.signer\n    ]);\n    // Refresh all data\n    const refresh = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[refresh]\": async ()=>{\n            try {\n                await Promise.all([\n                    getUserAssets(),\n                    getYourSupplies(),\n                    getYourBorrows(),\n                    getAssetsToBorrow(),\n                    getAccountData()\n                ]);\n                console.log(\"All data refreshed\");\n            } catch (error) {\n                reportError(error);\n            }\n        }\n    }[\"LendState.useCallback[refresh]\"], [\n        getUserAssets,\n        getYourSupplies,\n        getYourBorrows,\n        getAssetsToBorrow,\n        getAccountData\n    ]);\n    // Update interests (accrue)\n    const updateInterests = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[updateInterests]\": async (asset)=>{\n            if (!metamaskDetails.signer) {\n                throw new Error(\"No signer available\");\n            }\n            try {\n                const abi = [\n                    'function accruePublic(address asset)'\n                ];\n                const pool = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.LENDING_POOL, abi, metamaskDetails.signer);\n                const tx = await pool.accruePublic(asset);\n                await tx.wait();\n                console.log(\"Interests updated for asset:\", asset);\n                return {\n                    status: 200,\n                    message: \"Transaction Successful...\"\n                };\n            } catch (error) {\n                reportError(error);\n                return {\n                    status: 500,\n                    message: error.message || error.reason\n                };\n            }\n        }\n    }[\"LendState.useCallback[updateInterests]\"], [\n        metamaskDetails.signer\n    ]);\n    // Get user total available balance\n    const getUserTotalAvailableBalance = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getUserTotalAvailableBalance]\": async ()=>{\n            try {\n                if (!metamaskDetails.provider || !metamaskDetails.currentAccount) return 0;\n                const abi = [\n                    'function getUserTotalAvailableBalanceInUSD(address user, uint256 assetType) view returns (uint256)'\n                ];\n                const pool = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.LENDING_POOL, abi, metamaskDetails.provider);\n                const maxAmount = await pool.getUserTotalAvailableBalanceInUSD(metamaskDetails.currentAccount, 1);\n                return Number(ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(maxAmount, 18));\n            } catch (error) {\n                reportError(error);\n                return 0;\n            }\n        }\n    }[\"LendState.useCallback[getUserTotalAvailableBalance]\"], [\n        metamaskDetails.provider,\n        metamaskDetails.currentAccount\n    ]);\n    // Get tokens per USD amount\n    const getTokensPerUSDAmount = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[getTokensPerUSDAmount]\": async (token, amount)=>{\n            try {\n                if (!metamaskDetails.provider) return 0;\n                const abi = [\n                    'function getTokensPerUSDAmount(address token, uint256 amount) view returns (uint256)'\n                ];\n                const helper = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.PRICE_ORACLE, abi, metamaskDetails.provider);\n                const maxQty = await helper.getTokensPerUSDAmount(token, ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.parseUnits(amount.toString(), 18));\n                return Number(ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.formatUnits(maxQty, 18));\n            } catch (error) {\n                reportError(error);\n                return 0;\n            }\n        }\n    }[\"LendState.useCallback[getTokensPerUSDAmount]\"], [\n        metamaskDetails.provider\n    ]);\n    // Objectify supplied assets (format data)\n    const objectifySuppliedAssets = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[objectifySuppliedAssets]\": async (assets)=>{\n            const assetsList = [];\n            for(let i = 0; i < assets.length; i++){\n                const token = assets[i].token;\n                let lendQty = assets[i].lentQty;\n                const amountInUSD = await getAmountInUSD(token, lendQty);\n                lendQty = Number(assets[i].lentQty) / 1e18;\n                const maxSupplyAmount = await getUserTotalAvailableBalance();\n                const maxQty = await getTokensPerUSDAmount(token, maxSupplyAmount);\n                const qty = lendQty <= maxQty ? lendQty : maxQty;\n                assetsList.push({\n                    token: assets[i].token,\n                    balance: lendQty,\n                    apy: Number(assets[i].lentApy),\n                    balanceInUSD: amountInUSD,\n                    maxSupply: qty\n                });\n            }\n            return assetsList;\n        }\n    }[\"LendState.useCallback[objectifySuppliedAssets]\"], [\n        getAmountInUSD,\n        getUserTotalAvailableBalance,\n        getTokensPerUSDAmount\n    ]);\n    // Objectify borrowed assets (format data)\n    const objectifyBorrowedAssets = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[objectifyBorrowedAssets]\": async (assets)=>{\n            const borrowsList = [];\n            for(let i = 0; i < assets.length; i++){\n                const token = assets[i].token;\n                const borrowQty = assets[i].borrowQty;\n                const borrowApy = assets[i].borrowApy;\n                const amountInUSD = await getAmountInUSD(token, borrowQty);\n                borrowsList.push({\n                    token: token,\n                    borrowQty: Number(borrowQty),\n                    borrowApy: Number(borrowApy),\n                    borrowedBalInUSD: amountInUSD\n                });\n            }\n            return borrowsList;\n        }\n    }[\"LendState.useCallback[objectifyBorrowedAssets]\"], [\n        getAmountInUSD\n    ]);\n    // Merge objectified assets with token info\n    const mergeObjectifiedAssets = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LendState.useCallback[mergeObjectifiedAssets]\": (assets)=>{\n            const result = _config_contracts__WEBPACK_IMPORTED_MODULE_3__.CONFIG.TOKENS.filter({\n                \"LendState.useCallback[mergeObjectifiedAssets].result\": (tokenList)=>{\n                    return assets.some({\n                        \"LendState.useCallback[mergeObjectifiedAssets].result\": (assetList)=>{\n                            return tokenList.address.toLowerCase() === assetList.token.toLowerCase();\n                        }\n                    }[\"LendState.useCallback[mergeObjectifiedAssets].result\"]);\n                }\n            }[\"LendState.useCallback[mergeObjectifiedAssets].result\"]).map({\n                \"LendState.useCallback[mergeObjectifiedAssets].result\": (assetObj)=>({\n                        ...assets.find({\n                            \"LendState.useCallback[mergeObjectifiedAssets].result\": (item)=>item.token.toLowerCase() === assetObj.address.toLowerCase()\n                        }[\"LendState.useCallback[mergeObjectifiedAssets].result\"]),\n                        ...assetObj\n                    })\n            }[\"LendState.useCallback[mergeObjectifiedAssets].result\"]);\n            return result;\n        }\n    }[\"LendState.useCallback[mergeObjectifiedAssets]\"], []);\n    // Context value\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"LendState.useMemo[contextValue]\": ()=>({\n                // State\n                metamaskDetails,\n                userAssets,\n                supplyAssets,\n                assetsToBorrow,\n                yourBorrows,\n                supplySummary,\n                borrowSummary,\n                accountData,\n                contract,\n                // Wallet functions\n                connectWallet,\n                refresh,\n                // Asset functions\n                getUserAssets,\n                getYourSupplies,\n                getYourBorrows,\n                getAssetsToBorrow,\n                // Transaction functions\n                ApproveToContinue,\n                LendAsset,\n                WithdrawAsset,\n                borrowAsset,\n                repayAsset,\n                // Utility functions\n                getContract,\n                getPriceUSD,\n                getAmountInUSD,\n                numberToEthers,\n                reportError,\n                // ETH/WETH functions\n                wrapEth,\n                unwrapWeth,\n                // Account functions\n                getAccountData,\n                getUserTotalAvailableBalance,\n                getTokensPerUSDAmount,\n                // Data processing functions\n                objectifySuppliedAssets,\n                objectifyBorrowedAssets,\n                mergeObjectifiedAssets,\n                // Interest functions\n                updateInterests,\n                // Token withdraw/deposit functions\n                withdrawToken,\n                depositToToken\n            })\n    }[\"LendState.useMemo[contextValue]\"], [\n        metamaskDetails,\n        userAssets,\n        supplyAssets,\n        assetsToBorrow,\n        yourBorrows,\n        supplySummary,\n        borrowSummary,\n        accountData,\n        contract,\n        connectWallet,\n        refresh,\n        getUserAssets,\n        getYourSupplies,\n        getYourBorrows,\n        getAssetsToBorrow,\n        ApproveToContinue,\n        LendAsset,\n        WithdrawAsset,\n        borrowAsset,\n        repayAsset,\n        getContract,\n        getPriceUSD,\n        getAmountInUSD,\n        wrapEth,\n        unwrapWeth,\n        getAccountData,\n        getUserTotalAvailableBalance,\n        getTokensPerUSDAmount,\n        objectifySuppliedAssets,\n        objectifyBorrowedAssets,\n        mergeObjectifiedAssets,\n        updateInterests\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lendContext__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Provider, {\n        value: contextValue,\n        children: props.children\n    }, void 0, false, {\n        fileName: \"D:\\\\Do_an2\\\\lendhub_v2\\\\lendhub-frontend-nextjs\\\\src\\\\context\\\\LendState.js\",\n        lineNumber: 898,\n        columnNumber: 5\n    }, undefined);\n};\n_s(LendState, \"VmZhE1ZTOhq434hcVdJavoagcY4=\");\n_c = LendState;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LendState);\nvar _c;\n$RefreshReg$(_c, \"LendState\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9jb250ZXh0L0xlbmRTdGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUE4RDtBQUN0QjtBQUNSO0FBQ2E7QUFDaUg7QUFDN0Q7QUFDNUI7QUFFckUsb0JBQW9CO0FBQ3BCLE1BQU15QixpQkFBaUIsQ0FBQ0M7SUFDdEIsT0FBT3JCLDBDQUFNQSxDQUFDc0IsVUFBVSxDQUFDRCxPQUFPRSxRQUFRO0FBQzFDO0FBRUEsTUFBTUMsY0FBYyxDQUFDQztJQUNuQkMsUUFBUUQsS0FBSyxDQUFDLG9CQUFvQkUsS0FBS0MsU0FBUyxDQUFDSDtJQUNqREMsUUFBUUQsS0FBSyxDQUFDLGtCQUFrQkE7QUFDbEM7QUFFQSxNQUFNSSxZQUFZLENBQUNDOztJQUNqQiw0QkFBNEI7SUFFNUIsdUJBQXVCO0lBQ3ZCLE1BQU0sQ0FBQ0MsaUJBQWlCQyxtQkFBbUIsR0FBR3BDLCtDQUFRQSxDQUFDO1FBQ3JEcUMsVUFBVTtRQUNWQyxhQUFhO1FBQ2JDLFFBQVE7UUFDUkMsZ0JBQWdCO1FBQ2hCQyxTQUFTO0lBQ1g7SUFFQSwyQkFBMkI7SUFDM0IsTUFBTSxDQUFDQyxZQUFZQyxjQUFjLEdBQUczQywrQ0FBUUEsQ0FBQyxFQUFFO0lBQy9DLE1BQU0sQ0FBQzRDLGNBQWNDLGdCQUFnQixHQUFHN0MsK0NBQVFBLENBQUMsRUFBRTtJQUNuRCxNQUFNLENBQUM4QyxnQkFBZ0JDLGtCQUFrQixHQUFHL0MsK0NBQVFBLENBQUMsRUFBRTtJQUN2RCxNQUFNLENBQUNnRCxhQUFhQyxlQUFlLEdBQUdqRCwrQ0FBUUEsQ0FBQyxFQUFFO0lBRWpELG1CQUFtQjtJQUNuQixNQUFNLENBQUNrRCxVQUFVQyxZQUFZLEdBQUduRCwrQ0FBUUEsQ0FBQztRQUN2Q29ELHFCQUFxQjtRQUNyQkMsZ0JBQWdCO0lBQ2xCO0lBRUEsZUFBZTtJQUNmLE1BQU0sQ0FBQ0MsZUFBZUMsaUJBQWlCLEdBQUd2RCwrQ0FBUUEsQ0FBQztRQUNqRHdELGlCQUFp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RTtnQkFFQSxvQkFBb0I7Z0JBQ3BCckQ7Z0JBQ0FtQjtnQkFDQVU7Z0JBQ0E1RjtnQkFDQUk7Z0JBRUEscUJBQXFCO2dCQUNyQjBKO2dCQUNBTztnQkFFQSxvQkFBb0I7Z0JBQ3BCL0M7Z0JBQ0F1RDtnQkFDQUc7Z0JBRUEsNEJBQTRCO2dCQUM1Qkc7Z0JBQ0FXO2dCQUNBSztnQkFFQSxxQkFBcUI7Z0JBQ3JCeEI7Z0JBRUEsbUNBQW1DO2dCQUNuQ0o7Z0JBQ0FDO1lBQ0Y7MENBQUk7UUFDRjdKO1FBQ0FPO1FBQ0FFO1FBQ0FFO1FBQ0FFO1FBQ0FNO1FBQ0FLO1FBQ0FHO1FBQ0FaO1FBQ0FpQjtRQUNBK0g7UUFDQXZHO1FBQ0E0RDtRQUNBZTtRQUNBTTtRQUNBckQ7UUFDQVc7UUFDQU07UUFDQUU7UUFDQUU7UUFDQXJEO1FBQ0FtQjtRQUNBVTtRQUNBa0U7UUFDQU87UUFDQS9DO1FBQ0F1RDtRQUNBRztRQUNBRztRQUNBVztRQUNBSztRQUNBeEI7S0FDRDtJQUVELHFCQUNFLDhEQUFDaE0sNkRBQW9CO1FBQUN3TCxPQUFPdUM7a0JBQzFCaE0sTUFBTWtNLFFBQVE7Ozs7OztBQUdyQjtHQW4zQk1uTTtLQUFBQTtBQXEzQk4saUVBQWVBLFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxzcmNcXGNvbnRleHRcXExlbmRTdGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgbGVuZENvbnRleHQgZnJvbSBcIi4vbGVuZENvbnRleHRcIjtcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gXCJldGhlcnNcIjtcbmltcG9ydCB7IENPTkZJRyB9IGZyb20gXCIuLi9jb25maWcvY29udHJhY3RzXCI7XG5pbXBvcnQgeyBnZXRUb2tlbkJhbGFuY2UsIGdldFRva2VuQWxsb3dhbmNlLCBhcHByb3ZlSWZOZWVkZWQsIGxlbmQgYXMgbGVuZFR4LCB3aXRoZHJhdyBhcyB3aXRoZHJhd1R4LCBib3Jyb3cgYXMgYm9ycm93VHgsIHJlcGF5IGFzIHJlcGF5VHggfSBmcm9tIFwiLi4vbGliL3R4XCI7XG5pbXBvcnQgeyBFVEhBZGRyZXNzLCBMZW5kaW5nUG9vbEFkZHJlc3MsIExlbmRpbmdIZWxwZXJBZGRyZXNzLCBXRVRIQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzZXNcIjtcbmltcG9ydCB7IFRva2VuQUJJLCBMZW5kaW5nUG9vbEFCSSwgTGVuZGluZ0hlbHBlckFCSSB9IGZyb20gXCIuLi9hYmlzXCI7XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zXG5jb25zdCBudW1iZXJUb0V0aGVycyA9IChudW1iZXIpID0+IHtcbiAgcmV0dXJuIGV0aGVycy5wYXJzZUV0aGVyKG51bWJlci50b1N0cmluZygpKTtcbn07XG5cbmNvbnN0IHJlcG9ydEVycm9yID0gKGVycm9yKSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoXCJMZW5kU3RhdGUgRXJyb3I6XCIsIEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XG4gIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkZXRhaWxzOlwiLCBlcnJvcik7XG59O1xuXG5jb25zdCBMZW5kU3RhdGUgPSAocHJvcHMpID0+IHtcbiAgLy8qIERlY2xhcmluZyBhbGwgdGhlIHN0YXRlc1xuXG4gIC8vIFNldCBtZXRhbWFzayBkZXRhaWxzXG4gIGNvbnN0IFttZXRhbWFza0RldGFpbHMsIHNldE1ldGFtYXNrRGV0YWlsc10gPSB1c2VTdGF0ZSh7XG4gICAgcHJvdmlkZXI6IG51bGwsXG4gICAgbmV0d29ya05hbWU6IG51bGwsXG4gICAgc2lnbmVyOiBudWxsLFxuICAgIGN1cnJlbnRBY2NvdW50OiBudWxsLFxuICAgIGNoYWluSWQ6IG51bGwsXG4gIH0pO1xuXG4gIC8vIFVzZXIgYXNzZXRzIGFuZCBiYWxhbmNlc1xuICBjb25zdCBbdXNlckFzc2V0cywgc2V0VXNlckFzc2V0c10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtzdXBwbHlBc3NldHMsIHNldFN1cHBseUFzc2V0c10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFthc3NldHNUb0JvcnJvdywgc2V0QXNzZXRzVG9Cb3Jyb3ddID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbeW91ckJvcnJvd3MsIHNldFlvdXJCb3Jyb3dzXSA9IHVzZVN0YXRlKFtdKTtcblxuICAvLyBDb250cmFjdCBkZXRhaWxzXG4gIGNvbnN0IFtjb250cmFjdCwgc2V0Q29udHJhY3RdID0gdXNlU3RhdGUoe1xuICAgIGxlbmRpbmdQb29sQ29udHJhY3Q6IG51bGwsXG4gICAgb3JhY2xlQ29udHJhY3Q6IG51bGwsXG4gIH0pO1xuXG4gIC8vIFN1bW1hcnkgZGF0YVxuICBjb25zdCBbc3VwcGx5U3VtbWFyeSwgc2V0U3VwcGx5U3VtbWFyeV0gPSB1c2VTdGF0ZSh7XG4gICAgdG90YWxVU0RCYWxhbmNlOiAwLFxuICAgIHdlaWdodGVkQXZnQVBZOiAwLFxuICAgIHRvdGFsVVNEQ29sbGF0ZXJhbDogMCxcbiAgfSk7XG5cbiAgY29uc3QgW2JvcnJvd1N1bW1hcnksIHNldEJvcnJvd1N1bW1hcnldID0gdXNlU3RhdGUoe1xuICAgIHRvdGFsVVNEQmFsYW5jZTogMCxcbiAgICB3ZWlnaHRlZEF2Z0FQWTogMCxcbiAgICB0b3RhbEJvcnJvd1Bvd2VyVXNlZDogMCxcbiAgfSk7XG5cbiAgLy8gQWNjb3VudCBkYXRhXG4gIGNvbnN0IFthY2NvdW50RGF0YSwgc2V0QWNjb3VudERhdGFdID0gdXNlU3RhdGUoe1xuICAgIGNvbGxhdGVyYWxVU0Q6IFwiMFwiLFxuICAgIGRlYnRVU0Q6IFwiMFwiLFxuICAgIGhlYWx0aEZhY3RvcjogXCIwXCIsXG4gIH0pO1xuXG4gIC8vIENvbm5lY3Qgd2FsbGV0XG4gIC8vIGNvbnN0IGNvbm5lY3RXYWxsZXQgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gIC8vICAgY29uc29sZS5sb2coXCIxLiBDb25uZWN0aW5nIHRvIHdhbGxldC4uLlwiKTtcbiAgLy8gICBjb25zdCB7IGV0aGVyZXVtIH0gPSB3aW5kb3c7XG4gIC8vICAgY29uc3QgZmFpbE1lc3NhZ2UgPSBcIlBsZWFzZSBpbnN0YWxsIE1ldGFtYXNrICYgY29ubmVjdCB5b3VyIE1ldGFtYXNrXCI7XG4gICAgXG4gIC8vICAgdHJ5IHtcbiAgLy8gICAgIGlmICghZXRoZXJldW0pIHtcbiAgLy8gICAgICAgYWxlcnQoZmFpbE1lc3NhZ2UpO1xuICAvLyAgICAgICByZXR1cm47XG4gIC8vICAgICB9XG5cbiAgLy8gICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgZXRoZXJldW0ucmVxdWVzdCh7XG4gIC8vICAgICAgIG1ldGhvZDogXCJldGhfcmVxdWVzdEFjY291bnRzXCIsXG4gIC8vICAgICB9KTtcblxuICAvLyAgICAgLy8gTGlzdGVuIGZvciBhY2NvdW50IGFuZCBjaGFpbiBjaGFuZ2VzXG4gIC8vICAgICBldGhlcmV1bS5vbihcImNoYWluQ2hhbmdlZFwiLCAoKSA9PiB7XG4gIC8vICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgLy8gICAgIH0pO1xuICAvLyAgICAgZXRoZXJldW0ub24oXCJhY2NvdW50c0NoYW5nZWRcIiwgKCkgPT4ge1xuICAvLyAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gIC8vICAgICB9KTtcblxuICAvLyAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkJyb3dzZXJQcm92aWRlcihldGhlcmV1bSk7XG4gIC8vICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgcHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAvLyAgICAgY29uc3QgbmV0d29ya05hbWUgPSBuZXR3b3JrLm5hbWU7XG4gIC8vICAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcblxuICAvLyAgICAgaWYgKGFjY291bnRzLmxlbmd0aCkge1xuICAvLyAgICAgICBsZXQgY3VycmVudEFkZHJlc3MgPSBhY2NvdW50c1swXTtcbiAgLy8gICAgICAgc2V0TWV0YW1hc2tEZXRhaWxzKHtcbiAgLy8gICAgICAgICBwcm92aWRlcjogcHJvdmlkZXIsXG4gIC8vICAgICAgICAgbmV0d29ya05hbWU6IG5ldHdvcmtOYW1lLFxuICAvLyAgICAgICAgIHNpZ25lcjogc2lnbmVyLFxuICAvLyAgICAgICAgIGN1cnJlbnRBY2NvdW50OiBjdXJyZW50QWRkcmVzcyxcbiAgLy8gICAgICAgICBjaGFpbklkOiBOdW1iZXIobmV0d29yay5jaGFpbklkKSxcbiAgLy8gICAgICAgfSk7XG4gIC8vICAgICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdGVkIHRvIHdhbGxldDpcIiwgY3VycmVudEFkZHJlc3MpO1xuICAvLyAgICAgfSBlbHNlIHtcbiAgLy8gICAgICAgYWxlcnQoZmFpbE1lc3NhZ2UpO1xuICAvLyAgICAgICByZXR1cm47XG4gIC8vICAgICB9XG4gIC8vICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgLy8gICAgIHJlcG9ydEVycm9yKGVycm9yKTtcbiAgLy8gICB9XG4gIC8vIH0sIFtdKTtcblxuICBjb25zdCBjb25uZWN0V2FsbGV0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiMS4gQ29ubmVjdGluZyB0byB3YWxsZXQuLi5cIik7XG4gICAgY29uc3QgeyBldGhlcmV1bSB9ID0gd2luZG93O1xuICAgIGNvbnN0IGZhaWxNZXNzYWdlID0gXCJQbGVhc2UgaW5zdGFsbCBNZXRhbWFzayAmIGNvbm5lY3QgeW91ciBNZXRhbWFza1wiO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWV0aGVyZXVtKSB7XG4gICAgICAgIGFsZXJ0KGZhaWxNZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGV0aGVyZXVtLnJlcXVlc3QoeyBtZXRob2Q6IFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiIH0pO1xuXG4gICAgICAvLyBMaXN0ZW4gZm9yIGFjY291bnQgYW5kIGNoYWluIGNoYW5nZXNcbiAgICAgIGV0aGVyZXVtLm9uKFwiY2hhaW5DaGFuZ2VkXCIsICgpID0+IHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgfSk7XG4gICAgICBldGhlcmV1bS5vbihcImFjY291bnRzQ2hhbmdlZFwiLCAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuQnJvd3NlclByb3ZpZGVyKGV0aGVyZXVtKTtcbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBwcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICBjb25zdCBuZXR3b3JrTmFtZSA9IG5ldHdvcmsubmFtZTtcbiAgICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xuXG4gICAgICBpZiAoYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBjdXJyZW50QWRkcmVzcyA9IGFjY291bnRzWzBdO1xuICAgICAgICBzZXRNZXRhbWFza0RldGFpbHMoe1xuICAgICAgICAgIHByb3ZpZGVyOiBwcm92aWRlcixcbiAgICAgICAgICBuZXR3b3JrTmFtZTogbmV0d29ya05hbWUsXG4gICAgICAgICAgc2lnbmVyOiBzaWduZXIsXG4gICAgICAgICAgY3VycmVudEFjY291bnQ6IGN1cnJlbnRBZGRyZXNzLFxuICAgICAgICAgIGNoYWluSWQ6IE51bWJlcihuZXR3b3JrLmNoYWluSWQpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0ZWQgdG8gd2FsbGV0KysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKzpcIiwgY3VycmVudEFkZHJlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxlcnQoZmFpbE1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydEVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBHZXQgY29udHJhY3QgaW5zdGFuY2VcbiAgY29uc3QgZ2V0Q29udHJhY3QgPSB1c2VDYWxsYmFjayhhc3luYyAoYWRkcmVzcywgYWJpKSA9PiB7XG4gICAgaWYgKCFtZXRhbWFza0RldGFpbHMucHJvdmlkZXIpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChhZGRyZXNzLCBhYmksIG1ldGFtYXNrRGV0YWlscy5wcm92aWRlcik7XG4gICAgcmV0dXJuIGNvbnRyYWN0O1xuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyXSk7XG5cbiAgLy8gR2V0IHVzZXIgYXNzZXRzIChiYWxhbmNlcylcbiAgY29uc3QgZ2V0VXNlckFzc2V0cyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIjIuIEdldHRpbmcgdXNlciBhc3NldHMuLi5cIik7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyIHx8ICFtZXRhbWFza0RldGFpbHMuY3VycmVudEFjY291bnQpIHJldHVybiBbXTtcblxuICAgICAgY29uc3QgYXNzZXRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIENPTkZJRy5UT0tFTlMubWFwKGFzeW5jICh0b2tlbikgPT4ge1xuICAgICAgICAgIGxldCBiYWxhbmNlID0gXCIwXCI7XG4gICAgICAgICAgbGV0IGJhbGFuY2VVU0QgPSAwO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0b2tlbi5pc05hdGl2ZSkge1xuICAgICAgICAgICAgICAvLyBFVEggbmF0aXZlIGJhbGFuY2VcbiAgICAgICAgICAgICAgY29uc3QgYmFsID0gYXdhaXQgbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyLmdldEJhbGFuY2UobWV0YW1hc2tEZXRhaWxzLmN1cnJlbnRBY2NvdW50KTtcbiAgICAgICAgICAgICAgYmFsYW5jZSA9IGV0aGVycy5mb3JtYXRFdGhlcihiYWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gRVJDMjAgdG9rZW4gYmFsYW5jZVxuICAgICAgICAgICAgICBiYWxhbmNlID0gYXdhaXQgZ2V0VG9rZW5CYWxhbmNlKFxuICAgICAgICAgICAgICAgIG1ldGFtYXNrRGV0YWlscy5wcm92aWRlcixcbiAgICAgICAgICAgICAgICB0b2tlbi5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIG1ldGFtYXNrRGV0YWlscy5jdXJyZW50QWNjb3VudCxcbiAgICAgICAgICAgICAgICB0b2tlbi5kZWNpbWFsc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgVVNEIHZhbHVlXG4gICAgICAgICAgICBjb25zdCBwcmljZSA9IGF3YWl0IGdldFByaWNlVVNEKHRva2VuLmFkZHJlc3MpO1xuICAgICAgICAgICAgYmFsYW5jZVVTRCA9IHBhcnNlRmxvYXQoYmFsYW5jZSkgKiBwYXJzZUZsb2F0KHByaWNlKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgYWRkcmVzczogdG9rZW4uYWRkcmVzcyxcbiAgICAgICAgICAgICAgc3ltYm9sOiB0b2tlbi5zeW1ib2wsXG4gICAgICAgICAgICAgIG5hbWU6IHRva2VuLm5hbWUsXG4gICAgICAgICAgICAgIGRlY2ltYWxzOiB0b2tlbi5kZWNpbWFscyxcbiAgICAgICAgICAgICAgaXNOYXRpdmU6IHRva2VuLmlzTmF0aXZlLFxuICAgICAgICAgICAgICBiYWxhbmNlOiBiYWxhbmNlLFxuICAgICAgICAgICAgICBiYWxhbmNlVVNEOiBiYWxhbmNlVVNELFxuICAgICAgICAgICAgICBwcmljZVVTRDogcHJpY2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEVycm9yIGdldHRpbmcgYmFsYW5jZSBmb3IgJHt0b2tlbi5zeW1ib2x9OmAsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGFkZHJlc3M6IHRva2VuLmFkZHJlc3MsXG4gICAgICAgICAgICAgIHN5bWJvbDogdG9rZW4uc3ltYm9sLFxuICAgICAgICAgICAgICBuYW1lOiB0b2tlbi5uYW1lLFxuICAgICAgICAgICAgICBkZWNpbWFsczogdG9rZW4uZGVjaW1hbHMsXG4gICAgICAgICAgICAgIGlzTmF0aXZlOiB0b2tlbi5pc05hdGl2ZSxcbiAgICAgICAgICAgICAgYmFsYW5jZTogXCIwXCIsXG4gICAgICAgICAgICAgIGJhbGFuY2VVU0Q6IDAsXG4gICAgICAgICAgICAgIHByaWNlVVNEOiBcIjBcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgc2V0VXNlckFzc2V0cyhhc3NldHMpO1xuICAgICAgY29uc29sZS5sb2coXCJHb3QgdXNlciBhc3NldHM6XCIsIGFzc2V0cyk7XG4gICAgICByZXR1cm4gYXNzZXRzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyLCBtZXRhbWFza0RldGFpbHMuY3VycmVudEFjY291bnRdKTtcblxuICAvLyBHZXQgcHJpY2UgaW4gVVNEXG4gIGNvbnN0IGdldFByaWNlVVNEID0gdXNlQ2FsbGJhY2soYXN5bmMgKGFzc2V0KSA9PiB7XG4gICAgaWYgKCFtZXRhbWFza0RldGFpbHMucHJvdmlkZXIpIHJldHVybiBcIjBcIjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYWJpID0gWydmdW5jdGlvbiBnZXRBc3NldFByaWNlMWUxOChhZGRyZXNzIGFzc2V0KSB2aWV3IHJldHVybnMgKHVpbnQyNTYpJ107XG4gICAgICBjb25zdCBvcmFjbGUgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KENPTkZJRy5QUklDRV9PUkFDTEUsIGFiaSwgbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyKTtcbiAgICAgIGNvbnN0IHByaWNlID0gYXdhaXQgb3JhY2xlLmdldEFzc2V0UHJpY2UxZTE4KGFzc2V0KTtcbiAgICAgIHJldHVybiBldGhlcnMuZm9ybWF0VW5pdHMocHJpY2UsIDE4KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKGBFcnJvciBnZXR0aW5nIHByaWNlIGZvciAke2Fzc2V0fTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gXCIwXCI7XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyXSk7XG5cbiAgLy8gR2V0IGFtb3VudCBpbiBVU0RcbiAgY29uc3QgZ2V0QW1vdW50SW5VU0QgPSB1c2VDYWxsYmFjayhhc3luYyAoYWRkcmVzcywgYW1vdW50KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByaWNlID0gYXdhaXQgZ2V0UHJpY2VVU0QoYWRkcmVzcyk7XG4gICAgICBjb25zdCBhbW91bnRJblVTRCA9IHBhcnNlRmxvYXQoYW1vdW50KSAqIHBhcnNlRmxvYXQocHJpY2UpO1xuICAgICAgcmV0dXJuIGFtb3VudEluVVNEO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sIFtnZXRQcmljZVVTRF0pO1xuXG4gIC8vIEFwcHJvdmUgdG9rZW5zXG4gIGNvbnN0IEFwcHJvdmVUb0NvbnRpbnVlID0gdXNlQ2FsbGJhY2soYXN5bmMgKHRva2VuQWRkcmVzcywgYXBwcm92ZUFtb3VudCkgPT4ge1xuICAgIGlmICghbWV0YW1hc2tEZXRhaWxzLnNpZ25lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmVyIGF2YWlsYWJsZVwiKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdG9rZW4gPSBDT05GSUcuVE9LRU5TLmZpbmQodCA9PiB0LmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gdG9rZW5BZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKCF0b2tlbikgdGhyb3cgbmV3IEVycm9yKFwiVG9rZW4gbm90IGZvdW5kXCIpO1xuXG4gICAgICBhd2FpdCBhcHByb3ZlSWZOZWVkZWQoXG4gICAgICAgIG1ldGFtYXNrRGV0YWlscy5zaWduZXIsXG4gICAgICAgIHRva2VuQWRkcmVzcyxcbiAgICAgICAgQ09ORklHLkxFTkRJTkdfUE9PTCxcbiAgICAgICAgYXBwcm92ZUFtb3VudCxcbiAgICAgICAgdG9rZW4uZGVjaW1hbHNcbiAgICAgICk7XG5cbiAgICAgIGNvbnNvbGUubG9nKFwiVG9rZW4gYXBwcm92ZWQ6XCIsIHRva2VuQWRkcmVzcyk7XG4gICAgICByZXR1cm4geyBzdGF0dXM6IDIwMCwgbWVzc2FnZTogXCJUcmFuc2FjdGlvbiBTdWNjZXNzZnVsLi4uXCIgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiA1MDAsIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IucmVhc29uIH07XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnNpZ25lcl0pO1xuXG4gIC8vIExlbmQgYXNzZXRcbiAgY29uc3QgTGVuZEFzc2V0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKHRva2VuLCBzdXBwbHlBbW91bnQpID0+IHtcbiAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5zaWduZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRva2VuSW5mbyA9IENPTkZJRy5UT0tFTlMuZmluZCh0ID0+IHQuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSB0b2tlbi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIGlmICghdG9rZW5JbmZvKSB0aHJvdyBuZXcgRXJyb3IoXCJUb2tlbiBub3QgZm91bmRcIik7XG5cbiAgICAgIGNvbnN0IGFtb3VudCA9IGV0aGVycy5wYXJzZVVuaXRzKHN1cHBseUFtb3VudCwgdG9rZW5JbmZvLmRlY2ltYWxzKTtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgbGVuZFR4KG1ldGFtYXNrRGV0YWlscy5zaWduZXIsIHRva2VuLCBhbW91bnQpO1xuICAgICAgXG4gICAgICBpZiAodHgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJBc3NldCBsZW50IHN1Y2Nlc3NmdWxseTpcIiwgdG9rZW4sIHN1cHBseUFtb3VudCk7XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogMjAwLCBtZXNzYWdlOiBcIlRyYW5zYWN0aW9uIFN1Y2Nlc3NmdWwuLi5cIiwgaGFzaDogdHguaGFzaCB9O1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gZmFpbGVkXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4geyBzdGF0dXM6IDUwMCwgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB8fCBlcnJvci5yZWFzb24gfTtcbiAgICB9XG4gIH0sIFttZXRhbWFza0RldGFpbHMuc2lnbmVyXSk7XG5cbiAgLy8gV2l0aGRyYXcgYXNzZXRcbiAgY29uc3QgV2l0aGRyYXdBc3NldCA9IHVzZUNhbGxiYWNrKGFzeW5jICh0b2tlbkFkZHJlc3MsIHdpdGhkcmF3QW1vdW50KSA9PiB7XG4gICAgaWYgKCFtZXRhbWFza0RldGFpbHMuc2lnbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0b2tlbkluZm8gPSBDT05GSUcuVE9LRU5TLmZpbmQodCA9PiB0LmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gdG9rZW5BZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKCF0b2tlbkluZm8pIHRocm93IG5ldyBFcnJvcihcIlRva2VuIG5vdCBmb3VuZFwiKTtcblxuICAgICAgY29uc3QgYW1vdW50ID0gZXRoZXJzLnBhcnNlVW5pdHMod2l0aGRyYXdBbW91bnQsIHRva2VuSW5mby5kZWNpbWFscyk7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IHdpdGhkcmF3VHgobWV0YW1hc2tEZXRhaWxzLnNpZ25lciwgdG9rZW5BZGRyZXNzLCBhbW91bnQpO1xuICAgICAgXG4gICAgICBpZiAodHgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJBc3NldCB3aXRoZHJhd24gc3VjY2Vzc2Z1bGx5OlwiLCB0b2tlbkFkZHJlc3MsIHdpdGhkcmF3QW1vdW50KTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAyMDAsIG1lc3NhZ2U6IFwiVHJhbnNhY3Rpb24gU3VjY2Vzc2Z1bC4uLlwiLCBoYXNoOiB0eC5oYXNoIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2FjdGlvbiBmYWlsZWRcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydEVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogNTAwLCBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8IGVycm9yLnJlYXNvbiB9O1xuICAgIH1cbiAgfSwgW21ldGFtYXNrRGV0YWlscy5zaWduZXJdKTtcblxuICAvLyBCb3Jyb3cgYXNzZXRcbiAgY29uc3QgYm9ycm93QXNzZXQgPSB1c2VDYWxsYmFjayhhc3luYyAodG9rZW4sIGJvcnJvd0Ftb3VudCkgPT4ge1xuICAgIGlmICghbWV0YW1hc2tEZXRhaWxzLnNpZ25lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmVyIGF2YWlsYWJsZVwiKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdG9rZW5JbmZvID0gQ09ORklHLlRPS0VOUy5maW5kKHQgPT4gdC5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IHRva2VuLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKCF0b2tlbkluZm8pIHRocm93IG5ldyBFcnJvcihcIlRva2VuIG5vdCBmb3VuZFwiKTtcblxuICAgICAgY29uc3QgYW1vdW50ID0gZXRoZXJzLnBhcnNlVW5pdHMoYm9ycm93QW1vdW50LCB0b2tlbkluZm8uZGVjaW1hbHMpO1xuICAgICAgY29uc3QgdHggPSBhd2FpdCBib3Jyb3dUeChtZXRhbWFza0RldGFpbHMuc2lnbmVyLCB0b2tlbiwgYW1vdW50KTtcbiAgICAgIFxuICAgICAgaWYgKHR4KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQXNzZXQgYm9ycm93ZWQgc3VjY2Vzc2Z1bGx5OlwiLCB0b2tlbiwgYm9ycm93QW1vdW50KTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAyMDAsIG1lc3NhZ2U6IFwiVHJhbnNhY3Rpb24gU3VjY2Vzc2Z1bC4uLlwiLCBoYXNoOiB0eC5oYXNoIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2FjdGlvbiBmYWlsZWRcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydEVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogNTAwLCBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8IGVycm9yLnJlYXNvbiB9O1xuICAgIH1cbiAgfSwgW21ldGFtYXNrRGV0YWlscy5zaWduZXJdKTtcblxuICAvLyBSZXBheSBhc3NldFxuICBjb25zdCByZXBheUFzc2V0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKHRva2VuQWRkcmVzcywgcmVwYXlBbW91bnQpID0+IHtcbiAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5zaWduZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRva2VuSW5mbyA9IENPTkZJRy5UT0tFTlMuZmluZCh0ID0+IHQuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSB0b2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICBpZiAoIXRva2VuSW5mbykgdGhyb3cgbmV3IEVycm9yKFwiVG9rZW4gbm90IGZvdW5kXCIpO1xuXG4gICAgICBjb25zdCBhbW91bnQgPSBldGhlcnMucGFyc2VVbml0cyhyZXBheUFtb3VudCwgdG9rZW5JbmZvLmRlY2ltYWxzKTtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcmVwYXlUeChtZXRhbWFza0RldGFpbHMuc2lnbmVyLCB0b2tlbkFkZHJlc3MsIGFtb3VudCk7XG4gICAgICBcbiAgICAgIGlmICh0eCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFzc2V0IHJlcGFpZCBzdWNjZXNzZnVsbHk6XCIsIHRva2VuQWRkcmVzcywgcmVwYXlBbW91bnQpO1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IDIwMCwgbWVzc2FnZTogXCJUcmFuc2FjdGlvbiBTdWNjZXNzZnVsLi4uXCIsIGhhc2g6IHR4Lmhhc2ggfTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIGZhaWxlZFwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiA1MDAsIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IucmVhc29uIH07XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnNpZ25lcl0pO1xuXG4gIC8vIEdldCBhY2NvdW50IGRhdGEgKGNvbGxhdGVyYWwsIGRlYnQsIGhlYWx0aCBmYWN0b3IpXG4gIGNvbnN0IGdldEFjY291bnREYXRhID0gdXNlQ2FsbGJhY2soYXN5bmMgKHVzZXIpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFtZXRhbWFza0RldGFpbHMucHJvdmlkZXIpIHJldHVybiBudWxsO1xuXG4gICAgICBjb25zdCBwb29sID0gbmV3IGV0aGVycy5Db250cmFjdChMZW5kaW5nUG9vbEFkZHJlc3MsIExlbmRpbmdQb29sQUJJLmFiaSwgbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyKTtcbiAgICAgIGNvbnN0IHdhbGxldCA9IHVzZXIgfHwgbWV0YW1hc2tEZXRhaWxzLmN1cnJlbnRBY2NvdW50IHx8IGV0aGVycy5aZXJvQWRkcmVzcztcbiAgICAgIFxuICAgICAgLy8gQWRkIGVycm9yIGhhbmRsaW5nIGZvciBlbXB0eSByZXNwb25zZVxuICAgICAgbGV0IGNvbCwgZGVidCwgaGY7XG4gICAgICB0cnkge1xuICAgICAgICBbY29sLCBkZWJ0LCBoZl0gPSBhd2FpdCBwb29sLmdldEFjY291bnREYXRhKHdhbGxldCk7XG4gICAgICB9IGNhdGNoIChjb250cmFjdEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCBnZXRBY2NvdW50RGF0YSBmYWlsZWQsIHVzaW5nIGRlZmF1bHRzOicsIGNvbnRyYWN0RXJyb3IubWVzc2FnZSk7XG4gICAgICAgIC8vIFJldHVybiBkZWZhdWx0IHZhbHVlcyBmb3IgbmV3IHVzZXJzXG4gICAgICAgIGNvbCA9IGV0aGVycy5wYXJzZVVuaXRzKFwiMFwiLCAxOCk7XG4gICAgICAgIGRlYnQgPSBldGhlcnMucGFyc2VVbml0cyhcIjBcIiwgMTgpO1xuICAgICAgICBoZiA9IGV0aGVycy5wYXJzZVVuaXRzKFwiMTE1NzkyMDg5MjM3MzE2MTk1NDIzNTcwOTg1MDA4Njg3OTA3ODUzMjY5OTg0NjY1NjQwNTY0MDM5NDU3LjU4NDAwNzkxMzEyOTYzOTkzNVwiLCAxOCk7IC8vIE1heCB1aW50MjU2XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGFjY291bnREYXRhID0ge1xuICAgICAgICBjb2xsYXRlcmFsVVNEOiBldGhlcnMuZm9ybWF0VW5pdHMoY29sLCAxOCksXG4gICAgICAgIGRlYnRVU0Q6IGV0aGVycy5mb3JtYXRVbml0cyhkZWJ0LCAxOCksXG4gICAgICAgIGhlYWx0aEZhY3RvcjogZXRoZXJzLmZvcm1hdFVuaXRzKGhmLCAxOClcbiAgICAgIH07XG5cbiAgICAgIHNldEFjY291bnREYXRhKGFjY291bnREYXRhKTtcbiAgICAgIHJldHVybiBhY2NvdW50RGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coJ2dldEFjY291bnREYXRhIGVycm9yLCB1c2luZyBkZWZhdWx0czonLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIC8vIFJldHVybiBkZWZhdWx0IHZhbHVlcyBvbiBhbnkgZXJyb3JcbiAgICAgIGNvbnN0IGFjY291bnREYXRhID0ge1xuICAgICAgICBjb2xsYXRlcmFsVVNEOiBcIjBcIixcbiAgICAgICAgZGVidFVTRDogXCIwXCIsIFxuICAgICAgICBoZWFsdGhGYWN0b3I6IFwiMTE1NzkyMDg5MjM3MzE2MTk1NDIzNTcwOTg1MDA4Njg3OTA3ODUzMjY5OTg0NjY1NjQwNTY0MDM5NDU3LjU4NDAwNzkxMzEyOTYzOTkzNVwiXG4gICAgICB9O1xuICAgICAgc2V0QWNjb3VudERhdGEoYWNjb3VudERhdGEpO1xuICAgICAgcmV0dXJuIGFjY291bnREYXRhO1xuICAgIH1cbiAgfSwgW21ldGFtYXNrRGV0YWlscy5wcm92aWRlciwgbWV0YW1hc2tEZXRhaWxzLmN1cnJlbnRBY2NvdW50XSk7XG5cbiAgLy8gR2V0IHlvdXIgc3VwcGxpZXNcbiAgY29uc3QgZ2V0WW91clN1cHBsaWVzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiMy4gR2V0dGluZyB5b3VyIHN1cHBsaWVzLi4uXCIpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5wcm92aWRlciB8fCAhbWV0YW1hc2tEZXRhaWxzLmN1cnJlbnRBY2NvdW50KSByZXR1cm4gW107XG5cbiAgICAgIGNvbnN0IGFiaSA9IFtcbiAgICAgICAgJ2Z1bmN0aW9uIGdldFVzZXJSZXNlcnZlKGFkZHJlc3MgdXNlciwgYWRkcmVzcyBhc3NldCkgdmlldyByZXR1cm5zICh0dXBsZSh1aW50MTI4IHByaW5jaXBhbCx1aW50MTI4IGluZGV4KSBzdXBwbHksIHR1cGxlKHVpbnQxMjggcHJpbmNpcGFsLHVpbnQxMjggaW5kZXgpIGJvcnJvdyknXG4gICAgICBdO1xuICAgICAgY29uc3QgcG9vbCA9IG5ldyBldGhlcnMuQ29udHJhY3QoQ09ORklHLkxFTkRJTkdfUE9PTCwgYWJpLCBtZXRhbWFza0RldGFpbHMucHJvdmlkZXIpO1xuXG4gICAgICBjb25zdCBzdXBwbGllcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBDT05GSUcuVE9LRU5TLmZpbHRlcih0ID0+ICF0LmlzTmF0aXZlKS5tYXAoYXN5bmMgKHRva2VuKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJSZXNlcnZlID0gYXdhaXQgcG9vbC5nZXRVc2VyUmVzZXJ2ZShtZXRhbWFza0RldGFpbHMuY3VycmVudEFjY291bnQsIHRva2VuLmFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3Qgc3VwcGx5UHJpbmNpcGFsID0gZXRoZXJzLmZvcm1hdFVuaXRzKHVzZXJSZXNlcnZlLnN1cHBseS5wcmluY2lwYWwsIDE4KTtcbiAgICAgICAgICAgIGNvbnN0IHN1cHBseUluZGV4ID0gdXNlclJlc2VydmUuc3VwcGx5LmluZGV4LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KHN1cHBseVByaW5jaXBhbCkgPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHByaWNlID0gYXdhaXQgZ2V0UHJpY2VVU0QodG9rZW4uYWRkcmVzcyk7XG4gICAgICAgICAgICAgIGNvbnN0IGJhbGFuY2VVU0QgPSBwYXJzZUZsb2F0KHN1cHBseVByaW5jaXBhbCkgKiBwYXJzZUZsb2F0KHByaWNlKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdG9rZW4uYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzeW1ib2w6IHRva2VuLnN5bWJvbCxcbiAgICAgICAgICAgICAgICBuYW1lOiB0b2tlbi5uYW1lLFxuICAgICAgICAgICAgICAgIGRlY2ltYWxzOiB0b2tlbi5kZWNpbWFscyxcbiAgICAgICAgICAgICAgICBzdXBwbHlQcmluY2lwYWw6IHN1cHBseVByaW5jaXBhbCxcbiAgICAgICAgICAgICAgICBzdXBwbHlJbmRleDogc3VwcGx5SW5kZXgsXG4gICAgICAgICAgICAgICAgYmFsYW5jZVVTRDogYmFsYW5jZVVTRCxcbiAgICAgICAgICAgICAgICBwcmljZVVTRDogcHJpY2UsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBFcnJvciBnZXR0aW5nIHN1cHBseSBmb3IgJHt0b2tlbi5zeW1ib2x9OmAsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHZhbGlkU3VwcGxpZXMgPSBzdXBwbGllcy5maWx0ZXIocyA9PiBzICE9PSBudWxsKTtcbiAgICAgIHNldFN1cHBseUFzc2V0cyh2YWxpZFN1cHBsaWVzKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHN1bW1hcnlcbiAgICAgIGNvbnN0IHRvdGFsVVNEQmFsYW5jZSA9IHZhbGlkU3VwcGxpZXMucmVkdWNlKChzdW0sIGFzc2V0KSA9PiBzdW0gKyBhc3NldC5iYWxhbmNlVVNELCAwKTtcbiAgICAgIGNvbnN0IHdlaWdodGVkQXZnQVBZID0gdmFsaWRTdXBwbGllcy5sZW5ndGggPiAwID8gXG4gICAgICAgIHZhbGlkU3VwcGxpZXMucmVkdWNlKChzdW0sIGFzc2V0KSA9PiBzdW0gKyAoYXNzZXQuYXB5IHx8IDApLCAwKSAvIHZhbGlkU3VwcGxpZXMubGVuZ3RoIDogMDtcbiAgICAgIGNvbnN0IHRvdGFsVVNEQ29sbGF0ZXJhbCA9IHZhbGlkU3VwcGxpZXMucmVkdWNlKChzdW0sIGFzc2V0KSA9PiBzdW0gKyBhc3NldC5iYWxhbmNlVVNELCAwKTtcblxuICAgICAgc2V0U3VwcGx5U3VtbWFyeSh7XG4gICAgICAgIHRvdGFsVVNEQmFsYW5jZSxcbiAgICAgICAgd2VpZ2h0ZWRBdmdBUFksXG4gICAgICAgIHRvdGFsVVNEQ29sbGF0ZXJhbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZyhcIkdvdCB5b3VyIHN1cHBsaWVzOlwiLCB2YWxpZFN1cHBsaWVzKTtcbiAgICAgIHJldHVybiB2YWxpZFN1cHBsaWVzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyLCBtZXRhbWFza0RldGFpbHMuY3VycmVudEFjY291bnQsIGdldFByaWNlVVNEXSk7XG5cbiAgLy8gR2V0IHlvdXIgYm9ycm93c1xuICBjb25zdCBnZXRZb3VyQm9ycm93cyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIjQuIEdldHRpbmcgeW91ciBib3Jyb3dzLi4uXCIpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5wcm92aWRlciB8fCAhbWV0YW1hc2tEZXRhaWxzLmN1cnJlbnRBY2NvdW50KSByZXR1cm4gW107XG5cbiAgICAgIGNvbnN0IGFiaSA9IFtcbiAgICAgICAgJ2Z1bmN0aW9uIGdldFVzZXJSZXNlcnZlKGFkZHJlc3MgdXNlciwgYWRkcmVzcyBhc3NldCkgdmlldyByZXR1cm5zICh0dXBsZSh1aW50MTI4IHByaW5jaXBhbCx1aW50MTI4IGluZGV4KSBzdXBwbHksIHR1cGxlKHVpbnQxMjggcHJpbmNpcGFsLHVpbnQxMjggaW5kZXgpIGJvcnJvdyknXG4gICAgICBdO1xuICAgICAgY29uc3QgcG9vbCA9IG5ldyBldGhlcnMuQ29udHJhY3QoQ09ORklHLkxFTkRJTkdfUE9PTCwgYWJpLCBtZXRhbWFza0RldGFpbHMucHJvdmlkZXIpO1xuXG4gICAgICBjb25zdCBib3Jyb3dzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIENPTkZJRy5UT0tFTlMuZmlsdGVyKHQgPT4gIXQuaXNOYXRpdmUpLm1hcChhc3luYyAodG9rZW4pID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXNlclJlc2VydmUgPSBhd2FpdCBwb29sLmdldFVzZXJSZXNlcnZlKG1ldGFtYXNrRGV0YWlscy5jdXJyZW50QWNjb3VudCwgdG9rZW4uYWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBib3Jyb3dQcmluY2lwYWwgPSBldGhlcnMuZm9ybWF0VW5pdHModXNlclJlc2VydmUuYm9ycm93LnByaW5jaXBhbCwgMTgpO1xuICAgICAgICAgICAgY29uc3QgYm9ycm93SW5kZXggPSB1c2VyUmVzZXJ2ZS5ib3Jyb3cuaW5kZXgudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQoYm9ycm93UHJpbmNpcGFsKSA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgcHJpY2UgPSBhd2FpdCBnZXRQcmljZVVTRCh0b2tlbi5hZGRyZXNzKTtcbiAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZVVTRCA9IHBhcnNlRmxvYXQoYm9ycm93UHJpbmNpcGFsKSAqIHBhcnNlRmxvYXQocHJpY2UpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0b2tlbi5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIHN5bWJvbDogdG9rZW4uc3ltYm9sLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRva2VuLm5hbWUsXG4gICAgICAgICAgICAgICAgZGVjaW1hbHM6IHRva2VuLmRlY2ltYWxzLFxuICAgICAgICAgICAgICAgIGJvcnJvd1ByaW5jaXBhbDogYm9ycm93UHJpbmNpcGFsLFxuICAgICAgICAgICAgICAgIGJvcnJvd0luZGV4OiBib3Jyb3dJbmRleCxcbiAgICAgICAgICAgICAgICBiYWxhbmNlVVNEOiBiYWxhbmNlVVNELFxuICAgICAgICAgICAgICAgIHByaWNlVVNEOiBwcmljZSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEVycm9yIGdldHRpbmcgYm9ycm93IGZvciAke3Rva2VuLnN5bWJvbH06YCwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgY29uc3QgdmFsaWRCb3Jyb3dzID0gYm9ycm93cy5maWx0ZXIoYiA9PiBiICE9PSBudWxsKTtcbiAgICAgIHNldFlvdXJCb3Jyb3dzKHZhbGlkQm9ycm93cyk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBzdW1tYXJ5XG4gICAgICBjb25zdCB0b3RhbFVTREJhbGFuY2UgPSB2YWxpZEJvcnJvd3MucmVkdWNlKChzdW0sIGFzc2V0KSA9PiBzdW0gKyBhc3NldC5iYWxhbmNlVVNELCAwKTtcbiAgICAgIGNvbnN0IHdlaWdodGVkQXZnQVBZID0gdmFsaWRCb3Jyb3dzLmxlbmd0aCA+IDAgPyBcbiAgICAgICAgdmFsaWRCb3Jyb3dzLnJlZHVjZSgoc3VtLCBhc3NldCkgPT4gc3VtICsgKGFzc2V0LmFweSB8fCAwKSwgMCkgLyB2YWxpZEJvcnJvd3MubGVuZ3RoIDogMDtcbiAgICAgIGNvbnN0IHRvdGFsQm9ycm93UG93ZXJVc2VkID0gdG90YWxVU0RCYWxhbmNlO1xuXG4gICAgICBzZXRCb3Jyb3dTdW1tYXJ5KHtcbiAgICAgICAgdG90YWxVU0RCYWxhbmNlLFxuICAgICAgICB3ZWlnaHRlZEF2Z0FQWSxcbiAgICAgICAgdG90YWxCb3Jyb3dQb3dlclVzZWQsXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coXCJHb3QgeW91ciBib3Jyb3dzOlwiLCB2YWxpZEJvcnJvd3MpO1xuICAgICAgcmV0dXJuIHZhbGlkQm9ycm93cztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSwgW21ldGFtYXNrRGV0YWlscy5wcm92aWRlciwgbWV0YW1hc2tEZXRhaWxzLmN1cnJlbnRBY2NvdW50LCBnZXRQcmljZVVTRF0pO1xuXG4gIC8vIEdldCBhc3NldHMgdG8gYm9ycm93XG4gIGNvbnN0IGdldEFzc2V0c1RvQm9ycm93ID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiNS4gR2V0dGluZyBhc3NldHMgdG8gYm9ycm93Li4uXCIpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5wcm92aWRlcikgcmV0dXJuIFtdO1xuXG4gICAgICBjb25zdCBhYmkgPSBbXG4gICAgICAgICdmdW5jdGlvbiByZXNlcnZlcyhhZGRyZXNzKSB2aWV3IHJldHVybnMgKHVpbnQxMjggcmVzZXJ2ZUNhc2gsIHVpbnQxMjggdG90YWxEZWJ0UHJpbmNpcGFsLCB1aW50MTI4IGxpcXVpZGl0eUluZGV4LCB1aW50MTI4IHZhcmlhYmxlQm9ycm93SW5kZXgsIHVpbnQ2NCBsaXF1aWRpdHlSYXRlUmF5UGVyU2VjLCB1aW50NjQgdmFyaWFibGVCb3Jyb3dSYXRlUmF5UGVyU2VjLCB1aW50MTYgcmVzZXJ2ZUZhY3RvckJwcywgdWludDE2IGx0dkJwcywgdWludDE2IGxpcVRocmVzaG9sZEJwcywgdWludDE2IGxpcUJvbnVzQnBzLCB1aW50MTYgY2xvc2VGYWN0b3JCcHMsIHVpbnQ4IGRlY2ltYWxzLCBib29sIGlzQm9ycm93YWJsZSwgdWludDE2IG9wdGltYWxVQnBzLCB1aW50NjQgYmFzZVJhdGVSYXlQZXJTZWMsIHVpbnQ2NCBzbG9wZTFSYXlQZXJTZWMsIHVpbnQ2NCBzbG9wZTJSYXlQZXJTZWMsIHVpbnQ0MCBsYXN0VXBkYXRlKSdcbiAgICAgIF07XG4gICAgICBjb25zdCBwb29sID0gbmV3IGV0aGVycy5Db250cmFjdChDT05GSUcuTEVORElOR19QT09MLCBhYmksIG1ldGFtYXNrRGV0YWlscy5wcm92aWRlcik7XG5cbiAgICAgIGNvbnN0IGFzc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBDT05GSUcuVE9LRU5TLmZpbHRlcih0ID0+ICF0LmlzTmF0aXZlKS5tYXAoYXN5bmMgKHRva2VuKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc2VydmUgPSBhd2FpdCBwb29sLnJlc2VydmVzKHRva2VuLmFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgaXNCb3Jyb3dhYmxlID0gQm9vbGVhbihyZXNlcnZlLmlzQm9ycm93YWJsZSk7XG4gICAgICAgICAgICBjb25zdCByZXNlcnZlQ2FzaCA9IGV0aGVycy5mb3JtYXRVbml0cyhyZXNlcnZlLnJlc2VydmVDYXNoLCAxOCk7XG4gICAgICAgICAgICBjb25zdCBwcmljZSA9IGF3YWl0IGdldFByaWNlVVNEKHRva2VuLmFkZHJlc3MpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaXNCb3Jyb3dhYmxlICYmIHBhcnNlRmxvYXQocmVzZXJ2ZUNhc2gpID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRva2VuLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgc3ltYm9sOiB0b2tlbi5zeW1ib2wsXG4gICAgICAgICAgICAgICAgbmFtZTogdG9rZW4ubmFtZSxcbiAgICAgICAgICAgICAgICBkZWNpbWFsczogdG9rZW4uZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgcmVzZXJ2ZUNhc2g6IHJlc2VydmVDYXNoLFxuICAgICAgICAgICAgICAgIGlzQm9ycm93YWJsZTogaXNCb3Jyb3dhYmxlLFxuICAgICAgICAgICAgICAgIHByaWNlVVNEOiBwcmljZSxcbiAgICAgICAgICAgICAgICBsdHZCcHM6IE51bWJlcihyZXNlcnZlLmx0dkJwcyksXG4gICAgICAgICAgICAgICAgbGlxVGhyZXNob2xkQnBzOiBOdW1iZXIocmVzZXJ2ZS5saXFUaHJlc2hvbGRCcHMpLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRXJyb3IgZ2V0dGluZyBib3Jyb3cgYXNzZXQgJHt0b2tlbi5zeW1ib2x9OmAsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHZhbGlkQXNzZXRzID0gYXNzZXRzLmZpbHRlcihhID0+IGEgIT09IG51bGwpO1xuICAgICAgc2V0QXNzZXRzVG9Cb3Jyb3codmFsaWRBc3NldHMpO1xuICAgICAgY29uc29sZS5sb2coXCJHb3QgYXNzZXRzIHRvIGJvcnJvdzpcIiwgdmFsaWRBc3NldHMpO1xuICAgICAgcmV0dXJuIHZhbGlkQXNzZXRzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyLCBnZXRQcmljZVVTRF0pO1xuXG4gIC8vIFdyYXAgRVRIIHRvIFdFVEhcbiAgY29uc3Qgd3JhcEV0aCA9IHVzZUNhbGxiYWNrKGFzeW5jIChhbW91bnRFdGgpID0+IHtcbiAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5zaWduZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSAnMHhkMGUzMGRiMCc7IC8vIGRlcG9zaXQoKVxuICAgICAgY29uc29sZS5sb2coJ3dyYXBFdGgg4oaSIHVzaW5nIFdFVEggYWRkcmVzczonLCBXRVRIQWRkcmVzcyk7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IG1ldGFtYXNrRGV0YWlscy5zaWduZXIuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgdG86IFdFVEhBZGRyZXNzLFxuICAgICAgICB2YWx1ZTogZXRoZXJzLnBhcnNlRXRoZXIoYW1vdW50RXRoKSxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgICBjb25zb2xlLmxvZyhcIkVUSCB3cmFwcGVkIHRvIFdFVEg6XCIsIGFtb3VudEV0aCk7XG4gICAgICByZXR1cm4geyBzdGF0dXM6IDIwMCwgbWVzc2FnZTogXCJUcmFuc2FjdGlvbiBTdWNjZXNzZnVsLi4uXCIsIGhhc2g6IHR4Lmhhc2ggfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiA1MDAsIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IucmVhc29uIH07XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnNpZ25lcl0pO1xuXG4gIC8vIFVud3JhcCBXRVRIIHRvIEVUSFxuICBjb25zdCB1bndyYXBXZXRoID0gdXNlQ2FsbGJhY2soYXN5bmMgKGFtb3VudEV0aCkgPT4ge1xuICAgIGlmICghbWV0YW1hc2tEZXRhaWxzLnNpZ25lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmVyIGF2YWlsYWJsZVwiKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYWJpID0gWydmdW5jdGlvbiB3aXRoZHJhdyh1aW50MjU2IHdhZCknXTtcbiAgICAgIGNvbnNvbGUubG9nKCd1bndyYXBXZXRoIOKGkiB1c2luZyBXRVRIIGFkZHJlc3M6JywgV0VUSEFkZHJlc3MpO1xuICAgICAgY29uc3Qgd2V0aCA9IG5ldyBldGhlcnMuQ29udHJhY3QoV0VUSEFkZHJlc3MsIGFiaSwgbWV0YW1hc2tEZXRhaWxzLnNpZ25lcik7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IHdldGgud2l0aGRyYXcoZXRoZXJzLnBhcnNlRXRoZXIoYW1vdW50RXRoKSk7XG4gICAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgICBjb25zb2xlLmxvZyhcIldFVEggdW53cmFwcGVkIHRvIEVUSDpcIiwgYW1vdW50RXRoKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogMjAwLCBtZXNzYWdlOiBcIlRyYW5zYWN0aW9uIFN1Y2Nlc3NmdWwuLi5cIiwgaGFzaDogdHguaGFzaCB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4geyBzdGF0dXM6IDUwMCwgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB8fCBlcnJvci5yZWFzb24gfTtcbiAgICB9XG4gIH0sIFttZXRhbWFza0RldGFpbHMuc2lnbmVyXSk7XG5cbiAgLy8gV2l0aGRyYXcgdG9rZW4gdG8gRVRIIChmb3IgYWxsIHRva2VucyB3aXRoIHdpdGhkcmF3IGZ1bmN0aW9uKVxuICBjb25zdCB3aXRoZHJhd1Rva2VuID0gdXNlQ2FsbGJhY2soYXN5bmMgKHRva2VuQWRkcmVzcywgYW1vdW50KSA9PiB7XG4gICAgaWYgKCFtZXRhbWFza0RldGFpbHMuc2lnbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBhYmkgPSBbJ2Z1bmN0aW9uIHdpdGhkcmF3KHVpbnQyNTYgYW1vdW50KSddO1xuICAgICAgY29uc29sZS5sb2coJ3dpdGhkcmF3VG9rZW4g4oaSIHVzaW5nIGFkZHJlc3M6JywgdG9rZW5BZGRyZXNzKTtcbiAgICAgIGNvbnN0IHRva2VuID0gbmV3IGV0aGVycy5Db250cmFjdCh0b2tlbkFkZHJlc3MsIGFiaSwgbWV0YW1hc2tEZXRhaWxzLnNpZ25lcik7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IHRva2VuLndpdGhkcmF3KGV0aGVycy5wYXJzZUV0aGVyKGFtb3VudCkpO1xuICAgICAgYXdhaXQgdHgud2FpdCgpO1xuICAgICAgY29uc29sZS5sb2coXCJUb2tlbiB3aXRoZHJhd24gdG8gRVRIOlwiLCBhbW91bnQpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiAyMDAsIG1lc3NhZ2U6IFwiV2l0aGRyYXcgU3VjY2Vzc2Z1bC4uLlwiLCBoYXNoOiB0eC5oYXNoIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydEVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogNTAwLCBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8IGVycm9yLnJlYXNvbiB9O1xuICAgIH1cbiAgfSwgW21ldGFtYXNrRGV0YWlscy5zaWduZXJdKTtcblxuICAvLyBEZXBvc2l0IEVUSCB0byBnZXQgdG9rZW4gKGZvciBhbGwgdG9rZW5zIHdpdGggZGVwb3NpdCBmdW5jdGlvbilcbiAgY29uc3QgZGVwb3NpdFRvVG9rZW4gPSB1c2VDYWxsYmFjayhhc3luYyAodG9rZW5BZGRyZXNzLCBhbW91bnRFdGgpID0+IHtcbiAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5zaWduZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFiaSA9IFsnZnVuY3Rpb24gZGVwb3NpdCgpIHBheWFibGUnXTtcbiAgICAgIGNvbnNvbGUubG9nKCdkZXBvc2l0VG9Ub2tlbiDihpIgdXNpbmcgYWRkcmVzczonLCB0b2tlbkFkZHJlc3MpO1xuICAgICAgY29uc3QgdG9rZW4gPSBuZXcgZXRoZXJzLkNvbnRyYWN0KHRva2VuQWRkcmVzcywgYWJpLCBtZXRhbWFza0RldGFpbHMuc2lnbmVyKTtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdG9rZW4uZGVwb3NpdCh7IHZhbHVlOiBldGhlcnMucGFyc2VFdGhlcihhbW91bnRFdGgpIH0pO1xuICAgICAgYXdhaXQgdHgud2FpdCgpO1xuICAgICAgY29uc29sZS5sb2coXCJFVEggZGVwb3NpdGVkIHRvIHRva2VuOlwiLCBhbW91bnRFdGgpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiAyMDAsIG1lc3NhZ2U6IFwiRGVwb3NpdCBTdWNjZXNzZnVsLi4uXCIsIGhhc2g6IHR4Lmhhc2ggfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiA1MDAsIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IucmVhc29uIH07XG4gICAgfVxuICB9LCBbbWV0YW1hc2tEZXRhaWxzLnNpZ25lcl0pO1xuXG4gIC8vIFJlZnJlc2ggYWxsIGRhdGFcbiAgY29uc3QgcmVmcmVzaCA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBnZXRVc2VyQXNzZXRzKCksXG4gICAgICAgIGdldFlvdXJTdXBwbGllcygpLFxuICAgICAgICBnZXRZb3VyQm9ycm93cygpLFxuICAgICAgICBnZXRBc3NldHNUb0JvcnJvdygpLFxuICAgICAgICBnZXRBY2NvdW50RGF0YSgpLFxuICAgICAgXSk7XG4gICAgICBjb25zb2xlLmxvZyhcIkFsbCBkYXRhIHJlZnJlc2hlZFwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSwgW2dldFVzZXJBc3NldHMsIGdldFlvdXJTdXBwbGllcywgZ2V0WW91ckJvcnJvd3MsIGdldEFzc2V0c1RvQm9ycm93LCBnZXRBY2NvdW50RGF0YV0pO1xuXG4gIC8vIFVwZGF0ZSBpbnRlcmVzdHMgKGFjY3J1ZSlcbiAgY29uc3QgdXBkYXRlSW50ZXJlc3RzID0gdXNlQ2FsbGJhY2soYXN5bmMgKGFzc2V0KSA9PiB7XG4gICAgaWYgKCFtZXRhbWFza0RldGFpbHMuc2lnbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBhYmkgPSBbJ2Z1bmN0aW9uIGFjY3J1ZVB1YmxpYyhhZGRyZXNzIGFzc2V0KSddO1xuICAgICAgY29uc3QgcG9vbCA9IG5ldyBldGhlcnMuQ29udHJhY3QoQ09ORklHLkxFTkRJTkdfUE9PTCwgYWJpLCBtZXRhbWFza0RldGFpbHMuc2lnbmVyKTtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcG9vbC5hY2NydWVQdWJsaWMoYXNzZXQpO1xuICAgICAgYXdhaXQgdHgud2FpdCgpO1xuICAgICAgY29uc29sZS5sb2coXCJJbnRlcmVzdHMgdXBkYXRlZCBmb3IgYXNzZXQ6XCIsIGFzc2V0KTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogMjAwLCBtZXNzYWdlOiBcIlRyYW5zYWN0aW9uIFN1Y2Nlc3NmdWwuLi5cIiB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4geyBzdGF0dXM6IDUwMCwgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB8fCBlcnJvci5yZWFzb24gfTtcbiAgICB9XG4gIH0sIFttZXRhbWFza0RldGFpbHMuc2lnbmVyXSk7XG5cbiAgLy8gR2V0IHVzZXIgdG90YWwgYXZhaWxhYmxlIGJhbGFuY2VcbiAgY29uc3QgZ2V0VXNlclRvdGFsQXZhaWxhYmxlQmFsYW5jZSA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFtZXRhbWFza0RldGFpbHMucHJvdmlkZXIgfHwgIW1ldGFtYXNrRGV0YWlscy5jdXJyZW50QWNjb3VudCkgcmV0dXJuIDA7XG5cbiAgICAgIGNvbnN0IGFiaSA9IFtcbiAgICAgICAgJ2Z1bmN0aW9uIGdldFVzZXJUb3RhbEF2YWlsYWJsZUJhbGFuY2VJblVTRChhZGRyZXNzIHVzZXIsIHVpbnQyNTYgYXNzZXRUeXBlKSB2aWV3IHJldHVybnMgKHVpbnQyNTYpJ1xuICAgICAgXTtcbiAgICAgIGNvbnN0IHBvb2wgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KENPTkZJRy5MRU5ESU5HX1BPT0wsIGFiaSwgbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyKTtcbiAgICAgIGNvbnN0IG1heEFtb3VudCA9IGF3YWl0IHBvb2wuZ2V0VXNlclRvdGFsQXZhaWxhYmxlQmFsYW5jZUluVVNEKG1ldGFtYXNrRGV0YWlscy5jdXJyZW50QWNjb3VudCwgMSk7XG4gICAgICByZXR1cm4gTnVtYmVyKGV0aGVycy5mb3JtYXRVbml0cyhtYXhBbW91bnQsIDE4KSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydEVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSwgW21ldGFtYXNrRGV0YWlscy5wcm92aWRlciwgbWV0YW1hc2tEZXRhaWxzLmN1cnJlbnRBY2NvdW50XSk7XG5cbiAgLy8gR2V0IHRva2VucyBwZXIgVVNEIGFtb3VudFxuICBjb25zdCBnZXRUb2tlbnNQZXJVU0RBbW91bnQgPSB1c2VDYWxsYmFjayhhc3luYyAodG9rZW4sIGFtb3VudCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW1ldGFtYXNrRGV0YWlscy5wcm92aWRlcikgcmV0dXJuIDA7XG5cbiAgICAgIGNvbnN0IGFiaSA9IFtcbiAgICAgICAgJ2Z1bmN0aW9uIGdldFRva2Vuc1BlclVTREFtb3VudChhZGRyZXNzIHRva2VuLCB1aW50MjU2IGFtb3VudCkgdmlldyByZXR1cm5zICh1aW50MjU2KSdcbiAgICAgIF07XG4gICAgICBjb25zdCBoZWxwZXIgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KENPTkZJRy5QUklDRV9PUkFDTEUsIGFiaSwgbWV0YW1hc2tEZXRhaWxzLnByb3ZpZGVyKTtcbiAgICAgIGNvbnN0IG1heFF0eSA9IGF3YWl0IGhlbHBlci5nZXRUb2tlbnNQZXJVU0RBbW91bnQodG9rZW4sIGV0aGVycy5wYXJzZVVuaXRzKGFtb3VudC50b1N0cmluZygpLCAxOCkpO1xuICAgICAgcmV0dXJuIE51bWJlcihldGhlcnMuZm9ybWF0VW5pdHMobWF4UXR5LCAxOCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sIFttZXRhbWFza0RldGFpbHMucHJvdmlkZXJdKTtcblxuICAvLyBPYmplY3RpZnkgc3VwcGxpZWQgYXNzZXRzIChmb3JtYXQgZGF0YSlcbiAgY29uc3Qgb2JqZWN0aWZ5U3VwcGxpZWRBc3NldHMgPSB1c2VDYWxsYmFjayhhc3luYyAoYXNzZXRzKSA9PiB7XG4gICAgY29uc3QgYXNzZXRzTGlzdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXNzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IGFzc2V0c1tpXS50b2tlbjtcbiAgICAgIGxldCBsZW5kUXR5ID0gYXNzZXRzW2ldLmxlbnRRdHk7XG5cbiAgICAgIGNvbnN0IGFtb3VudEluVVNEID0gYXdhaXQgZ2V0QW1vdW50SW5VU0QodG9rZW4sIGxlbmRRdHkpO1xuICAgICAgbGVuZFF0eSA9IE51bWJlcihhc3NldHNbaV0ubGVudFF0eSkgLyAxZTE4O1xuXG4gICAgICBjb25zdCBtYXhTdXBwbHlBbW91bnQgPSBhd2FpdCBnZXRVc2VyVG90YWxBdmFpbGFibGVCYWxhbmNlKCk7XG4gICAgICBjb25zdCBtYXhRdHkgPSBhd2FpdCBnZXRUb2tlbnNQZXJVU0RBbW91bnQodG9rZW4sIG1heFN1cHBseUFtb3VudCk7XG4gICAgICBjb25zdCBxdHkgPSBsZW5kUXR5IDw9IG1heFF0eSA/IGxlbmRRdHkgOiBtYXhRdHk7XG5cbiAgICAgIGFzc2V0c0xpc3QucHVzaCh7XG4gICAgICAgIHRva2VuOiBhc3NldHNbaV0udG9rZW4sXG4gICAgICAgIGJhbGFuY2U6IGxlbmRRdHksXG4gICAgICAgIGFweTogTnVtYmVyKGFzc2V0c1tpXS5sZW50QXB5KSxcbiAgICAgICAgYmFsYW5jZUluVVNEOiBhbW91bnRJblVTRCxcbiAgICAgICAgbWF4U3VwcGx5OiBxdHksXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc2V0c0xpc3Q7XG4gIH0sIFtnZXRBbW91bnRJblVTRCwgZ2V0VXNlclRvdGFsQXZhaWxhYmxlQmFsYW5jZSwgZ2V0VG9rZW5zUGVyVVNEQW1vdW50XSk7XG5cbiAgLy8gT2JqZWN0aWZ5IGJvcnJvd2VkIGFzc2V0cyAoZm9ybWF0IGRhdGEpXG4gIGNvbnN0IG9iamVjdGlmeUJvcnJvd2VkQXNzZXRzID0gdXNlQ2FsbGJhY2soYXN5bmMgKGFzc2V0cykgPT4ge1xuICAgIGNvbnN0IGJvcnJvd3NMaXN0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRva2VuID0gYXNzZXRzW2ldLnRva2VuO1xuICAgICAgY29uc3QgYm9ycm93UXR5ID0gYXNzZXRzW2ldLmJvcnJvd1F0eTtcbiAgICAgIGNvbnN0IGJvcnJvd0FweSA9IGFzc2V0c1tpXS5ib3Jyb3dBcHk7XG4gICAgICBjb25zdCBhbW91bnRJblVTRCA9IGF3YWl0IGdldEFtb3VudEluVVNEKHRva2VuLCBib3Jyb3dRdHkpO1xuICAgICAgXG4gICAgICBib3Jyb3dzTGlzdC5wdXNoKHtcbiAgICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgICBib3Jyb3dRdHk6IE51bWJlcihib3Jyb3dRdHkpLFxuICAgICAgICBib3Jyb3dBcHk6IE51bWJlcihib3Jyb3dBcHkpLFxuICAgICAgICBib3Jyb3dlZEJhbEluVVNEOiBhbW91bnRJblVTRCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYm9ycm93c0xpc3Q7XG4gIH0sIFtnZXRBbW91bnRJblVTRF0pO1xuXG4gIC8vIE1lcmdlIG9iamVjdGlmaWVkIGFzc2V0cyB3aXRoIHRva2VuIGluZm9cbiAgY29uc3QgbWVyZ2VPYmplY3RpZmllZEFzc2V0cyA9IHVzZUNhbGxiYWNrKChhc3NldHMpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBDT05GSUcuVE9LRU5TXG4gICAgICAuZmlsdGVyKCh0b2tlbkxpc3QpID0+IHtcbiAgICAgICAgcmV0dXJuIGFzc2V0cy5zb21lKChhc3NldExpc3QpID0+IHtcbiAgICAgICAgICByZXR1cm4gdG9rZW5MaXN0LmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYXNzZXRMaXN0LnRva2VuLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgIC5tYXAoKGFzc2V0T2JqKSA9PiAoe1xuICAgICAgICAuLi5hc3NldHMuZmluZCgoaXRlbSkgPT4gaXRlbS50b2tlbi50b0xvd2VyQ2FzZSgpID09PSBhc3NldE9iai5hZGRyZXNzLnRvTG93ZXJDYXNlKCkpLFxuICAgICAgICAuLi5hc3NldE9iaixcbiAgICAgIH0pKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBbXSk7XG5cbiAgLy8gQ29udGV4dCB2YWx1ZVxuICBjb25zdCBjb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgLy8gU3RhdGVcbiAgICBtZXRhbWFza0RldGFpbHMsXG4gICAgdXNlckFzc2V0cyxcbiAgICBzdXBwbHlBc3NldHMsXG4gICAgYXNzZXRzVG9Cb3Jyb3csXG4gICAgeW91ckJvcnJvd3MsXG4gICAgc3VwcGx5U3VtbWFyeSxcbiAgICBib3Jyb3dTdW1tYXJ5LFxuICAgIGFjY291bnREYXRhLFxuICAgIGNvbnRyYWN0LFxuXG4gICAgLy8gV2FsbGV0IGZ1bmN0aW9uc1xuICAgIGNvbm5lY3RXYWxsZXQsXG4gICAgcmVmcmVzaCxcblxuICAgIC8vIEFzc2V0IGZ1bmN0aW9uc1xuICAgIGdldFVzZXJBc3NldHMsXG4gICAgZ2V0WW91clN1cHBsaWVzLFxuICAgIGdldFlvdXJCb3Jyb3dzLFxuICAgIGdldEFzc2V0c1RvQm9ycm93LFxuXG4gICAgLy8gVHJhbnNhY3Rpb24gZnVuY3Rpb25zXG4gICAgQXBwcm92ZVRvQ29udGludWUsXG4gICAgTGVuZEFzc2V0LFxuICAgIFdpdGhkcmF3QXNzZXQsXG4gICAgYm9ycm93QXNzZXQsXG4gICAgcmVwYXlBc3NldCxcblxuICAgIC8vIFV0aWxpdHkgZnVuY3Rpb25zXG4gICAgZ2V0Q29udHJhY3QsXG4gICAgZ2V0UHJpY2VVU0QsXG4gICAgZ2V0QW1vdW50SW5VU0QsXG4gICAgbnVtYmVyVG9FdGhlcnMsXG4gICAgcmVwb3J0RXJyb3IsXG5cbiAgICAvLyBFVEgvV0VUSCBmdW5jdGlvbnNcbiAgICB3cmFwRXRoLFxuICAgIHVud3JhcFdldGgsXG5cbiAgICAvLyBBY2NvdW50IGZ1bmN0aW9uc1xuICAgIGdldEFjY291bnREYXRhLFxuICAgIGdldFVzZXJUb3RhbEF2YWlsYWJsZUJhbGFuY2UsXG4gICAgZ2V0VG9rZW5zUGVyVVNEQW1vdW50LFxuXG4gICAgLy8gRGF0YSBwcm9jZXNzaW5nIGZ1bmN0aW9uc1xuICAgIG9iamVjdGlmeVN1cHBsaWVkQXNzZXRzLFxuICAgIG9iamVjdGlmeUJvcnJvd2VkQXNzZXRzLFxuICAgIG1lcmdlT2JqZWN0aWZpZWRBc3NldHMsXG5cbiAgICAvLyBJbnRlcmVzdCBmdW5jdGlvbnNcbiAgICB1cGRhdGVJbnRlcmVzdHMsXG5cbiAgICAvLyBUb2tlbiB3aXRoZHJhdy9kZXBvc2l0IGZ1bmN0aW9uc1xuICAgIHdpdGhkcmF3VG9rZW4sXG4gICAgZGVwb3NpdFRvVG9rZW4sXG4gIH0pLCBbXG4gICAgbWV0YW1hc2tEZXRhaWxzLFxuICAgIHVzZXJBc3NldHMsXG4gICAgc3VwcGx5QXNzZXRzLFxuICAgIGFzc2V0c1RvQm9ycm93LFxuICAgIHlvdXJCb3Jyb3dzLFxuICAgIHN1cHBseVN1bW1hcnksXG4gICAgYm9ycm93U3VtbWFyeSxcbiAgICBhY2NvdW50RGF0YSxcbiAgICBjb250cmFjdCxcbiAgICBjb25uZWN0V2FsbGV0LFxuICAgIHJlZnJlc2gsXG4gICAgZ2V0VXNlckFzc2V0cyxcbiAgICBnZXRZb3VyU3VwcGxpZXMsXG4gICAgZ2V0WW91ckJvcnJvd3MsXG4gICAgZ2V0QXNzZXRzVG9Cb3Jyb3csXG4gICAgQXBwcm92ZVRvQ29udGludWUsXG4gICAgTGVuZEFzc2V0LFxuICAgIFdpdGhkcmF3QXNzZXQsXG4gICAgYm9ycm93QXNzZXQsXG4gICAgcmVwYXlBc3NldCxcbiAgICBnZXRDb250cmFjdCxcbiAgICBnZXRQcmljZVVTRCxcbiAgICBnZXRBbW91bnRJblVTRCxcbiAgICB3cmFwRXRoLFxuICAgIHVud3JhcFdldGgsXG4gICAgZ2V0QWNjb3VudERhdGEsXG4gICAgZ2V0VXNlclRvdGFsQXZhaWxhYmxlQmFsYW5jZSxcbiAgICBnZXRUb2tlbnNQZXJVU0RBbW91bnQsXG4gICAgb2JqZWN0aWZ5U3VwcGxpZWRBc3NldHMsXG4gICAgb2JqZWN0aWZ5Qm9ycm93ZWRBc3NldHMsXG4gICAgbWVyZ2VPYmplY3RpZmllZEFzc2V0cyxcbiAgICB1cGRhdGVJbnRlcmVzdHMsXG4gIF0pO1xuXG4gIHJldHVybiAoXG4gICAgPGxlbmRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0VmFsdWV9PlxuICAgICAge3Byb3BzLmNoaWxkcmVufVxuICAgIDwvbGVuZENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBMZW5kU3RhdGU7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlTWVtbyIsImxlbmRDb250ZXh0IiwiZXRoZXJzIiwiQ09ORklHIiwiZ2V0VG9rZW5CYWxhbmNlIiwiZ2V0VG9rZW5BbGxvd2FuY2UiLCJhcHByb3ZlSWZOZWVkZWQiLCJsZW5kIiwibGVuZFR4Iiwid2l0aGRyYXciLCJ3aXRoZHJhd1R4IiwiYm9ycm93IiwiYm9ycm93VHgiLCJyZXBheSIsInJlcGF5VHgiLCJFVEhBZGRyZXNzIiwiTGVuZGluZ1Bvb2xBZGRyZXNzIiwiTGVuZGluZ0hlbHBlckFkZHJlc3MiLCJXRVRIQWRkcmVzcyIsIlRva2VuQUJJIiwiTGVuZGluZ1Bvb2xBQkkiLCJMZW5kaW5nSGVscGVyQUJJIiwibnVtYmVyVG9FdGhlcnMiLCJudW1iZXIiLCJwYXJzZUV0aGVyIiwidG9TdHJpbmciLCJyZXBvcnRFcnJvciIsImVycm9yIiwiY29uc29sZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJMZW5kU3RhdGUiLCJwcm9wcyIsIm1ldGFtYXNrRGV0YWlscyIsInNldE1ldGFtYXNrRGV0YWlscyIsInByb3ZpZGVyIiwibmV0d29ya05hbWUiLCJzaWduZXIiLCJjdXJyZW50QWNjb3VudCIsImNoYWluSWQiLCJ1c2VyQXNzZXRzIiwic2V0VXNlckFzc2V0cyIsInN1cHBseUFzc2V0cyIsInNldFN1cHBseUFzc2V0cyIsImFzc2V0c1RvQm9ycm93Iiwic2V0QXNzZXRzVG9Cb3Jyb3ciLCJ5b3VyQm9ycm93cyIsInNldFlvdXJCb3Jyb3dzIiwiY29udHJhY3QiLCJzZXRDb250cmFjdCIsImxlbmRpbmdQb29sQ29udHJhY3QiLCJvcmFjbGVDb250cmFjdCIsInN1cHBseVN1bW1hcnkiLCJzZXRTdXBwbHlTdW1tYXJ5IiwidG90YWxVU0RCYWxhbmNlIiwid2VpZ2h0ZWRBdmdBUFkiLCJ0b3RhbFVTRENvbGxhdGVyYWwiLCJib3Jyb3dTdW1tYXJ5Iiwic2V0Qm9ycm93U3VtbWFyeSIsInRvdGFsQm9ycm93UG93ZXJVc2VkIiwiYWNjb3VudERhdGEiLCJzZXRBY2NvdW50RGF0YSIsImNvbGxhdGVyYWxVU0QiLCJkZWJ0VVNEIiwiaGVhbHRoRmFjdG9yIiwiY29ubmVjdFdhbGxldCIsImxvZyIsImV0aGVyZXVtIiwid2luZG93IiwiZmFpbE1lc3NhZ2UiLCJhbGVydCIsImFjY291bnRzIiwicmVxdWVzdCIsIm1ldGhvZCIsIm9uIiwibG9jYXRpb24iLCJyZWxvYWQiLCJCcm93c2VyUHJvdmlkZXIiLCJuZXR3b3JrIiwiZ2V0TmV0d29yayIsIm5hbWUiLCJnZXRTaWduZXIiLCJsZW5ndGgiLCJjdXJyZW50QWRkcmVzcyIsIk51bWJlciIsImdldENvbnRyYWN0IiwiYWRkcmVzcyIsImFiaSIsIkNvbnRyYWN0IiwiZ2V0VXNlckFzc2V0cyIsImFzc2V0cyIsIlByb21pc2UiLCJhbGwiLCJUT0tFTlMiLCJtYXAiLCJ0b2tlbiIsImJhbGFuY2UiLCJiYWxhbmNlVVNEIiwiaXNOYXRpdmUiLCJiYWwiLCJnZXRCYWxhbmNlIiwiZm9ybWF0RXRoZXIiLCJkZWNpbWFscyIsInByaWNlIiwiZ2V0UHJpY2VVU0QiLCJwYXJzZUZsb2F0Iiwic3ltYm9sIiwicHJpY2VVU0QiLCJ3YXJuIiwiYXNzZXQiLCJvcmFjbGUiLCJQUklDRV9PUkFDTEUiLCJnZXRBc3NldFByaWNlMWUxOCIsImZvcm1hdFVuaXRzIiwiZ2V0QW1vdW50SW5VU0QiLCJhbW91bnQiLCJhbW91bnRJblVTRCIsIkFwcHJvdmVUb0NvbnRpbnVlIiwidG9rZW5BZGRyZXNzIiwiYXBwcm92ZUFtb3VudCIsIkVycm9yIiwiZmluZCIsInQiLCJ0b0xvd2VyQ2FzZSIsIkxFTkRJTkdfUE9PTCIsInN0YXR1cyIsIm1lc3NhZ2UiLCJyZWFzb24iLCJMZW5kQXNzZXQiLCJzdXBwbHlBbW91bnQiLCJ0b2tlbkluZm8iLCJwYXJzZVVuaXRzIiwidHgiLCJoYXNoIiwiV2l0aGRyYXdBc3NldCIsIndpdGhkcmF3QW1vdW50IiwiYm9ycm93QXNzZXQiLCJib3Jyb3dBbW91bnQiLCJyZXBheUFzc2V0IiwicmVwYXlBbW91bnQiLCJnZXRBY2NvdW50RGF0YSIsInVzZXIiLCJwb29sIiwid2FsbGV0IiwiWmVyb0FkZHJlc3MiLCJjb2wiLCJkZWJ0IiwiaGYiLCJjb250cmFjdEVycm9yIiwiZ2V0WW91clN1cHBsaWVzIiwic3VwcGxpZXMiLCJmaWx0ZXIiLCJ1c2VyUmVzZXJ2ZSIsImdldFVzZXJSZXNlcnZlIiwic3VwcGx5UHJpbmNpcGFsIiwic3VwcGx5IiwicHJpbmNpcGFsIiwic3VwcGx5SW5kZXgiLCJpbmRleCIsInZhbGlkU3VwcGxpZXMiLCJzIiwicmVkdWNlIiwic3VtIiwiYXB5IiwiZ2V0WW91ckJvcnJvd3MiLCJib3Jyb3dzIiwiYm9ycm93UHJpbmNpcGFsIiwiYm9ycm93SW5kZXgiLCJ2YWxpZEJvcnJvd3MiLCJiIiwiZ2V0QXNzZXRzVG9Cb3Jyb3ciLCJyZXNlcnZlIiwicmVzZXJ2ZXMiLCJpc0JvcnJvd2FibGUiLCJCb29sZWFuIiwicmVzZXJ2ZUNhc2giLCJsdHZCcHMiLCJsaXFUaHJlc2hvbGRCcHMiLCJ2YWxpZEFzc2V0cyIsImEiLCJ3cmFwRXRoIiwiYW1vdW50RXRoIiwiZGF0YSIsInNlbmRUcmFuc2FjdGlvbiIsInRvIiwidmFsdWUiLCJ3YWl0IiwidW53cmFwV2V0aCIsIndldGgiLCJ3aXRoZHJhd1Rva2VuIiwiZGVwb3NpdFRvVG9rZW4iLCJkZXBvc2l0IiwicmVmcmVzaCIsInVwZGF0ZUludGVyZXN0cyIsImFjY3J1ZVB1YmxpYyIsImdldFVzZXJUb3RhbEF2YWlsYWJsZUJhbGFuY2UiLCJtYXhBbW91bnQiLCJnZXRVc2VyVG90YWxBdmFpbGFibGVCYWxhbmNlSW5VU0QiLCJnZXRUb2tlbnNQZXJVU0RBbW91bnQiLCJoZWxwZXIiLCJtYXhRdHkiLCJvYmplY3RpZnlTdXBwbGllZEFzc2V0cyIsImFzc2V0c0xpc3QiLCJpIiwibGVuZFF0eSIsImxlbnRRdHkiLCJtYXhTdXBwbHlBbW91bnQiLCJxdHkiLCJwdXNoIiwibGVudEFweSIsImJhbGFuY2VJblVTRCIsIm1heFN1cHBseSIsIm9iamVjdGlmeUJvcnJvd2VkQXNzZXRzIiwiYm9ycm93c0xpc3QiLCJib3Jyb3dRdHkiLCJib3Jyb3dBcHkiLCJib3Jyb3dlZEJhbEluVVNEIiwibWVyZ2VPYmplY3RpZmllZEFzc2V0cyIsInJlc3VsdCIsInRva2VuTGlzdCIsInNvbWUiLCJhc3NldExpc3QiLCJhc3NldE9iaiIsIml0ZW0iLCJjb250ZXh0VmFsdWUiLCJQcm92aWRlciIsImNoaWxkcmVuIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/context/LendState.js\n"));

/***/ })

});