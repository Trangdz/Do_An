"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/recharts";
exports.ids = ["vendor-chunks/recharts"];
exports.modules = {

/***/ "(pages-dir-node)/./node_modules/recharts/lib/cartesian/Area.js":
/*!*****************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/Area.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Area = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _max = _interopRequireDefault(__webpack_require__(/*! lodash/max */ \"lodash/max\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _isNaN = _interopRequireDefault(__webpack_require__(/*! lodash/isNaN */ \"lodash/isNaN\"));\nvar _isEqual = _interopRequireDefault(__webpack_require__(/*! lodash/isEqual */ \"lodash/isEqual\"));\nvar _Curve = __webpack_require__(/*! ../shape/Curve */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Curve.js\");\nvar _Dot = __webpack_require__(/*! ../shape/Dot */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Dot.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _LabelList = __webpack_require__(/*! ../component/LabelList */ \"(pages-dir-node)/./node_modules/recharts/lib/component/LabelList.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"(pages-dir-node)/./node_modules/recharts/lib/util/Global.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"layout\",\n    \"type\",\n    \"stroke\",\n    \"connectNulls\",\n    \"isRange\",\n    \"ref\"\n], _excluded2 = [\n    \"key\"\n];\nvar _Area;\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Area\r\n */ \nvar Area = exports.Area = /*#__PURE__*/ function(_PureComponent) {\n    function Area() {\n        var _this;\n        _classCallCheck(this, Area);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, Area, [].concat(args));\n        _defineProperty(_this, \"state\", {\n            isAnimationFinished: true\n        });\n        _defineProperty(_this, \"id\", (0, _DataUtils.uniqueId)('recharts-area-'));\n        _defineProperty(_this, \"handleAnimationEnd\", function() {\n            var onAnimationEnd = _this.props.onAnimationEnd;\n            _this.setState({\n                isAnimationFinished: true\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationEnd)) {\n                onAnimationEnd();\n            }\n        });\n        _defineProperty(_this, \"handleAnimationStart\", function() {\n            var onAnimationStart = _this.props.onAnimationStart;\n            _this.setState({\n                isAnimationFinished: false\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationStart)) {\n                onAnimationStart();\n            }\n        });\n        return _this;\n    }\n    _inherits(Area, _PureComponent);\n    return _createClass(Area, [\n        {\n            key: \"renderDots\",\n            value: function renderDots(needClip, clipDot, clipPathId) {\n                var isAnimationActive = this.props.isAnimationActive;\n                var isAnimationFinished = this.state.isAnimationFinished;\n                if (isAnimationActive && !isAnimationFinished) {\n                    return null;\n                }\n                var _this$props = this.props, dot = _this$props.dot, points = _this$props.points, dataKey = _this$props.dataKey;\n                var areaProps = (0, _ReactUtils.filterProps)(this.props, false);\n                var customDotProps = (0, _ReactUtils.filterProps)(dot, true);\n                var dots = points.map(function(entry, i) {\n                    var dotProps = _objectSpread(_objectSpread(_objectSpread({\n                        key: \"dot-\".concat(i),\n                        r: 3\n                    }, areaProps), customDotProps), {}, {\n                        index: i,\n                        cx: entry.x,\n                        cy: entry.y,\n                        dataKey: dataKey,\n                        value: entry.value,\n                        payload: entry.payload,\n                        points: points\n                    });\n                    return Area.renderDotItem(dot, dotProps);\n                });\n                var dotsProps = {\n                    clipPath: needClip ? \"url(#clipPath-\".concat(clipDot ? '' : 'dots-').concat(clipPathId, \")\") : null\n                };\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                    className: \"recharts-area-dots\"\n                }, dotsProps), dots);\n            }\n        },\n        {\n            key: \"renderHorizontalRect\",\n            value: function renderHorizontalRect(alpha) {\n                var _this$props2 = this.props, baseLine = _this$props2.baseLine, points = _this$props2.points, strokeWidth = _this$props2.strokeWidth;\n                var startX = points[0].x;\n                var endX = points[points.length - 1].x;\n                var width = alpha * Math.abs(startX - endX);\n                var maxY = (0, _max[\"default\"])(points.map(function(entry) {\n                    return entry.y || 0;\n                }));\n                if ((0, _DataUtils.isNumber)(baseLine) && typeof baseLine === 'number') {\n                    maxY = Math.max(baseLine, maxY);\n                } else if (baseLine && Array.isArray(baseLine) && baseLine.length) {\n                    maxY = Math.max((0, _max[\"default\"])(baseLine.map(function(entry) {\n                        return entry.y || 0;\n                    })), maxY);\n                }\n                if ((0, _DataUtils.isNumber)(maxY)) {\n                    return /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                        x: startX < endX ? startX : startX - width,\n                        y: 0,\n                        width: width,\n                        height: Math.floor(maxY + (strokeWidth ? parseInt(\"\".concat(strokeWidth), 10) : 1))\n                    });\n                }\n                return null;\n            }\n        },\n        {\n            key: \"renderVerticalRect\",\n            value: function renderVerticalRect(alpha) {\n                var _this$props3 = this.props, baseLine = _this$props3.baseLine, points = _this$props3.points, strokeWidth = _this$props3.strokeWidth;\n                var startY = points[0].y;\n                var endY = points[points.length - 1].y;\n                var height = alpha * Math.abs(startY - endY);\n                var maxX = (0, _max[\"default\"])(points.map(function(entry) {\n                    return entry.x || 0;\n                }));\n                if ((0, _DataUtils.isNumber)(baseLine) && typeof baseLine === 'number') {\n                    maxX = Math.max(baseLine, maxX);\n                } else if (baseLine && Array.isArray(baseLine) && baseLine.length) {\n                    maxX = Math.max((0, _max[\"default\"])(baseLine.map(function(entry) {\n                        return entry.x || 0;\n                    })), maxX);\n                }\n                if ((0, _DataUtils.isNumber)(maxX)) {\n                    return /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                        x: 0,\n                        y: startY < endY ? startY : startY - height,\n                        width: maxX + (strokeWidth ? parseInt(\"\".concat(strokeWidth), 10) : 1),\n                        height: Math.floor(height)\n                    });\n                }\n                return null;\n            }\n        },\n        {\n            key: \"renderClipRect\",\n            value: function renderClipRect(alpha) {\n                var layout = this.props.layout;\n                if (layout === 'vertical') {\n                    return this.renderVerticalRect(alpha);\n                }\n                return this.renderHorizontalRect(alpha);\n            }\n        },\n        {\n            key: \"renderAreaStatically\",\n            value: function renderAreaStatically(points, baseLine, needClip, clipPathId) {\n                var _this$props4 = this.props, layout = _this$props4.layout, type = _this$props4.type, stroke = _this$props4.stroke, connectNulls = _this$props4.connectNulls, isRange = _this$props4.isRange, ref = _this$props4.ref, others = _objectWithoutProperties(_this$props4, _excluded);\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : null\n                }, /*#__PURE__*/ _react[\"default\"].createElement(_Curve.Curve, _extends({}, (0, _ReactUtils.filterProps)(others, true), {\n                    points: points,\n                    connectNulls: connectNulls,\n                    type: type,\n                    baseLine: baseLine,\n                    layout: layout,\n                    stroke: \"none\",\n                    className: \"recharts-area-area\"\n                })), stroke !== 'none' && /*#__PURE__*/ _react[\"default\"].createElement(_Curve.Curve, _extends({}, (0, _ReactUtils.filterProps)(this.props, false), {\n                    className: \"recharts-area-curve\",\n                    layout: layout,\n                    type: type,\n                    connectNulls: connectNulls,\n                    fill: \"none\",\n                    points: points\n                })), stroke !== 'none' && isRange && /*#__PURE__*/ _react[\"default\"].createElement(_Curve.Curve, _extends({}, (0, _ReactUtils.filterProps)(this.props, false), {\n                    className: \"recharts-area-curve\",\n                    layout: layout,\n                    type: type,\n                    connectNulls: connectNulls,\n                    fill: \"none\",\n                    points: baseLine\n                })));\n            }\n        },\n        {\n            key: \"renderAreaWithAnimation\",\n            value: function renderAreaWithAnimation(needClip, clipPathId) {\n                var _this2 = this;\n                var _this$props5 = this.props, points = _this$props5.points, baseLine = _this$props5.baseLine, isAnimationActive = _this$props5.isAnimationActive, animationBegin = _this$props5.animationBegin, animationDuration = _this$props5.animationDuration, animationEasing = _this$props5.animationEasing, animationId = _this$props5.animationId;\n                var _this$state = this.state, prevPoints = _this$state.prevPoints, prevBaseLine = _this$state.prevBaseLine;\n                // const clipPathId = isNil(id) ? this.id : id;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n                    begin: animationBegin,\n                    duration: animationDuration,\n                    isActive: isAnimationActive,\n                    easing: animationEasing,\n                    from: {\n                        t: 0\n                    },\n                    to: {\n                        t: 1\n                    },\n                    key: \"area-\".concat(animationId),\n                    onAnimationEnd: this.handleAnimationEnd,\n                    onAnimationStart: this.handleAnimationStart\n                }, function(_ref) {\n                    var t = _ref.t;\n                    if (prevPoints) {\n                        var prevPointsDiffFactor = prevPoints.length / points.length;\n                        // update animtaion\n                        var stepPoints = points.map(function(entry, index) {\n                            var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n                            if (prevPoints[prevPointIndex]) {\n                                var prev = prevPoints[prevPointIndex];\n                                var interpolatorX = (0, _DataUtils.interpolateNumber)(prev.x, entry.x);\n                                var interpolatorY = (0, _DataUtils.interpolateNumber)(prev.y, entry.y);\n                                return _objectSpread(_objectSpread({}, entry), {}, {\n                                    x: interpolatorX(t),\n                                    y: interpolatorY(t)\n                                });\n                            }\n                            return entry;\n                        });\n                        var stepBaseLine;\n                        if ((0, _DataUtils.isNumber)(baseLine) && typeof baseLine === 'number') {\n                            var interpolator = (0, _DataUtils.interpolateNumber)(prevBaseLine, baseLine);\n                            stepBaseLine = interpolator(t);\n                        } else if ((0, _isNil[\"default\"])(baseLine) || (0, _isNaN[\"default\"])(baseLine)) {\n                            var _interpolator = (0, _DataUtils.interpolateNumber)(prevBaseLine, 0);\n                            stepBaseLine = _interpolator(t);\n                        } else {\n                            stepBaseLine = baseLine.map(function(entry, index) {\n                                var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n                                if (prevBaseLine[prevPointIndex]) {\n                                    var prev = prevBaseLine[prevPointIndex];\n                                    var interpolatorX = (0, _DataUtils.interpolateNumber)(prev.x, entry.x);\n                                    var interpolatorY = (0, _DataUtils.interpolateNumber)(prev.y, entry.y);\n                                    return _objectSpread(_objectSpread({}, entry), {}, {\n                                        x: interpolatorX(t),\n                                        y: interpolatorY(t)\n                                    });\n                                }\n                                return entry;\n                            });\n                        }\n                        return _this2.renderAreaStatically(stepPoints, stepBaseLine, needClip, clipPathId);\n                    }\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, null, /*#__PURE__*/ _react[\"default\"].createElement(\"defs\", null, /*#__PURE__*/ _react[\"default\"].createElement(\"clipPath\", {\n                        id: \"animationClipPath-\".concat(clipPathId)\n                    }, _this2.renderClipRect(t))), /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                        clipPath: \"url(#animationClipPath-\".concat(clipPathId, \")\")\n                    }, _this2.renderAreaStatically(points, baseLine, needClip, clipPathId)));\n                });\n            }\n        },\n        {\n            key: \"renderArea\",\n            value: function renderArea(needClip, clipPathId) {\n                var _this$props6 = this.props, points = _this$props6.points, baseLine = _this$props6.baseLine, isAnimationActive = _this$props6.isAnimationActive;\n                var _this$state2 = this.state, prevPoints = _this$state2.prevPoints, prevBaseLine = _this$state2.prevBaseLine, totalLength = _this$state2.totalLength;\n                if (isAnimationActive && points && points.length && (!prevPoints && totalLength > 0 || !(0, _isEqual[\"default\"])(prevPoints, points) || !(0, _isEqual[\"default\"])(prevBaseLine, baseLine))) {\n                    return this.renderAreaWithAnimation(needClip, clipPathId);\n                }\n                return this.renderAreaStatically(points, baseLine, needClip, clipPathId);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _filterProps;\n                var _this$props7 = this.props, hide = _this$props7.hide, dot = _this$props7.dot, points = _this$props7.points, className = _this$props7.className, top = _this$props7.top, left = _this$props7.left, xAxis = _this$props7.xAxis, yAxis = _this$props7.yAxis, width = _this$props7.width, height = _this$props7.height, isAnimationActive = _this$props7.isAnimationActive, id = _this$props7.id;\n                if (hide || !points || !points.length) {\n                    return null;\n                }\n                var isAnimationFinished = this.state.isAnimationFinished;\n                var hasSinglePoint = points.length === 1;\n                var layerClass = (0, _clsx[\"default\"])('recharts-area', className);\n                var needClipX = xAxis && xAxis.allowDataOverflow;\n                var needClipY = yAxis && yAxis.allowDataOverflow;\n                var needClip = needClipX || needClipY;\n                var clipPathId = (0, _isNil[\"default\"])(id) ? this.id : id;\n                var _ref2 = (_filterProps = (0, _ReactUtils.filterProps)(dot, false)) !== null && _filterProps !== void 0 ? _filterProps : {\n                    r: 3,\n                    strokeWidth: 2\n                }, _ref2$r = _ref2.r, r = _ref2$r === void 0 ? 3 : _ref2$r, _ref2$strokeWidth = _ref2.strokeWidth, strokeWidth = _ref2$strokeWidth === void 0 ? 2 : _ref2$strokeWidth;\n                var _ref3 = (0, _ReactUtils.hasClipDot)(dot) ? dot : {}, _ref3$clipDot = _ref3.clipDot, clipDot = _ref3$clipDot === void 0 ? true : _ref3$clipDot;\n                var dotSize = r * 2 + strokeWidth;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: layerClass\n                }, needClipX || needClipY ? /*#__PURE__*/ _react[\"default\"].createElement(\"defs\", null, /*#__PURE__*/ _react[\"default\"].createElement(\"clipPath\", {\n                    id: \"clipPath-\".concat(clipPathId)\n                }, /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                    x: needClipX ? left : left - width / 2,\n                    y: needClipY ? top : top - height / 2,\n                    width: needClipX ? width : width * 2,\n                    height: needClipY ? height : height * 2\n                })), !clipDot && /*#__PURE__*/ _react[\"default\"].createElement(\"clipPath\", {\n                    id: \"clipPath-dots-\".concat(clipPathId)\n                }, /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                    x: left - dotSize / 2,\n                    y: top - dotSize / 2,\n                    width: width + dotSize,\n                    height: height + dotSize\n                }))) : null, !hasSinglePoint ? this.renderArea(needClip, clipPathId) : null, (dot || hasSinglePoint) && this.renderDots(needClip, clipDot, clipPathId), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, points));\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                if (nextProps.animationId !== prevState.prevAnimationId) {\n                    return {\n                        prevAnimationId: nextProps.animationId,\n                        curPoints: nextProps.points,\n                        curBaseLine: nextProps.baseLine,\n                        prevPoints: prevState.curPoints,\n                        prevBaseLine: prevState.curBaseLine\n                    };\n                }\n                if (nextProps.points !== prevState.curPoints || nextProps.baseLine !== prevState.curBaseLine) {\n                    return {\n                        curPoints: nextProps.points,\n                        curBaseLine: nextProps.baseLine\n                    };\n                }\n                return null;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_Area = Area;\n_defineProperty(Area, \"displayName\", 'Area');\n_defineProperty(Area, \"defaultProps\", {\n    stroke: '#3182bd',\n    fill: '#3182bd',\n    fillOpacity: 0.6,\n    xAxisId: 0,\n    yAxisId: 0,\n    legendType: 'line',\n    connectNulls: false,\n    // points of area\n    points: [],\n    dot: false,\n    activeDot: true,\n    hide: false,\n    isAnimationActive: !_Global.Global.isSsr,\n    animationBegin: 0,\n    animationDuration: 1500,\n    animationEasing: 'ease'\n});\n_defineProperty(Area, \"getBaseValue\", function(props, item, xAxis, yAxis) {\n    var layout = props.layout, chartBaseValue = props.baseValue;\n    var itemBaseValue = item.props.baseValue;\n    // The baseValue can be defined both on the AreaChart as well as on the Area.\n    // The value for the item takes precedence.\n    var baseValue = itemBaseValue !== null && itemBaseValue !== void 0 ? itemBaseValue : chartBaseValue;\n    if ((0, _DataUtils.isNumber)(baseValue) && typeof baseValue === 'number') {\n        return baseValue;\n    }\n    var numericAxis = layout === 'horizontal' ? yAxis : xAxis;\n    var domain = numericAxis.scale.domain();\n    if (numericAxis.type === 'number') {\n        var domainMax = Math.max(domain[0], domain[1]);\n        var domainMin = Math.min(domain[0], domain[1]);\n        if (baseValue === 'dataMin') {\n            return domainMin;\n        }\n        if (baseValue === 'dataMax') {\n            return domainMax;\n        }\n        return domainMax < 0 ? domainMax : Math.max(Math.min(domain[0], domain[1]), 0);\n    }\n    if (baseValue === 'dataMin') {\n        return domain[0];\n    }\n    if (baseValue === 'dataMax') {\n        return domain[1];\n    }\n    return domain[0];\n});\n_defineProperty(Area, \"getComposedData\", function(_ref4) {\n    var props = _ref4.props, item = _ref4.item, xAxis = _ref4.xAxis, yAxis = _ref4.yAxis, xAxisTicks = _ref4.xAxisTicks, yAxisTicks = _ref4.yAxisTicks, bandSize = _ref4.bandSize, dataKey = _ref4.dataKey, stackedData = _ref4.stackedData, dataStartIndex = _ref4.dataStartIndex, displayedData = _ref4.displayedData, offset = _ref4.offset;\n    var layout = props.layout;\n    var hasStack = stackedData && stackedData.length;\n    var baseValue = _Area.getBaseValue(props, item, xAxis, yAxis);\n    var isHorizontalLayout = layout === 'horizontal';\n    var isRange = false;\n    var points = displayedData.map(function(entry, index) {\n        var value;\n        if (hasStack) {\n            value = stackedData[dataStartIndex + index];\n        } else {\n            value = (0, _ChartUtils.getValueByDataKey)(entry, dataKey);\n            if (!Array.isArray(value)) {\n                value = [\n                    baseValue,\n                    value\n                ];\n            } else {\n                isRange = true;\n            }\n        }\n        var isBreakPoint = value[1] == null || hasStack && (0, _ChartUtils.getValueByDataKey)(entry, dataKey) == null;\n        if (isHorizontalLayout) {\n            return {\n                x: (0, _ChartUtils.getCateCoordinateOfLine)({\n                    axis: xAxis,\n                    ticks: xAxisTicks,\n                    bandSize: bandSize,\n                    entry: entry,\n                    index: index\n                }),\n                y: isBreakPoint ? null : yAxis.scale(value[1]),\n                value: value,\n                payload: entry\n            };\n        }\n        return {\n            x: isBreakPoint ? null : xAxis.scale(value[1]),\n            y: (0, _ChartUtils.getCateCoordinateOfLine)({\n                axis: yAxis,\n                ticks: yAxisTicks,\n                bandSize: bandSize,\n                entry: entry,\n                index: index\n            }),\n            value: value,\n            payload: entry\n        };\n    });\n    var baseLine;\n    if (hasStack || isRange) {\n        baseLine = points.map(function(entry) {\n            var x = Array.isArray(entry.value) ? entry.value[0] : null;\n            if (isHorizontalLayout) {\n                return {\n                    x: entry.x,\n                    y: x != null && entry.y != null ? yAxis.scale(x) : null\n                };\n            }\n            return {\n                x: x != null ? xAxis.scale(x) : null,\n                y: entry.y\n            };\n        });\n    } else {\n        baseLine = isHorizontalLayout ? yAxis.scale(baseValue) : xAxis.scale(baseValue);\n    }\n    return _objectSpread({\n        points: points,\n        baseLine: baseLine,\n        layout: layout,\n        isRange: isRange\n    }, offset);\n});\n_defineProperty(Area, \"renderDotItem\", function(option, props) {\n    var dotItem;\n    if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n        dotItem = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n    } else if ((0, _isFunction[\"default\"])(option)) {\n        dotItem = option(props);\n    } else {\n        var className = (0, _clsx[\"default\"])('recharts-area-dot', typeof option !== 'boolean' ? option.className : '');\n        var key = props.key, rest = _objectWithoutProperties(props, _excluded2);\n        dotItem = /*#__PURE__*/ _react[\"default\"].createElement(_Dot.Dot, _extends({}, rest, {\n            key: key,\n            className: className\n        }));\n    }\n    return dotItem;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2FydGVzaWFuL0FyZWEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELFlBQVksR0FBRyxLQUFLO0FBQ3BCLElBQUlHLFNBQVNDLHdCQUF3QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUMsUUFBUUMsdUJBQXVCRixtQkFBT0EsQ0FBQyx1QkFBTTtBQUNqRCxJQUFJRyxlQUFlRCx1QkFBdUJGLG1CQUFPQSxDQUFDLGtDQUFjO0FBQ2hFLElBQUlJLGNBQWNGLHVCQUF1QkYsbUJBQU9BLENBQUMsNENBQW1CO0FBQ3BFLElBQUlLLE9BQU9ILHVCQUF1QkYsbUJBQU9BLENBQUMsOEJBQVk7QUFDdEQsSUFBSU0sU0FBU0osdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJTyxTQUFTTCx1QkFBdUJGLG1CQUFPQSxDQUFDLGtDQUFjO0FBQzFELElBQUlRLFdBQVdOLHVCQUF1QkYsbUJBQU9BLENBQUMsc0NBQWdCO0FBQzlELElBQUlTLFNBQVNULG1CQUFPQSxDQUFDLG1GQUFnQjtBQUNyQyxJQUFJVSxPQUFPVixtQkFBT0EsQ0FBQywrRUFBYztBQUNqQyxJQUFJVyxTQUFTWCxtQkFBT0EsQ0FBQywyRkFBb0I7QUFDekMsSUFBSVksYUFBYVosbUJBQU9BLENBQUMsbUdBQXdCO0FBQ2pELElBQUlhLFVBQVViLG1CQUFPQSxDQUFDLG1GQUFnQjtBQUN0QyxJQUFJYyxhQUFhZCxtQkFBT0EsQ0FBQyx5RkFBbUI7QUFDNUMsSUFBSWUsY0FBY2YsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlnQixjQUFjaEIsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlpQixZQUFZO0lBQUM7SUFBVTtJQUFRO0lBQVU7SUFBZ0I7SUFBVztDQUFNLEVBQzVFQyxhQUFhO0lBQUM7Q0FBTTtBQUN0QixJQUFJ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S0E7WUFDTGlHLFdBQVdBO1FBQ2I7SUFDRjtJQUNBLE9BQU9vSTtBQUNUIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxjYXJ0ZXNpYW5cXEFyZWEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5BcmVhID0gdm9pZCAwO1xyXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XHJcbnZhciBfcmVhY3RTbW9vdGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1zbW9vdGhcIikpO1xyXG52YXIgX2lzRnVuY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XHJcbnZhciBfbWF4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL21heFwiKSk7XHJcbnZhciBfaXNOaWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNOaWxcIikpO1xyXG52YXIgX2lzTmFOID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzTmFOXCIpKTtcclxudmFyIF9pc0VxdWFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRXF1YWxcIikpO1xyXG52YXIgX0N1cnZlID0gcmVxdWlyZShcIi4uL3NoYXBlL0N1cnZlXCIpO1xyXG52YXIgX0RvdCA9IHJlcXVpcmUoXCIuLi9zaGFwZS9Eb3RcIik7XHJcbnZhciBfTGF5ZXIgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL0xheWVyXCIpO1xyXG52YXIgX0xhYmVsTGlzdCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQvTGFiZWxMaXN0XCIpO1xyXG52YXIgX0dsb2JhbCA9IHJlcXVpcmUoXCIuLi91dGlsL0dsb2JhbFwiKTtcclxudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9EYXRhVXRpbHNcIik7XHJcbnZhciBfQ2hhcnRVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NoYXJ0VXRpbHNcIik7XHJcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XHJcbnZhciBfZXhjbHVkZWQgPSBbXCJsYXlvdXRcIiwgXCJ0eXBlXCIsIFwic3Ryb2tlXCIsIFwiY29ubmVjdE51bGxzXCIsIFwiaXNSYW5nZVwiLCBcInJlZlwiXSxcclxuICBfZXhjbHVkZWQyID0gW1wia2V5XCJdO1xyXG52YXIgX0FyZWE7XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XHJcbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XHJcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XHJcbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XHJcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxyXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cclxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XHJcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XHJcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cclxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH0gLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgQXJlYVxyXG4gKi9cclxudmFyIEFyZWEgPSBleHBvcnRzLkFyZWEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QdXJlQ29tcG9uZW50KSB7XHJcbiAgZnVuY3Rpb24gQXJlYSgpIHtcclxuICAgIHZhciBfdGhpcztcclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBcmVhKTtcclxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xyXG4gICAgfVxyXG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIEFyZWEsIFtdLmNvbmNhdChhcmdzKSk7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwic3RhdGVcIiwge1xyXG4gICAgICBpc0FuaW1hdGlvbkZpbmlzaGVkOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJpZFwiLCAoMCwgX0RhdGFVdGlscy51bmlxdWVJZCkoJ3JlY2hhcnRzLWFyZWEtJykpO1xyXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZUFuaW1hdGlvbkVuZFwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBvbkFuaW1hdGlvbkVuZCA9IF90aGlzLnByb3BzLm9uQW5pbWF0aW9uRW5kO1xyXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9uQW5pbWF0aW9uRW5kKSkge1xyXG4gICAgICAgIG9uQW5pbWF0aW9uRW5kKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZUFuaW1hdGlvblN0YXJ0XCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG9uQW5pbWF0aW9uU3RhcnQgPSBfdGhpcy5wcm9wcy5vbkFuaW1hdGlvblN0YXJ0O1xyXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogZmFsc2VcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvbkFuaW1hdGlvblN0YXJ0KSkge1xyXG4gICAgICAgIG9uQW5pbWF0aW9uU3RhcnQoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gX3RoaXM7XHJcbiAgfVxyXG4gIF9pbmhlcml0cyhBcmVhLCBfUHVyZUNvbXBvbmVudCk7XHJcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBcmVhLCBbe1xyXG4gICAga2V5OiBcInJlbmRlckRvdHNcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJEb3RzKG5lZWRDbGlwLCBjbGlwRG90LCBjbGlwUGF0aElkKSB7XHJcbiAgICAgIHZhciBpc0FuaW1hdGlvbkFjdGl2ZSA9IHRoaXMucHJvcHMuaXNBbmltYXRpb25BY3RpdmU7XHJcbiAgICAgIHZhciBpc0FuaW1hdGlvbkZpbmlzaGVkID0gdGhpcy5zdGF0ZS5pc0FuaW1hdGlvbkZpbmlzaGVkO1xyXG4gICAgICBpZiAoaXNBbmltYXRpb25BY3RpdmUgJiYgIWlzQW5pbWF0aW9uRmluaXNoZWQpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIGRvdCA9IF90aGlzJHByb3BzLmRvdCxcclxuICAgICAgICBwb2ludHMgPSBfdGhpcyRwcm9wcy5wb2ludHMsXHJcbiAgICAgICAgZGF0YUtleSA9IF90aGlzJHByb3BzLmRhdGFLZXk7XHJcbiAgICAgIHZhciBhcmVhUHJvcHMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRoaXMucHJvcHMsIGZhbHNlKTtcclxuICAgICAgdmFyIGN1c3RvbURvdFByb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShkb3QsIHRydWUpO1xyXG4gICAgICB2YXIgZG90cyA9IHBvaW50cy5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpKSB7XHJcbiAgICAgICAgdmFyIGRvdFByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xyXG4gICAgICAgICAga2V5OiBcImRvdC1cIi5jb25jYXQoaSksXHJcbiAgICAgICAgICByOiAzXHJcbiAgICAgICAgfSwgYXJlYVByb3BzKSwgY3VzdG9tRG90UHJvcHMpLCB7fSwge1xyXG4gICAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgICBjeDogZW50cnkueCxcclxuICAgICAgICAgIGN5OiBlbnRyeS55LFxyXG4gICAgICAgICAgZGF0YUtleTogZGF0YUtleSxcclxuICAgICAgICAgIHZhbHVlOiBlbnRyeS52YWx1ZSxcclxuICAgICAgICAgIHBheWxvYWQ6IGVudHJ5LnBheWxvYWQsXHJcbiAgICAgICAgICBwb2ludHM6IHBvaW50c1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBBcmVhLnJlbmRlckRvdEl0ZW0oZG90LCBkb3RQcm9wcyk7XHJcbiAgICAgIH0pO1xyXG4gICAgICB2YXIgZG90c1Byb3BzID0ge1xyXG4gICAgICAgIGNsaXBQYXRoOiBuZWVkQ2xpcCA/IFwidXJsKCNjbGlwUGF0aC1cIi5jb25jYXQoY2xpcERvdCA/ICcnIDogJ2RvdHMtJykuY29uY2F0KGNsaXBQYXRoSWQsIFwiKVwiKSA6IG51bGxcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCBfZXh0ZW5kcyh7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWFyZWEtZG90c1wiXHJcbiAgICAgIH0sIGRvdHNQcm9wcyksIGRvdHMpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJIb3Jpem9udGFsUmVjdFwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckhvcml6b250YWxSZWN0KGFscGhhKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIGJhc2VMaW5lID0gX3RoaXMkcHJvcHMyLmJhc2VMaW5lLFxyXG4gICAgICAgIHBvaW50cyA9IF90aGlzJHByb3BzMi5wb2ludHMsXHJcbiAgICAgICAgc3Ryb2tlV2lkdGggPSBfdGhpcyRwcm9wczIuc3Ryb2tlV2lkdGg7XHJcbiAgICAgIHZhciBzdGFydFggPSBwb2ludHNbMF0ueDtcclxuICAgICAgdmFyIGVuZFggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLng7XHJcbiAgICAgIHZhciB3aWR0aCA9IGFscGhhICogTWF0aC5hYnMoc3RhcnRYIC0gZW5kWCk7XHJcbiAgICAgIHZhciBtYXhZID0gKDAsIF9tYXhbXCJkZWZhdWx0XCJdKShwb2ludHMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIHJldHVybiBlbnRyeS55IHx8IDA7XHJcbiAgICAgIH0pKTtcclxuICAgICAgaWYgKCgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShiYXNlTGluZSkgJiYgdHlwZW9mIGJhc2VMaW5lID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIG1heFkgPSBNYXRoLm1heChiYXNlTGluZSwgbWF4WSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoYmFzZUxpbmUgJiYgQXJyYXkuaXNBcnJheShiYXNlTGluZSkgJiYgYmFzZUxpbmUubGVuZ3RoKSB7XHJcbiAgICAgICAgbWF4WSA9IE1hdGgubWF4KCgwLCBfbWF4W1wiZGVmYXVsdFwiXSkoYmFzZUxpbmUubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgICAgcmV0dXJuIGVudHJ5LnkgfHwgMDtcclxuICAgICAgICB9KSksIG1heFkpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgoMCwgX0RhdGFVdGlscy5pc051bWJlcikobWF4WSkpIHtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xyXG4gICAgICAgICAgeDogc3RhcnRYIDwgZW5kWCA/IHN0YXJ0WCA6IHN0YXJ0WCAtIHdpZHRoLFxyXG4gICAgICAgICAgeTogMCxcclxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgIGhlaWdodDogTWF0aC5mbG9vcihtYXhZICsgKHN0cm9rZVdpZHRoID8gcGFyc2VJbnQoXCJcIi5jb25jYXQoc3Ryb2tlV2lkdGgpLCAxMCkgOiAxKSlcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyVmVydGljYWxSZWN0XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVmVydGljYWxSZWN0KGFscGhhKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIGJhc2VMaW5lID0gX3RoaXMkcHJvcHMzLmJhc2VMaW5lLFxyXG4gICAgICAgIHBvaW50cyA9IF90aGlzJHByb3BzMy5wb2ludHMsXHJcbiAgICAgICAgc3Ryb2tlV2lkdGggPSBfdGhpcyRwcm9wczMuc3Ryb2tlV2lkdGg7XHJcbiAgICAgIHZhciBzdGFydFkgPSBwb2ludHNbMF0ueTtcclxuICAgICAgdmFyIGVuZFkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLnk7XHJcbiAgICAgIHZhciBoZWlnaHQgPSBhbHBoYSAqIE1hdGguYWJzKHN0YXJ0WSAtIGVuZFkpO1xyXG4gICAgICB2YXIgbWF4WCA9ICgwLCBfbWF4W1wiZGVmYXVsdFwiXSkocG9pbnRzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICByZXR1cm4gZW50cnkueCB8fCAwO1xyXG4gICAgICB9KSk7XHJcbiAgICAgIGlmICgoMCwgX0RhdGFVdGlscy5pc051bWJlcikoYmFzZUxpbmUpICYmIHR5cGVvZiBiYXNlTGluZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBtYXhYID0gTWF0aC5tYXgoYmFzZUxpbmUsIG1heFgpO1xyXG4gICAgICB9IGVsc2UgaWYgKGJhc2VMaW5lICYmIEFycmF5LmlzQXJyYXkoYmFzZUxpbmUpICYmIGJhc2VMaW5lLmxlbmd0aCkge1xyXG4gICAgICAgIG1heFggPSBNYXRoLm1heCgoMCwgX21heFtcImRlZmF1bHRcIl0pKGJhc2VMaW5lLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICAgIHJldHVybiBlbnRyeS54IHx8IDA7XHJcbiAgICAgICAgfSkpLCBtYXhYKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKG1heFgpKSB7XHJcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcclxuICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICB5OiBzdGFydFkgPCBlbmRZID8gc3RhcnRZIDogc3RhcnRZIC0gaGVpZ2h0LFxyXG4gICAgICAgICAgd2lkdGg6IG1heFggKyAoc3Ryb2tlV2lkdGggPyBwYXJzZUludChcIlwiLmNvbmNhdChzdHJva2VXaWR0aCksIDEwKSA6IDEpLFxyXG4gICAgICAgICAgaGVpZ2h0OiBNYXRoLmZsb29yKGhlaWdodClcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyQ2xpcFJlY3RcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDbGlwUmVjdChhbHBoYSkge1xyXG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy5wcm9wcy5sYXlvdXQ7XHJcbiAgICAgIGlmIChsYXlvdXQgPT09ICd2ZXJ0aWNhbCcpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJWZXJ0aWNhbFJlY3QoYWxwaGEpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlckhvcml6b250YWxSZWN0KGFscGhhKTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyQXJlYVN0YXRpY2FsbHlcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJBcmVhU3RhdGljYWxseShwb2ludHMsIGJhc2VMaW5lLCBuZWVkQ2xpcCwgY2xpcFBhdGhJZCkge1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBsYXlvdXQgPSBfdGhpcyRwcm9wczQubGF5b3V0LFxyXG4gICAgICAgIHR5cGUgPSBfdGhpcyRwcm9wczQudHlwZSxcclxuICAgICAgICBzdHJva2UgPSBfdGhpcyRwcm9wczQuc3Ryb2tlLFxyXG4gICAgICAgIGNvbm5lY3ROdWxscyA9IF90aGlzJHByb3BzNC5jb25uZWN0TnVsbHMsXHJcbiAgICAgICAgaXNSYW5nZSA9IF90aGlzJHByb3BzNC5pc1JhbmdlLFxyXG4gICAgICAgIHJlZiA9IF90aGlzJHByb3BzNC5yZWYsXHJcbiAgICAgICAgb3RoZXJzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzNCwgX2V4Y2x1ZGVkKTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XHJcbiAgICAgICAgY2xpcFBhdGg6IG5lZWRDbGlwID8gXCJ1cmwoI2NsaXBQYXRoLVwiLmNvbmNhdChjbGlwUGF0aElkLCBcIilcIikgOiBudWxsXHJcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0N1cnZlLkN1cnZlLCBfZXh0ZW5kcyh7fSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShvdGhlcnMsIHRydWUpLCB7XHJcbiAgICAgICAgcG9pbnRzOiBwb2ludHMsXHJcbiAgICAgICAgY29ubmVjdE51bGxzOiBjb25uZWN0TnVsbHMsXHJcbiAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICBiYXNlTGluZTogYmFzZUxpbmUsXHJcbiAgICAgICAgbGF5b3V0OiBsYXlvdXQsXHJcbiAgICAgICAgc3Ryb2tlOiBcIm5vbmVcIixcclxuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtYXJlYS1hcmVhXCJcclxuICAgICAgfSkpLCBzdHJva2UgIT09ICdub25lJyAmJiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9DdXJ2ZS5DdXJ2ZSwgX2V4dGVuZHMoe30sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykodGhpcy5wcm9wcywgZmFsc2UpLCB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWFyZWEtY3VydmVcIixcclxuICAgICAgICBsYXlvdXQ6IGxheW91dCxcclxuICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgIGNvbm5lY3ROdWxsczogY29ubmVjdE51bGxzLFxyXG4gICAgICAgIGZpbGw6IFwibm9uZVwiLFxyXG4gICAgICAgIHBvaW50czogcG9pbnRzXHJcbiAgICAgIH0pKSwgc3Ryb2tlICE9PSAnbm9uZScgJiYgaXNSYW5nZSAmJiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9DdXJ2ZS5DdXJ2ZSwgX2V4dGVuZHMoe30sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykodGhpcy5wcm9wcywgZmFsc2UpLCB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWFyZWEtY3VydmVcIixcclxuICAgICAgICBsYXlvdXQ6IGxheW91dCxcclxuICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgIGNvbm5lY3ROdWxsczogY29ubmVjdE51bGxzLFxyXG4gICAgICAgIGZpbGw6IFwibm9uZVwiLFxyXG4gICAgICAgIHBvaW50czogYmFzZUxpbmVcclxuICAgICAgfSkpKTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyQXJlYVdpdGhBbmltYXRpb25cIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJBcmVhV2l0aEFuaW1hdGlvbihuZWVkQ2xpcCwgY2xpcFBhdGhJZCkge1xyXG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuICAgICAgdmFyIF90aGlzJHByb3BzNSA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgcG9pbnRzID0gX3RoaXMkcHJvcHM1LnBvaW50cyxcclxuICAgICAgICBiYXNlTGluZSA9IF90aGlzJHByb3BzNS5iYXNlTGluZSxcclxuICAgICAgICBpc0FuaW1hdGlvbkFjdGl2ZSA9IF90aGlzJHByb3BzNS5pc0FuaW1hdGlvbkFjdGl2ZSxcclxuICAgICAgICBhbmltYXRpb25CZWdpbiA9IF90aGlzJHByb3BzNS5hbmltYXRpb25CZWdpbixcclxuICAgICAgICBhbmltYXRpb25EdXJhdGlvbiA9IF90aGlzJHByb3BzNS5hbmltYXRpb25EdXJhdGlvbixcclxuICAgICAgICBhbmltYXRpb25FYXNpbmcgPSBfdGhpcyRwcm9wczUuYW5pbWF0aW9uRWFzaW5nLFxyXG4gICAgICAgIGFuaW1hdGlvbklkID0gX3RoaXMkcHJvcHM1LmFuaW1hdGlvbklkO1xyXG4gICAgICB2YXIgX3RoaXMkc3RhdGUgPSB0aGlzLnN0YXRlLFxyXG4gICAgICAgIHByZXZQb2ludHMgPSBfdGhpcyRzdGF0ZS5wcmV2UG9pbnRzLFxyXG4gICAgICAgIHByZXZCYXNlTGluZSA9IF90aGlzJHN0YXRlLnByZXZCYXNlTGluZTtcclxuICAgICAgLy8gY29uc3QgY2xpcFBhdGhJZCA9IGlzTmlsKGlkKSA/IHRoaXMuaWQgOiBpZDtcclxuXHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9yZWFjdFNtb290aFtcImRlZmF1bHRcIl0sIHtcclxuICAgICAgICBiZWdpbjogYW5pbWF0aW9uQmVnaW4sXHJcbiAgICAgICAgZHVyYXRpb246IGFuaW1hdGlvbkR1cmF0aW9uLFxyXG4gICAgICAgIGlzQWN0aXZlOiBpc0FuaW1hdGlvbkFjdGl2ZSxcclxuICAgICAgICBlYXNpbmc6IGFuaW1hdGlvbkVhc2luZyxcclxuICAgICAgICBmcm9tOiB7XHJcbiAgICAgICAgICB0OiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0bzoge1xyXG4gICAgICAgICAgdDogMVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAga2V5OiBcImFyZWEtXCIuY29uY2F0KGFuaW1hdGlvbklkKSxcclxuICAgICAgICBvbkFuaW1hdGlvbkVuZDogdGhpcy5oYW5kbGVBbmltYXRpb25FbmQsXHJcbiAgICAgICAgb25BbmltYXRpb25TdGFydDogdGhpcy5oYW5kbGVBbmltYXRpb25TdGFydFxyXG4gICAgICB9LCBmdW5jdGlvbiAoX3JlZikge1xyXG4gICAgICAgIHZhciB0ID0gX3JlZi50O1xyXG4gICAgICAgIGlmIChwcmV2UG9pbnRzKSB7XHJcbiAgICAgICAgICB2YXIgcHJldlBvaW50c0RpZmZGYWN0b3IgPSBwcmV2UG9pbnRzLmxlbmd0aCAvIHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAvLyB1cGRhdGUgYW5pbXRhaW9uXHJcbiAgICAgICAgICB2YXIgc3RlcFBvaW50cyA9IHBvaW50cy5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xyXG4gICAgICAgICAgICB2YXIgcHJldlBvaW50SW5kZXggPSBNYXRoLmZsb29yKGluZGV4ICogcHJldlBvaW50c0RpZmZGYWN0b3IpO1xyXG4gICAgICAgICAgICBpZiAocHJldlBvaW50c1twcmV2UG9pbnRJbmRleF0pIHtcclxuICAgICAgICAgICAgICB2YXIgcHJldiA9IHByZXZQb2ludHNbcHJldlBvaW50SW5kZXhdO1xyXG4gICAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3JYID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKHByZXYueCwgZW50cnkueCk7XHJcbiAgICAgICAgICAgICAgdmFyIGludGVycG9sYXRvclkgPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikocHJldi55LCBlbnRyeS55KTtcclxuICAgICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeSksIHt9LCB7XHJcbiAgICAgICAgICAgICAgICB4OiBpbnRlcnBvbGF0b3JYKHQpLFxyXG4gICAgICAgICAgICAgICAgeTogaW50ZXJwb2xhdG9yWSh0KVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyeTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgdmFyIHN0ZXBCYXNlTGluZTtcclxuICAgICAgICAgIGlmICgoMCwgX0RhdGFVdGlscy5pc051bWJlcikoYmFzZUxpbmUpICYmIHR5cGVvZiBiYXNlTGluZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdmFyIGludGVycG9sYXRvciA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShwcmV2QmFzZUxpbmUsIGJhc2VMaW5lKTtcclxuICAgICAgICAgICAgc3RlcEJhc2VMaW5lID0gaW50ZXJwb2xhdG9yKHQpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICgoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoYmFzZUxpbmUpIHx8ICgwLCBfaXNOYU5bXCJkZWZhdWx0XCJdKShiYXNlTGluZSkpIHtcclxuICAgICAgICAgICAgdmFyIF9pbnRlcnBvbGF0b3IgPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikocHJldkJhc2VMaW5lLCAwKTtcclxuICAgICAgICAgICAgc3RlcEJhc2VMaW5lID0gX2ludGVycG9sYXRvcih0KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN0ZXBCYXNlTGluZSA9IGJhc2VMaW5lLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgdmFyIHByZXZQb2ludEluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAqIHByZXZQb2ludHNEaWZmRmFjdG9yKTtcclxuICAgICAgICAgICAgICBpZiAocHJldkJhc2VMaW5lW3ByZXZQb2ludEluZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZXYgPSBwcmV2QmFzZUxpbmVbcHJldlBvaW50SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGludGVycG9sYXRvclggPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikocHJldi54LCBlbnRyeS54KTtcclxuICAgICAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3JZID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKHByZXYueSwgZW50cnkueSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeSksIHt9LCB7XHJcbiAgICAgICAgICAgICAgICAgIHg6IGludGVycG9sYXRvclgodCksXHJcbiAgICAgICAgICAgICAgICAgIHk6IGludGVycG9sYXRvclkodClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gZW50cnk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5yZW5kZXJBcmVhU3RhdGljYWxseShzdGVwUG9pbnRzLCBzdGVwQmFzZUxpbmUsIG5lZWRDbGlwLCBjbGlwUGF0aElkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCBudWxsLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiLCBudWxsLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIiwge1xyXG4gICAgICAgICAgaWQ6IFwiYW5pbWF0aW9uQ2xpcFBhdGgtXCIuY29uY2F0KGNsaXBQYXRoSWQpXHJcbiAgICAgICAgfSwgX3RoaXMyLnJlbmRlckNsaXBSZWN0KHQpKSksIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XHJcbiAgICAgICAgICBjbGlwUGF0aDogXCJ1cmwoI2FuaW1hdGlvbkNsaXBQYXRoLVwiLmNvbmNhdChjbGlwUGF0aElkLCBcIilcIilcclxuICAgICAgICB9LCBfdGhpczIucmVuZGVyQXJlYVN0YXRpY2FsbHkocG9pbnRzLCBiYXNlTGluZSwgbmVlZENsaXAsIGNsaXBQYXRoSWQpKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJBcmVhXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQXJlYShuZWVkQ2xpcCwgY2xpcFBhdGhJZCkge1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHM2ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBwb2ludHMgPSBfdGhpcyRwcm9wczYucG9pbnRzLFxyXG4gICAgICAgIGJhc2VMaW5lID0gX3RoaXMkcHJvcHM2LmJhc2VMaW5lLFxyXG4gICAgICAgIGlzQW5pbWF0aW9uQWN0aXZlID0gX3RoaXMkcHJvcHM2LmlzQW5pbWF0aW9uQWN0aXZlO1xyXG4gICAgICB2YXIgX3RoaXMkc3RhdGUyID0gdGhpcy5zdGF0ZSxcclxuICAgICAgICBwcmV2UG9pbnRzID0gX3RoaXMkc3RhdGUyLnByZXZQb2ludHMsXHJcbiAgICAgICAgcHJldkJhc2VMaW5lID0gX3RoaXMkc3RhdGUyLnByZXZCYXNlTGluZSxcclxuICAgICAgICB0b3RhbExlbmd0aCA9IF90aGlzJHN0YXRlMi50b3RhbExlbmd0aDtcclxuICAgICAgaWYgKGlzQW5pbWF0aW9uQWN0aXZlICYmIHBvaW50cyAmJiBwb2ludHMubGVuZ3RoICYmICghcHJldlBvaW50cyAmJiB0b3RhbExlbmd0aCA+IDAgfHwgISgwLCBfaXNFcXVhbFtcImRlZmF1bHRcIl0pKHByZXZQb2ludHMsIHBvaW50cykgfHwgISgwLCBfaXNFcXVhbFtcImRlZmF1bHRcIl0pKHByZXZCYXNlTGluZSwgYmFzZUxpbmUpKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckFyZWFXaXRoQW5pbWF0aW9uKG5lZWRDbGlwLCBjbGlwUGF0aElkKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJBcmVhU3RhdGljYWxseShwb2ludHMsIGJhc2VMaW5lLCBuZWVkQ2xpcCwgY2xpcFBhdGhJZCk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJlbmRlclwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcclxuICAgICAgdmFyIF9maWx0ZXJQcm9wcztcclxuICAgICAgdmFyIF90aGlzJHByb3BzNyA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgaGlkZSA9IF90aGlzJHByb3BzNy5oaWRlLFxyXG4gICAgICAgIGRvdCA9IF90aGlzJHByb3BzNy5kb3QsXHJcbiAgICAgICAgcG9pbnRzID0gX3RoaXMkcHJvcHM3LnBvaW50cyxcclxuICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczcuY2xhc3NOYW1lLFxyXG4gICAgICAgIHRvcCA9IF90aGlzJHByb3BzNy50b3AsXHJcbiAgICAgICAgbGVmdCA9IF90aGlzJHByb3BzNy5sZWZ0LFxyXG4gICAgICAgIHhBeGlzID0gX3RoaXMkcHJvcHM3LnhBeGlzLFxyXG4gICAgICAgIHlBeGlzID0gX3RoaXMkcHJvcHM3LnlBeGlzLFxyXG4gICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHM3LndpZHRoLFxyXG4gICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzNy5oZWlnaHQsXHJcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wczcuaXNBbmltYXRpb25BY3RpdmUsXHJcbiAgICAgICAgaWQgPSBfdGhpcyRwcm9wczcuaWQ7XHJcbiAgICAgIGlmIChoaWRlIHx8ICFwb2ludHMgfHwgIXBvaW50cy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgaXNBbmltYXRpb25GaW5pc2hlZCA9IHRoaXMuc3RhdGUuaXNBbmltYXRpb25GaW5pc2hlZDtcclxuICAgICAgdmFyIGhhc1NpbmdsZVBvaW50ID0gcG9pbnRzLmxlbmd0aCA9PT0gMTtcclxuICAgICAgdmFyIGxheWVyQ2xhc3MgPSAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtYXJlYScsIGNsYXNzTmFtZSk7XHJcbiAgICAgIHZhciBuZWVkQ2xpcFggPSB4QXhpcyAmJiB4QXhpcy5hbGxvd0RhdGFPdmVyZmxvdztcclxuICAgICAgdmFyIG5lZWRDbGlwWSA9IHlBeGlzICYmIHlBeGlzLmFsbG93RGF0YU92ZXJmbG93O1xyXG4gICAgICB2YXIgbmVlZENsaXAgPSBuZWVkQ2xpcFggfHwgbmVlZENsaXBZO1xyXG4gICAgICB2YXIgY2xpcFBhdGhJZCA9ICgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShpZCkgPyB0aGlzLmlkIDogaWQ7XHJcbiAgICAgIHZhciBfcmVmMiA9IChfZmlsdGVyUHJvcHMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKGRvdCwgZmFsc2UpKSAhPT0gbnVsbCAmJiBfZmlsdGVyUHJvcHMgIT09IHZvaWQgMCA/IF9maWx0ZXJQcm9wcyA6IHtcclxuICAgICAgICAgIHI6IDMsXHJcbiAgICAgICAgICBzdHJva2VXaWR0aDogMlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3JlZjIkciA9IF9yZWYyLnIsXHJcbiAgICAgICAgciA9IF9yZWYyJHIgPT09IHZvaWQgMCA/IDMgOiBfcmVmMiRyLFxyXG4gICAgICAgIF9yZWYyJHN0cm9rZVdpZHRoID0gX3JlZjIuc3Ryb2tlV2lkdGgsXHJcbiAgICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmMiRzdHJva2VXaWR0aCA9PT0gdm9pZCAwID8gMiA6IF9yZWYyJHN0cm9rZVdpZHRoO1xyXG4gICAgICB2YXIgX3JlZjMgPSAoMCwgX1JlYWN0VXRpbHMuaGFzQ2xpcERvdCkoZG90KSA/IGRvdCA6IHt9LFxyXG4gICAgICAgIF9yZWYzJGNsaXBEb3QgPSBfcmVmMy5jbGlwRG90LFxyXG4gICAgICAgIGNsaXBEb3QgPSBfcmVmMyRjbGlwRG90ID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjMkY2xpcERvdDtcclxuICAgICAgdmFyIGRvdFNpemUgPSByICogMiArIHN0cm9rZVdpZHRoO1xyXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIHtcclxuICAgICAgICBjbGFzc05hbWU6IGxheWVyQ2xhc3NcclxuICAgICAgfSwgbmVlZENsaXBYIHx8IG5lZWRDbGlwWSA/IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIsIG51bGwsIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiLCB7XHJcbiAgICAgICAgaWQ6IFwiY2xpcFBhdGgtXCIuY29uY2F0KGNsaXBQYXRoSWQpXHJcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcclxuICAgICAgICB4OiBuZWVkQ2xpcFggPyBsZWZ0IDogbGVmdCAtIHdpZHRoIC8gMixcclxuICAgICAgICB5OiBuZWVkQ2xpcFkgPyB0b3AgOiB0b3AgLSBoZWlnaHQgLyAyLFxyXG4gICAgICAgIHdpZHRoOiBuZWVkQ2xpcFggPyB3aWR0aCA6IHdpZHRoICogMixcclxuICAgICAgICBoZWlnaHQ6IG5lZWRDbGlwWSA/IGhlaWdodCA6IGhlaWdodCAqIDJcclxuICAgICAgfSkpLCAhY2xpcERvdCAmJiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIiwge1xyXG4gICAgICAgIGlkOiBcImNsaXBQYXRoLWRvdHMtXCIuY29uY2F0KGNsaXBQYXRoSWQpXHJcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcclxuICAgICAgICB4OiBsZWZ0IC0gZG90U2l6ZSAvIDIsXHJcbiAgICAgICAgeTogdG9wIC0gZG90U2l6ZSAvIDIsXHJcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgZG90U2l6ZSxcclxuICAgICAgICBoZWlnaHQ6IGhlaWdodCArIGRvdFNpemVcclxuICAgICAgfSkpKSA6IG51bGwsICFoYXNTaW5nbGVQb2ludCA/IHRoaXMucmVuZGVyQXJlYShuZWVkQ2xpcCwgY2xpcFBhdGhJZCkgOiBudWxsLCAoZG90IHx8IGhhc1NpbmdsZVBvaW50KSAmJiB0aGlzLnJlbmRlckRvdHMobmVlZENsaXAsIGNsaXBEb3QsIGNsaXBQYXRoSWQpLCAoIWlzQW5pbWF0aW9uQWN0aXZlIHx8IGlzQW5pbWF0aW9uRmluaXNoZWQpICYmIF9MYWJlbExpc3QuTGFiZWxMaXN0LnJlbmRlckNhbGxCeVBhcmVudCh0aGlzLnByb3BzLCBwb2ludHMpKTtcclxuICAgIH1cclxuICB9XSwgW3tcclxuICAgIGtleTogXCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpIHtcclxuICAgICAgaWYgKG5leHRQcm9wcy5hbmltYXRpb25JZCAhPT0gcHJldlN0YXRlLnByZXZBbmltYXRpb25JZCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBwcmV2QW5pbWF0aW9uSWQ6IG5leHRQcm9wcy5hbmltYXRpb25JZCxcclxuICAgICAgICAgIGN1clBvaW50czogbmV4dFByb3BzLnBvaW50cyxcclxuICAgICAgICAgIGN1ckJhc2VMaW5lOiBuZXh0UHJvcHMuYmFzZUxpbmUsXHJcbiAgICAgICAgICBwcmV2UG9pbnRzOiBwcmV2U3RhdGUuY3VyUG9pbnRzLFxyXG4gICAgICAgICAgcHJldkJhc2VMaW5lOiBwcmV2U3RhdGUuY3VyQmFzZUxpbmVcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChuZXh0UHJvcHMucG9pbnRzICE9PSBwcmV2U3RhdGUuY3VyUG9pbnRzIHx8IG5leHRQcm9wcy5iYXNlTGluZSAhPT0gcHJldlN0YXRlLmN1ckJhc2VMaW5lKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGN1clBvaW50czogbmV4dFByb3BzLnBvaW50cyxcclxuICAgICAgICAgIGN1ckJhc2VMaW5lOiBuZXh0UHJvcHMuYmFzZUxpbmVcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1dKTtcclxufShfcmVhY3QuUHVyZUNvbXBvbmVudCk7XHJcbl9BcmVhID0gQXJlYTtcclxuX2RlZmluZVByb3BlcnR5KEFyZWEsIFwiZGlzcGxheU5hbWVcIiwgJ0FyZWEnKTtcclxuX2RlZmluZVByb3BlcnR5KEFyZWEsIFwiZGVmYXVsdFByb3BzXCIsIHtcclxuICBzdHJva2U6ICcjMzE4MmJkJyxcclxuICBmaWxsOiAnIzMxODJiZCcsXHJcbiAgZmlsbE9wYWNpdHk6IDAuNixcclxuICB4QXhpc0lkOiAwLFxyXG4gIHlBeGlzSWQ6IDAsXHJcbiAgbGVnZW5kVHlwZTogJ2xpbmUnLFxyXG4gIGNvbm5lY3ROdWxsczogZmFsc2UsXHJcbiAgLy8gcG9pbnRzIG9mIGFyZWFcclxuICBwb2ludHM6IFtdLFxyXG4gIGRvdDogZmFsc2UsXHJcbiAgYWN0aXZlRG90OiB0cnVlLFxyXG4gIGhpZGU6IGZhbHNlLFxyXG4gIGlzQW5pbWF0aW9uQWN0aXZlOiAhX0dsb2JhbC5HbG9iYWwuaXNTc3IsXHJcbiAgYW5pbWF0aW9uQmVnaW46IDAsXHJcbiAgYW5pbWF0aW9uRHVyYXRpb246IDE1MDAsXHJcbiAgYW5pbWF0aW9uRWFzaW5nOiAnZWFzZSdcclxufSk7XHJcbl9kZWZpbmVQcm9wZXJ0eShBcmVhLCBcImdldEJhc2VWYWx1ZVwiLCBmdW5jdGlvbiAocHJvcHMsIGl0ZW0sIHhBeGlzLCB5QXhpcykge1xyXG4gIHZhciBsYXlvdXQgPSBwcm9wcy5sYXlvdXQsXHJcbiAgICBjaGFydEJhc2VWYWx1ZSA9IHByb3BzLmJhc2VWYWx1ZTtcclxuICB2YXIgaXRlbUJhc2VWYWx1ZSA9IGl0ZW0ucHJvcHMuYmFzZVZhbHVlO1xyXG5cclxuICAvLyBUaGUgYmFzZVZhbHVlIGNhbiBiZSBkZWZpbmVkIGJvdGggb24gdGhlIEFyZWFDaGFydCBhcyB3ZWxsIGFzIG9uIHRoZSBBcmVhLlxyXG4gIC8vIFRoZSB2YWx1ZSBmb3IgdGhlIGl0ZW0gdGFrZXMgcHJlY2VkZW5jZS5cclxuICB2YXIgYmFzZVZhbHVlID0gaXRlbUJhc2VWYWx1ZSAhPT0gbnVsbCAmJiBpdGVtQmFzZVZhbHVlICE9PSB2b2lkIDAgPyBpdGVtQmFzZVZhbHVlIDogY2hhcnRCYXNlVmFsdWU7XHJcbiAgaWYgKCgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShiYXNlVmFsdWUpICYmIHR5cGVvZiBiYXNlVmFsdWUgPT09ICdudW1iZXInKSB7XHJcbiAgICByZXR1cm4gYmFzZVZhbHVlO1xyXG4gIH1cclxuICB2YXIgbnVtZXJpY0F4aXMgPSBsYXlvdXQgPT09ICdob3Jpem9udGFsJyA/IHlBeGlzIDogeEF4aXM7XHJcbiAgdmFyIGRvbWFpbiA9IG51bWVyaWNBeGlzLnNjYWxlLmRvbWFpbigpO1xyXG4gIGlmIChudW1lcmljQXhpcy50eXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgdmFyIGRvbWFpbk1heCA9IE1hdGgubWF4KGRvbWFpblswXSwgZG9tYWluWzFdKTtcclxuICAgIHZhciBkb21haW5NaW4gPSBNYXRoLm1pbihkb21haW5bMF0sIGRvbWFpblsxXSk7XHJcbiAgICBpZiAoYmFzZVZhbHVlID09PSAnZGF0YU1pbicpIHtcclxuICAgICAgcmV0dXJuIGRvbWFpbk1pbjtcclxuICAgIH1cclxuICAgIGlmIChiYXNlVmFsdWUgPT09ICdkYXRhTWF4Jykge1xyXG4gICAgICByZXR1cm4gZG9tYWluTWF4O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRvbWFpbk1heCA8IDAgPyBkb21haW5NYXggOiBNYXRoLm1heChNYXRoLm1pbihkb21haW5bMF0sIGRvbWFpblsxXSksIDApO1xyXG4gIH1cclxuICBpZiAoYmFzZVZhbHVlID09PSAnZGF0YU1pbicpIHtcclxuICAgIHJldHVybiBkb21haW5bMF07XHJcbiAgfVxyXG4gIGlmIChiYXNlVmFsdWUgPT09ICdkYXRhTWF4Jykge1xyXG4gICAgcmV0dXJuIGRvbWFpblsxXTtcclxuICB9XHJcbiAgcmV0dXJuIGRvbWFpblswXTtcclxufSk7XHJcbl9kZWZpbmVQcm9wZXJ0eShBcmVhLCBcImdldENvbXBvc2VkRGF0YVwiLCBmdW5jdGlvbiAoX3JlZjQpIHtcclxuICB2YXIgcHJvcHMgPSBfcmVmNC5wcm9wcyxcclxuICAgIGl0ZW0gPSBfcmVmNC5pdGVtLFxyXG4gICAgeEF4aXMgPSBfcmVmNC54QXhpcyxcclxuICAgIHlBeGlzID0gX3JlZjQueUF4aXMsXHJcbiAgICB4QXhpc1RpY2tzID0gX3JlZjQueEF4aXNUaWNrcyxcclxuICAgIHlBeGlzVGlja3MgPSBfcmVmNC55QXhpc1RpY2tzLFxyXG4gICAgYmFuZFNpemUgPSBfcmVmNC5iYW5kU2l6ZSxcclxuICAgIGRhdGFLZXkgPSBfcmVmNC5kYXRhS2V5LFxyXG4gICAgc3RhY2tlZERhdGEgPSBfcmVmNC5zdGFja2VkRGF0YSxcclxuICAgIGRhdGFTdGFydEluZGV4ID0gX3JlZjQuZGF0YVN0YXJ0SW5kZXgsXHJcbiAgICBkaXNwbGF5ZWREYXRhID0gX3JlZjQuZGlzcGxheWVkRGF0YSxcclxuICAgIG9mZnNldCA9IF9yZWY0Lm9mZnNldDtcclxuICB2YXIgbGF5b3V0ID0gcHJvcHMubGF5b3V0O1xyXG4gIHZhciBoYXNTdGFjayA9IHN0YWNrZWREYXRhICYmIHN0YWNrZWREYXRhLmxlbmd0aDtcclxuICB2YXIgYmFzZVZhbHVlID0gX0FyZWEuZ2V0QmFzZVZhbHVlKHByb3BzLCBpdGVtLCB4QXhpcywgeUF4aXMpO1xyXG4gIHZhciBpc0hvcml6b250YWxMYXlvdXQgPSBsYXlvdXQgPT09ICdob3Jpem9udGFsJztcclxuICB2YXIgaXNSYW5nZSA9IGZhbHNlO1xyXG4gIHZhciBwb2ludHMgPSBkaXNwbGF5ZWREYXRhLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XHJcbiAgICB2YXIgdmFsdWU7XHJcbiAgICBpZiAoaGFzU3RhY2spIHtcclxuICAgICAgdmFsdWUgPSBzdGFja2VkRGF0YVtkYXRhU3RhcnRJbmRleCArIGluZGV4XTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhbHVlID0gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShlbnRyeSwgZGF0YUtleSk7XHJcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICB2YWx1ZSA9IFtiYXNlVmFsdWUsIHZhbHVlXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpc1JhbmdlID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGlzQnJlYWtQb2ludCA9IHZhbHVlWzFdID09IG51bGwgfHwgaGFzU3RhY2sgJiYgKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShlbnRyeSwgZGF0YUtleSkgPT0gbnVsbDtcclxuICAgIGlmIChpc0hvcml6b250YWxMYXlvdXQpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB4OiAoMCwgX0NoYXJ0VXRpbHMuZ2V0Q2F0ZUNvb3JkaW5hdGVPZkxpbmUpKHtcclxuICAgICAgICAgIGF4aXM6IHhBeGlzLFxyXG4gICAgICAgICAgdGlja3M6IHhBeGlzVGlja3MsXHJcbiAgICAgICAgICBiYW5kU2l6ZTogYmFuZFNpemUsXHJcbiAgICAgICAgICBlbnRyeTogZW50cnksXHJcbiAgICAgICAgICBpbmRleDogaW5kZXhcclxuICAgICAgICB9KSxcclxuICAgICAgICB5OiBpc0JyZWFrUG9pbnQgPyBudWxsIDogeUF4aXMuc2NhbGUodmFsdWVbMV0pLFxyXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICBwYXlsb2FkOiBlbnRyeVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogaXNCcmVha1BvaW50ID8gbnVsbCA6IHhBeGlzLnNjYWxlKHZhbHVlWzFdKSxcclxuICAgICAgeTogKDAsIF9DaGFydFV0aWxzLmdldENhdGVDb29yZGluYXRlT2ZMaW5lKSh7XHJcbiAgICAgICAgYXhpczogeUF4aXMsXHJcbiAgICAgICAgdGlja3M6IHlBeGlzVGlja3MsXHJcbiAgICAgICAgYmFuZFNpemU6IGJhbmRTaXplLFxyXG4gICAgICAgIGVudHJ5OiBlbnRyeSxcclxuICAgICAgICBpbmRleDogaW5kZXhcclxuICAgICAgfSksXHJcbiAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgcGF5bG9hZDogZW50cnlcclxuICAgIH07XHJcbiAgfSk7XHJcbiAgdmFyIGJhc2VMaW5lO1xyXG4gIGlmIChoYXNTdGFjayB8fCBpc1JhbmdlKSB7XHJcbiAgICBiYXNlTGluZSA9IHBvaW50cy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgIHZhciB4ID0gQXJyYXkuaXNBcnJheShlbnRyeS52YWx1ZSkgPyBlbnRyeS52YWx1ZVswXSA6IG51bGw7XHJcbiAgICAgIGlmIChpc0hvcml6b250YWxMYXlvdXQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgeDogZW50cnkueCxcclxuICAgICAgICAgIHk6IHggIT0gbnVsbCAmJiBlbnRyeS55ICE9IG51bGwgPyB5QXhpcy5zY2FsZSh4KSA6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogeCAhPSBudWxsID8geEF4aXMuc2NhbGUoeCkgOiBudWxsLFxyXG4gICAgICAgIHk6IGVudHJ5LnlcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBiYXNlTGluZSA9IGlzSG9yaXpvbnRhbExheW91dCA/IHlBeGlzLnNjYWxlKGJhc2VWYWx1ZSkgOiB4QXhpcy5zY2FsZShiYXNlVmFsdWUpO1xyXG4gIH1cclxuICByZXR1cm4gX29iamVjdFNwcmVhZCh7XHJcbiAgICBwb2ludHM6IHBvaW50cyxcclxuICAgIGJhc2VMaW5lOiBiYXNlTGluZSxcclxuICAgIGxheW91dDogbGF5b3V0LFxyXG4gICAgaXNSYW5nZTogaXNSYW5nZVxyXG4gIH0sIG9mZnNldCk7XHJcbn0pO1xyXG5fZGVmaW5lUHJvcGVydHkoQXJlYSwgXCJyZW5kZXJEb3RJdGVtXCIsIGZ1bmN0aW9uIChvcHRpb24sIHByb3BzKSB7XHJcbiAgdmFyIGRvdEl0ZW07XHJcbiAgaWYgKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5pc1ZhbGlkRWxlbWVudChvcHRpb24pKSB7XHJcbiAgICBkb3RJdGVtID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KG9wdGlvbiwgcHJvcHMpO1xyXG4gIH0gZWxzZSBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob3B0aW9uKSkge1xyXG4gICAgZG90SXRlbSA9IG9wdGlvbihwcm9wcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBjbGFzc05hbWUgPSAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtYXJlYS1kb3QnLCB0eXBlb2Ygb3B0aW9uICE9PSAnYm9vbGVhbicgPyBvcHRpb24uY2xhc3NOYW1lIDogJycpO1xyXG4gICAgdmFyIGtleSA9IHByb3BzLmtleSxcclxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkMik7XHJcbiAgICBkb3RJdGVtID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfRG90LkRvdCwgX2V4dGVuZHMoe30sIHJlc3QsIHtcclxuICAgICAga2V5OiBrZXksXHJcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXHJcbiAgICB9KSk7XHJcbiAgfVxyXG4gIHJldHVybiBkb3RJdGVtO1xyXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBcmVhIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX2Nsc3giLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX3JlYWN0U21vb3RoIiwiX2lzRnVuY3Rpb24iLCJfbWF4IiwiX2lzTmlsIiwiX2lzTmFOIiwiX2lzRXF1YWwiLCJfQ3VydmUiLCJfRG90IiwiX0xheWVyIiwiX0xhYmVsTGlzdCIsIl9HbG9iYWwiLCJfRGF0YVV0aWxzIiwiX0NoYXJ0VXRpbHMiLCJfUmVhY3RVdGlscyIsIl9leGNsdWRlZCIsIl9leGNsdWRlZDIiLCJfQXJlYSIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX3R5cGVvZiIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJzb3VyY2UiLCJleGNsdWRlZCIsInRhcmdldCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwia2V5IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsImxlbmd0aCIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsImFyZ3VtZW50cyIsImFwcGx5Iiwib3duS2V5cyIsImtleXMiLCJmaWx0ZXIiLCJlbnVtZXJhYmxlIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1Byb3BlcnR5S2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NhbGxTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiQm9vbGVhbiIsInZhbHVlT2YiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwicCIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiX1B1cmVDb21wb25lbnQiLCJfdGhpcyIsIl9sZW4iLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiY29uY2F0IiwiaXNBbmltYXRpb25GaW5pc2hlZCIsInVuaXF1ZUlkIiwib25BbmltYXRpb25FbmQiLCJzZXRTdGF0ZSIsIm9uQW5pbWF0aW9uU3RhcnQiLCJyZW5kZXJEb3RzIiwibmVlZENsaXAiLCJjbGlwRG90IiwiY2xpcFBhdGhJZCIsImlzQW5pbWF0aW9uQWN0aXZlIiwic3RhdGUiLCJfdGhpcyRwcm9wcyIsImRvdCIsInBvaW50cyIsImRhdGFLZXkiLCJhcmVhUHJvcHMiLCJmaWx0ZXJQcm9wcyIsImN1c3RvbURvdFByb3BzIiwiZG90cyIsIm1hcCIsImVudHJ5IiwiZG90UHJvcHMiLCJpbmRleCIsImN4IiwieCIsImN5IiwieSIsInBheWxvYWQiLCJyZW5kZXJEb3RJdGVtIiwiZG90c1Byb3BzIiwiY2xpcFBhdGgiLCJjcmVhdGVFbGVtZW50IiwiTGF5ZXIiLCJjbGFzc05hbWUiLCJyZW5kZXJIb3Jpem9udGFsUmVjdCIsImFscGhhIiwiX3RoaXMkcHJvcHMyIiwiYmFzZUxpbmUiLCJzdHJva2VXaWR0aCIsInN0YXJ0WCIsImVuZFgiLCJ3aWR0aCIsIk1hdGgiLCJhYnMiLCJtYXhZIiwiaXNOdW1iZXIiLCJtYXgiLCJpc0FycmF5IiwiaGVpZ2h0IiwiZmxvb3IiLCJwYXJzZUludCIsInJlbmRlclZlcnRpY2FsUmVjdCIsIl90aGlzJHByb3BzMyIsInN0YXJ0WSIsImVuZFkiLCJtYXhYIiwicmVuZGVyQ2xpcFJlY3QiLCJsYXlvdXQiLCJyZW5kZXJBcmVhU3RhdGljYWxseSIsIl90aGlzJHByb3BzNCIsInR5cGUiLCJzdHJva2UiLCJjb25uZWN0TnVsbHMiLCJpc1JhbmdlIiwicmVmIiwib3RoZXJzIiwiQ3VydmUiLCJmaWxsIiwicmVuZGVyQXJlYVdpdGhBbmltYXRpb24iLCJfdGhpczIiLCJfdGhpcyRwcm9wczUiLCJhbmltYXRpb25CZWdpbiIsImFuaW1hdGlvbkR1cmF0aW9uIiwiYW5pbWF0aW9uRWFzaW5nIiwiYW5pbWF0aW9uSWQiLCJfdGhpcyRzdGF0ZSIsInByZXZQb2ludHMiLCJwcmV2QmFzZUxpbmUiLCJiZWdpbiIsImR1cmF0aW9uIiwiaXNBY3RpdmUiLCJlYXNpbmciLCJmcm9tIiwidG8iLCJoYW5kbGVBbmltYXRpb25FbmQiLCJoYW5kbGVBbmltYXRpb25TdGFydCIsIl9yZWYiLCJwcmV2UG9pbnRzRGlmZkZhY3RvciIsInN0ZXBQb2ludHMiLCJwcmV2UG9pbnRJbmRleCIsInByZXYiLCJpbnRlcnBvbGF0b3JYIiwiaW50ZXJwb2xhdGVOdW1iZXIiLCJpbnRlcnBvbGF0b3JZIiwic3RlcEJhc2VMaW5lIiwiaW50ZXJwb2xhdG9yIiwiX2ludGVycG9sYXRvciIsImlkIiwicmVuZGVyQXJlYSIsIl90aGlzJHByb3BzNiIsIl90aGlzJHN0YXRlMiIsInRvdGFsTGVuZ3RoIiwicmVuZGVyIiwiX2ZpbHRlclByb3BzIiwiX3RoaXMkcHJvcHM3IiwiaGlkZSIsInRvcCIsImxlZnQiLCJ4QXhpcyIsInlBeGlzIiwiaGFzU2luZ2xlUG9pbnQiLCJsYXllckNsYXNzIiwibmVlZENsaXBYIiwiYWxsb3dEYXRhT3ZlcmZsb3ciLCJuZWVkQ2xpcFkiLCJfcmVmMiIsIl9yZWYyJHIiLCJfcmVmMiRzdHJva2VXaWR0aCIsIl9yZWYzIiwiaGFzQ2xpcERvdCIsIl9yZWYzJGNsaXBEb3QiLCJkb3RTaXplIiwiTGFiZWxMaXN0IiwicmVuZGVyQ2FsbEJ5UGFyZW50IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwibmV4dFByb3BzIiwicHJldlN0YXRlIiwicHJldkFuaW1hdGlvbklkIiwiY3VyUG9pbnRzIiwiY3VyQmFzZUxpbmUiLCJQdXJlQ29tcG9uZW50IiwiZmlsbE9wYWNpdHkiLCJ4QXhpc0lkIiwieUF4aXNJZCIsImxlZ2VuZFR5cGUiLCJhY3RpdmVEb3QiLCJHbG9iYWwiLCJpc1NzciIsIml0ZW0iLCJjaGFydEJhc2VWYWx1ZSIsImJhc2VWYWx1ZSIsIml0ZW1CYXNlVmFsdWUiLCJudW1lcmljQXhpcyIsImRvbWFpbiIsInNjYWxlIiwiZG9tYWluTWF4IiwiZG9tYWluTWluIiwibWluIiwiX3JlZjQiLCJ4QXhpc1RpY2tzIiwieUF4aXNUaWNrcyIsImJhbmRTaXplIiwic3RhY2tlZERhdGEiLCJkYXRhU3RhcnRJbmRleCIsImRpc3BsYXllZERhdGEiLCJvZmZzZXQiLCJoYXNTdGFjayIsImdldEJhc2VWYWx1ZSIsImlzSG9yaXpvbnRhbExheW91dCIsImdldFZhbHVlQnlEYXRhS2V5IiwiaXNCcmVha1BvaW50IiwiZ2V0Q2F0ZUNvb3JkaW5hdGVPZkxpbmUiLCJheGlzIiwidGlja3MiLCJvcHRpb24iLCJkb3RJdGVtIiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJyZXN0IiwiRG90Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/cartesian/Area.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/cartesian/Bar.js":
/*!****************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/Bar.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Bar = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _isEqual = _interopRequireDefault(__webpack_require__(/*! lodash/isEqual */ \"lodash/isEqual\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _ErrorBar = __webpack_require__(/*! ./ErrorBar */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/ErrorBar.js\");\nvar _Cell = __webpack_require__(/*! ../component/Cell */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Cell.js\");\nvar _LabelList = __webpack_require__(/*! ../component/LabelList */ \"(pages-dir-node)/./node_modules/recharts/lib/component/LabelList.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"(pages-dir-node)/./node_modules/recharts/lib/util/Global.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _types = __webpack_require__(/*! ../util/types */ \"(pages-dir-node)/./node_modules/recharts/lib/util/types.js\");\nvar _BarUtils = __webpack_require__(/*! ../util/BarUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/BarUtils.js\");\nvar _excluded = [\n    \"value\",\n    \"background\"\n];\nvar _Bar;\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Render a group of bar\r\n */ \nvar Bar = exports.Bar = /*#__PURE__*/ function(_PureComponent) {\n    function Bar() {\n        var _this;\n        _classCallCheck(this, Bar);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, Bar, [].concat(args));\n        _defineProperty(_this, \"state\", {\n            isAnimationFinished: false\n        });\n        _defineProperty(_this, \"id\", (0, _DataUtils.uniqueId)('recharts-bar-'));\n        _defineProperty(_this, \"handleAnimationEnd\", function() {\n            var onAnimationEnd = _this.props.onAnimationEnd;\n            _this.setState({\n                isAnimationFinished: true\n            });\n            if (onAnimationEnd) {\n                onAnimationEnd();\n            }\n        });\n        _defineProperty(_this, \"handleAnimationStart\", function() {\n            var onAnimationStart = _this.props.onAnimationStart;\n            _this.setState({\n                isAnimationFinished: false\n            });\n            if (onAnimationStart) {\n                onAnimationStart();\n            }\n        });\n        return _this;\n    }\n    _inherits(Bar, _PureComponent);\n    return _createClass(Bar, [\n        {\n            key: \"renderRectanglesStatically\",\n            value: function renderRectanglesStatically(data) {\n                var _this2 = this;\n                var _this$props = this.props, shape = _this$props.shape, dataKey = _this$props.dataKey, activeIndex = _this$props.activeIndex, activeBar = _this$props.activeBar;\n                var baseProps = (0, _ReactUtils.filterProps)(this.props, false);\n                return data && data.map(function(entry, i) {\n                    var isActive = i === activeIndex;\n                    var option = isActive ? activeBar : shape;\n                    var props = _objectSpread(_objectSpread(_objectSpread({}, baseProps), entry), {}, {\n                        isActive: isActive,\n                        option: option,\n                        index: i,\n                        dataKey: dataKey,\n                        onAnimationStart: _this2.handleAnimationStart,\n                        onAnimationEnd: _this2.handleAnimationEnd\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                        className: \"recharts-bar-rectangle\"\n                    }, (0, _types.adaptEventsOfChild)(_this2.props, entry, i), {\n                        // https://github.com/recharts/recharts/issues/5415\n                        // eslint-disable-next-line react/no-array-index-key\n                        key: \"rectangle-\".concat(entry === null || entry === void 0 ? void 0 : entry.x, \"-\").concat(entry === null || entry === void 0 ? void 0 : entry.y, \"-\").concat(entry === null || entry === void 0 ? void 0 : entry.value, \"-\").concat(i)\n                    }), /*#__PURE__*/ _react[\"default\"].createElement(_BarUtils.BarRectangle, props));\n                });\n            }\n        },\n        {\n            key: \"renderRectanglesWithAnimation\",\n            value: function renderRectanglesWithAnimation() {\n                var _this3 = this;\n                var _this$props2 = this.props, data = _this$props2.data, layout = _this$props2.layout, isAnimationActive = _this$props2.isAnimationActive, animationBegin = _this$props2.animationBegin, animationDuration = _this$props2.animationDuration, animationEasing = _this$props2.animationEasing, animationId = _this$props2.animationId;\n                var prevData = this.state.prevData;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n                    begin: animationBegin,\n                    duration: animationDuration,\n                    isActive: isAnimationActive,\n                    easing: animationEasing,\n                    from: {\n                        t: 0\n                    },\n                    to: {\n                        t: 1\n                    },\n                    key: \"bar-\".concat(animationId),\n                    onAnimationEnd: this.handleAnimationEnd,\n                    onAnimationStart: this.handleAnimationStart\n                }, function(_ref) {\n                    var t = _ref.t;\n                    var stepData = data.map(function(entry, index) {\n                        var prev = prevData && prevData[index];\n                        if (prev) {\n                            var interpolatorX = (0, _DataUtils.interpolateNumber)(prev.x, entry.x);\n                            var interpolatorY = (0, _DataUtils.interpolateNumber)(prev.y, entry.y);\n                            var interpolatorWidth = (0, _DataUtils.interpolateNumber)(prev.width, entry.width);\n                            var interpolatorHeight = (0, _DataUtils.interpolateNumber)(prev.height, entry.height);\n                            return _objectSpread(_objectSpread({}, entry), {}, {\n                                x: interpolatorX(t),\n                                y: interpolatorY(t),\n                                width: interpolatorWidth(t),\n                                height: interpolatorHeight(t)\n                            });\n                        }\n                        if (layout === 'horizontal') {\n                            var _interpolatorHeight = (0, _DataUtils.interpolateNumber)(0, entry.height);\n                            var h = _interpolatorHeight(t);\n                            return _objectSpread(_objectSpread({}, entry), {}, {\n                                y: entry.y + entry.height - h,\n                                height: h\n                            });\n                        }\n                        var interpolator = (0, _DataUtils.interpolateNumber)(0, entry.width);\n                        var w = interpolator(t);\n                        return _objectSpread(_objectSpread({}, entry), {}, {\n                            width: w\n                        });\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, null, _this3.renderRectanglesStatically(stepData));\n                });\n            }\n        },\n        {\n            key: \"renderRectangles\",\n            value: function renderRectangles() {\n                var _this$props3 = this.props, data = _this$props3.data, isAnimationActive = _this$props3.isAnimationActive;\n                var prevData = this.state.prevData;\n                if (isAnimationActive && data && data.length && (!prevData || !(0, _isEqual[\"default\"])(prevData, data))) {\n                    return this.renderRectanglesWithAnimation();\n                }\n                return this.renderRectanglesStatically(data);\n            }\n        },\n        {\n            key: \"renderBackground\",\n            value: function renderBackground() {\n                var _this4 = this;\n                var _this$props4 = this.props, data = _this$props4.data, dataKey = _this$props4.dataKey, activeIndex = _this$props4.activeIndex;\n                var backgroundProps = (0, _ReactUtils.filterProps)(this.props.background, false);\n                return data.map(function(entry, i) {\n                    var value = entry.value, background = entry.background, rest = _objectWithoutProperties(entry, _excluded);\n                    if (!background) {\n                        return null;\n                    }\n                    var props = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, rest), {}, {\n                        fill: '#eee'\n                    }, background), backgroundProps), (0, _types.adaptEventsOfChild)(_this4.props, entry, i)), {}, {\n                        onAnimationStart: _this4.handleAnimationStart,\n                        onAnimationEnd: _this4.handleAnimationEnd,\n                        dataKey: dataKey,\n                        index: i,\n                        className: 'recharts-bar-background-rectangle'\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_BarUtils.BarRectangle, _extends({\n                        key: \"background-bar-\".concat(i),\n                        option: _this4.props.background,\n                        isActive: i === activeIndex\n                    }, props));\n                });\n            }\n        },\n        {\n            key: \"renderErrorBar\",\n            value: function renderErrorBar(needClip, clipPathId) {\n                if (this.props.isAnimationActive && !this.state.isAnimationFinished) {\n                    return null;\n                }\n                var _this$props5 = this.props, data = _this$props5.data, xAxis = _this$props5.xAxis, yAxis = _this$props5.yAxis, layout = _this$props5.layout, children = _this$props5.children;\n                var errorBarItems = (0, _ReactUtils.findAllByType)(children, _ErrorBar.ErrorBar);\n                if (!errorBarItems) {\n                    return null;\n                }\n                var offset = layout === 'vertical' ? data[0].height / 2 : data[0].width / 2;\n                var dataPointFormatter = function dataPointFormatter(dataPoint, dataKey) {\n                    /**\r\n         * if the value coming from `getComposedData` is an array then this is a stacked bar chart.\r\n         * arr[1] represents end value of the bar since the data is in the form of [startValue, endValue].\r\n         * */ var value = Array.isArray(dataPoint.value) ? dataPoint.value[1] : dataPoint.value;\n                    return {\n                        x: dataPoint.x,\n                        y: dataPoint.y,\n                        value: value,\n                        errorVal: (0, _ChartUtils.getValueByDataKey)(dataPoint, dataKey)\n                    };\n                };\n                var errorBarProps = {\n                    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : null\n                };\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, errorBarProps, errorBarItems.map(function(item) {\n                    return /*#__PURE__*/ _react[\"default\"].cloneElement(item, {\n                        key: \"error-bar-\".concat(clipPathId, \"-\").concat(item.props.dataKey),\n                        data: data,\n                        xAxis: xAxis,\n                        yAxis: yAxis,\n                        layout: layout,\n                        offset: offset,\n                        dataPointFormatter: dataPointFormatter\n                    });\n                }));\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props6 = this.props, hide = _this$props6.hide, data = _this$props6.data, className = _this$props6.className, xAxis = _this$props6.xAxis, yAxis = _this$props6.yAxis, left = _this$props6.left, top = _this$props6.top, width = _this$props6.width, height = _this$props6.height, isAnimationActive = _this$props6.isAnimationActive, background = _this$props6.background, id = _this$props6.id;\n                if (hide || !data || !data.length) {\n                    return null;\n                }\n                var isAnimationFinished = this.state.isAnimationFinished;\n                var layerClass = (0, _clsx[\"default\"])('recharts-bar', className);\n                var needClipX = xAxis && xAxis.allowDataOverflow;\n                var needClipY = yAxis && yAxis.allowDataOverflow;\n                var needClip = needClipX || needClipY;\n                var clipPathId = (0, _isNil[\"default\"])(id) ? this.id : id;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: layerClass\n                }, needClipX || needClipY ? /*#__PURE__*/ _react[\"default\"].createElement(\"defs\", null, /*#__PURE__*/ _react[\"default\"].createElement(\"clipPath\", {\n                    id: \"clipPath-\".concat(clipPathId)\n                }, /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                    x: needClipX ? left : left - width / 2,\n                    y: needClipY ? top : top - height / 2,\n                    width: needClipX ? width : width * 2,\n                    height: needClipY ? height : height * 2\n                }))) : null, /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-bar-rectangles\",\n                    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : null\n                }, background ? this.renderBackground() : null, this.renderRectangles()), this.renderErrorBar(needClip, clipPathId), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, data));\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                if (nextProps.animationId !== prevState.prevAnimationId) {\n                    return {\n                        prevAnimationId: nextProps.animationId,\n                        curData: nextProps.data,\n                        prevData: prevState.curData\n                    };\n                }\n                if (nextProps.data !== prevState.curData) {\n                    return {\n                        curData: nextProps.data\n                    };\n                }\n                return null;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_Bar = Bar;\n_defineProperty(Bar, \"displayName\", 'Bar');\n_defineProperty(Bar, \"defaultProps\", {\n    xAxisId: 0,\n    yAxisId: 0,\n    legendType: 'rect',\n    minPointSize: 0,\n    hide: false,\n    data: [],\n    layout: 'vertical',\n    activeBar: false,\n    isAnimationActive: !_Global.Global.isSsr,\n    animationBegin: 0,\n    animationDuration: 400,\n    animationEasing: 'ease'\n});\n/**\r\n * Compose the data of each group\r\n * @param {Object} props Props for the component\r\n * @param {Object} item        An instance of Bar\r\n * @param {Array} barPosition  The offset and size of each bar\r\n * @param {Object} xAxis       The configuration of x-axis\r\n * @param {Object} yAxis       The configuration of y-axis\r\n * @param {Array} stackedData  The stacked data of a bar item\r\n * @return{Array} Composed data\r\n */ _defineProperty(Bar, \"getComposedData\", function(_ref2) {\n    var props = _ref2.props, item = _ref2.item, barPosition = _ref2.barPosition, bandSize = _ref2.bandSize, xAxis = _ref2.xAxis, yAxis = _ref2.yAxis, xAxisTicks = _ref2.xAxisTicks, yAxisTicks = _ref2.yAxisTicks, stackedData = _ref2.stackedData, dataStartIndex = _ref2.dataStartIndex, displayedData = _ref2.displayedData, offset = _ref2.offset;\n    var pos = (0, _ChartUtils.findPositionOfBar)(barPosition, item);\n    if (!pos) {\n        return null;\n    }\n    var layout = props.layout;\n    var itemDefaultProps = item.type.defaultProps;\n    var itemProps = itemDefaultProps !== undefined ? _objectSpread(_objectSpread({}, itemDefaultProps), item.props) : item.props;\n    var dataKey = itemProps.dataKey, children = itemProps.children, minPointSizeProp = itemProps.minPointSize;\n    var numericAxis = layout === 'horizontal' ? yAxis : xAxis;\n    var stackedDomain = stackedData ? numericAxis.scale.domain() : null;\n    var baseValue = (0, _ChartUtils.getBaseValueOfBar)({\n        numericAxis: numericAxis\n    });\n    var cells = (0, _ReactUtils.findAllByType)(children, _Cell.Cell);\n    var rects = displayedData.map(function(entry, index) {\n        var value, x, y, width, height, background;\n        if (stackedData) {\n            value = (0, _ChartUtils.truncateByDomain)(stackedData[dataStartIndex + index], stackedDomain);\n        } else {\n            value = (0, _ChartUtils.getValueByDataKey)(entry, dataKey);\n            if (!Array.isArray(value)) {\n                value = [\n                    baseValue,\n                    value\n                ];\n            }\n        }\n        var minPointSize = (0, _BarUtils.minPointSizeCallback)(minPointSizeProp, _Bar.defaultProps.minPointSize)(value[1], index);\n        if (layout === 'horizontal') {\n            var _ref4;\n            var _ref3 = [\n                yAxis.scale(value[0]),\n                yAxis.scale(value[1])\n            ], baseValueScale = _ref3[0], currentValueScale = _ref3[1];\n            x = (0, _ChartUtils.getCateCoordinateOfBar)({\n                axis: xAxis,\n                ticks: xAxisTicks,\n                bandSize: bandSize,\n                offset: pos.offset,\n                entry: entry,\n                index: index\n            });\n            y = (_ref4 = currentValueScale !== null && currentValueScale !== void 0 ? currentValueScale : baseValueScale) !== null && _ref4 !== void 0 ? _ref4 : undefined;\n            width = pos.size;\n            var computedHeight = baseValueScale - currentValueScale;\n            height = Number.isNaN(computedHeight) ? 0 : computedHeight;\n            background = {\n                x: x,\n                y: yAxis.y,\n                width: width,\n                height: yAxis.height\n            };\n            if (Math.abs(minPointSize) > 0 && Math.abs(height) < Math.abs(minPointSize)) {\n                var delta = (0, _DataUtils.mathSign)(height || minPointSize) * (Math.abs(minPointSize) - Math.abs(height));\n                y -= delta;\n                height += delta;\n            }\n        } else {\n            var _ref5 = [\n                xAxis.scale(value[0]),\n                xAxis.scale(value[1])\n            ], _baseValueScale = _ref5[0], _currentValueScale = _ref5[1];\n            x = _baseValueScale;\n            y = (0, _ChartUtils.getCateCoordinateOfBar)({\n                axis: yAxis,\n                ticks: yAxisTicks,\n                bandSize: bandSize,\n                offset: pos.offset,\n                entry: entry,\n                index: index\n            });\n            width = _currentValueScale - _baseValueScale;\n            height = pos.size;\n            background = {\n                x: xAxis.x,\n                y: y,\n                width: xAxis.width,\n                height: height\n            };\n            if (Math.abs(minPointSize) > 0 && Math.abs(width) < Math.abs(minPointSize)) {\n                var _delta = (0, _DataUtils.mathSign)(width || minPointSize) * (Math.abs(minPointSize) - Math.abs(width));\n                width += _delta;\n            }\n        }\n        return _objectSpread(_objectSpread(_objectSpread({}, entry), {}, {\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            value: stackedData ? value : value[1],\n            payload: entry,\n            background: background\n        }, cells && cells[index] && cells[index].props), {}, {\n            tooltipPayload: [\n                (0, _ChartUtils.getTooltipItem)(item, entry)\n            ],\n            tooltipPosition: {\n                x: x + width / 2,\n                y: y + height / 2\n            }\n        });\n    });\n    return _objectSpread({\n        data: rects,\n        layout: layout\n    }, offset);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2FydGVzaWFuL0Jhci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsV0FBVyxHQUFHLEtBQUs7QUFDbkIsSUFBSUcsU0FBU0Msd0JBQXdCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNwRCxJQUFJQyxRQUFRQyx1QkFBdUJGLG1CQUFPQSxDQUFDLHVCQUFNO0FBQ2pELElBQUlHLGVBQWVELHVCQUF1QkYsbUJBQU9BLENBQUMsa0NBQWM7QUFDaEUsSUFBSUksV0FBV0YsdUJBQXVCRixtQkFBT0EsQ0FBQyxzQ0FBZ0I7QUFDOUQsSUFBSUssU0FBU0gsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJTSxTQUFTTixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDekMsSUFBSU8sWUFBWVAsbUJBQU9BLENBQUMsc0ZBQVk7QUFDcEMsSUFBSVEsUUFBUVIsbUJBQU9BLENBQUMseUZBQW1CO0FBQ3ZDLElBQUlTLGFBQWFULG1CQUFPQSxDQUFDLG1HQUF3QjtBQUNqRCxJQUFJVSxhQUFhVixtQkFBT0EsQ0FBQyx5RkFBbUI7QUFDNUMsSUFBSVcsY0FBY1gsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlZLFVBQVVaLG1CQUFPQSxDQUFDLG1GQUFnQjtBQUN0QyxJQUFJYSxjQUFjYixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDOUMsSUFBSWMsU0FBU2QsbUJBQU9BLENBQUMsaUZBQWU7QUFDcEMsSUFBSWUsWUFBWWYsbUJBQU9BLENBQUMsdUZBQWtCO0FBQzFDLElBQUlnQixZQUFZO0lBQUM7SUFBUztDQUFhO0FBQ3ZDLElBQUlDO0FBQ0osU0FBU2YsdUJBQXVCZ0IsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSx5QkFBeUJD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QVMsQ0FBQyxHQUFHaFEsV0FBVzRQLFFBQVEsRUFBRXBHLFNBQVN5RCxnQkFBaUJ3QyxDQUFBQSxLQUFLQyxHQUFHLENBQUN6QyxnQkFBZ0J3QyxLQUFLQyxHQUFHLENBQUNsRyxNQUFLO2dCQUN2R0EsU0FBU3dHO1lBQ1g7UUFDRjtRQUNBLE9BQU81TSxjQUFjQSxjQUFjQSxjQUFjLENBQUMsR0FBR2dFLFFBQVEsQ0FBQyxHQUFHO1lBQy9EVSxHQUFHQTtZQUNIQyxHQUFHQTtZQUNIeUIsT0FBT0E7WUFDUEUsUUFBUUE7WUFDUnhLLE9BQU91TyxjQUFjdk8sUUFBUUEsS0FBSyxDQUFDLEVBQUU7WUFDckMrUSxTQUFTN0k7WUFDVGlELFlBQVlBO1FBQ2QsR0FBR3FFLFNBQVNBLEtBQUssQ0FBQ25ILE1BQU0sSUFBSW1ILEtBQUssQ0FBQ25ILE1BQU0sQ0FBQ3pELEtBQUssR0FBRyxDQUFDLEdBQUc7WUFDbkRvTSxnQkFBZ0I7Z0JBQUUsSUFBRy9QLFlBQVlnUSxjQUFjLEVBQUV6RSxNQUFNdEU7YUFBTztZQUM5RGdKLGlCQUFpQjtnQkFDZnRJLEdBQUdBLElBQUkwQixRQUFRO2dCQUNmekIsR0FBR0EsSUFBSTJCLFNBQVM7WUFDbEI7UUFDRjtJQUNGO0lBQ0EsT0FBT3RHLGNBQWM7UUFDbkJzRCxNQUFNa0k7UUFDTnhHLFFBQVFBO0lBQ1YsR0FBRzhDO0FBQ0wiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXGNhcnRlc2lhblxcQmFyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuQmFyID0gdm9pZCAwO1xyXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XHJcbnZhciBfcmVhY3RTbW9vdGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1zbW9vdGhcIikpO1xyXG52YXIgX2lzRXF1YWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNFcXVhbFwiKSk7XHJcbnZhciBfaXNOaWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNOaWxcIikpO1xyXG52YXIgX0xheWVyID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9MYXllclwiKTtcclxudmFyIF9FcnJvckJhciA9IHJlcXVpcmUoXCIuL0Vycm9yQmFyXCIpO1xyXG52YXIgX0NlbGwgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50L0NlbGxcIik7XHJcbnZhciBfTGFiZWxMaXN0ID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9MYWJlbExpc3RcIik7XHJcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRGF0YVV0aWxzXCIpO1xyXG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xyXG52YXIgX0dsb2JhbCA9IHJlcXVpcmUoXCIuLi91dGlsL0dsb2JhbFwiKTtcclxudmFyIF9DaGFydFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvQ2hhcnRVdGlsc1wiKTtcclxudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuLi91dGlsL3R5cGVzXCIpO1xyXG52YXIgX0JhclV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvQmFyVXRpbHNcIik7XHJcbnZhciBfZXhjbHVkZWQgPSBbXCJ2YWx1ZVwiLCBcImJhY2tncm91bmRcIl07XHJcbnZhciBfQmFyO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XHJcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxyXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxyXG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxyXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cclxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XHJcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxyXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxyXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxyXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxyXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XHJcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxyXG4gKiBAZmlsZU92ZXJ2aWV3IFJlbmRlciBhIGdyb3VwIG9mIGJhclxyXG4gKi9cclxudmFyIEJhciA9IGV4cG9ydHMuQmFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xyXG4gIGZ1bmN0aW9uIEJhcigpIHtcclxuICAgIHZhciBfdGhpcztcclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXIpO1xyXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgICB9XHJcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgQmFyLCBbXS5jb25jYXQoYXJncykpO1xyXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInN0YXRlXCIsIHtcclxuICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogZmFsc2VcclxuICAgIH0pO1xyXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImlkXCIsICgwLCBfRGF0YVV0aWxzLnVuaXF1ZUlkKSgncmVjaGFydHMtYmFyLScpKTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVBbmltYXRpb25FbmRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgb25BbmltYXRpb25FbmQgPSBfdGhpcy5wcm9wcy5vbkFuaW1hdGlvbkVuZDtcclxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChvbkFuaW1hdGlvbkVuZCkge1xyXG4gICAgICAgIG9uQW5pbWF0aW9uRW5kKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZUFuaW1hdGlvblN0YXJ0XCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG9uQW5pbWF0aW9uU3RhcnQgPSBfdGhpcy5wcm9wcy5vbkFuaW1hdGlvblN0YXJ0O1xyXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogZmFsc2VcclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChvbkFuaW1hdGlvblN0YXJ0KSB7XHJcbiAgICAgICAgb25BbmltYXRpb25TdGFydCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcbiAgX2luaGVyaXRzKEJhciwgX1B1cmVDb21wb25lbnQpO1xyXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQmFyLCBbe1xyXG4gICAga2V5OiBcInJlbmRlclJlY3RhbmdsZXNTdGF0aWNhbGx5XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyUmVjdGFuZ2xlc1N0YXRpY2FsbHkoZGF0YSkge1xyXG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBzaGFwZSA9IF90aGlzJHByb3BzLnNoYXBlLFxyXG4gICAgICAgIGRhdGFLZXkgPSBfdGhpcyRwcm9wcy5kYXRhS2V5LFxyXG4gICAgICAgIGFjdGl2ZUluZGV4ID0gX3RoaXMkcHJvcHMuYWN0aXZlSW5kZXgsXHJcbiAgICAgICAgYWN0aXZlQmFyID0gX3RoaXMkcHJvcHMuYWN0aXZlQmFyO1xyXG4gICAgICB2YXIgYmFzZVByb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0aGlzLnByb3BzLCBmYWxzZSk7XHJcbiAgICAgIHJldHVybiBkYXRhICYmIGRhdGEubWFwKGZ1bmN0aW9uIChlbnRyeSwgaSkge1xyXG4gICAgICAgIHZhciBpc0FjdGl2ZSA9IGkgPT09IGFjdGl2ZUluZGV4O1xyXG4gICAgICAgIHZhciBvcHRpb24gPSBpc0FjdGl2ZSA/IGFjdGl2ZUJhciA6IHNoYXBlO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBiYXNlUHJvcHMpLCBlbnRyeSksIHt9LCB7XHJcbiAgICAgICAgICBpc0FjdGl2ZTogaXNBY3RpdmUsXHJcbiAgICAgICAgICBvcHRpb246IG9wdGlvbixcclxuICAgICAgICAgIGluZGV4OiBpLFxyXG4gICAgICAgICAgZGF0YUtleTogZGF0YUtleSxcclxuICAgICAgICAgIG9uQW5pbWF0aW9uU3RhcnQ6IF90aGlzMi5oYW5kbGVBbmltYXRpb25TdGFydCxcclxuICAgICAgICAgIG9uQW5pbWF0aW9uRW5kOiBfdGhpczIuaGFuZGxlQW5pbWF0aW9uRW5kXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCBfZXh0ZW5kcyh7XHJcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtYmFyLXJlY3RhbmdsZVwiXHJcbiAgICAgICAgfSwgKDAsIF90eXBlcy5hZGFwdEV2ZW50c09mQ2hpbGQpKF90aGlzMi5wcm9wcywgZW50cnksIGkpLCB7XHJcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcmVjaGFydHMvcmVjaGFydHMvaXNzdWVzLzU0MTVcclxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1hcnJheS1pbmRleC1rZXlcclxuICAgICAgICAgIGtleTogXCJyZWN0YW5nbGUtXCIuY29uY2F0KGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS54LCBcIi1cIikuY29uY2F0KGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS55LCBcIi1cIikuY29uY2F0KGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS52YWx1ZSwgXCItXCIpLmNvbmNhdChpKVxyXG4gICAgICAgIH0pLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9CYXJVdGlscy5CYXJSZWN0YW5nbGUsIHByb3BzKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJSZWN0YW5nbGVzV2l0aEFuaW1hdGlvblwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclJlY3RhbmdsZXNXaXRoQW5pbWF0aW9uKCkge1xyXG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcclxuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgZGF0YSA9IF90aGlzJHByb3BzMi5kYXRhLFxyXG4gICAgICAgIGxheW91dCA9IF90aGlzJHByb3BzMi5sYXlvdXQsXHJcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wczIuaXNBbmltYXRpb25BY3RpdmUsXHJcbiAgICAgICAgYW5pbWF0aW9uQmVnaW4gPSBfdGhpcyRwcm9wczIuYW5pbWF0aW9uQmVnaW4sXHJcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb24gPSBfdGhpcyRwcm9wczIuYW5pbWF0aW9uRHVyYXRpb24sXHJcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nID0gX3RoaXMkcHJvcHMyLmFuaW1hdGlvbkVhc2luZyxcclxuICAgICAgICBhbmltYXRpb25JZCA9IF90aGlzJHByb3BzMi5hbmltYXRpb25JZDtcclxuICAgICAgdmFyIHByZXZEYXRhID0gdGhpcy5zdGF0ZS5wcmV2RGF0YTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX3JlYWN0U21vb3RoW1wiZGVmYXVsdFwiXSwge1xyXG4gICAgICAgIGJlZ2luOiBhbmltYXRpb25CZWdpbixcclxuICAgICAgICBkdXJhdGlvbjogYW5pbWF0aW9uRHVyYXRpb24sXHJcbiAgICAgICAgaXNBY3RpdmU6IGlzQW5pbWF0aW9uQWN0aXZlLFxyXG4gICAgICAgIGVhc2luZzogYW5pbWF0aW9uRWFzaW5nLFxyXG4gICAgICAgIGZyb206IHtcclxuICAgICAgICAgIHQ6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvOiB7XHJcbiAgICAgICAgICB0OiAxXHJcbiAgICAgICAgfSxcclxuICAgICAgICBrZXk6IFwiYmFyLVwiLmNvbmNhdChhbmltYXRpb25JZCksXHJcbiAgICAgICAgb25BbmltYXRpb25FbmQ6IHRoaXMuaGFuZGxlQW5pbWF0aW9uRW5kLFxyXG4gICAgICAgIG9uQW5pbWF0aW9uU3RhcnQ6IHRoaXMuaGFuZGxlQW5pbWF0aW9uU3RhcnRcclxuICAgICAgfSwgZnVuY3Rpb24gKF9yZWYpIHtcclxuICAgICAgICB2YXIgdCA9IF9yZWYudDtcclxuICAgICAgICB2YXIgc3RlcERhdGEgPSBkYXRhLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XHJcbiAgICAgICAgICB2YXIgcHJldiA9IHByZXZEYXRhICYmIHByZXZEYXRhW2luZGV4XTtcclxuICAgICAgICAgIGlmIChwcmV2KSB7XHJcbiAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3JYID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKHByZXYueCwgZW50cnkueCk7XHJcbiAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3JZID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKHByZXYueSwgZW50cnkueSk7XHJcbiAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3JXaWR0aCA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShwcmV2LndpZHRoLCBlbnRyeS53aWR0aCk7XHJcbiAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3JIZWlnaHQgPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikocHJldi5oZWlnaHQsIGVudHJ5LmhlaWdodCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcclxuICAgICAgICAgICAgICB4OiBpbnRlcnBvbGF0b3JYKHQpLFxyXG4gICAgICAgICAgICAgIHk6IGludGVycG9sYXRvclkodCksXHJcbiAgICAgICAgICAgICAgd2lkdGg6IGludGVycG9sYXRvcldpZHRoKHQpLFxyXG4gICAgICAgICAgICAgIGhlaWdodDogaW50ZXJwb2xhdG9ySGVpZ2h0KHQpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGxheW91dCA9PT0gJ2hvcml6b250YWwnKSB7XHJcbiAgICAgICAgICAgIHZhciBfaW50ZXJwb2xhdG9ySGVpZ2h0ID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKDAsIGVudHJ5LmhlaWdodCk7XHJcbiAgICAgICAgICAgIHZhciBoID0gX2ludGVycG9sYXRvckhlaWdodCh0KTtcclxuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xyXG4gICAgICAgICAgICAgIHk6IGVudHJ5LnkgKyBlbnRyeS5oZWlnaHQgLSBoLFxyXG4gICAgICAgICAgICAgIGhlaWdodDogaFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3IgPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikoMCwgZW50cnkud2lkdGgpO1xyXG4gICAgICAgICAgdmFyIHcgPSBpbnRlcnBvbGF0b3IodCk7XHJcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeSksIHt9LCB7XHJcbiAgICAgICAgICAgIHdpZHRoOiB3XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIG51bGwsIF90aGlzMy5yZW5kZXJSZWN0YW5nbGVzU3RhdGljYWxseShzdGVwRGF0YSkpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyUmVjdGFuZ2xlc1wiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclJlY3RhbmdsZXMoKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIGRhdGEgPSBfdGhpcyRwcm9wczMuZGF0YSxcclxuICAgICAgICBpc0FuaW1hdGlvbkFjdGl2ZSA9IF90aGlzJHByb3BzMy5pc0FuaW1hdGlvbkFjdGl2ZTtcclxuICAgICAgdmFyIHByZXZEYXRhID0gdGhpcy5zdGF0ZS5wcmV2RGF0YTtcclxuICAgICAgaWYgKGlzQW5pbWF0aW9uQWN0aXZlICYmIGRhdGEgJiYgZGF0YS5sZW5ndGggJiYgKCFwcmV2RGF0YSB8fCAhKDAsIF9pc0VxdWFsW1wiZGVmYXVsdFwiXSkocHJldkRhdGEsIGRhdGEpKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlclJlY3RhbmdsZXNXaXRoQW5pbWF0aW9uKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyUmVjdGFuZ2xlc1N0YXRpY2FsbHkoZGF0YSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJlbmRlckJhY2tncm91bmRcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJCYWNrZ3JvdW5kKCkge1xyXG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcclxuICAgICAgdmFyIF90aGlzJHByb3BzNCA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgZGF0YSA9IF90aGlzJHByb3BzNC5kYXRhLFxyXG4gICAgICAgIGRhdGFLZXkgPSBfdGhpcyRwcm9wczQuZGF0YUtleSxcclxuICAgICAgICBhY3RpdmVJbmRleCA9IF90aGlzJHByb3BzNC5hY3RpdmVJbmRleDtcclxuICAgICAgdmFyIGJhY2tncm91bmRQcm9wcyA9ICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykodGhpcy5wcm9wcy5iYWNrZ3JvdW5kLCBmYWxzZSk7XHJcbiAgICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbiAoZW50cnksIGkpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBlbnRyeS52YWx1ZSxcclxuICAgICAgICAgIGJhY2tncm91bmQgPSBlbnRyeS5iYWNrZ3JvdW5kLFxyXG4gICAgICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhlbnRyeSwgX2V4Y2x1ZGVkKTtcclxuICAgICAgICBpZiAoIWJhY2tncm91bmQpIHtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlc3QpLCB7fSwge1xyXG4gICAgICAgICAgZmlsbDogJyNlZWUnXHJcbiAgICAgICAgfSwgYmFja2dyb3VuZCksIGJhY2tncm91bmRQcm9wcyksICgwLCBfdHlwZXMuYWRhcHRFdmVudHNPZkNoaWxkKShfdGhpczQucHJvcHMsIGVudHJ5LCBpKSksIHt9LCB7XHJcbiAgICAgICAgICBvbkFuaW1hdGlvblN0YXJ0OiBfdGhpczQuaGFuZGxlQW5pbWF0aW9uU3RhcnQsXHJcbiAgICAgICAgICBvbkFuaW1hdGlvbkVuZDogX3RoaXM0LmhhbmRsZUFuaW1hdGlvbkVuZCxcclxuICAgICAgICAgIGRhdGFLZXk6IGRhdGFLZXksXHJcbiAgICAgICAgICBpbmRleDogaSxcclxuICAgICAgICAgIGNsYXNzTmFtZTogJ3JlY2hhcnRzLWJhci1iYWNrZ3JvdW5kLXJlY3RhbmdsZSdcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfQmFyVXRpbHMuQmFyUmVjdGFuZ2xlLCBfZXh0ZW5kcyh7XHJcbiAgICAgICAgICBrZXk6IFwiYmFja2dyb3VuZC1iYXItXCIuY29uY2F0KGkpLFxyXG4gICAgICAgICAgb3B0aW9uOiBfdGhpczQucHJvcHMuYmFja2dyb3VuZCxcclxuICAgICAgICAgIGlzQWN0aXZlOiBpID09PSBhY3RpdmVJbmRleFxyXG4gICAgICAgIH0sIHByb3BzKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJFcnJvckJhclwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckVycm9yQmFyKG5lZWRDbGlwLCBjbGlwUGF0aElkKSB7XHJcbiAgICAgIGlmICh0aGlzLnByb3BzLmlzQW5pbWF0aW9uQWN0aXZlICYmICF0aGlzLnN0YXRlLmlzQW5pbWF0aW9uRmluaXNoZWQpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgX3RoaXMkcHJvcHM1ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBkYXRhID0gX3RoaXMkcHJvcHM1LmRhdGEsXHJcbiAgICAgICAgeEF4aXMgPSBfdGhpcyRwcm9wczUueEF4aXMsXHJcbiAgICAgICAgeUF4aXMgPSBfdGhpcyRwcm9wczUueUF4aXMsXHJcbiAgICAgICAgbGF5b3V0ID0gX3RoaXMkcHJvcHM1LmxheW91dCxcclxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzNS5jaGlsZHJlbjtcclxuICAgICAgdmFyIGVycm9yQmFySXRlbXMgPSAoMCwgX1JlYWN0VXRpbHMuZmluZEFsbEJ5VHlwZSkoY2hpbGRyZW4sIF9FcnJvckJhci5FcnJvckJhcik7XHJcbiAgICAgIGlmICghZXJyb3JCYXJJdGVtcykge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBvZmZzZXQgPSBsYXlvdXQgPT09ICd2ZXJ0aWNhbCcgPyBkYXRhWzBdLmhlaWdodCAvIDIgOiBkYXRhWzBdLndpZHRoIC8gMjtcclxuICAgICAgdmFyIGRhdGFQb2ludEZvcm1hdHRlciA9IGZ1bmN0aW9uIGRhdGFQb2ludEZvcm1hdHRlcihkYXRhUG9pbnQsIGRhdGFLZXkpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBpZiB0aGUgdmFsdWUgY29taW5nIGZyb20gYGdldENvbXBvc2VkRGF0YWAgaXMgYW4gYXJyYXkgdGhlbiB0aGlzIGlzIGEgc3RhY2tlZCBiYXIgY2hhcnQuXHJcbiAgICAgICAgICogYXJyWzFdIHJlcHJlc2VudHMgZW5kIHZhbHVlIG9mIHRoZSBiYXIgc2luY2UgdGhlIGRhdGEgaXMgaW4gdGhlIGZvcm0gb2YgW3N0YXJ0VmFsdWUsIGVuZFZhbHVlXS5cclxuICAgICAgICAgKiAqL1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IEFycmF5LmlzQXJyYXkoZGF0YVBvaW50LnZhbHVlKSA/IGRhdGFQb2ludC52YWx1ZVsxXSA6IGRhdGFQb2ludC52YWx1ZTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgeDogZGF0YVBvaW50LngsXHJcbiAgICAgICAgICB5OiBkYXRhUG9pbnQueSxcclxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgIGVycm9yVmFsOiAoMCwgX0NoYXJ0VXRpbHMuZ2V0VmFsdWVCeURhdGFLZXkpKGRhdGFQb2ludCwgZGF0YUtleSlcclxuICAgICAgICB9O1xyXG4gICAgICB9O1xyXG4gICAgICB2YXIgZXJyb3JCYXJQcm9wcyA9IHtcclxuICAgICAgICBjbGlwUGF0aDogbmVlZENsaXAgPyBcInVybCgjY2xpcFBhdGgtXCIuY29uY2F0KGNsaXBQYXRoSWQsIFwiKVwiKSA6IG51bGxcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCBlcnJvckJhclByb3BzLCBlcnJvckJhckl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQoaXRlbSwge1xyXG4gICAgICAgICAga2V5OiBcImVycm9yLWJhci1cIi5jb25jYXQoY2xpcFBhdGhJZCwgXCItXCIpLmNvbmNhdChpdGVtLnByb3BzLmRhdGFLZXkpLFxyXG4gICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICAgIHhBeGlzOiB4QXhpcyxcclxuICAgICAgICAgIHlBeGlzOiB5QXhpcyxcclxuICAgICAgICAgIGxheW91dDogbGF5b3V0LFxyXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXHJcbiAgICAgICAgICBkYXRhUG9pbnRGb3JtYXR0ZXI6IGRhdGFQb2ludEZvcm1hdHRlclxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJlbmRlclwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcclxuICAgICAgdmFyIF90aGlzJHByb3BzNiA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgaGlkZSA9IF90aGlzJHByb3BzNi5oaWRlLFxyXG4gICAgICAgIGRhdGEgPSBfdGhpcyRwcm9wczYuZGF0YSxcclxuICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczYuY2xhc3NOYW1lLFxyXG4gICAgICAgIHhBeGlzID0gX3RoaXMkcHJvcHM2LnhBeGlzLFxyXG4gICAgICAgIHlBeGlzID0gX3RoaXMkcHJvcHM2LnlBeGlzLFxyXG4gICAgICAgIGxlZnQgPSBfdGhpcyRwcm9wczYubGVmdCxcclxuICAgICAgICB0b3AgPSBfdGhpcyRwcm9wczYudG9wLFxyXG4gICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHM2LndpZHRoLFxyXG4gICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzNi5oZWlnaHQsXHJcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wczYuaXNBbmltYXRpb25BY3RpdmUsXHJcbiAgICAgICAgYmFja2dyb3VuZCA9IF90aGlzJHByb3BzNi5iYWNrZ3JvdW5kLFxyXG4gICAgICAgIGlkID0gX3RoaXMkcHJvcHM2LmlkO1xyXG4gICAgICBpZiAoaGlkZSB8fCAhZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgaXNBbmltYXRpb25GaW5pc2hlZCA9IHRoaXMuc3RhdGUuaXNBbmltYXRpb25GaW5pc2hlZDtcclxuICAgICAgdmFyIGxheWVyQ2xhc3MgPSAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtYmFyJywgY2xhc3NOYW1lKTtcclxuICAgICAgdmFyIG5lZWRDbGlwWCA9IHhBeGlzICYmIHhBeGlzLmFsbG93RGF0YU92ZXJmbG93O1xyXG4gICAgICB2YXIgbmVlZENsaXBZID0geUF4aXMgJiYgeUF4aXMuYWxsb3dEYXRhT3ZlcmZsb3c7XHJcbiAgICAgIHZhciBuZWVkQ2xpcCA9IG5lZWRDbGlwWCB8fCBuZWVkQ2xpcFk7XHJcbiAgICAgIHZhciBjbGlwUGF0aElkID0gKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGlkKSA/IHRoaXMuaWQgOiBpZDtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBsYXllckNsYXNzXHJcbiAgICAgIH0sIG5lZWRDbGlwWCB8fCBuZWVkQ2xpcFkgPyAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiLCBudWxsLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIiwge1xyXG4gICAgICAgIGlkOiBcImNsaXBQYXRoLVwiLmNvbmNhdChjbGlwUGF0aElkKVxyXG4gICAgICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XHJcbiAgICAgICAgeDogbmVlZENsaXBYID8gbGVmdCA6IGxlZnQgLSB3aWR0aCAvIDIsXHJcbiAgICAgICAgeTogbmVlZENsaXBZID8gdG9wIDogdG9wIC0gaGVpZ2h0IC8gMixcclxuICAgICAgICB3aWR0aDogbmVlZENsaXBYID8gd2lkdGggOiB3aWR0aCAqIDIsXHJcbiAgICAgICAgaGVpZ2h0OiBuZWVkQ2xpcFkgPyBoZWlnaHQgOiBoZWlnaHQgKiAyXHJcbiAgICAgIH0pKSkgOiBudWxsLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xyXG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1iYXItcmVjdGFuZ2xlc1wiLFxyXG4gICAgICAgIGNsaXBQYXRoOiBuZWVkQ2xpcCA/IFwidXJsKCNjbGlwUGF0aC1cIi5jb25jYXQoY2xpcFBhdGhJZCwgXCIpXCIpIDogbnVsbFxyXG4gICAgICB9LCBiYWNrZ3JvdW5kID8gdGhpcy5yZW5kZXJCYWNrZ3JvdW5kKCkgOiBudWxsLCB0aGlzLnJlbmRlclJlY3RhbmdsZXMoKSksIHRoaXMucmVuZGVyRXJyb3JCYXIobmVlZENsaXAsIGNsaXBQYXRoSWQpLCAoIWlzQW5pbWF0aW9uQWN0aXZlIHx8IGlzQW5pbWF0aW9uRmluaXNoZWQpICYmIF9MYWJlbExpc3QuTGFiZWxMaXN0LnJlbmRlckNhbGxCeVBhcmVudCh0aGlzLnByb3BzLCBkYXRhKSk7XHJcbiAgICB9XHJcbiAgfV0sIFt7XHJcbiAgICBrZXk6IFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKSB7XHJcbiAgICAgIGlmIChuZXh0UHJvcHMuYW5pbWF0aW9uSWQgIT09IHByZXZTdGF0ZS5wcmV2QW5pbWF0aW9uSWQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgcHJldkFuaW1hdGlvbklkOiBuZXh0UHJvcHMuYW5pbWF0aW9uSWQsXHJcbiAgICAgICAgICBjdXJEYXRhOiBuZXh0UHJvcHMuZGF0YSxcclxuICAgICAgICAgIHByZXZEYXRhOiBwcmV2U3RhdGUuY3VyRGF0YVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5leHRQcm9wcy5kYXRhICE9PSBwcmV2U3RhdGUuY3VyRGF0YSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBjdXJEYXRhOiBuZXh0UHJvcHMuZGF0YVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfV0pO1xyXG59KF9yZWFjdC5QdXJlQ29tcG9uZW50KTtcclxuX0JhciA9IEJhcjtcclxuX2RlZmluZVByb3BlcnR5KEJhciwgXCJkaXNwbGF5TmFtZVwiLCAnQmFyJyk7XHJcbl9kZWZpbmVQcm9wZXJ0eShCYXIsIFwiZGVmYXVsdFByb3BzXCIsIHtcclxuICB4QXhpc0lkOiAwLFxyXG4gIHlBeGlzSWQ6IDAsXHJcbiAgbGVnZW5kVHlwZTogJ3JlY3QnLFxyXG4gIG1pblBvaW50U2l6ZTogMCxcclxuICBoaWRlOiBmYWxzZSxcclxuICBkYXRhOiBbXSxcclxuICBsYXlvdXQ6ICd2ZXJ0aWNhbCcsXHJcbiAgYWN0aXZlQmFyOiBmYWxzZSxcclxuICBpc0FuaW1hdGlvbkFjdGl2ZTogIV9HbG9iYWwuR2xvYmFsLmlzU3NyLFxyXG4gIGFuaW1hdGlvbkJlZ2luOiAwLFxyXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA0MDAsXHJcbiAgYW5pbWF0aW9uRWFzaW5nOiAnZWFzZSdcclxufSk7XHJcbi8qKlxyXG4gKiBDb21wb3NlIHRoZSBkYXRhIG9mIGVhY2ggZ3JvdXBcclxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFByb3BzIGZvciB0aGUgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtICAgICAgICBBbiBpbnN0YW5jZSBvZiBCYXJcclxuICogQHBhcmFtIHtBcnJheX0gYmFyUG9zaXRpb24gIFRoZSBvZmZzZXQgYW5kIHNpemUgb2YgZWFjaCBiYXJcclxuICogQHBhcmFtIHtPYmplY3R9IHhBeGlzICAgICAgIFRoZSBjb25maWd1cmF0aW9uIG9mIHgtYXhpc1xyXG4gKiBAcGFyYW0ge09iamVjdH0geUF4aXMgICAgICAgVGhlIGNvbmZpZ3VyYXRpb24gb2YgeS1heGlzXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YWNrZWREYXRhICBUaGUgc3RhY2tlZCBkYXRhIG9mIGEgYmFyIGl0ZW1cclxuICogQHJldHVybntBcnJheX0gQ29tcG9zZWQgZGF0YVxyXG4gKi9cclxuX2RlZmluZVByb3BlcnR5KEJhciwgXCJnZXRDb21wb3NlZERhdGFcIiwgZnVuY3Rpb24gKF9yZWYyKSB7XHJcbiAgdmFyIHByb3BzID0gX3JlZjIucHJvcHMsXHJcbiAgICBpdGVtID0gX3JlZjIuaXRlbSxcclxuICAgIGJhclBvc2l0aW9uID0gX3JlZjIuYmFyUG9zaXRpb24sXHJcbiAgICBiYW5kU2l6ZSA9IF9yZWYyLmJhbmRTaXplLFxyXG4gICAgeEF4aXMgPSBfcmVmMi54QXhpcyxcclxuICAgIHlBeGlzID0gX3JlZjIueUF4aXMsXHJcbiAgICB4QXhpc1RpY2tzID0gX3JlZjIueEF4aXNUaWNrcyxcclxuICAgIHlBeGlzVGlja3MgPSBfcmVmMi55QXhpc1RpY2tzLFxyXG4gICAgc3RhY2tlZERhdGEgPSBfcmVmMi5zdGFja2VkRGF0YSxcclxuICAgIGRhdGFTdGFydEluZGV4ID0gX3JlZjIuZGF0YVN0YXJ0SW5kZXgsXHJcbiAgICBkaXNwbGF5ZWREYXRhID0gX3JlZjIuZGlzcGxheWVkRGF0YSxcclxuICAgIG9mZnNldCA9IF9yZWYyLm9mZnNldDtcclxuICB2YXIgcG9zID0gKDAsIF9DaGFydFV0aWxzLmZpbmRQb3NpdGlvbk9mQmFyKShiYXJQb3NpdGlvbiwgaXRlbSk7XHJcbiAgaWYgKCFwb3MpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICB2YXIgbGF5b3V0ID0gcHJvcHMubGF5b3V0O1xyXG4gIHZhciBpdGVtRGVmYXVsdFByb3BzID0gaXRlbS50eXBlLmRlZmF1bHRQcm9wcztcclxuICB2YXIgaXRlbVByb3BzID0gaXRlbURlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBpdGVtRGVmYXVsdFByb3BzKSwgaXRlbS5wcm9wcykgOiBpdGVtLnByb3BzO1xyXG4gIHZhciBkYXRhS2V5ID0gaXRlbVByb3BzLmRhdGFLZXksXHJcbiAgICBjaGlsZHJlbiA9IGl0ZW1Qcm9wcy5jaGlsZHJlbixcclxuICAgIG1pblBvaW50U2l6ZVByb3AgPSBpdGVtUHJvcHMubWluUG9pbnRTaXplO1xyXG4gIHZhciBudW1lcmljQXhpcyA9IGxheW91dCA9PT0gJ2hvcml6b250YWwnID8geUF4aXMgOiB4QXhpcztcclxuICB2YXIgc3RhY2tlZERvbWFpbiA9IHN0YWNrZWREYXRhID8gbnVtZXJpY0F4aXMuc2NhbGUuZG9tYWluKCkgOiBudWxsO1xyXG4gIHZhciBiYXNlVmFsdWUgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0QmFzZVZhbHVlT2ZCYXIpKHtcclxuICAgIG51bWVyaWNBeGlzOiBudW1lcmljQXhpc1xyXG4gIH0pO1xyXG4gIHZhciBjZWxscyA9ICgwLCBfUmVhY3RVdGlscy5maW5kQWxsQnlUeXBlKShjaGlsZHJlbiwgX0NlbGwuQ2VsbCk7XHJcbiAgdmFyIHJlY3RzID0gZGlzcGxheWVkRGF0YS5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xyXG4gICAgdmFyIHZhbHVlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBiYWNrZ3JvdW5kO1xyXG4gICAgaWYgKHN0YWNrZWREYXRhKSB7XHJcbiAgICAgIHZhbHVlID0gKDAsIF9DaGFydFV0aWxzLnRydW5jYXRlQnlEb21haW4pKHN0YWNrZWREYXRhW2RhdGFTdGFydEluZGV4ICsgaW5kZXhdLCBzdGFja2VkRG9tYWluKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhbHVlID0gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShlbnRyeSwgZGF0YUtleSk7XHJcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICB2YWx1ZSA9IFtiYXNlVmFsdWUsIHZhbHVlXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIG1pblBvaW50U2l6ZSA9ICgwLCBfQmFyVXRpbHMubWluUG9pbnRTaXplQ2FsbGJhY2spKG1pblBvaW50U2l6ZVByb3AsIF9CYXIuZGVmYXVsdFByb3BzLm1pblBvaW50U2l6ZSkodmFsdWVbMV0sIGluZGV4KTtcclxuICAgIGlmIChsYXlvdXQgPT09ICdob3Jpem9udGFsJykge1xyXG4gICAgICB2YXIgX3JlZjQ7XHJcbiAgICAgIHZhciBfcmVmMyA9IFt5QXhpcy5zY2FsZSh2YWx1ZVswXSksIHlBeGlzLnNjYWxlKHZhbHVlWzFdKV0sXHJcbiAgICAgICAgYmFzZVZhbHVlU2NhbGUgPSBfcmVmM1swXSxcclxuICAgICAgICBjdXJyZW50VmFsdWVTY2FsZSA9IF9yZWYzWzFdO1xyXG4gICAgICB4ID0gKDAsIF9DaGFydFV0aWxzLmdldENhdGVDb29yZGluYXRlT2ZCYXIpKHtcclxuICAgICAgICBheGlzOiB4QXhpcyxcclxuICAgICAgICB0aWNrczogeEF4aXNUaWNrcyxcclxuICAgICAgICBiYW5kU2l6ZTogYmFuZFNpemUsXHJcbiAgICAgICAgb2Zmc2V0OiBwb3Mub2Zmc2V0LFxyXG4gICAgICAgIGVudHJ5OiBlbnRyeSxcclxuICAgICAgICBpbmRleDogaW5kZXhcclxuICAgICAgfSk7XHJcbiAgICAgIHkgPSAoX3JlZjQgPSBjdXJyZW50VmFsdWVTY2FsZSAhPT0gbnVsbCAmJiBjdXJyZW50VmFsdWVTY2FsZSAhPT0gdm9pZCAwID8gY3VycmVudFZhbHVlU2NhbGUgOiBiYXNlVmFsdWVTY2FsZSkgIT09IG51bGwgJiYgX3JlZjQgIT09IHZvaWQgMCA/IF9yZWY0IDogdW5kZWZpbmVkO1xyXG4gICAgICB3aWR0aCA9IHBvcy5zaXplO1xyXG4gICAgICB2YXIgY29tcHV0ZWRIZWlnaHQgPSBiYXNlVmFsdWVTY2FsZSAtIGN1cnJlbnRWYWx1ZVNjYWxlO1xyXG4gICAgICBoZWlnaHQgPSBOdW1iZXIuaXNOYU4oY29tcHV0ZWRIZWlnaHQpID8gMCA6IGNvbXB1dGVkSGVpZ2h0O1xyXG4gICAgICBiYWNrZ3JvdW5kID0ge1xyXG4gICAgICAgIHg6IHgsXHJcbiAgICAgICAgeTogeUF4aXMueSxcclxuICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiB5QXhpcy5oZWlnaHRcclxuICAgICAgfTtcclxuICAgICAgaWYgKE1hdGguYWJzKG1pblBvaW50U2l6ZSkgPiAwICYmIE1hdGguYWJzKGhlaWdodCkgPCBNYXRoLmFicyhtaW5Qb2ludFNpemUpKSB7XHJcbiAgICAgICAgdmFyIGRlbHRhID0gKDAsIF9EYXRhVXRpbHMubWF0aFNpZ24pKGhlaWdodCB8fCBtaW5Qb2ludFNpemUpICogKE1hdGguYWJzKG1pblBvaW50U2l6ZSkgLSBNYXRoLmFicyhoZWlnaHQpKTtcclxuICAgICAgICB5IC09IGRlbHRhO1xyXG4gICAgICAgIGhlaWdodCArPSBkZWx0YTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIF9yZWY1ID0gW3hBeGlzLnNjYWxlKHZhbHVlWzBdKSwgeEF4aXMuc2NhbGUodmFsdWVbMV0pXSxcclxuICAgICAgICBfYmFzZVZhbHVlU2NhbGUgPSBfcmVmNVswXSxcclxuICAgICAgICBfY3VycmVudFZhbHVlU2NhbGUgPSBfcmVmNVsxXTtcclxuICAgICAgeCA9IF9iYXNlVmFsdWVTY2FsZTtcclxuICAgICAgeSA9ICgwLCBfQ2hhcnRVdGlscy5nZXRDYXRlQ29vcmRpbmF0ZU9mQmFyKSh7XHJcbiAgICAgICAgYXhpczogeUF4aXMsXHJcbiAgICAgICAgdGlja3M6IHlBeGlzVGlja3MsXHJcbiAgICAgICAgYmFuZFNpemU6IGJhbmRTaXplLFxyXG4gICAgICAgIG9mZnNldDogcG9zLm9mZnNldCxcclxuICAgICAgICBlbnRyeTogZW50cnksXHJcbiAgICAgICAgaW5kZXg6IGluZGV4XHJcbiAgICAgIH0pO1xyXG4gICAgICB3aWR0aCA9IF9jdXJyZW50VmFsdWVTY2FsZSAtIF9iYXNlVmFsdWVTY2FsZTtcclxuICAgICAgaGVpZ2h0ID0gcG9zLnNpemU7XHJcbiAgICAgIGJhY2tncm91bmQgPSB7XHJcbiAgICAgICAgeDogeEF4aXMueCxcclxuICAgICAgICB5OiB5LFxyXG4gICAgICAgIHdpZHRoOiB4QXhpcy53aWR0aCxcclxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxyXG4gICAgICB9O1xyXG4gICAgICBpZiAoTWF0aC5hYnMobWluUG9pbnRTaXplKSA+IDAgJiYgTWF0aC5hYnMod2lkdGgpIDwgTWF0aC5hYnMobWluUG9pbnRTaXplKSkge1xyXG4gICAgICAgIHZhciBfZGVsdGEgPSAoMCwgX0RhdGFVdGlscy5tYXRoU2lnbikod2lkdGggfHwgbWluUG9pbnRTaXplKSAqIChNYXRoLmFicyhtaW5Qb2ludFNpemUpIC0gTWF0aC5hYnMod2lkdGgpKTtcclxuICAgICAgICB3aWR0aCArPSBfZGVsdGE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xyXG4gICAgICB4OiB4LFxyXG4gICAgICB5OiB5LFxyXG4gICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICB2YWx1ZTogc3RhY2tlZERhdGEgPyB2YWx1ZSA6IHZhbHVlWzFdLFxyXG4gICAgICBwYXlsb2FkOiBlbnRyeSxcclxuICAgICAgYmFja2dyb3VuZDogYmFja2dyb3VuZFxyXG4gICAgfSwgY2VsbHMgJiYgY2VsbHNbaW5kZXhdICYmIGNlbGxzW2luZGV4XS5wcm9wcyksIHt9LCB7XHJcbiAgICAgIHRvb2x0aXBQYXlsb2FkOiBbKDAsIF9DaGFydFV0aWxzLmdldFRvb2x0aXBJdGVtKShpdGVtLCBlbnRyeSldLFxyXG4gICAgICB0b29sdGlwUG9zaXRpb246IHtcclxuICAgICAgICB4OiB4ICsgd2lkdGggLyAyLFxyXG4gICAgICAgIHk6IHkgKyBoZWlnaHQgLyAyXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKHtcclxuICAgIGRhdGE6IHJlY3RzLFxyXG4gICAgbGF5b3V0OiBsYXlvdXRcclxuICB9LCBvZmZzZXQpO1xyXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJCYXIiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfY2xzeCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfcmVhY3RTbW9vdGgiLCJfaXNFcXVhbCIsIl9pc05pbCIsIl9MYXllciIsIl9FcnJvckJhciIsIl9DZWxsIiwiX0xhYmVsTGlzdCIsIl9EYXRhVXRpbHMiLCJfUmVhY3RVdGlscyIsIl9HbG9iYWwiLCJfQ2hhcnRVdGlscyIsIl90eXBlcyIsIl9CYXJVdGlscyIsIl9leGNsdWRlZCIsIl9CYXIiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwicHJvdG90eXBlIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwic291cmNlIiwiZXhjbHVkZWQiLCJ0YXJnZXQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImtleSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNvdXJjZVN5bWJvbEtleXMiLCJsZW5ndGgiLCJpbmRleE9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJhcmd1bWVudHMiLCJhcHBseSIsIm93bktleXMiLCJrZXlzIiwiZmlsdGVyIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9Qcm9wZXJ0eUtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsInAiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsIl9QdXJlQ29tcG9uZW50IiwiX3RoaXMiLCJfbGVuIiwiYXJncyIsIkFycmF5IiwiX2tleSIsImNvbmNhdCIsImlzQW5pbWF0aW9uRmluaXNoZWQiLCJ1bmlxdWVJZCIsIm9uQW5pbWF0aW9uRW5kIiwic2V0U3RhdGUiLCJvbkFuaW1hdGlvblN0YXJ0IiwicmVuZGVyUmVjdGFuZ2xlc1N0YXRpY2FsbHkiLCJkYXRhIiwiX3RoaXMyIiwiX3RoaXMkcHJvcHMiLCJzaGFwZSIsImRhdGFLZXkiLCJhY3RpdmVJbmRleCIsImFjdGl2ZUJhciIsImJhc2VQcm9wcyIsImZpbHRlclByb3BzIiwibWFwIiwiZW50cnkiLCJpc0FjdGl2ZSIsIm9wdGlvbiIsImluZGV4IiwiaGFuZGxlQW5pbWF0aW9uU3RhcnQiLCJoYW5kbGVBbmltYXRpb25FbmQiLCJjcmVhdGVFbGVtZW50IiwiTGF5ZXIiLCJjbGFzc05hbWUiLCJhZGFwdEV2ZW50c09mQ2hpbGQiLCJ4IiwieSIsIkJhclJlY3RhbmdsZSIsInJlbmRlclJlY3RhbmdsZXNXaXRoQW5pbWF0aW9uIiwiX3RoaXMzIiwiX3RoaXMkcHJvcHMyIiwibGF5b3V0IiwiaXNBbmltYXRpb25BY3RpdmUiLCJhbmltYXRpb25CZWdpbiIsImFuaW1hdGlvbkR1cmF0aW9uIiwiYW5pbWF0aW9uRWFzaW5nIiwiYW5pbWF0aW9uSWQiLCJwcmV2RGF0YSIsInN0YXRlIiwiYmVnaW4iLCJkdXJhdGlvbiIsImVhc2luZyIsImZyb20iLCJ0byIsIl9yZWYiLCJzdGVwRGF0YSIsInByZXYiLCJpbnRlcnBvbGF0b3JYIiwiaW50ZXJwb2xhdGVOdW1iZXIiLCJpbnRlcnBvbGF0b3JZIiwiaW50ZXJwb2xhdG9yV2lkdGgiLCJ3aWR0aCIsImludGVycG9sYXRvckhlaWdodCIsImhlaWdodCIsIl9pbnRlcnBvbGF0b3JIZWlnaHQiLCJoIiwiaW50ZXJwb2xhdG9yIiwidyIsInJlbmRlclJlY3RhbmdsZXMiLCJfdGhpcyRwcm9wczMiLCJyZW5kZXJCYWNrZ3JvdW5kIiwiX3RoaXM0IiwiX3RoaXMkcHJvcHM0IiwiYmFja2dyb3VuZFByb3BzIiwiYmFja2dyb3VuZCIsInJlc3QiLCJmaWxsIiwicmVuZGVyRXJyb3JCYXIiLCJuZWVkQ2xpcCIsImNsaXBQYXRoSWQiLCJfdGhpcyRwcm9wczUiLCJ4QXhpcyIsInlBeGlzIiwiY2hpbGRyZW4iLCJlcnJvckJhckl0ZW1zIiwiZmluZEFsbEJ5VHlwZSIsIkVycm9yQmFyIiwib2Zmc2V0IiwiZGF0YVBvaW50Rm9ybWF0dGVyIiwiZGF0YVBvaW50IiwiaXNBcnJheSIsImVycm9yVmFsIiwiZ2V0VmFsdWVCeURhdGFLZXkiLCJlcnJvckJhclByb3BzIiwiY2xpcFBhdGgiLCJpdGVtIiwiY2xvbmVFbGVtZW50IiwicmVuZGVyIiwiX3RoaXMkcHJvcHM2IiwiaGlkZSIsImxlZnQiLCJ0b3AiLCJpZCIsImxheWVyQ2xhc3MiLCJuZWVkQ2xpcFgiLCJhbGxvd0RhdGFPdmVyZmxvdyIsIm5lZWRDbGlwWSIsIkxhYmVsTGlzdCIsInJlbmRlckNhbGxCeVBhcmVudCIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIm5leHRQcm9wcyIsInByZXZTdGF0ZSIsInByZXZBbmltYXRpb25JZCIsImN1ckRhdGEiLCJQdXJlQ29tcG9uZW50IiwieEF4aXNJZCIsInlBeGlzSWQiLCJsZWdlbmRUeXBlIiwibWluUG9pbnRTaXplIiwiR2xvYmFsIiwiaXNTc3IiLCJfcmVmMiIsImJhclBvc2l0aW9uIiwiYmFuZFNpemUiLCJ4QXhpc1RpY2tzIiwieUF4aXNUaWNrcyIsInN0YWNrZWREYXRhIiwiZGF0YVN0YXJ0SW5kZXgiLCJkaXNwbGF5ZWREYXRhIiwicG9zIiwiZmluZFBvc2l0aW9uT2ZCYXIiLCJpdGVtRGVmYXVsdFByb3BzIiwidHlwZSIsImRlZmF1bHRQcm9wcyIsIml0ZW1Qcm9wcyIsInVuZGVmaW5lZCIsIm1pblBvaW50U2l6ZVByb3AiLCJudW1lcmljQXhpcyIsInN0YWNrZWREb21haW4iLCJzY2FsZSIsImRvbWFpbiIsImJhc2VWYWx1ZSIsImdldEJhc2VWYWx1ZU9mQmFyIiwiY2VsbHMiLCJDZWxsIiwicmVjdHMiLCJ0cnVuY2F0ZUJ5RG9tYWluIiwibWluUG9pbnRTaXplQ2FsbGJhY2siLCJfcmVmNCIsIl9yZWYzIiwiYmFzZVZhbHVlU2NhbGUiLCJjdXJyZW50VmFsdWVTY2FsZSIsImdldENhdGVDb29yZGluYXRlT2ZCYXIiLCJheGlzIiwidGlja3MiLCJzaXplIiwiY29tcHV0ZWRIZWlnaHQiLCJpc05hTiIsIk1hdGgiLCJhYnMiLCJkZWx0YSIsIm1hdGhTaWduIiwiX3JlZjUiLCJfYmFzZVZhbHVlU2NhbGUiLCJfY3VycmVudFZhbHVlU2NhbGUiLCJfZGVsdGEiLCJwYXlsb2FkIiwidG9vbHRpcFBheWxvYWQiLCJnZXRUb29sdGlwSXRlbSIsInRvb2x0aXBQb3NpdGlvbiJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/cartesian/Bar.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/cartesian/Brush.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/Brush.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Brush = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _d3Scale = __webpack_require__(/*! victory-vendor/d3-scale */ \"victory-vendor/d3-scale\");\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _range = _interopRequireDefault(__webpack_require__(/*! lodash/range */ \"lodash/range\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _Text = __webpack_require__(/*! ../component/Text */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Text.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _CssPrefixUtils = __webpack_require__(/*! ../util/CssPrefixUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/CssPrefixUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Brush\r\n */ \nvar createScale = function createScale(_ref) {\n    var data = _ref.data, startIndex = _ref.startIndex, endIndex = _ref.endIndex, x = _ref.x, width = _ref.width, travellerWidth = _ref.travellerWidth;\n    if (!data || !data.length) {\n        return {};\n    }\n    var len = data.length;\n    var scale = (0, _d3Scale.scalePoint)().domain((0, _range[\"default\"])(0, len)).range([\n        x,\n        x + width - travellerWidth\n    ]);\n    var scaleValues = scale.domain().map(function(entry) {\n        return scale(entry);\n    });\n    return {\n        isTextActive: false,\n        isSlideMoving: false,\n        isTravellerMoving: false,\n        isTravellerFocused: false,\n        startX: scale(startIndex),\n        endX: scale(endIndex),\n        scale: scale,\n        scaleValues: scaleValues\n    };\n};\nvar isTouch = function isTouch(e) {\n    return e.changedTouches && !!e.changedTouches.length;\n};\nvar Brush = exports.Brush = /*#__PURE__*/ function(_PureComponent) {\n    function Brush(props) {\n        var _this;\n        _classCallCheck(this, Brush);\n        _this = _callSuper(this, Brush, [\n            props\n        ]);\n        _defineProperty(_this, \"handleDrag\", function(e) {\n            if (_this.leaveTimer) {\n                clearTimeout(_this.leaveTimer);\n                _this.leaveTimer = null;\n            }\n            if (_this.state.isTravellerMoving) {\n                _this.handleTravellerMove(e);\n            } else if (_this.state.isSlideMoving) {\n                _this.handleSlideDrag(e);\n            }\n        });\n        _defineProperty(_this, \"handleTouchMove\", function(e) {\n            if (e.changedTouches != null && e.changedTouches.length > 0) {\n                _this.handleDrag(e.changedTouches[0]);\n            }\n        });\n        _defineProperty(_this, \"handleDragEnd\", function() {\n            _this.setState({\n                isTravellerMoving: false,\n                isSlideMoving: false\n            }, function() {\n                var _this$props = _this.props, endIndex = _this$props.endIndex, onDragEnd = _this$props.onDragEnd, startIndex = _this$props.startIndex;\n                onDragEnd === null || onDragEnd === void 0 || onDragEnd({\n                    endIndex: endIndex,\n                    startIndex: startIndex\n                });\n            });\n            _this.detachDragEndListener();\n        });\n        _defineProperty(_this, \"handleLeaveWrapper\", function() {\n            if (_this.state.isTravellerMoving || _this.state.isSlideMoving) {\n                _this.leaveTimer = window.setTimeout(_this.handleDragEnd, _this.props.leaveTimeOut);\n            }\n        });\n        _defineProperty(_this, \"handleEnterSlideOrTraveller\", function() {\n            _this.setState({\n                isTextActive: true\n            });\n        });\n        _defineProperty(_this, \"handleLeaveSlideOrTraveller\", function() {\n            _this.setState({\n                isTextActive: false\n            });\n        });\n        _defineProperty(_this, \"handleSlideDragStart\", function(e) {\n            var event = isTouch(e) ? e.changedTouches[0] : e;\n            _this.setState({\n                isTravellerMoving: false,\n                isSlideMoving: true,\n                slideMoveStartX: event.pageX\n            });\n            _this.attachDragEndListener();\n        });\n        _this.travellerDragStartHandlers = {\n            startX: _this.handleTravellerDragStart.bind(_this, 'startX'),\n            endX: _this.handleTravellerDragStart.bind(_this, 'endX')\n        };\n        _this.state = {};\n        return _this;\n    }\n    _inherits(Brush, _PureComponent);\n    return _createClass(Brush, [\n        {\n            key: \"componentWillUnmount\",\n            value: function componentWillUnmount() {\n                if (this.leaveTimer) {\n                    clearTimeout(this.leaveTimer);\n                    this.leaveTimer = null;\n                }\n                this.detachDragEndListener();\n            }\n        },\n        {\n            key: \"getIndex\",\n            value: function getIndex(_ref2) {\n                var startX = _ref2.startX, endX = _ref2.endX;\n                var scaleValues = this.state.scaleValues;\n                var _this$props2 = this.props, gap = _this$props2.gap, data = _this$props2.data;\n                var lastIndex = data.length - 1;\n                var min = Math.min(startX, endX);\n                var max = Math.max(startX, endX);\n                var minIndex = Brush.getIndexInRange(scaleValues, min);\n                var maxIndex = Brush.getIndexInRange(scaleValues, max);\n                return {\n                    startIndex: minIndex - minIndex % gap,\n                    endIndex: maxIndex === lastIndex ? lastIndex : maxIndex - maxIndex % gap\n                };\n            }\n        },\n        {\n            key: \"getTextOfTick\",\n            value: function getTextOfTick(index) {\n                var _this$props3 = this.props, data = _this$props3.data, tickFormatter = _this$props3.tickFormatter, dataKey = _this$props3.dataKey;\n                var text = (0, _ChartUtils.getValueByDataKey)(data[index], dataKey, index);\n                return (0, _isFunction[\"default\"])(tickFormatter) ? tickFormatter(text, index) : text;\n            }\n        },\n        {\n            key: \"attachDragEndListener\",\n            value: function attachDragEndListener() {\n                window.addEventListener('mouseup', this.handleDragEnd, true);\n                window.addEventListener('touchend', this.handleDragEnd, true);\n                window.addEventListener('mousemove', this.handleDrag, true);\n            }\n        },\n        {\n            key: \"detachDragEndListener\",\n            value: function detachDragEndListener() {\n                window.removeEventListener('mouseup', this.handleDragEnd, true);\n                window.removeEventListener('touchend', this.handleDragEnd, true);\n                window.removeEventListener('mousemove', this.handleDrag, true);\n            }\n        },\n        {\n            key: \"handleSlideDrag\",\n            value: function handleSlideDrag(e) {\n                var _this$state = this.state, slideMoveStartX = _this$state.slideMoveStartX, startX = _this$state.startX, endX = _this$state.endX;\n                var _this$props4 = this.props, x = _this$props4.x, width = _this$props4.width, travellerWidth = _this$props4.travellerWidth, startIndex = _this$props4.startIndex, endIndex = _this$props4.endIndex, onChange = _this$props4.onChange;\n                var delta = e.pageX - slideMoveStartX;\n                if (delta > 0) {\n                    delta = Math.min(delta, x + width - travellerWidth - endX, x + width - travellerWidth - startX);\n                } else if (delta < 0) {\n                    delta = Math.max(delta, x - startX, x - endX);\n                }\n                var newIndex = this.getIndex({\n                    startX: startX + delta,\n                    endX: endX + delta\n                });\n                if ((newIndex.startIndex !== startIndex || newIndex.endIndex !== endIndex) && onChange) {\n                    onChange(newIndex);\n                }\n                this.setState({\n                    startX: startX + delta,\n                    endX: endX + delta,\n                    slideMoveStartX: e.pageX\n                });\n            }\n        },\n        {\n            key: \"handleTravellerDragStart\",\n            value: function handleTravellerDragStart(id, e) {\n                var event = isTouch(e) ? e.changedTouches[0] : e;\n                this.setState({\n                    isSlideMoving: false,\n                    isTravellerMoving: true,\n                    movingTravellerId: id,\n                    brushMoveStartX: event.pageX\n                });\n                this.attachDragEndListener();\n            }\n        },\n        {\n            key: \"handleTravellerMove\",\n            value: function handleTravellerMove(e) {\n                var _this$state2 = this.state, brushMoveStartX = _this$state2.brushMoveStartX, movingTravellerId = _this$state2.movingTravellerId, endX = _this$state2.endX, startX = _this$state2.startX;\n                var prevValue = this.state[movingTravellerId];\n                var _this$props5 = this.props, x = _this$props5.x, width = _this$props5.width, travellerWidth = _this$props5.travellerWidth, onChange = _this$props5.onChange, gap = _this$props5.gap, data = _this$props5.data;\n                var params = {\n                    startX: this.state.startX,\n                    endX: this.state.endX\n                };\n                var delta = e.pageX - brushMoveStartX;\n                if (delta > 0) {\n                    delta = Math.min(delta, x + width - travellerWidth - prevValue);\n                } else if (delta < 0) {\n                    delta = Math.max(delta, x - prevValue);\n                }\n                params[movingTravellerId] = prevValue + delta;\n                var newIndex = this.getIndex(params);\n                var startIndex = newIndex.startIndex, endIndex = newIndex.endIndex;\n                var isFullGap = function isFullGap() {\n                    var lastIndex = data.length - 1;\n                    if (movingTravellerId === 'startX' && (endX > startX ? startIndex % gap === 0 : endIndex % gap === 0) || endX < startX && endIndex === lastIndex || movingTravellerId === 'endX' && (endX > startX ? endIndex % gap === 0 : startIndex % gap === 0) || endX > startX && endIndex === lastIndex) {\n                        return true;\n                    }\n                    return false;\n                };\n                this.setState(_defineProperty(_defineProperty({}, movingTravellerId, prevValue + delta), \"brushMoveStartX\", e.pageX), function() {\n                    if (onChange) {\n                        if (isFullGap()) {\n                            onChange(newIndex);\n                        }\n                    }\n                });\n            }\n        },\n        {\n            key: \"handleTravellerMoveKeyboard\",\n            value: function handleTravellerMoveKeyboard(direction, id) {\n                var _this2 = this;\n                // scaleValues are a list of coordinates. For example: [65, 250, 435, 620, 805, 990].\n                var _this$state3 = this.state, scaleValues = _this$state3.scaleValues, startX = _this$state3.startX, endX = _this$state3.endX;\n                // currentScaleValue refers to which coordinate the current traveller should be placed at.\n                var currentScaleValue = this.state[id];\n                var currentIndex = scaleValues.indexOf(currentScaleValue);\n                if (currentIndex === -1) {\n                    return;\n                }\n                var newIndex = currentIndex + direction;\n                if (newIndex === -1 || newIndex >= scaleValues.length) {\n                    return;\n                }\n                var newScaleValue = scaleValues[newIndex];\n                // Prevent travellers from being on top of each other or overlapping\n                if (id === 'startX' && newScaleValue >= endX || id === 'endX' && newScaleValue <= startX) {\n                    return;\n                }\n                this.setState(_defineProperty({}, id, newScaleValue), function() {\n                    _this2.props.onChange(_this2.getIndex({\n                        startX: _this2.state.startX,\n                        endX: _this2.state.endX\n                    }));\n                });\n            }\n        },\n        {\n            key: \"renderBackground\",\n            value: function renderBackground() {\n                var _this$props6 = this.props, x = _this$props6.x, y = _this$props6.y, width = _this$props6.width, height = _this$props6.height, fill = _this$props6.fill, stroke = _this$props6.stroke;\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                    stroke: stroke,\n                    fill: fill,\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }\n        },\n        {\n            key: \"renderPanorama\",\n            value: function renderPanorama() {\n                var _this$props7 = this.props, x = _this$props7.x, y = _this$props7.y, width = _this$props7.width, height = _this$props7.height, data = _this$props7.data, children = _this$props7.children, padding = _this$props7.padding;\n                var chartElement = _react.Children.only(children);\n                if (!chartElement) {\n                    return null;\n                }\n                return /*#__PURE__*/ _react[\"default\"].cloneElement(chartElement, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height,\n                    margin: padding,\n                    compact: true,\n                    data: data\n                });\n            }\n        },\n        {\n            key: \"renderTravellerLayer\",\n            value: function renderTravellerLayer(travellerX, id) {\n                var _data$startIndex, _data$endIndex, _this3 = this;\n                var _this$props8 = this.props, y = _this$props8.y, travellerWidth = _this$props8.travellerWidth, height = _this$props8.height, traveller = _this$props8.traveller, ariaLabel = _this$props8.ariaLabel, data = _this$props8.data, startIndex = _this$props8.startIndex, endIndex = _this$props8.endIndex;\n                var x = Math.max(travellerX, this.props.x);\n                var travellerProps = _objectSpread(_objectSpread({}, (0, _ReactUtils.filterProps)(this.props, false)), {}, {\n                    x: x,\n                    y: y,\n                    width: travellerWidth,\n                    height: height\n                });\n                var ariaLabelBrush = ariaLabel || \"Min value: \".concat((_data$startIndex = data[startIndex]) === null || _data$startIndex === void 0 ? void 0 : _data$startIndex.name, \", Max value: \").concat((_data$endIndex = data[endIndex]) === null || _data$endIndex === void 0 ? void 0 : _data$endIndex.name);\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    tabIndex: 0,\n                    role: \"slider\",\n                    \"aria-label\": ariaLabelBrush,\n                    \"aria-valuenow\": travellerX,\n                    className: \"recharts-brush-traveller\",\n                    onMouseEnter: this.handleEnterSlideOrTraveller,\n                    onMouseLeave: this.handleLeaveSlideOrTraveller,\n                    onMouseDown: this.travellerDragStartHandlers[id],\n                    onTouchStart: this.travellerDragStartHandlers[id],\n                    onKeyDown: function onKeyDown(e) {\n                        if (![\n                            'ArrowLeft',\n                            'ArrowRight'\n                        ].includes(e.key)) {\n                            return;\n                        }\n                        e.preventDefault();\n                        e.stopPropagation();\n                        _this3.handleTravellerMoveKeyboard(e.key === 'ArrowRight' ? 1 : -1, id);\n                    },\n                    onFocus: function onFocus() {\n                        _this3.setState({\n                            isTravellerFocused: true\n                        });\n                    },\n                    onBlur: function onBlur() {\n                        _this3.setState({\n                            isTravellerFocused: false\n                        });\n                    },\n                    style: {\n                        cursor: 'col-resize'\n                    }\n                }, Brush.renderTraveller(traveller, travellerProps));\n            }\n        },\n        {\n            key: \"renderSlide\",\n            value: function renderSlide(startX, endX) {\n                var _this$props9 = this.props, y = _this$props9.y, height = _this$props9.height, stroke = _this$props9.stroke, travellerWidth = _this$props9.travellerWidth;\n                var x = Math.min(startX, endX) + travellerWidth;\n                var width = Math.max(Math.abs(endX - startX) - travellerWidth, 0);\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                    className: \"recharts-brush-slide\",\n                    onMouseEnter: this.handleEnterSlideOrTraveller,\n                    onMouseLeave: this.handleLeaveSlideOrTraveller,\n                    onMouseDown: this.handleSlideDragStart,\n                    onTouchStart: this.handleSlideDragStart,\n                    style: {\n                        cursor: 'move'\n                    },\n                    stroke: \"none\",\n                    fill: stroke,\n                    fillOpacity: 0.2,\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }\n        },\n        {\n            key: \"renderText\",\n            value: function renderText() {\n                var _this$props10 = this.props, startIndex = _this$props10.startIndex, endIndex = _this$props10.endIndex, y = _this$props10.y, height = _this$props10.height, travellerWidth = _this$props10.travellerWidth, stroke = _this$props10.stroke;\n                var _this$state4 = this.state, startX = _this$state4.startX, endX = _this$state4.endX;\n                var offset = 5;\n                var attrs = {\n                    pointerEvents: 'none',\n                    fill: stroke\n                };\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-brush-texts\"\n                }, /*#__PURE__*/ _react[\"default\"].createElement(_Text.Text, _extends({\n                    textAnchor: \"end\",\n                    verticalAnchor: \"middle\",\n                    x: Math.min(startX, endX) - offset,\n                    y: y + height / 2\n                }, attrs), this.getTextOfTick(startIndex)), /*#__PURE__*/ _react[\"default\"].createElement(_Text.Text, _extends({\n                    textAnchor: \"start\",\n                    verticalAnchor: \"middle\",\n                    x: Math.max(startX, endX) + travellerWidth + offset,\n                    y: y + height / 2\n                }, attrs), this.getTextOfTick(endIndex)));\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props11 = this.props, data = _this$props11.data, className = _this$props11.className, children = _this$props11.children, x = _this$props11.x, y = _this$props11.y, width = _this$props11.width, height = _this$props11.height, alwaysShowText = _this$props11.alwaysShowText;\n                var _this$state5 = this.state, startX = _this$state5.startX, endX = _this$state5.endX, isTextActive = _this$state5.isTextActive, isSlideMoving = _this$state5.isSlideMoving, isTravellerMoving = _this$state5.isTravellerMoving, isTravellerFocused = _this$state5.isTravellerFocused;\n                if (!data || !data.length || !(0, _DataUtils.isNumber)(x) || !(0, _DataUtils.isNumber)(y) || !(0, _DataUtils.isNumber)(width) || !(0, _DataUtils.isNumber)(height) || width <= 0 || height <= 0) {\n                    return null;\n                }\n                var layerClass = (0, _clsx[\"default\"])('recharts-brush', className);\n                var isPanoramic = _react[\"default\"].Children.count(children) === 1;\n                var style = (0, _CssPrefixUtils.generatePrefixStyle)('userSelect', 'none');\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: layerClass,\n                    onMouseLeave: this.handleLeaveWrapper,\n                    onTouchMove: this.handleTouchMove,\n                    style: style\n                }, this.renderBackground(), isPanoramic && this.renderPanorama(), this.renderSlide(startX, endX), this.renderTravellerLayer(startX, 'startX'), this.renderTravellerLayer(endX, 'endX'), (isTextActive || isSlideMoving || isTravellerMoving || isTravellerFocused || alwaysShowText) && this.renderText());\n            }\n        }\n    ], [\n        {\n            key: \"renderDefaultTraveller\",\n            value: function renderDefaultTraveller(props) {\n                var x = props.x, y = props.y, width = props.width, height = props.height, stroke = props.stroke;\n                var lineY = Math.floor(y + height / 2) - 1;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_react[\"default\"].Fragment, null, /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height,\n                    fill: stroke,\n                    stroke: \"none\"\n                }), /*#__PURE__*/ _react[\"default\"].createElement(\"line\", {\n                    x1: x + 1,\n                    y1: lineY,\n                    x2: x + width - 1,\n                    y2: lineY,\n                    fill: \"none\",\n                    stroke: \"#fff\"\n                }), /*#__PURE__*/ _react[\"default\"].createElement(\"line\", {\n                    x1: x + 1,\n                    y1: lineY + 2,\n                    x2: x + width - 1,\n                    y2: lineY + 2,\n                    fill: \"none\",\n                    stroke: \"#fff\"\n                }));\n            }\n        },\n        {\n            key: \"renderTraveller\",\n            value: function renderTraveller(option, props) {\n                var rectangle;\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n                    rectangle = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n                } else if ((0, _isFunction[\"default\"])(option)) {\n                    rectangle = option(props);\n                } else {\n                    rectangle = Brush.renderDefaultTraveller(props);\n                }\n                return rectangle;\n            }\n        },\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                var data = nextProps.data, width = nextProps.width, x = nextProps.x, travellerWidth = nextProps.travellerWidth, updateId = nextProps.updateId, startIndex = nextProps.startIndex, endIndex = nextProps.endIndex;\n                if (data !== prevState.prevData || updateId !== prevState.prevUpdateId) {\n                    return _objectSpread({\n                        prevData: data,\n                        prevTravellerWidth: travellerWidth,\n                        prevUpdateId: updateId,\n                        prevX: x,\n                        prevWidth: width\n                    }, data && data.length ? createScale({\n                        data: data,\n                        width: width,\n                        x: x,\n                        travellerWidth: travellerWidth,\n                        startIndex: startIndex,\n                        endIndex: endIndex\n                    }) : {\n                        scale: null,\n                        scaleValues: null\n                    });\n                }\n                if (prevState.scale && (width !== prevState.prevWidth || x !== prevState.prevX || travellerWidth !== prevState.prevTravellerWidth)) {\n                    prevState.scale.range([\n                        x,\n                        x + width - travellerWidth\n                    ]);\n                    var scaleValues = prevState.scale.domain().map(function(entry) {\n                        return prevState.scale(entry);\n                    });\n                    return {\n                        prevData: data,\n                        prevTravellerWidth: travellerWidth,\n                        prevUpdateId: updateId,\n                        prevX: x,\n                        prevWidth: width,\n                        startX: prevState.scale(nextProps.startIndex),\n                        endX: prevState.scale(nextProps.endIndex),\n                        scaleValues: scaleValues\n                    };\n                }\n                return null;\n            }\n        },\n        {\n            key: \"getIndexInRange\",\n            value: function getIndexInRange(valueRange, x) {\n                var len = valueRange.length;\n                var start = 0;\n                var end = len - 1;\n                while(end - start > 1){\n                    var middle = Math.floor((start + end) / 2);\n                    if (valueRange[middle] > x) {\n                        end = middle;\n                    } else {\n                        start = middle;\n                    }\n                }\n                return x >= valueRange[end] ? end : start;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(Brush, \"displayName\", 'Brush');\n_defineProperty(Brush, \"defaultProps\", {\n    height: 40,\n    travellerWidth: 5,\n    gap: 1,\n    fill: '#fff',\n    stroke: '#666',\n    padding: {\n        top: 1,\n        right: 1,\n        bottom: 1,\n        left: 1\n    },\n    leaveTimeOut: 1000,\n    alwaysShowText: false\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2FydGVzaWFuL0JydXNoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxhQUFhLEdBQUcsS0FBSztBQUNyQixJQUFJRyxTQUFTQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3BELElBQUlDLFFBQVFDLHVCQUF1QkYsbUJBQU9BLENBQUMsdUJBQU07QUFDakQsSUFBSUcsV0FBV0gsbUJBQU9BLENBQUMsd0RBQXlCO0FBQ2hELElBQUlJLGNBQWNGLHVCQUF1QkYsbUJBQU9BLENBQUMsNENBQW1CO0FBQ3BFLElBQUlLLFNBQVNILHVCQUF1QkYsbUJBQU9BLENBQUMsa0NBQWM7QUFDMUQsSUFBSU0sU0FBU04sbUJBQU9BLENBQUMsMkZBQW9CO0FBQ3pDLElBQUlPLFFBQVFQLG1CQUFPQSxDQUFDLHlGQUFtQjtBQUN2QyxJQUFJUSxjQUFjUixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDOUMsSUFBSVMsYUFBYVQsbUJBQU9BLENBQUMseUZBQW1CO0FBQzVDLElBQUlVLGtCQUFrQlYsbUJBQU9BLENBQUMsbUdBQXdCO0FBQ3RELElBQUlXLGNBQWNYLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM5QyxTQUFTRSx1QkFBdUJVLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UseUJBQXlCQyxDQUFDO0lBQUksSUFBSSxjQUFjLE9BQU9DLFNBQVMsT0FBTztJQUFNLElBQUlDLElBQUksSUFBSUQsV0FBV0UsSUFBSSxJQUFJRjtJQUFXLE9BQU8sQ0FBQ0YsMkJBQTJCLFNBQVNBLHlCQUF5QkMsQ0FBQztRQUFJLE9BQU9BLElBQUlHLElBQUlEO0lBQUcsR0FBR0Y7QUFBSTtBQUNuTyxTQUFTaEIsd0JBQXdCZ0IsQ0FBQyxFQUFFRSxDQUFD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LElBQUlDLE1BQU1qTCxNQUFNO2dCQUNoQixNQUFPaUwsTUFBTUQsUUFBUSxFQUFHO29CQUN0QixJQUFJRSxTQUFTckksS0FBS2dILEtBQUssQ0FBQyxDQUFDbUIsUUFBUUMsR0FBRSxJQUFLO29CQUN4QyxJQUFJRixVQUFVLENBQUNHLE9BQU8sR0FBR3JMLEdBQUc7d0JBQzFCb0wsTUFBTUM7b0JBQ1IsT0FBTzt3QkFDTEYsUUFBUUU7b0JBQ1Y7Z0JBQ0Y7Z0JBQ0EsT0FBT3JMLEtBQUtrTCxVQUFVLENBQUNFLElBQUksR0FBR0EsTUFBTUQ7WUFDdEM7UUFDRjtLQUFFO0FBQ0osRUFBRXJSLE9BQU93UixhQUFhO0FBQ3RCbE8sZ0JBQWdCdkQsT0FBTyxlQUFlO0FBQ3RDdUQsZ0JBQWdCdkQsT0FBTyxnQkFBZ0I7SUFDckN5TCxRQUFRO0lBQ1JwRixnQkFBZ0I7SUFDaEIyQyxLQUFLO0lBQ0wwQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkssU0FBUztRQUNQMEYsS0FBSztRQUNMQyxPQUFPO1FBQ1BDLFFBQVE7UUFDUkMsTUFBTTtJQUNSO0lBQ0F4SixjQUFjO0lBQ2RrSCxnQkFBZ0I7QUFDbEIiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXGNhcnRlc2lhblxcQnJ1c2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5CcnVzaCA9IHZvaWQgMDtcclxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xyXG52YXIgX2QzU2NhbGUgPSByZXF1aXJlKFwidmljdG9yeS12ZW5kb3IvZDMtc2NhbGVcIik7XHJcbnZhciBfaXNGdW5jdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpKTtcclxudmFyIF9yYW5nZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9yYW5nZVwiKSk7XHJcbnZhciBfTGF5ZXIgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL0xheWVyXCIpO1xyXG52YXIgX1RleHQgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50L1RleHRcIik7XHJcbnZhciBfQ2hhcnRVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NoYXJ0VXRpbHNcIik7XHJcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRGF0YVV0aWxzXCIpO1xyXG52YXIgX0Nzc1ByZWZpeFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvQ3NzUHJlZml4VXRpbHNcIik7XHJcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxyXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxyXG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxyXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cclxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XHJcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxyXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxyXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxyXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxyXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XHJcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxyXG4gKiBAZmlsZU92ZXJ2aWV3IEJydXNoXHJcbiAqL1xyXG52YXIgY3JlYXRlU2NhbGUgPSBmdW5jdGlvbiBjcmVhdGVTY2FsZShfcmVmKSB7XHJcbiAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXHJcbiAgICBzdGFydEluZGV4ID0gX3JlZi5zdGFydEluZGV4LFxyXG4gICAgZW5kSW5kZXggPSBfcmVmLmVuZEluZGV4LFxyXG4gICAgeCA9IF9yZWYueCxcclxuICAgIHdpZHRoID0gX3JlZi53aWR0aCxcclxuICAgIHRyYXZlbGxlcldpZHRoID0gX3JlZi50cmF2ZWxsZXJXaWR0aDtcclxuICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4ge307XHJcbiAgfVxyXG4gIHZhciBsZW4gPSBkYXRhLmxlbmd0aDtcclxuICB2YXIgc2NhbGUgPSAoMCwgX2QzU2NhbGUuc2NhbGVQb2ludCkoKS5kb21haW4oKDAsIF9yYW5nZVtcImRlZmF1bHRcIl0pKDAsIGxlbikpLnJhbmdlKFt4LCB4ICsgd2lkdGggLSB0cmF2ZWxsZXJXaWR0aF0pO1xyXG4gIHZhciBzY2FsZVZhbHVlcyA9IHNjYWxlLmRvbWFpbigpLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgIHJldHVybiBzY2FsZShlbnRyeSk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHtcclxuICAgIGlzVGV4dEFjdGl2ZTogZmFsc2UsXHJcbiAgICBpc1NsaWRlTW92aW5nOiBmYWxzZSxcclxuICAgIGlzVHJhdmVsbGVyTW92aW5nOiBmYWxzZSxcclxuICAgIGlzVHJhdmVsbGVyRm9jdXNlZDogZmFsc2UsXHJcbiAgICBzdGFydFg6IHNjYWxlKHN0YXJ0SW5kZXgpLFxyXG4gICAgZW5kWDogc2NhbGUoZW5kSW5kZXgpLFxyXG4gICAgc2NhbGU6IHNjYWxlLFxyXG4gICAgc2NhbGVWYWx1ZXM6IHNjYWxlVmFsdWVzXHJcbiAgfTtcclxufTtcclxudmFyIGlzVG91Y2ggPSBmdW5jdGlvbiBpc1RvdWNoKGUpIHtcclxuICByZXR1cm4gZS5jaGFuZ2VkVG91Y2hlcyAmJiAhIWUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoO1xyXG59O1xyXG52YXIgQnJ1c2ggPSBleHBvcnRzLkJydXNoID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xyXG4gIGZ1bmN0aW9uIEJydXNoKHByb3BzKSB7XHJcbiAgICB2YXIgX3RoaXM7XHJcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnJ1c2gpO1xyXG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIEJydXNoLCBbcHJvcHNdKTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVEcmFnXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIGlmIChfdGhpcy5sZWF2ZVRpbWVyKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmxlYXZlVGltZXIpO1xyXG4gICAgICAgIF90aGlzLmxlYXZlVGltZXIgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChfdGhpcy5zdGF0ZS5pc1RyYXZlbGxlck1vdmluZykge1xyXG4gICAgICAgIF90aGlzLmhhbmRsZVRyYXZlbGxlck1vdmUoZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoX3RoaXMuc3RhdGUuaXNTbGlkZU1vdmluZykge1xyXG4gICAgICAgIF90aGlzLmhhbmRsZVNsaWRlRHJhZyhlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlVG91Y2hNb3ZlXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIGlmIChlLmNoYW5nZWRUb3VjaGVzICE9IG51bGwgJiYgZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgX3RoaXMuaGFuZGxlRHJhZyhlLmNoYW5nZWRUb3VjaGVzWzBdKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlRHJhZ0VuZFwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcclxuICAgICAgICBpc1RyYXZlbGxlck1vdmluZzogZmFsc2UsXHJcbiAgICAgICAgaXNTbGlkZU1vdmluZzogZmFsc2VcclxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxyXG4gICAgICAgICAgZW5kSW5kZXggPSBfdGhpcyRwcm9wcy5lbmRJbmRleCxcclxuICAgICAgICAgIG9uRHJhZ0VuZCA9IF90aGlzJHByb3BzLm9uRHJhZ0VuZCxcclxuICAgICAgICAgIHN0YXJ0SW5kZXggPSBfdGhpcyRwcm9wcy5zdGFydEluZGV4O1xyXG4gICAgICAgIG9uRHJhZ0VuZCA9PT0gbnVsbCB8fCBvbkRyYWdFbmQgPT09IHZvaWQgMCB8fCBvbkRyYWdFbmQoe1xyXG4gICAgICAgICAgZW5kSW5kZXg6IGVuZEluZGV4LFxyXG4gICAgICAgICAgc3RhcnRJbmRleDogc3RhcnRJbmRleFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgICAgX3RoaXMuZGV0YWNoRHJhZ0VuZExpc3RlbmVyKCk7XHJcbiAgICB9KTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVMZWF2ZVdyYXBwZXJcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAoX3RoaXMuc3RhdGUuaXNUcmF2ZWxsZXJNb3ZpbmcgfHwgX3RoaXMuc3RhdGUuaXNTbGlkZU1vdmluZykge1xyXG4gICAgICAgIF90aGlzLmxlYXZlVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChfdGhpcy5oYW5kbGVEcmFnRW5kLCBfdGhpcy5wcm9wcy5sZWF2ZVRpbWVPdXQpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVFbnRlclNsaWRlT3JUcmF2ZWxsZXJcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgaXNUZXh0QWN0aXZlOiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlTGVhdmVTbGlkZU9yVHJhdmVsbGVyXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgIGlzVGV4dEFjdGl2ZTogZmFsc2VcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVTbGlkZURyYWdTdGFydFwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICB2YXIgZXZlbnQgPSBpc1RvdWNoKGUpID8gZS5jaGFuZ2VkVG91Y2hlc1swXSA6IGU7XHJcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcclxuICAgICAgICBpc1RyYXZlbGxlck1vdmluZzogZmFsc2UsXHJcbiAgICAgICAgaXNTbGlkZU1vdmluZzogdHJ1ZSxcclxuICAgICAgICBzbGlkZU1vdmVTdGFydFg6IGV2ZW50LnBhZ2VYXHJcbiAgICAgIH0pO1xyXG4gICAgICBfdGhpcy5hdHRhY2hEcmFnRW5kTGlzdGVuZXIoKTtcclxuICAgIH0pO1xyXG4gICAgX3RoaXMudHJhdmVsbGVyRHJhZ1N0YXJ0SGFuZGxlcnMgPSB7XHJcbiAgICAgIHN0YXJ0WDogX3RoaXMuaGFuZGxlVHJhdmVsbGVyRHJhZ1N0YXJ0LmJpbmQoX3RoaXMsICdzdGFydFgnKSxcclxuICAgICAgZW5kWDogX3RoaXMuaGFuZGxlVHJhdmVsbGVyRHJhZ1N0YXJ0LmJpbmQoX3RoaXMsICdlbmRYJylcclxuICAgIH07XHJcbiAgICBfdGhpcy5zdGF0ZSA9IHt9O1xyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuICBfaW5oZXJpdHMoQnJ1c2gsIF9QdXJlQ29tcG9uZW50KTtcclxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEJydXNoLCBbe1xyXG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICAgIGlmICh0aGlzLmxlYXZlVGltZXIpIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5sZWF2ZVRpbWVyKTtcclxuICAgICAgICB0aGlzLmxlYXZlVGltZXIgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZGV0YWNoRHJhZ0VuZExpc3RlbmVyKCk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImdldEluZGV4XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5kZXgoX3JlZjIpIHtcclxuICAgICAgdmFyIHN0YXJ0WCA9IF9yZWYyLnN0YXJ0WCxcclxuICAgICAgICBlbmRYID0gX3JlZjIuZW5kWDtcclxuICAgICAgdmFyIHNjYWxlVmFsdWVzID0gdGhpcy5zdGF0ZS5zY2FsZVZhbHVlcztcclxuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgZ2FwID0gX3RoaXMkcHJvcHMyLmdhcCxcclxuICAgICAgICBkYXRhID0gX3RoaXMkcHJvcHMyLmRhdGE7XHJcbiAgICAgIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XHJcbiAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihzdGFydFgsIGVuZFgpO1xyXG4gICAgICB2YXIgbWF4ID0gTWF0aC5tYXgoc3RhcnRYLCBlbmRYKTtcclxuICAgICAgdmFyIG1pbkluZGV4ID0gQnJ1c2guZ2V0SW5kZXhJblJhbmdlKHNjYWxlVmFsdWVzLCBtaW4pO1xyXG4gICAgICB2YXIgbWF4SW5kZXggPSBCcnVzaC5nZXRJbmRleEluUmFuZ2Uoc2NhbGVWYWx1ZXMsIG1heCk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhcnRJbmRleDogbWluSW5kZXggLSBtaW5JbmRleCAlIGdhcCxcclxuICAgICAgICBlbmRJbmRleDogbWF4SW5kZXggPT09IGxhc3RJbmRleCA/IGxhc3RJbmRleCA6IG1heEluZGV4IC0gbWF4SW5kZXggJSBnYXBcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiZ2V0VGV4dE9mVGlja1wiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRleHRPZlRpY2soaW5kZXgpIHtcclxuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgZGF0YSA9IF90aGlzJHByb3BzMy5kYXRhLFxyXG4gICAgICAgIHRpY2tGb3JtYXR0ZXIgPSBfdGhpcyRwcm9wczMudGlja0Zvcm1hdHRlcixcclxuICAgICAgICBkYXRhS2V5ID0gX3RoaXMkcHJvcHMzLmRhdGFLZXk7XHJcbiAgICAgIHZhciB0ZXh0ID0gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShkYXRhW2luZGV4XSwgZGF0YUtleSwgaW5kZXgpO1xyXG4gICAgICByZXR1cm4gKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkodGlja0Zvcm1hdHRlcikgPyB0aWNrRm9ybWF0dGVyKHRleHQsIGluZGV4KSA6IHRleHQ7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImF0dGFjaERyYWdFbmRMaXN0ZW5lclwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaERyYWdFbmRMaXN0ZW5lcigpIHtcclxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLmhhbmRsZURyYWdFbmQsIHRydWUpO1xyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLmhhbmRsZURyYWdFbmQsIHRydWUpO1xyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVEcmFnLCB0cnVlKTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiZGV0YWNoRHJhZ0VuZExpc3RlbmVyXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoRHJhZ0VuZExpc3RlbmVyKCkge1xyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCwgdHJ1ZSk7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCwgdHJ1ZSk7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZURyYWcsIHRydWUpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJoYW5kbGVTbGlkZURyYWdcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVTbGlkZURyYWcoZSkge1xyXG4gICAgICB2YXIgX3RoaXMkc3RhdGUgPSB0aGlzLnN0YXRlLFxyXG4gICAgICAgIHNsaWRlTW92ZVN0YXJ0WCA9IF90aGlzJHN0YXRlLnNsaWRlTW92ZVN0YXJ0WCxcclxuICAgICAgICBzdGFydFggPSBfdGhpcyRzdGF0ZS5zdGFydFgsXHJcbiAgICAgICAgZW5kWCA9IF90aGlzJHN0YXRlLmVuZFg7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIHggPSBfdGhpcyRwcm9wczQueCxcclxuICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzNC53aWR0aCxcclxuICAgICAgICB0cmF2ZWxsZXJXaWR0aCA9IF90aGlzJHByb3BzNC50cmF2ZWxsZXJXaWR0aCxcclxuICAgICAgICBzdGFydEluZGV4ID0gX3RoaXMkcHJvcHM0LnN0YXJ0SW5kZXgsXHJcbiAgICAgICAgZW5kSW5kZXggPSBfdGhpcyRwcm9wczQuZW5kSW5kZXgsXHJcbiAgICAgICAgb25DaGFuZ2UgPSBfdGhpcyRwcm9wczQub25DaGFuZ2U7XHJcbiAgICAgIHZhciBkZWx0YSA9IGUucGFnZVggLSBzbGlkZU1vdmVTdGFydFg7XHJcbiAgICAgIGlmIChkZWx0YSA+IDApIHtcclxuICAgICAgICBkZWx0YSA9IE1hdGgubWluKGRlbHRhLCB4ICsgd2lkdGggLSB0cmF2ZWxsZXJXaWR0aCAtIGVuZFgsIHggKyB3aWR0aCAtIHRyYXZlbGxlcldpZHRoIC0gc3RhcnRYKTtcclxuICAgICAgfSBlbHNlIGlmIChkZWx0YSA8IDApIHtcclxuICAgICAgICBkZWx0YSA9IE1hdGgubWF4KGRlbHRhLCB4IC0gc3RhcnRYLCB4IC0gZW5kWCk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIG5ld0luZGV4ID0gdGhpcy5nZXRJbmRleCh7XHJcbiAgICAgICAgc3RhcnRYOiBzdGFydFggKyBkZWx0YSxcclxuICAgICAgICBlbmRYOiBlbmRYICsgZGVsdGFcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICgobmV3SW5kZXguc3RhcnRJbmRleCAhPT0gc3RhcnRJbmRleCB8fCBuZXdJbmRleC5lbmRJbmRleCAhPT0gZW5kSW5kZXgpICYmIG9uQ2hhbmdlKSB7XHJcbiAgICAgICAgb25DaGFuZ2UobmV3SW5kZXgpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgIHN0YXJ0WDogc3RhcnRYICsgZGVsdGEsXHJcbiAgICAgICAgZW5kWDogZW5kWCArIGRlbHRhLFxyXG4gICAgICAgIHNsaWRlTW92ZVN0YXJ0WDogZS5wYWdlWFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiaGFuZGxlVHJhdmVsbGVyRHJhZ1N0YXJ0XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVHJhdmVsbGVyRHJhZ1N0YXJ0KGlkLCBlKSB7XHJcbiAgICAgIHZhciBldmVudCA9IGlzVG91Y2goZSkgPyBlLmNoYW5nZWRUb3VjaGVzWzBdIDogZTtcclxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgaXNTbGlkZU1vdmluZzogZmFsc2UsXHJcbiAgICAgICAgaXNUcmF2ZWxsZXJNb3Zpbmc6IHRydWUsXHJcbiAgICAgICAgbW92aW5nVHJhdmVsbGVySWQ6IGlkLFxyXG4gICAgICAgIGJydXNoTW92ZVN0YXJ0WDogZXZlbnQucGFnZVhcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuYXR0YWNoRHJhZ0VuZExpc3RlbmVyKCk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImhhbmRsZVRyYXZlbGxlck1vdmVcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVUcmF2ZWxsZXJNb3ZlKGUpIHtcclxuICAgICAgdmFyIF90aGlzJHN0YXRlMiA9IHRoaXMuc3RhdGUsXHJcbiAgICAgICAgYnJ1c2hNb3ZlU3RhcnRYID0gX3RoaXMkc3RhdGUyLmJydXNoTW92ZVN0YXJ0WCxcclxuICAgICAgICBtb3ZpbmdUcmF2ZWxsZXJJZCA9IF90aGlzJHN0YXRlMi5tb3ZpbmdUcmF2ZWxsZXJJZCxcclxuICAgICAgICBlbmRYID0gX3RoaXMkc3RhdGUyLmVuZFgsXHJcbiAgICAgICAgc3RhcnRYID0gX3RoaXMkc3RhdGUyLnN0YXJ0WDtcclxuICAgICAgdmFyIHByZXZWYWx1ZSA9IHRoaXMuc3RhdGVbbW92aW5nVHJhdmVsbGVySWRdO1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHM1ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICB4ID0gX3RoaXMkcHJvcHM1LngsXHJcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczUud2lkdGgsXHJcbiAgICAgICAgdHJhdmVsbGVyV2lkdGggPSBfdGhpcyRwcm9wczUudHJhdmVsbGVyV2lkdGgsXHJcbiAgICAgICAgb25DaGFuZ2UgPSBfdGhpcyRwcm9wczUub25DaGFuZ2UsXHJcbiAgICAgICAgZ2FwID0gX3RoaXMkcHJvcHM1LmdhcCxcclxuICAgICAgICBkYXRhID0gX3RoaXMkcHJvcHM1LmRhdGE7XHJcbiAgICAgIHZhciBwYXJhbXMgPSB7XHJcbiAgICAgICAgc3RhcnRYOiB0aGlzLnN0YXRlLnN0YXJ0WCxcclxuICAgICAgICBlbmRYOiB0aGlzLnN0YXRlLmVuZFhcclxuICAgICAgfTtcclxuICAgICAgdmFyIGRlbHRhID0gZS5wYWdlWCAtIGJydXNoTW92ZVN0YXJ0WDtcclxuICAgICAgaWYgKGRlbHRhID4gMCkge1xyXG4gICAgICAgIGRlbHRhID0gTWF0aC5taW4oZGVsdGEsIHggKyB3aWR0aCAtIHRyYXZlbGxlcldpZHRoIC0gcHJldlZhbHVlKTtcclxuICAgICAgfSBlbHNlIGlmIChkZWx0YSA8IDApIHtcclxuICAgICAgICBkZWx0YSA9IE1hdGgubWF4KGRlbHRhLCB4IC0gcHJldlZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICBwYXJhbXNbbW92aW5nVHJhdmVsbGVySWRdID0gcHJldlZhbHVlICsgZGVsdGE7XHJcbiAgICAgIHZhciBuZXdJbmRleCA9IHRoaXMuZ2V0SW5kZXgocGFyYW1zKTtcclxuICAgICAgdmFyIHN0YXJ0SW5kZXggPSBuZXdJbmRleC5zdGFydEluZGV4LFxyXG4gICAgICAgIGVuZEluZGV4ID0gbmV3SW5kZXguZW5kSW5kZXg7XHJcbiAgICAgIHZhciBpc0Z1bGxHYXAgPSBmdW5jdGlvbiBpc0Z1bGxHYXAoKSB7XHJcbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcclxuICAgICAgICBpZiAobW92aW5nVHJhdmVsbGVySWQgPT09ICdzdGFydFgnICYmIChlbmRYID4gc3RhcnRYID8gc3RhcnRJbmRleCAlIGdhcCA9PT0gMCA6IGVuZEluZGV4ICUgZ2FwID09PSAwKSB8fCBlbmRYIDwgc3RhcnRYICYmIGVuZEluZGV4ID09PSBsYXN0SW5kZXggfHwgbW92aW5nVHJhdmVsbGVySWQgPT09ICdlbmRYJyAmJiAoZW5kWCA+IHN0YXJ0WCA/IGVuZEluZGV4ICUgZ2FwID09PSAwIDogc3RhcnRJbmRleCAlIGdhcCA9PT0gMCkgfHwgZW5kWCA+IHN0YXJ0WCAmJiBlbmRJbmRleCA9PT0gbGFzdEluZGV4KSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLnNldFN0YXRlKF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoe30sIG1vdmluZ1RyYXZlbGxlcklkLCBwcmV2VmFsdWUgKyBkZWx0YSksIFwiYnJ1c2hNb3ZlU3RhcnRYXCIsIGUucGFnZVgpLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKG9uQ2hhbmdlKSB7XHJcbiAgICAgICAgICBpZiAoaXNGdWxsR2FwKCkpIHtcclxuICAgICAgICAgICAgb25DaGFuZ2UobmV3SW5kZXgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImhhbmRsZVRyYXZlbGxlck1vdmVLZXlib2FyZFwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVRyYXZlbGxlck1vdmVLZXlib2FyZChkaXJlY3Rpb24sIGlkKSB7XHJcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG4gICAgICAvLyBzY2FsZVZhbHVlcyBhcmUgYSBsaXN0IG9mIGNvb3JkaW5hdGVzLiBGb3IgZXhhbXBsZTogWzY1LCAyNTAsIDQzNSwgNjIwLCA4MDUsIDk5MF0uXHJcbiAgICAgIHZhciBfdGhpcyRzdGF0ZTMgPSB0aGlzLnN0YXRlLFxyXG4gICAgICAgIHNjYWxlVmFsdWVzID0gX3RoaXMkc3RhdGUzLnNjYWxlVmFsdWVzLFxyXG4gICAgICAgIHN0YXJ0WCA9IF90aGlzJHN0YXRlMy5zdGFydFgsXHJcbiAgICAgICAgZW5kWCA9IF90aGlzJHN0YXRlMy5lbmRYO1xyXG4gICAgICAvLyBjdXJyZW50U2NhbGVWYWx1ZSByZWZlcnMgdG8gd2hpY2ggY29vcmRpbmF0ZSB0aGUgY3VycmVudCB0cmF2ZWxsZXIgc2hvdWxkIGJlIHBsYWNlZCBhdC5cclxuICAgICAgdmFyIGN1cnJlbnRTY2FsZVZhbHVlID0gdGhpcy5zdGF0ZVtpZF07XHJcbiAgICAgIHZhciBjdXJyZW50SW5kZXggPSBzY2FsZVZhbHVlcy5pbmRleE9mKGN1cnJlbnRTY2FsZVZhbHVlKTtcclxuICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdmFyIG5ld0luZGV4ID0gY3VycmVudEluZGV4ICsgZGlyZWN0aW9uO1xyXG4gICAgICBpZiAobmV3SW5kZXggPT09IC0xIHx8IG5ld0luZGV4ID49IHNjYWxlVmFsdWVzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB2YXIgbmV3U2NhbGVWYWx1ZSA9IHNjYWxlVmFsdWVzW25ld0luZGV4XTtcclxuXHJcbiAgICAgIC8vIFByZXZlbnQgdHJhdmVsbGVycyBmcm9tIGJlaW5nIG9uIHRvcCBvZiBlYWNoIG90aGVyIG9yIG92ZXJsYXBwaW5nXHJcbiAgICAgIGlmIChpZCA9PT0gJ3N0YXJ0WCcgJiYgbmV3U2NhbGVWYWx1ZSA+PSBlbmRYIHx8IGlkID09PSAnZW5kWCcgJiYgbmV3U2NhbGVWYWx1ZSA8PSBzdGFydFgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zZXRTdGF0ZShfZGVmaW5lUHJvcGVydHkoe30sIGlkLCBuZXdTY2FsZVZhbHVlKSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF90aGlzMi5wcm9wcy5vbkNoYW5nZShfdGhpczIuZ2V0SW5kZXgoe1xyXG4gICAgICAgICAgc3RhcnRYOiBfdGhpczIuc3RhdGUuc3RhcnRYLFxyXG4gICAgICAgICAgZW5kWDogX3RoaXMyLnN0YXRlLmVuZFhcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJCYWNrZ3JvdW5kXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQmFja2dyb3VuZCgpIHtcclxuICAgICAgdmFyIF90aGlzJHByb3BzNiA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgeCA9IF90aGlzJHByb3BzNi54LFxyXG4gICAgICAgIHkgPSBfdGhpcyRwcm9wczYueSxcclxuICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzNi53aWR0aCxcclxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczYuaGVpZ2h0LFxyXG4gICAgICAgIGZpbGwgPSBfdGhpcyRwcm9wczYuZmlsbCxcclxuICAgICAgICBzdHJva2UgPSBfdGhpcyRwcm9wczYuc3Ryb2tlO1xyXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xyXG4gICAgICAgIHN0cm9rZTogc3Ryb2tlLFxyXG4gICAgICAgIGZpbGw6IGZpbGwsXHJcbiAgICAgICAgeDogeCxcclxuICAgICAgICB5OiB5LFxyXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyUGFub3JhbWFcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJQYW5vcmFtYSgpIHtcclxuICAgICAgdmFyIF90aGlzJHByb3BzNyA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgeCA9IF90aGlzJHByb3BzNy54LFxyXG4gICAgICAgIHkgPSBfdGhpcyRwcm9wczcueSxcclxuICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzNy53aWR0aCxcclxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczcuaGVpZ2h0LFxyXG4gICAgICAgIGRhdGEgPSBfdGhpcyRwcm9wczcuZGF0YSxcclxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzNy5jaGlsZHJlbixcclxuICAgICAgICBwYWRkaW5nID0gX3RoaXMkcHJvcHM3LnBhZGRpbmc7XHJcbiAgICAgIHZhciBjaGFydEVsZW1lbnQgPSBfcmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XHJcbiAgICAgIGlmICghY2hhcnRFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChjaGFydEVsZW1lbnQsIHtcclxuICAgICAgICB4OiB4LFxyXG4gICAgICAgIHk6IHksXHJcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgIG1hcmdpbjogcGFkZGluZyxcclxuICAgICAgICBjb21wYWN0OiB0cnVlLFxyXG4gICAgICAgIGRhdGE6IGRhdGFcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJlbmRlclRyYXZlbGxlckxheWVyXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVHJhdmVsbGVyTGF5ZXIodHJhdmVsbGVyWCwgaWQpIHtcclxuICAgICAgdmFyIF9kYXRhJHN0YXJ0SW5kZXgsXHJcbiAgICAgICAgX2RhdGEkZW5kSW5kZXgsXHJcbiAgICAgICAgX3RoaXMzID0gdGhpcztcclxuICAgICAgdmFyIF90aGlzJHByb3BzOCA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgeSA9IF90aGlzJHByb3BzOC55LFxyXG4gICAgICAgIHRyYXZlbGxlcldpZHRoID0gX3RoaXMkcHJvcHM4LnRyYXZlbGxlcldpZHRoLFxyXG4gICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzOC5oZWlnaHQsXHJcbiAgICAgICAgdHJhdmVsbGVyID0gX3RoaXMkcHJvcHM4LnRyYXZlbGxlcixcclxuICAgICAgICBhcmlhTGFiZWwgPSBfdGhpcyRwcm9wczguYXJpYUxhYmVsLFxyXG4gICAgICAgIGRhdGEgPSBfdGhpcyRwcm9wczguZGF0YSxcclxuICAgICAgICBzdGFydEluZGV4ID0gX3RoaXMkcHJvcHM4LnN0YXJ0SW5kZXgsXHJcbiAgICAgICAgZW5kSW5kZXggPSBfdGhpcyRwcm9wczguZW5kSW5kZXg7XHJcbiAgICAgIHZhciB4ID0gTWF0aC5tYXgodHJhdmVsbGVyWCwgdGhpcy5wcm9wcy54KTtcclxuICAgICAgdmFyIHRyYXZlbGxlclByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRoaXMucHJvcHMsIGZhbHNlKSksIHt9LCB7XHJcbiAgICAgICAgeDogeCxcclxuICAgICAgICB5OiB5LFxyXG4gICAgICAgIHdpZHRoOiB0cmF2ZWxsZXJXaWR0aCxcclxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxyXG4gICAgICB9KTtcclxuICAgICAgdmFyIGFyaWFMYWJlbEJydXNoID0gYXJpYUxhYmVsIHx8IFwiTWluIHZhbHVlOiBcIi5jb25jYXQoKF9kYXRhJHN0YXJ0SW5kZXggPSBkYXRhW3N0YXJ0SW5kZXhdKSA9PT0gbnVsbCB8fCBfZGF0YSRzdGFydEluZGV4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGF0YSRzdGFydEluZGV4Lm5hbWUsIFwiLCBNYXggdmFsdWU6IFwiKS5jb25jYXQoKF9kYXRhJGVuZEluZGV4ID0gZGF0YVtlbmRJbmRleF0pID09PSBudWxsIHx8IF9kYXRhJGVuZEluZGV4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGF0YSRlbmRJbmRleC5uYW1lKTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XHJcbiAgICAgICAgdGFiSW5kZXg6IDAsXHJcbiAgICAgICAgcm9sZTogXCJzbGlkZXJcIixcclxuICAgICAgICBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsQnJ1c2gsXHJcbiAgICAgICAgXCJhcmlhLXZhbHVlbm93XCI6IHRyYXZlbGxlclgsXHJcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWJydXNoLXRyYXZlbGxlclwiLFxyXG4gICAgICAgIG9uTW91c2VFbnRlcjogdGhpcy5oYW5kbGVFbnRlclNsaWRlT3JUcmF2ZWxsZXIsXHJcbiAgICAgICAgb25Nb3VzZUxlYXZlOiB0aGlzLmhhbmRsZUxlYXZlU2xpZGVPclRyYXZlbGxlcixcclxuICAgICAgICBvbk1vdXNlRG93bjogdGhpcy50cmF2ZWxsZXJEcmFnU3RhcnRIYW5kbGVyc1tpZF0sXHJcbiAgICAgICAgb25Ub3VjaFN0YXJ0OiB0aGlzLnRyYXZlbGxlckRyYWdTdGFydEhhbmRsZXJzW2lkXSxcclxuICAgICAgICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XHJcbiAgICAgICAgICBpZiAoIVsnQXJyb3dMZWZ0JywgJ0Fycm93UmlnaHQnXS5pbmNsdWRlcyhlLmtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgIF90aGlzMy5oYW5kbGVUcmF2ZWxsZXJNb3ZlS2V5Ym9hcmQoZS5rZXkgPT09ICdBcnJvd1JpZ2h0JyA/IDEgOiAtMSwgaWQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25Gb2N1czogZnVuY3Rpb24gb25Gb2N1cygpIHtcclxuICAgICAgICAgIF90aGlzMy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgIGlzVHJhdmVsbGVyRm9jdXNlZDogdHJ1ZVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkJsdXI6IGZ1bmN0aW9uIG9uQmx1cigpIHtcclxuICAgICAgICAgIF90aGlzMy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgIGlzVHJhdmVsbGVyRm9jdXNlZDogZmFsc2VcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgIGN1cnNvcjogJ2NvbC1yZXNpemUnXHJcbiAgICAgICAgfVxyXG4gICAgICB9LCBCcnVzaC5yZW5kZXJUcmF2ZWxsZXIodHJhdmVsbGVyLCB0cmF2ZWxsZXJQcm9wcykpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJTbGlkZVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclNsaWRlKHN0YXJ0WCwgZW5kWCkge1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHM5ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICB5ID0gX3RoaXMkcHJvcHM5LnksXHJcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHM5LmhlaWdodCxcclxuICAgICAgICBzdHJva2UgPSBfdGhpcyRwcm9wczkuc3Ryb2tlLFxyXG4gICAgICAgIHRyYXZlbGxlcldpZHRoID0gX3RoaXMkcHJvcHM5LnRyYXZlbGxlcldpZHRoO1xyXG4gICAgICB2YXIgeCA9IE1hdGgubWluKHN0YXJ0WCwgZW5kWCkgKyB0cmF2ZWxsZXJXaWR0aDtcclxuICAgICAgdmFyIHdpZHRoID0gTWF0aC5tYXgoTWF0aC5hYnMoZW5kWCAtIHN0YXJ0WCkgLSB0cmF2ZWxsZXJXaWR0aCwgMCk7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWJydXNoLXNsaWRlXCIsXHJcbiAgICAgICAgb25Nb3VzZUVudGVyOiB0aGlzLmhhbmRsZUVudGVyU2xpZGVPclRyYXZlbGxlcixcclxuICAgICAgICBvbk1vdXNlTGVhdmU6IHRoaXMuaGFuZGxlTGVhdmVTbGlkZU9yVHJhdmVsbGVyLFxyXG4gICAgICAgIG9uTW91c2VEb3duOiB0aGlzLmhhbmRsZVNsaWRlRHJhZ1N0YXJ0LFxyXG4gICAgICAgIG9uVG91Y2hTdGFydDogdGhpcy5oYW5kbGVTbGlkZURyYWdTdGFydCxcclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgY3Vyc29yOiAnbW92ZSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0cm9rZTogXCJub25lXCIsXHJcbiAgICAgICAgZmlsbDogc3Ryb2tlLFxyXG4gICAgICAgIGZpbGxPcGFjaXR5OiAwLjIsXHJcbiAgICAgICAgeDogeCxcclxuICAgICAgICB5OiB5LFxyXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyVGV4dFwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclRleHQoKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczEwID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBzdGFydEluZGV4ID0gX3RoaXMkcHJvcHMxMC5zdGFydEluZGV4LFxyXG4gICAgICAgIGVuZEluZGV4ID0gX3RoaXMkcHJvcHMxMC5lbmRJbmRleCxcclxuICAgICAgICB5ID0gX3RoaXMkcHJvcHMxMC55LFxyXG4gICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzMTAuaGVpZ2h0LFxyXG4gICAgICAgIHRyYXZlbGxlcldpZHRoID0gX3RoaXMkcHJvcHMxMC50cmF2ZWxsZXJXaWR0aCxcclxuICAgICAgICBzdHJva2UgPSBfdGhpcyRwcm9wczEwLnN0cm9rZTtcclxuICAgICAgdmFyIF90aGlzJHN0YXRlNCA9IHRoaXMuc3RhdGUsXHJcbiAgICAgICAgc3RhcnRYID0gX3RoaXMkc3RhdGU0LnN0YXJ0WCxcclxuICAgICAgICBlbmRYID0gX3RoaXMkc3RhdGU0LmVuZFg7XHJcbiAgICAgIHZhciBvZmZzZXQgPSA1O1xyXG4gICAgICB2YXIgYXR0cnMgPSB7XHJcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxyXG4gICAgICAgIGZpbGw6IHN0cm9rZVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIHtcclxuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtYnJ1c2gtdGV4dHNcIlxyXG4gICAgICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9UZXh0LlRleHQsIF9leHRlbmRzKHtcclxuICAgICAgICB0ZXh0QW5jaG9yOiBcImVuZFwiLFxyXG4gICAgICAgIHZlcnRpY2FsQW5jaG9yOiBcIm1pZGRsZVwiLFxyXG4gICAgICAgIHg6IE1hdGgubWluKHN0YXJ0WCwgZW5kWCkgLSBvZmZzZXQsXHJcbiAgICAgICAgeTogeSArIGhlaWdodCAvIDJcclxuICAgICAgfSwgYXR0cnMpLCB0aGlzLmdldFRleHRPZlRpY2soc3RhcnRJbmRleCkpLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9UZXh0LlRleHQsIF9leHRlbmRzKHtcclxuICAgICAgICB0ZXh0QW5jaG9yOiBcInN0YXJ0XCIsXHJcbiAgICAgICAgdmVydGljYWxBbmNob3I6IFwibWlkZGxlXCIsXHJcbiAgICAgICAgeDogTWF0aC5tYXgoc3RhcnRYLCBlbmRYKSArIHRyYXZlbGxlcldpZHRoICsgb2Zmc2V0LFxyXG4gICAgICAgIHk6IHkgKyBoZWlnaHQgLyAyXHJcbiAgICAgIH0sIGF0dHJzKSwgdGhpcy5nZXRUZXh0T2ZUaWNrKGVuZEluZGV4KSkpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczExID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBkYXRhID0gX3RoaXMkcHJvcHMxMS5kYXRhLFxyXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzMTEuY2xhc3NOYW1lLFxyXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMxMS5jaGlsZHJlbixcclxuICAgICAgICB4ID0gX3RoaXMkcHJvcHMxMS54LFxyXG4gICAgICAgIHkgPSBfdGhpcyRwcm9wczExLnksXHJcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczExLndpZHRoLFxyXG4gICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzMTEuaGVpZ2h0LFxyXG4gICAgICAgIGFsd2F5c1Nob3dUZXh0ID0gX3RoaXMkcHJvcHMxMS5hbHdheXNTaG93VGV4dDtcclxuICAgICAgdmFyIF90aGlzJHN0YXRlNSA9IHRoaXMuc3RhdGUsXHJcbiAgICAgICAgc3RhcnRYID0gX3RoaXMkc3RhdGU1LnN0YXJ0WCxcclxuICAgICAgICBlbmRYID0gX3RoaXMkc3RhdGU1LmVuZFgsXHJcbiAgICAgICAgaXNUZXh0QWN0aXZlID0gX3RoaXMkc3RhdGU1LmlzVGV4dEFjdGl2ZSxcclxuICAgICAgICBpc1NsaWRlTW92aW5nID0gX3RoaXMkc3RhdGU1LmlzU2xpZGVNb3ZpbmcsXHJcbiAgICAgICAgaXNUcmF2ZWxsZXJNb3ZpbmcgPSBfdGhpcyRzdGF0ZTUuaXNUcmF2ZWxsZXJNb3ZpbmcsXHJcbiAgICAgICAgaXNUcmF2ZWxsZXJGb2N1c2VkID0gX3RoaXMkc3RhdGU1LmlzVHJhdmVsbGVyRm9jdXNlZDtcclxuICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHgpIHx8ICEoMCwgX0RhdGFVdGlscy5pc051bWJlcikoeSkgfHwgISgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKSh3aWR0aCkgfHwgISgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShoZWlnaHQpIHx8IHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgbGF5ZXJDbGFzcyA9ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1icnVzaCcsIGNsYXNzTmFtZSk7XHJcbiAgICAgIHZhciBpc1Bhbm9yYW1pYyA9IF9yZWFjdFtcImRlZmF1bHRcIl0uQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pID09PSAxO1xyXG4gICAgICB2YXIgc3R5bGUgPSAoMCwgX0Nzc1ByZWZpeFV0aWxzLmdlbmVyYXRlUHJlZml4U3R5bGUpKCd1c2VyU2VsZWN0JywgJ25vbmUnKTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBsYXllckNsYXNzLFxyXG4gICAgICAgIG9uTW91c2VMZWF2ZTogdGhpcy5oYW5kbGVMZWF2ZVdyYXBwZXIsXHJcbiAgICAgICAgb25Ub3VjaE1vdmU6IHRoaXMuaGFuZGxlVG91Y2hNb3ZlLFxyXG4gICAgICAgIHN0eWxlOiBzdHlsZVxyXG4gICAgICB9LCB0aGlzLnJlbmRlckJhY2tncm91bmQoKSwgaXNQYW5vcmFtaWMgJiYgdGhpcy5yZW5kZXJQYW5vcmFtYSgpLCB0aGlzLnJlbmRlclNsaWRlKHN0YXJ0WCwgZW5kWCksIHRoaXMucmVuZGVyVHJhdmVsbGVyTGF5ZXIoc3RhcnRYLCAnc3RhcnRYJyksIHRoaXMucmVuZGVyVHJhdmVsbGVyTGF5ZXIoZW5kWCwgJ2VuZFgnKSwgKGlzVGV4dEFjdGl2ZSB8fCBpc1NsaWRlTW92aW5nIHx8IGlzVHJhdmVsbGVyTW92aW5nIHx8IGlzVHJhdmVsbGVyRm9jdXNlZCB8fCBhbHdheXNTaG93VGV4dCkgJiYgdGhpcy5yZW5kZXJUZXh0KCkpO1xyXG4gICAgfVxyXG4gIH1dLCBbe1xyXG4gICAga2V5OiBcInJlbmRlckRlZmF1bHRUcmF2ZWxsZXJcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJEZWZhdWx0VHJhdmVsbGVyKHByb3BzKSB7XHJcbiAgICAgIHZhciB4ID0gcHJvcHMueCxcclxuICAgICAgICB5ID0gcHJvcHMueSxcclxuICAgICAgICB3aWR0aCA9IHByb3BzLndpZHRoLFxyXG4gICAgICAgIGhlaWdodCA9IHByb3BzLmhlaWdodCxcclxuICAgICAgICBzdHJva2UgPSBwcm9wcy5zdHJva2U7XHJcbiAgICAgIHZhciBsaW5lWSA9IE1hdGguZmxvb3IoeSArIGhlaWdodCAvIDIpIC0gMTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX3JlYWN0W1wiZGVmYXVsdFwiXS5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xyXG4gICAgICAgIHg6IHgsXHJcbiAgICAgICAgeTogeSxcclxuICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgZmlsbDogc3Ryb2tlLFxyXG4gICAgICAgIHN0cm9rZTogXCJub25lXCJcclxuICAgICAgfSksIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIHtcclxuICAgICAgICB4MTogeCArIDEsXHJcbiAgICAgICAgeTE6IGxpbmVZLFxyXG4gICAgICAgIHgyOiB4ICsgd2lkdGggLSAxLFxyXG4gICAgICAgIHkyOiBsaW5lWSxcclxuICAgICAgICBmaWxsOiBcIm5vbmVcIixcclxuICAgICAgICBzdHJva2U6IFwiI2ZmZlwiXHJcbiAgICAgIH0pLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7XHJcbiAgICAgICAgeDE6IHggKyAxLFxyXG4gICAgICAgIHkxOiBsaW5lWSArIDIsXHJcbiAgICAgICAgeDI6IHggKyB3aWR0aCAtIDEsXHJcbiAgICAgICAgeTI6IGxpbmVZICsgMixcclxuICAgICAgICBmaWxsOiBcIm5vbmVcIixcclxuICAgICAgICBzdHJva2U6IFwiI2ZmZlwiXHJcbiAgICAgIH0pKTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyVHJhdmVsbGVyXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVHJhdmVsbGVyKG9wdGlvbiwgcHJvcHMpIHtcclxuICAgICAgdmFyIHJlY3RhbmdsZTtcclxuICAgICAgaWYgKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5pc1ZhbGlkRWxlbWVudChvcHRpb24pKSB7XHJcbiAgICAgICAgcmVjdGFuZ2xlID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KG9wdGlvbiwgcHJvcHMpO1xyXG4gICAgICB9IGVsc2UgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9wdGlvbikpIHtcclxuICAgICAgICByZWN0YW5nbGUgPSBvcHRpb24ocHJvcHMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlY3RhbmdsZSA9IEJydXNoLnJlbmRlckRlZmF1bHRUcmF2ZWxsZXIocHJvcHMpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZWN0YW5nbGU7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1wiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSkge1xyXG4gICAgICB2YXIgZGF0YSA9IG5leHRQcm9wcy5kYXRhLFxyXG4gICAgICAgIHdpZHRoID0gbmV4dFByb3BzLndpZHRoLFxyXG4gICAgICAgIHggPSBuZXh0UHJvcHMueCxcclxuICAgICAgICB0cmF2ZWxsZXJXaWR0aCA9IG5leHRQcm9wcy50cmF2ZWxsZXJXaWR0aCxcclxuICAgICAgICB1cGRhdGVJZCA9IG5leHRQcm9wcy51cGRhdGVJZCxcclxuICAgICAgICBzdGFydEluZGV4ID0gbmV4dFByb3BzLnN0YXJ0SW5kZXgsXHJcbiAgICAgICAgZW5kSW5kZXggPSBuZXh0UHJvcHMuZW5kSW5kZXg7XHJcbiAgICAgIGlmIChkYXRhICE9PSBwcmV2U3RhdGUucHJldkRhdGEgfHwgdXBkYXRlSWQgIT09IHByZXZTdGF0ZS5wcmV2VXBkYXRlSWQpIHtcclxuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7XHJcbiAgICAgICAgICBwcmV2RGF0YTogZGF0YSxcclxuICAgICAgICAgIHByZXZUcmF2ZWxsZXJXaWR0aDogdHJhdmVsbGVyV2lkdGgsXHJcbiAgICAgICAgICBwcmV2VXBkYXRlSWQ6IHVwZGF0ZUlkLFxyXG4gICAgICAgICAgcHJldlg6IHgsXHJcbiAgICAgICAgICBwcmV2V2lkdGg6IHdpZHRoXHJcbiAgICAgICAgfSwgZGF0YSAmJiBkYXRhLmxlbmd0aCA/IGNyZWF0ZVNjYWxlKHtcclxuICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgdHJhdmVsbGVyV2lkdGg6IHRyYXZlbGxlcldpZHRoLFxyXG4gICAgICAgICAgc3RhcnRJbmRleDogc3RhcnRJbmRleCxcclxuICAgICAgICAgIGVuZEluZGV4OiBlbmRJbmRleFxyXG4gICAgICAgIH0pIDoge1xyXG4gICAgICAgICAgc2NhbGU6IG51bGwsXHJcbiAgICAgICAgICBzY2FsZVZhbHVlczogbnVsbFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwcmV2U3RhdGUuc2NhbGUgJiYgKHdpZHRoICE9PSBwcmV2U3RhdGUucHJldldpZHRoIHx8IHggIT09IHByZXZTdGF0ZS5wcmV2WCB8fCB0cmF2ZWxsZXJXaWR0aCAhPT0gcHJldlN0YXRlLnByZXZUcmF2ZWxsZXJXaWR0aCkpIHtcclxuICAgICAgICBwcmV2U3RhdGUuc2NhbGUucmFuZ2UoW3gsIHggKyB3aWR0aCAtIHRyYXZlbGxlcldpZHRoXSk7XHJcbiAgICAgICAgdmFyIHNjYWxlVmFsdWVzID0gcHJldlN0YXRlLnNjYWxlLmRvbWFpbigpLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICAgIHJldHVybiBwcmV2U3RhdGUuc2NhbGUoZW50cnkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBwcmV2RGF0YTogZGF0YSxcclxuICAgICAgICAgIHByZXZUcmF2ZWxsZXJXaWR0aDogdHJhdmVsbGVyV2lkdGgsXHJcbiAgICAgICAgICBwcmV2VXBkYXRlSWQ6IHVwZGF0ZUlkLFxyXG4gICAgICAgICAgcHJldlg6IHgsXHJcbiAgICAgICAgICBwcmV2V2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgc3RhcnRYOiBwcmV2U3RhdGUuc2NhbGUobmV4dFByb3BzLnN0YXJ0SW5kZXgpLFxyXG4gICAgICAgICAgZW5kWDogcHJldlN0YXRlLnNjYWxlKG5leHRQcm9wcy5lbmRJbmRleCksXHJcbiAgICAgICAgICBzY2FsZVZhbHVlczogc2NhbGVWYWx1ZXNcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJnZXRJbmRleEluUmFuZ2VcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmRleEluUmFuZ2UodmFsdWVSYW5nZSwgeCkge1xyXG4gICAgICB2YXIgbGVuID0gdmFsdWVSYW5nZS5sZW5ndGg7XHJcbiAgICAgIHZhciBzdGFydCA9IDA7XHJcbiAgICAgIHZhciBlbmQgPSBsZW4gLSAxO1xyXG4gICAgICB3aGlsZSAoZW5kIC0gc3RhcnQgPiAxKSB7XHJcbiAgICAgICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xyXG4gICAgICAgIGlmICh2YWx1ZVJhbmdlW21pZGRsZV0gPiB4KSB7XHJcbiAgICAgICAgICBlbmQgPSBtaWRkbGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN0YXJ0ID0gbWlkZGxlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4geCA+PSB2YWx1ZVJhbmdlW2VuZF0gPyBlbmQgOiBzdGFydDtcclxuICAgIH1cclxuICB9XSk7XHJcbn0oX3JlYWN0LlB1cmVDb21wb25lbnQpO1xyXG5fZGVmaW5lUHJvcGVydHkoQnJ1c2gsIFwiZGlzcGxheU5hbWVcIiwgJ0JydXNoJyk7XHJcbl9kZWZpbmVQcm9wZXJ0eShCcnVzaCwgXCJkZWZhdWx0UHJvcHNcIiwge1xyXG4gIGhlaWdodDogNDAsXHJcbiAgdHJhdmVsbGVyV2lkdGg6IDUsXHJcbiAgZ2FwOiAxLFxyXG4gIGZpbGw6ICcjZmZmJyxcclxuICBzdHJva2U6ICcjNjY2JyxcclxuICBwYWRkaW5nOiB7XHJcbiAgICB0b3A6IDEsXHJcbiAgICByaWdodDogMSxcclxuICAgIGJvdHRvbTogMSxcclxuICAgIGxlZnQ6IDFcclxuICB9LFxyXG4gIGxlYXZlVGltZU91dDogMTAwMCxcclxuICBhbHdheXNTaG93VGV4dDogZmFsc2VcclxufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQnJ1c2giLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfY2xzeCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfZDNTY2FsZSIsIl9pc0Z1bmN0aW9uIiwiX3JhbmdlIiwiX0xheWVyIiwiX1RleHQiLCJfQ2hhcnRVdGlscyIsIl9EYXRhVXRpbHMiLCJfQ3NzUHJlZml4VXRpbHMiLCJfUmVhY3RVdGlscyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX3R5cGVvZiIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJhcHBseSIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9Qcm9wZXJ0eUtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsInAiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsImNyZWF0ZVNjYWxlIiwiX3JlZiIsImRhdGEiLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJ4Iiwid2lkdGgiLCJ0cmF2ZWxsZXJXaWR0aCIsImxlbiIsInNjYWxlIiwic2NhbGVQb2ludCIsImRvbWFpbiIsInJhbmdlIiwic2NhbGVWYWx1ZXMiLCJtYXAiLCJlbnRyeSIsImlzVGV4dEFjdGl2ZSIsImlzU2xpZGVNb3ZpbmciLCJpc1RyYXZlbGxlck1vdmluZyIsImlzVHJhdmVsbGVyRm9jdXNlZCIsInN0YXJ0WCIsImVuZFgiLCJpc1RvdWNoIiwiY2hhbmdlZFRvdWNoZXMiLCJfUHVyZUNvbXBvbmVudCIsIl90aGlzIiwibGVhdmVUaW1lciIsImNsZWFyVGltZW91dCIsInN0YXRlIiwiaGFuZGxlVHJhdmVsbGVyTW92ZSIsImhhbmRsZVNsaWRlRHJhZyIsImhhbmRsZURyYWciLCJzZXRTdGF0ZSIsIl90aGlzJHByb3BzIiwib25EcmFnRW5kIiwiZGV0YWNoRHJhZ0VuZExpc3RlbmVyIiwid2luZG93Iiwic2V0VGltZW91dCIsImhhbmRsZURyYWdFbmQiLCJsZWF2ZVRpbWVPdXQiLCJldmVudCIsInNsaWRlTW92ZVN0YXJ0WCIsInBhZ2VYIiwiYXR0YWNoRHJhZ0VuZExpc3RlbmVyIiwidHJhdmVsbGVyRHJhZ1N0YXJ0SGFuZGxlcnMiLCJoYW5kbGVUcmF2ZWxsZXJEcmFnU3RhcnQiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImdldEluZGV4IiwiX3JlZjIiLCJfdGhpcyRwcm9wczIiLCJnYXAiLCJsYXN0SW5kZXgiLCJtaW4iLCJNYXRoIiwibWF4IiwibWluSW5kZXgiLCJnZXRJbmRleEluUmFuZ2UiLCJtYXhJbmRleCIsImdldFRleHRPZlRpY2siLCJpbmRleCIsIl90aGlzJHByb3BzMyIsInRpY2tGb3JtYXR0ZXIiLCJkYXRhS2V5IiwidGV4dCIsImdldFZhbHVlQnlEYXRhS2V5IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJfdGhpcyRzdGF0ZSIsIl90aGlzJHByb3BzNCIsIm9uQ2hhbmdlIiwiZGVsdGEiLCJuZXdJbmRleCIsImlkIiwibW92aW5nVHJhdmVsbGVySWQiLCJicnVzaE1vdmVTdGFydFgiLCJfdGhpcyRzdGF0ZTIiLCJwcmV2VmFsdWUiLCJfdGhpcyRwcm9wczUiLCJwYXJhbXMiLCJpc0Z1bGxHYXAiLCJoYW5kbGVUcmF2ZWxsZXJNb3ZlS2V5Ym9hcmQiLCJkaXJlY3Rpb24iLCJfdGhpczIiLCJfdGhpcyRzdGF0ZTMiLCJjdXJyZW50U2NhbGVWYWx1ZSIsImN1cnJlbnRJbmRleCIsImluZGV4T2YiLCJuZXdTY2FsZVZhbHVlIiwicmVuZGVyQmFja2dyb3VuZCIsIl90aGlzJHByb3BzNiIsInkiLCJoZWlnaHQiLCJmaWxsIiwic3Ryb2tlIiwiY3JlYXRlRWxlbWVudCIsInJlbmRlclBhbm9yYW1hIiwiX3RoaXMkcHJvcHM3IiwiY2hpbGRyZW4iLCJwYWRkaW5nIiwiY2hhcnRFbGVtZW50IiwiQ2hpbGRyZW4iLCJvbmx5IiwiY2xvbmVFbGVtZW50IiwibWFyZ2luIiwiY29tcGFjdCIsInJlbmRlclRyYXZlbGxlckxheWVyIiwidHJhdmVsbGVyWCIsIl9kYXRhJHN0YXJ0SW5kZXgiLCJfZGF0YSRlbmRJbmRleCIsIl90aGlzMyIsIl90aGlzJHByb3BzOCIsInRyYXZlbGxlciIsImFyaWFMYWJlbCIsInRyYXZlbGxlclByb3BzIiwiZmlsdGVyUHJvcHMiLCJhcmlhTGFiZWxCcnVzaCIsImNvbmNhdCIsIm5hbWUiLCJMYXllciIsInRhYkluZGV4Iiwicm9sZSIsImNsYXNzTmFtZSIsIm9uTW91c2VFbnRlciIsImhhbmRsZUVudGVyU2xpZGVPclRyYXZlbGxlciIsIm9uTW91c2VMZWF2ZSIsImhhbmRsZUxlYXZlU2xpZGVPclRyYXZlbGxlciIsIm9uTW91c2VEb3duIiwib25Ub3VjaFN0YXJ0Iiwib25LZXlEb3duIiwiaW5jbHVkZXMiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsIm9uRm9jdXMiLCJvbkJsdXIiLCJzdHlsZSIsImN1cnNvciIsInJlbmRlclRyYXZlbGxlciIsInJlbmRlclNsaWRlIiwiX3RoaXMkcHJvcHM5IiwiYWJzIiwiaGFuZGxlU2xpZGVEcmFnU3RhcnQiLCJmaWxsT3BhY2l0eSIsInJlbmRlclRleHQiLCJfdGhpcyRwcm9wczEwIiwiX3RoaXMkc3RhdGU0Iiwib2Zmc2V0IiwiYXR0cnMiLCJwb2ludGVyRXZlbnRzIiwiVGV4dCIsInRleHRBbmNob3IiLCJ2ZXJ0aWNhbEFuY2hvciIsInJlbmRlciIsIl90aGlzJHByb3BzMTEiLCJhbHdheXNTaG93VGV4dCIsIl90aGlzJHN0YXRlNSIsImlzTnVtYmVyIiwibGF5ZXJDbGFzcyIsImlzUGFub3JhbWljIiwiY291bnQiLCJnZW5lcmF0ZVByZWZpeFN0eWxlIiwiaGFuZGxlTGVhdmVXcmFwcGVyIiwib25Ub3VjaE1vdmUiLCJoYW5kbGVUb3VjaE1vdmUiLCJyZW5kZXJEZWZhdWx0VHJhdmVsbGVyIiwibGluZVkiLCJmbG9vciIsIkZyYWdtZW50IiwieDEiLCJ5MSIsIngyIiwieTIiLCJvcHRpb24iLCJyZWN0YW5nbGUiLCJpc1ZhbGlkRWxlbWVudCIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIm5leHRQcm9wcyIsInByZXZTdGF0ZSIsInVwZGF0ZUlkIiwicHJldkRhdGEiLCJwcmV2VXBkYXRlSWQiLCJwcmV2VHJhdmVsbGVyV2lkdGgiLCJwcmV2WCIsInByZXZXaWR0aCIsInZhbHVlUmFuZ2UiLCJzdGFydCIsImVuZCIsIm1pZGRsZSIsIlB1cmVDb21wb25lbnQiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/cartesian/Brush.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/cartesian/CartesianAxis.js":
/*!**************************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/CartesianAxis.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CartesianAxis = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _get = _interopRequireDefault(__webpack_require__(/*! lodash/get */ \"lodash/get\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _ShallowEqual = __webpack_require__(/*! ../util/ShallowEqual */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ShallowEqual.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _Text = __webpack_require__(/*! ../component/Text */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Text.js\");\nvar _Label = __webpack_require__(/*! ../component/Label */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Label.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _types = __webpack_require__(/*! ../util/types */ \"(pages-dir-node)/./node_modules/recharts/lib/util/types.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _getTicks = __webpack_require__(/*! ./getTicks */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/getTicks.js\");\nvar _excluded = [\n    \"viewBox\"\n], _excluded2 = [\n    \"viewBox\"\n], _excluded3 = [\n    \"ticks\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Cartesian Axis\r\n */ \n/** The orientation of the axis in correspondence to the chart */ /** A unit to be appended to a value */ /** The formatter function of tick */ var CartesianAxis = exports.CartesianAxis = /*#__PURE__*/ function(_Component) {\n    function CartesianAxis(props) {\n        var _this;\n        _classCallCheck(this, CartesianAxis);\n        _this = _callSuper(this, CartesianAxis, [\n            props\n        ]);\n        _this.state = {\n            fontSize: '',\n            letterSpacing: ''\n        };\n        return _this;\n    }\n    _inherits(CartesianAxis, _Component);\n    return _createClass(CartesianAxis, [\n        {\n            key: \"shouldComponentUpdate\",\n            value: function shouldComponentUpdate(_ref, nextState) {\n                var viewBox = _ref.viewBox, restProps = _objectWithoutProperties(_ref, _excluded);\n                // props.viewBox is sometimes generated every time -\n                // check that specially as object equality is likely to fail\n                var _this$props = this.props, viewBoxOld = _this$props.viewBox, restPropsOld = _objectWithoutProperties(_this$props, _excluded2);\n                return !(0, _ShallowEqual.shallowEqual)(viewBox, viewBoxOld) || !(0, _ShallowEqual.shallowEqual)(restProps, restPropsOld) || !(0, _ShallowEqual.shallowEqual)(nextState, this.state);\n            }\n        },\n        {\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n                var htmlLayer = this.layerReference;\n                if (!htmlLayer) return;\n                var tick = htmlLayer.getElementsByClassName('recharts-cartesian-axis-tick-value')[0];\n                if (tick) {\n                    this.setState({\n                        fontSize: window.getComputedStyle(tick).fontSize,\n                        letterSpacing: window.getComputedStyle(tick).letterSpacing\n                    });\n                }\n            }\n        },\n        {\n            key: \"getTickLineCoord\",\n            value: function getTickLineCoord(data) {\n                var _this$props2 = this.props, x = _this$props2.x, y = _this$props2.y, width = _this$props2.width, height = _this$props2.height, orientation = _this$props2.orientation, tickSize = _this$props2.tickSize, mirror = _this$props2.mirror, tickMargin = _this$props2.tickMargin;\n                var x1, x2, y1, y2, tx, ty;\n                var sign = mirror ? -1 : 1;\n                var finalTickSize = data.tickSize || tickSize;\n                var tickCoord = (0, _DataUtils.isNumber)(data.tickCoord) ? data.tickCoord : data.coordinate;\n                switch(orientation){\n                    case 'top':\n                        x1 = x2 = data.coordinate;\n                        y2 = y + +!mirror * height;\n                        y1 = y2 - sign * finalTickSize;\n                        ty = y1 - sign * tickMargin;\n                        tx = tickCoord;\n                        break;\n                    case 'left':\n                        y1 = y2 = data.coordinate;\n                        x2 = x + +!mirror * width;\n                        x1 = x2 - sign * finalTickSize;\n                        tx = x1 - sign * tickMargin;\n                        ty = tickCoord;\n                        break;\n                    case 'right':\n                        y1 = y2 = data.coordinate;\n                        x2 = x + +mirror * width;\n                        x1 = x2 + sign * finalTickSize;\n                        tx = x1 + sign * tickMargin;\n                        ty = tickCoord;\n                        break;\n                    default:\n                        x1 = x2 = data.coordinate;\n                        y2 = y + +mirror * height;\n                        y1 = y2 + sign * finalTickSize;\n                        ty = y1 + sign * tickMargin;\n                        tx = tickCoord;\n                        break;\n                }\n                return {\n                    line: {\n                        x1: x1,\n                        y1: y1,\n                        x2: x2,\n                        y2: y2\n                    },\n                    tick: {\n                        x: tx,\n                        y: ty\n                    }\n                };\n            }\n        },\n        {\n            key: \"getTickTextAnchor\",\n            value: function getTickTextAnchor() {\n                var _this$props3 = this.props, orientation = _this$props3.orientation, mirror = _this$props3.mirror;\n                var textAnchor;\n                switch(orientation){\n                    case 'left':\n                        textAnchor = mirror ? 'start' : 'end';\n                        break;\n                    case 'right':\n                        textAnchor = mirror ? 'end' : 'start';\n                        break;\n                    default:\n                        textAnchor = 'middle';\n                        break;\n                }\n                return textAnchor;\n            }\n        },\n        {\n            key: \"getTickVerticalAnchor\",\n            value: function getTickVerticalAnchor() {\n                var _this$props4 = this.props, orientation = _this$props4.orientation, mirror = _this$props4.mirror;\n                var verticalAnchor = 'end';\n                switch(orientation){\n                    case 'left':\n                    case 'right':\n                        verticalAnchor = 'middle';\n                        break;\n                    case 'top':\n                        verticalAnchor = mirror ? 'start' : 'end';\n                        break;\n                    default:\n                        verticalAnchor = mirror ? 'end' : 'start';\n                        break;\n                }\n                return verticalAnchor;\n            }\n        },\n        {\n            key: \"renderAxisLine\",\n            value: function renderAxisLine() {\n                var _this$props5 = this.props, x = _this$props5.x, y = _this$props5.y, width = _this$props5.width, height = _this$props5.height, orientation = _this$props5.orientation, mirror = _this$props5.mirror, axisLine = _this$props5.axisLine;\n                var props = _objectSpread(_objectSpread(_objectSpread({}, (0, _ReactUtils.filterProps)(this.props, false)), (0, _ReactUtils.filterProps)(axisLine, false)), {}, {\n                    fill: 'none'\n                });\n                if (orientation === 'top' || orientation === 'bottom') {\n                    var needHeight = +(orientation === 'top' && !mirror || orientation === 'bottom' && mirror);\n                    props = _objectSpread(_objectSpread({}, props), {}, {\n                        x1: x,\n                        y1: y + needHeight * height,\n                        x2: x + width,\n                        y2: y + needHeight * height\n                    });\n                } else {\n                    var needWidth = +(orientation === 'left' && !mirror || orientation === 'right' && mirror);\n                    props = _objectSpread(_objectSpread({}, props), {}, {\n                        x1: x + needWidth * width,\n                        y1: y,\n                        x2: x + needWidth * width,\n                        y2: y + height\n                    });\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"line\", _extends({}, props, {\n                    className: (0, _clsx[\"default\"])('recharts-cartesian-axis-line', (0, _get[\"default\"])(axisLine, 'className'))\n                }));\n            }\n        },\n        {\n            key: \"renderTicks\",\n            value: /**\r\n     * render the ticks\r\n     * @param {Array} ticks The ticks to actually render (overrides what was passed in props)\r\n     * @param {string} fontSize Fontsize to consider for tick spacing\r\n     * @param {string} letterSpacing Letterspacing to consider for tick spacing\r\n     * @return {ReactComponent} renderedTicks\r\n     */ function renderTicks(ticks, fontSize, letterSpacing) {\n                var _this2 = this;\n                var _this$props6 = this.props, tickLine = _this$props6.tickLine, stroke = _this$props6.stroke, tick = _this$props6.tick, tickFormatter = _this$props6.tickFormatter, unit = _this$props6.unit;\n                var finalTicks = (0, _getTicks.getTicks)(_objectSpread(_objectSpread({}, this.props), {}, {\n                    ticks: ticks\n                }), fontSize, letterSpacing);\n                var textAnchor = this.getTickTextAnchor();\n                var verticalAnchor = this.getTickVerticalAnchor();\n                var axisProps = (0, _ReactUtils.filterProps)(this.props, false);\n                var customTickProps = (0, _ReactUtils.filterProps)(tick, false);\n                var tickLineProps = _objectSpread(_objectSpread({}, axisProps), {}, {\n                    fill: 'none'\n                }, (0, _ReactUtils.filterProps)(tickLine, false));\n                var items = finalTicks.map(function(entry, i) {\n                    var _this2$getTickLineCoo = _this2.getTickLineCoord(entry), lineCoord = _this2$getTickLineCoo.line, tickCoord = _this2$getTickLineCoo.tick;\n                    var tickProps = _objectSpread(_objectSpread(_objectSpread(_objectSpread({\n                        textAnchor: textAnchor,\n                        verticalAnchor: verticalAnchor\n                    }, axisProps), {}, {\n                        stroke: 'none',\n                        fill: stroke\n                    }, customTickProps), tickCoord), {}, {\n                        index: i,\n                        payload: entry,\n                        visibleTicksCount: finalTicks.length,\n                        tickFormatter: tickFormatter\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                        className: \"recharts-cartesian-axis-tick\",\n                        key: \"tick-\".concat(entry.value, \"-\").concat(entry.coordinate, \"-\").concat(entry.tickCoord)\n                    }, (0, _types.adaptEventsOfChild)(_this2.props, entry, i)), tickLine && /*#__PURE__*/ _react[\"default\"].createElement(\"line\", _extends({}, tickLineProps, lineCoord, {\n                        className: (0, _clsx[\"default\"])('recharts-cartesian-axis-tick-line', (0, _get[\"default\"])(tickLine, 'className'))\n                    })), tick && CartesianAxis.renderTickItem(tick, tickProps, \"\".concat((0, _isFunction[\"default\"])(tickFormatter) ? tickFormatter(entry.value, i) : entry.value).concat(unit || '')));\n                });\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", {\n                    className: \"recharts-cartesian-axis-ticks\"\n                }, items);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this3 = this;\n                var _this$props7 = this.props, axisLine = _this$props7.axisLine, width = _this$props7.width, height = _this$props7.height, ticksGenerator = _this$props7.ticksGenerator, className = _this$props7.className, hide = _this$props7.hide;\n                if (hide) {\n                    return null;\n                }\n                var _this$props8 = this.props, ticks = _this$props8.ticks, noTicksProps = _objectWithoutProperties(_this$props8, _excluded3);\n                var finalTicks = ticks;\n                if ((0, _isFunction[\"default\"])(ticksGenerator)) {\n                    finalTicks = ticks && ticks.length > 0 ? ticksGenerator(this.props) : ticksGenerator(noTicksProps);\n                }\n                if (width <= 0 || height <= 0 || !finalTicks || !finalTicks.length) {\n                    return null;\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: (0, _clsx[\"default\"])('recharts-cartesian-axis', className),\n                    ref: function ref(_ref2) {\n                        _this3.layerReference = _ref2;\n                    }\n                }, axisLine && this.renderAxisLine(), this.renderTicks(finalTicks, this.state.fontSize, this.state.letterSpacing), _Label.Label.renderCallByParent(this.props));\n            }\n        }\n    ], [\n        {\n            key: \"renderTickItem\",\n            value: function renderTickItem(option, props, value) {\n                var tickItem;\n                var combinedClassName = (0, _clsx[\"default\"])(props.className, 'recharts-cartesian-axis-tick-value');\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n                    tickItem = /*#__PURE__*/ _react[\"default\"].cloneElement(option, _objectSpread(_objectSpread({}, props), {}, {\n                        className: combinedClassName\n                    }));\n                } else if ((0, _isFunction[\"default\"])(option)) {\n                    tickItem = option(_objectSpread(_objectSpread({}, props), {}, {\n                        className: combinedClassName\n                    }));\n                } else {\n                    tickItem = /*#__PURE__*/ _react[\"default\"].createElement(_Text.Text, _extends({}, props, {\n                        className: \"recharts-cartesian-axis-tick-value\"\n                    }), value);\n                }\n                return tickItem;\n            }\n        }\n    ]);\n}(_react.Component);\n_defineProperty(CartesianAxis, \"displayName\", 'CartesianAxis');\n_defineProperty(CartesianAxis, \"defaultProps\", {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n    viewBox: {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n    },\n    // The orientation of axis\n    orientation: 'bottom',\n    // The ticks\n    ticks: [],\n    stroke: '#666',\n    tickLine: true,\n    axisLine: true,\n    tick: true,\n    mirror: false,\n    minTickGap: 5,\n    // The width or height of tick\n    tickSize: 6,\n    tickMargin: 2,\n    interval: 'preserveEnd'\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2FydGVzaWFuL0NhcnRlc2lhbkF4aXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELHFCQUFxQixHQUFHLEtBQUs7QUFDN0IsSUFBSUcsU0FBU0Msd0JBQXdCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNwRCxJQUFJQyxjQUFjQyx1QkFBdUJGLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJRyxPQUFPRCx1QkFBdUJGLG1CQUFPQSxDQUFDLDhCQUFZO0FBQ3RELElBQUlJLFFBQVFGLHVCQUF1QkYsbUJBQU9BLENBQUMsdUJBQU07QUFDakQsSUFBSUssZ0JBQWdCTCxtQkFBT0EsQ0FBQywrRkFBc0I7QUFDbEQsSUFBSU0sU0FBU04sbUJBQU9BLENBQUMsMkZBQW9CO0FBQ3pDLElBQUlPLFFBQVFQLG1CQUFPQSxDQUFDLHlGQUFtQjtBQUN2QyxJQUFJUSxTQUFTUixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDekMsSUFBSVMsYUFBYVQsbUJBQU9BLENBQUMseUZBQW1CO0FBQzVDLElBQUlVLFNBQVNWLG1CQUFPQSxDQUFDLGlGQUFlO0FBQ3BDLElBQUlXLGNBQWNYLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM5QyxJQUFJWSxZQUFZWixtQkFBT0EsQ0FBQyxzRkFBWTtBQUNwQyxJQUFJYSxZQUFZO0lBQUM7Q0FBVSxFQUN6QkMsYUFBYTtJQUFDO0NBQVUsRUFDeEJDLGFBQWE7SUFBQztDQUFRO0FBQ3hCLFNBQVNiLHVCQUF1QmMsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSx5QkFBeUJDLENBQUM7SUFBSSxJQUFJLGNBQWMsT0FBT0MsU0FBUyxPQUFPO0lBQU0sSUFBSUMsSUFBSSxJQUFJRCxXQUFXRSxJQUFJLElBQUlGO0lB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LFlBQVk7SUFDWnlFLFVBQVU7QUFDWiIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcY2FydGVzaWFuXFxDYXJ0ZXNpYW5BeGlzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuQ2FydGVzaWFuQXhpcyA9IHZvaWQgMDtcclxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBfaXNGdW5jdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpKTtcclxudmFyIF9nZXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZ2V0XCIpKTtcclxudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XHJcbnZhciBfU2hhbGxvd0VxdWFsID0gcmVxdWlyZShcIi4uL3V0aWwvU2hhbGxvd0VxdWFsXCIpO1xyXG52YXIgX0xheWVyID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9MYXllclwiKTtcclxudmFyIF9UZXh0ID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9UZXh0XCIpO1xyXG52YXIgX0xhYmVsID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9MYWJlbFwiKTtcclxudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9EYXRhVXRpbHNcIik7XHJcbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi4vdXRpbC90eXBlc1wiKTtcclxudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmVhY3RVdGlsc1wiKTtcclxudmFyIF9nZXRUaWNrcyA9IHJlcXVpcmUoXCIuL2dldFRpY2tzXCIpO1xyXG52YXIgX2V4Y2x1ZGVkID0gW1widmlld0JveFwiXSxcclxuICBfZXhjbHVkZWQyID0gW1widmlld0JveFwiXSxcclxuICBfZXhjbHVkZWQzID0gW1widGlja3NcIl07XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XHJcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XHJcbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XHJcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxyXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cclxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XHJcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XHJcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cclxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH0gLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgQ2FydGVzaWFuIEF4aXNcclxuICovXHJcbi8qKiBUaGUgb3JpZW50YXRpb24gb2YgdGhlIGF4aXMgaW4gY29ycmVzcG9uZGVuY2UgdG8gdGhlIGNoYXJ0ICovXHJcbi8qKiBBIHVuaXQgdG8gYmUgYXBwZW5kZWQgdG8gYSB2YWx1ZSAqL1xyXG4vKiogVGhlIGZvcm1hdHRlciBmdW5jdGlvbiBvZiB0aWNrICovXHJcbnZhciBDYXJ0ZXNpYW5BeGlzID0gZXhwb3J0cy5DYXJ0ZXNpYW5BeGlzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29tcG9uZW50KSB7XHJcbiAgZnVuY3Rpb24gQ2FydGVzaWFuQXhpcyhwcm9wcykge1xyXG4gICAgdmFyIF90aGlzO1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhcnRlc2lhbkF4aXMpO1xyXG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIENhcnRlc2lhbkF4aXMsIFtwcm9wc10pO1xyXG4gICAgX3RoaXMuc3RhdGUgPSB7XHJcbiAgICAgIGZvbnRTaXplOiAnJyxcclxuICAgICAgbGV0dGVyU3BhY2luZzogJydcclxuICAgIH07XHJcbiAgICByZXR1cm4gX3RoaXM7XHJcbiAgfVxyXG4gIF9pbmhlcml0cyhDYXJ0ZXNpYW5BeGlzLCBfQ29tcG9uZW50KTtcclxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENhcnRlc2lhbkF4aXMsIFt7XHJcbiAgICBrZXk6IFwic2hvdWxkQ29tcG9uZW50VXBkYXRlXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKF9yZWYsIG5leHRTdGF0ZSkge1xyXG4gICAgICB2YXIgdmlld0JveCA9IF9yZWYudmlld0JveCxcclxuICAgICAgICByZXN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkKTtcclxuICAgICAgLy8gcHJvcHMudmlld0JveCBpcyBzb21ldGltZXMgZ2VuZXJhdGVkIGV2ZXJ5IHRpbWUgLVxyXG4gICAgICAvLyBjaGVjayB0aGF0IHNwZWNpYWxseSBhcyBvYmplY3QgZXF1YWxpdHkgaXMgbGlrZWx5IHRvIGZhaWxcclxuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcclxuICAgICAgICB2aWV3Qm94T2xkID0gX3RoaXMkcHJvcHMudmlld0JveCxcclxuICAgICAgICByZXN0UHJvcHNPbGQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkcHJvcHMsIF9leGNsdWRlZDIpO1xyXG4gICAgICByZXR1cm4gISgwLCBfU2hhbGxvd0VxdWFsLnNoYWxsb3dFcXVhbCkodmlld0JveCwgdmlld0JveE9sZCkgfHwgISgwLCBfU2hhbGxvd0VxdWFsLnNoYWxsb3dFcXVhbCkocmVzdFByb3BzLCByZXN0UHJvcHNPbGQpIHx8ICEoMCwgX1NoYWxsb3dFcXVhbC5zaGFsbG93RXF1YWwpKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgIHZhciBodG1sTGF5ZXIgPSB0aGlzLmxheWVyUmVmZXJlbmNlO1xyXG4gICAgICBpZiAoIWh0bWxMYXllcikgcmV0dXJuO1xyXG4gICAgICB2YXIgdGljayA9IGh0bWxMYXllci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdyZWNoYXJ0cy1jYXJ0ZXNpYW4tYXhpcy10aWNrLXZhbHVlJylbMF07XHJcbiAgICAgIGlmICh0aWNrKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICBmb250U2l6ZTogd2luZG93LmdldENvbXB1dGVkU3R5bGUodGljaykuZm9udFNpemUsXHJcbiAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aWNrKS5sZXR0ZXJTcGFjaW5nXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSB0aGUgY29vcmRpbmF0ZXMgb2YgZW5kcG9pbnRzIGluIHRpY2tzXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgb2YgYSBzaW1wbGUgdGlja1xyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAoeDEsIHkxKTogVGhlIGNvb3JkaW5hdGUgb2YgZW5kcG9pbnQgY2xvc2UgdG8gdGljayB0ZXh0XHJcbiAgICAgKiAgKHgyLCB5Mik6IFRoZSBjb29yZGluYXRlIG9mIGVuZHBvaW50IGNsb3NlIHRvIGF4aXNcclxuICAgICAqL1xyXG4gIH0sIHtcclxuICAgIGtleTogXCJnZXRUaWNrTGluZUNvb3JkXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGlja0xpbmVDb29yZChkYXRhKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIHggPSBfdGhpcyRwcm9wczIueCxcclxuICAgICAgICB5ID0gX3RoaXMkcHJvcHMyLnksXHJcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczIud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHMyLmhlaWdodCxcclxuICAgICAgICBvcmllbnRhdGlvbiA9IF90aGlzJHByb3BzMi5vcmllbnRhdGlvbixcclxuICAgICAgICB0aWNrU2l6ZSA9IF90aGlzJHByb3BzMi50aWNrU2l6ZSxcclxuICAgICAgICBtaXJyb3IgPSBfdGhpcyRwcm9wczIubWlycm9yLFxyXG4gICAgICAgIHRpY2tNYXJnaW4gPSBfdGhpcyRwcm9wczIudGlja01hcmdpbjtcclxuICAgICAgdmFyIHgxLCB4MiwgeTEsIHkyLCB0eCwgdHk7XHJcbiAgICAgIHZhciBzaWduID0gbWlycm9yID8gLTEgOiAxO1xyXG4gICAgICB2YXIgZmluYWxUaWNrU2l6ZSA9IGRhdGEudGlja1NpemUgfHwgdGlja1NpemU7XHJcbiAgICAgIHZhciB0aWNrQ29vcmQgPSAoMCwgX0RhdGFVdGlscy5pc051bWJlcikoZGF0YS50aWNrQ29vcmQpID8gZGF0YS50aWNrQ29vcmQgOiBkYXRhLmNvb3JkaW5hdGU7XHJcbiAgICAgIHN3aXRjaCAob3JpZW50YXRpb24pIHtcclxuICAgICAgICBjYXNlICd0b3AnOlxyXG4gICAgICAgICAgeDEgPSB4MiA9IGRhdGEuY29vcmRpbmF0ZTtcclxuICAgICAgICAgIHkyID0geSArICshbWlycm9yICogaGVpZ2h0O1xyXG4gICAgICAgICAgeTEgPSB5MiAtIHNpZ24gKiBmaW5hbFRpY2tTaXplO1xyXG4gICAgICAgICAgdHkgPSB5MSAtIHNpZ24gKiB0aWNrTWFyZ2luO1xyXG4gICAgICAgICAgdHggPSB0aWNrQ29vcmQ7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgIHkxID0geTIgPSBkYXRhLmNvb3JkaW5hdGU7XHJcbiAgICAgICAgICB4MiA9IHggKyArIW1pcnJvciAqIHdpZHRoO1xyXG4gICAgICAgICAgeDEgPSB4MiAtIHNpZ24gKiBmaW5hbFRpY2tTaXplO1xyXG4gICAgICAgICAgdHggPSB4MSAtIHNpZ24gKiB0aWNrTWFyZ2luO1xyXG4gICAgICAgICAgdHkgPSB0aWNrQ29vcmQ7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdyaWdodCc6XHJcbiAgICAgICAgICB5MSA9IHkyID0gZGF0YS5jb29yZGluYXRlO1xyXG4gICAgICAgICAgeDIgPSB4ICsgK21pcnJvciAqIHdpZHRoO1xyXG4gICAgICAgICAgeDEgPSB4MiArIHNpZ24gKiBmaW5hbFRpY2tTaXplO1xyXG4gICAgICAgICAgdHggPSB4MSArIHNpZ24gKiB0aWNrTWFyZ2luO1xyXG4gICAgICAgICAgdHkgPSB0aWNrQ29vcmQ7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgeDEgPSB4MiA9IGRhdGEuY29vcmRpbmF0ZTtcclxuICAgICAgICAgIHkyID0geSArICttaXJyb3IgKiBoZWlnaHQ7XHJcbiAgICAgICAgICB5MSA9IHkyICsgc2lnbiAqIGZpbmFsVGlja1NpemU7XHJcbiAgICAgICAgICB0eSA9IHkxICsgc2lnbiAqIHRpY2tNYXJnaW47XHJcbiAgICAgICAgICB0eCA9IHRpY2tDb29yZDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbGluZToge1xyXG4gICAgICAgICAgeDE6IHgxLFxyXG4gICAgICAgICAgeTE6IHkxLFxyXG4gICAgICAgICAgeDI6IHgyLFxyXG4gICAgICAgICAgeTI6IHkyXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0aWNrOiB7XHJcbiAgICAgICAgICB4OiB0eCxcclxuICAgICAgICAgIHk6IHR5XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJnZXRUaWNrVGV4dEFuY2hvclwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRpY2tUZXh0QW5jaG9yKCkge1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBvcmllbnRhdGlvbiA9IF90aGlzJHByb3BzMy5vcmllbnRhdGlvbixcclxuICAgICAgICBtaXJyb3IgPSBfdGhpcyRwcm9wczMubWlycm9yO1xyXG4gICAgICB2YXIgdGV4dEFuY2hvcjtcclxuICAgICAgc3dpdGNoIChvcmllbnRhdGlvbikge1xyXG4gICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgdGV4dEFuY2hvciA9IG1pcnJvciA/ICdzdGFydCcgOiAnZW5kJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgIHRleHRBbmNob3IgPSBtaXJyb3IgPyAnZW5kJyA6ICdzdGFydCc7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdGV4dEFuY2hvciA9ICdtaWRkbGUnO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRleHRBbmNob3I7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImdldFRpY2tWZXJ0aWNhbEFuY2hvclwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRpY2tWZXJ0aWNhbEFuY2hvcigpIHtcclxuICAgICAgdmFyIF90aGlzJHByb3BzNCA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgb3JpZW50YXRpb24gPSBfdGhpcyRwcm9wczQub3JpZW50YXRpb24sXHJcbiAgICAgICAgbWlycm9yID0gX3RoaXMkcHJvcHM0Lm1pcnJvcjtcclxuICAgICAgdmFyIHZlcnRpY2FsQW5jaG9yID0gJ2VuZCc7XHJcbiAgICAgIHN3aXRjaCAob3JpZW50YXRpb24pIHtcclxuICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICBjYXNlICdyaWdodCc6XHJcbiAgICAgICAgICB2ZXJ0aWNhbEFuY2hvciA9ICdtaWRkbGUnO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICAgIHZlcnRpY2FsQW5jaG9yID0gbWlycm9yID8gJ3N0YXJ0JyA6ICdlbmQnO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHZlcnRpY2FsQW5jaG9yID0gbWlycm9yID8gJ2VuZCcgOiAnc3RhcnQnO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZlcnRpY2FsQW5jaG9yO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJBeGlzTGluZVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckF4aXNMaW5lKCkge1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHM1ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICB4ID0gX3RoaXMkcHJvcHM1LngsXHJcbiAgICAgICAgeSA9IF90aGlzJHByb3BzNS55LFxyXG4gICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHM1LndpZHRoLFxyXG4gICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzNS5oZWlnaHQsXHJcbiAgICAgICAgb3JpZW50YXRpb24gPSBfdGhpcyRwcm9wczUub3JpZW50YXRpb24sXHJcbiAgICAgICAgbWlycm9yID0gX3RoaXMkcHJvcHM1Lm1pcnJvcixcclxuICAgICAgICBheGlzTGluZSA9IF90aGlzJHByb3BzNS5heGlzTGluZTtcclxuICAgICAgdmFyIHByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykodGhpcy5wcm9wcywgZmFsc2UpKSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShheGlzTGluZSwgZmFsc2UpKSwge30sIHtcclxuICAgICAgICBmaWxsOiAnbm9uZSdcclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ3RvcCcgfHwgb3JpZW50YXRpb24gPT09ICdib3R0b20nKSB7XHJcbiAgICAgICAgdmFyIG5lZWRIZWlnaHQgPSArKG9yaWVudGF0aW9uID09PSAndG9wJyAmJiAhbWlycm9yIHx8IG9yaWVudGF0aW9uID09PSAnYm90dG9tJyAmJiBtaXJyb3IpO1xyXG4gICAgICAgIHByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHt9LCB7XHJcbiAgICAgICAgICB4MTogeCxcclxuICAgICAgICAgIHkxOiB5ICsgbmVlZEhlaWdodCAqIGhlaWdodCxcclxuICAgICAgICAgIHgyOiB4ICsgd2lkdGgsXHJcbiAgICAgICAgICB5MjogeSArIG5lZWRIZWlnaHQgKiBoZWlnaHRcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgbmVlZFdpZHRoID0gKyhvcmllbnRhdGlvbiA9PT0gJ2xlZnQnICYmICFtaXJyb3IgfHwgb3JpZW50YXRpb24gPT09ICdyaWdodCcgJiYgbWlycm9yKTtcclxuICAgICAgICBwcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xyXG4gICAgICAgICAgeDE6IHggKyBuZWVkV2lkdGggKiB3aWR0aCxcclxuICAgICAgICAgIHkxOiB5LFxyXG4gICAgICAgICAgeDI6IHggKyBuZWVkV2lkdGggKiB3aWR0aCxcclxuICAgICAgICAgIHkyOiB5ICsgaGVpZ2h0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xyXG4gICAgICAgIGNsYXNzTmFtZTogKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLWNhcnRlc2lhbi1heGlzLWxpbmUnLCAoMCwgX2dldFtcImRlZmF1bHRcIl0pKGF4aXNMaW5lLCAnY2xhc3NOYW1lJykpXHJcbiAgICAgIH0pKTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyVGlja3NcIixcclxuICAgIHZhbHVlOlxyXG4gICAgLyoqXHJcbiAgICAgKiByZW5kZXIgdGhlIHRpY2tzXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0aWNrcyBUaGUgdGlja3MgdG8gYWN0dWFsbHkgcmVuZGVyIChvdmVycmlkZXMgd2hhdCB3YXMgcGFzc2VkIGluIHByb3BzKVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnRTaXplIEZvbnRzaXplIHRvIGNvbnNpZGVyIGZvciB0aWNrIHNwYWNpbmdcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZXR0ZXJTcGFjaW5nIExldHRlcnNwYWNpbmcgdG8gY29uc2lkZXIgZm9yIHRpY2sgc3BhY2luZ1xyXG4gICAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IHJlbmRlcmVkVGlja3NcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVuZGVyVGlja3ModGlja3MsIGZvbnRTaXplLCBsZXR0ZXJTcGFjaW5nKSB7XHJcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHM2ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICB0aWNrTGluZSA9IF90aGlzJHByb3BzNi50aWNrTGluZSxcclxuICAgICAgICBzdHJva2UgPSBfdGhpcyRwcm9wczYuc3Ryb2tlLFxyXG4gICAgICAgIHRpY2sgPSBfdGhpcyRwcm9wczYudGljayxcclxuICAgICAgICB0aWNrRm9ybWF0dGVyID0gX3RoaXMkcHJvcHM2LnRpY2tGb3JtYXR0ZXIsXHJcbiAgICAgICAgdW5pdCA9IF90aGlzJHByb3BzNi51bml0O1xyXG4gICAgICB2YXIgZmluYWxUaWNrcyA9ICgwLCBfZ2V0VGlja3MuZ2V0VGlja3MpKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5wcm9wcyksIHt9LCB7XHJcbiAgICAgICAgdGlja3M6IHRpY2tzXHJcbiAgICAgIH0pLCBmb250U2l6ZSwgbGV0dGVyU3BhY2luZyk7XHJcbiAgICAgIHZhciB0ZXh0QW5jaG9yID0gdGhpcy5nZXRUaWNrVGV4dEFuY2hvcigpO1xyXG4gICAgICB2YXIgdmVydGljYWxBbmNob3IgPSB0aGlzLmdldFRpY2tWZXJ0aWNhbEFuY2hvcigpO1xyXG4gICAgICB2YXIgYXhpc1Byb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0aGlzLnByb3BzLCBmYWxzZSk7XHJcbiAgICAgIHZhciBjdXN0b21UaWNrUHJvcHMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRpY2ssIGZhbHNlKTtcclxuICAgICAgdmFyIHRpY2tMaW5lUHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGF4aXNQcm9wcyksIHt9LCB7XHJcbiAgICAgICAgZmlsbDogJ25vbmUnXHJcbiAgICAgIH0sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykodGlja0xpbmUsIGZhbHNlKSk7XHJcbiAgICAgIHZhciBpdGVtcyA9IGZpbmFsVGlja3MubWFwKGZ1bmN0aW9uIChlbnRyeSwgaSkge1xyXG4gICAgICAgIHZhciBfdGhpczIkZ2V0VGlja0xpbmVDb28gPSBfdGhpczIuZ2V0VGlja0xpbmVDb29yZChlbnRyeSksXHJcbiAgICAgICAgICBsaW5lQ29vcmQgPSBfdGhpczIkZ2V0VGlja0xpbmVDb28ubGluZSxcclxuICAgICAgICAgIHRpY2tDb29yZCA9IF90aGlzMiRnZXRUaWNrTGluZUNvby50aWNrO1xyXG4gICAgICAgIHZhciB0aWNrUHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcclxuICAgICAgICAgIHRleHRBbmNob3I6IHRleHRBbmNob3IsXHJcbiAgICAgICAgICB2ZXJ0aWNhbEFuY2hvcjogdmVydGljYWxBbmNob3JcclxuICAgICAgICB9LCBheGlzUHJvcHMpLCB7fSwge1xyXG4gICAgICAgICAgc3Ryb2tlOiAnbm9uZScsXHJcbiAgICAgICAgICBmaWxsOiBzdHJva2VcclxuICAgICAgICB9LCBjdXN0b21UaWNrUHJvcHMpLCB0aWNrQ29vcmQpLCB7fSwge1xyXG4gICAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgICBwYXlsb2FkOiBlbnRyeSxcclxuICAgICAgICAgIHZpc2libGVUaWNrc0NvdW50OiBmaW5hbFRpY2tzLmxlbmd0aCxcclxuICAgICAgICAgIHRpY2tGb3JtYXR0ZXI6IHRpY2tGb3JtYXR0ZXJcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIF9leHRlbmRzKHtcclxuICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1jYXJ0ZXNpYW4tYXhpcy10aWNrXCIsXHJcbiAgICAgICAgICBrZXk6IFwidGljay1cIi5jb25jYXQoZW50cnkudmFsdWUsIFwiLVwiKS5jb25jYXQoZW50cnkuY29vcmRpbmF0ZSwgXCItXCIpLmNvbmNhdChlbnRyeS50aWNrQ29vcmQpXHJcbiAgICAgICAgfSwgKDAsIF90eXBlcy5hZGFwdEV2ZW50c09mQ2hpbGQpKF90aGlzMi5wcm9wcywgZW50cnksIGkpKSwgdGlja0xpbmUgJiYgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImxpbmVcIiwgX2V4dGVuZHMoe30sIHRpY2tMaW5lUHJvcHMsIGxpbmVDb29yZCwge1xyXG4gICAgICAgICAgY2xhc3NOYW1lOiAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtY2FydGVzaWFuLWF4aXMtdGljay1saW5lJywgKDAsIF9nZXRbXCJkZWZhdWx0XCJdKSh0aWNrTGluZSwgJ2NsYXNzTmFtZScpKVxyXG4gICAgICAgIH0pKSwgdGljayAmJiBDYXJ0ZXNpYW5BeGlzLnJlbmRlclRpY2tJdGVtKHRpY2ssIHRpY2tQcm9wcywgXCJcIi5jb25jYXQoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkodGlja0Zvcm1hdHRlcikgPyB0aWNrRm9ybWF0dGVyKGVudHJ5LnZhbHVlLCBpKSA6IGVudHJ5LnZhbHVlKS5jb25jYXQodW5pdCB8fCAnJykpKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWNhcnRlc2lhbi1heGlzLXRpY2tzXCJcclxuICAgICAgfSwgaXRlbXMpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHM3ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBheGlzTGluZSA9IF90aGlzJHByb3BzNy5heGlzTGluZSxcclxuICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzNy53aWR0aCxcclxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczcuaGVpZ2h0LFxyXG4gICAgICAgIHRpY2tzR2VuZXJhdG9yID0gX3RoaXMkcHJvcHM3LnRpY2tzR2VuZXJhdG9yLFxyXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzNy5jbGFzc05hbWUsXHJcbiAgICAgICAgaGlkZSA9IF90aGlzJHByb3BzNy5oaWRlO1xyXG4gICAgICBpZiAoaGlkZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczggPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIHRpY2tzID0gX3RoaXMkcHJvcHM4LnRpY2tzLFxyXG4gICAgICAgIG5vVGlja3NQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdGhpcyRwcm9wczgsIF9leGNsdWRlZDMpO1xyXG4gICAgICB2YXIgZmluYWxUaWNrcyA9IHRpY2tzO1xyXG4gICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkodGlja3NHZW5lcmF0b3IpKSB7XHJcbiAgICAgICAgZmluYWxUaWNrcyA9IHRpY2tzICYmIHRpY2tzLmxlbmd0aCA+IDAgPyB0aWNrc0dlbmVyYXRvcih0aGlzLnByb3BzKSA6IHRpY2tzR2VuZXJhdG9yKG5vVGlja3NQcm9wcyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDAgfHwgIWZpbmFsVGlja3MgfHwgIWZpbmFsVGlja3MubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtY2FydGVzaWFuLWF4aXMnLCBjbGFzc05hbWUpLFxyXG4gICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKF9yZWYyKSB7XHJcbiAgICAgICAgICBfdGhpczMubGF5ZXJSZWZlcmVuY2UgPSBfcmVmMjtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIGF4aXNMaW5lICYmIHRoaXMucmVuZGVyQXhpc0xpbmUoKSwgdGhpcy5yZW5kZXJUaWNrcyhmaW5hbFRpY2tzLCB0aGlzLnN0YXRlLmZvbnRTaXplLCB0aGlzLnN0YXRlLmxldHRlclNwYWNpbmcpLCBfTGFiZWwuTGFiZWwucmVuZGVyQ2FsbEJ5UGFyZW50KHRoaXMucHJvcHMpKTtcclxuICAgIH1cclxuICB9XSwgW3tcclxuICAgIGtleTogXCJyZW5kZXJUaWNrSXRlbVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclRpY2tJdGVtKG9wdGlvbiwgcHJvcHMsIHZhbHVlKSB7XHJcbiAgICAgIHZhciB0aWNrSXRlbTtcclxuICAgICAgdmFyIGNvbWJpbmVkQ2xhc3NOYW1lID0gKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkocHJvcHMuY2xhc3NOYW1lLCAncmVjaGFydHMtY2FydGVzaWFuLWF4aXMtdGljay12YWx1ZScpO1xyXG4gICAgICBpZiAoIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KG9wdGlvbikpIHtcclxuICAgICAgICB0aWNrSXRlbSA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChvcHRpb24sIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xyXG4gICAgICAgICAgY2xhc3NOYW1lOiBjb21iaW5lZENsYXNzTmFtZVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgfSBlbHNlIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvcHRpb24pKSB7XHJcbiAgICAgICAgdGlja0l0ZW0gPSBvcHRpb24oX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHt9LCB7XHJcbiAgICAgICAgICBjbGFzc05hbWU6IGNvbWJpbmVkQ2xhc3NOYW1lXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRpY2tJdGVtID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfVGV4dC5UZXh0LCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcclxuICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1jYXJ0ZXNpYW4tYXhpcy10aWNrLXZhbHVlXCJcclxuICAgICAgICB9KSwgdmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aWNrSXRlbTtcclxuICAgIH1cclxuICB9XSk7XHJcbn0oX3JlYWN0LkNvbXBvbmVudCk7XHJcbl9kZWZpbmVQcm9wZXJ0eShDYXJ0ZXNpYW5BeGlzLCBcImRpc3BsYXlOYW1lXCIsICdDYXJ0ZXNpYW5BeGlzJyk7XHJcbl9kZWZpbmVQcm9wZXJ0eShDYXJ0ZXNpYW5BeGlzLCBcImRlZmF1bHRQcm9wc1wiLCB7XHJcbiAgeDogMCxcclxuICB5OiAwLFxyXG4gIHdpZHRoOiAwLFxyXG4gIGhlaWdodDogMCxcclxuICB2aWV3Qm94OiB7XHJcbiAgICB4OiAwLFxyXG4gICAgeTogMCxcclxuICAgIHdpZHRoOiAwLFxyXG4gICAgaGVpZ2h0OiAwXHJcbiAgfSxcclxuICAvLyBUaGUgb3JpZW50YXRpb24gb2YgYXhpc1xyXG4gIG9yaWVudGF0aW9uOiAnYm90dG9tJyxcclxuICAvLyBUaGUgdGlja3NcclxuICB0aWNrczogW10sXHJcbiAgc3Ryb2tlOiAnIzY2NicsXHJcbiAgdGlja0xpbmU6IHRydWUsXHJcbiAgYXhpc0xpbmU6IHRydWUsXHJcbiAgdGljazogdHJ1ZSxcclxuICBtaXJyb3I6IGZhbHNlLFxyXG4gIG1pblRpY2tHYXA6IDUsXHJcbiAgLy8gVGhlIHdpZHRoIG9yIGhlaWdodCBvZiB0aWNrXHJcbiAgdGlja1NpemU6IDYsXHJcbiAgdGlja01hcmdpbjogMixcclxuICBpbnRlcnZhbDogJ3ByZXNlcnZlRW5kJ1xyXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDYXJ0ZXNpYW5BeGlzIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX2lzRnVuY3Rpb24iLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2dldCIsIl9jbHN4IiwiX1NoYWxsb3dFcXVhbCIsIl9MYXllciIsIl9UZXh0IiwiX0xhYmVsIiwiX0RhdGFVdGlscyIsIl90eXBlcyIsIl9SZWFjdFV0aWxzIiwiX2dldFRpY2tzIiwiX2V4Y2x1ZGVkIiwiX2V4Y2x1ZGVkMiIsIl9leGNsdWRlZDMiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwicHJvdG90eXBlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwiYXBwbHkiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImVudW1lcmFibGUiLCJwdXNoIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsImV4Y2x1ZGVkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJzb3VyY2VTeW1ib2xLZXlzIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9Qcm9wZXJ0eUtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsInAiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsIl9Db21wb25lbnQiLCJfdGhpcyIsInN0YXRlIiwiZm9udFNpemUiLCJsZXR0ZXJTcGFjaW5nIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiX3JlZiIsIm5leHRTdGF0ZSIsInZpZXdCb3giLCJyZXN0UHJvcHMiLCJfdGhpcyRwcm9wcyIsInZpZXdCb3hPbGQiLCJyZXN0UHJvcHNPbGQiLCJzaGFsbG93RXF1YWwiLCJjb21wb25lbnREaWRNb3VudCIsImh0bWxMYXllciIsImxheWVyUmVmZXJlbmNlIiwidGljayIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJzZXRTdGF0ZSIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRUaWNrTGluZUNvb3JkIiwiZGF0YSIsIl90aGlzJHByb3BzMiIsIngiLCJ5Iiwid2lkdGgiLCJoZWlnaHQiLCJvcmllbnRhdGlvbiIsInRpY2tTaXplIiwibWlycm9yIiwidGlja01hcmdpbiIsIngxIiwieDIiLCJ5MSIsInkyIiwidHgiLCJ0eSIsInNpZ24iLCJmaW5hbFRpY2tTaXplIiwidGlja0Nvb3JkIiwiaXNOdW1iZXIiLCJjb29yZGluYXRlIiwibGluZSIsImdldFRpY2tUZXh0QW5jaG9yIiwiX3RoaXMkcHJvcHMzIiwidGV4dEFuY2hvciIsImdldFRpY2tWZXJ0aWNhbEFuY2hvciIsIl90aGlzJHByb3BzNCIsInZlcnRpY2FsQW5jaG9yIiwicmVuZGVyQXhpc0xpbmUiLCJfdGhpcyRwcm9wczUiLCJheGlzTGluZSIsImZpbHRlclByb3BzIiwiZmlsbCIsIm5lZWRIZWlnaHQiLCJuZWVkV2lkdGgiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwicmVuZGVyVGlja3MiLCJ0aWNrcyIsIl90aGlzMiIsIl90aGlzJHByb3BzNiIsInRpY2tMaW5lIiwic3Ryb2tlIiwidGlja0Zvcm1hdHRlciIsInVuaXQiLCJmaW5hbFRpY2tzIiwiZ2V0VGlja3MiLCJheGlzUHJvcHMiLCJjdXN0b21UaWNrUHJvcHMiLCJ0aWNrTGluZVByb3BzIiwiaXRlbXMiLCJtYXAiLCJlbnRyeSIsIl90aGlzMiRnZXRUaWNrTGluZUNvbyIsImxpbmVDb29yZCIsInRpY2tQcm9wcyIsImluZGV4IiwicGF5bG9hZCIsInZpc2libGVUaWNrc0NvdW50IiwiTGF5ZXIiLCJjb25jYXQiLCJhZGFwdEV2ZW50c09mQ2hpbGQiLCJyZW5kZXJUaWNrSXRlbSIsInJlbmRlciIsIl90aGlzMyIsIl90aGlzJHByb3BzNyIsInRpY2tzR2VuZXJhdG9yIiwiaGlkZSIsIl90aGlzJHByb3BzOCIsIm5vVGlja3NQcm9wcyIsInJlZiIsIl9yZWYyIiwiTGFiZWwiLCJyZW5kZXJDYWxsQnlQYXJlbnQiLCJvcHRpb24iLCJ0aWNrSXRlbSIsImNvbWJpbmVkQ2xhc3NOYW1lIiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJUZXh0IiwiQ29tcG9uZW50IiwibWluVGlja0dhcCIsImludGVydmFsIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/cartesian/CartesianAxis.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/cartesian/CartesianGrid.js":
/*!**************************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/CartesianGrid.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CartesianGrid = CartesianGrid;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _LogUtils = __webpack_require__(/*! ../util/LogUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/LogUtils.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _getTicks = __webpack_require__(/*! ./getTicks */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/getTicks.js\");\nvar _CartesianAxis = __webpack_require__(/*! ./CartesianAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/CartesianAxis.js\");\nvar _chartLayoutContext = __webpack_require__(/*! ../context/chartLayoutContext */ \"(pages-dir-node)/./node_modules/recharts/lib/context/chartLayoutContext.js\");\nvar _excluded = [\n    \"x1\",\n    \"y1\",\n    \"x2\",\n    \"y2\",\n    \"key\"\n], _excluded2 = [\n    \"offset\"\n];\n/**\r\n * @fileOverview Cartesian Grid\r\n */ function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\n/**\r\n * The <CartesianGrid horizontal\r\n */ var Background = function Background(props) {\n    var fill = props.fill;\n    if (!fill || fill === 'none') {\n        return null;\n    }\n    var fillOpacity = props.fillOpacity, x = props.x, y = props.y, width = props.width, height = props.height, ry = props.ry;\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n        x: x,\n        y: y,\n        ry: ry,\n        width: width,\n        height: height,\n        stroke: \"none\",\n        fill: fill,\n        fillOpacity: fillOpacity,\n        className: \"recharts-cartesian-grid-bg\"\n    });\n};\nfunction renderLineItem(option, props) {\n    var lineItem;\n    if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n        // @ts-expect-error typescript does not see the props type when cloning an element\n        lineItem = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n    } else if ((0, _isFunction[\"default\"])(option)) {\n        lineItem = option(props);\n    } else {\n        var x1 = props.x1, y1 = props.y1, x2 = props.x2, y2 = props.y2, key = props.key, others = _objectWithoutProperties(props, _excluded);\n        var _filterProps = (0, _ReactUtils.filterProps)(others, false), __ = _filterProps.offset, restOfFilteredProps = _objectWithoutProperties(_filterProps, _excluded2);\n        lineItem = /*#__PURE__*/ _react[\"default\"].createElement(\"line\", _extends({}, restOfFilteredProps, {\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2,\n            fill: \"none\",\n            key: key\n        }));\n    }\n    return lineItem;\n}\nfunction HorizontalGridLines(props) {\n    var x = props.x, width = props.width, _props$horizontal = props.horizontal, horizontal = _props$horizontal === void 0 ? true : _props$horizontal, horizontalPoints = props.horizontalPoints;\n    if (!horizontal || !horizontalPoints || !horizontalPoints.length) {\n        return null;\n    }\n    var items = horizontalPoints.map(function(entry, i) {\n        var lineItemProps = _objectSpread(_objectSpread({}, props), {}, {\n            x1: x,\n            y1: entry,\n            x2: x + width,\n            y2: entry,\n            key: \"line-\".concat(i),\n            index: i\n        });\n        return renderLineItem(horizontal, lineItemProps);\n    });\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", {\n        className: \"recharts-cartesian-grid-horizontal\"\n    }, items);\n}\nfunction VerticalGridLines(props) {\n    var y = props.y, height = props.height, _props$vertical = props.vertical, vertical = _props$vertical === void 0 ? true : _props$vertical, verticalPoints = props.verticalPoints;\n    if (!vertical || !verticalPoints || !verticalPoints.length) {\n        return null;\n    }\n    var items = verticalPoints.map(function(entry, i) {\n        var lineItemProps = _objectSpread(_objectSpread({}, props), {}, {\n            x1: entry,\n            y1: y,\n            x2: entry,\n            y2: y + height,\n            key: \"line-\".concat(i),\n            index: i\n        });\n        return renderLineItem(vertical, lineItemProps);\n    });\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", {\n        className: \"recharts-cartesian-grid-vertical\"\n    }, items);\n}\nfunction HorizontalStripes(props) {\n    var horizontalFill = props.horizontalFill, fillOpacity = props.fillOpacity, x = props.x, y = props.y, width = props.width, height = props.height, horizontalPoints = props.horizontalPoints, _props$horizontal2 = props.horizontal, horizontal = _props$horizontal2 === void 0 ? true : _props$horizontal2;\n    if (!horizontal || !horizontalFill || !horizontalFill.length) {\n        return null;\n    }\n    // Why =y -y? I was trying to find any difference that this makes, with floating point numbers and edge cases but ... nothing.\n    var roundedSortedHorizontalPoints = horizontalPoints.map(function(e) {\n        return Math.round(e + y - y);\n    }).sort(function(a, b) {\n        return a - b;\n    });\n    // Why is this condition `!==` instead of `<=` ?\n    if (y !== roundedSortedHorizontalPoints[0]) {\n        roundedSortedHorizontalPoints.unshift(0);\n    }\n    var items = roundedSortedHorizontalPoints.map(function(entry, i) {\n        // Why do we strip only the last stripe if it is invisible, and not all invisible stripes?\n        var lastStripe = !roundedSortedHorizontalPoints[i + 1];\n        var lineHeight = lastStripe ? y + height - entry : roundedSortedHorizontalPoints[i + 1] - entry;\n        if (lineHeight <= 0) {\n            return null;\n        }\n        var colorIndex = i % horizontalFill.length;\n        return /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n            key: \"react-\".concat(i) // eslint-disable-line react/no-array-index-key\n            ,\n            y: entry,\n            x: x,\n            height: lineHeight,\n            width: width,\n            stroke: \"none\",\n            fill: horizontalFill[colorIndex],\n            fillOpacity: fillOpacity,\n            className: \"recharts-cartesian-grid-bg\"\n        });\n    });\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", {\n        className: \"recharts-cartesian-gridstripes-horizontal\"\n    }, items);\n}\nfunction VerticalStripes(props) {\n    var _props$vertical2 = props.vertical, vertical = _props$vertical2 === void 0 ? true : _props$vertical2, verticalFill = props.verticalFill, fillOpacity = props.fillOpacity, x = props.x, y = props.y, width = props.width, height = props.height, verticalPoints = props.verticalPoints;\n    if (!vertical || !verticalFill || !verticalFill.length) {\n        return null;\n    }\n    var roundedSortedVerticalPoints = verticalPoints.map(function(e) {\n        return Math.round(e + x - x);\n    }).sort(function(a, b) {\n        return a - b;\n    });\n    if (x !== roundedSortedVerticalPoints[0]) {\n        roundedSortedVerticalPoints.unshift(0);\n    }\n    var items = roundedSortedVerticalPoints.map(function(entry, i) {\n        var lastStripe = !roundedSortedVerticalPoints[i + 1];\n        var lineWidth = lastStripe ? x + width - entry : roundedSortedVerticalPoints[i + 1] - entry;\n        if (lineWidth <= 0) {\n            return null;\n        }\n        var colorIndex = i % verticalFill.length;\n        return /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n            key: \"react-\".concat(i) // eslint-disable-line react/no-array-index-key\n            ,\n            x: entry,\n            y: y,\n            width: lineWidth,\n            height: height,\n            stroke: \"none\",\n            fill: verticalFill[colorIndex],\n            fillOpacity: fillOpacity,\n            className: \"recharts-cartesian-grid-bg\"\n        });\n    });\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", {\n        className: \"recharts-cartesian-gridstripes-vertical\"\n    }, items);\n}\nvar defaultVerticalCoordinatesGenerator = function defaultVerticalCoordinatesGenerator(_ref, syncWithTicks) {\n    var xAxis = _ref.xAxis, width = _ref.width, height = _ref.height, offset = _ref.offset;\n    return (0, _ChartUtils.getCoordinatesOfGrid)((0, _getTicks.getTicks)(_objectSpread(_objectSpread(_objectSpread({}, _CartesianAxis.CartesianAxis.defaultProps), xAxis), {}, {\n        ticks: (0, _ChartUtils.getTicksOfAxis)(xAxis, true),\n        viewBox: {\n            x: 0,\n            y: 0,\n            width: width,\n            height: height\n        }\n    })), offset.left, offset.left + offset.width, syncWithTicks);\n};\nvar defaultHorizontalCoordinatesGenerator = function defaultHorizontalCoordinatesGenerator(_ref2, syncWithTicks) {\n    var yAxis = _ref2.yAxis, width = _ref2.width, height = _ref2.height, offset = _ref2.offset;\n    return (0, _ChartUtils.getCoordinatesOfGrid)((0, _getTicks.getTicks)(_objectSpread(_objectSpread(_objectSpread({}, _CartesianAxis.CartesianAxis.defaultProps), yAxis), {}, {\n        ticks: (0, _ChartUtils.getTicksOfAxis)(yAxis, true),\n        viewBox: {\n            x: 0,\n            y: 0,\n            width: width,\n            height: height\n        }\n    })), offset.top, offset.top + offset.height, syncWithTicks);\n};\nvar defaultProps = {\n    horizontal: true,\n    vertical: true,\n    // The ordinates of horizontal grid lines\n    horizontalPoints: [],\n    // The abscissas of vertical grid lines\n    verticalPoints: [],\n    stroke: '#ccc',\n    fill: 'none',\n    // The fill of colors of grid lines\n    verticalFill: [],\n    horizontalFill: []\n};\nfunction CartesianGrid(props) {\n    var _props$stroke, _props$fill, _props$horizontal3, _props$horizontalFill, _props$vertical3, _props$verticalFill;\n    var chartWidth = (0, _chartLayoutContext.useChartWidth)();\n    var chartHeight = (0, _chartLayoutContext.useChartHeight)();\n    var offset = (0, _chartLayoutContext.useOffset)();\n    var propsIncludingDefaults = _objectSpread(_objectSpread({}, props), {}, {\n        stroke: (_props$stroke = props.stroke) !== null && _props$stroke !== void 0 ? _props$stroke : defaultProps.stroke,\n        fill: (_props$fill = props.fill) !== null && _props$fill !== void 0 ? _props$fill : defaultProps.fill,\n        horizontal: (_props$horizontal3 = props.horizontal) !== null && _props$horizontal3 !== void 0 ? _props$horizontal3 : defaultProps.horizontal,\n        horizontalFill: (_props$horizontalFill = props.horizontalFill) !== null && _props$horizontalFill !== void 0 ? _props$horizontalFill : defaultProps.horizontalFill,\n        vertical: (_props$vertical3 = props.vertical) !== null && _props$vertical3 !== void 0 ? _props$vertical3 : defaultProps.vertical,\n        verticalFill: (_props$verticalFill = props.verticalFill) !== null && _props$verticalFill !== void 0 ? _props$verticalFill : defaultProps.verticalFill,\n        x: (0, _DataUtils.isNumber)(props.x) ? props.x : offset.left,\n        y: (0, _DataUtils.isNumber)(props.y) ? props.y : offset.top,\n        width: (0, _DataUtils.isNumber)(props.width) ? props.width : offset.width,\n        height: (0, _DataUtils.isNumber)(props.height) ? props.height : offset.height\n    });\n    var x = propsIncludingDefaults.x, y = propsIncludingDefaults.y, width = propsIncludingDefaults.width, height = propsIncludingDefaults.height, syncWithTicks = propsIncludingDefaults.syncWithTicks, horizontalValues = propsIncludingDefaults.horizontalValues, verticalValues = propsIncludingDefaults.verticalValues;\n    // @ts-expect-error the scale prop is mixed up - we need to untagle this at some point\n    var xAxis = (0, _chartLayoutContext.useArbitraryXAxis)();\n    // @ts-expect-error the scale prop is mixed up - we need to untagle this at some point\n    var yAxis = (0, _chartLayoutContext.useYAxisWithFiniteDomainOrRandom)();\n    if (!(0, _DataUtils.isNumber)(width) || width <= 0 || !(0, _DataUtils.isNumber)(height) || height <= 0 || !(0, _DataUtils.isNumber)(x) || x !== +x || !(0, _DataUtils.isNumber)(y) || y !== +y) {\n        return null;\n    }\n    /*\r\n   * verticalCoordinatesGenerator and horizontalCoordinatesGenerator are defined\r\n   * outside of the propsIncludingDefaults because they were never part of the original props\r\n   * and they were never passed as a prop down to horizontal/vertical custom elements.\r\n   * If we add these two to propsIncludingDefaults then we are changing public API.\r\n   * Not a bad thing per se but also not necessary.\r\n   */ var verticalCoordinatesGenerator = propsIncludingDefaults.verticalCoordinatesGenerator || defaultVerticalCoordinatesGenerator;\n    var horizontalCoordinatesGenerator = propsIncludingDefaults.horizontalCoordinatesGenerator || defaultHorizontalCoordinatesGenerator;\n    var horizontalPoints = propsIncludingDefaults.horizontalPoints, verticalPoints = propsIncludingDefaults.verticalPoints;\n    // No horizontal points are specified\n    if ((!horizontalPoints || !horizontalPoints.length) && (0, _isFunction[\"default\"])(horizontalCoordinatesGenerator)) {\n        var isHorizontalValues = horizontalValues && horizontalValues.length;\n        var generatorResult = horizontalCoordinatesGenerator({\n            yAxis: yAxis ? _objectSpread(_objectSpread({}, yAxis), {}, {\n                ticks: isHorizontalValues ? horizontalValues : yAxis.ticks\n            }) : undefined,\n            width: chartWidth,\n            height: chartHeight,\n            offset: offset\n        }, isHorizontalValues ? true : syncWithTicks);\n        (0, _LogUtils.warn)(Array.isArray(generatorResult), \"horizontalCoordinatesGenerator should return Array but instead it returned [\".concat(_typeof(generatorResult), \"]\"));\n        if (Array.isArray(generatorResult)) {\n            horizontalPoints = generatorResult;\n        }\n    }\n    // No vertical points are specified\n    if ((!verticalPoints || !verticalPoints.length) && (0, _isFunction[\"default\"])(verticalCoordinatesGenerator)) {\n        var isVerticalValues = verticalValues && verticalValues.length;\n        var _generatorResult = verticalCoordinatesGenerator({\n            xAxis: xAxis ? _objectSpread(_objectSpread({}, xAxis), {}, {\n                ticks: isVerticalValues ? verticalValues : xAxis.ticks\n            }) : undefined,\n            width: chartWidth,\n            height: chartHeight,\n            offset: offset\n        }, isVerticalValues ? true : syncWithTicks);\n        (0, _LogUtils.warn)(Array.isArray(_generatorResult), \"verticalCoordinatesGenerator should return Array but instead it returned [\".concat(_typeof(_generatorResult), \"]\"));\n        if (Array.isArray(_generatorResult)) {\n            verticalPoints = _generatorResult;\n        }\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", {\n        className: \"recharts-cartesian-grid\"\n    }, /*#__PURE__*/ _react[\"default\"].createElement(Background, {\n        fill: propsIncludingDefaults.fill,\n        fillOpacity: propsIncludingDefaults.fillOpacity,\n        x: propsIncludingDefaults.x,\n        y: propsIncludingDefaults.y,\n        width: propsIncludingDefaults.width,\n        height: propsIncludingDefaults.height,\n        ry: propsIncludingDefaults.ry\n    }), /*#__PURE__*/ _react[\"default\"].createElement(HorizontalGridLines, _extends({}, propsIncludingDefaults, {\n        offset: offset,\n        horizontalPoints: horizontalPoints,\n        xAxis: xAxis,\n        yAxis: yAxis\n    })), /*#__PURE__*/ _react[\"default\"].createElement(VerticalGridLines, _extends({}, propsIncludingDefaults, {\n        offset: offset,\n        verticalPoints: verticalPoints,\n        xAxis: xAxis,\n        yAxis: yAxis\n    })), /*#__PURE__*/ _react[\"default\"].createElement(HorizontalStripes, _extends({}, propsIncludingDefaults, {\n        horizontalPoints: horizontalPoints\n    })), /*#__PURE__*/ _react[\"default\"].createElement(VerticalStripes, _extends({}, propsIncludingDefaults, {\n        verticalPoints: verticalPoints\n    })));\n}\nCartesianGrid.displayName = 'CartesianGrid';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2FydGVzaWFuL0NhcnRlc2lhbkdyaWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELHFCQUFxQixHQUFHRTtBQUN4QixJQUFJQyxTQUFTQyx1QkFBdUJDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ25ELElBQUlDLGNBQWNGLHVCQUF1QkMsbUJBQU9BLENBQUMsNENBQW1CO0FBQ3BFLElBQUlFLFlBQVlGLG1CQUFPQSxDQUFDLHVGQUFrQjtBQUMxQyxJQUFJRyxhQUFhSCxtQkFBT0EsQ0FBQyx5RkFBbUI7QUFDNUMsSUFBSUksY0FBY0osbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlLLGNBQWNMLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM5QyxJQUFJTSxZQUFZTixtQkFBT0EsQ0FBQyxzRkFBWTtBQUNwQyxJQUFJTyxpQkFBaUJQLG1CQUFPQSxDQUFDLGdHQUFpQjtBQUM5QyxJQUFJUSxzQkFBc0JSLG1CQUFPQSxDQUFDLGlIQUErQjtBQUNqRSxJQUFJUyxZQUFZO0lBQUM7SUFBTTtJQUFNO0lBQU07SUFBTTtDQUFNLEVBQzdDQyxhQUFhO0lBQUM7Q0FBUztBQUN6Qjs7Q0FFQyxHQUNELFNBQVNYLHVCQUF1QlksR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRSxXQUFXLEtBQUtDLFVBQVVELE1BQU1DLE9BQU9FLFNBQVMsR0FBRyxX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QkFBdUIvRSxNQUFNO1FBQ3JDQyxJQUFJOEUsdUJBQXVCOUUsRUFBRTtJQUMvQixJQUFJLFdBQVcsR0FBRXJFLE1BQU0sQ0FBQyxVQUFVLENBQUNzRSxhQUFhLENBQUNrQixxQkFBcUJ2QyxTQUFTLENBQUMsR0FBR2tHLHdCQUF3QjtRQUN6RzdELFFBQVFBO1FBQ1JLLGtCQUFrQkE7UUFDbEJnQyxPQUFPQTtRQUNQVyxPQUFPQTtJQUNULEtBQUssV0FBVyxHQUFFdEksTUFBTSxDQUFDLFVBQVUsQ0FBQ3NFLGFBQWEsQ0FBQzRCLG1CQUFtQmpELFNBQVMsQ0FBQyxHQUFHa0csd0JBQXdCO1FBQ3hHN0QsUUFBUUE7UUFDUmUsZ0JBQWdCQTtRQUNoQnNCLE9BQU9BO1FBQ1BXLE9BQU9BO0lBQ1QsS0FBSyxXQUFXLEdBQUV0SSxNQUFNLENBQUMsVUFBVSxDQUFDc0UsYUFBYSxDQUFDZ0MsbUJBQW1CckQsU0FBUyxDQUFDLEdBQUdrRyx3QkFBd0I7UUFDeEd4RCxrQkFBa0JBO0lBQ3BCLEtBQUssV0FBVyxHQUFFM0YsTUFBTSxDQUFDLFVBQVUsQ0FBQ3NFLGFBQWEsQ0FBQzZDLGlCQUFpQmxFLFNBQVMsQ0FBQyxHQUFHa0csd0JBQXdCO1FBQ3RHOUMsZ0JBQWdCQTtJQUNsQjtBQUNGO0FBQ0F0RyxjQUFjb0ssV0FBVyxHQUFHIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxjYXJ0ZXNpYW5cXENhcnRlc2lhbkdyaWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5DYXJ0ZXNpYW5HcmlkID0gQ2FydGVzaWFuR3JpZDtcclxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xyXG52YXIgX0xvZ1V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvTG9nVXRpbHNcIik7XHJcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRGF0YVV0aWxzXCIpO1xyXG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xyXG52YXIgX0NoYXJ0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9DaGFydFV0aWxzXCIpO1xyXG52YXIgX2dldFRpY2tzID0gcmVxdWlyZShcIi4vZ2V0VGlja3NcIik7XHJcbnZhciBfQ2FydGVzaWFuQXhpcyA9IHJlcXVpcmUoXCIuL0NhcnRlc2lhbkF4aXNcIik7XHJcbnZhciBfY2hhcnRMYXlvdXRDb250ZXh0ID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY2hhcnRMYXlvdXRDb250ZXh0XCIpO1xyXG52YXIgX2V4Y2x1ZGVkID0gW1wieDFcIiwgXCJ5MVwiLCBcIngyXCIsIFwieTJcIiwgXCJrZXlcIl0sXHJcbiAgX2V4Y2x1ZGVkMiA9IFtcIm9mZnNldFwiXTtcclxuLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgQ2FydGVzaWFuIEdyaWRcclxuICovXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cclxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cclxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxuLyoqXHJcbiAqIFRoZSA8Q2FydGVzaWFuR3JpZCBob3Jpem9udGFsXHJcbiAqL1xyXG5cclxudmFyIEJhY2tncm91bmQgPSBmdW5jdGlvbiBCYWNrZ3JvdW5kKHByb3BzKSB7XHJcbiAgdmFyIGZpbGwgPSBwcm9wcy5maWxsO1xyXG4gIGlmICghZmlsbCB8fCBmaWxsID09PSAnbm9uZScpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICB2YXIgZmlsbE9wYWNpdHkgPSBwcm9wcy5maWxsT3BhY2l0eSxcclxuICAgIHggPSBwcm9wcy54LFxyXG4gICAgeSA9IHByb3BzLnksXHJcbiAgICB3aWR0aCA9IHByb3BzLndpZHRoLFxyXG4gICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0LFxyXG4gICAgcnkgPSBwcm9wcy5yeTtcclxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xyXG4gICAgeDogeCxcclxuICAgIHk6IHksXHJcbiAgICByeTogcnksXHJcbiAgICB3aWR0aDogd2lkdGgsXHJcbiAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgIHN0cm9rZTogXCJub25lXCIsXHJcbiAgICBmaWxsOiBmaWxsLFxyXG4gICAgZmlsbE9wYWNpdHk6IGZpbGxPcGFjaXR5LFxyXG4gICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWNhcnRlc2lhbi1ncmlkLWJnXCJcclxuICB9KTtcclxufTtcclxuZnVuY3Rpb24gcmVuZGVyTGluZUl0ZW0ob3B0aW9uLCBwcm9wcykge1xyXG4gIHZhciBsaW5lSXRlbTtcclxuICBpZiAoIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KG9wdGlvbikpIHtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdHlwZXNjcmlwdCBkb2VzIG5vdCBzZWUgdGhlIHByb3BzIHR5cGUgd2hlbiBjbG9uaW5nIGFuIGVsZW1lbnRcclxuICAgIGxpbmVJdGVtID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KG9wdGlvbiwgcHJvcHMpO1xyXG4gIH0gZWxzZSBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob3B0aW9uKSkge1xyXG4gICAgbGluZUl0ZW0gPSBvcHRpb24ocHJvcHMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgeDEgPSBwcm9wcy54MSxcclxuICAgICAgeTEgPSBwcm9wcy55MSxcclxuICAgICAgeDIgPSBwcm9wcy54MixcclxuICAgICAgeTIgPSBwcm9wcy55MixcclxuICAgICAga2V5ID0gcHJvcHMua2V5LFxyXG4gICAgICBvdGhlcnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZCk7XHJcbiAgICB2YXIgX2ZpbHRlclByb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShvdGhlcnMsIGZhbHNlKSxcclxuICAgICAgX18gPSBfZmlsdGVyUHJvcHMub2Zmc2V0LFxyXG4gICAgICByZXN0T2ZGaWx0ZXJlZFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9maWx0ZXJQcm9wcywgX2V4Y2x1ZGVkMik7XHJcbiAgICBsaW5lSXRlbSA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIF9leHRlbmRzKHt9LCByZXN0T2ZGaWx0ZXJlZFByb3BzLCB7XHJcbiAgICAgIHgxOiB4MSxcclxuICAgICAgeTE6IHkxLFxyXG4gICAgICB4MjogeDIsXHJcbiAgICAgIHkyOiB5MixcclxuICAgICAgZmlsbDogXCJub25lXCIsXHJcbiAgICAgIGtleToga2V5XHJcbiAgICB9KSk7XHJcbiAgfVxyXG4gIHJldHVybiBsaW5lSXRlbTtcclxufVxyXG5mdW5jdGlvbiBIb3Jpem9udGFsR3JpZExpbmVzKHByb3BzKSB7XHJcbiAgdmFyIHggPSBwcm9wcy54LFxyXG4gICAgd2lkdGggPSBwcm9wcy53aWR0aCxcclxuICAgIF9wcm9wcyRob3Jpem9udGFsID0gcHJvcHMuaG9yaXpvbnRhbCxcclxuICAgIGhvcml6b250YWwgPSBfcHJvcHMkaG9yaXpvbnRhbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9wcm9wcyRob3Jpem9udGFsLFxyXG4gICAgaG9yaXpvbnRhbFBvaW50cyA9IHByb3BzLmhvcml6b250YWxQb2ludHM7XHJcbiAgaWYgKCFob3Jpem9udGFsIHx8ICFob3Jpem9udGFsUG9pbnRzIHx8ICFob3Jpem9udGFsUG9pbnRzLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHZhciBpdGVtcyA9IGhvcml6b250YWxQb2ludHMubWFwKGZ1bmN0aW9uIChlbnRyeSwgaSkge1xyXG4gICAgdmFyIGxpbmVJdGVtUHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwge30sIHtcclxuICAgICAgeDE6IHgsXHJcbiAgICAgIHkxOiBlbnRyeSxcclxuICAgICAgeDI6IHggKyB3aWR0aCxcclxuICAgICAgeTI6IGVudHJ5LFxyXG4gICAgICBrZXk6IFwibGluZS1cIi5jb25jYXQoaSksXHJcbiAgICAgIGluZGV4OiBpXHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZW5kZXJMaW5lSXRlbShob3Jpem9udGFsLCBsaW5lSXRlbVByb3BzKTtcclxuICB9KTtcclxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImdcIiwge1xyXG4gICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWNhcnRlc2lhbi1ncmlkLWhvcml6b250YWxcIlxyXG4gIH0sIGl0ZW1zKTtcclxufVxyXG5mdW5jdGlvbiBWZXJ0aWNhbEdyaWRMaW5lcyhwcm9wcykge1xyXG4gIHZhciB5ID0gcHJvcHMueSxcclxuICAgIGhlaWdodCA9IHByb3BzLmhlaWdodCxcclxuICAgIF9wcm9wcyR2ZXJ0aWNhbCA9IHByb3BzLnZlcnRpY2FsLFxyXG4gICAgdmVydGljYWwgPSBfcHJvcHMkdmVydGljYWwgPT09IHZvaWQgMCA/IHRydWUgOiBfcHJvcHMkdmVydGljYWwsXHJcbiAgICB2ZXJ0aWNhbFBvaW50cyA9IHByb3BzLnZlcnRpY2FsUG9pbnRzO1xyXG4gIGlmICghdmVydGljYWwgfHwgIXZlcnRpY2FsUG9pbnRzIHx8ICF2ZXJ0aWNhbFBvaW50cy5sZW5ndGgpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICB2YXIgaXRlbXMgPSB2ZXJ0aWNhbFBvaW50cy5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpKSB7XHJcbiAgICB2YXIgbGluZUl0ZW1Qcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xyXG4gICAgICB4MTogZW50cnksXHJcbiAgICAgIHkxOiB5LFxyXG4gICAgICB4MjogZW50cnksXHJcbiAgICAgIHkyOiB5ICsgaGVpZ2h0LFxyXG4gICAgICBrZXk6IFwibGluZS1cIi5jb25jYXQoaSksXHJcbiAgICAgIGluZGV4OiBpXHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZW5kZXJMaW5lSXRlbSh2ZXJ0aWNhbCwgbGluZUl0ZW1Qcm9wcyk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcclxuICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1jYXJ0ZXNpYW4tZ3JpZC12ZXJ0aWNhbFwiXHJcbiAgfSwgaXRlbXMpO1xyXG59XHJcbmZ1bmN0aW9uIEhvcml6b250YWxTdHJpcGVzKHByb3BzKSB7XHJcbiAgdmFyIGhvcml6b250YWxGaWxsID0gcHJvcHMuaG9yaXpvbnRhbEZpbGwsXHJcbiAgICBmaWxsT3BhY2l0eSA9IHByb3BzLmZpbGxPcGFjaXR5LFxyXG4gICAgeCA9IHByb3BzLngsXHJcbiAgICB5ID0gcHJvcHMueSxcclxuICAgIHdpZHRoID0gcHJvcHMud2lkdGgsXHJcbiAgICBoZWlnaHQgPSBwcm9wcy5oZWlnaHQsXHJcbiAgICBob3Jpem9udGFsUG9pbnRzID0gcHJvcHMuaG9yaXpvbnRhbFBvaW50cyxcclxuICAgIF9wcm9wcyRob3Jpem9udGFsMiA9IHByb3BzLmhvcml6b250YWwsXHJcbiAgICBob3Jpem9udGFsID0gX3Byb3BzJGhvcml6b250YWwyID09PSB2b2lkIDAgPyB0cnVlIDogX3Byb3BzJGhvcml6b250YWwyO1xyXG4gIGlmICghaG9yaXpvbnRhbCB8fCAhaG9yaXpvbnRhbEZpbGwgfHwgIWhvcml6b250YWxGaWxsLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBXaHkgPXkgLXk/IEkgd2FzIHRyeWluZyB0byBmaW5kIGFueSBkaWZmZXJlbmNlIHRoYXQgdGhpcyBtYWtlcywgd2l0aCBmbG9hdGluZyBwb2ludCBudW1iZXJzIGFuZCBlZGdlIGNhc2VzIGJ1dCAuLi4gbm90aGluZy5cclxuICB2YXIgcm91bmRlZFNvcnRlZEhvcml6b250YWxQb2ludHMgPSBob3Jpem9udGFsUG9pbnRzLm1hcChmdW5jdGlvbiAoZSkge1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQoZSArIHkgLSB5KTtcclxuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICByZXR1cm4gYSAtIGI7XHJcbiAgfSk7XHJcbiAgLy8gV2h5IGlzIHRoaXMgY29uZGl0aW9uIGAhPT1gIGluc3RlYWQgb2YgYDw9YCA/XHJcbiAgaWYgKHkgIT09IHJvdW5kZWRTb3J0ZWRIb3Jpem9udGFsUG9pbnRzWzBdKSB7XHJcbiAgICByb3VuZGVkU29ydGVkSG9yaXpvbnRhbFBvaW50cy51bnNoaWZ0KDApO1xyXG4gIH1cclxuICB2YXIgaXRlbXMgPSByb3VuZGVkU29ydGVkSG9yaXpvbnRhbFBvaW50cy5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpKSB7XHJcbiAgICAvLyBXaHkgZG8gd2Ugc3RyaXAgb25seSB0aGUgbGFzdCBzdHJpcGUgaWYgaXQgaXMgaW52aXNpYmxlLCBhbmQgbm90IGFsbCBpbnZpc2libGUgc3RyaXBlcz9cclxuICAgIHZhciBsYXN0U3RyaXBlID0gIXJvdW5kZWRTb3J0ZWRIb3Jpem9udGFsUG9pbnRzW2kgKyAxXTtcclxuICAgIHZhciBsaW5lSGVpZ2h0ID0gbGFzdFN0cmlwZSA/IHkgKyBoZWlnaHQgLSBlbnRyeSA6IHJvdW5kZWRTb3J0ZWRIb3Jpem9udGFsUG9pbnRzW2kgKyAxXSAtIGVudHJ5O1xyXG4gICAgaWYgKGxpbmVIZWlnaHQgPD0gMCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHZhciBjb2xvckluZGV4ID0gaSAlIGhvcml6b250YWxGaWxsLmxlbmd0aDtcclxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XHJcbiAgICAgIGtleTogXCJyZWFjdC1cIi5jb25jYXQoaSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC9uby1hcnJheS1pbmRleC1rZXlcclxuICAgICAgLFxyXG4gICAgICB5OiBlbnRyeSxcclxuICAgICAgeDogeCxcclxuICAgICAgaGVpZ2h0OiBsaW5lSGVpZ2h0LFxyXG4gICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgIHN0cm9rZTogXCJub25lXCIsXHJcbiAgICAgIGZpbGw6IGhvcml6b250YWxGaWxsW2NvbG9ySW5kZXhdLFxyXG4gICAgICBmaWxsT3BhY2l0eTogZmlsbE9wYWNpdHksXHJcbiAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1jYXJ0ZXNpYW4tZ3JpZC1iZ1wiXHJcbiAgICB9KTtcclxuICB9KTtcclxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImdcIiwge1xyXG4gICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWNhcnRlc2lhbi1ncmlkc3RyaXBlcy1ob3Jpem9udGFsXCJcclxuICB9LCBpdGVtcyk7XHJcbn1cclxuZnVuY3Rpb24gVmVydGljYWxTdHJpcGVzKHByb3BzKSB7XHJcbiAgdmFyIF9wcm9wcyR2ZXJ0aWNhbDIgPSBwcm9wcy52ZXJ0aWNhbCxcclxuICAgIHZlcnRpY2FsID0gX3Byb3BzJHZlcnRpY2FsMiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9wcm9wcyR2ZXJ0aWNhbDIsXHJcbiAgICB2ZXJ0aWNhbEZpbGwgPSBwcm9wcy52ZXJ0aWNhbEZpbGwsXHJcbiAgICBmaWxsT3BhY2l0eSA9IHByb3BzLmZpbGxPcGFjaXR5LFxyXG4gICAgeCA9IHByb3BzLngsXHJcbiAgICB5ID0gcHJvcHMueSxcclxuICAgIHdpZHRoID0gcHJvcHMud2lkdGgsXHJcbiAgICBoZWlnaHQgPSBwcm9wcy5oZWlnaHQsXHJcbiAgICB2ZXJ0aWNhbFBvaW50cyA9IHByb3BzLnZlcnRpY2FsUG9pbnRzO1xyXG4gIGlmICghdmVydGljYWwgfHwgIXZlcnRpY2FsRmlsbCB8fCAhdmVydGljYWxGaWxsLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHZhciByb3VuZGVkU29ydGVkVmVydGljYWxQb2ludHMgPSB2ZXJ0aWNhbFBvaW50cy5tYXAoZnVuY3Rpb24gKGUpIHtcclxuICAgIHJldHVybiBNYXRoLnJvdW5kKGUgKyB4IC0geCk7XHJcbiAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgcmV0dXJuIGEgLSBiO1xyXG4gIH0pO1xyXG4gIGlmICh4ICE9PSByb3VuZGVkU29ydGVkVmVydGljYWxQb2ludHNbMF0pIHtcclxuICAgIHJvdW5kZWRTb3J0ZWRWZXJ0aWNhbFBvaW50cy51bnNoaWZ0KDApO1xyXG4gIH1cclxuICB2YXIgaXRlbXMgPSByb3VuZGVkU29ydGVkVmVydGljYWxQb2ludHMubWFwKGZ1bmN0aW9uIChlbnRyeSwgaSkge1xyXG4gICAgdmFyIGxhc3RTdHJpcGUgPSAhcm91bmRlZFNvcnRlZFZlcnRpY2FsUG9pbnRzW2kgKyAxXTtcclxuICAgIHZhciBsaW5lV2lkdGggPSBsYXN0U3RyaXBlID8geCArIHdpZHRoIC0gZW50cnkgOiByb3VuZGVkU29ydGVkVmVydGljYWxQb2ludHNbaSArIDFdIC0gZW50cnk7XHJcbiAgICBpZiAobGluZVdpZHRoIDw9IDApIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB2YXIgY29sb3JJbmRleCA9IGkgJSB2ZXJ0aWNhbEZpbGwubGVuZ3RoO1xyXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcclxuICAgICAga2V5OiBcInJlYWN0LVwiLmNvbmNhdChpKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxyXG4gICAgICAsXHJcbiAgICAgIHg6IGVudHJ5LFxyXG4gICAgICB5OiB5LFxyXG4gICAgICB3aWR0aDogbGluZVdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgc3Ryb2tlOiBcIm5vbmVcIixcclxuICAgICAgZmlsbDogdmVydGljYWxGaWxsW2NvbG9ySW5kZXhdLFxyXG4gICAgICBmaWxsT3BhY2l0eTogZmlsbE9wYWNpdHksXHJcbiAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1jYXJ0ZXNpYW4tZ3JpZC1iZ1wiXHJcbiAgICB9KTtcclxuICB9KTtcclxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImdcIiwge1xyXG4gICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWNhcnRlc2lhbi1ncmlkc3RyaXBlcy12ZXJ0aWNhbFwiXHJcbiAgfSwgaXRlbXMpO1xyXG59XHJcbnZhciBkZWZhdWx0VmVydGljYWxDb29yZGluYXRlc0dlbmVyYXRvciA9IGZ1bmN0aW9uIGRlZmF1bHRWZXJ0aWNhbENvb3JkaW5hdGVzR2VuZXJhdG9yKF9yZWYsIHN5bmNXaXRoVGlja3MpIHtcclxuICB2YXIgeEF4aXMgPSBfcmVmLnhBeGlzLFxyXG4gICAgd2lkdGggPSBfcmVmLndpZHRoLFxyXG4gICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXHJcbiAgICBvZmZzZXQgPSBfcmVmLm9mZnNldDtcclxuICByZXR1cm4gKDAsIF9DaGFydFV0aWxzLmdldENvb3JkaW5hdGVzT2ZHcmlkKSgoMCwgX2dldFRpY2tzLmdldFRpY2tzKShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX0NhcnRlc2lhbkF4aXMuQ2FydGVzaWFuQXhpcy5kZWZhdWx0UHJvcHMpLCB4QXhpcyksIHt9LCB7XHJcbiAgICB0aWNrczogKDAsIF9DaGFydFV0aWxzLmdldFRpY2tzT2ZBeGlzKSh4QXhpcywgdHJ1ZSksXHJcbiAgICB2aWV3Qm94OiB7XHJcbiAgICAgIHg6IDAsXHJcbiAgICAgIHk6IDAsXHJcbiAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgaGVpZ2h0OiBoZWlnaHRcclxuICAgIH1cclxuICB9KSksIG9mZnNldC5sZWZ0LCBvZmZzZXQubGVmdCArIG9mZnNldC53aWR0aCwgc3luY1dpdGhUaWNrcyk7XHJcbn07XHJcbnZhciBkZWZhdWx0SG9yaXpvbnRhbENvb3JkaW5hdGVzR2VuZXJhdG9yID0gZnVuY3Rpb24gZGVmYXVsdEhvcml6b250YWxDb29yZGluYXRlc0dlbmVyYXRvcihfcmVmMiwgc3luY1dpdGhUaWNrcykge1xyXG4gIHZhciB5QXhpcyA9IF9yZWYyLnlBeGlzLFxyXG4gICAgd2lkdGggPSBfcmVmMi53aWR0aCxcclxuICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodCxcclxuICAgIG9mZnNldCA9IF9yZWYyLm9mZnNldDtcclxuICByZXR1cm4gKDAsIF9DaGFydFV0aWxzLmdldENvb3JkaW5hdGVzT2ZHcmlkKSgoMCwgX2dldFRpY2tzLmdldFRpY2tzKShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX0NhcnRlc2lhbkF4aXMuQ2FydGVzaWFuQXhpcy5kZWZhdWx0UHJvcHMpLCB5QXhpcyksIHt9LCB7XHJcbiAgICB0aWNrczogKDAsIF9DaGFydFV0aWxzLmdldFRpY2tzT2ZBeGlzKSh5QXhpcywgdHJ1ZSksXHJcbiAgICB2aWV3Qm94OiB7XHJcbiAgICAgIHg6IDAsXHJcbiAgICAgIHk6IDAsXHJcbiAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgaGVpZ2h0OiBoZWlnaHRcclxuICAgIH1cclxuICB9KSksIG9mZnNldC50b3AsIG9mZnNldC50b3AgKyBvZmZzZXQuaGVpZ2h0LCBzeW5jV2l0aFRpY2tzKTtcclxufTtcclxudmFyIGRlZmF1bHRQcm9wcyA9IHtcclxuICBob3Jpem9udGFsOiB0cnVlLFxyXG4gIHZlcnRpY2FsOiB0cnVlLFxyXG4gIC8vIFRoZSBvcmRpbmF0ZXMgb2YgaG9yaXpvbnRhbCBncmlkIGxpbmVzXHJcbiAgaG9yaXpvbnRhbFBvaW50czogW10sXHJcbiAgLy8gVGhlIGFic2Npc3NhcyBvZiB2ZXJ0aWNhbCBncmlkIGxpbmVzXHJcbiAgdmVydGljYWxQb2ludHM6IFtdLFxyXG4gIHN0cm9rZTogJyNjY2MnLFxyXG4gIGZpbGw6ICdub25lJyxcclxuICAvLyBUaGUgZmlsbCBvZiBjb2xvcnMgb2YgZ3JpZCBsaW5lc1xyXG4gIHZlcnRpY2FsRmlsbDogW10sXHJcbiAgaG9yaXpvbnRhbEZpbGw6IFtdXHJcbn07XHJcbmZ1bmN0aW9uIENhcnRlc2lhbkdyaWQocHJvcHMpIHtcclxuICB2YXIgX3Byb3BzJHN0cm9rZSwgX3Byb3BzJGZpbGwsIF9wcm9wcyRob3Jpem9udGFsMywgX3Byb3BzJGhvcml6b250YWxGaWxsLCBfcHJvcHMkdmVydGljYWwzLCBfcHJvcHMkdmVydGljYWxGaWxsO1xyXG4gIHZhciBjaGFydFdpZHRoID0gKDAsIF9jaGFydExheW91dENvbnRleHQudXNlQ2hhcnRXaWR0aCkoKTtcclxuICB2YXIgY2hhcnRIZWlnaHQgPSAoMCwgX2NoYXJ0TGF5b3V0Q29udGV4dC51c2VDaGFydEhlaWdodCkoKTtcclxuICB2YXIgb2Zmc2V0ID0gKDAsIF9jaGFydExheW91dENvbnRleHQudXNlT2Zmc2V0KSgpO1xyXG4gIHZhciBwcm9wc0luY2x1ZGluZ0RlZmF1bHRzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHt9LCB7XHJcbiAgICBzdHJva2U6IChfcHJvcHMkc3Ryb2tlID0gcHJvcHMuc3Ryb2tlKSAhPT0gbnVsbCAmJiBfcHJvcHMkc3Ryb2tlICE9PSB2b2lkIDAgPyBfcHJvcHMkc3Ryb2tlIDogZGVmYXVsdFByb3BzLnN0cm9rZSxcclxuICAgIGZpbGw6IChfcHJvcHMkZmlsbCA9IHByb3BzLmZpbGwpICE9PSBudWxsICYmIF9wcm9wcyRmaWxsICE9PSB2b2lkIDAgPyBfcHJvcHMkZmlsbCA6IGRlZmF1bHRQcm9wcy5maWxsLFxyXG4gICAgaG9yaXpvbnRhbDogKF9wcm9wcyRob3Jpem9udGFsMyA9IHByb3BzLmhvcml6b250YWwpICE9PSBudWxsICYmIF9wcm9wcyRob3Jpem9udGFsMyAhPT0gdm9pZCAwID8gX3Byb3BzJGhvcml6b250YWwzIDogZGVmYXVsdFByb3BzLmhvcml6b250YWwsXHJcbiAgICBob3Jpem9udGFsRmlsbDogKF9wcm9wcyRob3Jpem9udGFsRmlsbCA9IHByb3BzLmhvcml6b250YWxGaWxsKSAhPT0gbnVsbCAmJiBfcHJvcHMkaG9yaXpvbnRhbEZpbGwgIT09IHZvaWQgMCA/IF9wcm9wcyRob3Jpem9udGFsRmlsbCA6IGRlZmF1bHRQcm9wcy5ob3Jpem9udGFsRmlsbCxcclxuICAgIHZlcnRpY2FsOiAoX3Byb3BzJHZlcnRpY2FsMyA9IHByb3BzLnZlcnRpY2FsKSAhPT0gbnVsbCAmJiBfcHJvcHMkdmVydGljYWwzICE9PSB2b2lkIDAgPyBfcHJvcHMkdmVydGljYWwzIDogZGVmYXVsdFByb3BzLnZlcnRpY2FsLFxyXG4gICAgdmVydGljYWxGaWxsOiAoX3Byb3BzJHZlcnRpY2FsRmlsbCA9IHByb3BzLnZlcnRpY2FsRmlsbCkgIT09IG51bGwgJiYgX3Byb3BzJHZlcnRpY2FsRmlsbCAhPT0gdm9pZCAwID8gX3Byb3BzJHZlcnRpY2FsRmlsbCA6IGRlZmF1bHRQcm9wcy52ZXJ0aWNhbEZpbGwsXHJcbiAgICB4OiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikocHJvcHMueCkgPyBwcm9wcy54IDogb2Zmc2V0LmxlZnQsXHJcbiAgICB5OiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikocHJvcHMueSkgPyBwcm9wcy55IDogb2Zmc2V0LnRvcCxcclxuICAgIHdpZHRoOiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikocHJvcHMud2lkdGgpID8gcHJvcHMud2lkdGggOiBvZmZzZXQud2lkdGgsXHJcbiAgICBoZWlnaHQ6ICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShwcm9wcy5oZWlnaHQpID8gcHJvcHMuaGVpZ2h0IDogb2Zmc2V0LmhlaWdodFxyXG4gIH0pO1xyXG4gIHZhciB4ID0gcHJvcHNJbmNsdWRpbmdEZWZhdWx0cy54LFxyXG4gICAgeSA9IHByb3BzSW5jbHVkaW5nRGVmYXVsdHMueSxcclxuICAgIHdpZHRoID0gcHJvcHNJbmNsdWRpbmdEZWZhdWx0cy53aWR0aCxcclxuICAgIGhlaWdodCA9IHByb3BzSW5jbHVkaW5nRGVmYXVsdHMuaGVpZ2h0LFxyXG4gICAgc3luY1dpdGhUaWNrcyA9IHByb3BzSW5jbHVkaW5nRGVmYXVsdHMuc3luY1dpdGhUaWNrcyxcclxuICAgIGhvcml6b250YWxWYWx1ZXMgPSBwcm9wc0luY2x1ZGluZ0RlZmF1bHRzLmhvcml6b250YWxWYWx1ZXMsXHJcbiAgICB2ZXJ0aWNhbFZhbHVlcyA9IHByb3BzSW5jbHVkaW5nRGVmYXVsdHMudmVydGljYWxWYWx1ZXM7XHJcblxyXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgdGhlIHNjYWxlIHByb3AgaXMgbWl4ZWQgdXAgLSB3ZSBuZWVkIHRvIHVudGFnbGUgdGhpcyBhdCBzb21lIHBvaW50XHJcbiAgdmFyIHhBeGlzID0gKDAsIF9jaGFydExheW91dENvbnRleHQudXNlQXJiaXRyYXJ5WEF4aXMpKCk7XHJcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGUgc2NhbGUgcHJvcCBpcyBtaXhlZCB1cCAtIHdlIG5lZWQgdG8gdW50YWdsZSB0aGlzIGF0IHNvbWUgcG9pbnRcclxuICB2YXIgeUF4aXMgPSAoMCwgX2NoYXJ0TGF5b3V0Q29udGV4dC51c2VZQXhpc1dpdGhGaW5pdGVEb21haW5PclJhbmRvbSkoKTtcclxuICBpZiAoISgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKSh3aWR0aCkgfHwgd2lkdGggPD0gMCB8fCAhKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGhlaWdodCkgfHwgaGVpZ2h0IDw9IDAgfHwgISgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKSh4KSB8fCB4ICE9PSAreCB8fCAhKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHkpIHx8IHkgIT09ICt5KSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qXHJcbiAgICogdmVydGljYWxDb29yZGluYXRlc0dlbmVyYXRvciBhbmQgaG9yaXpvbnRhbENvb3JkaW5hdGVzR2VuZXJhdG9yIGFyZSBkZWZpbmVkXHJcbiAgICogb3V0c2lkZSBvZiB0aGUgcHJvcHNJbmNsdWRpbmdEZWZhdWx0cyBiZWNhdXNlIHRoZXkgd2VyZSBuZXZlciBwYXJ0IG9mIHRoZSBvcmlnaW5hbCBwcm9wc1xyXG4gICAqIGFuZCB0aGV5IHdlcmUgbmV2ZXIgcGFzc2VkIGFzIGEgcHJvcCBkb3duIHRvIGhvcml6b250YWwvdmVydGljYWwgY3VzdG9tIGVsZW1lbnRzLlxyXG4gICAqIElmIHdlIGFkZCB0aGVzZSB0d28gdG8gcHJvcHNJbmNsdWRpbmdEZWZhdWx0cyB0aGVuIHdlIGFyZSBjaGFuZ2luZyBwdWJsaWMgQVBJLlxyXG4gICAqIE5vdCBhIGJhZCB0aGluZyBwZXIgc2UgYnV0IGFsc28gbm90IG5lY2Vzc2FyeS5cclxuICAgKi9cclxuICB2YXIgdmVydGljYWxDb29yZGluYXRlc0dlbmVyYXRvciA9IHByb3BzSW5jbHVkaW5nRGVmYXVsdHMudmVydGljYWxDb29yZGluYXRlc0dlbmVyYXRvciB8fCBkZWZhdWx0VmVydGljYWxDb29yZGluYXRlc0dlbmVyYXRvcjtcclxuICB2YXIgaG9yaXpvbnRhbENvb3JkaW5hdGVzR2VuZXJhdG9yID0gcHJvcHNJbmNsdWRpbmdEZWZhdWx0cy5ob3Jpem9udGFsQ29vcmRpbmF0ZXNHZW5lcmF0b3IgfHwgZGVmYXVsdEhvcml6b250YWxDb29yZGluYXRlc0dlbmVyYXRvcjtcclxuICB2YXIgaG9yaXpvbnRhbFBvaW50cyA9IHByb3BzSW5jbHVkaW5nRGVmYXVsdHMuaG9yaXpvbnRhbFBvaW50cyxcclxuICAgIHZlcnRpY2FsUG9pbnRzID0gcHJvcHNJbmNsdWRpbmdEZWZhdWx0cy52ZXJ0aWNhbFBvaW50cztcclxuXHJcbiAgLy8gTm8gaG9yaXpvbnRhbCBwb2ludHMgYXJlIHNwZWNpZmllZFxyXG4gIGlmICgoIWhvcml6b250YWxQb2ludHMgfHwgIWhvcml6b250YWxQb2ludHMubGVuZ3RoKSAmJiAoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShob3Jpem9udGFsQ29vcmRpbmF0ZXNHZW5lcmF0b3IpKSB7XHJcbiAgICB2YXIgaXNIb3Jpem9udGFsVmFsdWVzID0gaG9yaXpvbnRhbFZhbHVlcyAmJiBob3Jpem9udGFsVmFsdWVzLmxlbmd0aDtcclxuICAgIHZhciBnZW5lcmF0b3JSZXN1bHQgPSBob3Jpem9udGFsQ29vcmRpbmF0ZXNHZW5lcmF0b3Ioe1xyXG4gICAgICB5QXhpczogeUF4aXMgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHlBeGlzKSwge30sIHtcclxuICAgICAgICB0aWNrczogaXNIb3Jpem9udGFsVmFsdWVzID8gaG9yaXpvbnRhbFZhbHVlcyA6IHlBeGlzLnRpY2tzXHJcbiAgICAgIH0pIDogdW5kZWZpbmVkLFxyXG4gICAgICB3aWR0aDogY2hhcnRXaWR0aCxcclxuICAgICAgaGVpZ2h0OiBjaGFydEhlaWdodCxcclxuICAgICAgb2Zmc2V0OiBvZmZzZXRcclxuICAgIH0sIGlzSG9yaXpvbnRhbFZhbHVlcyA/IHRydWUgOiBzeW5jV2l0aFRpY2tzKTtcclxuICAgICgwLCBfTG9nVXRpbHMud2FybikoQXJyYXkuaXNBcnJheShnZW5lcmF0b3JSZXN1bHQpLCBcImhvcml6b250YWxDb29yZGluYXRlc0dlbmVyYXRvciBzaG91bGQgcmV0dXJuIEFycmF5IGJ1dCBpbnN0ZWFkIGl0IHJldHVybmVkIFtcIi5jb25jYXQoX3R5cGVvZihnZW5lcmF0b3JSZXN1bHQpLCBcIl1cIikpO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZ2VuZXJhdG9yUmVzdWx0KSkge1xyXG4gICAgICBob3Jpem9udGFsUG9pbnRzID0gZ2VuZXJhdG9yUmVzdWx0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTm8gdmVydGljYWwgcG9pbnRzIGFyZSBzcGVjaWZpZWRcclxuICBpZiAoKCF2ZXJ0aWNhbFBvaW50cyB8fCAhdmVydGljYWxQb2ludHMubGVuZ3RoKSAmJiAoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKSh2ZXJ0aWNhbENvb3JkaW5hdGVzR2VuZXJhdG9yKSkge1xyXG4gICAgdmFyIGlzVmVydGljYWxWYWx1ZXMgPSB2ZXJ0aWNhbFZhbHVlcyAmJiB2ZXJ0aWNhbFZhbHVlcy5sZW5ndGg7XHJcbiAgICB2YXIgX2dlbmVyYXRvclJlc3VsdCA9IHZlcnRpY2FsQ29vcmRpbmF0ZXNHZW5lcmF0b3Ioe1xyXG4gICAgICB4QXhpczogeEF4aXMgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHhBeGlzKSwge30sIHtcclxuICAgICAgICB0aWNrczogaXNWZXJ0aWNhbFZhbHVlcyA/IHZlcnRpY2FsVmFsdWVzIDogeEF4aXMudGlja3NcclxuICAgICAgfSkgOiB1bmRlZmluZWQsXHJcbiAgICAgIHdpZHRoOiBjaGFydFdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IGNoYXJ0SGVpZ2h0LFxyXG4gICAgICBvZmZzZXQ6IG9mZnNldFxyXG4gICAgfSwgaXNWZXJ0aWNhbFZhbHVlcyA/IHRydWUgOiBzeW5jV2l0aFRpY2tzKTtcclxuICAgICgwLCBfTG9nVXRpbHMud2FybikoQXJyYXkuaXNBcnJheShfZ2VuZXJhdG9yUmVzdWx0KSwgXCJ2ZXJ0aWNhbENvb3JkaW5hdGVzR2VuZXJhdG9yIHNob3VsZCByZXR1cm4gQXJyYXkgYnV0IGluc3RlYWQgaXQgcmV0dXJuZWQgW1wiLmNvbmNhdChfdHlwZW9mKF9nZW5lcmF0b3JSZXN1bHQpLCBcIl1cIikpO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoX2dlbmVyYXRvclJlc3VsdCkpIHtcclxuICAgICAgdmVydGljYWxQb2ludHMgPSBfZ2VuZXJhdG9yUmVzdWx0O1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImdcIiwge1xyXG4gICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWNhcnRlc2lhbi1ncmlkXCJcclxuICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KEJhY2tncm91bmQsIHtcclxuICAgIGZpbGw6IHByb3BzSW5jbHVkaW5nRGVmYXVsdHMuZmlsbCxcclxuICAgIGZpbGxPcGFjaXR5OiBwcm9wc0luY2x1ZGluZ0RlZmF1bHRzLmZpbGxPcGFjaXR5LFxyXG4gICAgeDogcHJvcHNJbmNsdWRpbmdEZWZhdWx0cy54LFxyXG4gICAgeTogcHJvcHNJbmNsdWRpbmdEZWZhdWx0cy55LFxyXG4gICAgd2lkdGg6IHByb3BzSW5jbHVkaW5nRGVmYXVsdHMud2lkdGgsXHJcbiAgICBoZWlnaHQ6IHByb3BzSW5jbHVkaW5nRGVmYXVsdHMuaGVpZ2h0LFxyXG4gICAgcnk6IHByb3BzSW5jbHVkaW5nRGVmYXVsdHMucnlcclxuICB9KSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChIb3Jpem9udGFsR3JpZExpbmVzLCBfZXh0ZW5kcyh7fSwgcHJvcHNJbmNsdWRpbmdEZWZhdWx0cywge1xyXG4gICAgb2Zmc2V0OiBvZmZzZXQsXHJcbiAgICBob3Jpem9udGFsUG9pbnRzOiBob3Jpem9udGFsUG9pbnRzLFxyXG4gICAgeEF4aXM6IHhBeGlzLFxyXG4gICAgeUF4aXM6IHlBeGlzXHJcbiAgfSkpLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFZlcnRpY2FsR3JpZExpbmVzLCBfZXh0ZW5kcyh7fSwgcHJvcHNJbmNsdWRpbmdEZWZhdWx0cywge1xyXG4gICAgb2Zmc2V0OiBvZmZzZXQsXHJcbiAgICB2ZXJ0aWNhbFBvaW50czogdmVydGljYWxQb2ludHMsXHJcbiAgICB4QXhpczogeEF4aXMsXHJcbiAgICB5QXhpczogeUF4aXNcclxuICB9KSksIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoSG9yaXpvbnRhbFN0cmlwZXMsIF9leHRlbmRzKHt9LCBwcm9wc0luY2x1ZGluZ0RlZmF1bHRzLCB7XHJcbiAgICBob3Jpem9udGFsUG9pbnRzOiBob3Jpem9udGFsUG9pbnRzXHJcbiAgfSkpLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFZlcnRpY2FsU3RyaXBlcywgX2V4dGVuZHMoe30sIHByb3BzSW5jbHVkaW5nRGVmYXVsdHMsIHtcclxuICAgIHZlcnRpY2FsUG9pbnRzOiB2ZXJ0aWNhbFBvaW50c1xyXG4gIH0pKSk7XHJcbn1cclxuQ2FydGVzaWFuR3JpZC5kaXNwbGF5TmFtZSA9ICdDYXJ0ZXNpYW5HcmlkJzsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDYXJ0ZXNpYW5HcmlkIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfaXNGdW5jdGlvbiIsIl9Mb2dVdGlscyIsIl9EYXRhVXRpbHMiLCJfUmVhY3RVdGlscyIsIl9DaGFydFV0aWxzIiwiX2dldFRpY2tzIiwiX0NhcnRlc2lhbkF4aXMiLCJfY2hhcnRMYXlvdXRDb250ZXh0IiwiX2V4Y2x1ZGVkIiwiX2V4Y2x1ZGVkMiIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwicHJvdG90eXBlIiwib3duS2V5cyIsImUiLCJyIiwidCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImtleSIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJpIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0Iiwic291cmNlIiwiaGFzT3duUHJvcGVydHkiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJleGNsdWRlZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwic291cmNlU3ltYm9sS2V5cyIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIkJhY2tncm91bmQiLCJwcm9wcyIsImZpbGwiLCJmaWxsT3BhY2l0eSIsIngiLCJ5Iiwid2lkdGgiLCJoZWlnaHQiLCJyeSIsImNyZWF0ZUVsZW1lbnQiLCJzdHJva2UiLCJjbGFzc05hbWUiLCJyZW5kZXJMaW5lSXRlbSIsIm9wdGlvbiIsImxpbmVJdGVtIiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJ4MSIsInkxIiwieDIiLCJ5MiIsIm90aGVycyIsIl9maWx0ZXJQcm9wcyIsImZpbHRlclByb3BzIiwiX18iLCJvZmZzZXQiLCJyZXN0T2ZGaWx0ZXJlZFByb3BzIiwiSG9yaXpvbnRhbEdyaWRMaW5lcyIsIl9wcm9wcyRob3Jpem9udGFsIiwiaG9yaXpvbnRhbCIsImhvcml6b250YWxQb2ludHMiLCJpdGVtcyIsIm1hcCIsImVudHJ5IiwibGluZUl0ZW1Qcm9wcyIsImNvbmNhdCIsImluZGV4IiwiVmVydGljYWxHcmlkTGluZXMiLCJfcHJvcHMkdmVydGljYWwiLCJ2ZXJ0aWNhbCIsInZlcnRpY2FsUG9pbnRzIiwiSG9yaXpvbnRhbFN0cmlwZXMiLCJob3Jpem9udGFsRmlsbCIsIl9wcm9wcyRob3Jpem9udGFsMiIsInJvdW5kZWRTb3J0ZWRIb3Jpem9udGFsUG9pbnRzIiwiTWF0aCIsInJvdW5kIiwic29ydCIsImEiLCJiIiwidW5zaGlmdCIsImxhc3RTdHJpcGUiLCJsaW5lSGVpZ2h0IiwiY29sb3JJbmRleCIsIlZlcnRpY2FsU3RyaXBlcyIsIl9wcm9wcyR2ZXJ0aWNhbDIiLCJ2ZXJ0aWNhbEZpbGwiLCJyb3VuZGVkU29ydGVkVmVydGljYWxQb2ludHMiLCJsaW5lV2lkdGgiLCJkZWZhdWx0VmVydGljYWxDb29yZGluYXRlc0dlbmVyYXRvciIsIl9yZWYiLCJzeW5jV2l0aFRpY2tzIiwieEF4aXMiLCJnZXRDb29yZGluYXRlc09mR3JpZCIsImdldFRpY2tzIiwiQ2FydGVzaWFuQXhpcyIsImRlZmF1bHRQcm9wcyIsInRpY2tzIiwiZ2V0VGlja3NPZkF4aXMiLCJ2aWV3Qm94IiwibGVmdCIsImRlZmF1bHRIb3Jpem9udGFsQ29vcmRpbmF0ZXNHZW5lcmF0b3IiLCJfcmVmMiIsInlBeGlzIiwidG9wIiwiX3Byb3BzJHN0cm9rZSIsIl9wcm9wcyRmaWxsIiwiX3Byb3BzJGhvcml6b250YWwzIiwiX3Byb3BzJGhvcml6b250YWxGaWxsIiwiX3Byb3BzJHZlcnRpY2FsMyIsIl9wcm9wcyR2ZXJ0aWNhbEZpbGwiLCJjaGFydFdpZHRoIiwidXNlQ2hhcnRXaWR0aCIsImNoYXJ0SGVpZ2h0IiwidXNlQ2hhcnRIZWlnaHQiLCJ1c2VPZmZzZXQiLCJwcm9wc0luY2x1ZGluZ0RlZmF1bHRzIiwiaXNOdW1iZXIiLCJob3Jpem9udGFsVmFsdWVzIiwidmVydGljYWxWYWx1ZXMiLCJ1c2VBcmJpdHJhcnlYQXhpcyIsInVzZVlBeGlzV2l0aEZpbml0ZURvbWFpbk9yUmFuZG9tIiwidmVydGljYWxDb29yZGluYXRlc0dlbmVyYXRvciIsImhvcml6b250YWxDb29yZGluYXRlc0dlbmVyYXRvciIsImlzSG9yaXpvbnRhbFZhbHVlcyIsImdlbmVyYXRvclJlc3VsdCIsInVuZGVmaW5lZCIsIndhcm4iLCJBcnJheSIsImlzQXJyYXkiLCJpc1ZlcnRpY2FsVmFsdWVzIiwiX2dlbmVyYXRvclJlc3VsdCIsImRpc3BsYXlOYW1lIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/cartesian/CartesianGrid.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/cartesian/ErrorBar.js":
/*!*********************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/ErrorBar.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ErrorBar = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _tinyInvariant = _interopRequireDefault(__webpack_require__(/*! tiny-invariant */ \"tiny-invariant\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"offset\",\n    \"layout\",\n    \"width\",\n    \"dataKey\",\n    \"data\",\n    \"dataPointFormatter\",\n    \"xAxis\",\n    \"yAxis\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Render a group of error bar\r\n */ \n// eslint-disable-next-line react/prefer-stateless-function -- requires static defaultProps\nvar ErrorBar = exports.ErrorBar = /*#__PURE__*/ function(_React$Component) {\n    function ErrorBar() {\n        _classCallCheck(this, ErrorBar);\n        return _callSuper(this, ErrorBar, arguments);\n    }\n    _inherits(ErrorBar, _React$Component);\n    return _createClass(ErrorBar, [\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props = this.props, offset = _this$props.offset, layout = _this$props.layout, width = _this$props.width, dataKey = _this$props.dataKey, data = _this$props.data, dataPointFormatter = _this$props.dataPointFormatter, xAxis = _this$props.xAxis, yAxis = _this$props.yAxis, others = _objectWithoutProperties(_this$props, _excluded);\n                var svgProps = (0, _ReactUtils.filterProps)(others, false);\n                !!(this.props.direction === 'x' && xAxis.type !== 'number') ?  true ? (0, _tinyInvariant[\"default\"])(false, 'ErrorBar requires Axis type property to be \"number\".') : 0 : void 0;\n                var errorBars = data.map(function(entry) {\n                    var _dataPointFormatter = dataPointFormatter(entry, dataKey), x = _dataPointFormatter.x, y = _dataPointFormatter.y, value = _dataPointFormatter.value, errorVal = _dataPointFormatter.errorVal;\n                    if (!errorVal) {\n                        return null;\n                    }\n                    var lineCoordinates = [];\n                    var lowBound, highBound;\n                    if (Array.isArray(errorVal)) {\n                        var _errorVal = _slicedToArray(errorVal, 2);\n                        lowBound = _errorVal[0];\n                        highBound = _errorVal[1];\n                    } else {\n                        lowBound = highBound = errorVal;\n                    }\n                    if (layout === 'vertical') {\n                        // error bar for horizontal charts, the y is fixed, x is a range value\n                        var scale = xAxis.scale;\n                        var yMid = y + offset;\n                        var yMin = yMid + width;\n                        var yMax = yMid - width;\n                        var xMin = scale(value - lowBound);\n                        var xMax = scale(value + highBound);\n                        // the right line of |--|\n                        lineCoordinates.push({\n                            x1: xMax,\n                            y1: yMin,\n                            x2: xMax,\n                            y2: yMax\n                        });\n                        // the middle line of |--|\n                        lineCoordinates.push({\n                            x1: xMin,\n                            y1: yMid,\n                            x2: xMax,\n                            y2: yMid\n                        });\n                        // the left line of |--|\n                        lineCoordinates.push({\n                            x1: xMin,\n                            y1: yMin,\n                            x2: xMin,\n                            y2: yMax\n                        });\n                    } else if (layout === 'horizontal') {\n                        // error bar for horizontal charts, the x is fixed, y is a range value\n                        var _scale = yAxis.scale;\n                        var xMid = x + offset;\n                        var _xMin = xMid - width;\n                        var _xMax = xMid + width;\n                        var _yMin = _scale(value - lowBound);\n                        var _yMax = _scale(value + highBound);\n                        // the top line\n                        lineCoordinates.push({\n                            x1: _xMin,\n                            y1: _yMax,\n                            x2: _xMax,\n                            y2: _yMax\n                        });\n                        // the middle line\n                        lineCoordinates.push({\n                            x1: xMid,\n                            y1: _yMin,\n                            x2: xMid,\n                            y2: _yMax\n                        });\n                        // the bottom line\n                        lineCoordinates.push({\n                            x1: _xMin,\n                            y1: _yMin,\n                            x2: _xMax,\n                            y2: _yMin\n                        });\n                    }\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                        className: \"recharts-errorBar\",\n                        key: \"bar-\".concat(lineCoordinates.map(function(c) {\n                            return \"\".concat(c.x1, \"-\").concat(c.x2, \"-\").concat(c.y1, \"-\").concat(c.y2);\n                        }))\n                    }, svgProps), lineCoordinates.map(function(coordinates) {\n                        return /*#__PURE__*/ _react[\"default\"].createElement(\"line\", _extends({}, coordinates, {\n                            key: \"line-\".concat(coordinates.x1, \"-\").concat(coordinates.x2, \"-\").concat(coordinates.y1, \"-\").concat(coordinates.y2)\n                        }));\n                    }));\n                });\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-errorBars\"\n                }, errorBars);\n            }\n        }\n    ]);\n}(_react[\"default\"].Component);\n_defineProperty(ErrorBar, \"defaultProps\", {\n    stroke: 'black',\n    strokeWidth: 1.5,\n    width: 5,\n    offset: 0,\n    layout: 'horizontal'\n});\n_defineProperty(ErrorBar, \"displayName\", 'ErrorBar');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2FydGVzaWFuL0Vycm9yQmFyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxnQkFBZ0IsR0FBRyxLQUFLO0FBQ3hCLElBQUlHLFNBQVNDLHVCQUF1QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDbkQsSUFBSUMsaUJBQWlCRix1QkFBdUJDLG1CQUFPQSxDQUFDLHNDQUFnQjtBQUNwRSxJQUFJRSxTQUFTRixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDekMsSUFBSUcsY0FBY0gsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlJLFlBQVk7SUFBQztJQUFVO0lBQVU7SUFBUztJQUFXO0lBQVE7SUFBc0I7SUFBUztDQUFRO0FBQ3hHLFNBQVNMLHVCQUF1Qk0sR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRSxXQUFXLEtBQUtDLFVBQVVELE1BQU1DLE9BQU9FLFNBQVMsR0FBRyxXQUFXLE9BQU9IO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSTtJQUFhQSxXQUFXbkIsT0FBT29CLE1BQU0sR0FBR3BCLE9BQU9vQixNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVQyxNQUFNO1FBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUFFLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZ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Z0osYUFBYSxDQUFDNUksT0FBTzZJLEtBQUssRUFBRTtvQkFDaEVDLFdBQVc7Z0JBQ2IsR0FBRzdCO1lBQ0w7UUFDRjtLQUFFO0FBQ0osRUFBRXJILE1BQU0sQ0FBQyxVQUFVLENBQUNzSixTQUFTO0FBQzdCdkQsZ0JBQWdCaEcsVUFBVSxnQkFBZ0I7SUFDeEN3SixRQUFRO0lBQ1JDLGFBQWE7SUFDYi9DLE9BQU87SUFDUEYsUUFBUTtJQUNSQyxRQUFRO0FBQ1Y7QUFDQVQsZ0JBQWdCaEcsVUFBVSxlQUFlIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxjYXJ0ZXNpYW5cXEVycm9yQmFyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuRXJyb3JCYXIgPSB2b2lkIDA7XHJcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBfdGlueUludmFyaWFudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInRpbnktaW52YXJpYW50XCIpKTtcclxudmFyIF9MYXllciA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvTGF5ZXJcIik7XHJcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XHJcbnZhciBfZXhjbHVkZWQgPSBbXCJvZmZzZXRcIiwgXCJsYXlvdXRcIiwgXCJ3aWR0aFwiLCBcImRhdGFLZXlcIiwgXCJkYXRhXCIsIFwiZGF0YVBvaW50Rm9ybWF0dGVyXCIsIFwieEF4aXNcIiwgXCJ5QXhpc1wiXTtcclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XHJcbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cclxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XHJcbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XHJcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cclxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XHJcbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XHJcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxyXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxyXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxyXG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxyXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cclxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XHJcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxyXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxyXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxyXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxyXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XHJcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxyXG4gKiBAZmlsZU92ZXJ2aWV3IFJlbmRlciBhIGdyb3VwIG9mIGVycm9yIGJhclxyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L3ByZWZlci1zdGF0ZWxlc3MtZnVuY3Rpb24gLS0gcmVxdWlyZXMgc3RhdGljIGRlZmF1bHRQcm9wc1xyXG52YXIgRXJyb3JCYXIgPSBleHBvcnRzLkVycm9yQmFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XHJcbiAgZnVuY3Rpb24gRXJyb3JCYXIoKSB7XHJcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXJyb3JCYXIpO1xyXG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgRXJyb3JCYXIsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG4gIF9pbmhlcml0cyhFcnJvckJhciwgX1JlYWN0JENvbXBvbmVudCk7XHJcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFcnJvckJhciwgW3tcclxuICAgIGtleTogXCJyZW5kZXJcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgb2Zmc2V0ID0gX3RoaXMkcHJvcHMub2Zmc2V0LFxyXG4gICAgICAgIGxheW91dCA9IF90aGlzJHByb3BzLmxheW91dCxcclxuICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzLndpZHRoLFxyXG4gICAgICAgIGRhdGFLZXkgPSBfdGhpcyRwcm9wcy5kYXRhS2V5LFxyXG4gICAgICAgIGRhdGEgPSBfdGhpcyRwcm9wcy5kYXRhLFxyXG4gICAgICAgIGRhdGFQb2ludEZvcm1hdHRlciA9IF90aGlzJHByb3BzLmRhdGFQb2ludEZvcm1hdHRlcixcclxuICAgICAgICB4QXhpcyA9IF90aGlzJHByb3BzLnhBeGlzLFxyXG4gICAgICAgIHlBeGlzID0gX3RoaXMkcHJvcHMueUF4aXMsXHJcbiAgICAgICAgb3RoZXJzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzLCBfZXhjbHVkZWQpO1xyXG4gICAgICB2YXIgc3ZnUHJvcHMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKG90aGVycywgZmFsc2UpO1xyXG4gICAgICAhISh0aGlzLnByb3BzLmRpcmVjdGlvbiA9PT0gJ3gnICYmIHhBeGlzLnR5cGUgIT09ICdudW1iZXInKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/ICgwLCBfdGlueUludmFyaWFudFtcImRlZmF1bHRcIl0pKGZhbHNlLCAnRXJyb3JCYXIgcmVxdWlyZXMgQXhpcyB0eXBlIHByb3BlcnR5IHRvIGJlIFwibnVtYmVyXCIuJykgOiAoMCwgX3RpbnlJbnZhcmlhbnRbXCJkZWZhdWx0XCJdKShmYWxzZSkgOiB2b2lkIDA7XHJcbiAgICAgIHZhciBlcnJvckJhcnMgPSBkYXRhLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICB2YXIgX2RhdGFQb2ludEZvcm1hdHRlciA9IGRhdGFQb2ludEZvcm1hdHRlcihlbnRyeSwgZGF0YUtleSksXHJcbiAgICAgICAgICB4ID0gX2RhdGFQb2ludEZvcm1hdHRlci54LFxyXG4gICAgICAgICAgeSA9IF9kYXRhUG9pbnRGb3JtYXR0ZXIueSxcclxuICAgICAgICAgIHZhbHVlID0gX2RhdGFQb2ludEZvcm1hdHRlci52YWx1ZSxcclxuICAgICAgICAgIGVycm9yVmFsID0gX2RhdGFQb2ludEZvcm1hdHRlci5lcnJvclZhbDtcclxuICAgICAgICBpZiAoIWVycm9yVmFsKSB7XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxpbmVDb29yZGluYXRlcyA9IFtdO1xyXG4gICAgICAgIHZhciBsb3dCb3VuZCwgaGlnaEJvdW5kO1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVycm9yVmFsKSkge1xyXG4gICAgICAgICAgdmFyIF9lcnJvclZhbCA9IF9zbGljZWRUb0FycmF5KGVycm9yVmFsLCAyKTtcclxuICAgICAgICAgIGxvd0JvdW5kID0gX2Vycm9yVmFsWzBdO1xyXG4gICAgICAgICAgaGlnaEJvdW5kID0gX2Vycm9yVmFsWzFdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBsb3dCb3VuZCA9IGhpZ2hCb3VuZCA9IGVycm9yVmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGF5b3V0ID09PSAndmVydGljYWwnKSB7XHJcbiAgICAgICAgICAvLyBlcnJvciBiYXIgZm9yIGhvcml6b250YWwgY2hhcnRzLCB0aGUgeSBpcyBmaXhlZCwgeCBpcyBhIHJhbmdlIHZhbHVlXHJcbiAgICAgICAgICB2YXIgc2NhbGUgPSB4QXhpcy5zY2FsZTtcclxuICAgICAgICAgIHZhciB5TWlkID0geSArIG9mZnNldDtcclxuICAgICAgICAgIHZhciB5TWluID0geU1pZCArIHdpZHRoO1xyXG4gICAgICAgICAgdmFyIHlNYXggPSB5TWlkIC0gd2lkdGg7XHJcbiAgICAgICAgICB2YXIgeE1pbiA9IHNjYWxlKHZhbHVlIC0gbG93Qm91bmQpO1xyXG4gICAgICAgICAgdmFyIHhNYXggPSBzY2FsZSh2YWx1ZSArIGhpZ2hCb3VuZCk7XHJcblxyXG4gICAgICAgICAgLy8gdGhlIHJpZ2h0IGxpbmUgb2YgfC0tfFxyXG4gICAgICAgICAgbGluZUNvb3JkaW5hdGVzLnB1c2goe1xyXG4gICAgICAgICAgICB4MTogeE1heCxcclxuICAgICAgICAgICAgeTE6IHlNaW4sXHJcbiAgICAgICAgICAgIHgyOiB4TWF4LFxyXG4gICAgICAgICAgICB5MjogeU1heFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICAvLyB0aGUgbWlkZGxlIGxpbmUgb2YgfC0tfFxyXG4gICAgICAgICAgbGluZUNvb3JkaW5hdGVzLnB1c2goe1xyXG4gICAgICAgICAgICB4MTogeE1pbixcclxuICAgICAgICAgICAgeTE6IHlNaWQsXHJcbiAgICAgICAgICAgIHgyOiB4TWF4LFxyXG4gICAgICAgICAgICB5MjogeU1pZFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICAvLyB0aGUgbGVmdCBsaW5lIG9mIHwtLXxcclxuICAgICAgICAgIGxpbmVDb29yZGluYXRlcy5wdXNoKHtcclxuICAgICAgICAgICAgeDE6IHhNaW4sXHJcbiAgICAgICAgICAgIHkxOiB5TWluLFxyXG4gICAgICAgICAgICB4MjogeE1pbixcclxuICAgICAgICAgICAgeTI6IHlNYXhcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobGF5b3V0ID09PSAnaG9yaXpvbnRhbCcpIHtcclxuICAgICAgICAgIC8vIGVycm9yIGJhciBmb3IgaG9yaXpvbnRhbCBjaGFydHMsIHRoZSB4IGlzIGZpeGVkLCB5IGlzIGEgcmFuZ2UgdmFsdWVcclxuICAgICAgICAgIHZhciBfc2NhbGUgPSB5QXhpcy5zY2FsZTtcclxuICAgICAgICAgIHZhciB4TWlkID0geCArIG9mZnNldDtcclxuICAgICAgICAgIHZhciBfeE1pbiA9IHhNaWQgLSB3aWR0aDtcclxuICAgICAgICAgIHZhciBfeE1heCA9IHhNaWQgKyB3aWR0aDtcclxuICAgICAgICAgIHZhciBfeU1pbiA9IF9zY2FsZSh2YWx1ZSAtIGxvd0JvdW5kKTtcclxuICAgICAgICAgIHZhciBfeU1heCA9IF9zY2FsZSh2YWx1ZSArIGhpZ2hCb3VuZCk7XHJcblxyXG4gICAgICAgICAgLy8gdGhlIHRvcCBsaW5lXHJcbiAgICAgICAgICBsaW5lQ29vcmRpbmF0ZXMucHVzaCh7XHJcbiAgICAgICAgICAgIHgxOiBfeE1pbixcclxuICAgICAgICAgICAgeTE6IF95TWF4LFxyXG4gICAgICAgICAgICB4MjogX3hNYXgsXHJcbiAgICAgICAgICAgIHkyOiBfeU1heFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICAvLyB0aGUgbWlkZGxlIGxpbmVcclxuICAgICAgICAgIGxpbmVDb29yZGluYXRlcy5wdXNoKHtcclxuICAgICAgICAgICAgeDE6IHhNaWQsXHJcbiAgICAgICAgICAgIHkxOiBfeU1pbixcclxuICAgICAgICAgICAgeDI6IHhNaWQsXHJcbiAgICAgICAgICAgIHkyOiBfeU1heFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICAvLyB0aGUgYm90dG9tIGxpbmVcclxuICAgICAgICAgIGxpbmVDb29yZGluYXRlcy5wdXNoKHtcclxuICAgICAgICAgICAgeDE6IF94TWluLFxyXG4gICAgICAgICAgICB5MTogX3lNaW4sXHJcbiAgICAgICAgICAgIHgyOiBfeE1heCxcclxuICAgICAgICAgICAgeTI6IF95TWluXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCBfZXh0ZW5kcyh7XHJcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtZXJyb3JCYXJcIixcclxuICAgICAgICAgIGtleTogXCJiYXItXCIuY29uY2F0KGxpbmVDb29yZGluYXRlcy5tYXAoZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGMueDEsIFwiLVwiKS5jb25jYXQoYy54MiwgXCItXCIpLmNvbmNhdChjLnkxLCBcIi1cIikuY29uY2F0KGMueTIpO1xyXG4gICAgICAgICAgfSkpXHJcbiAgICAgICAgfSwgc3ZnUHJvcHMpLCBsaW5lQ29vcmRpbmF0ZXMubWFwKGZ1bmN0aW9uIChjb29yZGluYXRlcykge1xyXG4gICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIF9leHRlbmRzKHt9LCBjb29yZGluYXRlcywge1xyXG4gICAgICAgICAgICBrZXk6IFwibGluZS1cIi5jb25jYXQoY29vcmRpbmF0ZXMueDEsIFwiLVwiKS5jb25jYXQoY29vcmRpbmF0ZXMueDIsIFwiLVwiKS5jb25jYXQoY29vcmRpbmF0ZXMueTEsIFwiLVwiKS5jb25jYXQoY29vcmRpbmF0ZXMueTIpXHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWVycm9yQmFyc1wiXHJcbiAgICAgIH0sIGVycm9yQmFycyk7XHJcbiAgICB9XHJcbiAgfV0pO1xyXG59KF9yZWFjdFtcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcclxuX2RlZmluZVByb3BlcnR5KEVycm9yQmFyLCBcImRlZmF1bHRQcm9wc1wiLCB7XHJcbiAgc3Ryb2tlOiAnYmxhY2snLFxyXG4gIHN0cm9rZVdpZHRoOiAxLjUsXHJcbiAgd2lkdGg6IDUsXHJcbiAgb2Zmc2V0OiAwLFxyXG4gIGxheW91dDogJ2hvcml6b250YWwnXHJcbn0pO1xyXG5fZGVmaW5lUHJvcGVydHkoRXJyb3JCYXIsIFwiZGlzcGxheU5hbWVcIiwgJ0Vycm9yQmFyJyk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRXJyb3JCYXIiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl90aW55SW52YXJpYW50IiwiX0xheWVyIiwiX1JlYWN0VXRpbHMiLCJfZXhjbHVkZWQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIlR5cGVFcnJvciIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwibiIsInRvU3RyaW5nIiwic2xpY2UiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsImxlbiIsImFycjIiLCJyIiwibCIsInQiLCJlIiwidSIsImEiLCJmIiwibmV4dCIsImRvbmUiLCJwdXNoIiwiaXNBcnJheSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsImV4Y2x1ZGVkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzb3VyY2VTeW1ib2xLZXlzIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2FsbFN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJCb29sZWFuIiwidmFsdWVPZiIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwiX2RlZmluZVByb3BlcnR5IiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJfUmVhY3QkQ29tcG9uZW50IiwicmVuZGVyIiwiX3RoaXMkcHJvcHMiLCJvZmZzZXQiLCJsYXlvdXQiLCJ3aWR0aCIsImRhdGFLZXkiLCJkYXRhIiwiZGF0YVBvaW50Rm9ybWF0dGVyIiwieEF4aXMiLCJ5QXhpcyIsIm90aGVycyIsInN2Z1Byb3BzIiwiZmlsdGVyUHJvcHMiLCJkaXJlY3Rpb24iLCJ0eXBlIiwicHJvY2VzcyIsImVycm9yQmFycyIsIm1hcCIsImVudHJ5IiwiX2RhdGFQb2ludEZvcm1hdHRlciIsIngiLCJ5IiwiZXJyb3JWYWwiLCJsaW5lQ29vcmRpbmF0ZXMiLCJsb3dCb3VuZCIsImhpZ2hCb3VuZCIsIl9lcnJvclZhbCIsInNjYWxlIiwieU1pZCIsInlNaW4iLCJ5TWF4IiwieE1pbiIsInhNYXgiLCJ4MSIsInkxIiwieDIiLCJ5MiIsIl9zY2FsZSIsInhNaWQiLCJfeE1pbiIsIl94TWF4IiwiX3lNaW4iLCJfeU1heCIsImNyZWF0ZUVsZW1lbnQiLCJMYXllciIsImNsYXNzTmFtZSIsImNvbmNhdCIsImMiLCJjb29yZGluYXRlcyIsIkNvbXBvbmVudCIsInN0cm9rZSIsInN0cm9rZVdpZHRoIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/cartesian/ErrorBar.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/cartesian/Line.js":
/*!*****************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/Line.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Line = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _isEqual = _interopRequireDefault(__webpack_require__(/*! lodash/isEqual */ \"lodash/isEqual\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _Curve = __webpack_require__(/*! ../shape/Curve */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Curve.js\");\nvar _Dot = __webpack_require__(/*! ../shape/Dot */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Dot.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _LabelList = __webpack_require__(/*! ../component/LabelList */ \"(pages-dir-node)/./node_modules/recharts/lib/component/LabelList.js\");\nvar _ErrorBar = __webpack_require__(/*! ./ErrorBar */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/ErrorBar.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"(pages-dir-node)/./node_modules/recharts/lib/util/Global.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _excluded = [\n    \"type\",\n    \"layout\",\n    \"connectNulls\",\n    \"ref\"\n], _excluded2 = [\n    \"key\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Line\r\n */ \nvar Line = exports.Line = /*#__PURE__*/ function(_PureComponent) {\n    function Line() {\n        var _this;\n        _classCallCheck(this, Line);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, Line, [].concat(args));\n        _defineProperty(_this, \"state\", {\n            isAnimationFinished: true,\n            totalLength: 0\n        });\n        _defineProperty(_this, \"generateSimpleStrokeDasharray\", function(totalLength, length) {\n            return \"\".concat(length, \"px \").concat(totalLength - length, \"px\");\n        });\n        _defineProperty(_this, \"getStrokeDasharray\", function(length, totalLength, lines) {\n            var lineLength = lines.reduce(function(pre, next) {\n                return pre + next;\n            });\n            // if lineLength is 0 return the default when no strokeDasharray is provided\n            if (!lineLength) {\n                return _this.generateSimpleStrokeDasharray(totalLength, length);\n            }\n            var count = Math.floor(length / lineLength);\n            var remainLength = length % lineLength;\n            var restLength = totalLength - length;\n            var remainLines = [];\n            for(var i = 0, sum = 0; i < lines.length; sum += lines[i], ++i){\n                if (sum + lines[i] > remainLength) {\n                    remainLines = [].concat(_toConsumableArray(lines.slice(0, i)), [\n                        remainLength - sum\n                    ]);\n                    break;\n                }\n            }\n            var emptyLines = remainLines.length % 2 === 0 ? [\n                0,\n                restLength\n            ] : [\n                restLength\n            ];\n            return [].concat(_toConsumableArray(Line.repeat(lines, count)), _toConsumableArray(remainLines), emptyLines).map(function(line) {\n                return \"\".concat(line, \"px\");\n            }).join(', ');\n        });\n        _defineProperty(_this, \"id\", (0, _DataUtils.uniqueId)('recharts-line-'));\n        _defineProperty(_this, \"pathRef\", function(node) {\n            _this.mainCurve = node;\n        });\n        _defineProperty(_this, \"handleAnimationEnd\", function() {\n            _this.setState({\n                isAnimationFinished: true\n            });\n            if (_this.props.onAnimationEnd) {\n                _this.props.onAnimationEnd();\n            }\n        });\n        _defineProperty(_this, \"handleAnimationStart\", function() {\n            _this.setState({\n                isAnimationFinished: false\n            });\n            if (_this.props.onAnimationStart) {\n                _this.props.onAnimationStart();\n            }\n        });\n        return _this;\n    }\n    _inherits(Line, _PureComponent);\n    return _createClass(Line, [\n        {\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n                if (!this.props.isAnimationActive) {\n                    return;\n                }\n                var totalLength = this.getTotalLength();\n                this.setState({\n                    totalLength: totalLength\n                });\n            }\n        },\n        {\n            key: \"componentDidUpdate\",\n            value: function componentDidUpdate() {\n                if (!this.props.isAnimationActive) {\n                    return;\n                }\n                var totalLength = this.getTotalLength();\n                if (totalLength !== this.state.totalLength) {\n                    this.setState({\n                        totalLength: totalLength\n                    });\n                }\n            }\n        },\n        {\n            key: \"getTotalLength\",\n            value: function getTotalLength() {\n                var curveDom = this.mainCurve;\n                try {\n                    return curveDom && curveDom.getTotalLength && curveDom.getTotalLength() || 0;\n                } catch (err) {\n                    return 0;\n                }\n            }\n        },\n        {\n            key: \"renderErrorBar\",\n            value: function renderErrorBar(needClip, clipPathId) {\n                if (this.props.isAnimationActive && !this.state.isAnimationFinished) {\n                    return null;\n                }\n                var _this$props = this.props, points = _this$props.points, xAxis = _this$props.xAxis, yAxis = _this$props.yAxis, layout = _this$props.layout, children = _this$props.children;\n                var errorBarItems = (0, _ReactUtils.findAllByType)(children, _ErrorBar.ErrorBar);\n                if (!errorBarItems) {\n                    return null;\n                }\n                var dataPointFormatter = function dataPointFormatter(dataPoint, dataKey) {\n                    return {\n                        x: dataPoint.x,\n                        y: dataPoint.y,\n                        value: dataPoint.value,\n                        errorVal: (0, _ChartUtils.getValueByDataKey)(dataPoint.payload, dataKey)\n                    };\n                };\n                var errorBarProps = {\n                    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : null\n                };\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, errorBarProps, errorBarItems.map(function(item) {\n                    return /*#__PURE__*/ _react[\"default\"].cloneElement(item, {\n                        key: \"bar-\".concat(item.props.dataKey),\n                        data: points,\n                        xAxis: xAxis,\n                        yAxis: yAxis,\n                        layout: layout,\n                        dataPointFormatter: dataPointFormatter\n                    });\n                }));\n            }\n        },\n        {\n            key: \"renderDots\",\n            value: function renderDots(needClip, clipDot, clipPathId) {\n                var isAnimationActive = this.props.isAnimationActive;\n                if (isAnimationActive && !this.state.isAnimationFinished) {\n                    return null;\n                }\n                var _this$props2 = this.props, dot = _this$props2.dot, points = _this$props2.points, dataKey = _this$props2.dataKey;\n                var lineProps = (0, _ReactUtils.filterProps)(this.props, false);\n                var customDotProps = (0, _ReactUtils.filterProps)(dot, true);\n                var dots = points.map(function(entry, i) {\n                    var dotProps = _objectSpread(_objectSpread(_objectSpread({\n                        key: \"dot-\".concat(i),\n                        r: 3\n                    }, lineProps), customDotProps), {}, {\n                        index: i,\n                        cx: entry.x,\n                        cy: entry.y,\n                        value: entry.value,\n                        dataKey: dataKey,\n                        payload: entry.payload,\n                        points: points\n                    });\n                    return Line.renderDotItem(dot, dotProps);\n                });\n                var dotsProps = {\n                    clipPath: needClip ? \"url(#clipPath-\".concat(clipDot ? '' : 'dots-').concat(clipPathId, \")\") : null\n                };\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                    className: \"recharts-line-dots\",\n                    key: \"dots\"\n                }, dotsProps), dots);\n            }\n        },\n        {\n            key: \"renderCurveStatically\",\n            value: function renderCurveStatically(points, needClip, clipPathId, props) {\n                var _this$props3 = this.props, type = _this$props3.type, layout = _this$props3.layout, connectNulls = _this$props3.connectNulls, ref = _this$props3.ref, others = _objectWithoutProperties(_this$props3, _excluded);\n                var curveProps = _objectSpread(_objectSpread(_objectSpread({}, (0, _ReactUtils.filterProps)(others, true)), {}, {\n                    fill: 'none',\n                    className: 'recharts-line-curve',\n                    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : null,\n                    points: points\n                }, props), {}, {\n                    type: type,\n                    layout: layout,\n                    connectNulls: connectNulls\n                });\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Curve.Curve, _extends({}, curveProps, {\n                    pathRef: this.pathRef\n                }));\n            }\n        },\n        {\n            key: \"renderCurveWithAnimation\",\n            value: function renderCurveWithAnimation(needClip, clipPathId) {\n                var _this2 = this;\n                var _this$props4 = this.props, points = _this$props4.points, strokeDasharray = _this$props4.strokeDasharray, isAnimationActive = _this$props4.isAnimationActive, animationBegin = _this$props4.animationBegin, animationDuration = _this$props4.animationDuration, animationEasing = _this$props4.animationEasing, animationId = _this$props4.animationId, animateNewValues = _this$props4.animateNewValues, width = _this$props4.width, height = _this$props4.height;\n                var _this$state = this.state, prevPoints = _this$state.prevPoints, totalLength = _this$state.totalLength;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n                    begin: animationBegin,\n                    duration: animationDuration,\n                    isActive: isAnimationActive,\n                    easing: animationEasing,\n                    from: {\n                        t: 0\n                    },\n                    to: {\n                        t: 1\n                    },\n                    key: \"line-\".concat(animationId),\n                    onAnimationEnd: this.handleAnimationEnd,\n                    onAnimationStart: this.handleAnimationStart\n                }, function(_ref) {\n                    var t = _ref.t;\n                    if (prevPoints) {\n                        var prevPointsDiffFactor = prevPoints.length / points.length;\n                        var stepData = points.map(function(entry, index) {\n                            var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n                            if (prevPoints[prevPointIndex]) {\n                                var prev = prevPoints[prevPointIndex];\n                                var interpolatorX = (0, _DataUtils.interpolateNumber)(prev.x, entry.x);\n                                var interpolatorY = (0, _DataUtils.interpolateNumber)(prev.y, entry.y);\n                                return _objectSpread(_objectSpread({}, entry), {}, {\n                                    x: interpolatorX(t),\n                                    y: interpolatorY(t)\n                                });\n                            }\n                            // magic number of faking previous x and y location\n                            if (animateNewValues) {\n                                var _interpolatorX = (0, _DataUtils.interpolateNumber)(width * 2, entry.x);\n                                var _interpolatorY = (0, _DataUtils.interpolateNumber)(height / 2, entry.y);\n                                return _objectSpread(_objectSpread({}, entry), {}, {\n                                    x: _interpolatorX(t),\n                                    y: _interpolatorY(t)\n                                });\n                            }\n                            return _objectSpread(_objectSpread({}, entry), {}, {\n                                x: entry.x,\n                                y: entry.y\n                            });\n                        });\n                        return _this2.renderCurveStatically(stepData, needClip, clipPathId);\n                    }\n                    var interpolator = (0, _DataUtils.interpolateNumber)(0, totalLength);\n                    var curLength = interpolator(t);\n                    var currentStrokeDasharray;\n                    if (strokeDasharray) {\n                        var lines = \"\".concat(strokeDasharray).split(/[,\\s]+/gim).map(function(num) {\n                            return parseFloat(num);\n                        });\n                        currentStrokeDasharray = _this2.getStrokeDasharray(curLength, totalLength, lines);\n                    } else {\n                        currentStrokeDasharray = _this2.generateSimpleStrokeDasharray(totalLength, curLength);\n                    }\n                    return _this2.renderCurveStatically(points, needClip, clipPathId, {\n                        strokeDasharray: currentStrokeDasharray\n                    });\n                });\n            }\n        },\n        {\n            key: \"renderCurve\",\n            value: function renderCurve(needClip, clipPathId) {\n                var _this$props5 = this.props, points = _this$props5.points, isAnimationActive = _this$props5.isAnimationActive;\n                var _this$state2 = this.state, prevPoints = _this$state2.prevPoints, totalLength = _this$state2.totalLength;\n                if (isAnimationActive && points && points.length && (!prevPoints && totalLength > 0 || !(0, _isEqual[\"default\"])(prevPoints, points))) {\n                    return this.renderCurveWithAnimation(needClip, clipPathId);\n                }\n                return this.renderCurveStatically(points, needClip, clipPathId);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _filterProps;\n                var _this$props6 = this.props, hide = _this$props6.hide, dot = _this$props6.dot, points = _this$props6.points, className = _this$props6.className, xAxis = _this$props6.xAxis, yAxis = _this$props6.yAxis, top = _this$props6.top, left = _this$props6.left, width = _this$props6.width, height = _this$props6.height, isAnimationActive = _this$props6.isAnimationActive, id = _this$props6.id;\n                if (hide || !points || !points.length) {\n                    return null;\n                }\n                var isAnimationFinished = this.state.isAnimationFinished;\n                var hasSinglePoint = points.length === 1;\n                var layerClass = (0, _clsx[\"default\"])('recharts-line', className);\n                var needClipX = xAxis && xAxis.allowDataOverflow;\n                var needClipY = yAxis && yAxis.allowDataOverflow;\n                var needClip = needClipX || needClipY;\n                var clipPathId = (0, _isNil[\"default\"])(id) ? this.id : id;\n                var _ref2 = (_filterProps = (0, _ReactUtils.filterProps)(dot, false)) !== null && _filterProps !== void 0 ? _filterProps : {\n                    r: 3,\n                    strokeWidth: 2\n                }, _ref2$r = _ref2.r, r = _ref2$r === void 0 ? 3 : _ref2$r, _ref2$strokeWidth = _ref2.strokeWidth, strokeWidth = _ref2$strokeWidth === void 0 ? 2 : _ref2$strokeWidth;\n                var _ref3 = (0, _ReactUtils.hasClipDot)(dot) ? dot : {}, _ref3$clipDot = _ref3.clipDot, clipDot = _ref3$clipDot === void 0 ? true : _ref3$clipDot;\n                var dotSize = r * 2 + strokeWidth;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: layerClass\n                }, needClipX || needClipY ? /*#__PURE__*/ _react[\"default\"].createElement(\"defs\", null, /*#__PURE__*/ _react[\"default\"].createElement(\"clipPath\", {\n                    id: \"clipPath-\".concat(clipPathId)\n                }, /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                    x: needClipX ? left : left - width / 2,\n                    y: needClipY ? top : top - height / 2,\n                    width: needClipX ? width : width * 2,\n                    height: needClipY ? height : height * 2\n                })), !clipDot && /*#__PURE__*/ _react[\"default\"].createElement(\"clipPath\", {\n                    id: \"clipPath-dots-\".concat(clipPathId)\n                }, /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                    x: left - dotSize / 2,\n                    y: top - dotSize / 2,\n                    width: width + dotSize,\n                    height: height + dotSize\n                }))) : null, !hasSinglePoint && this.renderCurve(needClip, clipPathId), this.renderErrorBar(needClip, clipPathId), (hasSinglePoint || dot) && this.renderDots(needClip, clipDot, clipPathId), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, points));\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                if (nextProps.animationId !== prevState.prevAnimationId) {\n                    return {\n                        prevAnimationId: nextProps.animationId,\n                        curPoints: nextProps.points,\n                        prevPoints: prevState.curPoints\n                    };\n                }\n                if (nextProps.points !== prevState.curPoints) {\n                    return {\n                        curPoints: nextProps.points\n                    };\n                }\n                return null;\n            }\n        },\n        {\n            key: \"repeat\",\n            value: function repeat(lines, count) {\n                var linesUnit = lines.length % 2 !== 0 ? [].concat(_toConsumableArray(lines), [\n                    0\n                ]) : lines;\n                var result = [];\n                for(var i = 0; i < count; ++i){\n                    result = [].concat(_toConsumableArray(result), _toConsumableArray(linesUnit));\n                }\n                return result;\n            }\n        },\n        {\n            key: \"renderDotItem\",\n            value: function renderDotItem(option, props) {\n                var dotItem;\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n                    dotItem = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n                } else if ((0, _isFunction[\"default\"])(option)) {\n                    dotItem = option(props);\n                } else {\n                    var key = props.key, dotProps = _objectWithoutProperties(props, _excluded2);\n                    var className = (0, _clsx[\"default\"])('recharts-line-dot', typeof option !== 'boolean' ? option.className : '');\n                    dotItem = /*#__PURE__*/ _react[\"default\"].createElement(_Dot.Dot, _extends({\n                        key: key\n                    }, dotProps, {\n                        className: className\n                    }));\n                }\n                return dotItem;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(Line, \"displayName\", 'Line');\n_defineProperty(Line, \"defaultProps\", {\n    xAxisId: 0,\n    yAxisId: 0,\n    connectNulls: false,\n    activeDot: true,\n    dot: true,\n    legendType: 'line',\n    stroke: '#3182bd',\n    strokeWidth: 1,\n    fill: '#fff',\n    points: [],\n    isAnimationActive: !_Global.Global.isSsr,\n    animateNewValues: true,\n    animationBegin: 0,\n    animationDuration: 1500,\n    animationEasing: 'ease',\n    hide: false,\n    label: false\n});\n/**\r\n * Compose the data of each group\r\n * @param {Object} props The props from the component\r\n * @param  {Object} xAxis   The configuration of x-axis\r\n * @param  {Object} yAxis   The configuration of y-axis\r\n * @param  {String} dataKey The unique key of a group\r\n * @return {Array}  Composed data\r\n */ _defineProperty(Line, \"getComposedData\", function(_ref4) {\n    var props = _ref4.props, xAxis = _ref4.xAxis, yAxis = _ref4.yAxis, xAxisTicks = _ref4.xAxisTicks, yAxisTicks = _ref4.yAxisTicks, dataKey = _ref4.dataKey, bandSize = _ref4.bandSize, displayedData = _ref4.displayedData, offset = _ref4.offset;\n    var layout = props.layout;\n    var points = displayedData.map(function(entry, index) {\n        var value = (0, _ChartUtils.getValueByDataKey)(entry, dataKey);\n        if (layout === 'horizontal') {\n            return {\n                x: (0, _ChartUtils.getCateCoordinateOfLine)({\n                    axis: xAxis,\n                    ticks: xAxisTicks,\n                    bandSize: bandSize,\n                    entry: entry,\n                    index: index\n                }),\n                y: (0, _isNil[\"default\"])(value) ? null : yAxis.scale(value),\n                value: value,\n                payload: entry\n            };\n        }\n        return {\n            x: (0, _isNil[\"default\"])(value) ? null : xAxis.scale(value),\n            y: (0, _ChartUtils.getCateCoordinateOfLine)({\n                axis: yAxis,\n                ticks: yAxisTicks,\n                bandSize: bandSize,\n                entry: entry,\n                index: index\n            }),\n            value: value,\n            payload: entry\n        };\n    });\n    return _objectSpread({\n        points: points,\n        layout: layout\n    }, offset);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2FydGVzaWFuL0xpbmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELFlBQVksR0FBRyxLQUFLO0FBQ3BCLElBQUlHLFNBQVNDLHdCQUF3QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUMsZUFBZUMsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUNoRSxJQUFJRyxjQUFjRCx1QkFBdUJGLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJSSxTQUFTRix1QkFBdUJGLG1CQUFPQSxDQUFDLGtDQUFjO0FBQzFELElBQUlLLFdBQVdILHVCQUF1QkYsbUJBQU9BLENBQUMsc0NBQWdCO0FBQzlELElBQUlNLFFBQVFKLHVCQUF1QkYsbUJBQU9BLENBQUMsdUJBQU07QUFDakQsSUFBSU8sU0FBU1AsbUJBQU9BLENBQUMsbUZBQWdCO0FBQ3JDLElBQUlRLE9BQU9SLG1CQUFPQSxDQUFDLCtFQUFjO0FBQ2pDLElBQUlTLFNBQVNULG1CQUFPQSxDQUFDLDJGQUFvQjtBQUN6QyxJQUFJVSxhQUFhVixtQkFBT0EsQ0FBQyxtR0FBd0I7QUFDakQsSUFBSVcsWUFBWVgsbUJBQU9BLENBQUMsc0ZBQVk7QUFDcEMsSUFBSVksYUFBYVosbUJBQU9BLENBQUMseUZBQW1CO0FBQzVDLElBQUlhLGNBQWNiLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM5QyxJQUFJYyxVQUFVZCxtQkFBT0EsQ0FBQyxtRkFBZ0I7QUFDdEMsSUFBSWUsY0FBY2YsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlnQixZQUFZO0lBQUM7SUFBUTtJQUFVO0lBQWdCO0NBQU0sRUFDdkRDLGFBQWE7SUFBQztDQUFNO0FBQ3RCLFNBQVNmLHVCQUF1QmdCLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UseUJBQXlCQyxDQUFDO0lBQUksSUFBSSxjQUFjLE9BQU9DLFNBQVMsT0FBTztJQUFNLElBQUlDLElBQUksSUFBSUQsV0FBV0UsSUFBSSxJQUFJRjtJQUFXLE9BQU8sQ0FBQ0YsMkJBQTJCLFNBQVNBLHlCQUF5QkMsQ0FBQztRQUFJLE9BQU9BLElBQUlHLElBQUlEO0lBQUcsR0FBR0Y7QUFBSTtBQUNuTyxTQUFTdEIsd0JBQXdCc0IsQ0FBQyxFQUFFRSxDQUFDO0lBQUksSUFBSSxDQUFDQSxLQUFLRixLQUFLQSxFQUFFRixVQUFVLEVBQUUsT0FBT0U7SUFBRyxJQUFJLFNBQVNBLEtBQUssWUFBWUksUUFBUUosTUFBTSxjQUFjLE9BQU9BLEdBQUcsT0FBTztRQUFFLFdBQVdBO0lBQUU7SUFBRyxJQUFJRyxJQUFJSix5QkFBeUJHO0lBQUksSUFBSUMsS0FBS0EsRUFBRUUsR0FBRyxDQUFDTCxJQUFJLE9BQU9HLEVBQUVHLEdBQUcsQ0FBQ047SUFBSSxJQUFJTyxJQUFJO1FBQUVDLFdBQVc7SUFBSyxHQUFHQyxJQUFJckMsT0FBT0MsY0FBYyxJQUFJRCxPQUFPc0Msd0JBQXdCO0lBQUUsSUFBSyxJQUFJQyxLQUFLWCxFQUFHLElBQUksY0FBY1csS0FBSyxFQUFDLEdBQUVDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDYixHQUFHVyxJQUFJO1FBQUUsSUFBSUcsSUFBSUwsSUFBSXJDLE9BQU9zQyx3QkFBd0IsQ0FBQ1YsR0FBR1csS0FBSztRQUFNRyxLQUFNQSxDQUFBQSxFQUFFUixHQUFHLElBQUlRLEVBQUVDLEdBQUcsSUFBSTNDLE9BQU9DLGNBQWMsQ0FBQ2tDLEdBQUdJLEdBQUdHLEtBQUtQLENBQUMsQ0FBQ0ksRUFBRSxHQUFHWCxDQUFDLENBQUNXLEVBQUU7SUFBRTtJQUFFLE9BQU9KLENBQUMsQ0FBQyxVQUFVLEdBQUdQLEdBQUdHLEtBQUtBLEVBQUVZLEdBQUcsQ0FBQ2YsR0FBR08sSUFBSUE7QUFBRztBQUN6a0IsU0FBU0gsUUFBUVksQ0FBQztJQUFJO0lBQTJCLE9BQU9aLFVBQVUsY0FBYyxPQUFPYSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUUsV0FBVyxLQUFLQyxVQUFVRCxNQUFNQyxPQUFPRSxTQUFTLEdBQUcsV0FBVyxPQUFPSDtJQUFHLEdBQUdaLFFBQVFZO0FBQUk7QUFDN1QsU0FBU0kseUJBQXlCQyxNQUFNLEVBQUVDLFFBQVE7SUFBSSxJQUFJRCxVQUFVLE1BQU0sT0FBTyxDQUFDO0lBQUcsSUFBSUUsU0FBU0MsOEJBQThCSCxRQUFRQztJQUFXLElBQUlHLEtBQUtYO0lBQUcsSUFBSTFDLE9BQU9zRCxxQkFBcUIsRUFBRTtRQUFFLElBQUlDLG1CQUFtQnZELE9BQU9zRCxxQkFBcUIsQ0FBQ0w7UUFBUyxJQUFLUCxJQUFJLEdBQUdBLElBQUlhLGlCQUFpQkMsTUFBTSxFQUFFZCxJQUFLO1lBQUVXLE1BQU1FLGdCQUFnQixDQUFDYixFQUFFO1lBQUUsSUFBSVEsU0FBU08sT0FBTyxDQUFDSixRQUFRLEdBQUc7WUFBVSxJQUFJLENBQUNyRCxPQUFPK0MsU0FBUyxDQUFDVyxvQkFBb0IsQ0FBQ2pCLElBQUksQ0FBQ1EsUUFBUUksTUFBTTtZQUFVRixNQUFNLENBQUNFLElBQUksR0FBR0osTUFBTSxDQUFDSSxJQUFJO1FBQUU7SUFBRTtJQUFFLE9BQU9GO0FBQVE7QUFDM2UsU0FBU0MsOEJBQThCSCxNQUFNLEVBQUVDLFFBQVE7SUFBSSxJQUFJRCxVQUFVLE1BQU0sT0FBTyxDQUFDO0lBQUcsSUFBSUUsU0FBUyxDQUFDO0lBQUcsSUFBSyxJQUFJRSxPQUFPSixPQUFRO1FBQUUsSUFBSWpELE9BQU8rQyxTQUFTLENBQUNQLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUSxRQUFRSSxNQUFNO1lBQUUsSUFBSUgsU0FBU08sT0FBTyxDQUFDSixRQUFRLEdBQUc7WUFBVUYsTUFBTSxDQUFDRSxJQUFJLEdBQUdKLE1BQU0sQ0FBQ0ksSUFBSTtRQUFFO0lBQUU7SUFBRSxPQUFPRjtBQUFRO0FBQ3RSLFNBQVNRO0lBQWFBLFdBQVczRCxPQUFPNEQsTUFBTSxHQUFHNUQsT0FBTzRELE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVWLE1BQU07UUFBSSxJQUFLLElBQUlULElBQUksR0FBR0EsSUFBSW9CLFVBQVVOLE1BQU0sRUFBRWQsSUFBSztZQUFFLElBQUlPLFNBQVNhLFNBQVMsQ0FBQ3BCLEVBQUU7WUFBRSxJQUFLLElBQUlXLE9BQU9KLE9BQVE7Z0JBQUUsSUFBSWpELE9BQU8rQyxTQUFTLENBQUNQLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUSxRQUFRSSxNQUFNO29CQUFFRixNQUFNLENBQUNFLElBQUksR0FBR0osTUFBTSxDQUFDSSxJQUFJO2dCQUFFO1lBQUU7UUFBRTtRQUFFLE9BQU9GO0lBQVE7SUFBRyxPQUFPUSxTQUFTSSxLQUFLLENBQUMsSUFBSSxFQUFFRDtBQUFZO0FBQ2xWLFNBQVNFLFFBQVFwQyxDQUFDLEVBQUVFLENBQUM7SUFBSSxJQUFJQyxJQUFJL0IsT0FBT2lFLElBQUksQ0FBQ3JDO0lBQUksSUFBSTVCLE9BQU9zRCxxQkFBcUIsRUFBRTtRQUFFLElBQUlWLElBQUk1QyxPQUFPc0QscUJBQXFCLENBQUMxQjtRQUFJRSxLQUFNYyxDQUFBQSxJQUFJQSxFQUFFc0IsTUFBTSxDQUFDLFNBQVVwQyxDQUFDO1lBQUksT0FBTzlCLE9BQU9zQyx3QkFBd0IsQ0FBQ1YsR0FBR0UsR0FBR3FDLFVBQVU7UUFBRSxFQUFDLEdBQUlwQyxFQUFFcUMsSUFBSSxDQUFDTCxLQUFLLENBQUNoQyxHQUFHYTtJQUFJO0lBQUUsT0FBT2I7QUFBRztBQUM5UCxTQUFTc0MsY0FBY3pDLENBQUM7SUFBSSxJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSWdDLFVBQVVOLE1BQU0sRUFBRTFCLElBQUs7UUFBRSxJQUFJQyxJQUFJLFFBQVErQixTQUFTLENBQUNoQyxFQUFFLEdBQUdnQyxTQUFTLENBQUNoQyxFQUFFLEdBQUcsQ0FBQztRQUFHQSxJQUFJLElBQUlrQyxRQUFRaEUsT0FBTytCLElBQUksQ0FBQyxHQUFHdUMsT0FBTyxDQUFDLFNBQVV4QyxDQUFDO1lBQUl5QyxnQkFBZ0IzQyxHQUFHRSxHQUFHQyxDQUFDLENBQUNELEVBQUU7UUFBRyxLQUFLOUIsT0FBT3dFLHlCQUF5QixHQUFHeEUsT0FBT3lFLGdCQUFnQixDQUFDN0MsR0FBRzVCLE9BQU93RSx5QkFBeUIsQ0FBQ3pDLE1BQU1pQyxRQUFRaEUsT0FBTytCLElBQUl1QyxPQUFPLENBQUMsU0FBVXhDLENBQUM7WUFBSTlCLE9BQU9DLGNBQWMsQ0FBQzJCLEdBQUdFLEdBQUc5QixPQUFPc0Msd0JBQXdCLENBQUNQLEdBQUdEO1FBQUs7SUFBSTtJQUFFLE9BQU9GO0FBQUc7QUFDdGIsU0FBUzhDLG1CQUFtQkMsR0FBRztJQUFJLE9BQU9DLG1CQUFtQkQsUUFBUUUsaUJBQWlCRixRQUFRRyw0QkFBNEJILFFBQVFJO0FBQXNCO0FBQ3hKLFNBQVNBO0lBQXVCLE1BQU0sSUFBSUMsVUFBVTtBQUF5STtBQUM3TCxTQUFTRiw0QkFBNEJsQyxDQUFDLEVBQUVxQyxNQUFNO0lBQUksSUFBSSxDQUFDckMsR0FBRztJQUFRLElBQUksT0FBT0EsTUFBTSxVQUFVLE9BQU9zQyxrQkFBa0J0QyxHQUFHcUM7SUFBUyxJQUFJOUMsSUFBSW5DLE9BQU8rQyxTQUFTLENBQUNvQyxRQUFRLENBQUMxQyxJQUFJLENBQUNHLEdBQUd3QyxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQUksSUFBSWpELE1BQU0sWUFBWVMsRUFBRSxXQUFXLEVBQUVULElBQUlTLEVBQUUsV0FBVyxDQUFDeUMsSUFBSTtJQUFFLElBQUlsRCxNQUFNLFNBQVNBLE1BQU0sT0FBTyxPQUFPbUQsTUFBTUMsSUFBSSxDQUFDM0M7SUFBSSxJQUFJVCxNQUFNLGVBQWUsMkNBQTJDcUQsSUFBSSxDQUFDckQsSUFBSSxPQUFPK0Msa0JBQWtCdEMsR0FBR3FDO0FBQVM7QUFDL1osU0FBU0osaUJBQWlCWSxJQUFJO0lBQUksSUFBSSxPQUFPNUMsV0FBVyxlQUFlNEMsSUFBSSxDQUFDNUMsT0FBT0MsUUFBUSxDQUFDLElBQUksUUFBUTJDLElBQUksQ0FBQyxhQUFhLElBQUksTUFBTSxPQUFPSCxNQUFNQyxJQUFJLENBQUNFO0FBQU87QUFDN0osU0FBU2IsbUJBQW1CRCxHQUFHO0lBQUksSUFBSVcsTUFBTUksT0FBTyxDQUFDZixNQUFNLE9BQU9PLGtCQUFrQlA7QUFBTTtBQUMxRixTQUFTTyxrQkFBa0JQLEdBQUcsRUFBRWdCLEdBQUc7SUFBSSxJQUFJQSxPQUFPLFFBQVFBLE1BQU1oQixJQUFJbkIsTUFBTSxFQUFFbUMsTUFBTWhCLElBQUluQixNQUFNO0lBQUUsSUFBSyxJQUFJZCxJQUFJLEdBQUdrRCxPQUFPLElBQUlOLE1BQU1LLE1BQU1qRCxJQUFJaUQsS0FBS2pELElBQUtrRCxJQUFJLENBQUNsRCxFQUFFLEdBQUdpQyxHQUFHLENBQUNqQyxFQUFFO0lBQUUsT0FBT2tEO0FBQU07QUFDbEwsU0FBU0MsZ0JBQWdCQyxRQUFRLEVBQUVDLFdBQVc7SUFBSSxJQUFJLENBQUVELENBQUFBLG9CQUFvQkMsV0FBVSxHQUFJO1FBQUUsTUFBTSxJQUFJZixVQUFVO0lBQXNDO0FBQUU7QUFDeEosU0FBU2dCLGtCQUFrQjdDLE1BQU0sRUFBRThDLEtBQUs7SUFBSSxJQUFLLElBQUl2RCxJQUFJLEdBQUdBLElBQUl1RCxNQUFNekMsTUFBTSxFQUFFZCxJQUFLO1FBQUUsSUFBSXdELGFBQWFELEtBQUssQ0FBQ3ZELEVBQUU7UUFBRXdELFdBQVcvQixVQUFVLEdBQUcrQixXQUFXL0IsVUFBVSxJQUFJO1FBQU8rQixXQUFXQyxZQUFZLEdBQUc7UUFBTSxJQUFJLFdBQVdELFlBQVlBLFdBQVdFLFFBQVEsR0FBRztRQUFNcEcsT0FBT0MsY0FBYyxDQUFDa0QsUUFBUWtELGVBQWVILFdBQVc3QyxHQUFHLEdBQUc2QztJQUFhO0FBQUU7QUFDNVUsU0FBU0ksYUFBYVAsV0FBVyxFQUFFUSxVQUFVLEVBQUVDLFdBQVc7SUFBSSxJQUFJRCxZQUFZUCxrQkFBa0JELFlBQVloRCxTQUFTLEVBQUV3RDtJQUFhLElBQUlDLGFBQWFSLGtCQUFrQkQsYUFBYVM7SUFBY3hHLE9BQU9DLGNBQWMsQ0FBQzhGLGFBQWEsYUFBYTtRQUFFSyxVQUFVO0lBQU07SUFBSSxPQUFPTDtBQUFhO0FBQzVSLFNBQVNVLFdBQVcxRSxDQUFDLEVBQUVhLENBQUMsRUFBRWhCLENBQUM7SUFBSSxPQUFPZ0IsSUFBSThELGdCQUFnQjlELElBQUkrRCwyQkFBMkI1RSxHQUFHNkUsOEJBQThCQyxRQUFRQyxTQUFTLENBQUNsRSxHQUFHaEIsS0FBSyxFQUFFLEVBQUU4RSxnQkFBZ0IzRSxHQUFHLFdBQVcsSUFBSWEsRUFBRW1CLEtBQUssQ0FBQ2hDLEdBQUdIO0FBQUs7QUFDMU0sU0FBUytFLDJCQUEyQkksSUFBSSxFQUFFdEUsSUFBSTtJQUFJLElBQUlBLFFBQVNULENBQUFBLFFBQVFTLFVBQVUsWUFBWSxPQUFPQSxTQUFTLFVBQVMsR0FBSTtRQUFFLE9BQU9BO0lBQU0sT0FBTyxJQUFJQSxTQUFTLEtBQUssR0FBRztRQUFFLE1BQU0sSUFBSXVDLFVBQVU7SUFBNkQ7SUFBRSxPQUFPZ0MsdUJBQXVCRDtBQUFPO0FBQy9SLFNBQVNDLHVCQUF1QkQsSUFBSTtJQUFJLElBQUlBLFNBQVMsS0FBSyxHQUFHO1FBQUUsTUFBTSxJQUFJRSxlQUFlO0lBQThEO0lBQUUsT0FBT0Y7QUFBTTtBQUNySyxTQUFTSDtJQUE4QixJQUFJO1FBQUUsSUFBSTdFLElBQUksQ0FBQ21GLFFBQVFuRSxTQUFTLENBQUNvRSxPQUFPLENBQUMxRSxJQUFJLENBQUNvRSxRQUFRQyxTQUFTLENBQUNJLFNBQVMsRUFBRSxFQUFFLFlBQWE7SUFBSyxFQUFFLE9BQU9uRixHQUFHLENBQUM7SUFBRSxPQUFPLENBQUM2RSw0QkFBNEIsU0FBU0E7UUFBOEIsT0FBTyxDQUFDLENBQUM3RTtJQUFHO0FBQU07QUFDbFAsU0FBUzJFLGdCQUFnQjlELENBQUM7SUFBSThELGtCQUFrQjFHLE9BQU9vSCxjQUFjLEdBQUdwSCxPQUFPcUgsY0FBYyxDQUFDeEQsSUFBSSxLQUFLLFNBQVM2QyxnQkFBZ0I5RCxDQUFDO1FBQUksT0FBT0EsRUFBRVIsU0FBUyxJQUFJcEMsT0FBT3FILGNBQWMsQ0FBQ3pFO0lBQUk7SUFBRyxPQUFPOEQsZ0JBQWdCOUQ7QUFBSTtBQUNuTixTQUFTMEUsVUFBVUMsUUFBUSxFQUFFQyxVQUFVO0lBQUksSUFBSSxPQUFPQSxlQUFlLGNBQWNBLGVBQWUsTUFBTTtRQUFFLE1BQU0sSUFBSXhDLFVBQVU7SUFBdUQ7SUFBRXVDLFNBQVN4RSxTQUFTLEdBQUcvQyxPQUFPeUgsTUFBTSxDQUFDRCxjQUFjQSxXQUFXekUsU0FBUyxFQUFFO1FBQUUsYUFBYTtZQUFFNUMsT0FBT29IO1lBQVVuQixVQUFVO1lBQU1ELGNBQWM7UUFBSztJQUFFO0lBQUluRyxPQUFPQyxjQUFjLENBQUNzSCxVQUFVLGFBQWE7UUFBRW5CLFVBQVU7SUFBTTtJQUFJLElBQUlvQixZQUFZRSxnQkFBZ0JILFVBQVVDO0FBQWE7QUFDbmMsU0FBU0UsZ0JBQWdCOUUsQ0FBQyxFQUFFK0UsQ0FBQztJQUFJRCxrQkFBa0IxSCxPQUFPb0gsY0FBYyxHQUFHcEgsT0FBT29ILGNBQWMsQ0FBQ3ZELElBQUksS0FBSyxTQUFTNkQsZ0JBQWdCOUUsQ0FBQyxFQUFFK0UsQ0FBQztRQUFJL0UsRUFBRVIsU0FBUyxHQUFHdUY7UUFBRyxPQUFPL0U7SUFBRztJQUFHLE9BQU84RSxnQkFBZ0I5RSxHQUFHK0U7QUFBSTtBQUN2TSxTQUFTcEQsZ0JBQWdCOUMsR0FBRyxFQUFFNEIsR0FBRyxFQUFFbEQsS0FBSztJQUFJa0QsTUFBTWdELGVBQWVoRDtJQUFNLElBQUlBLE9BQU81QixLQUFLO1FBQUV6QixPQUFPQyxjQUFjLENBQUN3QixLQUFLNEIsS0FBSztZQUFFbEQsT0FBT0E7WUFBT2dFLFlBQVk7WUFBTWdDLGNBQWM7WUFBTUMsVUFBVTtRQUFLO0lBQUksT0FBTztRQUFFM0UsR0FBRyxDQUFDNEIsSUFBSSxHQUFHbEQ7SUFBTztJQUFFLE9BQU9zQjtBQUFLO0FBQzNPLFNBQVM0RSxlQUFldEUsQ0FBQztJQUFJLElBQUlXLElBQUlrRixhQUFhN0YsR0FBRztJQUFXLE9BQU8sWUFBWUMsUUFBUVUsS0FBS0EsSUFBSUEsSUFBSTtBQUFJO0FBQzVHLFNBQVNrRixhQUFhN0YsQ0FBQyxFQUFFRCxDQUFDO0lBQUksSUFBSSxZQUFZRSxRQUFRRCxNQUFNLENBQUNBLEdBQUcsT0FBT0E7SUFBRyxJQUFJSCxJQUFJRyxDQUFDLENBQUNjLE9BQU9nRixXQUFXLENBQUM7SUFBRSxJQUFJLEtBQUssTUFBTWpHLEdBQUc7UUFBRSxJQUFJYyxJQUFJZCxFQUFFYSxJQUFJLENBQUNWLEdBQUdELEtBQUs7UUFBWSxJQUFJLFlBQVlFLFFBQVFVLElBQUksT0FBT0E7UUFBRyxNQUFNLElBQUlzQyxVQUFVO0lBQWlEO0lBQUUsT0FBTyxDQUFDLGFBQWFsRCxJQUFJZ0csU0FBU0MsTUFBSyxFQUFHaEc7QUFBSSxFQUFFOztDQUU1VDtBQUNELElBQUkzQixPQUFPRixZQUFZLEdBQUcsV0FBVyxHQUFFLFNBQVU4SCxjQUFjO0lBQzdELFNBQVM1SDtRQUNQLElBQUk2SDtRQUNKcEMsZ0JBQWdCLElBQUksRUFBRXpGO1FBQ3RCLElBQUssSUFBSThILE9BQU9wRSxVQUFVTixNQUFNLEVBQUUyRSxPQUFPLElBQUk3QyxNQUFNNEMsT0FBT0UsT0FBTyxHQUFHQSxPQUFPRixNQUFNRSxPQUFRO1lBQ3ZGRCxJQUFJLENBQUNDLEtBQUssR0FBR3RFLFNBQVMsQ0FBQ3NFLEtBQUs7UUFDOUI7UUFDQUgsUUFBUXhCLFdBQVcsSUFBSSxFQUFFckcsTUFBTSxFQUFFLENBQUNpSSxNQUFNLENBQUNGO1FBQ3pDNUQsZ0JBQWdCMEQsT0FBTyxTQUFTO1lBQzlCSyxxQkFBcUI7WUFDckJDLGFBQWE7UUFDZjtRQUNBaEUsZ0JBQWdCMEQsT0FBTyxpQ0FBaUMsU0FBVU0sV0FBVyxFQUFFL0UsTUFBTTtZQUNuRixPQUFPLEdBQUc2RSxNQUFNLENBQUM3RSxRQUFRLE9BQU82RSxNQUFNLENBQUNFLGNBQWMvRSxRQUFRO1FBQy9EO1FBQ0FlLGdCQUFnQjBELE9BQU8sc0JBQXNCLFNBQVV6RSxNQUFNLEVBQUUrRSxXQUFXLEVBQUVDLEtBQUs7WUFDL0UsSUFBSUMsYUFBYUQsTUFBTUUsTUFBTSxDQUFDLFNBQVVDLEdBQUcsRUFBRUMsSUFBSTtnQkFDL0MsT0FBT0QsTUFBTUM7WUFDZjtZQUVBLDRFQUE0RTtZQUM1RSxJQUFJLENBQUNILFlBQVk7Z0JBQ2YsT0FBT1IsTUFBTVksNkJBQTZCLENBQUNOLGFBQWEvRTtZQUMxRDtZQUNBLElBQUlzRixRQUFRQyxLQUFLQyxLQUFLLENBQUN4RixTQUFTaUY7WUFDaEMsSUFBSVEsZUFBZXpGLFNBQVNpRjtZQUM1QixJQUFJUyxhQUFhWCxjQUFjL0U7WUFDL0IsSUFBSTJGLGNBQWMsRUFBRTtZQUNwQixJQUFLLElBQUl6RyxJQUFJLEdBQUcwRyxNQUFNLEdBQUcxRyxJQUFJOEYsTUFBTWhGLE1BQU0sRUFBRTRGLE9BQU9aLEtBQUssQ0FBQzlGLEVBQUUsRUFBRSxFQUFFQSxFQUFHO2dCQUMvRCxJQUFJMEcsTUFBTVosS0FBSyxDQUFDOUYsRUFBRSxHQUFHdUcsY0FBYztvQkFDakNFLGNBQWMsRUFBRSxDQUFDZCxNQUFNLENBQUMzRCxtQkFBbUI4RCxNQUFNcEQsS0FBSyxDQUFDLEdBQUcxQyxLQUFLO3dCQUFDdUcsZUFBZUc7cUJBQUk7b0JBQ25GO2dCQUNGO1lBQ0Y7WUFDQSxJQUFJQyxhQUFhRixZQUFZM0YsTUFBTSxHQUFHLE1BQU0sSUFBSTtnQkFBQztnQkFBRzBGO2FBQVcsR0FBRztnQkFBQ0E7YUFBVztZQUM5RSxPQUFPLEVBQUUsQ0FBQ2IsTUFBTSxDQUFDM0QsbUJBQW1CdEUsS0FBS2tKLE1BQU0sQ0FBQ2QsT0FBT00sU0FBU3BFLG1CQUFtQnlFLGNBQWNFLFlBQVlFLEdBQUcsQ0FBQyxTQUFVQyxJQUFJO2dCQUM3SCxPQUFPLEdBQUduQixNQUFNLENBQUNtQixNQUFNO1lBQ3pCLEdBQUdDLElBQUksQ0FBQztRQUNWO1FBQ0FsRixnQkFBZ0IwRCxPQUFPLE1BQU0sQ0FBQyxHQUFHOUcsV0FBV3VJLFFBQVEsRUFBRTtRQUN0RG5GLGdCQUFnQjBELE9BQU8sV0FBVyxTQUFVMEIsSUFBSTtZQUM5QzFCLE1BQU0yQixTQUFTLEdBQUdEO1FBQ3BCO1FBQ0FwRixnQkFBZ0IwRCxPQUFPLHNCQUFzQjtZQUMzQ0EsTUFBTTRCLFFBQVEsQ0FBQztnQkFDYnZCLHFCQUFxQjtZQUN2QjtZQUNBLElBQUlMLE1BQU1oQyxLQUFLLENBQUM2RCxjQUFjLEVBQUU7Z0JBQzlCN0IsTUFBTWhDLEtBQUssQ0FBQzZELGNBQWM7WUFDNUI7UUFDRjtRQUNBdkYsZ0JBQWdCMEQsT0FBTyx3QkFBd0I7WUFDN0NBLE1BQU00QixRQUFRLENBQUM7Z0JBQ2J2QixxQkFBcUI7WUFDdkI7WUFDQSxJQUFJTCxNQUFNaEMsS0FBSyxDQUFDOEQsZ0JBQWdCLEVBQUU7Z0JBQ2hDOUIsTUFBTWhDLEtBQUssQ0FBQzhELGdCQUFnQjtZQUM5QjtRQUNGO1FBQ0EsT0FBTzlCO0lBQ1Q7SUFDQVgsVUFBVWxILE1BQU00SDtJQUNoQixPQUFPMUIsYUFBYWxHLE1BQU07UUFBQztZQUN6QmlELEtBQUs7WUFDTGxELE9BQU8sU0FBUzZKO2dCQUNkLElBQUksQ0FBQyxJQUFJLENBQUMvRCxLQUFLLENBQUNnRSxpQkFBaUIsRUFBRTtvQkFDakM7Z0JBQ0Y7Z0JBQ0EsSUFBSTFCLGNBQWMsSUFBSSxDQUFDMkIsY0FBYztnQkFDckMsSUFBSSxDQUFDTCxRQUFRLENBQUM7b0JBQ1p0QixhQUFhQTtnQkFDZjtZQUNGO1FBQ0Y7UUFBRztZQUNEbEYsS0FBSztZQUNMbEQsT0FBTyxTQUFTZ0s7Z0JBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQ2xFLEtBQUssQ0FBQ2dFLGlCQUFpQixFQUFFO29CQUNqQztnQkFDRjtnQkFDQSxJQUFJMUIsY0FBYyxJQUFJLENBQUMyQixjQUFjO2dCQUNyQyxJQUFJM0IsZ0JBQWdCLElBQUksQ0FBQzZCLEtBQUssQ0FBQzdCLFdBQVcsRUFBRTtvQkFDMUMsSUFBSSxDQUFDc0IsUUFBUSxDQUFDO3dCQUNadEIsYUFBYUE7b0JBQ2Y7Z0JBQ0Y7WUFDRjtRQUNGO1FBQUc7WUFDRGxGLEtBQUs7WUFDTGxELE9BQU8sU0FBUytKO2dCQUNkLElBQUlHLFdBQVcsSUFBSSxDQUFDVCxTQUFTO2dCQUM3QixJQUFJO29CQUNGLE9BQU9TLFlBQVlBLFNBQVNILGNBQWMsSUFBSUcsU0FBU0gsY0FBYyxNQUFNO2dCQUM3RSxFQUFFLE9BQU9JLEtBQUs7b0JBQ1osT0FBTztnQkFDVDtZQUNGO1FBQ0Y7UUFBRztZQUNEakgsS0FBSztZQUNMbEQsT0FBTyxTQUFTb0ssZUFBZUMsUUFBUSxFQUFFQyxVQUFVO2dCQUNqRCxJQUFJLElBQUksQ0FBQ3hFLEtBQUssQ0FBQ2dFLGlCQUFpQixJQUFJLENBQUMsSUFBSSxDQUFDRyxLQUFLLENBQUM5QixtQkFBbUIsRUFBRTtvQkFDbkUsT0FBTztnQkFDVDtnQkFDQSxJQUFJb0MsY0FBYyxJQUFJLENBQUN6RSxLQUFLLEVBQzFCMEUsU0FBU0QsWUFBWUMsTUFBTSxFQUMzQkMsUUFBUUYsWUFBWUUsS0FBSyxFQUN6QkMsUUFBUUgsWUFBWUcsS0FBSyxFQUN6QkMsU0FBU0osWUFBWUksTUFBTSxFQUMzQkMsV0FBV0wsWUFBWUssUUFBUTtnQkFDakMsSUFBSUMsZ0JBQWdCLENBQUMsR0FBRzVKLFlBQVk2SixhQUFhLEVBQUVGLFVBQVU3SixVQUFVZ0ssUUFBUTtnQkFDL0UsSUFBSSxDQUFDRixlQUFlO29CQUNsQixPQUFPO2dCQUNUO2dCQUNBLElBQUlHLHFCQUFxQixTQUFTQSxtQkFBbUJDLFNBQVMsRUFBRUMsT0FBTztvQkFDckUsT0FBTzt3QkFDTEMsR0FBR0YsVUFBVUUsQ0FBQzt3QkFDZEMsR0FBR0gsVUFBVUcsQ0FBQzt3QkFDZHBMLE9BQU9pTCxVQUFVakwsS0FBSzt3QkFDdEJxTCxVQUFVLENBQUMsR0FBR2xLLFlBQVltSyxpQkFBaUIsRUFBRUwsVUFBVU0sT0FBTyxFQUFFTDtvQkFDbEU7Z0JBQ0Y7Z0JBQ0EsSUFBSU0sZ0JBQWdCO29CQUNsQkMsVUFBVXBCLFdBQVcsaUJBQWlCbkMsTUFBTSxDQUFDb0MsWUFBWSxPQUFPO2dCQUNsRTtnQkFDQSxPQUFPLFdBQVcsR0FBRXBLLE1BQU0sQ0FBQyxVQUFVLENBQUN3TCxhQUFhLENBQUM3SyxPQUFPOEssS0FBSyxFQUFFSCxlQUFlWCxjQUFjekIsR0FBRyxDQUFDLFNBQVV3QyxJQUFJO29CQUMvRyxPQUFPLFdBQVcsR0FBRTFMLE1BQU0sQ0FBQyxVQUFVLENBQUMyTCxZQUFZLENBQUNELE1BQU07d0JBQ3ZEMUksS0FBSyxPQUFPZ0YsTUFBTSxDQUFDMEQsS0FBSzlGLEtBQUssQ0FBQ29GLE9BQU87d0JBQ3JDWSxNQUFNdEI7d0JBQ05DLE9BQU9BO3dCQUNQQyxPQUFPQTt3QkFDUEMsUUFBUUE7d0JBQ1JLLG9CQUFvQkE7b0JBQ3RCO2dCQUNGO1lBQ0Y7UUFDRjtRQUFHO1lBQ0Q5SCxLQUFLO1lBQ0xsRCxPQUFPLFNBQVMrTCxXQUFXMUIsUUFBUSxFQUFFMkIsT0FBTyxFQUFFMUIsVUFBVTtnQkFDdEQsSUFBSVIsb0JBQW9CLElBQUksQ0FBQ2hFLEtBQUssQ0FBQ2dFLGlCQUFpQjtnQkFDcEQsSUFBSUEscUJBQXFCLENBQUMsSUFBSSxDQUFDRyxLQUFLLENBQUM5QixtQkFBbUIsRUFBRTtvQkFDeEQsT0FBTztnQkFDVDtnQkFDQSxJQUFJOEQsZUFBZSxJQUFJLENBQUNuRyxLQUFLLEVBQzNCb0csTUFBTUQsYUFBYUMsR0FBRyxFQUN0QjFCLFNBQVN5QixhQUFhekIsTUFBTSxFQUM1QlUsVUFBVWUsYUFBYWYsT0FBTztnQkFDaEMsSUFBSWlCLFlBQVksQ0FBQyxHQUFHbEwsWUFBWW1MLFdBQVcsRUFBRSxJQUFJLENBQUN0RyxLQUFLLEVBQUU7Z0JBQ3pELElBQUl1RyxpQkFBaUIsQ0FBQyxHQUFHcEwsWUFBWW1MLFdBQVcsRUFBRUYsS0FBSztnQkFDdkQsSUFBSUksT0FBTzlCLE9BQU9wQixHQUFHLENBQUMsU0FBVW1ELEtBQUssRUFBRWhLLENBQUM7b0JBQ3RDLElBQUlpSyxXQUFXdEksY0FBY0EsY0FBY0EsY0FBYzt3QkFDdkRoQixLQUFLLE9BQU9nRixNQUFNLENBQUMzRjt3QkFDbkJaLEdBQUc7b0JBQ0wsR0FBR3dLLFlBQVlFLGlCQUFpQixDQUFDLEdBQUc7d0JBQ2xDSSxPQUFPbEs7d0JBQ1BtSyxJQUFJSCxNQUFNcEIsQ0FBQzt3QkFDWHdCLElBQUlKLE1BQU1uQixDQUFDO3dCQUNYcEwsT0FBT3VNLE1BQU12TSxLQUFLO3dCQUNsQmtMLFNBQVNBO3dCQUNUSyxTQUFTZ0IsTUFBTWhCLE9BQU87d0JBQ3RCZixRQUFRQTtvQkFDVjtvQkFDQSxPQUFPdkssS0FBSzJNLGFBQWEsQ0FBQ1YsS0FBS007Z0JBQ2pDO2dCQUNBLElBQUlLLFlBQVk7b0JBQ2RwQixVQUFVcEIsV0FBVyxpQkFBaUJuQyxNQUFNLENBQUM4RCxVQUFVLEtBQUssU0FBUzlELE1BQU0sQ0FBQ29DLFlBQVksT0FBTztnQkFDakc7Z0JBQ0EsT0FBTyxXQUFXLEdBQUVwSyxNQUFNLENBQUMsVUFBVSxDQUFDd0wsYUFBYSxDQUFDN0ssT0FBTzhLLEtBQUssRUFBRW5JLFNBQVM7b0JBQ3pFc0osV0FBVztvQkFDWDVKLEtBQUs7Z0JBQ1AsR0FBRzJKLFlBQVlQO1lBQ2pCO1FBQ0Y7UUFBRztZQUNEcEosS0FBSztZQUNMbEQsT0FBTyxTQUFTK00sc0JBQXNCdkMsTUFBTSxFQUFFSCxRQUFRLEVBQUVDLFVBQVUsRUFBRXhFLEtBQUs7Z0JBQ3ZFLElBQUlrSCxlQUFlLElBQUksQ0FBQ2xILEtBQUssRUFDM0JtSCxPQUFPRCxhQUFhQyxJQUFJLEVBQ3hCdEMsU0FBU3FDLGFBQWFyQyxNQUFNLEVBQzVCdUMsZUFBZUYsYUFBYUUsWUFBWSxFQUN4Q0MsTUFBTUgsYUFBYUcsR0FBRyxFQUN0QkMsU0FBU3ZLLHlCQUF5Qm1LLGNBQWM1TDtnQkFDbEQsSUFBSWlNLGFBQWFuSixjQUFjQSxjQUFjQSxjQUFjLENBQUMsR0FBRyxDQUFDLEdBQUdqRCxZQUFZbUwsV0FBVyxFQUFFZ0IsUUFBUSxRQUFRLENBQUMsR0FBRztvQkFDOUdFLE1BQU07b0JBQ05SLFdBQVc7b0JBQ1hyQixVQUFVcEIsV0FBVyxpQkFBaUJuQyxNQUFNLENBQUNvQyxZQUFZLE9BQU87b0JBQ2hFRSxRQUFRQTtnQkFDVixHQUFHMUUsUUFBUSxDQUFDLEdBQUc7b0JBQ2JtSCxNQUFNQTtvQkFDTnRDLFFBQVFBO29CQUNSdUMsY0FBY0E7Z0JBQ2hCO2dCQUNBLE9BQU8sV0FBVyxHQUFFaE4sTUFBTSxDQUFDLFVBQVUsQ0FBQ3dMLGFBQWEsQ0FBQy9LLE9BQU80TSxLQUFLLEVBQUUvSixTQUFTLENBQUMsR0FBRzZKLFlBQVk7b0JBQ3pGRyxTQUFTLElBQUksQ0FBQ0EsT0FBTztnQkFDdkI7WUFDRjtRQUNGO1FBQUc7WUFDRHRLLEtBQUs7WUFDTGxELE9BQU8sU0FBU3lOLHlCQUF5QnBELFFBQVEsRUFBRUMsVUFBVTtnQkFDM0QsSUFBSW9ELFNBQVMsSUFBSTtnQkFDakIsSUFBSUMsZUFBZSxJQUFJLENBQUM3SCxLQUFLLEVBQzNCMEUsU0FBU21ELGFBQWFuRCxNQUFNLEVBQzVCb0Qsa0JBQWtCRCxhQUFhQyxlQUFlLEVBQzlDOUQsb0JBQW9CNkQsYUFBYTdELGlCQUFpQixFQUNsRCtELGlCQUFpQkYsYUFBYUUsY0FBYyxFQUM1Q0Msb0JBQW9CSCxhQUFhRyxpQkFBaUIsRUFDbERDLGtCQUFrQkosYUFBYUksZUFBZSxFQUM5Q0MsY0FBY0wsYUFBYUssV0FBVyxFQUN0Q0MsbUJBQW1CTixhQUFhTSxnQkFBZ0IsRUFDaERDLFFBQVFQLGFBQWFPLEtBQUssRUFDMUJDLFNBQVNSLGFBQWFRLE1BQU07Z0JBQzlCLElBQUlDLGNBQWMsSUFBSSxDQUFDbkUsS0FBSyxFQUMxQm9FLGFBQWFELFlBQVlDLFVBQVUsRUFDbkNqRyxjQUFjZ0csWUFBWWhHLFdBQVc7Z0JBQ3ZDLE9BQU8sV0FBVyxHQUFFbEksTUFBTSxDQUFDLFVBQVUsQ0FBQ3dMLGFBQWEsQ0FBQ3JMLFlBQVksQ0FBQyxVQUFVLEVBQUU7b0JBQzNFaU8sT0FBT1Q7b0JBQ1BVLFVBQVVUO29CQUNWVSxVQUFVMUU7b0JBQ1YyRSxRQUFRVjtvQkFDUjNJLE1BQU07d0JBQ0p4RCxHQUFHO29CQUNMO29CQUNBOE0sSUFBSTt3QkFDRjlNLEdBQUc7b0JBQ0w7b0JBQ0FzQixLQUFLLFFBQVFnRixNQUFNLENBQUM4RjtvQkFDcEJyRSxnQkFBZ0IsSUFBSSxDQUFDZ0Ysa0JBQWtCO29CQUN2Qy9FLGtCQUFrQixJQUFJLENBQUNnRixvQkFBb0I7Z0JBQzdDLEdBQUcsU0FBVUMsSUFBSTtvQkFDZixJQUFJak4sSUFBSWlOLEtBQUtqTixDQUFDO29CQUNkLElBQUl5TSxZQUFZO3dCQUNkLElBQUlTLHVCQUF1QlQsV0FBV2hMLE1BQU0sR0FBR21ILE9BQU9uSCxNQUFNO3dCQUM1RCxJQUFJMEwsV0FBV3ZFLE9BQU9wQixHQUFHLENBQUMsU0FBVW1ELEtBQUssRUFBRUUsS0FBSzs0QkFDOUMsSUFBSXVDLGlCQUFpQnBHLEtBQUtDLEtBQUssQ0FBQzRELFFBQVFxQzs0QkFDeEMsSUFBSVQsVUFBVSxDQUFDVyxlQUFlLEVBQUU7Z0NBQzlCLElBQUlDLE9BQU9aLFVBQVUsQ0FBQ1csZUFBZTtnQ0FDckMsSUFBSUUsZ0JBQWdCLENBQUMsR0FBR2xPLFdBQVdtTyxpQkFBaUIsRUFBRUYsS0FBSzlELENBQUMsRUFBRW9CLE1BQU1wQixDQUFDO2dDQUNyRSxJQUFJaUUsZ0JBQWdCLENBQUMsR0FBR3BPLFdBQVdtTyxpQkFBaUIsRUFBRUYsS0FBSzdELENBQUMsRUFBRW1CLE1BQU1uQixDQUFDO2dDQUNyRSxPQUFPbEgsY0FBY0EsY0FBYyxDQUFDLEdBQUdxSSxRQUFRLENBQUMsR0FBRztvQ0FDakRwQixHQUFHK0QsY0FBY3ROO29DQUNqQndKLEdBQUdnRSxjQUFjeE47Z0NBQ25COzRCQUNGOzRCQUVBLG1EQUFtRDs0QkFDbkQsSUFBSXFNLGtCQUFrQjtnQ0FDcEIsSUFBSW9CLGlCQUFpQixDQUFDLEdBQUdyTyxXQUFXbU8saUJBQWlCLEVBQUVqQixRQUFRLEdBQUczQixNQUFNcEIsQ0FBQztnQ0FDekUsSUFBSW1FLGlCQUFpQixDQUFDLEdBQUd0TyxXQUFXbU8saUJBQWlCLEVBQUVoQixTQUFTLEdBQUc1QixNQUFNbkIsQ0FBQztnQ0FDMUUsT0FBT2xILGNBQWNBLGNBQWMsQ0FBQyxHQUFHcUksUUFBUSxDQUFDLEdBQUc7b0NBQ2pEcEIsR0FBR2tFLGVBQWV6TjtvQ0FDbEJ3SixHQUFHa0UsZUFBZTFOO2dDQUNwQjs0QkFDRjs0QkFDQSxPQUFPc0MsY0FBY0EsY0FBYyxDQUFDLEdBQUdxSSxRQUFRLENBQUMsR0FBRztnQ0FDakRwQixHQUFHb0IsTUFBTXBCLENBQUM7Z0NBQ1ZDLEdBQUdtQixNQUFNbkIsQ0FBQzs0QkFDWjt3QkFDRjt3QkFDQSxPQUFPc0MsT0FBT1gscUJBQXFCLENBQUNnQyxVQUFVMUUsVUFBVUM7b0JBQzFEO29CQUNBLElBQUlpRixlQUFlLENBQUMsR0FBR3ZPLFdBQVdtTyxpQkFBaUIsRUFBRSxHQUFHL0c7b0JBQ3hELElBQUlvSCxZQUFZRCxhQUFhM047b0JBQzdCLElBQUk2TjtvQkFDSixJQUFJN0IsaUJBQWlCO3dCQUNuQixJQUFJdkYsUUFBUSxHQUFHSCxNQUFNLENBQUMwRixpQkFBaUI4QixLQUFLLENBQUMsYUFBYXRHLEdBQUcsQ0FBQyxTQUFVdUcsR0FBRzs0QkFDekUsT0FBT0MsV0FBV0Q7d0JBQ3BCO3dCQUNBRix5QkFBeUIvQixPQUFPbUMsa0JBQWtCLENBQUNMLFdBQVdwSCxhQUFhQztvQkFDN0UsT0FBTzt3QkFDTG9ILHlCQUF5Qi9CLE9BQU9oRiw2QkFBNkIsQ0FBQ04sYUFBYW9IO29CQUM3RTtvQkFDQSxPQUFPOUIsT0FBT1gscUJBQXFCLENBQUN2QyxRQUFRSCxVQUFVQyxZQUFZO3dCQUNoRXNELGlCQUFpQjZCO29CQUNuQjtnQkFDRjtZQUNGO1FBQ0Y7UUFBRztZQUNEdk0sS0FBSztZQUNMbEQsT0FBTyxTQUFTOFAsWUFBWXpGLFFBQVEsRUFBRUMsVUFBVTtnQkFDOUMsSUFBSXlGLGVBQWUsSUFBSSxDQUFDakssS0FBSyxFQUMzQjBFLFNBQVN1RixhQUFhdkYsTUFBTSxFQUM1QlYsb0JBQW9CaUcsYUFBYWpHLGlCQUFpQjtnQkFDcEQsSUFBSWtHLGVBQWUsSUFBSSxDQUFDL0YsS0FBSyxFQUMzQm9FLGFBQWEyQixhQUFhM0IsVUFBVSxFQUNwQ2pHLGNBQWM0SCxhQUFhNUgsV0FBVztnQkFDeEMsSUFBSTBCLHFCQUFxQlUsVUFBVUEsT0FBT25ILE1BQU0sSUFBSyxFQUFDZ0wsY0FBY2pHLGNBQWMsS0FBSyxDQUFDLENBQUMsR0FBRzNILFFBQVEsQ0FBQyxVQUFVLEVBQUU0TixZQUFZN0QsT0FBTSxHQUFJO29CQUNySSxPQUFPLElBQUksQ0FBQ2lELHdCQUF3QixDQUFDcEQsVUFBVUM7Z0JBQ2pEO2dCQUNBLE9BQU8sSUFBSSxDQUFDeUMscUJBQXFCLENBQUN2QyxRQUFRSCxVQUFVQztZQUN0RDtRQUNGO1FBQUc7WUFDRHBILEtBQUs7WUFDTGxELE9BQU8sU0FBU2lRO2dCQUNkLElBQUlDO2dCQUNKLElBQUlDLGVBQWUsSUFBSSxDQUFDckssS0FBSyxFQUMzQnNLLE9BQU9ELGFBQWFDLElBQUksRUFDeEJsRSxNQUFNaUUsYUFBYWpFLEdBQUcsRUFDdEIxQixTQUFTMkYsYUFBYTNGLE1BQU0sRUFDNUJzQyxZQUFZcUQsYUFBYXJELFNBQVMsRUFDbENyQyxRQUFRMEYsYUFBYTFGLEtBQUssRUFDMUJDLFFBQVF5RixhQUFhekYsS0FBSyxFQUMxQjJGLE1BQU1GLGFBQWFFLEdBQUcsRUFDdEJDLE9BQU9ILGFBQWFHLElBQUksRUFDeEJwQyxRQUFRaUMsYUFBYWpDLEtBQUssRUFDMUJDLFNBQVNnQyxhQUFhaEMsTUFBTSxFQUM1QnJFLG9CQUFvQnFHLGFBQWFyRyxpQkFBaUIsRUFDbER5RyxLQUFLSixhQUFhSSxFQUFFO2dCQUN0QixJQUFJSCxRQUFRLENBQUM1RixVQUFVLENBQUNBLE9BQU9uSCxNQUFNLEVBQUU7b0JBQ3JDLE9BQU87Z0JBQ1Q7Z0JBQ0EsSUFBSThFLHNCQUFzQixJQUFJLENBQUM4QixLQUFLLENBQUM5QixtQkFBbUI7Z0JBQ3hELElBQUlxSSxpQkFBaUJoRyxPQUFPbkgsTUFBTSxLQUFLO2dCQUN2QyxJQUFJb04sYUFBYSxDQUFDLEdBQUcvUCxLQUFLLENBQUMsVUFBVSxFQUFFLGlCQUFpQm9NO2dCQUN4RCxJQUFJNEQsWUFBWWpHLFNBQVNBLE1BQU1rRyxpQkFBaUI7Z0JBQ2hELElBQUlDLFlBQVlsRyxTQUFTQSxNQUFNaUcsaUJBQWlCO2dCQUNoRCxJQUFJdEcsV0FBV3FHLGFBQWFFO2dCQUM1QixJQUFJdEcsYUFBYSxDQUFDLEdBQUc5SixNQUFNLENBQUMsVUFBVSxFQUFFK1AsTUFBTSxJQUFJLENBQUNBLEVBQUUsR0FBR0E7Z0JBQ3hELElBQUlNLFFBQVEsQ0FBQ1gsZUFBZSxDQUFDLEdBQUdqUCxZQUFZbUwsV0FBVyxFQUFFRixLQUFLLE1BQUssTUFBTyxRQUFRZ0UsaUJBQWlCLEtBQUssSUFBSUEsZUFBZTtvQkFDdkh2TyxHQUFHO29CQUNIbVAsYUFBYTtnQkFDZixHQUNBQyxVQUFVRixNQUFNbFAsQ0FBQyxFQUNqQkEsSUFBSW9QLFlBQVksS0FBSyxJQUFJLElBQUlBLFNBQzdCQyxvQkFBb0JILE1BQU1DLFdBQVcsRUFDckNBLGNBQWNFLHNCQUFzQixLQUFLLElBQUksSUFBSUE7Z0JBQ25ELElBQUlDLFFBQVEsQ0FBQyxHQUFHaFEsWUFBWWlRLFVBQVUsRUFBRWhGLE9BQU9BLE1BQU0sQ0FBQyxHQUNwRGlGLGdCQUFnQkYsTUFBTWpGLE9BQU8sRUFDN0JBLFVBQVVtRixrQkFBa0IsS0FBSyxJQUFJLE9BQU9BO2dCQUM5QyxJQUFJQyxVQUFVelAsSUFBSSxJQUFJbVA7Z0JBQ3RCLE9BQU8sV0FBVyxHQUFFNVEsTUFBTSxDQUFDLFVBQVUsQ0FBQ3dMLGFBQWEsQ0FBQzdLLE9BQU84SyxLQUFLLEVBQUU7b0JBQ2hFbUIsV0FBVzJEO2dCQUNiLEdBQUdDLGFBQWFFLFlBQVksV0FBVyxHQUFFMVEsTUFBTSxDQUFDLFVBQVUsQ0FBQ3dMLGFBQWEsQ0FBQyxRQUFRLE1BQU0sV0FBVyxHQUFFeEwsTUFBTSxDQUFDLFVBQVUsQ0FBQ3dMLGFBQWEsQ0FBQyxZQUFZO29CQUM5STZFLElBQUksWUFBWXJJLE1BQU0sQ0FBQ29DO2dCQUN6QixHQUFHLFdBQVcsR0FBRXBLLE1BQU0sQ0FBQyxVQUFVLENBQUN3TCxhQUFhLENBQUMsUUFBUTtvQkFDdERQLEdBQUd1RixZQUFZSixPQUFPQSxPQUFPcEMsUUFBUTtvQkFDckM5QyxHQUFHd0YsWUFBWVAsTUFBTUEsTUFBTWxDLFNBQVM7b0JBQ3BDRCxPQUFPd0MsWUFBWXhDLFFBQVFBLFFBQVE7b0JBQ25DQyxRQUFReUMsWUFBWXpDLFNBQVNBLFNBQVM7Z0JBQ3hDLEtBQUssQ0FBQ25DLFdBQVcsV0FBVyxHQUFFOUwsTUFBTSxDQUFDLFVBQVUsQ0FBQ3dMLGFBQWEsQ0FBQyxZQUFZO29CQUN4RTZFLElBQUksaUJBQWlCckksTUFBTSxDQUFDb0M7Z0JBQzlCLEdBQUcsV0FBVyxHQUFFcEssTUFBTSxDQUFDLFVBQVUsQ0FBQ3dMLGFBQWEsQ0FBQyxRQUFRO29CQUN0RFAsR0FBR21GLE9BQU9jLFVBQVU7b0JBQ3BCaEcsR0FBR2lGLE1BQU1lLFVBQVU7b0JBQ25CbEQsT0FBT0EsUUFBUWtEO29CQUNmakQsUUFBUUEsU0FBU2lEO2dCQUNuQixPQUFPLE1BQU0sQ0FBQ1osa0JBQWtCLElBQUksQ0FBQ1YsV0FBVyxDQUFDekYsVUFBVUMsYUFBYSxJQUFJLENBQUNGLGNBQWMsQ0FBQ0MsVUFBVUMsYUFBYSxDQUFDa0csa0JBQWtCdEUsR0FBRSxLQUFNLElBQUksQ0FBQ0gsVUFBVSxDQUFDMUIsVUFBVTJCLFNBQVMxQixhQUFhLENBQUMsQ0FBQ1IscUJBQXFCM0IsbUJBQWtCLEtBQU1ySCxXQUFXdVEsU0FBUyxDQUFDQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUN4TCxLQUFLLEVBQUUwRTtZQUNuUztRQUNGO0tBQUUsRUFBRTtRQUFDO1lBQ0h0SCxLQUFLO1lBQ0xsRCxPQUFPLFNBQVN1Uix5QkFBeUJDLFNBQVMsRUFBRUMsU0FBUztnQkFDM0QsSUFBSUQsVUFBVXhELFdBQVcsS0FBS3lELFVBQVVDLGVBQWUsRUFBRTtvQkFDdkQsT0FBTzt3QkFDTEEsaUJBQWlCRixVQUFVeEQsV0FBVzt3QkFDdEMyRCxXQUFXSCxVQUFVaEgsTUFBTTt3QkFDM0I2RCxZQUFZb0QsVUFBVUUsU0FBUztvQkFDakM7Z0JBQ0Y7Z0JBQ0EsSUFBSUgsVUFBVWhILE1BQU0sS0FBS2lILFVBQVVFLFNBQVMsRUFBRTtvQkFDNUMsT0FBTzt3QkFDTEEsV0FBV0gsVUFBVWhILE1BQU07b0JBQzdCO2dCQUNGO2dCQUNBLE9BQU87WUFDVDtRQUNGO1FBQUc7WUFDRHRILEtBQUs7WUFDTGxELE9BQU8sU0FBU21KLE9BQU9kLEtBQUssRUFBRU0sS0FBSztnQkFDakMsSUFBSWlKLFlBQVl2SixNQUFNaEYsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUM2RSxNQUFNLENBQUMzRCxtQkFBbUI4RCxRQUFRO29CQUFDO2lCQUFFLElBQUlBO2dCQUNyRixJQUFJd0osU0FBUyxFQUFFO2dCQUNmLElBQUssSUFBSXRQLElBQUksR0FBR0EsSUFBSW9HLE9BQU8sRUFBRXBHLEVBQUc7b0JBQzlCc1AsU0FBUyxFQUFFLENBQUMzSixNQUFNLENBQUMzRCxtQkFBbUJzTixTQUFTdE4sbUJBQW1CcU47Z0JBQ3BFO2dCQUNBLE9BQU9DO1lBQ1Q7UUFDRjtRQUFHO1lBQ0QzTyxLQUFLO1lBQ0xsRCxPQUFPLFNBQVM0TSxjQUFja0YsTUFBTSxFQUFFaE0sS0FBSztnQkFDekMsSUFBSWlNO2dCQUNKLElBQUssV0FBVyxHQUFFN1IsTUFBTSxDQUFDLFVBQVUsQ0FBQzhSLGNBQWMsQ0FBQ0YsU0FBUztvQkFDMURDLFVBQVUsV0FBVyxHQUFFN1IsTUFBTSxDQUFDLFVBQVUsQ0FBQzJMLFlBQVksQ0FBQ2lHLFFBQVFoTTtnQkFDaEUsT0FBTyxJQUFJLENBQUMsR0FBR3ZGLFdBQVcsQ0FBQyxVQUFVLEVBQUV1UixTQUFTO29CQUM5Q0MsVUFBVUQsT0FBT2hNO2dCQUNuQixPQUFPO29CQUNMLElBQUk1QyxNQUFNNEMsTUFBTTVDLEdBQUcsRUFDakJzSixXQUFXM0oseUJBQXlCaUQsT0FBT3pFO29CQUM3QyxJQUFJeUwsWUFBWSxDQUFDLEdBQUdwTSxLQUFLLENBQUMsVUFBVSxFQUFFLHFCQUFxQixPQUFPb1IsV0FBVyxZQUFZQSxPQUFPaEYsU0FBUyxHQUFHO29CQUM1R2lGLFVBQVUsV0FBVyxHQUFFN1IsTUFBTSxDQUFDLFVBQVUsQ0FBQ3dMLGFBQWEsQ0FBQzlLLEtBQUtxUixHQUFHLEVBQUV6TyxTQUFTO3dCQUN4RU4sS0FBS0E7b0JBQ1AsR0FBR3NKLFVBQVU7d0JBQ1hNLFdBQVdBO29CQUNiO2dCQUNGO2dCQUNBLE9BQU9pRjtZQUNUO1FBQ0Y7S0FBRTtBQUNKLEVBQUU3UixPQUFPZ1MsYUFBYTtBQUN0QjlOLGdCQUFnQm5FLE1BQU0sZUFBZTtBQUNyQ21FLGdCQUFnQm5FLE1BQU0sZ0JBQWdCO0lBQ3BDa1MsU0FBUztJQUNUQyxTQUFTO0lBQ1RsRixjQUFjO0lBQ2RtRixXQUFXO0lBQ1huRyxLQUFLO0lBQ0xvRyxZQUFZO0lBQ1pDLFFBQVE7SUFDUnpCLGFBQWE7SUFDYnhELE1BQU07SUFDTjlDLFFBQVEsRUFBRTtJQUNWVixtQkFBbUIsQ0FBQzVJLFFBQVFzUixNQUFNLENBQUNDLEtBQUs7SUFDeEN4RSxrQkFBa0I7SUFDbEJKLGdCQUFnQjtJQUNoQkMsbUJBQW1CO0lBQ25CQyxpQkFBaUI7SUFDakJxQyxNQUFNO0lBQ05zQyxPQUFPO0FBQ1Q7QUFDQTs7Ozs7OztDQU9DLEdBQ0R0TyxnQkFBZ0JuRSxNQUFNLG1CQUFtQixTQUFVMFMsS0FBSztJQUN0RCxJQUFJN00sUUFBUTZNLE1BQU03TSxLQUFLLEVBQ3JCMkUsUUFBUWtJLE1BQU1sSSxLQUFLLEVBQ25CQyxRQUFRaUksTUFBTWpJLEtBQUssRUFDbkJrSSxhQUFhRCxNQUFNQyxVQUFVLEVBQzdCQyxhQUFhRixNQUFNRSxVQUFVLEVBQzdCM0gsVUFBVXlILE1BQU16SCxPQUFPLEVBQ3ZCNEgsV0FBV0gsTUFBTUcsUUFBUSxFQUN6QkMsZ0JBQWdCSixNQUFNSSxhQUFhLEVBQ25DQyxTQUFTTCxNQUFNSyxNQUFNO0lBQ3ZCLElBQUlySSxTQUFTN0UsTUFBTTZFLE1BQU07SUFDekIsSUFBSUgsU0FBU3VJLGNBQWMzSixHQUFHLENBQUMsU0FBVW1ELEtBQUssRUFBRUUsS0FBSztRQUNuRCxJQUFJek0sUUFBUSxDQUFDLEdBQUdtQixZQUFZbUssaUJBQWlCLEVBQUVpQixPQUFPckI7UUFDdEQsSUFBSVAsV0FBVyxjQUFjO1lBQzNCLE9BQU87Z0JBQ0xRLEdBQUcsQ0FBQyxHQUFHaEssWUFBWThSLHVCQUF1QixFQUFFO29CQUMxQ0MsTUFBTXpJO29CQUNOMEksT0FBT1A7b0JBQ1BFLFVBQVVBO29CQUNWdkcsT0FBT0E7b0JBQ1BFLE9BQU9BO2dCQUNUO2dCQUNBckIsR0FBRyxDQUFDLEdBQUc1SyxNQUFNLENBQUMsVUFBVSxFQUFFUixTQUFTLE9BQU8wSyxNQUFNMEksS0FBSyxDQUFDcFQ7Z0JBQ3REQSxPQUFPQTtnQkFDUHVMLFNBQVNnQjtZQUNYO1FBQ0Y7UUFDQSxPQUFPO1lBQ0xwQixHQUFHLENBQUMsR0FBRzNLLE1BQU0sQ0FBQyxVQUFVLEVBQUVSLFNBQVMsT0FBT3lLLE1BQU0ySSxLQUFLLENBQUNwVDtZQUN0RG9MLEdBQUcsQ0FBQyxHQUFHakssWUFBWThSLHVCQUF1QixFQUFFO2dCQUMxQ0MsTUFBTXhJO2dCQUNOeUksT0FBT047Z0JBQ1BDLFVBQVVBO2dCQUNWdkcsT0FBT0E7Z0JBQ1BFLE9BQU9BO1lBQ1Q7WUFDQXpNLE9BQU9BO1lBQ1B1TCxTQUFTZ0I7UUFDWDtJQUNGO0lBQ0EsT0FBT3JJLGNBQWM7UUFDbkJzRyxRQUFRQTtRQUNSRyxRQUFRQTtJQUNWLEdBQUdxSTtBQUNMIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxjYXJ0ZXNpYW5cXExpbmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5MaW5lID0gdm9pZCAwO1xyXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIF9yZWFjdFNtb290aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0LXNtb290aFwiKSk7XHJcbnZhciBfaXNGdW5jdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpKTtcclxudmFyIF9pc05pbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc05pbFwiKSk7XHJcbnZhciBfaXNFcXVhbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0VxdWFsXCIpKTtcclxudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XHJcbnZhciBfQ3VydmUgPSByZXF1aXJlKFwiLi4vc2hhcGUvQ3VydmVcIik7XHJcbnZhciBfRG90ID0gcmVxdWlyZShcIi4uL3NoYXBlL0RvdFwiKTtcclxudmFyIF9MYXllciA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvTGF5ZXJcIik7XHJcbnZhciBfTGFiZWxMaXN0ID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9MYWJlbExpc3RcIik7XHJcbnZhciBfRXJyb3JCYXIgPSByZXF1aXJlKFwiLi9FcnJvckJhclwiKTtcclxudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9EYXRhVXRpbHNcIik7XHJcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XHJcbnZhciBfR2xvYmFsID0gcmVxdWlyZShcIi4uL3V0aWwvR2xvYmFsXCIpO1xyXG52YXIgX0NoYXJ0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9DaGFydFV0aWxzXCIpO1xyXG52YXIgX2V4Y2x1ZGVkID0gW1widHlwZVwiLCBcImxheW91dFwiLCBcImNvbm5lY3ROdWxsc1wiLCBcInJlZlwiXSxcclxuICBfZXhjbHVkZWQyID0gW1wia2V5XCJdO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XHJcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cclxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxyXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cclxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XHJcbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cclxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cclxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cclxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cclxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XHJcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxyXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cclxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cclxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cclxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cclxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxyXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfSAvKipcclxuICogQGZpbGVPdmVydmlldyBMaW5lXHJcbiAqL1xyXG52YXIgTGluZSA9IGV4cG9ydHMuTGluZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1B1cmVDb21wb25lbnQpIHtcclxuICBmdW5jdGlvbiBMaW5lKCkge1xyXG4gICAgdmFyIF90aGlzO1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmUpO1xyXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgICB9XHJcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgTGluZSwgW10uY29uY2F0KGFyZ3MpKTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJzdGF0ZVwiLCB7XHJcbiAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6IHRydWUsXHJcbiAgICAgIHRvdGFsTGVuZ3RoOiAwXHJcbiAgICB9KTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJnZW5lcmF0ZVNpbXBsZVN0cm9rZURhc2hhcnJheVwiLCBmdW5jdGlvbiAodG90YWxMZW5ndGgsIGxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQobGVuZ3RoLCBcInB4IFwiKS5jb25jYXQodG90YWxMZW5ndGggLSBsZW5ndGgsIFwicHhcIik7XHJcbiAgICB9KTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJnZXRTdHJva2VEYXNoYXJyYXlcIiwgZnVuY3Rpb24gKGxlbmd0aCwgdG90YWxMZW5ndGgsIGxpbmVzKSB7XHJcbiAgICAgIHZhciBsaW5lTGVuZ3RoID0gbGluZXMucmVkdWNlKGZ1bmN0aW9uIChwcmUsIG5leHQpIHtcclxuICAgICAgICByZXR1cm4gcHJlICsgbmV4dDtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBpZiBsaW5lTGVuZ3RoIGlzIDAgcmV0dXJuIHRoZSBkZWZhdWx0IHdoZW4gbm8gc3Ryb2tlRGFzaGFycmF5IGlzIHByb3ZpZGVkXHJcbiAgICAgIGlmICghbGluZUxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBfdGhpcy5nZW5lcmF0ZVNpbXBsZVN0cm9rZURhc2hhcnJheSh0b3RhbExlbmd0aCwgbGVuZ3RoKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgY291bnQgPSBNYXRoLmZsb29yKGxlbmd0aCAvIGxpbmVMZW5ndGgpO1xyXG4gICAgICB2YXIgcmVtYWluTGVuZ3RoID0gbGVuZ3RoICUgbGluZUxlbmd0aDtcclxuICAgICAgdmFyIHJlc3RMZW5ndGggPSB0b3RhbExlbmd0aCAtIGxlbmd0aDtcclxuICAgICAgdmFyIHJlbWFpbkxpbmVzID0gW107XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBzdW0gPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBzdW0gKz0gbGluZXNbaV0sICsraSkge1xyXG4gICAgICAgIGlmIChzdW0gKyBsaW5lc1tpXSA+IHJlbWFpbkxlbmd0aCkge1xyXG4gICAgICAgICAgcmVtYWluTGluZXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxpbmVzLnNsaWNlKDAsIGkpKSwgW3JlbWFpbkxlbmd0aCAtIHN1bV0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHZhciBlbXB0eUxpbmVzID0gcmVtYWluTGluZXMubGVuZ3RoICUgMiA9PT0gMCA/IFswLCByZXN0TGVuZ3RoXSA6IFtyZXN0TGVuZ3RoXTtcclxuICAgICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoTGluZS5yZXBlYXQobGluZXMsIGNvdW50KSksIF90b0NvbnN1bWFibGVBcnJheShyZW1haW5MaW5lcyksIGVtcHR5TGluZXMpLm1hcChmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChsaW5lLCBcInB4XCIpO1xyXG4gICAgICB9KS5qb2luKCcsICcpO1xyXG4gICAgfSk7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaWRcIiwgKDAsIF9EYXRhVXRpbHMudW5pcXVlSWQpKCdyZWNoYXJ0cy1saW5lLScpKTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJwYXRoUmVmXCIsIGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgIF90aGlzLm1haW5DdXJ2ZSA9IG5vZGU7XHJcbiAgICB9KTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVBbmltYXRpb25FbmRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uQW5pbWF0aW9uRW5kKSB7XHJcbiAgICAgICAgX3RoaXMucHJvcHMub25BbmltYXRpb25FbmQoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlQW5pbWF0aW9uU3RhcnRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogZmFsc2VcclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkFuaW1hdGlvblN0YXJ0KSB7XHJcbiAgICAgICAgX3RoaXMucHJvcHMub25BbmltYXRpb25TdGFydCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcbiAgX2luaGVyaXRzKExpbmUsIF9QdXJlQ29tcG9uZW50KTtcclxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKExpbmUsIFt7XHJcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgaWYgKCF0aGlzLnByb3BzLmlzQW5pbWF0aW9uQWN0aXZlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB0b3RhbExlbmd0aCA9IHRoaXMuZ2V0VG90YWxMZW5ndGgoKTtcclxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgdG90YWxMZW5ndGg6IHRvdGFsTGVuZ3RoXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJjb21wb25lbnREaWRVcGRhdGVcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XHJcbiAgICAgIGlmICghdGhpcy5wcm9wcy5pc0FuaW1hdGlvbkFjdGl2ZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB2YXIgdG90YWxMZW5ndGggPSB0aGlzLmdldFRvdGFsTGVuZ3RoKCk7XHJcbiAgICAgIGlmICh0b3RhbExlbmd0aCAhPT0gdGhpcy5zdGF0ZS50b3RhbExlbmd0aCkge1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgdG90YWxMZW5ndGg6IHRvdGFsTGVuZ3RoXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiZ2V0VG90YWxMZW5ndGhcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUb3RhbExlbmd0aCgpIHtcclxuICAgICAgdmFyIGN1cnZlRG9tID0gdGhpcy5tYWluQ3VydmU7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIGN1cnZlRG9tICYmIGN1cnZlRG9tLmdldFRvdGFsTGVuZ3RoICYmIGN1cnZlRG9tLmdldFRvdGFsTGVuZ3RoKCkgfHwgMDtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyRXJyb3JCYXJcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJFcnJvckJhcihuZWVkQ2xpcCwgY2xpcFBhdGhJZCkge1xyXG4gICAgICBpZiAodGhpcy5wcm9wcy5pc0FuaW1hdGlvbkFjdGl2ZSAmJiAhdGhpcy5zdGF0ZS5pc0FuaW1hdGlvbkZpbmlzaGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBwb2ludHMgPSBfdGhpcyRwcm9wcy5wb2ludHMsXHJcbiAgICAgICAgeEF4aXMgPSBfdGhpcyRwcm9wcy54QXhpcyxcclxuICAgICAgICB5QXhpcyA9IF90aGlzJHByb3BzLnlBeGlzLFxyXG4gICAgICAgIGxheW91dCA9IF90aGlzJHByb3BzLmxheW91dCxcclxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuO1xyXG4gICAgICB2YXIgZXJyb3JCYXJJdGVtcyA9ICgwLCBfUmVhY3RVdGlscy5maW5kQWxsQnlUeXBlKShjaGlsZHJlbiwgX0Vycm9yQmFyLkVycm9yQmFyKTtcclxuICAgICAgaWYgKCFlcnJvckJhckl0ZW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGRhdGFQb2ludEZvcm1hdHRlciA9IGZ1bmN0aW9uIGRhdGFQb2ludEZvcm1hdHRlcihkYXRhUG9pbnQsIGRhdGFLZXkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgeDogZGF0YVBvaW50LngsXHJcbiAgICAgICAgICB5OiBkYXRhUG9pbnQueSxcclxuICAgICAgICAgIHZhbHVlOiBkYXRhUG9pbnQudmFsdWUsXHJcbiAgICAgICAgICBlcnJvclZhbDogKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShkYXRhUG9pbnQucGF5bG9hZCwgZGF0YUtleSlcclxuICAgICAgICB9O1xyXG4gICAgICB9O1xyXG4gICAgICB2YXIgZXJyb3JCYXJQcm9wcyA9IHtcclxuICAgICAgICBjbGlwUGF0aDogbmVlZENsaXAgPyBcInVybCgjY2xpcFBhdGgtXCIuY29uY2F0KGNsaXBQYXRoSWQsIFwiKVwiKSA6IG51bGxcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCBlcnJvckJhclByb3BzLCBlcnJvckJhckl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQoaXRlbSwge1xyXG4gICAgICAgICAga2V5OiBcImJhci1cIi5jb25jYXQoaXRlbS5wcm9wcy5kYXRhS2V5KSxcclxuICAgICAgICAgIGRhdGE6IHBvaW50cyxcclxuICAgICAgICAgIHhBeGlzOiB4QXhpcyxcclxuICAgICAgICAgIHlBeGlzOiB5QXhpcyxcclxuICAgICAgICAgIGxheW91dDogbGF5b3V0LFxyXG4gICAgICAgICAgZGF0YVBvaW50Rm9ybWF0dGVyOiBkYXRhUG9pbnRGb3JtYXR0ZXJcclxuICAgICAgICB9KTtcclxuICAgICAgfSkpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJEb3RzXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyRG90cyhuZWVkQ2xpcCwgY2xpcERvdCwgY2xpcFBhdGhJZCkge1xyXG4gICAgICB2YXIgaXNBbmltYXRpb25BY3RpdmUgPSB0aGlzLnByb3BzLmlzQW5pbWF0aW9uQWN0aXZlO1xyXG4gICAgICBpZiAoaXNBbmltYXRpb25BY3RpdmUgJiYgIXRoaXMuc3RhdGUuaXNBbmltYXRpb25GaW5pc2hlZCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIGRvdCA9IF90aGlzJHByb3BzMi5kb3QsXHJcbiAgICAgICAgcG9pbnRzID0gX3RoaXMkcHJvcHMyLnBvaW50cyxcclxuICAgICAgICBkYXRhS2V5ID0gX3RoaXMkcHJvcHMyLmRhdGFLZXk7XHJcbiAgICAgIHZhciBsaW5lUHJvcHMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRoaXMucHJvcHMsIGZhbHNlKTtcclxuICAgICAgdmFyIGN1c3RvbURvdFByb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShkb3QsIHRydWUpO1xyXG4gICAgICB2YXIgZG90cyA9IHBvaW50cy5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpKSB7XHJcbiAgICAgICAgdmFyIGRvdFByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xyXG4gICAgICAgICAga2V5OiBcImRvdC1cIi5jb25jYXQoaSksXHJcbiAgICAgICAgICByOiAzXHJcbiAgICAgICAgfSwgbGluZVByb3BzKSwgY3VzdG9tRG90UHJvcHMpLCB7fSwge1xyXG4gICAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgICBjeDogZW50cnkueCxcclxuICAgICAgICAgIGN5OiBlbnRyeS55LFxyXG4gICAgICAgICAgdmFsdWU6IGVudHJ5LnZhbHVlLFxyXG4gICAgICAgICAgZGF0YUtleTogZGF0YUtleSxcclxuICAgICAgICAgIHBheWxvYWQ6IGVudHJ5LnBheWxvYWQsXHJcbiAgICAgICAgICBwb2ludHM6IHBvaW50c1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBMaW5lLnJlbmRlckRvdEl0ZW0oZG90LCBkb3RQcm9wcyk7XHJcbiAgICAgIH0pO1xyXG4gICAgICB2YXIgZG90c1Byb3BzID0ge1xyXG4gICAgICAgIGNsaXBQYXRoOiBuZWVkQ2xpcCA/IFwidXJsKCNjbGlwUGF0aC1cIi5jb25jYXQoY2xpcERvdCA/ICcnIDogJ2RvdHMtJykuY29uY2F0KGNsaXBQYXRoSWQsIFwiKVwiKSA6IG51bGxcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCBfZXh0ZW5kcyh7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWxpbmUtZG90c1wiLFxyXG4gICAgICAgIGtleTogXCJkb3RzXCJcclxuICAgICAgfSwgZG90c1Byb3BzKSwgZG90cyk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJlbmRlckN1cnZlU3RhdGljYWxseVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckN1cnZlU3RhdGljYWxseShwb2ludHMsIG5lZWRDbGlwLCBjbGlwUGF0aElkLCBwcm9wcykge1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcyxcclxuICAgICAgICB0eXBlID0gX3RoaXMkcHJvcHMzLnR5cGUsXHJcbiAgICAgICAgbGF5b3V0ID0gX3RoaXMkcHJvcHMzLmxheW91dCxcclxuICAgICAgICBjb25uZWN0TnVsbHMgPSBfdGhpcyRwcm9wczMuY29ubmVjdE51bGxzLFxyXG4gICAgICAgIHJlZiA9IF90aGlzJHByb3BzMy5yZWYsXHJcbiAgICAgICAgb3RoZXJzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzMywgX2V4Y2x1ZGVkKTtcclxuICAgICAgdmFyIGN1cnZlUHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShvdGhlcnMsIHRydWUpKSwge30sIHtcclxuICAgICAgICBmaWxsOiAnbm9uZScsXHJcbiAgICAgICAgY2xhc3NOYW1lOiAncmVjaGFydHMtbGluZS1jdXJ2ZScsXHJcbiAgICAgICAgY2xpcFBhdGg6IG5lZWRDbGlwID8gXCJ1cmwoI2NsaXBQYXRoLVwiLmNvbmNhdChjbGlwUGF0aElkLCBcIilcIikgOiBudWxsLFxyXG4gICAgICAgIHBvaW50czogcG9pbnRzXHJcbiAgICAgIH0sIHByb3BzKSwge30sIHtcclxuICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgIGxheW91dDogbGF5b3V0LFxyXG4gICAgICAgIGNvbm5lY3ROdWxsczogY29ubmVjdE51bGxzXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfQ3VydmUuQ3VydmUsIF9leHRlbmRzKHt9LCBjdXJ2ZVByb3BzLCB7XHJcbiAgICAgICAgcGF0aFJlZjogdGhpcy5wYXRoUmVmXHJcbiAgICAgIH0pKTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyQ3VydmVXaXRoQW5pbWF0aW9uXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQ3VydmVXaXRoQW5pbWF0aW9uKG5lZWRDbGlwLCBjbGlwUGF0aElkKSB7XHJcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBwb2ludHMgPSBfdGhpcyRwcm9wczQucG9pbnRzLFxyXG4gICAgICAgIHN0cm9rZURhc2hhcnJheSA9IF90aGlzJHByb3BzNC5zdHJva2VEYXNoYXJyYXksXHJcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wczQuaXNBbmltYXRpb25BY3RpdmUsXHJcbiAgICAgICAgYW5pbWF0aW9uQmVnaW4gPSBfdGhpcyRwcm9wczQuYW5pbWF0aW9uQmVnaW4sXHJcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb24gPSBfdGhpcyRwcm9wczQuYW5pbWF0aW9uRHVyYXRpb24sXHJcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nID0gX3RoaXMkcHJvcHM0LmFuaW1hdGlvbkVhc2luZyxcclxuICAgICAgICBhbmltYXRpb25JZCA9IF90aGlzJHByb3BzNC5hbmltYXRpb25JZCxcclxuICAgICAgICBhbmltYXRlTmV3VmFsdWVzID0gX3RoaXMkcHJvcHM0LmFuaW1hdGVOZXdWYWx1ZXMsXHJcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczQud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHM0LmhlaWdodDtcclxuICAgICAgdmFyIF90aGlzJHN0YXRlID0gdGhpcy5zdGF0ZSxcclxuICAgICAgICBwcmV2UG9pbnRzID0gX3RoaXMkc3RhdGUucHJldlBvaW50cyxcclxuICAgICAgICB0b3RhbExlbmd0aCA9IF90aGlzJHN0YXRlLnRvdGFsTGVuZ3RoO1xyXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfcmVhY3RTbW9vdGhbXCJkZWZhdWx0XCJdLCB7XHJcbiAgICAgICAgYmVnaW46IGFuaW1hdGlvbkJlZ2luLFxyXG4gICAgICAgIGR1cmF0aW9uOiBhbmltYXRpb25EdXJhdGlvbixcclxuICAgICAgICBpc0FjdGl2ZTogaXNBbmltYXRpb25BY3RpdmUsXHJcbiAgICAgICAgZWFzaW5nOiBhbmltYXRpb25FYXNpbmcsXHJcbiAgICAgICAgZnJvbToge1xyXG4gICAgICAgICAgdDogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG86IHtcclxuICAgICAgICAgIHQ6IDFcclxuICAgICAgICB9LFxyXG4gICAgICAgIGtleTogXCJsaW5lLVwiLmNvbmNhdChhbmltYXRpb25JZCksXHJcbiAgICAgICAgb25BbmltYXRpb25FbmQ6IHRoaXMuaGFuZGxlQW5pbWF0aW9uRW5kLFxyXG4gICAgICAgIG9uQW5pbWF0aW9uU3RhcnQ6IHRoaXMuaGFuZGxlQW5pbWF0aW9uU3RhcnRcclxuICAgICAgfSwgZnVuY3Rpb24gKF9yZWYpIHtcclxuICAgICAgICB2YXIgdCA9IF9yZWYudDtcclxuICAgICAgICBpZiAocHJldlBvaW50cykge1xyXG4gICAgICAgICAgdmFyIHByZXZQb2ludHNEaWZmRmFjdG9yID0gcHJldlBvaW50cy5sZW5ndGggLyBwb2ludHMubGVuZ3RoO1xyXG4gICAgICAgICAgdmFyIHN0ZXBEYXRhID0gcG9pbnRzLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBwcmV2UG9pbnRJbmRleCA9IE1hdGguZmxvb3IoaW5kZXggKiBwcmV2UG9pbnRzRGlmZkZhY3Rvcik7XHJcbiAgICAgICAgICAgIGlmIChwcmV2UG9pbnRzW3ByZXZQb2ludEluZGV4XSkge1xyXG4gICAgICAgICAgICAgIHZhciBwcmV2ID0gcHJldlBvaW50c1twcmV2UG9pbnRJbmRleF07XHJcbiAgICAgICAgICAgICAgdmFyIGludGVycG9sYXRvclggPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikocHJldi54LCBlbnRyeS54KTtcclxuICAgICAgICAgICAgICB2YXIgaW50ZXJwb2xhdG9yWSA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShwcmV2LnksIGVudHJ5LnkpO1xyXG4gICAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcclxuICAgICAgICAgICAgICAgIHg6IGludGVycG9sYXRvclgodCksXHJcbiAgICAgICAgICAgICAgICB5OiBpbnRlcnBvbGF0b3JZKHQpXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIG1hZ2ljIG51bWJlciBvZiBmYWtpbmcgcHJldmlvdXMgeCBhbmQgeSBsb2NhdGlvblxyXG4gICAgICAgICAgICBpZiAoYW5pbWF0ZU5ld1ZhbHVlcykge1xyXG4gICAgICAgICAgICAgIHZhciBfaW50ZXJwb2xhdG9yWCA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKSh3aWR0aCAqIDIsIGVudHJ5LngpO1xyXG4gICAgICAgICAgICAgIHZhciBfaW50ZXJwb2xhdG9yWSA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShoZWlnaHQgLyAyLCBlbnRyeS55KTtcclxuICAgICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeSksIHt9LCB7XHJcbiAgICAgICAgICAgICAgICB4OiBfaW50ZXJwb2xhdG9yWCh0KSxcclxuICAgICAgICAgICAgICAgIHk6IF9pbnRlcnBvbGF0b3JZKHQpXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xyXG4gICAgICAgICAgICAgIHg6IGVudHJ5LngsXHJcbiAgICAgICAgICAgICAgeTogZW50cnkueVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5yZW5kZXJDdXJ2ZVN0YXRpY2FsbHkoc3RlcERhdGEsIG5lZWRDbGlwLCBjbGlwUGF0aElkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGludGVycG9sYXRvciA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKSgwLCB0b3RhbExlbmd0aCk7XHJcbiAgICAgICAgdmFyIGN1ckxlbmd0aCA9IGludGVycG9sYXRvcih0KTtcclxuICAgICAgICB2YXIgY3VycmVudFN0cm9rZURhc2hhcnJheTtcclxuICAgICAgICBpZiAoc3Ryb2tlRGFzaGFycmF5KSB7XHJcbiAgICAgICAgICB2YXIgbGluZXMgPSBcIlwiLmNvbmNhdChzdHJva2VEYXNoYXJyYXkpLnNwbGl0KC9bLFxcc10rL2dpbSkubWFwKGZ1bmN0aW9uIChudW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobnVtKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgY3VycmVudFN0cm9rZURhc2hhcnJheSA9IF90aGlzMi5nZXRTdHJva2VEYXNoYXJyYXkoY3VyTGVuZ3RoLCB0b3RhbExlbmd0aCwgbGluZXMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjdXJyZW50U3Ryb2tlRGFzaGFycmF5ID0gX3RoaXMyLmdlbmVyYXRlU2ltcGxlU3Ryb2tlRGFzaGFycmF5KHRvdGFsTGVuZ3RoLCBjdXJMZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXMyLnJlbmRlckN1cnZlU3RhdGljYWxseShwb2ludHMsIG5lZWRDbGlwLCBjbGlwUGF0aElkLCB7XHJcbiAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IGN1cnJlbnRTdHJva2VEYXNoYXJyYXlcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJlbmRlckN1cnZlXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQ3VydmUobmVlZENsaXAsIGNsaXBQYXRoSWQpIHtcclxuICAgICAgdmFyIF90aGlzJHByb3BzNSA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgcG9pbnRzID0gX3RoaXMkcHJvcHM1LnBvaW50cyxcclxuICAgICAgICBpc0FuaW1hdGlvbkFjdGl2ZSA9IF90aGlzJHByb3BzNS5pc0FuaW1hdGlvbkFjdGl2ZTtcclxuICAgICAgdmFyIF90aGlzJHN0YXRlMiA9IHRoaXMuc3RhdGUsXHJcbiAgICAgICAgcHJldlBvaW50cyA9IF90aGlzJHN0YXRlMi5wcmV2UG9pbnRzLFxyXG4gICAgICAgIHRvdGFsTGVuZ3RoID0gX3RoaXMkc3RhdGUyLnRvdGFsTGVuZ3RoO1xyXG4gICAgICBpZiAoaXNBbmltYXRpb25BY3RpdmUgJiYgcG9pbnRzICYmIHBvaW50cy5sZW5ndGggJiYgKCFwcmV2UG9pbnRzICYmIHRvdGFsTGVuZ3RoID4gMCB8fCAhKDAsIF9pc0VxdWFsW1wiZGVmYXVsdFwiXSkocHJldlBvaW50cywgcG9pbnRzKSkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJDdXJ2ZVdpdGhBbmltYXRpb24obmVlZENsaXAsIGNsaXBQYXRoSWQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlckN1cnZlU3RhdGljYWxseShwb2ludHMsIG5lZWRDbGlwLCBjbGlwUGF0aElkKTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgICB2YXIgX2ZpbHRlclByb3BzO1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHM2ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBoaWRlID0gX3RoaXMkcHJvcHM2LmhpZGUsXHJcbiAgICAgICAgZG90ID0gX3RoaXMkcHJvcHM2LmRvdCxcclxuICAgICAgICBwb2ludHMgPSBfdGhpcyRwcm9wczYucG9pbnRzLFxyXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzNi5jbGFzc05hbWUsXHJcbiAgICAgICAgeEF4aXMgPSBfdGhpcyRwcm9wczYueEF4aXMsXHJcbiAgICAgICAgeUF4aXMgPSBfdGhpcyRwcm9wczYueUF4aXMsXHJcbiAgICAgICAgdG9wID0gX3RoaXMkcHJvcHM2LnRvcCxcclxuICAgICAgICBsZWZ0ID0gX3RoaXMkcHJvcHM2LmxlZnQsXHJcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczYud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHM2LmhlaWdodCxcclxuICAgICAgICBpc0FuaW1hdGlvbkFjdGl2ZSA9IF90aGlzJHByb3BzNi5pc0FuaW1hdGlvbkFjdGl2ZSxcclxuICAgICAgICBpZCA9IF90aGlzJHByb3BzNi5pZDtcclxuICAgICAgaWYgKGhpZGUgfHwgIXBvaW50cyB8fCAhcG9pbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBpc0FuaW1hdGlvbkZpbmlzaGVkID0gdGhpcy5zdGF0ZS5pc0FuaW1hdGlvbkZpbmlzaGVkO1xyXG4gICAgICB2YXIgaGFzU2luZ2xlUG9pbnQgPSBwb2ludHMubGVuZ3RoID09PSAxO1xyXG4gICAgICB2YXIgbGF5ZXJDbGFzcyA9ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1saW5lJywgY2xhc3NOYW1lKTtcclxuICAgICAgdmFyIG5lZWRDbGlwWCA9IHhBeGlzICYmIHhBeGlzLmFsbG93RGF0YU92ZXJmbG93O1xyXG4gICAgICB2YXIgbmVlZENsaXBZID0geUF4aXMgJiYgeUF4aXMuYWxsb3dEYXRhT3ZlcmZsb3c7XHJcbiAgICAgIHZhciBuZWVkQ2xpcCA9IG5lZWRDbGlwWCB8fCBuZWVkQ2xpcFk7XHJcbiAgICAgIHZhciBjbGlwUGF0aElkID0gKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGlkKSA/IHRoaXMuaWQgOiBpZDtcclxuICAgICAgdmFyIF9yZWYyID0gKF9maWx0ZXJQcm9wcyA9ICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykoZG90LCBmYWxzZSkpICE9PSBudWxsICYmIF9maWx0ZXJQcm9wcyAhPT0gdm9pZCAwID8gX2ZpbHRlclByb3BzIDoge1xyXG4gICAgICAgICAgcjogMyxcclxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAyXHJcbiAgICAgICAgfSxcclxuICAgICAgICBfcmVmMiRyID0gX3JlZjIucixcclxuICAgICAgICByID0gX3JlZjIkciA9PT0gdm9pZCAwID8gMyA6IF9yZWYyJHIsXHJcbiAgICAgICAgX3JlZjIkc3Ryb2tlV2lkdGggPSBfcmVmMi5zdHJva2VXaWR0aCxcclxuICAgICAgICBzdHJva2VXaWR0aCA9IF9yZWYyJHN0cm9rZVdpZHRoID09PSB2b2lkIDAgPyAyIDogX3JlZjIkc3Ryb2tlV2lkdGg7XHJcbiAgICAgIHZhciBfcmVmMyA9ICgwLCBfUmVhY3RVdGlscy5oYXNDbGlwRG90KShkb3QpID8gZG90IDoge30sXHJcbiAgICAgICAgX3JlZjMkY2xpcERvdCA9IF9yZWYzLmNsaXBEb3QsXHJcbiAgICAgICAgY2xpcERvdCA9IF9yZWYzJGNsaXBEb3QgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMyRjbGlwRG90O1xyXG4gICAgICB2YXIgZG90U2l6ZSA9IHIgKiAyICsgc3Ryb2tlV2lkdGg7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xyXG4gICAgICAgIGNsYXNzTmFtZTogbGF5ZXJDbGFzc1xyXG4gICAgICB9LCBuZWVkQ2xpcFggfHwgbmVlZENsaXBZID8gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRlZnNcIiwgbnVsbCwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIsIHtcclxuICAgICAgICBpZDogXCJjbGlwUGF0aC1cIi5jb25jYXQoY2xpcFBhdGhJZClcclxuICAgICAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xyXG4gICAgICAgIHg6IG5lZWRDbGlwWCA/IGxlZnQgOiBsZWZ0IC0gd2lkdGggLyAyLFxyXG4gICAgICAgIHk6IG5lZWRDbGlwWSA/IHRvcCA6IHRvcCAtIGhlaWdodCAvIDIsXHJcbiAgICAgICAgd2lkdGg6IG5lZWRDbGlwWCA/IHdpZHRoIDogd2lkdGggKiAyLFxyXG4gICAgICAgIGhlaWdodDogbmVlZENsaXBZID8gaGVpZ2h0IDogaGVpZ2h0ICogMlxyXG4gICAgICB9KSksICFjbGlwRG90ICYmIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiLCB7XHJcbiAgICAgICAgaWQ6IFwiY2xpcFBhdGgtZG90cy1cIi5jb25jYXQoY2xpcFBhdGhJZClcclxuICAgICAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xyXG4gICAgICAgIHg6IGxlZnQgLSBkb3RTaXplIC8gMixcclxuICAgICAgICB5OiB0b3AgLSBkb3RTaXplIC8gMixcclxuICAgICAgICB3aWR0aDogd2lkdGggKyBkb3RTaXplLFxyXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgZG90U2l6ZVxyXG4gICAgICB9KSkpIDogbnVsbCwgIWhhc1NpbmdsZVBvaW50ICYmIHRoaXMucmVuZGVyQ3VydmUobmVlZENsaXAsIGNsaXBQYXRoSWQpLCB0aGlzLnJlbmRlckVycm9yQmFyKG5lZWRDbGlwLCBjbGlwUGF0aElkKSwgKGhhc1NpbmdsZVBvaW50IHx8IGRvdCkgJiYgdGhpcy5yZW5kZXJEb3RzKG5lZWRDbGlwLCBjbGlwRG90LCBjbGlwUGF0aElkKSwgKCFpc0FuaW1hdGlvbkFjdGl2ZSB8fCBpc0FuaW1hdGlvbkZpbmlzaGVkKSAmJiBfTGFiZWxMaXN0LkxhYmVsTGlzdC5yZW5kZXJDYWxsQnlQYXJlbnQodGhpcy5wcm9wcywgcG9pbnRzKSk7XHJcbiAgICB9XHJcbiAgfV0sIFt7XHJcbiAgICBrZXk6IFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKSB7XHJcbiAgICAgIGlmIChuZXh0UHJvcHMuYW5pbWF0aW9uSWQgIT09IHByZXZTdGF0ZS5wcmV2QW5pbWF0aW9uSWQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgcHJldkFuaW1hdGlvbklkOiBuZXh0UHJvcHMuYW5pbWF0aW9uSWQsXHJcbiAgICAgICAgICBjdXJQb2ludHM6IG5leHRQcm9wcy5wb2ludHMsXHJcbiAgICAgICAgICBwcmV2UG9pbnRzOiBwcmV2U3RhdGUuY3VyUG9pbnRzXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobmV4dFByb3BzLnBvaW50cyAhPT0gcHJldlN0YXRlLmN1clBvaW50cykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBjdXJQb2ludHM6IG5leHRQcm9wcy5wb2ludHNcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZXBlYXRcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBlYXQobGluZXMsIGNvdW50KSB7XHJcbiAgICAgIHZhciBsaW5lc1VuaXQgPSBsaW5lcy5sZW5ndGggJSAyICE9PSAwID8gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShsaW5lcyksIFswXSkgOiBsaW5lcztcclxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcclxuICAgICAgICByZXN1bHQgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHJlc3VsdCksIF90b0NvbnN1bWFibGVBcnJheShsaW5lc1VuaXQpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJEb3RJdGVtXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyRG90SXRlbShvcHRpb24sIHByb3BzKSB7XHJcbiAgICAgIHZhciBkb3RJdGVtO1xyXG4gICAgICBpZiAoIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KG9wdGlvbikpIHtcclxuICAgICAgICBkb3RJdGVtID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KG9wdGlvbiwgcHJvcHMpO1xyXG4gICAgICB9IGVsc2UgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9wdGlvbikpIHtcclxuICAgICAgICBkb3RJdGVtID0gb3B0aW9uKHByb3BzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIga2V5ID0gcHJvcHMua2V5LFxyXG4gICAgICAgICAgZG90UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZDIpO1xyXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtbGluZS1kb3QnLCB0eXBlb2Ygb3B0aW9uICE9PSAnYm9vbGVhbicgPyBvcHRpb24uY2xhc3NOYW1lIDogJycpO1xyXG4gICAgICAgIGRvdEl0ZW0gPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9Eb3QuRG90LCBfZXh0ZW5kcyh7XHJcbiAgICAgICAgICBrZXk6IGtleVxyXG4gICAgICAgIH0sIGRvdFByb3BzLCB7XHJcbiAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZG90SXRlbTtcclxuICAgIH1cclxuICB9XSk7XHJcbn0oX3JlYWN0LlB1cmVDb21wb25lbnQpO1xyXG5fZGVmaW5lUHJvcGVydHkoTGluZSwgXCJkaXNwbGF5TmFtZVwiLCAnTGluZScpO1xyXG5fZGVmaW5lUHJvcGVydHkoTGluZSwgXCJkZWZhdWx0UHJvcHNcIiwge1xyXG4gIHhBeGlzSWQ6IDAsXHJcbiAgeUF4aXNJZDogMCxcclxuICBjb25uZWN0TnVsbHM6IGZhbHNlLFxyXG4gIGFjdGl2ZURvdDogdHJ1ZSxcclxuICBkb3Q6IHRydWUsXHJcbiAgbGVnZW5kVHlwZTogJ2xpbmUnLFxyXG4gIHN0cm9rZTogJyMzMTgyYmQnLFxyXG4gIHN0cm9rZVdpZHRoOiAxLFxyXG4gIGZpbGw6ICcjZmZmJyxcclxuICBwb2ludHM6IFtdLFxyXG4gIGlzQW5pbWF0aW9uQWN0aXZlOiAhX0dsb2JhbC5HbG9iYWwuaXNTc3IsXHJcbiAgYW5pbWF0ZU5ld1ZhbHVlczogdHJ1ZSxcclxuICBhbmltYXRpb25CZWdpbjogMCxcclxuICBhbmltYXRpb25EdXJhdGlvbjogMTUwMCxcclxuICBhbmltYXRpb25FYXNpbmc6ICdlYXNlJyxcclxuICBoaWRlOiBmYWxzZSxcclxuICBsYWJlbDogZmFsc2VcclxufSk7XHJcbi8qKlxyXG4gKiBDb21wb3NlIHRoZSBkYXRhIG9mIGVhY2ggZ3JvdXBcclxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFRoZSBwcm9wcyBmcm9tIHRoZSBjb21wb25lbnRcclxuICogQHBhcmFtICB7T2JqZWN0fSB4QXhpcyAgIFRoZSBjb25maWd1cmF0aW9uIG9mIHgtYXhpc1xyXG4gKiBAcGFyYW0gIHtPYmplY3R9IHlBeGlzICAgVGhlIGNvbmZpZ3VyYXRpb24gb2YgeS1heGlzXHJcbiAqIEBwYXJhbSAge1N0cmluZ30gZGF0YUtleSBUaGUgdW5pcXVlIGtleSBvZiBhIGdyb3VwXHJcbiAqIEByZXR1cm4ge0FycmF5fSAgQ29tcG9zZWQgZGF0YVxyXG4gKi9cclxuX2RlZmluZVByb3BlcnR5KExpbmUsIFwiZ2V0Q29tcG9zZWREYXRhXCIsIGZ1bmN0aW9uIChfcmVmNCkge1xyXG4gIHZhciBwcm9wcyA9IF9yZWY0LnByb3BzLFxyXG4gICAgeEF4aXMgPSBfcmVmNC54QXhpcyxcclxuICAgIHlBeGlzID0gX3JlZjQueUF4aXMsXHJcbiAgICB4QXhpc1RpY2tzID0gX3JlZjQueEF4aXNUaWNrcyxcclxuICAgIHlBeGlzVGlja3MgPSBfcmVmNC55QXhpc1RpY2tzLFxyXG4gICAgZGF0YUtleSA9IF9yZWY0LmRhdGFLZXksXHJcbiAgICBiYW5kU2l6ZSA9IF9yZWY0LmJhbmRTaXplLFxyXG4gICAgZGlzcGxheWVkRGF0YSA9IF9yZWY0LmRpc3BsYXllZERhdGEsXHJcbiAgICBvZmZzZXQgPSBfcmVmNC5vZmZzZXQ7XHJcbiAgdmFyIGxheW91dCA9IHByb3BzLmxheW91dDtcclxuICB2YXIgcG9pbnRzID0gZGlzcGxheWVkRGF0YS5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xyXG4gICAgdmFyIHZhbHVlID0gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShlbnRyeSwgZGF0YUtleSk7XHJcbiAgICBpZiAobGF5b3V0ID09PSAnaG9yaXpvbnRhbCcpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB4OiAoMCwgX0NoYXJ0VXRpbHMuZ2V0Q2F0ZUNvb3JkaW5hdGVPZkxpbmUpKHtcclxuICAgICAgICAgIGF4aXM6IHhBeGlzLFxyXG4gICAgICAgICAgdGlja3M6IHhBeGlzVGlja3MsXHJcbiAgICAgICAgICBiYW5kU2l6ZTogYmFuZFNpemUsXHJcbiAgICAgICAgICBlbnRyeTogZW50cnksXHJcbiAgICAgICAgICBpbmRleDogaW5kZXhcclxuICAgICAgICB9KSxcclxuICAgICAgICB5OiAoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkodmFsdWUpID8gbnVsbCA6IHlBeGlzLnNjYWxlKHZhbHVlKSxcclxuICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgcGF5bG9hZDogZW50cnlcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6ICgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKSh2YWx1ZSkgPyBudWxsIDogeEF4aXMuc2NhbGUodmFsdWUpLFxyXG4gICAgICB5OiAoMCwgX0NoYXJ0VXRpbHMuZ2V0Q2F0ZUNvb3JkaW5hdGVPZkxpbmUpKHtcclxuICAgICAgICBheGlzOiB5QXhpcyxcclxuICAgICAgICB0aWNrczogeUF4aXNUaWNrcyxcclxuICAgICAgICBiYW5kU2l6ZTogYmFuZFNpemUsXHJcbiAgICAgICAgZW50cnk6IGVudHJ5LFxyXG4gICAgICAgIGluZGV4OiBpbmRleFxyXG4gICAgICB9KSxcclxuICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICBwYXlsb2FkOiBlbnRyeVxyXG4gICAgfTtcclxuICB9KTtcclxuICByZXR1cm4gX29iamVjdFNwcmVhZCh7XHJcbiAgICBwb2ludHM6IHBvaW50cyxcclxuICAgIGxheW91dDogbGF5b3V0XHJcbiAgfSwgb2Zmc2V0KTtcclxufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTGluZSIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9yZWFjdFNtb290aCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfaXNGdW5jdGlvbiIsIl9pc05pbCIsIl9pc0VxdWFsIiwiX2Nsc3giLCJfQ3VydmUiLCJfRG90IiwiX0xheWVyIiwiX0xhYmVsTGlzdCIsIl9FcnJvckJhciIsIl9EYXRhVXRpbHMiLCJfUmVhY3RVdGlscyIsIl9HbG9iYWwiLCJfQ2hhcnRVdGlscyIsIl9leGNsdWRlZCIsIl9leGNsdWRlZDIiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwicHJvdG90eXBlIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwic291cmNlIiwiZXhjbHVkZWQiLCJ0YXJnZXQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImtleSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNvdXJjZVN5bWJvbEtleXMiLCJsZW5ndGgiLCJpbmRleE9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJhcmd1bWVudHMiLCJhcHBseSIsIm93bktleXMiLCJrZXlzIiwiZmlsdGVyIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiYXJyIiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIlR5cGVFcnJvciIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwiaXRlciIsImlzQXJyYXkiLCJsZW4iLCJhcnIyIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9Qcm9wZXJ0eUtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsInAiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsIl9QdXJlQ29tcG9uZW50IiwiX3RoaXMiLCJfbGVuIiwiYXJncyIsIl9rZXkiLCJjb25jYXQiLCJpc0FuaW1hdGlvbkZpbmlzaGVkIiwidG90YWxMZW5ndGgiLCJsaW5lcyIsImxpbmVMZW5ndGgiLCJyZWR1Y2UiLCJwcmUiLCJuZXh0IiwiZ2VuZXJhdGVTaW1wbGVTdHJva2VEYXNoYXJyYXkiLCJjb3VudCIsIk1hdGgiLCJmbG9vciIsInJlbWFpbkxlbmd0aCIsInJlc3RMZW5ndGgiLCJyZW1haW5MaW5lcyIsInN1bSIsImVtcHR5TGluZXMiLCJyZXBlYXQiLCJtYXAiLCJsaW5lIiwiam9pbiIsInVuaXF1ZUlkIiwibm9kZSIsIm1haW5DdXJ2ZSIsInNldFN0YXRlIiwib25BbmltYXRpb25FbmQiLCJvbkFuaW1hdGlvblN0YXJ0IiwiY29tcG9uZW50RGlkTW91bnQiLCJpc0FuaW1hdGlvbkFjdGl2ZSIsImdldFRvdGFsTGVuZ3RoIiwiY29tcG9uZW50RGlkVXBkYXRlIiwic3RhdGUiLCJjdXJ2ZURvbSIsImVyciIsInJlbmRlckVycm9yQmFyIiwibmVlZENsaXAiLCJjbGlwUGF0aElkIiwiX3RoaXMkcHJvcHMiLCJwb2ludHMiLCJ4QXhpcyIsInlBeGlzIiwibGF5b3V0IiwiY2hpbGRyZW4iLCJlcnJvckJhckl0ZW1zIiwiZmluZEFsbEJ5VHlwZSIsIkVycm9yQmFyIiwiZGF0YVBvaW50Rm9ybWF0dGVyIiwiZGF0YVBvaW50IiwiZGF0YUtleSIsIngiLCJ5IiwiZXJyb3JWYWwiLCJnZXRWYWx1ZUJ5RGF0YUtleSIsInBheWxvYWQiLCJlcnJvckJhclByb3BzIiwiY2xpcFBhdGgiLCJjcmVhdGVFbGVtZW50IiwiTGF5ZXIiLCJpdGVtIiwiY2xvbmVFbGVtZW50IiwiZGF0YSIsInJlbmRlckRvdHMiLCJjbGlwRG90IiwiX3RoaXMkcHJvcHMyIiwiZG90IiwibGluZVByb3BzIiwiZmlsdGVyUHJvcHMiLCJjdXN0b21Eb3RQcm9wcyIsImRvdHMiLCJlbnRyeSIsImRvdFByb3BzIiwiaW5kZXgiLCJjeCIsImN5IiwicmVuZGVyRG90SXRlbSIsImRvdHNQcm9wcyIsImNsYXNzTmFtZSIsInJlbmRlckN1cnZlU3RhdGljYWxseSIsIl90aGlzJHByb3BzMyIsInR5cGUiLCJjb25uZWN0TnVsbHMiLCJyZWYiLCJvdGhlcnMiLCJjdXJ2ZVByb3BzIiwiZmlsbCIsIkN1cnZlIiwicGF0aFJlZiIsInJlbmRlckN1cnZlV2l0aEFuaW1hdGlvbiIsIl90aGlzMiIsIl90aGlzJHByb3BzNCIsInN0cm9rZURhc2hhcnJheSIsImFuaW1hdGlvbkJlZ2luIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJhbmltYXRpb25FYXNpbmciLCJhbmltYXRpb25JZCIsImFuaW1hdGVOZXdWYWx1ZXMiLCJ3aWR0aCIsImhlaWdodCIsIl90aGlzJHN0YXRlIiwicHJldlBvaW50cyIsImJlZ2luIiwiZHVyYXRpb24iLCJpc0FjdGl2ZSIsImVhc2luZyIsInRvIiwiaGFuZGxlQW5pbWF0aW9uRW5kIiwiaGFuZGxlQW5pbWF0aW9uU3RhcnQiLCJfcmVmIiwicHJldlBvaW50c0RpZmZGYWN0b3IiLCJzdGVwRGF0YSIsInByZXZQb2ludEluZGV4IiwicHJldiIsImludGVycG9sYXRvclgiLCJpbnRlcnBvbGF0ZU51bWJlciIsImludGVycG9sYXRvclkiLCJfaW50ZXJwb2xhdG9yWCIsIl9pbnRlcnBvbGF0b3JZIiwiaW50ZXJwb2xhdG9yIiwiY3VyTGVuZ3RoIiwiY3VycmVudFN0cm9rZURhc2hhcnJheSIsInNwbGl0IiwibnVtIiwicGFyc2VGbG9hdCIsImdldFN0cm9rZURhc2hhcnJheSIsInJlbmRlckN1cnZlIiwiX3RoaXMkcHJvcHM1IiwiX3RoaXMkc3RhdGUyIiwicmVuZGVyIiwiX2ZpbHRlclByb3BzIiwiX3RoaXMkcHJvcHM2IiwiaGlkZSIsInRvcCIsImxlZnQiLCJpZCIsImhhc1NpbmdsZVBvaW50IiwibGF5ZXJDbGFzcyIsIm5lZWRDbGlwWCIsImFsbG93RGF0YU92ZXJmbG93IiwibmVlZENsaXBZIiwiX3JlZjIiLCJzdHJva2VXaWR0aCIsIl9yZWYyJHIiLCJfcmVmMiRzdHJva2VXaWR0aCIsIl9yZWYzIiwiaGFzQ2xpcERvdCIsIl9yZWYzJGNsaXBEb3QiLCJkb3RTaXplIiwiTGFiZWxMaXN0IiwicmVuZGVyQ2FsbEJ5UGFyZW50IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwibmV4dFByb3BzIiwicHJldlN0YXRlIiwicHJldkFuaW1hdGlvbklkIiwiY3VyUG9pbnRzIiwibGluZXNVbml0IiwicmVzdWx0Iiwib3B0aW9uIiwiZG90SXRlbSIsImlzVmFsaWRFbGVtZW50IiwiRG90IiwiUHVyZUNvbXBvbmVudCIsInhBeGlzSWQiLCJ5QXhpc0lkIiwiYWN0aXZlRG90IiwibGVnZW5kVHlwZSIsInN0cm9rZSIsIkdsb2JhbCIsImlzU3NyIiwibGFiZWwiLCJfcmVmNCIsInhBeGlzVGlja3MiLCJ5QXhpc1RpY2tzIiwiYmFuZFNpemUiLCJkaXNwbGF5ZWREYXRhIiwib2Zmc2V0IiwiZ2V0Q2F0ZUNvb3JkaW5hdGVPZkxpbmUiLCJheGlzIiwidGlja3MiLCJzY2FsZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/cartesian/Line.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/cartesian/ReferenceArea.js":
/*!**************************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/ReferenceArea.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ReferenceArea = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _Label = __webpack_require__(/*! ../component/Label */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Label.js\");\nvar _CartesianUtils = __webpack_require__(/*! ../util/CartesianUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/CartesianUtils.js\");\nvar _IfOverflowMatches = __webpack_require__(/*! ../util/IfOverflowMatches */ \"(pages-dir-node)/./node_modules/recharts/lib/util/IfOverflowMatches.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _LogUtils = __webpack_require__(/*! ../util/LogUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/LogUtils.js\");\nvar _Rectangle = __webpack_require__(/*! ../shape/Rectangle */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Rectangle.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Reference Line\r\n */ \nvar getRect = function getRect(hasX1, hasX2, hasY1, hasY2, props) {\n    var xValue1 = props.x1, xValue2 = props.x2, yValue1 = props.y1, yValue2 = props.y2, xAxis = props.xAxis, yAxis = props.yAxis;\n    if (!xAxis || !yAxis) return null;\n    var scales = (0, _CartesianUtils.createLabeledScales)({\n        x: xAxis.scale,\n        y: yAxis.scale\n    });\n    var p1 = {\n        x: hasX1 ? scales.x.apply(xValue1, {\n            position: 'start'\n        }) : scales.x.rangeMin,\n        y: hasY1 ? scales.y.apply(yValue1, {\n            position: 'start'\n        }) : scales.y.rangeMin\n    };\n    var p2 = {\n        x: hasX2 ? scales.x.apply(xValue2, {\n            position: 'end'\n        }) : scales.x.rangeMax,\n        y: hasY2 ? scales.y.apply(yValue2, {\n            position: 'end'\n        }) : scales.y.rangeMax\n    };\n    if ((0, _IfOverflowMatches.ifOverflowMatches)(props, 'discard') && (!scales.isInRange(p1) || !scales.isInRange(p2))) {\n        return null;\n    }\n    return (0, _CartesianUtils.rectWithPoints)(p1, p2);\n};\n// eslint-disable-next-line react/prefer-stateless-function -- requires static defaultProps\nvar ReferenceArea = exports.ReferenceArea = /*#__PURE__*/ function(_React$Component) {\n    function ReferenceArea() {\n        _classCallCheck(this, ReferenceArea);\n        return _callSuper(this, ReferenceArea, arguments);\n    }\n    _inherits(ReferenceArea, _React$Component);\n    return _createClass(ReferenceArea, [\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props = this.props, x1 = _this$props.x1, x2 = _this$props.x2, y1 = _this$props.y1, y2 = _this$props.y2, className = _this$props.className, alwaysShow = _this$props.alwaysShow, clipPathId = _this$props.clipPathId;\n                (0, _LogUtils.warn)(alwaysShow === undefined, 'The alwaysShow prop is deprecated. Please use ifOverflow=\"extendDomain\" instead.');\n                var hasX1 = (0, _DataUtils.isNumOrStr)(x1);\n                var hasX2 = (0, _DataUtils.isNumOrStr)(x2);\n                var hasY1 = (0, _DataUtils.isNumOrStr)(y1);\n                var hasY2 = (0, _DataUtils.isNumOrStr)(y2);\n                var shape = this.props.shape;\n                if (!hasX1 && !hasX2 && !hasY1 && !hasY2 && !shape) {\n                    return null;\n                }\n                var rect = getRect(hasX1, hasX2, hasY1, hasY2, this.props);\n                if (!rect && !shape) {\n                    return null;\n                }\n                var clipPath = (0, _IfOverflowMatches.ifOverflowMatches)(this.props, 'hidden') ? \"url(#\".concat(clipPathId, \")\") : undefined;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: (0, _clsx[\"default\"])('recharts-reference-area', className)\n                }, ReferenceArea.renderRect(shape, _objectSpread(_objectSpread({\n                    clipPath: clipPath\n                }, (0, _ReactUtils.filterProps)(this.props, true)), rect)), _Label.Label.renderCallByParent(this.props, rect));\n            }\n        }\n    ]);\n}(_react[\"default\"].Component);\n_defineProperty(ReferenceArea, \"displayName\", 'ReferenceArea');\n_defineProperty(ReferenceArea, \"defaultProps\", {\n    isFront: false,\n    ifOverflow: 'discard',\n    xAxisId: 0,\n    yAxisId: 0,\n    r: 10,\n    fill: '#ccc',\n    fillOpacity: 0.5,\n    stroke: 'none',\n    strokeWidth: 1\n});\n_defineProperty(ReferenceArea, \"renderRect\", function(option, props) {\n    var rect;\n    if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n        rect = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n    } else if ((0, _isFunction[\"default\"])(option)) {\n        rect = option(props);\n    } else {\n        rect = /*#__PURE__*/ _react[\"default\"].createElement(_Rectangle.Rectangle, _extends({}, props, {\n            className: \"recharts-reference-area-rect\"\n        }));\n    }\n    return rect;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2FydGVzaWFuL1JlZmVyZW5jZUFyZWEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELHFCQUFxQixHQUFHLEtBQUs7QUFDN0IsSUFBSUcsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNuRCxJQUFJQyxjQUFjRix1QkFBdUJDLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJRSxRQUFRSCx1QkFBdUJDLG1CQUFPQSxDQUFDLHVCQUFNO0FBQ2pELElBQUlHLFNBQVNILG1CQUFPQSxDQUFDLDJGQUFvQjtBQUN6QyxJQUFJSSxTQUFTSixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDekMsSUFBSUssa0JBQWtCTCxtQkFBT0EsQ0FBQyxtR0FBd0I7QUFDdEQsSUFBSU0scUJBQXFCTixtQkFBT0EsQ0FBQyx5R0FBMkI7QUFDNUQsSUFBSU8sYUFBYVAsbUJBQU9BLENBQUMseUZBQW1CO0FBQzVDLElBQUlRLFlBQVlSLG1CQUFPQSxDQUFDLHVGQUFrQjtBQUMxQyxJQUFJUyxhQUFhVCxtQkFBT0EsQ0FBQywyRkFBb0I7QUFDN0MsSUFBSVUsY0FBY1YsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLFNBQVNELHVCQUF1QlksR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRTtJQUFhQSxXQUFXcEIsT0FBT3FCLE1BQU0sR0FBR3JCLE9BQU9xQixNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVQyxNQUFNO1FBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUFFLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUFFLElBQUssSUFBSUksT0FBT0QsT0FBUTtnQkFBRSxJQUFJ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Q0FBQ21JLFNBQVM7QUFDN0J2RixnQkFBZ0I3QyxlQUFlLGVBQWU7QUFDOUM2QyxnQkFBZ0I3QyxlQUFlLGdCQUFnQjtJQUM3Q3FJLFNBQVM7SUFDVEMsWUFBWTtJQUNaQyxTQUFTO0lBQ1RDLFNBQVM7SUFDVHJHLEdBQUc7SUFDSHNHLE1BQU07SUFDTkMsYUFBYTtJQUNiQyxRQUFRO0lBQ1JDLGFBQWE7QUFDZjtBQUNBL0YsZ0JBQWdCN0MsZUFBZSxjQUFjLFNBQVU2SSxNQUFNLEVBQUV4RixLQUFLO0lBQ2xFLElBQUlzRTtJQUNKLElBQUssV0FBVyxHQUFFMUgsTUFBTSxDQUFDLFVBQVUsQ0FBQzZJLGNBQWMsQ0FBQ0QsU0FBUztRQUMxRGxCLE9BQU8sV0FBVyxHQUFFMUgsTUFBTSxDQUFDLFVBQVUsQ0FBQzhJLFlBQVksQ0FBQ0YsUUFBUXhGO0lBQzdELE9BQU8sSUFBSSxDQUFDLEdBQUdqRCxXQUFXLENBQUMsVUFBVSxFQUFFeUksU0FBUztRQUM5Q2xCLE9BQU9rQixPQUFPeEY7SUFDaEIsT0FBTztRQUNMc0UsT0FBTyxXQUFXLEdBQUUxSCxNQUFNLENBQUMsVUFBVSxDQUFDNkgsYUFBYSxDQUFDbEgsV0FBV29JLFNBQVMsRUFBRWhJLFNBQVMsQ0FBQyxHQUFHcUMsT0FBTztZQUM1RitELFdBQVc7UUFDYjtJQUNGO0lBQ0EsT0FBT087QUFDVCIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcY2FydGVzaWFuXFxSZWZlcmVuY2VBcmVhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuUmVmZXJlbmNlQXJlYSA9IHZvaWQgMDtcclxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xyXG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcclxudmFyIF9MYXllciA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvTGF5ZXJcIik7XHJcbnZhciBfTGFiZWwgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50L0xhYmVsXCIpO1xyXG52YXIgX0NhcnRlc2lhblV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvQ2FydGVzaWFuVXRpbHNcIik7XHJcbnZhciBfSWZPdmVyZmxvd01hdGNoZXMgPSByZXF1aXJlKFwiLi4vdXRpbC9JZk92ZXJmbG93TWF0Y2hlc1wiKTtcclxudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9EYXRhVXRpbHNcIik7XHJcbnZhciBfTG9nVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9Mb2dVdGlsc1wiKTtcclxudmFyIF9SZWN0YW5nbGUgPSByZXF1aXJlKFwiLi4vc2hhcGUvUmVjdGFuZ2xlXCIpO1xyXG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XHJcbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cclxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cclxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cclxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cclxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XHJcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxyXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cclxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cclxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cclxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cclxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxyXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfSAvKipcclxuICogQGZpbGVPdmVydmlldyBSZWZlcmVuY2UgTGluZVxyXG4gKi9cclxudmFyIGdldFJlY3QgPSBmdW5jdGlvbiBnZXRSZWN0KGhhc1gxLCBoYXNYMiwgaGFzWTEsIGhhc1kyLCBwcm9wcykge1xyXG4gIHZhciB4VmFsdWUxID0gcHJvcHMueDEsXHJcbiAgICB4VmFsdWUyID0gcHJvcHMueDIsXHJcbiAgICB5VmFsdWUxID0gcHJvcHMueTEsXHJcbiAgICB5VmFsdWUyID0gcHJvcHMueTIsXHJcbiAgICB4QXhpcyA9IHByb3BzLnhBeGlzLFxyXG4gICAgeUF4aXMgPSBwcm9wcy55QXhpcztcclxuICBpZiAoIXhBeGlzIHx8ICF5QXhpcykgcmV0dXJuIG51bGw7XHJcbiAgdmFyIHNjYWxlcyA9ICgwLCBfQ2FydGVzaWFuVXRpbHMuY3JlYXRlTGFiZWxlZFNjYWxlcykoe1xyXG4gICAgeDogeEF4aXMuc2NhbGUsXHJcbiAgICB5OiB5QXhpcy5zY2FsZVxyXG4gIH0pO1xyXG4gIHZhciBwMSA9IHtcclxuICAgIHg6IGhhc1gxID8gc2NhbGVzLnguYXBwbHkoeFZhbHVlMSwge1xyXG4gICAgICBwb3NpdGlvbjogJ3N0YXJ0J1xyXG4gICAgfSkgOiBzY2FsZXMueC5yYW5nZU1pbixcclxuICAgIHk6IGhhc1kxID8gc2NhbGVzLnkuYXBwbHkoeVZhbHVlMSwge1xyXG4gICAgICBwb3NpdGlvbjogJ3N0YXJ0J1xyXG4gICAgfSkgOiBzY2FsZXMueS5yYW5nZU1pblxyXG4gIH07XHJcbiAgdmFyIHAyID0ge1xyXG4gICAgeDogaGFzWDIgPyBzY2FsZXMueC5hcHBseSh4VmFsdWUyLCB7XHJcbiAgICAgIHBvc2l0aW9uOiAnZW5kJ1xyXG4gICAgfSkgOiBzY2FsZXMueC5yYW5nZU1heCxcclxuICAgIHk6IGhhc1kyID8gc2NhbGVzLnkuYXBwbHkoeVZhbHVlMiwge1xyXG4gICAgICBwb3NpdGlvbjogJ2VuZCdcclxuICAgIH0pIDogc2NhbGVzLnkucmFuZ2VNYXhcclxuICB9O1xyXG4gIGlmICgoMCwgX0lmT3ZlcmZsb3dNYXRjaGVzLmlmT3ZlcmZsb3dNYXRjaGVzKShwcm9wcywgJ2Rpc2NhcmQnKSAmJiAoIXNjYWxlcy5pc0luUmFuZ2UocDEpIHx8ICFzY2FsZXMuaXNJblJhbmdlKHAyKSkpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICByZXR1cm4gKDAsIF9DYXJ0ZXNpYW5VdGlscy5yZWN0V2l0aFBvaW50cykocDEsIHAyKTtcclxufTtcclxuXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9wcmVmZXItc3RhdGVsZXNzLWZ1bmN0aW9uIC0tIHJlcXVpcmVzIHN0YXRpYyBkZWZhdWx0UHJvcHNcclxudmFyIFJlZmVyZW5jZUFyZWEgPSBleHBvcnRzLlJlZmVyZW5jZUFyZWEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcclxuICBmdW5jdGlvbiBSZWZlcmVuY2VBcmVhKCkge1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlZmVyZW5jZUFyZWEpO1xyXG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgUmVmZXJlbmNlQXJlYSwgYXJndW1lbnRzKTtcclxuICB9XHJcbiAgX2luaGVyaXRzKFJlZmVyZW5jZUFyZWEsIF9SZWFjdCRDb21wb25lbnQpO1xyXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUmVmZXJlbmNlQXJlYSwgW3tcclxuICAgIGtleTogXCJyZW5kZXJcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgeDEgPSBfdGhpcyRwcm9wcy54MSxcclxuICAgICAgICB4MiA9IF90aGlzJHByb3BzLngyLFxyXG4gICAgICAgIHkxID0gX3RoaXMkcHJvcHMueTEsXHJcbiAgICAgICAgeTIgPSBfdGhpcyRwcm9wcy55MixcclxuICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wcy5jbGFzc05hbWUsXHJcbiAgICAgICAgYWx3YXlzU2hvdyA9IF90aGlzJHByb3BzLmFsd2F5c1Nob3csXHJcbiAgICAgICAgY2xpcFBhdGhJZCA9IF90aGlzJHByb3BzLmNsaXBQYXRoSWQ7XHJcbiAgICAgICgwLCBfTG9nVXRpbHMud2FybikoYWx3YXlzU2hvdyA9PT0gdW5kZWZpbmVkLCAnVGhlIGFsd2F5c1Nob3cgcHJvcCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIGlmT3ZlcmZsb3c9XCJleHRlbmREb21haW5cIiBpbnN0ZWFkLicpO1xyXG4gICAgICB2YXIgaGFzWDEgPSAoMCwgX0RhdGFVdGlscy5pc051bU9yU3RyKSh4MSk7XHJcbiAgICAgIHZhciBoYXNYMiA9ICgwLCBfRGF0YVV0aWxzLmlzTnVtT3JTdHIpKHgyKTtcclxuICAgICAgdmFyIGhhc1kxID0gKDAsIF9EYXRhVXRpbHMuaXNOdW1PclN0cikoeTEpO1xyXG4gICAgICB2YXIgaGFzWTIgPSAoMCwgX0RhdGFVdGlscy5pc051bU9yU3RyKSh5Mik7XHJcbiAgICAgIHZhciBzaGFwZSA9IHRoaXMucHJvcHMuc2hhcGU7XHJcbiAgICAgIGlmICghaGFzWDEgJiYgIWhhc1gyICYmICFoYXNZMSAmJiAhaGFzWTIgJiYgIXNoYXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHJlY3QgPSBnZXRSZWN0KGhhc1gxLCBoYXNYMiwgaGFzWTEsIGhhc1kyLCB0aGlzLnByb3BzKTtcclxuICAgICAgaWYgKCFyZWN0ICYmICFzaGFwZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBjbGlwUGF0aCA9ICgwLCBfSWZPdmVyZmxvd01hdGNoZXMuaWZPdmVyZmxvd01hdGNoZXMpKHRoaXMucHJvcHMsICdoaWRkZW4nKSA/IFwidXJsKCNcIi5jb25jYXQoY2xpcFBhdGhJZCwgXCIpXCIpIDogdW5kZWZpbmVkO1xyXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIHtcclxuICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1yZWZlcmVuY2UtYXJlYScsIGNsYXNzTmFtZSlcclxuICAgICAgfSwgUmVmZXJlbmNlQXJlYS5yZW5kZXJSZWN0KHNoYXBlLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xyXG4gICAgICAgIGNsaXBQYXRoOiBjbGlwUGF0aFxyXG4gICAgICB9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRoaXMucHJvcHMsIHRydWUpKSwgcmVjdCkpLCBfTGFiZWwuTGFiZWwucmVuZGVyQ2FsbEJ5UGFyZW50KHRoaXMucHJvcHMsIHJlY3QpKTtcclxuICAgIH1cclxuICB9XSk7XHJcbn0oX3JlYWN0W1wiZGVmYXVsdFwiXS5Db21wb25lbnQpO1xyXG5fZGVmaW5lUHJvcGVydHkoUmVmZXJlbmNlQXJlYSwgXCJkaXNwbGF5TmFtZVwiLCAnUmVmZXJlbmNlQXJlYScpO1xyXG5fZGVmaW5lUHJvcGVydHkoUmVmZXJlbmNlQXJlYSwgXCJkZWZhdWx0UHJvcHNcIiwge1xyXG4gIGlzRnJvbnQ6IGZhbHNlLFxyXG4gIGlmT3ZlcmZsb3c6ICdkaXNjYXJkJyxcclxuICB4QXhpc0lkOiAwLFxyXG4gIHlBeGlzSWQ6IDAsXHJcbiAgcjogMTAsXHJcbiAgZmlsbDogJyNjY2MnLFxyXG4gIGZpbGxPcGFjaXR5OiAwLjUsXHJcbiAgc3Ryb2tlOiAnbm9uZScsXHJcbiAgc3Ryb2tlV2lkdGg6IDFcclxufSk7XHJcbl9kZWZpbmVQcm9wZXJ0eShSZWZlcmVuY2VBcmVhLCBcInJlbmRlclJlY3RcIiwgZnVuY3Rpb24gKG9wdGlvbiwgcHJvcHMpIHtcclxuICB2YXIgcmVjdDtcclxuICBpZiAoIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KG9wdGlvbikpIHtcclxuICAgIHJlY3QgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQob3B0aW9uLCBwcm9wcyk7XHJcbiAgfSBlbHNlIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvcHRpb24pKSB7XHJcbiAgICByZWN0ID0gb3B0aW9uKHByb3BzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmVjdCA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX1JlY3RhbmdsZS5SZWN0YW5nbGUsIF9leHRlbmRzKHt9LCBwcm9wcywge1xyXG4gICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtcmVmZXJlbmNlLWFyZWEtcmVjdFwiXHJcbiAgICB9KSk7XHJcbiAgfVxyXG4gIHJldHVybiByZWN0O1xyXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSZWZlcmVuY2VBcmVhIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfaXNGdW5jdGlvbiIsIl9jbHN4IiwiX0xheWVyIiwiX0xhYmVsIiwiX0NhcnRlc2lhblV0aWxzIiwiX0lmT3ZlcmZsb3dNYXRjaGVzIiwiX0RhdGFVdGlscyIsIl9Mb2dVdGlscyIsIl9SZWN0YW5nbGUiLCJfUmVhY3RVdGlscyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwib3duS2V5cyIsImUiLCJyIiwidCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1Byb3BlcnR5S2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NhbGxTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiQm9vbGVhbiIsInZhbHVlT2YiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwicCIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiZ2V0UmVjdCIsImhhc1gxIiwiaGFzWDIiLCJoYXNZMSIsImhhc1kyIiwieFZhbHVlMSIsIngxIiwieFZhbHVlMiIsIngyIiwieVZhbHVlMSIsInkxIiwieVZhbHVlMiIsInkyIiwieEF4aXMiLCJ5QXhpcyIsInNjYWxlcyIsImNyZWF0ZUxhYmVsZWRTY2FsZXMiLCJ4Iiwic2NhbGUiLCJ5IiwicDEiLCJwb3NpdGlvbiIsInJhbmdlTWluIiwicDIiLCJyYW5nZU1heCIsImlmT3ZlcmZsb3dNYXRjaGVzIiwiaXNJblJhbmdlIiwicmVjdFdpdGhQb2ludHMiLCJfUmVhY3QkQ29tcG9uZW50IiwicmVuZGVyIiwiX3RoaXMkcHJvcHMiLCJjbGFzc05hbWUiLCJhbHdheXNTaG93IiwiY2xpcFBhdGhJZCIsIndhcm4iLCJ1bmRlZmluZWQiLCJpc051bU9yU3RyIiwic2hhcGUiLCJyZWN0IiwiY2xpcFBhdGgiLCJjb25jYXQiLCJjcmVhdGVFbGVtZW50IiwiTGF5ZXIiLCJyZW5kZXJSZWN0IiwiZmlsdGVyUHJvcHMiLCJMYWJlbCIsInJlbmRlckNhbGxCeVBhcmVudCIsIkNvbXBvbmVudCIsImlzRnJvbnQiLCJpZk92ZXJmbG93IiwieEF4aXNJZCIsInlBeGlzSWQiLCJmaWxsIiwiZmlsbE9wYWNpdHkiLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsIm9wdGlvbiIsImlzVmFsaWRFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwiUmVjdGFuZ2xlIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/cartesian/ReferenceArea.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/cartesian/ReferenceDot.js":
/*!*************************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/ReferenceDot.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ReferenceDot = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _Dot = __webpack_require__(/*! ../shape/Dot */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Dot.js\");\nvar _Label = __webpack_require__(/*! ../component/Label */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Label.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _IfOverflowMatches = __webpack_require__(/*! ../util/IfOverflowMatches */ \"(pages-dir-node)/./node_modules/recharts/lib/util/IfOverflowMatches.js\");\nvar _CartesianUtils = __webpack_require__(/*! ../util/CartesianUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/CartesianUtils.js\");\nvar _LogUtils = __webpack_require__(/*! ../util/LogUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/LogUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Reference Dot\r\n */ \nvar getCoordinate = function getCoordinate(props) {\n    var x = props.x, y = props.y, xAxis = props.xAxis, yAxis = props.yAxis;\n    var scales = (0, _CartesianUtils.createLabeledScales)({\n        x: xAxis.scale,\n        y: yAxis.scale\n    });\n    var result = scales.apply({\n        x: x,\n        y: y\n    }, {\n        bandAware: true\n    });\n    if ((0, _IfOverflowMatches.ifOverflowMatches)(props, 'discard') && !scales.isInRange(result)) {\n        return null;\n    }\n    return result;\n};\n// eslint-disable-next-line react/prefer-stateless-function -- requires static defaultProps\nvar ReferenceDot = exports.ReferenceDot = /*#__PURE__*/ function(_React$Component) {\n    function ReferenceDot() {\n        _classCallCheck(this, ReferenceDot);\n        return _callSuper(this, ReferenceDot, arguments);\n    }\n    _inherits(ReferenceDot, _React$Component);\n    return _createClass(ReferenceDot, [\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props = this.props, x = _this$props.x, y = _this$props.y, r = _this$props.r, alwaysShow = _this$props.alwaysShow, clipPathId = _this$props.clipPathId;\n                var isX = (0, _DataUtils.isNumOrStr)(x);\n                var isY = (0, _DataUtils.isNumOrStr)(y);\n                (0, _LogUtils.warn)(alwaysShow === undefined, 'The alwaysShow prop is deprecated. Please use ifOverflow=\"extendDomain\" instead.');\n                if (!isX || !isY) {\n                    return null;\n                }\n                var coordinate = getCoordinate(this.props);\n                if (!coordinate) {\n                    return null;\n                }\n                var cx = coordinate.x, cy = coordinate.y;\n                var _this$props2 = this.props, shape = _this$props2.shape, className = _this$props2.className;\n                var clipPath = (0, _IfOverflowMatches.ifOverflowMatches)(this.props, 'hidden') ? \"url(#\".concat(clipPathId, \")\") : undefined;\n                var dotProps = _objectSpread(_objectSpread({\n                    clipPath: clipPath\n                }, (0, _ReactUtils.filterProps)(this.props, true)), {}, {\n                    cx: cx,\n                    cy: cy\n                });\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: (0, _clsx[\"default\"])('recharts-reference-dot', className)\n                }, ReferenceDot.renderDot(shape, dotProps), _Label.Label.renderCallByParent(this.props, {\n                    x: cx - r,\n                    y: cy - r,\n                    width: 2 * r,\n                    height: 2 * r\n                }));\n            }\n        }\n    ]);\n}(_react[\"default\"].Component);\n_defineProperty(ReferenceDot, \"displayName\", 'ReferenceDot');\n_defineProperty(ReferenceDot, \"defaultProps\", {\n    isFront: false,\n    ifOverflow: 'discard',\n    xAxisId: 0,\n    yAxisId: 0,\n    r: 10,\n    fill: '#fff',\n    stroke: '#ccc',\n    fillOpacity: 1,\n    strokeWidth: 1\n});\n_defineProperty(ReferenceDot, \"renderDot\", function(option, props) {\n    var dot;\n    if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n        dot = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n    } else if ((0, _isFunction[\"default\"])(option)) {\n        dot = option(props);\n    } else {\n        dot = /*#__PURE__*/ _react[\"default\"].createElement(_Dot.Dot, _extends({}, props, {\n            cx: props.cx,\n            cy: props.cy,\n            className: \"recharts-reference-dot-dot\"\n        }));\n    }\n    return dot;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2FydGVzaWFuL1JlZmVyZW5jZURvdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsb0JBQW9CLEdBQUcsS0FBSztBQUM1QixJQUFJRyxTQUFTQyx1QkFBdUJDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ25ELElBQUlDLGNBQWNGLHVCQUF1QkMsbUJBQU9BLENBQUMsNENBQW1CO0FBQ3BFLElBQUlFLFFBQVFILHVCQUF1QkMsbUJBQU9BLENBQUMsdUJBQU07QUFDakQsSUFBSUcsU0FBU0gsbUJBQU9BLENBQUMsMkZBQW9CO0FBQ3pDLElBQUlJLE9BQU9KLG1CQUFPQSxDQUFDLCtFQUFjO0FBQ2pDLElBQUlLLFNBQVNMLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUN6QyxJQUFJTSxhQUFhTixtQkFBT0EsQ0FBQyx5RkFBbUI7QUFDNUMsSUFBSU8scUJBQXFCUCxtQkFBT0EsQ0FBQyx5R0FBMkI7QUFDNUQsSUFBSVEsa0JBQWtCUixtQkFBT0EsQ0FBQyxtR0FBd0I7QUFDdEQsSUFBSVMsWUFBWVQsbUJBQU9BLENBQUMsdUZBQWtCO0FBQzFDLElBQUlVLGNBQWNWLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM5QyxTQUFTRCx1QkFBdUJZLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0U7SUFBYUEsV0FBV3BCLE9BQU9xQixNQUFNLEdBQUdyQixPQUFPcUIsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVUMsTUFBTTtRQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFBRSxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFBRSxJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQUUsSUFBSTNC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QU87WUFDL0V1RCxJQUFJdkQsTUFBTXVELEVBQUU7WUFDWkMsSUFBSXhELE1BQU13RCxFQUFFO1lBQ1pHLFdBQVc7UUFDYjtJQUNGO0lBQ0EsT0FBT3NCO0FBQ1QiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXGNhcnRlc2lhblxcUmVmZXJlbmNlRG90LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuUmVmZXJlbmNlRG90ID0gdm9pZCAwO1xyXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgX2lzRnVuY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XHJcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xyXG52YXIgX0xheWVyID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9MYXllclwiKTtcclxudmFyIF9Eb3QgPSByZXF1aXJlKFwiLi4vc2hhcGUvRG90XCIpO1xyXG52YXIgX0xhYmVsID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9MYWJlbFwiKTtcclxudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9EYXRhVXRpbHNcIik7XHJcbnZhciBfSWZPdmVyZmxvd01hdGNoZXMgPSByZXF1aXJlKFwiLi4vdXRpbC9JZk92ZXJmbG93TWF0Y2hlc1wiKTtcclxudmFyIF9DYXJ0ZXNpYW5VdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NhcnRlc2lhblV0aWxzXCIpO1xyXG52YXIgX0xvZ1V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvTG9nVXRpbHNcIik7XHJcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxyXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxyXG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxyXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cclxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XHJcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxyXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxyXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxyXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxyXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XHJcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxyXG4gKiBAZmlsZU92ZXJ2aWV3IFJlZmVyZW5jZSBEb3RcclxuICovXHJcbnZhciBnZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZShwcm9wcykge1xyXG4gIHZhciB4ID0gcHJvcHMueCxcclxuICAgIHkgPSBwcm9wcy55LFxyXG4gICAgeEF4aXMgPSBwcm9wcy54QXhpcyxcclxuICAgIHlBeGlzID0gcHJvcHMueUF4aXM7XHJcbiAgdmFyIHNjYWxlcyA9ICgwLCBfQ2FydGVzaWFuVXRpbHMuY3JlYXRlTGFiZWxlZFNjYWxlcykoe1xyXG4gICAgeDogeEF4aXMuc2NhbGUsXHJcbiAgICB5OiB5QXhpcy5zY2FsZVxyXG4gIH0pO1xyXG4gIHZhciByZXN1bHQgPSBzY2FsZXMuYXBwbHkoe1xyXG4gICAgeDogeCxcclxuICAgIHk6IHlcclxuICB9LCB7XHJcbiAgICBiYW5kQXdhcmU6IHRydWVcclxuICB9KTtcclxuICBpZiAoKDAsIF9JZk92ZXJmbG93TWF0Y2hlcy5pZk92ZXJmbG93TWF0Y2hlcykocHJvcHMsICdkaXNjYXJkJykgJiYgIXNjYWxlcy5pc0luUmFuZ2UocmVzdWx0KSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvcHJlZmVyLXN0YXRlbGVzcy1mdW5jdGlvbiAtLSByZXF1aXJlcyBzdGF0aWMgZGVmYXVsdFByb3BzXHJcbnZhciBSZWZlcmVuY2VEb3QgPSBleHBvcnRzLlJlZmVyZW5jZURvdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xyXG4gIGZ1bmN0aW9uIFJlZmVyZW5jZURvdCgpIHtcclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWZlcmVuY2VEb3QpO1xyXG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgUmVmZXJlbmNlRG90LCBhcmd1bWVudHMpO1xyXG4gIH1cclxuICBfaW5oZXJpdHMoUmVmZXJlbmNlRG90LCBfUmVhY3QkQ29tcG9uZW50KTtcclxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFJlZmVyZW5jZURvdCwgW3tcclxuICAgIGtleTogXCJyZW5kZXJcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgeCA9IF90aGlzJHByb3BzLngsXHJcbiAgICAgICAgeSA9IF90aGlzJHByb3BzLnksXHJcbiAgICAgICAgciA9IF90aGlzJHByb3BzLnIsXHJcbiAgICAgICAgYWx3YXlzU2hvdyA9IF90aGlzJHByb3BzLmFsd2F5c1Nob3csXHJcbiAgICAgICAgY2xpcFBhdGhJZCA9IF90aGlzJHByb3BzLmNsaXBQYXRoSWQ7XHJcbiAgICAgIHZhciBpc1ggPSAoMCwgX0RhdGFVdGlscy5pc051bU9yU3RyKSh4KTtcclxuICAgICAgdmFyIGlzWSA9ICgwLCBfRGF0YVV0aWxzLmlzTnVtT3JTdHIpKHkpO1xyXG4gICAgICAoMCwgX0xvZ1V0aWxzLndhcm4pKGFsd2F5c1Nob3cgPT09IHVuZGVmaW5lZCwgJ1RoZSBhbHdheXNTaG93IHByb3AgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBpZk92ZXJmbG93PVwiZXh0ZW5kRG9tYWluXCIgaW5zdGVhZC4nKTtcclxuICAgICAgaWYgKCFpc1ggfHwgIWlzWSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBjb29yZGluYXRlID0gZ2V0Q29vcmRpbmF0ZSh0aGlzLnByb3BzKTtcclxuICAgICAgaWYgKCFjb29yZGluYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGN4ID0gY29vcmRpbmF0ZS54LFxyXG4gICAgICAgIGN5ID0gY29vcmRpbmF0ZS55O1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBzaGFwZSA9IF90aGlzJHByb3BzMi5zaGFwZSxcclxuICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczIuY2xhc3NOYW1lO1xyXG4gICAgICB2YXIgY2xpcFBhdGggPSAoMCwgX0lmT3ZlcmZsb3dNYXRjaGVzLmlmT3ZlcmZsb3dNYXRjaGVzKSh0aGlzLnByb3BzLCAnaGlkZGVuJykgPyBcInVybCgjXCIuY29uY2F0KGNsaXBQYXRoSWQsIFwiKVwiKSA6IHVuZGVmaW5lZDtcclxuICAgICAgdmFyIGRvdFByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcclxuICAgICAgICBjbGlwUGF0aDogY2xpcFBhdGhcclxuICAgICAgfSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0aGlzLnByb3BzLCB0cnVlKSksIHt9LCB7XHJcbiAgICAgICAgY3g6IGN4LFxyXG4gICAgICAgIGN5OiBjeVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtcmVmZXJlbmNlLWRvdCcsIGNsYXNzTmFtZSlcclxuICAgICAgfSwgUmVmZXJlbmNlRG90LnJlbmRlckRvdChzaGFwZSwgZG90UHJvcHMpLCBfTGFiZWwuTGFiZWwucmVuZGVyQ2FsbEJ5UGFyZW50KHRoaXMucHJvcHMsIHtcclxuICAgICAgICB4OiBjeCAtIHIsXHJcbiAgICAgICAgeTogY3kgLSByLFxyXG4gICAgICAgIHdpZHRoOiAyICogcixcclxuICAgICAgICBoZWlnaHQ6IDIgKiByXHJcbiAgICAgIH0pKTtcclxuICAgIH1cclxuICB9XSk7XHJcbn0oX3JlYWN0W1wiZGVmYXVsdFwiXS5Db21wb25lbnQpO1xyXG5fZGVmaW5lUHJvcGVydHkoUmVmZXJlbmNlRG90LCBcImRpc3BsYXlOYW1lXCIsICdSZWZlcmVuY2VEb3QnKTtcclxuX2RlZmluZVByb3BlcnR5KFJlZmVyZW5jZURvdCwgXCJkZWZhdWx0UHJvcHNcIiwge1xyXG4gIGlzRnJvbnQ6IGZhbHNlLFxyXG4gIGlmT3ZlcmZsb3c6ICdkaXNjYXJkJyxcclxuICB4QXhpc0lkOiAwLFxyXG4gIHlBeGlzSWQ6IDAsXHJcbiAgcjogMTAsXHJcbiAgZmlsbDogJyNmZmYnLFxyXG4gIHN0cm9rZTogJyNjY2MnLFxyXG4gIGZpbGxPcGFjaXR5OiAxLFxyXG4gIHN0cm9rZVdpZHRoOiAxXHJcbn0pO1xyXG5fZGVmaW5lUHJvcGVydHkoUmVmZXJlbmNlRG90LCBcInJlbmRlckRvdFwiLCBmdW5jdGlvbiAob3B0aW9uLCBwcm9wcykge1xyXG4gIHZhciBkb3Q7XHJcbiAgaWYgKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5pc1ZhbGlkRWxlbWVudChvcHRpb24pKSB7XHJcbiAgICBkb3QgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQob3B0aW9uLCBwcm9wcyk7XHJcbiAgfSBlbHNlIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvcHRpb24pKSB7XHJcbiAgICBkb3QgPSBvcHRpb24ocHJvcHMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBkb3QgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9Eb3QuRG90LCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcclxuICAgICAgY3g6IHByb3BzLmN4LFxyXG4gICAgICBjeTogcHJvcHMuY3ksXHJcbiAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1yZWZlcmVuY2UtZG90LWRvdFwiXHJcbiAgICB9KSk7XHJcbiAgfVxyXG4gIHJldHVybiBkb3Q7XHJcbn0pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlJlZmVyZW5jZURvdCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2lzRnVuY3Rpb24iLCJfY2xzeCIsIl9MYXllciIsIl9Eb3QiLCJfTGFiZWwiLCJfRGF0YVV0aWxzIiwiX0lmT3ZlcmZsb3dNYXRjaGVzIiwiX0NhcnRlc2lhblV0aWxzIiwiX0xvZ1V0aWxzIiwiX1JlYWN0VXRpbHMiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsIm93bktleXMiLCJlIiwiciIsInQiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9Qcm9wZXJ0eUtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsInAiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsImdldENvb3JkaW5hdGUiLCJ4IiwieSIsInhBeGlzIiwieUF4aXMiLCJzY2FsZXMiLCJjcmVhdGVMYWJlbGVkU2NhbGVzIiwic2NhbGUiLCJyZXN1bHQiLCJiYW5kQXdhcmUiLCJpZk92ZXJmbG93TWF0Y2hlcyIsImlzSW5SYW5nZSIsIl9SZWFjdCRDb21wb25lbnQiLCJyZW5kZXIiLCJfdGhpcyRwcm9wcyIsImFsd2F5c1Nob3ciLCJjbGlwUGF0aElkIiwiaXNYIiwiaXNOdW1PclN0ciIsImlzWSIsIndhcm4iLCJ1bmRlZmluZWQiLCJjb29yZGluYXRlIiwiY3giLCJjeSIsIl90aGlzJHByb3BzMiIsInNoYXBlIiwiY2xhc3NOYW1lIiwiY2xpcFBhdGgiLCJjb25jYXQiLCJkb3RQcm9wcyIsImZpbHRlclByb3BzIiwiY3JlYXRlRWxlbWVudCIsIkxheWVyIiwicmVuZGVyRG90IiwiTGFiZWwiLCJyZW5kZXJDYWxsQnlQYXJlbnQiLCJ3aWR0aCIsImhlaWdodCIsIkNvbXBvbmVudCIsImlzRnJvbnQiLCJpZk92ZXJmbG93IiwieEF4aXNJZCIsInlBeGlzSWQiLCJmaWxsIiwic3Ryb2tlIiwiZmlsbE9wYWNpdHkiLCJzdHJva2VXaWR0aCIsIm9wdGlvbiIsImRvdCIsImlzVmFsaWRFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwiRG90Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/cartesian/ReferenceDot.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/cartesian/ReferenceLine.js":
/*!**************************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/ReferenceLine.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getEndPoints = exports.ReferenceLine = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _some = _interopRequireDefault(__webpack_require__(/*! lodash/some */ \"lodash/some\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _Label = __webpack_require__(/*! ../component/Label */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Label.js\");\nvar _IfOverflowMatches = __webpack_require__(/*! ../util/IfOverflowMatches */ \"(pages-dir-node)/./node_modules/recharts/lib/util/IfOverflowMatches.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _CartesianUtils = __webpack_require__(/*! ../util/CartesianUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/CartesianUtils.js\");\nvar _LogUtils = __webpack_require__(/*! ../util/LogUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/LogUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _chartLayoutContext = __webpack_require__(/*! ../context/chartLayoutContext */ \"(pages-dir-node)/./node_modules/recharts/lib/context/chartLayoutContext.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n} /**\r\n * @fileOverview Reference Line\r\n */ \n/**\r\n * This excludes `viewBox` prop from svg for two reasons:\r\n * 1. The components wants viewBox of object type, and svg wants string\r\n *    - so there's a conflict, and the component will throw if it gets string\r\n * 2. Internally the component calls `filterProps` which filters the viewBox away anyway\r\n */ var renderLine = function renderLine(option, props) {\n    var line;\n    if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n        line = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n    } else if ((0, _isFunction[\"default\"])(option)) {\n        line = option(props);\n    } else {\n        line = /*#__PURE__*/ _react[\"default\"].createElement(\"line\", _extends({}, props, {\n            className: \"recharts-reference-line-line\"\n        }));\n    }\n    return line;\n};\n// TODO: ScaleHelper\nvar getEndPoints = exports.getEndPoints = function getEndPoints(scales, isFixedX, isFixedY, isSegment, viewBox, position, xAxisOrientation, yAxisOrientation, props) {\n    var x = viewBox.x, y = viewBox.y, width = viewBox.width, height = viewBox.height;\n    if (isFixedY) {\n        var yCoord = props.y;\n        var coord = scales.y.apply(yCoord, {\n            position: position\n        });\n        if ((0, _IfOverflowMatches.ifOverflowMatches)(props, 'discard') && !scales.y.isInRange(coord)) {\n            return null;\n        }\n        var points = [\n            {\n                x: x + width,\n                y: coord\n            },\n            {\n                x: x,\n                y: coord\n            }\n        ];\n        return yAxisOrientation === 'left' ? points.reverse() : points;\n    }\n    if (isFixedX) {\n        var xCoord = props.x;\n        var _coord = scales.x.apply(xCoord, {\n            position: position\n        });\n        if ((0, _IfOverflowMatches.ifOverflowMatches)(props, 'discard') && !scales.x.isInRange(_coord)) {\n            return null;\n        }\n        var _points = [\n            {\n                x: _coord,\n                y: y + height\n            },\n            {\n                x: _coord,\n                y: y\n            }\n        ];\n        return xAxisOrientation === 'top' ? _points.reverse() : _points;\n    }\n    if (isSegment) {\n        var segment = props.segment;\n        var _points2 = segment.map(function(p) {\n            return scales.apply(p, {\n                position: position\n            });\n        });\n        if ((0, _IfOverflowMatches.ifOverflowMatches)(props, 'discard') && (0, _some[\"default\"])(_points2, function(p) {\n            return !scales.isInRange(p);\n        })) {\n            return null;\n        }\n        return _points2;\n    }\n    return null;\n};\nfunction ReferenceLineImpl(props) {\n    var fixedX = props.x, fixedY = props.y, segment = props.segment, xAxisId = props.xAxisId, yAxisId = props.yAxisId, shape = props.shape, className = props.className, alwaysShow = props.alwaysShow;\n    var clipPathId = (0, _chartLayoutContext.useClipPathId)();\n    var xAxis = (0, _chartLayoutContext.useXAxisOrThrow)(xAxisId);\n    var yAxis = (0, _chartLayoutContext.useYAxisOrThrow)(yAxisId);\n    var viewBox = (0, _chartLayoutContext.useViewBox)();\n    if (!clipPathId || !viewBox) {\n        return null;\n    }\n    (0, _LogUtils.warn)(alwaysShow === undefined, 'The alwaysShow prop is deprecated. Please use ifOverflow=\"extendDomain\" instead.');\n    var scales = (0, _CartesianUtils.createLabeledScales)({\n        x: xAxis.scale,\n        y: yAxis.scale\n    });\n    var isX = (0, _DataUtils.isNumOrStr)(fixedX);\n    var isY = (0, _DataUtils.isNumOrStr)(fixedY);\n    var isSegment = segment && segment.length === 2;\n    var endPoints = getEndPoints(scales, isX, isY, isSegment, viewBox, props.position, xAxis.orientation, yAxis.orientation, props);\n    if (!endPoints) {\n        return null;\n    }\n    var _endPoints = _slicedToArray(endPoints, 2), _endPoints$ = _endPoints[0], x1 = _endPoints$.x, y1 = _endPoints$.y, _endPoints$2 = _endPoints[1], x2 = _endPoints$2.x, y2 = _endPoints$2.y;\n    var clipPath = (0, _IfOverflowMatches.ifOverflowMatches)(props, 'hidden') ? \"url(#\".concat(clipPathId, \")\") : undefined;\n    var lineProps = _objectSpread(_objectSpread({\n        clipPath: clipPath\n    }, (0, _ReactUtils.filterProps)(props, true)), {}, {\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2\n    });\n    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n        className: (0, _clsx[\"default\"])('recharts-reference-line', className)\n    }, renderLine(shape, lineProps), _Label.Label.renderCallByParent(props, (0, _CartesianUtils.rectWithCoords)({\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2\n    })));\n}\n// eslint-disable-next-line react/prefer-stateless-function -- requires static defaultProps\nvar ReferenceLine = exports.ReferenceLine = /*#__PURE__*/ function(_React$Component) {\n    function ReferenceLine() {\n        _classCallCheck(this, ReferenceLine);\n        return _callSuper(this, ReferenceLine, arguments);\n    }\n    _inherits(ReferenceLine, _React$Component);\n    return _createClass(ReferenceLine, [\n        {\n            key: \"render\",\n            value: function render() {\n                return /*#__PURE__*/ _react[\"default\"].createElement(ReferenceLineImpl, this.props);\n            }\n        }\n    ]);\n}(_react[\"default\"].Component);\n_defineProperty(ReferenceLine, \"displayName\", 'ReferenceLine');\n_defineProperty(ReferenceLine, \"defaultProps\", {\n    isFront: false,\n    ifOverflow: 'discard',\n    xAxisId: 0,\n    yAxisId: 0,\n    fill: 'none',\n    stroke: '#ccc',\n    fillOpacity: 1,\n    strokeWidth: 1,\n    position: 'middle'\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2FydGVzaWFuL1JlZmVyZW5jZUxpbmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRSxXQUFXLEtBQUtDLFVBQVVELE1BQU1DLE9BQU9FLFNBQVMsR0FBRyxXQUFXLE9BQU9IO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VEksOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELG9CQUFvQixHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBQ3BELElBQUlJLFNBQVNDLHVCQUF1QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDbkQsSUFBSUMsY0FBY0YsdUJBQXVCQyxtQkFBT0EsQ0FBQyw0Q0FBbUI7QUFDcEUsSUFBSUUsUUFBUUgsdUJBQXVCQyxtQkFBT0EsQ0FBQyxnQ0FBYTtBQUN4RCxJQUFJRyxRQUFRSix1QkFBdUJDLG1CQUFPQSxDQUFDLHVCQUFNO0FBQ2pELElBQUlJLFNBQVNKLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUN6QyxJQUFJSyxTQUFTTCxtQkFBT0EsQ0FBQywyRkFBb0I7QUFDekMsSUFBSU0scUJBQXFCTixtQkFBT0EsQ0FBQyx5R0FBMkI7QUFDNUQsSUFBSU8sYUFBYVAsbUJBQU9BLENBQUMseUZBQW1CO0FBQzVDLElBQUlRLGtCQUFrQlIsbUJBQU9BLENBQUMsbUdBQXdCO0FBQ3RELElBQUlTLFlBQVlULG1CQUFPQSxDQUFDLHVGQUFrQjtBQUMxQyxJQUFJVSxjQUFjVixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDOUMsSUFBSVcsc0JBQXNCWCxtQkFBT0Es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LElBQUlBO1FBQ0pFLElBQUlBO1FBQ0pDLElBQUlBO0lBQ047QUFDRjtBQUVBLDJGQUEyRjtBQUMzRixJQUFJckssZ0JBQWdCSCxxQkFBcUIsR0FBRyxXQUFXLEdBQUUsU0FBVWlMLGdCQUFnQjtJQUNqRixTQUFTOUs7UUFDUGlCLGdCQUFnQixJQUFJLEVBQUVqQjtRQUN0QixPQUFPbUMsV0FBVyxJQUFJLEVBQUVuQyxlQUFlb0U7SUFDekM7SUFDQWQsVUFBVXRELGVBQWU4SztJQUN6QixPQUFPOUksYUFBYWhDLGVBQWU7UUFBQztZQUNsQytCLEtBQUs7WUFDTGpDLE9BQU8sU0FBU2lMO2dCQUNkLE9BQU8sV0FBVyxHQUFFOUssTUFBTSxDQUFDLFVBQVUsQ0FBQzZHLGFBQWEsQ0FBQzBCLG1CQUFtQixJQUFJLENBQUNqSCxLQUFLO1lBQ25GO1FBQ0Y7S0FBRTtBQUNKLEVBQUV0QixNQUFNLENBQUMsVUFBVSxDQUFDK0ssU0FBUztBQUM3QjFHLGdCQUFnQnRFLGVBQWUsZUFBZTtBQUM5Q3NFLGdCQUFnQnRFLGVBQWUsZ0JBQWdCO0lBQzdDaUwsU0FBUztJQUNUQyxZQUFZO0lBQ1p2QyxTQUFTO0lBQ1RDLFNBQVM7SUFDVHVDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxhQUFhO0lBQ2JDLGFBQWE7SUFDYmpFLFVBQVU7QUFDWiIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcY2FydGVzaWFuXFxSZWZlcmVuY2VMaW5lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5nZXRFbmRQb2ludHMgPSBleHBvcnRzLlJlZmVyZW5jZUxpbmUgPSB2b2lkIDA7XHJcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBfaXNGdW5jdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpKTtcclxudmFyIF9zb21lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL3NvbWVcIikpO1xyXG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcclxudmFyIF9MYXllciA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvTGF5ZXJcIik7XHJcbnZhciBfTGFiZWwgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50L0xhYmVsXCIpO1xyXG52YXIgX0lmT3ZlcmZsb3dNYXRjaGVzID0gcmVxdWlyZShcIi4uL3V0aWwvSWZPdmVyZmxvd01hdGNoZXNcIik7XHJcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRGF0YVV0aWxzXCIpO1xyXG52YXIgX0NhcnRlc2lhblV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvQ2FydGVzaWFuVXRpbHNcIik7XHJcbnZhciBfTG9nVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9Mb2dVdGlsc1wiKTtcclxudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmVhY3RVdGlsc1wiKTtcclxudmFyIF9jaGFydExheW91dENvbnRleHQgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jaGFydExheW91dENvbnRleHRcIik7XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxyXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxyXG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxyXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cclxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XHJcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxyXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxyXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxyXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxyXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XHJcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XHJcbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XHJcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cclxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XHJcbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XHJcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxyXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cclxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IC8qKlxyXG4gKiBAZmlsZU92ZXJ2aWV3IFJlZmVyZW5jZSBMaW5lXHJcbiAqL1xyXG4vKipcclxuICogVGhpcyBleGNsdWRlcyBgdmlld0JveGAgcHJvcCBmcm9tIHN2ZyBmb3IgdHdvIHJlYXNvbnM6XHJcbiAqIDEuIFRoZSBjb21wb25lbnRzIHdhbnRzIHZpZXdCb3ggb2Ygb2JqZWN0IHR5cGUsIGFuZCBzdmcgd2FudHMgc3RyaW5nXHJcbiAqICAgIC0gc28gdGhlcmUncyBhIGNvbmZsaWN0LCBhbmQgdGhlIGNvbXBvbmVudCB3aWxsIHRocm93IGlmIGl0IGdldHMgc3RyaW5nXHJcbiAqIDIuIEludGVybmFsbHkgdGhlIGNvbXBvbmVudCBjYWxscyBgZmlsdGVyUHJvcHNgIHdoaWNoIGZpbHRlcnMgdGhlIHZpZXdCb3ggYXdheSBhbnl3YXlcclxuICovXHJcblxyXG52YXIgcmVuZGVyTGluZSA9IGZ1bmN0aW9uIHJlbmRlckxpbmUob3B0aW9uLCBwcm9wcykge1xyXG4gIHZhciBsaW5lO1xyXG4gIGlmICggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uaXNWYWxpZEVsZW1lbnQob3B0aW9uKSkge1xyXG4gICAgbGluZSA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChvcHRpb24sIHByb3BzKTtcclxuICB9IGVsc2UgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9wdGlvbikpIHtcclxuICAgIGxpbmUgPSBvcHRpb24ocHJvcHMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBsaW5lID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImxpbmVcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1yZWZlcmVuY2UtbGluZS1saW5lXCJcclxuICAgIH0pKTtcclxuICB9XHJcbiAgcmV0dXJuIGxpbmU7XHJcbn07XHJcbi8vIFRPRE86IFNjYWxlSGVscGVyXHJcbnZhciBnZXRFbmRQb2ludHMgPSBleHBvcnRzLmdldEVuZFBvaW50cyA9IGZ1bmN0aW9uIGdldEVuZFBvaW50cyhzY2FsZXMsIGlzRml4ZWRYLCBpc0ZpeGVkWSwgaXNTZWdtZW50LCB2aWV3Qm94LCBwb3NpdGlvbiwgeEF4aXNPcmllbnRhdGlvbiwgeUF4aXNPcmllbnRhdGlvbiwgcHJvcHMpIHtcclxuICB2YXIgeCA9IHZpZXdCb3gueCxcclxuICAgIHkgPSB2aWV3Qm94LnksXHJcbiAgICB3aWR0aCA9IHZpZXdCb3gud2lkdGgsXHJcbiAgICBoZWlnaHQgPSB2aWV3Qm94LmhlaWdodDtcclxuICBpZiAoaXNGaXhlZFkpIHtcclxuICAgIHZhciB5Q29vcmQgPSBwcm9wcy55O1xyXG4gICAgdmFyIGNvb3JkID0gc2NhbGVzLnkuYXBwbHkoeUNvb3JkLCB7XHJcbiAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxyXG4gICAgfSk7XHJcbiAgICBpZiAoKDAsIF9JZk92ZXJmbG93TWF0Y2hlcy5pZk92ZXJmbG93TWF0Y2hlcykocHJvcHMsICdkaXNjYXJkJykgJiYgIXNjYWxlcy55LmlzSW5SYW5nZShjb29yZCkpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB2YXIgcG9pbnRzID0gW3tcclxuICAgICAgeDogeCArIHdpZHRoLFxyXG4gICAgICB5OiBjb29yZFxyXG4gICAgfSwge1xyXG4gICAgICB4OiB4LFxyXG4gICAgICB5OiBjb29yZFxyXG4gICAgfV07XHJcbiAgICByZXR1cm4geUF4aXNPcmllbnRhdGlvbiA9PT0gJ2xlZnQnID8gcG9pbnRzLnJldmVyc2UoKSA6IHBvaW50cztcclxuICB9XHJcbiAgaWYgKGlzRml4ZWRYKSB7XHJcbiAgICB2YXIgeENvb3JkID0gcHJvcHMueDtcclxuICAgIHZhciBfY29vcmQgPSBzY2FsZXMueC5hcHBseSh4Q29vcmQsIHtcclxuICAgICAgcG9zaXRpb246IHBvc2l0aW9uXHJcbiAgICB9KTtcclxuICAgIGlmICgoMCwgX0lmT3ZlcmZsb3dNYXRjaGVzLmlmT3ZlcmZsb3dNYXRjaGVzKShwcm9wcywgJ2Rpc2NhcmQnKSAmJiAhc2NhbGVzLnguaXNJblJhbmdlKF9jb29yZCkpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB2YXIgX3BvaW50cyA9IFt7XHJcbiAgICAgIHg6IF9jb29yZCxcclxuICAgICAgeTogeSArIGhlaWdodFxyXG4gICAgfSwge1xyXG4gICAgICB4OiBfY29vcmQsXHJcbiAgICAgIHk6IHlcclxuICAgIH1dO1xyXG4gICAgcmV0dXJuIHhBeGlzT3JpZW50YXRpb24gPT09ICd0b3AnID8gX3BvaW50cy5yZXZlcnNlKCkgOiBfcG9pbnRzO1xyXG4gIH1cclxuICBpZiAoaXNTZWdtZW50KSB7XHJcbiAgICB2YXIgc2VnbWVudCA9IHByb3BzLnNlZ21lbnQ7XHJcbiAgICB2YXIgX3BvaW50czIgPSBzZWdtZW50Lm1hcChmdW5jdGlvbiAocCkge1xyXG4gICAgICByZXR1cm4gc2NhbGVzLmFwcGx5KHAsIHtcclxuICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIGlmICgoMCwgX0lmT3ZlcmZsb3dNYXRjaGVzLmlmT3ZlcmZsb3dNYXRjaGVzKShwcm9wcywgJ2Rpc2NhcmQnKSAmJiAoMCwgX3NvbWVbXCJkZWZhdWx0XCJdKShfcG9pbnRzMiwgZnVuY3Rpb24gKHApIHtcclxuICAgICAgcmV0dXJuICFzY2FsZXMuaXNJblJhbmdlKHApO1xyXG4gICAgfSkpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX3BvaW50czI7XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59O1xyXG5mdW5jdGlvbiBSZWZlcmVuY2VMaW5lSW1wbChwcm9wcykge1xyXG4gIHZhciBmaXhlZFggPSBwcm9wcy54LFxyXG4gICAgZml4ZWRZID0gcHJvcHMueSxcclxuICAgIHNlZ21lbnQgPSBwcm9wcy5zZWdtZW50LFxyXG4gICAgeEF4aXNJZCA9IHByb3BzLnhBeGlzSWQsXHJcbiAgICB5QXhpc0lkID0gcHJvcHMueUF4aXNJZCxcclxuICAgIHNoYXBlID0gcHJvcHMuc2hhcGUsXHJcbiAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXHJcbiAgICBhbHdheXNTaG93ID0gcHJvcHMuYWx3YXlzU2hvdztcclxuICB2YXIgY2xpcFBhdGhJZCA9ICgwLCBfY2hhcnRMYXlvdXRDb250ZXh0LnVzZUNsaXBQYXRoSWQpKCk7XHJcbiAgdmFyIHhBeGlzID0gKDAsIF9jaGFydExheW91dENvbnRleHQudXNlWEF4aXNPclRocm93KSh4QXhpc0lkKTtcclxuICB2YXIgeUF4aXMgPSAoMCwgX2NoYXJ0TGF5b3V0Q29udGV4dC51c2VZQXhpc09yVGhyb3cpKHlBeGlzSWQpO1xyXG4gIHZhciB2aWV3Qm94ID0gKDAsIF9jaGFydExheW91dENvbnRleHQudXNlVmlld0JveCkoKTtcclxuICBpZiAoIWNsaXBQYXRoSWQgfHwgIXZpZXdCb3gpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICAoMCwgX0xvZ1V0aWxzLndhcm4pKGFsd2F5c1Nob3cgPT09IHVuZGVmaW5lZCwgJ1RoZSBhbHdheXNTaG93IHByb3AgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBpZk92ZXJmbG93PVwiZXh0ZW5kRG9tYWluXCIgaW5zdGVhZC4nKTtcclxuICB2YXIgc2NhbGVzID0gKDAsIF9DYXJ0ZXNpYW5VdGlscy5jcmVhdGVMYWJlbGVkU2NhbGVzKSh7XHJcbiAgICB4OiB4QXhpcy5zY2FsZSxcclxuICAgIHk6IHlBeGlzLnNjYWxlXHJcbiAgfSk7XHJcbiAgdmFyIGlzWCA9ICgwLCBfRGF0YVV0aWxzLmlzTnVtT3JTdHIpKGZpeGVkWCk7XHJcbiAgdmFyIGlzWSA9ICgwLCBfRGF0YVV0aWxzLmlzTnVtT3JTdHIpKGZpeGVkWSk7XHJcbiAgdmFyIGlzU2VnbWVudCA9IHNlZ21lbnQgJiYgc2VnbWVudC5sZW5ndGggPT09IDI7XHJcbiAgdmFyIGVuZFBvaW50cyA9IGdldEVuZFBvaW50cyhzY2FsZXMsIGlzWCwgaXNZLCBpc1NlZ21lbnQsIHZpZXdCb3gsIHByb3BzLnBvc2l0aW9uLCB4QXhpcy5vcmllbnRhdGlvbiwgeUF4aXMub3JpZW50YXRpb24sIHByb3BzKTtcclxuICBpZiAoIWVuZFBvaW50cykge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHZhciBfZW5kUG9pbnRzID0gX3NsaWNlZFRvQXJyYXkoZW5kUG9pbnRzLCAyKSxcclxuICAgIF9lbmRQb2ludHMkID0gX2VuZFBvaW50c1swXSxcclxuICAgIHgxID0gX2VuZFBvaW50cyQueCxcclxuICAgIHkxID0gX2VuZFBvaW50cyQueSxcclxuICAgIF9lbmRQb2ludHMkMiA9IF9lbmRQb2ludHNbMV0sXHJcbiAgICB4MiA9IF9lbmRQb2ludHMkMi54LFxyXG4gICAgeTIgPSBfZW5kUG9pbnRzJDIueTtcclxuICB2YXIgY2xpcFBhdGggPSAoMCwgX0lmT3ZlcmZsb3dNYXRjaGVzLmlmT3ZlcmZsb3dNYXRjaGVzKShwcm9wcywgJ2hpZGRlbicpID8gXCJ1cmwoI1wiLmNvbmNhdChjbGlwUGF0aElkLCBcIilcIikgOiB1bmRlZmluZWQ7XHJcbiAgdmFyIGxpbmVQcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XHJcbiAgICBjbGlwUGF0aDogY2xpcFBhdGhcclxuICB9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHByb3BzLCB0cnVlKSksIHt9LCB7XHJcbiAgICB4MTogeDEsXHJcbiAgICB5MTogeTEsXHJcbiAgICB4MjogeDIsXHJcbiAgICB5MjogeTJcclxuICB9KTtcclxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIHtcclxuICAgIGNsYXNzTmFtZTogKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXJlZmVyZW5jZS1saW5lJywgY2xhc3NOYW1lKVxyXG4gIH0sIHJlbmRlckxpbmUoc2hhcGUsIGxpbmVQcm9wcyksIF9MYWJlbC5MYWJlbC5yZW5kZXJDYWxsQnlQYXJlbnQocHJvcHMsICgwLCBfQ2FydGVzaWFuVXRpbHMucmVjdFdpdGhDb29yZHMpKHtcclxuICAgIHgxOiB4MSxcclxuICAgIHkxOiB5MSxcclxuICAgIHgyOiB4MixcclxuICAgIHkyOiB5MlxyXG4gIH0pKSk7XHJcbn1cclxuXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9wcmVmZXItc3RhdGVsZXNzLWZ1bmN0aW9uIC0tIHJlcXVpcmVzIHN0YXRpYyBkZWZhdWx0UHJvcHNcclxudmFyIFJlZmVyZW5jZUxpbmUgPSBleHBvcnRzLlJlZmVyZW5jZUxpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcclxuICBmdW5jdGlvbiBSZWZlcmVuY2VMaW5lKCkge1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlZmVyZW5jZUxpbmUpO1xyXG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgUmVmZXJlbmNlTGluZSwgYXJndW1lbnRzKTtcclxuICB9XHJcbiAgX2luaGVyaXRzKFJlZmVyZW5jZUxpbmUsIF9SZWFjdCRDb21wb25lbnQpO1xyXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUmVmZXJlbmNlTGluZSwgW3tcclxuICAgIGtleTogXCJyZW5kZXJcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFJlZmVyZW5jZUxpbmVJbXBsLCB0aGlzLnByb3BzKTtcclxuICAgIH1cclxuICB9XSk7XHJcbn0oX3JlYWN0W1wiZGVmYXVsdFwiXS5Db21wb25lbnQpO1xyXG5fZGVmaW5lUHJvcGVydHkoUmVmZXJlbmNlTGluZSwgXCJkaXNwbGF5TmFtZVwiLCAnUmVmZXJlbmNlTGluZScpO1xyXG5fZGVmaW5lUHJvcGVydHkoUmVmZXJlbmNlTGluZSwgXCJkZWZhdWx0UHJvcHNcIiwge1xyXG4gIGlzRnJvbnQ6IGZhbHNlLFxyXG4gIGlmT3ZlcmZsb3c6ICdkaXNjYXJkJyxcclxuICB4QXhpc0lkOiAwLFxyXG4gIHlBeGlzSWQ6IDAsXHJcbiAgZmlsbDogJ25vbmUnLFxyXG4gIHN0cm9rZTogJyNjY2MnLFxyXG4gIGZpbGxPcGFjaXR5OiAxLFxyXG4gIHN0cm9rZVdpZHRoOiAxLFxyXG4gIHBvc2l0aW9uOiAnbWlkZGxlJ1xyXG59KTsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0RW5kUG9pbnRzIiwiUmVmZXJlbmNlTGluZSIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2lzRnVuY3Rpb24iLCJfc29tZSIsIl9jbHN4IiwiX0xheWVyIiwiX0xhYmVsIiwiX0lmT3ZlcmZsb3dNYXRjaGVzIiwiX0RhdGFVdGlscyIsIl9DYXJ0ZXNpYW5VdGlscyIsIl9Mb2dVdGlscyIsIl9SZWFjdFV0aWxzIiwiX2NoYXJ0TGF5b3V0Q29udGV4dCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2FsbFN1cGVyIiwidCIsImUiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0IiwiYXBwbHkiLCJzZWxmIiwiY2FsbCIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsImJpbmQiLCJfX3Byb3RvX18iLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwib3duS2V5cyIsInIiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwibiIsInRvU3RyaW5nIiwic2xpY2UiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsImxlbiIsImFycjIiLCJsIiwidSIsImEiLCJmIiwibmV4dCIsImRvbmUiLCJpc0FycmF5IiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJzb3VyY2UiLCJoYXNPd25Qcm9wZXJ0eSIsInJlbmRlckxpbmUiLCJvcHRpb24iLCJsaW5lIiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwic2NhbGVzIiwiaXNGaXhlZFgiLCJpc0ZpeGVkWSIsImlzU2VnbWVudCIsInZpZXdCb3giLCJwb3NpdGlvbiIsInhBeGlzT3JpZW50YXRpb24iLCJ5QXhpc09yaWVudGF0aW9uIiwieCIsInkiLCJ3aWR0aCIsImhlaWdodCIsInlDb29yZCIsImNvb3JkIiwiaWZPdmVyZmxvd01hdGNoZXMiLCJpc0luUmFuZ2UiLCJwb2ludHMiLCJyZXZlcnNlIiwieENvb3JkIiwiX2Nvb3JkIiwiX3BvaW50cyIsInNlZ21lbnQiLCJfcG9pbnRzMiIsIm1hcCIsIlJlZmVyZW5jZUxpbmVJbXBsIiwiZml4ZWRYIiwiZml4ZWRZIiwieEF4aXNJZCIsInlBeGlzSWQiLCJzaGFwZSIsImFsd2F5c1Nob3ciLCJjbGlwUGF0aElkIiwidXNlQ2xpcFBhdGhJZCIsInhBeGlzIiwidXNlWEF4aXNPclRocm93IiwieUF4aXMiLCJ1c2VZQXhpc09yVGhyb3ciLCJ1c2VWaWV3Qm94Iiwid2FybiIsInVuZGVmaW5lZCIsImNyZWF0ZUxhYmVsZWRTY2FsZXMiLCJzY2FsZSIsImlzWCIsImlzTnVtT3JTdHIiLCJpc1kiLCJlbmRQb2ludHMiLCJvcmllbnRhdGlvbiIsIl9lbmRQb2ludHMiLCJfZW5kUG9pbnRzJCIsIngxIiwieTEiLCJfZW5kUG9pbnRzJDIiLCJ4MiIsInkyIiwiY2xpcFBhdGgiLCJjb25jYXQiLCJsaW5lUHJvcHMiLCJmaWx0ZXJQcm9wcyIsIkxheWVyIiwiTGFiZWwiLCJyZW5kZXJDYWxsQnlQYXJlbnQiLCJyZWN0V2l0aENvb3JkcyIsIl9SZWFjdCRDb21wb25lbnQiLCJyZW5kZXIiLCJDb21wb25lbnQiLCJpc0Zyb250IiwiaWZPdmVyZmxvdyIsImZpbGwiLCJzdHJva2UiLCJmaWxsT3BhY2l0eSIsInN0cm9rZVdpZHRoIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/cartesian/ReferenceLine.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/cartesian/Scatter.js":
/*!********************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/Scatter.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Scatter = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _isEqual = _interopRequireDefault(__webpack_require__(/*! lodash/isEqual */ \"lodash/isEqual\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _LabelList = __webpack_require__(/*! ../component/LabelList */ \"(pages-dir-node)/./node_modules/recharts/lib/component/LabelList.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"(pages-dir-node)/./node_modules/recharts/lib/util/Global.js\");\nvar _ZAxis = __webpack_require__(/*! ./ZAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/ZAxis.js\");\nvar _Curve = __webpack_require__(/*! ../shape/Curve */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Curve.js\");\nvar _ErrorBar = __webpack_require__(/*! ./ErrorBar */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/ErrorBar.js\");\nvar _Cell = __webpack_require__(/*! ../component/Cell */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Cell.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _types = __webpack_require__(/*! ../util/types */ \"(pages-dir-node)/./node_modules/recharts/lib/util/types.js\");\nvar _ScatterUtils = __webpack_require__(/*! ../util/ScatterUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ScatterUtils.js\");\nvar _Scatter;\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Render a group of scatters\r\n */ \nvar Scatter = exports.Scatter = /*#__PURE__*/ function(_PureComponent) {\n    function Scatter() {\n        var _this;\n        _classCallCheck(this, Scatter);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, Scatter, [].concat(args));\n        _defineProperty(_this, \"state\", {\n            isAnimationFinished: false\n        });\n        _defineProperty(_this, \"handleAnimationEnd\", function() {\n            _this.setState({\n                isAnimationFinished: true\n            });\n        });\n        _defineProperty(_this, \"handleAnimationStart\", function() {\n            _this.setState({\n                isAnimationFinished: false\n            });\n        });\n        _defineProperty(_this, \"id\", (0, _DataUtils.uniqueId)('recharts-scatter-'));\n        return _this;\n    }\n    _inherits(Scatter, _PureComponent);\n    return _createClass(Scatter, [\n        {\n            key: \"renderSymbolsStatically\",\n            value: function renderSymbolsStatically(points) {\n                var _this2 = this;\n                var _this$props = this.props, shape = _this$props.shape, activeShape = _this$props.activeShape, activeIndex = _this$props.activeIndex;\n                var baseProps = (0, _ReactUtils.filterProps)(this.props, false);\n                return points.map(function(entry, i) {\n                    var isActive = activeIndex === i;\n                    var option = isActive ? activeShape : shape;\n                    var props = _objectSpread(_objectSpread({}, baseProps), entry);\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                        className: \"recharts-scatter-symbol\",\n                        key: \"symbol-\".concat(entry === null || entry === void 0 ? void 0 : entry.cx, \"-\").concat(entry === null || entry === void 0 ? void 0 : entry.cy, \"-\").concat(entry === null || entry === void 0 ? void 0 : entry.size, \"-\").concat(i)\n                    }, (0, _types.adaptEventsOfChild)(_this2.props, entry, i), {\n                        role: \"img\"\n                    }), /*#__PURE__*/ _react[\"default\"].createElement(_ScatterUtils.ScatterSymbol, _extends({\n                        option: option,\n                        isActive: isActive,\n                        key: \"symbol-\".concat(i)\n                    }, props)));\n                });\n            }\n        },\n        {\n            key: \"renderSymbolsWithAnimation\",\n            value: function renderSymbolsWithAnimation() {\n                var _this3 = this;\n                var _this$props2 = this.props, points = _this$props2.points, isAnimationActive = _this$props2.isAnimationActive, animationBegin = _this$props2.animationBegin, animationDuration = _this$props2.animationDuration, animationEasing = _this$props2.animationEasing, animationId = _this$props2.animationId;\n                var prevPoints = this.state.prevPoints;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n                    begin: animationBegin,\n                    duration: animationDuration,\n                    isActive: isAnimationActive,\n                    easing: animationEasing,\n                    from: {\n                        t: 0\n                    },\n                    to: {\n                        t: 1\n                    },\n                    key: \"pie-\".concat(animationId),\n                    onAnimationEnd: this.handleAnimationEnd,\n                    onAnimationStart: this.handleAnimationStart\n                }, function(_ref) {\n                    var t = _ref.t;\n                    var stepData = points.map(function(entry, index) {\n                        var prev = prevPoints && prevPoints[index];\n                        if (prev) {\n                            var interpolatorCx = (0, _DataUtils.interpolateNumber)(prev.cx, entry.cx);\n                            var interpolatorCy = (0, _DataUtils.interpolateNumber)(prev.cy, entry.cy);\n                            var interpolatorSize = (0, _DataUtils.interpolateNumber)(prev.size, entry.size);\n                            return _objectSpread(_objectSpread({}, entry), {}, {\n                                cx: interpolatorCx(t),\n                                cy: interpolatorCy(t),\n                                size: interpolatorSize(t)\n                            });\n                        }\n                        var interpolator = (0, _DataUtils.interpolateNumber)(0, entry.size);\n                        return _objectSpread(_objectSpread({}, entry), {}, {\n                            size: interpolator(t)\n                        });\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, null, _this3.renderSymbolsStatically(stepData));\n                });\n            }\n        },\n        {\n            key: \"renderSymbols\",\n            value: function renderSymbols() {\n                var _this$props3 = this.props, points = _this$props3.points, isAnimationActive = _this$props3.isAnimationActive;\n                var prevPoints = this.state.prevPoints;\n                if (isAnimationActive && points && points.length && (!prevPoints || !(0, _isEqual[\"default\"])(prevPoints, points))) {\n                    return this.renderSymbolsWithAnimation();\n                }\n                return this.renderSymbolsStatically(points);\n            }\n        },\n        {\n            key: \"renderErrorBar\",\n            value: function renderErrorBar() {\n                var isAnimationActive = this.props.isAnimationActive;\n                if (isAnimationActive && !this.state.isAnimationFinished) {\n                    return null;\n                }\n                var _this$props4 = this.props, points = _this$props4.points, xAxis = _this$props4.xAxis, yAxis = _this$props4.yAxis, children = _this$props4.children;\n                var errorBarItems = (0, _ReactUtils.findAllByType)(children, _ErrorBar.ErrorBar);\n                if (!errorBarItems) {\n                    return null;\n                }\n                return errorBarItems.map(function(item, i) {\n                    var _item$props = item.props, direction = _item$props.direction, errorDataKey = _item$props.dataKey;\n                    return /*#__PURE__*/ _react[\"default\"].cloneElement(item, {\n                        key: \"\".concat(direction, \"-\").concat(errorDataKey, \"-\").concat(points[i]),\n                        data: points,\n                        xAxis: xAxis,\n                        yAxis: yAxis,\n                        layout: direction === 'x' ? 'vertical' : 'horizontal',\n                        dataPointFormatter: function dataPointFormatter(dataPoint, dataKey) {\n                            return {\n                                x: dataPoint.cx,\n                                y: dataPoint.cy,\n                                value: direction === 'x' ? +dataPoint.node.x : +dataPoint.node.y,\n                                errorVal: (0, _ChartUtils.getValueByDataKey)(dataPoint, dataKey)\n                            };\n                        }\n                    });\n                });\n            }\n        },\n        {\n            key: \"renderLine\",\n            value: function renderLine() {\n                var _this$props5 = this.props, points = _this$props5.points, line = _this$props5.line, lineType = _this$props5.lineType, lineJointType = _this$props5.lineJointType;\n                var scatterProps = (0, _ReactUtils.filterProps)(this.props, false);\n                var customLineProps = (0, _ReactUtils.filterProps)(line, false);\n                var linePoints, lineItem;\n                if (lineType === 'joint') {\n                    linePoints = points.map(function(entry) {\n                        return {\n                            x: entry.cx,\n                            y: entry.cy\n                        };\n                    });\n                } else if (lineType === 'fitting') {\n                    var _getLinearRegression = (0, _DataUtils.getLinearRegression)(points), xmin = _getLinearRegression.xmin, xmax = _getLinearRegression.xmax, a = _getLinearRegression.a, b = _getLinearRegression.b;\n                    var linearExp = function linearExp(x) {\n                        return a * x + b;\n                    };\n                    linePoints = [\n                        {\n                            x: xmin,\n                            y: linearExp(xmin)\n                        },\n                        {\n                            x: xmax,\n                            y: linearExp(xmax)\n                        }\n                    ];\n                }\n                var lineProps = _objectSpread(_objectSpread(_objectSpread({}, scatterProps), {}, {\n                    fill: 'none',\n                    stroke: scatterProps && scatterProps.fill\n                }, customLineProps), {}, {\n                    points: linePoints\n                });\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(line)) {\n                    lineItem = /*#__PURE__*/ _react[\"default\"].cloneElement(line, lineProps);\n                } else if ((0, _isFunction[\"default\"])(line)) {\n                    lineItem = line(lineProps);\n                } else {\n                    lineItem = /*#__PURE__*/ _react[\"default\"].createElement(_Curve.Curve, _extends({}, lineProps, {\n                        type: lineJointType\n                    }));\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-scatter-line\",\n                    key: \"recharts-scatter-line\"\n                }, lineItem);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props6 = this.props, hide = _this$props6.hide, points = _this$props6.points, line = _this$props6.line, className = _this$props6.className, xAxis = _this$props6.xAxis, yAxis = _this$props6.yAxis, left = _this$props6.left, top = _this$props6.top, width = _this$props6.width, height = _this$props6.height, id = _this$props6.id, isAnimationActive = _this$props6.isAnimationActive;\n                if (hide || !points || !points.length) {\n                    return null;\n                }\n                var isAnimationFinished = this.state.isAnimationFinished;\n                var layerClass = (0, _clsx[\"default\"])('recharts-scatter', className);\n                var needClipX = xAxis && xAxis.allowDataOverflow;\n                var needClipY = yAxis && yAxis.allowDataOverflow;\n                var needClip = needClipX || needClipY;\n                var clipPathId = (0, _isNil[\"default\"])(id) ? this.id : id;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: layerClass,\n                    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : null\n                }, needClipX || needClipY ? /*#__PURE__*/ _react[\"default\"].createElement(\"defs\", null, /*#__PURE__*/ _react[\"default\"].createElement(\"clipPath\", {\n                    id: \"clipPath-\".concat(clipPathId)\n                }, /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                    x: needClipX ? left : left - width / 2,\n                    y: needClipY ? top : top - height / 2,\n                    width: needClipX ? width : width * 2,\n                    height: needClipY ? height : height * 2\n                }))) : null, line && this.renderLine(), this.renderErrorBar(), /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    key: \"recharts-scatter-symbols\"\n                }, this.renderSymbols()), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, points));\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                if (nextProps.animationId !== prevState.prevAnimationId) {\n                    return {\n                        prevAnimationId: nextProps.animationId,\n                        curPoints: nextProps.points,\n                        prevPoints: prevState.curPoints\n                    };\n                }\n                if (nextProps.points !== prevState.curPoints) {\n                    return {\n                        curPoints: nextProps.points\n                    };\n                }\n                return null;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_Scatter = Scatter;\n_defineProperty(Scatter, \"displayName\", 'Scatter');\n_defineProperty(Scatter, \"defaultProps\", {\n    xAxisId: 0,\n    yAxisId: 0,\n    zAxisId: 0,\n    legendType: 'circle',\n    lineType: 'joint',\n    lineJointType: 'linear',\n    data: [],\n    shape: 'circle',\n    hide: false,\n    isAnimationActive: !_Global.Global.isSsr,\n    animationBegin: 0,\n    animationDuration: 400,\n    animationEasing: 'linear'\n});\n/**\r\n * Compose the data of each group\r\n * @param  {Object} xAxis   The configuration of x-axis\r\n * @param  {Object} yAxis   The configuration of y-axis\r\n * @param  {String} dataKey The unique key of a group\r\n * @return {Array}  Composed data\r\n */ _defineProperty(Scatter, \"getComposedData\", function(_ref2) {\n    var xAxis = _ref2.xAxis, yAxis = _ref2.yAxis, zAxis = _ref2.zAxis, item = _ref2.item, displayedData = _ref2.displayedData, xAxisTicks = _ref2.xAxisTicks, yAxisTicks = _ref2.yAxisTicks, offset = _ref2.offset;\n    var tooltipType = item.props.tooltipType;\n    var cells = (0, _ReactUtils.findAllByType)(item.props.children, _Cell.Cell);\n    var xAxisDataKey = (0, _isNil[\"default\"])(xAxis.dataKey) ? item.props.dataKey : xAxis.dataKey;\n    var yAxisDataKey = (0, _isNil[\"default\"])(yAxis.dataKey) ? item.props.dataKey : yAxis.dataKey;\n    var zAxisDataKey = zAxis && zAxis.dataKey;\n    var defaultRangeZ = zAxis ? zAxis.range : _ZAxis.ZAxis.defaultProps.range;\n    var defaultZ = defaultRangeZ && defaultRangeZ[0];\n    var xBandSize = xAxis.scale.bandwidth ? xAxis.scale.bandwidth() : 0;\n    var yBandSize = yAxis.scale.bandwidth ? yAxis.scale.bandwidth() : 0;\n    var points = displayedData.map(function(entry, index) {\n        var x = (0, _ChartUtils.getValueByDataKey)(entry, xAxisDataKey);\n        var y = (0, _ChartUtils.getValueByDataKey)(entry, yAxisDataKey);\n        var z = !(0, _isNil[\"default\"])(zAxisDataKey) && (0, _ChartUtils.getValueByDataKey)(entry, zAxisDataKey) || '-';\n        var tooltipPayload = [\n            {\n                name: (0, _isNil[\"default\"])(xAxis.dataKey) ? item.props.name : xAxis.name || xAxis.dataKey,\n                unit: xAxis.unit || '',\n                value: x,\n                payload: entry,\n                dataKey: xAxisDataKey,\n                type: tooltipType\n            },\n            {\n                name: (0, _isNil[\"default\"])(yAxis.dataKey) ? item.props.name : yAxis.name || yAxis.dataKey,\n                unit: yAxis.unit || '',\n                value: y,\n                payload: entry,\n                dataKey: yAxisDataKey,\n                type: tooltipType\n            }\n        ];\n        if (z !== '-') {\n            tooltipPayload.push({\n                name: zAxis.name || zAxis.dataKey,\n                unit: zAxis.unit || '',\n                value: z,\n                payload: entry,\n                dataKey: zAxisDataKey,\n                type: tooltipType\n            });\n        }\n        var cx = (0, _ChartUtils.getCateCoordinateOfLine)({\n            axis: xAxis,\n            ticks: xAxisTicks,\n            bandSize: xBandSize,\n            entry: entry,\n            index: index,\n            dataKey: xAxisDataKey\n        });\n        var cy = (0, _ChartUtils.getCateCoordinateOfLine)({\n            axis: yAxis,\n            ticks: yAxisTicks,\n            bandSize: yBandSize,\n            entry: entry,\n            index: index,\n            dataKey: yAxisDataKey\n        });\n        var size = z !== '-' ? zAxis.scale(z) : defaultZ;\n        var radius = Math.sqrt(Math.max(size, 0) / Math.PI);\n        return _objectSpread(_objectSpread({}, entry), {}, {\n            cx: cx,\n            cy: cy,\n            x: cx - radius,\n            y: cy - radius,\n            xAxis: xAxis,\n            yAxis: yAxis,\n            zAxis: zAxis,\n            width: 2 * radius,\n            height: 2 * radius,\n            size: size,\n            node: {\n                x: x,\n                y: y,\n                z: z\n            },\n            tooltipPayload: tooltipPayload,\n            tooltipPosition: {\n                x: cx,\n                y: cy\n            },\n            payload: entry\n        }, cells && cells[index] && cells[index].props);\n    });\n    return _objectSpread({\n        points: points\n    }, offset);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2FydGVzaWFuL1NjYXR0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGVBQWUsR0FBRyxLQUFLO0FBQ3ZCLElBQUlHLFNBQVNDLHdCQUF3QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUMsZUFBZUMsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUNoRSxJQUFJRyxTQUFTRCx1QkFBdUJGLG1CQUFPQSxDQUFDLGtDQUFjO0FBQzFELElBQUlJLFdBQVdGLHVCQUF1QkYsbUJBQU9BLENBQUMsc0NBQWdCO0FBQzlELElBQUlLLGNBQWNILHVCQUF1QkYsbUJBQU9BLENBQUMsNENBQW1CO0FBQ3BFLElBQUlNLFFBQVFKLHVCQUF1QkYsbUJBQU9BLENBQUMsdUJBQU07QUFDakQsSUFBSU8sU0FBU1AsbUJBQU9BLENBQUMsMkZBQW9CO0FBQ3pDLElBQUlRLGFBQWFSLG1CQUFPQSxDQUFDLG1HQUF3QjtBQUNqRCxJQUFJUyxjQUFjVCxtQkFBT0EsQ0FBQywyRkFBb0I7QUFDOUMsSUFBSVUsVUFBVVYsbUJBQU9BLENBQUMsbUZBQWdCO0FBQ3RDLElBQUlXLFNBQVNYLG1CQUFPQSxDQUFDLGdGQUFTO0FBQzlCLElBQUlZLFNBQVNaLG1CQUFPQSxDQUFDLG1GQUFnQjtBQUNyQyxJQUFJYSxZQUFZYixtQkFBT0EsQ0FBQyxzRkFBWTtBQUNwQyxJQUFJYyxRQUFRZCxtQkFBT0EsQ0FBQyx5RkFBbUI7QUFDdkMsSUFBSWUsYUFBYWYsbUJBQU9BLENBQUMseUZBQW1CO0FBQzVDLElBQUlnQixjQUFjaEIsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlpQixTQUFTakIsbUJBQU9BLENBQUMsaUZBQWU7QUFDcEMsSUFBSWtCLGdCQUFnQmxCLG1CQUFPQSxDQUFDLCtGQUFzQjtBQUNsRCxJQUFJbUI7QUFDSixT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O1lBQ1BxQixTQUFTdUU7UUFDWDtRQUNBLElBQUlySCxPQUFPZ0ksTUFBTSxNQUFNcEIsTUFBTWlCLEtBQUssQ0FBQ0csS0FBS0w7UUFDeEMsSUFBSWMsU0FBU0MsS0FBS0MsSUFBSSxDQUFDRCxLQUFLRSxHQUFHLENBQUM1SSxNQUFNLEtBQUswSSxLQUFLRyxFQUFFO1FBQ2xELE9BQU9sTixjQUFjQSxjQUFjLENBQUMsR0FBRzZELFFBQVEsQ0FBQyxHQUFHO1lBQ2pETSxJQUFJQTtZQUNKQyxJQUFJQTtZQUNKcUQsR0FBR3RELEtBQUsySTtZQUNScEYsR0FBR3RELEtBQUswSTtZQUNSckcsT0FBT0E7WUFDUEMsT0FBT0E7WUFDUHVFLE9BQU9BO1lBQ1B6QixPQUFPLElBQUlzRDtZQUNYckQsUUFBUSxJQUFJcUQ7WUFDWnpJLE1BQU1BO1lBQ05zRCxNQUFNO2dCQUNKRixHQUFHQTtnQkFDSEMsR0FBR0E7Z0JBQ0gyRSxHQUFHQTtZQUNMO1lBQ0FDLGdCQUFnQkE7WUFDaEJhLGlCQUFpQjtnQkFDZjFGLEdBQUd0RDtnQkFDSHVELEdBQUd0RDtZQUNMO1lBQ0FxSSxTQUFTNUk7UUFDWCxHQUFHMEgsU0FBU0EsS0FBSyxDQUFDekYsTUFBTSxJQUFJeUYsS0FBSyxDQUFDekYsTUFBTSxDQUFDcEYsS0FBSztJQUNoRDtJQUNBLE9BQU9WLGNBQWM7UUFDbkJvRCxRQUFRQTtJQUNWLEdBQUdpSTtBQUNMIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxjYXJ0ZXNpYW5cXFNjYXR0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5TY2F0dGVyID0gdm9pZCAwO1xyXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIF9yZWFjdFNtb290aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0LXNtb290aFwiKSk7XHJcbnZhciBfaXNOaWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNOaWxcIikpO1xyXG52YXIgX2lzRXF1YWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNFcXVhbFwiKSk7XHJcbnZhciBfaXNGdW5jdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpKTtcclxudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XHJcbnZhciBfTGF5ZXIgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL0xheWVyXCIpO1xyXG52YXIgX0xhYmVsTGlzdCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQvTGFiZWxMaXN0XCIpO1xyXG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xyXG52YXIgX0dsb2JhbCA9IHJlcXVpcmUoXCIuLi91dGlsL0dsb2JhbFwiKTtcclxudmFyIF9aQXhpcyA9IHJlcXVpcmUoXCIuL1pBeGlzXCIpO1xyXG52YXIgX0N1cnZlID0gcmVxdWlyZShcIi4uL3NoYXBlL0N1cnZlXCIpO1xyXG52YXIgX0Vycm9yQmFyID0gcmVxdWlyZShcIi4vRXJyb3JCYXJcIik7XHJcbnZhciBfQ2VsbCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQvQ2VsbFwiKTtcclxudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9EYXRhVXRpbHNcIik7XHJcbnZhciBfQ2hhcnRVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NoYXJ0VXRpbHNcIik7XHJcbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi4vdXRpbC90eXBlc1wiKTtcclxudmFyIF9TY2F0dGVyVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9TY2F0dGVyVXRpbHNcIik7XHJcbnZhciBfU2NhdHRlcjtcclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XHJcbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBudWxsOyB2YXIgciA9IG5ldyBXZWFrTWFwKCksIHQgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IHJldHVybiBlID8gdCA6IHI7IH0pKGUpOyB9XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHUpKSB7IHZhciBpID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdSkgOiBudWxsOyBpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgdSwgaSkgOiBuW3VdID0gZVt1XTsgfSByZXR1cm4gbltcImRlZmF1bHRcIl0gPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XHJcbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cclxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XHJcbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XHJcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XHJcbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XHJcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxyXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cclxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XHJcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XHJcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cclxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH0gLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgUmVuZGVyIGEgZ3JvdXAgb2Ygc2NhdHRlcnNcclxuICovXHJcbnZhciBTY2F0dGVyID0gZXhwb3J0cy5TY2F0dGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xyXG4gIGZ1bmN0aW9uIFNjYXR0ZXIoKSB7XHJcbiAgICB2YXIgX3RoaXM7XHJcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2NhdHRlcik7XHJcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcclxuICAgIH1cclxuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBTY2F0dGVyLCBbXS5jb25jYXQoYXJncykpO1xyXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInN0YXRlXCIsIHtcclxuICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogZmFsc2VcclxuICAgIH0pO1xyXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZUFuaW1hdGlvbkVuZFwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcclxuICAgICAgICBpc0FuaW1hdGlvbkZpbmlzaGVkOiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlQW5pbWF0aW9uU3RhcnRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogZmFsc2VcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJpZFwiLCAoMCwgX0RhdGFVdGlscy51bmlxdWVJZCkoJ3JlY2hhcnRzLXNjYXR0ZXItJykpO1xyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuICBfaW5oZXJpdHMoU2NhdHRlciwgX1B1cmVDb21wb25lbnQpO1xyXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoU2NhdHRlciwgW3tcclxuICAgIGtleTogXCJyZW5kZXJTeW1ib2xzU3RhdGljYWxseVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclN5bWJvbHNTdGF0aWNhbGx5KHBvaW50cykge1xyXG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBzaGFwZSA9IF90aGlzJHByb3BzLnNoYXBlLFxyXG4gICAgICAgIGFjdGl2ZVNoYXBlID0gX3RoaXMkcHJvcHMuYWN0aXZlU2hhcGUsXHJcbiAgICAgICAgYWN0aXZlSW5kZXggPSBfdGhpcyRwcm9wcy5hY3RpdmVJbmRleDtcclxuICAgICAgdmFyIGJhc2VQcm9wcyA9ICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykodGhpcy5wcm9wcywgZmFsc2UpO1xyXG4gICAgICByZXR1cm4gcG9pbnRzLm1hcChmdW5jdGlvbiAoZW50cnksIGkpIHtcclxuICAgICAgICB2YXIgaXNBY3RpdmUgPSBhY3RpdmVJbmRleCA9PT0gaTtcclxuICAgICAgICB2YXIgb3B0aW9uID0gaXNBY3RpdmUgPyBhY3RpdmVTaGFwZSA6IHNoYXBlO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgYmFzZVByb3BzKSwgZW50cnkpO1xyXG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwgX2V4dGVuZHMoe1xyXG4gICAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXNjYXR0ZXItc3ltYm9sXCJcclxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1hcnJheS1pbmRleC1rZXlcclxuICAgICAgICAgICxcclxuICAgICAgICAgIGtleTogXCJzeW1ib2wtXCIuY29uY2F0KGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS5jeCwgXCItXCIpLmNvbmNhdChlbnRyeSA9PT0gbnVsbCB8fCBlbnRyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW50cnkuY3ksIFwiLVwiKS5jb25jYXQoZW50cnkgPT09IG51bGwgfHwgZW50cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVudHJ5LnNpemUsIFwiLVwiKS5jb25jYXQoaSlcclxuICAgICAgICB9LCAoMCwgX3R5cGVzLmFkYXB0RXZlbnRzT2ZDaGlsZCkoX3RoaXMyLnByb3BzLCBlbnRyeSwgaSksIHtcclxuICAgICAgICAgIHJvbGU6IFwiaW1nXCJcclxuICAgICAgICB9KSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfU2NhdHRlclV0aWxzLlNjYXR0ZXJTeW1ib2wsIF9leHRlbmRzKHtcclxuICAgICAgICAgIG9wdGlvbjogb3B0aW9uLFxyXG4gICAgICAgICAgaXNBY3RpdmU6IGlzQWN0aXZlXHJcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XHJcbiAgICAgICAgICAsXHJcbiAgICAgICAgICBrZXk6IFwic3ltYm9sLVwiLmNvbmNhdChpKVxyXG4gICAgICAgIH0sIHByb3BzKSkpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyU3ltYm9sc1dpdGhBbmltYXRpb25cIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJTeW1ib2xzV2l0aEFuaW1hdGlvbigpIHtcclxuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIHBvaW50cyA9IF90aGlzJHByb3BzMi5wb2ludHMsXHJcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wczIuaXNBbmltYXRpb25BY3RpdmUsXHJcbiAgICAgICAgYW5pbWF0aW9uQmVnaW4gPSBfdGhpcyRwcm9wczIuYW5pbWF0aW9uQmVnaW4sXHJcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb24gPSBfdGhpcyRwcm9wczIuYW5pbWF0aW9uRHVyYXRpb24sXHJcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nID0gX3RoaXMkcHJvcHMyLmFuaW1hdGlvbkVhc2luZyxcclxuICAgICAgICBhbmltYXRpb25JZCA9IF90aGlzJHByb3BzMi5hbmltYXRpb25JZDtcclxuICAgICAgdmFyIHByZXZQb2ludHMgPSB0aGlzLnN0YXRlLnByZXZQb2ludHM7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9yZWFjdFNtb290aFtcImRlZmF1bHRcIl0sIHtcclxuICAgICAgICBiZWdpbjogYW5pbWF0aW9uQmVnaW4sXHJcbiAgICAgICAgZHVyYXRpb246IGFuaW1hdGlvbkR1cmF0aW9uLFxyXG4gICAgICAgIGlzQWN0aXZlOiBpc0FuaW1hdGlvbkFjdGl2ZSxcclxuICAgICAgICBlYXNpbmc6IGFuaW1hdGlvbkVhc2luZyxcclxuICAgICAgICBmcm9tOiB7XHJcbiAgICAgICAgICB0OiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0bzoge1xyXG4gICAgICAgICAgdDogMVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAga2V5OiBcInBpZS1cIi5jb25jYXQoYW5pbWF0aW9uSWQpLFxyXG4gICAgICAgIG9uQW5pbWF0aW9uRW5kOiB0aGlzLmhhbmRsZUFuaW1hdGlvbkVuZCxcclxuICAgICAgICBvbkFuaW1hdGlvblN0YXJ0OiB0aGlzLmhhbmRsZUFuaW1hdGlvblN0YXJ0XHJcbiAgICAgIH0sIGZ1bmN0aW9uIChfcmVmKSB7XHJcbiAgICAgICAgdmFyIHQgPSBfcmVmLnQ7XHJcbiAgICAgICAgdmFyIHN0ZXBEYXRhID0gcG9pbnRzLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XHJcbiAgICAgICAgICB2YXIgcHJldiA9IHByZXZQb2ludHMgJiYgcHJldlBvaW50c1tpbmRleF07XHJcbiAgICAgICAgICBpZiAocHJldikge1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJwb2xhdG9yQ3ggPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikocHJldi5jeCwgZW50cnkuY3gpO1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJwb2xhdG9yQ3kgPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikocHJldi5jeSwgZW50cnkuY3kpO1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJwb2xhdG9yU2l6ZSA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShwcmV2LnNpemUsIGVudHJ5LnNpemUpO1xyXG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeSksIHt9LCB7XHJcbiAgICAgICAgICAgICAgY3g6IGludGVycG9sYXRvckN4KHQpLFxyXG4gICAgICAgICAgICAgIGN5OiBpbnRlcnBvbGF0b3JDeSh0KSxcclxuICAgICAgICAgICAgICBzaXplOiBpbnRlcnBvbGF0b3JTaXplKHQpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFyIGludGVycG9sYXRvciA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKSgwLCBlbnRyeS5zaXplKTtcclxuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcclxuICAgICAgICAgICAgc2l6ZTogaW50ZXJwb2xhdG9yKHQpXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIG51bGwsIF90aGlzMy5yZW5kZXJTeW1ib2xzU3RhdGljYWxseShzdGVwRGF0YSkpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyU3ltYm9sc1wiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclN5bWJvbHMoKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIHBvaW50cyA9IF90aGlzJHByb3BzMy5wb2ludHMsXHJcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wczMuaXNBbmltYXRpb25BY3RpdmU7XHJcbiAgICAgIHZhciBwcmV2UG9pbnRzID0gdGhpcy5zdGF0ZS5wcmV2UG9pbnRzO1xyXG4gICAgICBpZiAoaXNBbmltYXRpb25BY3RpdmUgJiYgcG9pbnRzICYmIHBvaW50cy5sZW5ndGggJiYgKCFwcmV2UG9pbnRzIHx8ICEoMCwgX2lzRXF1YWxbXCJkZWZhdWx0XCJdKShwcmV2UG9pbnRzLCBwb2ludHMpKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlclN5bWJvbHNXaXRoQW5pbWF0aW9uKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyU3ltYm9sc1N0YXRpY2FsbHkocG9pbnRzKTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyRXJyb3JCYXJcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJFcnJvckJhcigpIHtcclxuICAgICAgdmFyIGlzQW5pbWF0aW9uQWN0aXZlID0gdGhpcy5wcm9wcy5pc0FuaW1hdGlvbkFjdGl2ZTtcclxuICAgICAgaWYgKGlzQW5pbWF0aW9uQWN0aXZlICYmICF0aGlzLnN0YXRlLmlzQW5pbWF0aW9uRmluaXNoZWQpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBwb2ludHMgPSBfdGhpcyRwcm9wczQucG9pbnRzLFxyXG4gICAgICAgIHhBeGlzID0gX3RoaXMkcHJvcHM0LnhBeGlzLFxyXG4gICAgICAgIHlBeGlzID0gX3RoaXMkcHJvcHM0LnlBeGlzLFxyXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHM0LmNoaWxkcmVuO1xyXG4gICAgICB2YXIgZXJyb3JCYXJJdGVtcyA9ICgwLCBfUmVhY3RVdGlscy5maW5kQWxsQnlUeXBlKShjaGlsZHJlbiwgX0Vycm9yQmFyLkVycm9yQmFyKTtcclxuICAgICAgaWYgKCFlcnJvckJhckl0ZW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGVycm9yQmFySXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtLCBpKSB7XHJcbiAgICAgICAgdmFyIF9pdGVtJHByb3BzID0gaXRlbS5wcm9wcyxcclxuICAgICAgICAgIGRpcmVjdGlvbiA9IF9pdGVtJHByb3BzLmRpcmVjdGlvbixcclxuICAgICAgICAgIGVycm9yRGF0YUtleSA9IF9pdGVtJHByb3BzLmRhdGFLZXk7XHJcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChpdGVtLCB7XHJcbiAgICAgICAgICBrZXk6IFwiXCIuY29uY2F0KGRpcmVjdGlvbiwgXCItXCIpLmNvbmNhdChlcnJvckRhdGFLZXksIFwiLVwiKS5jb25jYXQocG9pbnRzW2ldKSxcclxuICAgICAgICAgIGRhdGE6IHBvaW50cyxcclxuICAgICAgICAgIHhBeGlzOiB4QXhpcyxcclxuICAgICAgICAgIHlBeGlzOiB5QXhpcyxcclxuICAgICAgICAgIGxheW91dDogZGlyZWN0aW9uID09PSAneCcgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnLFxyXG4gICAgICAgICAgZGF0YVBvaW50Rm9ybWF0dGVyOiBmdW5jdGlvbiBkYXRhUG9pbnRGb3JtYXR0ZXIoZGF0YVBvaW50LCBkYXRhS2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgeDogZGF0YVBvaW50LmN4LFxyXG4gICAgICAgICAgICAgIHk6IGRhdGFQb2ludC5jeSxcclxuICAgICAgICAgICAgICB2YWx1ZTogZGlyZWN0aW9uID09PSAneCcgPyArZGF0YVBvaW50Lm5vZGUueCA6ICtkYXRhUG9pbnQubm9kZS55LFxyXG4gICAgICAgICAgICAgIGVycm9yVmFsOiAoMCwgX0NoYXJ0VXRpbHMuZ2V0VmFsdWVCeURhdGFLZXkpKGRhdGFQb2ludCwgZGF0YUtleSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJlbmRlckxpbmVcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJMaW5lKCkge1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHM1ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBwb2ludHMgPSBfdGhpcyRwcm9wczUucG9pbnRzLFxyXG4gICAgICAgIGxpbmUgPSBfdGhpcyRwcm9wczUubGluZSxcclxuICAgICAgICBsaW5lVHlwZSA9IF90aGlzJHByb3BzNS5saW5lVHlwZSxcclxuICAgICAgICBsaW5lSm9pbnRUeXBlID0gX3RoaXMkcHJvcHM1LmxpbmVKb2ludFR5cGU7XHJcbiAgICAgIHZhciBzY2F0dGVyUHJvcHMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRoaXMucHJvcHMsIGZhbHNlKTtcclxuICAgICAgdmFyIGN1c3RvbUxpbmVQcm9wcyA9ICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykobGluZSwgZmFsc2UpO1xyXG4gICAgICB2YXIgbGluZVBvaW50cywgbGluZUl0ZW07XHJcbiAgICAgIGlmIChsaW5lVHlwZSA9PT0gJ2pvaW50Jykge1xyXG4gICAgICAgIGxpbmVQb2ludHMgPSBwb2ludHMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogZW50cnkuY3gsXHJcbiAgICAgICAgICAgIHk6IGVudHJ5LmN5XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2UgaWYgKGxpbmVUeXBlID09PSAnZml0dGluZycpIHtcclxuICAgICAgICB2YXIgX2dldExpbmVhclJlZ3Jlc3Npb24gPSAoMCwgX0RhdGFVdGlscy5nZXRMaW5lYXJSZWdyZXNzaW9uKShwb2ludHMpLFxyXG4gICAgICAgICAgeG1pbiA9IF9nZXRMaW5lYXJSZWdyZXNzaW9uLnhtaW4sXHJcbiAgICAgICAgICB4bWF4ID0gX2dldExpbmVhclJlZ3Jlc3Npb24ueG1heCxcclxuICAgICAgICAgIGEgPSBfZ2V0TGluZWFyUmVncmVzc2lvbi5hLFxyXG4gICAgICAgICAgYiA9IF9nZXRMaW5lYXJSZWdyZXNzaW9uLmI7XHJcbiAgICAgICAgdmFyIGxpbmVhckV4cCA9IGZ1bmN0aW9uIGxpbmVhckV4cCh4KSB7XHJcbiAgICAgICAgICByZXR1cm4gYSAqIHggKyBiO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGluZVBvaW50cyA9IFt7XHJcbiAgICAgICAgICB4OiB4bWluLFxyXG4gICAgICAgICAgeTogbGluZWFyRXhwKHhtaW4pXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgeDogeG1heCxcclxuICAgICAgICAgIHk6IGxpbmVhckV4cCh4bWF4KVxyXG4gICAgICAgIH1dO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBsaW5lUHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc2NhdHRlclByb3BzKSwge30sIHtcclxuICAgICAgICBmaWxsOiAnbm9uZScsXHJcbiAgICAgICAgc3Ryb2tlOiBzY2F0dGVyUHJvcHMgJiYgc2NhdHRlclByb3BzLmZpbGxcclxuICAgICAgfSwgY3VzdG9tTGluZVByb3BzKSwge30sIHtcclxuICAgICAgICBwb2ludHM6IGxpbmVQb2ludHNcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uaXNWYWxpZEVsZW1lbnQobGluZSkpIHtcclxuICAgICAgICBsaW5lSXRlbSA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChsaW5lLCBsaW5lUHJvcHMpO1xyXG4gICAgICB9IGVsc2UgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKGxpbmUpKSB7XHJcbiAgICAgICAgbGluZUl0ZW0gPSBsaW5lKGxpbmVQcm9wcyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGluZUl0ZW0gPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9DdXJ2ZS5DdXJ2ZSwgX2V4dGVuZHMoe30sIGxpbmVQcm9wcywge1xyXG4gICAgICAgICAgdHlwZTogbGluZUpvaW50VHlwZVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIHtcclxuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtc2NhdHRlci1saW5lXCIsXHJcbiAgICAgICAga2V5OiBcInJlY2hhcnRzLXNjYXR0ZXItbGluZVwiXHJcbiAgICAgIH0sIGxpbmVJdGVtKTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHM2ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBoaWRlID0gX3RoaXMkcHJvcHM2LmhpZGUsXHJcbiAgICAgICAgcG9pbnRzID0gX3RoaXMkcHJvcHM2LnBvaW50cyxcclxuICAgICAgICBsaW5lID0gX3RoaXMkcHJvcHM2LmxpbmUsXHJcbiAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHM2LmNsYXNzTmFtZSxcclxuICAgICAgICB4QXhpcyA9IF90aGlzJHByb3BzNi54QXhpcyxcclxuICAgICAgICB5QXhpcyA9IF90aGlzJHByb3BzNi55QXhpcyxcclxuICAgICAgICBsZWZ0ID0gX3RoaXMkcHJvcHM2LmxlZnQsXHJcbiAgICAgICAgdG9wID0gX3RoaXMkcHJvcHM2LnRvcCxcclxuICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzNi53aWR0aCxcclxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczYuaGVpZ2h0LFxyXG4gICAgICAgIGlkID0gX3RoaXMkcHJvcHM2LmlkLFxyXG4gICAgICAgIGlzQW5pbWF0aW9uQWN0aXZlID0gX3RoaXMkcHJvcHM2LmlzQW5pbWF0aW9uQWN0aXZlO1xyXG4gICAgICBpZiAoaGlkZSB8fCAhcG9pbnRzIHx8ICFwb2ludHMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGlzQW5pbWF0aW9uRmluaXNoZWQgPSB0aGlzLnN0YXRlLmlzQW5pbWF0aW9uRmluaXNoZWQ7XHJcbiAgICAgIHZhciBsYXllckNsYXNzID0gKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXNjYXR0ZXInLCBjbGFzc05hbWUpO1xyXG4gICAgICB2YXIgbmVlZENsaXBYID0geEF4aXMgJiYgeEF4aXMuYWxsb3dEYXRhT3ZlcmZsb3c7XHJcbiAgICAgIHZhciBuZWVkQ2xpcFkgPSB5QXhpcyAmJiB5QXhpcy5hbGxvd0RhdGFPdmVyZmxvdztcclxuICAgICAgdmFyIG5lZWRDbGlwID0gbmVlZENsaXBYIHx8IG5lZWRDbGlwWTtcclxuICAgICAgdmFyIGNsaXBQYXRoSWQgPSAoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoaWQpID8gdGhpcy5pZCA6IGlkO1xyXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIHtcclxuICAgICAgICBjbGFzc05hbWU6IGxheWVyQ2xhc3MsXHJcbiAgICAgICAgY2xpcFBhdGg6IG5lZWRDbGlwID8gXCJ1cmwoI2NsaXBQYXRoLVwiLmNvbmNhdChjbGlwUGF0aElkLCBcIilcIikgOiBudWxsXHJcbiAgICAgIH0sIG5lZWRDbGlwWCB8fCBuZWVkQ2xpcFkgPyAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiLCBudWxsLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIiwge1xyXG4gICAgICAgIGlkOiBcImNsaXBQYXRoLVwiLmNvbmNhdChjbGlwUGF0aElkKVxyXG4gICAgICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XHJcbiAgICAgICAgeDogbmVlZENsaXBYID8gbGVmdCA6IGxlZnQgLSB3aWR0aCAvIDIsXHJcbiAgICAgICAgeTogbmVlZENsaXBZID8gdG9wIDogdG9wIC0gaGVpZ2h0IC8gMixcclxuICAgICAgICB3aWR0aDogbmVlZENsaXBYID8gd2lkdGggOiB3aWR0aCAqIDIsXHJcbiAgICAgICAgaGVpZ2h0OiBuZWVkQ2xpcFkgPyBoZWlnaHQgOiBoZWlnaHQgKiAyXHJcbiAgICAgIH0pKSkgOiBudWxsLCBsaW5lICYmIHRoaXMucmVuZGVyTGluZSgpLCB0aGlzLnJlbmRlckVycm9yQmFyKCksIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XHJcbiAgICAgICAga2V5OiBcInJlY2hhcnRzLXNjYXR0ZXItc3ltYm9sc1wiXHJcbiAgICAgIH0sIHRoaXMucmVuZGVyU3ltYm9scygpKSwgKCFpc0FuaW1hdGlvbkFjdGl2ZSB8fCBpc0FuaW1hdGlvbkZpbmlzaGVkKSAmJiBfTGFiZWxMaXN0LkxhYmVsTGlzdC5yZW5kZXJDYWxsQnlQYXJlbnQodGhpcy5wcm9wcywgcG9pbnRzKSk7XHJcbiAgICB9XHJcbiAgfV0sIFt7XHJcbiAgICBrZXk6IFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKSB7XHJcbiAgICAgIGlmIChuZXh0UHJvcHMuYW5pbWF0aW9uSWQgIT09IHByZXZTdGF0ZS5wcmV2QW5pbWF0aW9uSWQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgcHJldkFuaW1hdGlvbklkOiBuZXh0UHJvcHMuYW5pbWF0aW9uSWQsXHJcbiAgICAgICAgICBjdXJQb2ludHM6IG5leHRQcm9wcy5wb2ludHMsXHJcbiAgICAgICAgICBwcmV2UG9pbnRzOiBwcmV2U3RhdGUuY3VyUG9pbnRzXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobmV4dFByb3BzLnBvaW50cyAhPT0gcHJldlN0YXRlLmN1clBvaW50cykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBjdXJQb2ludHM6IG5leHRQcm9wcy5wb2ludHNcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1dKTtcclxufShfcmVhY3QuUHVyZUNvbXBvbmVudCk7XHJcbl9TY2F0dGVyID0gU2NhdHRlcjtcclxuX2RlZmluZVByb3BlcnR5KFNjYXR0ZXIsIFwiZGlzcGxheU5hbWVcIiwgJ1NjYXR0ZXInKTtcclxuX2RlZmluZVByb3BlcnR5KFNjYXR0ZXIsIFwiZGVmYXVsdFByb3BzXCIsIHtcclxuICB4QXhpc0lkOiAwLFxyXG4gIHlBeGlzSWQ6IDAsXHJcbiAgekF4aXNJZDogMCxcclxuICBsZWdlbmRUeXBlOiAnY2lyY2xlJyxcclxuICBsaW5lVHlwZTogJ2pvaW50JyxcclxuICBsaW5lSm9pbnRUeXBlOiAnbGluZWFyJyxcclxuICBkYXRhOiBbXSxcclxuICBzaGFwZTogJ2NpcmNsZScsXHJcbiAgaGlkZTogZmFsc2UsXHJcbiAgaXNBbmltYXRpb25BY3RpdmU6ICFfR2xvYmFsLkdsb2JhbC5pc1NzcixcclxuICBhbmltYXRpb25CZWdpbjogMCxcclxuICBhbmltYXRpb25EdXJhdGlvbjogNDAwLFxyXG4gIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcidcclxufSk7XHJcbi8qKlxyXG4gKiBDb21wb3NlIHRoZSBkYXRhIG9mIGVhY2ggZ3JvdXBcclxuICogQHBhcmFtICB7T2JqZWN0fSB4QXhpcyAgIFRoZSBjb25maWd1cmF0aW9uIG9mIHgtYXhpc1xyXG4gKiBAcGFyYW0gIHtPYmplY3R9IHlBeGlzICAgVGhlIGNvbmZpZ3VyYXRpb24gb2YgeS1heGlzXHJcbiAqIEBwYXJhbSAge1N0cmluZ30gZGF0YUtleSBUaGUgdW5pcXVlIGtleSBvZiBhIGdyb3VwXHJcbiAqIEByZXR1cm4ge0FycmF5fSAgQ29tcG9zZWQgZGF0YVxyXG4gKi9cclxuX2RlZmluZVByb3BlcnR5KFNjYXR0ZXIsIFwiZ2V0Q29tcG9zZWREYXRhXCIsIGZ1bmN0aW9uIChfcmVmMikge1xyXG4gIHZhciB4QXhpcyA9IF9yZWYyLnhBeGlzLFxyXG4gICAgeUF4aXMgPSBfcmVmMi55QXhpcyxcclxuICAgIHpBeGlzID0gX3JlZjIuekF4aXMsXHJcbiAgICBpdGVtID0gX3JlZjIuaXRlbSxcclxuICAgIGRpc3BsYXllZERhdGEgPSBfcmVmMi5kaXNwbGF5ZWREYXRhLFxyXG4gICAgeEF4aXNUaWNrcyA9IF9yZWYyLnhBeGlzVGlja3MsXHJcbiAgICB5QXhpc1RpY2tzID0gX3JlZjIueUF4aXNUaWNrcyxcclxuICAgIG9mZnNldCA9IF9yZWYyLm9mZnNldDtcclxuICB2YXIgdG9vbHRpcFR5cGUgPSBpdGVtLnByb3BzLnRvb2x0aXBUeXBlO1xyXG4gIHZhciBjZWxscyA9ICgwLCBfUmVhY3RVdGlscy5maW5kQWxsQnlUeXBlKShpdGVtLnByb3BzLmNoaWxkcmVuLCBfQ2VsbC5DZWxsKTtcclxuICB2YXIgeEF4aXNEYXRhS2V5ID0gKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKHhBeGlzLmRhdGFLZXkpID8gaXRlbS5wcm9wcy5kYXRhS2V5IDogeEF4aXMuZGF0YUtleTtcclxuICB2YXIgeUF4aXNEYXRhS2V5ID0gKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKHlBeGlzLmRhdGFLZXkpID8gaXRlbS5wcm9wcy5kYXRhS2V5IDogeUF4aXMuZGF0YUtleTtcclxuICB2YXIgekF4aXNEYXRhS2V5ID0gekF4aXMgJiYgekF4aXMuZGF0YUtleTtcclxuICB2YXIgZGVmYXVsdFJhbmdlWiA9IHpBeGlzID8gekF4aXMucmFuZ2UgOiBfWkF4aXMuWkF4aXMuZGVmYXVsdFByb3BzLnJhbmdlO1xyXG4gIHZhciBkZWZhdWx0WiA9IGRlZmF1bHRSYW5nZVogJiYgZGVmYXVsdFJhbmdlWlswXTtcclxuICB2YXIgeEJhbmRTaXplID0geEF4aXMuc2NhbGUuYmFuZHdpZHRoID8geEF4aXMuc2NhbGUuYmFuZHdpZHRoKCkgOiAwO1xyXG4gIHZhciB5QmFuZFNpemUgPSB5QXhpcy5zY2FsZS5iYW5kd2lkdGggPyB5QXhpcy5zY2FsZS5iYW5kd2lkdGgoKSA6IDA7XHJcbiAgdmFyIHBvaW50cyA9IGRpc3BsYXllZERhdGEubWFwKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHtcclxuICAgIHZhciB4ID0gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShlbnRyeSwgeEF4aXNEYXRhS2V5KTtcclxuICAgIHZhciB5ID0gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShlbnRyeSwgeUF4aXNEYXRhS2V5KTtcclxuICAgIHZhciB6ID0gISgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKSh6QXhpc0RhdGFLZXkpICYmICgwLCBfQ2hhcnRVdGlscy5nZXRWYWx1ZUJ5RGF0YUtleSkoZW50cnksIHpBeGlzRGF0YUtleSkgfHwgJy0nO1xyXG4gICAgdmFyIHRvb2x0aXBQYXlsb2FkID0gW3tcclxuICAgICAgbmFtZTogKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKHhBeGlzLmRhdGFLZXkpID8gaXRlbS5wcm9wcy5uYW1lIDogeEF4aXMubmFtZSB8fCB4QXhpcy5kYXRhS2V5LFxyXG4gICAgICB1bml0OiB4QXhpcy51bml0IHx8ICcnLFxyXG4gICAgICB2YWx1ZTogeCxcclxuICAgICAgcGF5bG9hZDogZW50cnksXHJcbiAgICAgIGRhdGFLZXk6IHhBeGlzRGF0YUtleSxcclxuICAgICAgdHlwZTogdG9vbHRpcFR5cGVcclxuICAgIH0sIHtcclxuICAgICAgbmFtZTogKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKHlBeGlzLmRhdGFLZXkpID8gaXRlbS5wcm9wcy5uYW1lIDogeUF4aXMubmFtZSB8fCB5QXhpcy5kYXRhS2V5LFxyXG4gICAgICB1bml0OiB5QXhpcy51bml0IHx8ICcnLFxyXG4gICAgICB2YWx1ZTogeSxcclxuICAgICAgcGF5bG9hZDogZW50cnksXHJcbiAgICAgIGRhdGFLZXk6IHlBeGlzRGF0YUtleSxcclxuICAgICAgdHlwZTogdG9vbHRpcFR5cGVcclxuICAgIH1dO1xyXG4gICAgaWYgKHogIT09ICctJykge1xyXG4gICAgICB0b29sdGlwUGF5bG9hZC5wdXNoKHtcclxuICAgICAgICBuYW1lOiB6QXhpcy5uYW1lIHx8IHpBeGlzLmRhdGFLZXksXHJcbiAgICAgICAgdW5pdDogekF4aXMudW5pdCB8fCAnJyxcclxuICAgICAgICB2YWx1ZTogeixcclxuICAgICAgICBwYXlsb2FkOiBlbnRyeSxcclxuICAgICAgICBkYXRhS2V5OiB6QXhpc0RhdGFLZXksXHJcbiAgICAgICAgdHlwZTogdG9vbHRpcFR5cGVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB2YXIgY3ggPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0Q2F0ZUNvb3JkaW5hdGVPZkxpbmUpKHtcclxuICAgICAgYXhpczogeEF4aXMsXHJcbiAgICAgIHRpY2tzOiB4QXhpc1RpY2tzLFxyXG4gICAgICBiYW5kU2l6ZTogeEJhbmRTaXplLFxyXG4gICAgICBlbnRyeTogZW50cnksXHJcbiAgICAgIGluZGV4OiBpbmRleCxcclxuICAgICAgZGF0YUtleTogeEF4aXNEYXRhS2V5XHJcbiAgICB9KTtcclxuICAgIHZhciBjeSA9ICgwLCBfQ2hhcnRVdGlscy5nZXRDYXRlQ29vcmRpbmF0ZU9mTGluZSkoe1xyXG4gICAgICBheGlzOiB5QXhpcyxcclxuICAgICAgdGlja3M6IHlBeGlzVGlja3MsXHJcbiAgICAgIGJhbmRTaXplOiB5QmFuZFNpemUsXHJcbiAgICAgIGVudHJ5OiBlbnRyeSxcclxuICAgICAgaW5kZXg6IGluZGV4LFxyXG4gICAgICBkYXRhS2V5OiB5QXhpc0RhdGFLZXlcclxuICAgIH0pO1xyXG4gICAgdmFyIHNpemUgPSB6ICE9PSAnLScgPyB6QXhpcy5zY2FsZSh6KSA6IGRlZmF1bHRaO1xyXG4gICAgdmFyIHJhZGl1cyA9IE1hdGguc3FydChNYXRoLm1heChzaXplLCAwKSAvIE1hdGguUEkpO1xyXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xyXG4gICAgICBjeDogY3gsXHJcbiAgICAgIGN5OiBjeSxcclxuICAgICAgeDogY3ggLSByYWRpdXMsXHJcbiAgICAgIHk6IGN5IC0gcmFkaXVzLFxyXG4gICAgICB4QXhpczogeEF4aXMsXHJcbiAgICAgIHlBeGlzOiB5QXhpcyxcclxuICAgICAgekF4aXM6IHpBeGlzLFxyXG4gICAgICB3aWR0aDogMiAqIHJhZGl1cyxcclxuICAgICAgaGVpZ2h0OiAyICogcmFkaXVzLFxyXG4gICAgICBzaXplOiBzaXplLFxyXG4gICAgICBub2RlOiB7XHJcbiAgICAgICAgeDogeCxcclxuICAgICAgICB5OiB5LFxyXG4gICAgICAgIHo6IHpcclxuICAgICAgfSxcclxuICAgICAgdG9vbHRpcFBheWxvYWQ6IHRvb2x0aXBQYXlsb2FkLFxyXG4gICAgICB0b29sdGlwUG9zaXRpb246IHtcclxuICAgICAgICB4OiBjeCxcclxuICAgICAgICB5OiBjeVxyXG4gICAgICB9LFxyXG4gICAgICBwYXlsb2FkOiBlbnRyeVxyXG4gICAgfSwgY2VsbHMgJiYgY2VsbHNbaW5kZXhdICYmIGNlbGxzW2luZGV4XS5wcm9wcyk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xyXG4gICAgcG9pbnRzOiBwb2ludHNcclxuICB9LCBvZmZzZXQpO1xyXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTY2F0dGVyIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX3JlYWN0U21vb3RoIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9pc05pbCIsIl9pc0VxdWFsIiwiX2lzRnVuY3Rpb24iLCJfY2xzeCIsIl9MYXllciIsIl9MYWJlbExpc3QiLCJfUmVhY3RVdGlscyIsIl9HbG9iYWwiLCJfWkF4aXMiLCJfQ3VydmUiLCJfRXJyb3JCYXIiLCJfQ2VsbCIsIl9EYXRhVXRpbHMiLCJfQ2hhcnRVdGlscyIsIl90eXBlcyIsIl9TY2F0dGVyVXRpbHMiLCJfU2NhdHRlciIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX3R5cGVvZiIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJhcHBseSIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9Qcm9wZXJ0eUtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsInAiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsIl9QdXJlQ29tcG9uZW50IiwiX3RoaXMiLCJfbGVuIiwiYXJncyIsIkFycmF5IiwiX2tleSIsImNvbmNhdCIsImlzQW5pbWF0aW9uRmluaXNoZWQiLCJzZXRTdGF0ZSIsInVuaXF1ZUlkIiwicmVuZGVyU3ltYm9sc1N0YXRpY2FsbHkiLCJwb2ludHMiLCJfdGhpczIiLCJfdGhpcyRwcm9wcyIsInNoYXBlIiwiYWN0aXZlU2hhcGUiLCJhY3RpdmVJbmRleCIsImJhc2VQcm9wcyIsImZpbHRlclByb3BzIiwibWFwIiwiZW50cnkiLCJpc0FjdGl2ZSIsIm9wdGlvbiIsImNyZWF0ZUVsZW1lbnQiLCJMYXllciIsImNsYXNzTmFtZSIsImN4IiwiY3kiLCJzaXplIiwiYWRhcHRFdmVudHNPZkNoaWxkIiwicm9sZSIsIlNjYXR0ZXJTeW1ib2wiLCJyZW5kZXJTeW1ib2xzV2l0aEFuaW1hdGlvbiIsIl90aGlzMyIsIl90aGlzJHByb3BzMiIsImlzQW5pbWF0aW9uQWN0aXZlIiwiYW5pbWF0aW9uQmVnaW4iLCJhbmltYXRpb25EdXJhdGlvbiIsImFuaW1hdGlvbkVhc2luZyIsImFuaW1hdGlvbklkIiwicHJldlBvaW50cyIsInN0YXRlIiwiYmVnaW4iLCJkdXJhdGlvbiIsImVhc2luZyIsImZyb20iLCJ0byIsIm9uQW5pbWF0aW9uRW5kIiwiaGFuZGxlQW5pbWF0aW9uRW5kIiwib25BbmltYXRpb25TdGFydCIsImhhbmRsZUFuaW1hdGlvblN0YXJ0IiwiX3JlZiIsInN0ZXBEYXRhIiwiaW5kZXgiLCJwcmV2IiwiaW50ZXJwb2xhdG9yQ3giLCJpbnRlcnBvbGF0ZU51bWJlciIsImludGVycG9sYXRvckN5IiwiaW50ZXJwb2xhdG9yU2l6ZSIsImludGVycG9sYXRvciIsInJlbmRlclN5bWJvbHMiLCJfdGhpcyRwcm9wczMiLCJyZW5kZXJFcnJvckJhciIsIl90aGlzJHByb3BzNCIsInhBeGlzIiwieUF4aXMiLCJjaGlsZHJlbiIsImVycm9yQmFySXRlbXMiLCJmaW5kQWxsQnlUeXBlIiwiRXJyb3JCYXIiLCJpdGVtIiwiX2l0ZW0kcHJvcHMiLCJkaXJlY3Rpb24iLCJlcnJvckRhdGFLZXkiLCJkYXRhS2V5IiwiY2xvbmVFbGVtZW50IiwiZGF0YSIsImxheW91dCIsImRhdGFQb2ludEZvcm1hdHRlciIsImRhdGFQb2ludCIsIngiLCJ5Iiwibm9kZSIsImVycm9yVmFsIiwiZ2V0VmFsdWVCeURhdGFLZXkiLCJyZW5kZXJMaW5lIiwiX3RoaXMkcHJvcHM1IiwibGluZSIsImxpbmVUeXBlIiwibGluZUpvaW50VHlwZSIsInNjYXR0ZXJQcm9wcyIsImN1c3RvbUxpbmVQcm9wcyIsImxpbmVQb2ludHMiLCJsaW5lSXRlbSIsIl9nZXRMaW5lYXJSZWdyZXNzaW9uIiwiZ2V0TGluZWFyUmVncmVzc2lvbiIsInhtaW4iLCJ4bWF4IiwiYiIsImxpbmVhckV4cCIsImxpbmVQcm9wcyIsImZpbGwiLCJzdHJva2UiLCJpc1ZhbGlkRWxlbWVudCIsIkN1cnZlIiwidHlwZSIsInJlbmRlciIsIl90aGlzJHByb3BzNiIsImhpZGUiLCJsZWZ0IiwidG9wIiwid2lkdGgiLCJoZWlnaHQiLCJpZCIsImxheWVyQ2xhc3MiLCJuZWVkQ2xpcFgiLCJhbGxvd0RhdGFPdmVyZmxvdyIsIm5lZWRDbGlwWSIsIm5lZWRDbGlwIiwiY2xpcFBhdGhJZCIsImNsaXBQYXRoIiwiTGFiZWxMaXN0IiwicmVuZGVyQ2FsbEJ5UGFyZW50IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwibmV4dFByb3BzIiwicHJldlN0YXRlIiwicHJldkFuaW1hdGlvbklkIiwiY3VyUG9pbnRzIiwiUHVyZUNvbXBvbmVudCIsInhBeGlzSWQiLCJ5QXhpc0lkIiwiekF4aXNJZCIsImxlZ2VuZFR5cGUiLCJHbG9iYWwiLCJpc1NzciIsIl9yZWYyIiwiekF4aXMiLCJkaXNwbGF5ZWREYXRhIiwieEF4aXNUaWNrcyIsInlBeGlzVGlja3MiLCJvZmZzZXQiLCJ0b29sdGlwVHlwZSIsImNlbGxzIiwiQ2VsbCIsInhBeGlzRGF0YUtleSIsInlBeGlzRGF0YUtleSIsInpBeGlzRGF0YUtleSIsImRlZmF1bHRSYW5nZVoiLCJyYW5nZSIsIlpBeGlzIiwiZGVmYXVsdFByb3BzIiwiZGVmYXVsdFoiLCJ4QmFuZFNpemUiLCJzY2FsZSIsImJhbmR3aWR0aCIsInlCYW5kU2l6ZSIsInoiLCJ0b29sdGlwUGF5bG9hZCIsIm5hbWUiLCJ1bml0IiwicGF5bG9hZCIsImdldENhdGVDb29yZGluYXRlT2ZMaW5lIiwiYXhpcyIsInRpY2tzIiwiYmFuZFNpemUiLCJyYWRpdXMiLCJNYXRoIiwic3FydCIsIm1heCIsIlBJIiwidG9vbHRpcFBvc2l0aW9uIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/cartesian/Scatter.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/cartesian/XAxis.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/XAxis.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.XAxis = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _chartLayoutContext = __webpack_require__(/*! ../context/chartLayoutContext */ \"(pages-dir-node)/./node_modules/recharts/lib/context/chartLayoutContext.js\");\nvar _CartesianAxis = __webpack_require__(/*! ./CartesianAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/CartesianAxis.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n} /**\r\n * @fileOverview X Axis\r\n */ \n/** Define of XAxis props */ function XAxisImpl(_ref) {\n    var xAxisId = _ref.xAxisId;\n    var width = (0, _chartLayoutContext.useChartWidth)();\n    var height = (0, _chartLayoutContext.useChartHeight)();\n    var axisOptions = (0, _chartLayoutContext.useXAxisOrThrow)(xAxisId);\n    if (axisOptions == null) {\n        return null;\n    }\n    return(/*#__PURE__*/ // @ts-expect-error the axisOptions type is not exactly what CartesianAxis is expecting.\n    React.createElement(_CartesianAxis.CartesianAxis, _extends({}, axisOptions, {\n        className: (0, _clsx[\"default\"])(\"recharts-\".concat(axisOptions.axisType, \" \").concat(axisOptions.axisType), axisOptions.className),\n        viewBox: {\n            x: 0,\n            y: 0,\n            width: width,\n            height: height\n        },\n        ticksGenerator: function ticksGenerator(axis) {\n            return (0, _ChartUtils.getTicksOfAxis)(axis, true);\n        }\n    })));\n}\n// eslint-disable-next-line react/prefer-stateless-function -- requires static defaultProps\nvar XAxis = exports.XAxis = /*#__PURE__*/ function(_React$Component) {\n    function XAxis() {\n        _classCallCheck(this, XAxis);\n        return _callSuper(this, XAxis, arguments);\n    }\n    _inherits(XAxis, _React$Component);\n    return _createClass(XAxis, [\n        {\n            key: \"render\",\n            value: function render() {\n                return /*#__PURE__*/ React.createElement(XAxisImpl, this.props);\n            }\n        }\n    ]);\n}(React.Component);\n_defineProperty(XAxis, \"displayName\", 'XAxis');\n_defineProperty(XAxis, \"defaultProps\", {\n    allowDecimals: true,\n    hide: false,\n    orientation: 'bottom',\n    width: 0,\n    height: 30,\n    mirror: false,\n    xAxisId: 0,\n    tickCount: 5,\n    type: 'category',\n    padding: {\n        left: 0,\n        right: 0\n    },\n    allowDataOverflow: false,\n    scale: 'auto',\n    reversed: false,\n    allowDuplicatedCategory: true\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2FydGVzaWFuL1hBeGlzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUUsV0FBVyxLQUFLQyxVQUFVRCxNQUFNQyxPQUFPRSxTQUFTLEdBQUcsV0FBVyxPQUFPSDtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1RJLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxhQUFhLEdBQUcsS0FBSztBQUNyQixJQUFJRyxRQUFRQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ25ELElBQUlDLFFBQVFDLHVCQUF1QkYsbUJBQU9BLENBQUMsdUJBQU07QUFDakQsSUFBSUcsc0JBQXNCSCxtQkFBT0EsQ0FBQyxpSEFBK0I7QUFDakUsSUFBSUksaUJBQWlCSixtQkFBT0EsQ0FBQyxnR0FBaUI7QUFDOUMsSUFBSUssY0FBY0wsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLFNBQVNFLHVCQUF1QkksR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSx5QkFBeUJDLENBQUM7SUFBSSxJQUFJLGNBQWMsT0FBT0MsU0FBUyxPQUFPO0lBQU0sSUFBSUMsSUFBSSxJQUFJRCxXQUFXRSxJQUFJLElBQUlGO0lBQVcsT0FBTyxDQUFDRiwyQkFBMkIsU0FBU0EseUJBQXlCQyxDQUFDO1FBQUksT0FBT0EsSUFBSUcsSUFBSUQ7SUFBRyxHQUFHRjtBQUFJO0FBQ25PLFNBQVNWLHdCQUF3QlUsQ0FBQyxF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QUFPckQsYUFBYXpDLE9BQU87UUFBQztZQUMxQndDLEtBQUs7WUFDTHpDLE9BQU8sU0FBU2dHO2dCQUNkLE9BQU8sV0FBVyxHQUFFOUYsTUFBTWtGLGFBQWEsQ0FBQ1QsV0FBVyxJQUFJLENBQUN6QyxLQUFLO1lBQy9EO1FBQ0Y7S0FBRTtBQUNKLEVBQUVoQyxNQUFNK0YsU0FBUztBQUNqQi9CLGdCQUFnQmpFLE9BQU8sZUFBZTtBQUN0Q2lFLGdCQUFnQmpFLE9BQU8sZ0JBQWdCO0lBQ3JDaUcsZUFBZTtJQUNmQyxNQUFNO0lBQ05DLGFBQWE7SUFDYnRCLE9BQU87SUFDUEUsUUFBUTtJQUNScUIsUUFBUTtJQUNSeEIsU0FBUztJQUNUeUIsV0FBVztJQUNYQyxNQUFNO0lBQ05DLFNBQVM7UUFDUEMsTUFBTTtRQUNOQyxPQUFPO0lBQ1Q7SUFDQUMsbUJBQW1CO0lBQ25CQyxPQUFPO0lBQ1BDLFVBQVU7SUFDVkMseUJBQXlCO0FBQzNCIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxjYXJ0ZXNpYW5cXFhBeGlzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5YQXhpcyA9IHZvaWQgMDtcclxudmFyIFJlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XHJcbnZhciBfY2hhcnRMYXlvdXRDb250ZXh0ID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY2hhcnRMYXlvdXRDb250ZXh0XCIpO1xyXG52YXIgX0NhcnRlc2lhbkF4aXMgPSByZXF1aXJlKFwiLi9DYXJ0ZXNpYW5BeGlzXCIpO1xyXG52YXIgX0NoYXJ0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9DaGFydFV0aWxzXCIpO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cclxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cclxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cclxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XHJcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxyXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cclxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cclxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cclxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cclxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxyXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxyXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgWCBBeGlzXHJcbiAqL1xyXG4vKiogRGVmaW5lIG9mIFhBeGlzIHByb3BzICovXHJcblxyXG5mdW5jdGlvbiBYQXhpc0ltcGwoX3JlZikge1xyXG4gIHZhciB4QXhpc0lkID0gX3JlZi54QXhpc0lkO1xyXG4gIHZhciB3aWR0aCA9ICgwLCBfY2hhcnRMYXlvdXRDb250ZXh0LnVzZUNoYXJ0V2lkdGgpKCk7XHJcbiAgdmFyIGhlaWdodCA9ICgwLCBfY2hhcnRMYXlvdXRDb250ZXh0LnVzZUNoYXJ0SGVpZ2h0KSgpO1xyXG4gIHZhciBheGlzT3B0aW9ucyA9ICgwLCBfY2hhcnRMYXlvdXRDb250ZXh0LnVzZVhBeGlzT3JUaHJvdykoeEF4aXNJZCk7XHJcbiAgaWYgKGF4aXNPcHRpb25zID09IG51bGwpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICByZXR1cm4gKFxyXG4gICAgLyojX19QVVJFX18qL1xyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGUgYXhpc09wdGlvbnMgdHlwZSBpcyBub3QgZXhhY3RseSB3aGF0IENhcnRlc2lhbkF4aXMgaXMgZXhwZWN0aW5nLlxyXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChfQ2FydGVzaWFuQXhpcy5DYXJ0ZXNpYW5BeGlzLCBfZXh0ZW5kcyh7fSwgYXhpc09wdGlvbnMsIHtcclxuICAgICAgY2xhc3NOYW1lOiAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKShcInJlY2hhcnRzLVwiLmNvbmNhdChheGlzT3B0aW9ucy5heGlzVHlwZSwgXCIgXCIpLmNvbmNhdChheGlzT3B0aW9ucy5heGlzVHlwZSksIGF4aXNPcHRpb25zLmNsYXNzTmFtZSksXHJcbiAgICAgIHZpZXdCb3g6IHtcclxuICAgICAgICB4OiAwLFxyXG4gICAgICAgIHk6IDAsXHJcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICAgIH0sXHJcbiAgICAgIHRpY2tzR2VuZXJhdG9yOiBmdW5jdGlvbiB0aWNrc0dlbmVyYXRvcihheGlzKSB7XHJcbiAgICAgICAgcmV0dXJuICgwLCBfQ2hhcnRVdGlscy5nZXRUaWNrc09mQXhpcykoYXhpcywgdHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0pKVxyXG4gICk7XHJcbn1cclxuXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9wcmVmZXItc3RhdGVsZXNzLWZ1bmN0aW9uIC0tIHJlcXVpcmVzIHN0YXRpYyBkZWZhdWx0UHJvcHNcclxudmFyIFhBeGlzID0gZXhwb3J0cy5YQXhpcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xyXG4gIGZ1bmN0aW9uIFhBeGlzKCkge1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFhBeGlzKTtcclxuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIFhBeGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuICBfaW5oZXJpdHMoWEF4aXMsIF9SZWFjdCRDb21wb25lbnQpO1xyXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoWEF4aXMsIFt7XHJcbiAgICBrZXk6IFwicmVuZGVyXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoWEF4aXNJbXBsLCB0aGlzLnByb3BzKTtcclxuICAgIH1cclxuICB9XSk7XHJcbn0oUmVhY3QuQ29tcG9uZW50KTtcclxuX2RlZmluZVByb3BlcnR5KFhBeGlzLCBcImRpc3BsYXlOYW1lXCIsICdYQXhpcycpO1xyXG5fZGVmaW5lUHJvcGVydHkoWEF4aXMsIFwiZGVmYXVsdFByb3BzXCIsIHtcclxuICBhbGxvd0RlY2ltYWxzOiB0cnVlLFxyXG4gIGhpZGU6IGZhbHNlLFxyXG4gIG9yaWVudGF0aW9uOiAnYm90dG9tJyxcclxuICB3aWR0aDogMCxcclxuICBoZWlnaHQ6IDMwLFxyXG4gIG1pcnJvcjogZmFsc2UsXHJcbiAgeEF4aXNJZDogMCxcclxuICB0aWNrQ291bnQ6IDUsXHJcbiAgdHlwZTogJ2NhdGVnb3J5JyxcclxuICBwYWRkaW5nOiB7XHJcbiAgICBsZWZ0OiAwLFxyXG4gICAgcmlnaHQ6IDBcclxuICB9LFxyXG4gIGFsbG93RGF0YU92ZXJmbG93OiBmYWxzZSxcclxuICBzY2FsZTogJ2F1dG8nLFxyXG4gIHJldmVyc2VkOiBmYWxzZSxcclxuICBhbGxvd0R1cGxpY2F0ZWRDYXRlZ29yeTogdHJ1ZVxyXG59KTsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiWEF4aXMiLCJSZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9jbHN4IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9jaGFydExheW91dENvbnRleHQiLCJfQ2FydGVzaWFuQXhpcyIsIl9DaGFydFV0aWxzIiwib2JqIiwiX19lc01vZHVsZSIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2FsbFN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsImFwcGx5Iiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsImJpbmQiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwiX2RlZmluZVByb3BlcnR5IiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImFyZ3VtZW50cyIsInNvdXJjZSIsIlhBeGlzSW1wbCIsIl9yZWYiLCJ4QXhpc0lkIiwid2lkdGgiLCJ1c2VDaGFydFdpZHRoIiwiaGVpZ2h0IiwidXNlQ2hhcnRIZWlnaHQiLCJheGlzT3B0aW9ucyIsInVzZVhBeGlzT3JUaHJvdyIsImNyZWF0ZUVsZW1lbnQiLCJDYXJ0ZXNpYW5BeGlzIiwiY2xhc3NOYW1lIiwiY29uY2F0IiwiYXhpc1R5cGUiLCJ2aWV3Qm94IiwieCIsInkiLCJ0aWNrc0dlbmVyYXRvciIsImF4aXMiLCJnZXRUaWNrc09mQXhpcyIsIl9SZWFjdCRDb21wb25lbnQiLCJyZW5kZXIiLCJDb21wb25lbnQiLCJhbGxvd0RlY2ltYWxzIiwiaGlkZSIsIm9yaWVudGF0aW9uIiwibWlycm9yIiwidGlja0NvdW50IiwidHlwZSIsInBhZGRpbmciLCJsZWZ0IiwicmlnaHQiLCJhbGxvd0RhdGFPdmVyZmxvdyIsInNjYWxlIiwicmV2ZXJzZWQiLCJhbGxvd0R1cGxpY2F0ZWRDYXRlZ29yeSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/cartesian/XAxis.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/cartesian/YAxis.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/YAxis.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.YAxis = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _chartLayoutContext = __webpack_require__(/*! ../context/chartLayoutContext */ \"(pages-dir-node)/./node_modules/recharts/lib/context/chartLayoutContext.js\");\nvar _CartesianAxis = __webpack_require__(/*! ./CartesianAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/CartesianAxis.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n} /**\r\n * @fileOverview Y Axis\r\n */ \nvar YAxisImpl = function YAxisImpl(_ref) {\n    var yAxisId = _ref.yAxisId;\n    var width = (0, _chartLayoutContext.useChartWidth)();\n    var height = (0, _chartLayoutContext.useChartHeight)();\n    var axisOptions = (0, _chartLayoutContext.useYAxisOrThrow)(yAxisId);\n    if (axisOptions == null) {\n        return null;\n    }\n    return(/*#__PURE__*/ // @ts-expect-error the axisOptions type is not exactly what CartesianAxis is expecting.\n    React.createElement(_CartesianAxis.CartesianAxis, _extends({}, axisOptions, {\n        className: (0, _clsx[\"default\"])(\"recharts-\".concat(axisOptions.axisType, \" \").concat(axisOptions.axisType), axisOptions.className),\n        viewBox: {\n            x: 0,\n            y: 0,\n            width: width,\n            height: height\n        },\n        ticksGenerator: function ticksGenerator(axis) {\n            return (0, _ChartUtils.getTicksOfAxis)(axis, true);\n        }\n    })));\n};\n// eslint-disable-next-line react/prefer-stateless-function -- requires static defaultProps\nvar YAxis = exports.YAxis = /*#__PURE__*/ function(_React$Component) {\n    function YAxis() {\n        _classCallCheck(this, YAxis);\n        return _callSuper(this, YAxis, arguments);\n    }\n    _inherits(YAxis, _React$Component);\n    return _createClass(YAxis, [\n        {\n            key: \"render\",\n            value: function render() {\n                return /*#__PURE__*/ React.createElement(YAxisImpl, this.props);\n            }\n        }\n    ]);\n}(React.Component);\n_defineProperty(YAxis, \"displayName\", 'YAxis');\n_defineProperty(YAxis, \"defaultProps\", {\n    allowDuplicatedCategory: true,\n    allowDecimals: true,\n    hide: false,\n    orientation: 'left',\n    width: 60,\n    height: 0,\n    mirror: false,\n    yAxisId: 0,\n    tickCount: 5,\n    type: 'number',\n    padding: {\n        top: 0,\n        bottom: 0\n    },\n    allowDataOverflow: false,\n    scale: 'auto',\n    reversed: false\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2FydGVzaWFuL1lBeGlzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUUsV0FBVyxLQUFLQyxVQUFVRCxNQUFNQyxPQUFPRSxTQUFTLEdBQUcsV0FBVyxPQUFPSDtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1RJLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxhQUFhLEdBQUcsS0FBSztBQUNyQixJQUFJRyxRQUFRQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ25ELElBQUlDLFFBQVFDLHVCQUF1QkYsbUJBQU9BLENBQUMsdUJBQU07QUFDakQsSUFBSUcsc0JBQXNCSCxtQkFBT0EsQ0FBQyxpSEFBK0I7QUFDakUsSUFBSUksaUJBQWlCSixtQkFBT0EsQ0FBQyxnR0FBaUI7QUFDOUMsSUFBSUssY0FBY0wsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLFNBQVNFLHVCQUF1QkksR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSx5QkFBeUJDLENBQUM7SUFBSSxJQUFJLGNBQWMsT0FBT0MsU0FBUyxPQUFPO0lBQU0sSUFBSUMsSUFBSSxJQUFJRCxXQUFXRSxJQUFJLElBQUlGO0lBQVcsT0FBTyxDQUFDRiwyQkFBMkIsU0FBU0EseUJBQXlCQyxDQUFDO1FBQUksT0FBT0EsSUFBSUcsSUFBSUQ7SUFBRyxHQUFHRjtBQUFJO0FBQ25PLFNBQVNWLHdCQUF3QlUsQ0FBQyxF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T3JELGFBQWF6QyxPQUFPO1FBQUM7WUFDMUJ3QyxLQUFLO1lBQ0x6QyxPQUFPLFNBQVNnRztnQkFDZCxPQUFPLFdBQVcsR0FBRTlGLE1BQU1rRixhQUFhLENBQUNULFdBQVcsSUFBSSxDQUFDekMsS0FBSztZQUMvRDtRQUNGO0tBQUU7QUFDSixFQUFFaEMsTUFBTStGLFNBQVM7QUFDakIvQixnQkFBZ0JqRSxPQUFPLGVBQWU7QUFDdENpRSxnQkFBZ0JqRSxPQUFPLGdCQUFnQjtJQUNyQ2lHLHlCQUF5QjtJQUN6QkMsZUFBZTtJQUNmQyxNQUFNO0lBQ05DLGFBQWE7SUFDYnZCLE9BQU87SUFDUEUsUUFBUTtJQUNSc0IsUUFBUTtJQUNSekIsU0FBUztJQUNUMEIsV0FBVztJQUNYQyxNQUFNO0lBQ05DLFNBQVM7UUFDUEMsS0FBSztRQUNMQyxRQUFRO0lBQ1Y7SUFDQUMsbUJBQW1CO0lBQ25CQyxPQUFPO0lBQ1BDLFVBQVU7QUFDWiIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcY2FydGVzaWFuXFxZQXhpcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuWUF4aXMgPSB2b2lkIDA7XHJcbnZhciBSZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xyXG52YXIgX2NoYXJ0TGF5b3V0Q29udGV4dCA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NoYXJ0TGF5b3V0Q29udGV4dFwiKTtcclxudmFyIF9DYXJ0ZXNpYW5BeGlzID0gcmVxdWlyZShcIi4vQ2FydGVzaWFuQXhpc1wiKTtcclxudmFyIF9DaGFydFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvQ2hhcnRVdGlsc1wiKTtcclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XHJcbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBudWxsOyB2YXIgciA9IG5ldyBXZWFrTWFwKCksIHQgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IHJldHVybiBlID8gdCA6IHI7IH0pKGUpOyB9XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHUpKSB7IHZhciBpID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdSkgOiBudWxsOyBpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgdSwgaSkgOiBuW3VdID0gZVt1XTsgfSByZXR1cm4gbltcImRlZmF1bHRcIl0gPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XHJcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XHJcbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XHJcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxyXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cclxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XHJcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XHJcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cclxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cclxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IC8qKlxyXG4gKiBAZmlsZU92ZXJ2aWV3IFkgQXhpc1xyXG4gKi9cclxudmFyIFlBeGlzSW1wbCA9IGZ1bmN0aW9uIFlBeGlzSW1wbChfcmVmKSB7XHJcbiAgdmFyIHlBeGlzSWQgPSBfcmVmLnlBeGlzSWQ7XHJcbiAgdmFyIHdpZHRoID0gKDAsIF9jaGFydExheW91dENvbnRleHQudXNlQ2hhcnRXaWR0aCkoKTtcclxuICB2YXIgaGVpZ2h0ID0gKDAsIF9jaGFydExheW91dENvbnRleHQudXNlQ2hhcnRIZWlnaHQpKCk7XHJcbiAgdmFyIGF4aXNPcHRpb25zID0gKDAsIF9jaGFydExheW91dENvbnRleHQudXNlWUF4aXNPclRocm93KSh5QXhpc0lkKTtcclxuICBpZiAoYXhpc09wdGlvbnMgPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHJldHVybiAoXHJcbiAgICAvKiNfX1BVUkVfXyovXHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRoZSBheGlzT3B0aW9ucyB0eXBlIGlzIG5vdCBleGFjdGx5IHdoYXQgQ2FydGVzaWFuQXhpcyBpcyBleHBlY3RpbmcuXHJcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KF9DYXJ0ZXNpYW5BeGlzLkNhcnRlc2lhbkF4aXMsIF9leHRlbmRzKHt9LCBheGlzT3B0aW9ucywge1xyXG4gICAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKFwicmVjaGFydHMtXCIuY29uY2F0KGF4aXNPcHRpb25zLmF4aXNUeXBlLCBcIiBcIikuY29uY2F0KGF4aXNPcHRpb25zLmF4aXNUeXBlKSwgYXhpc09wdGlvbnMuY2xhc3NOYW1lKSxcclxuICAgICAgdmlld0JveDoge1xyXG4gICAgICAgIHg6IDAsXHJcbiAgICAgICAgeTogMCxcclxuICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcclxuICAgICAgfSxcclxuICAgICAgdGlja3NHZW5lcmF0b3I6IGZ1bmN0aW9uIHRpY2tzR2VuZXJhdG9yKGF4aXMpIHtcclxuICAgICAgICByZXR1cm4gKDAsIF9DaGFydFV0aWxzLmdldFRpY2tzT2ZBeGlzKShheGlzLCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfSkpXHJcbiAgKTtcclxufTtcclxuXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9wcmVmZXItc3RhdGVsZXNzLWZ1bmN0aW9uIC0tIHJlcXVpcmVzIHN0YXRpYyBkZWZhdWx0UHJvcHNcclxudmFyIFlBeGlzID0gZXhwb3J0cy5ZQXhpcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xyXG4gIGZ1bmN0aW9uIFlBeGlzKCkge1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFlBeGlzKTtcclxuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIFlBeGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuICBfaW5oZXJpdHMoWUF4aXMsIF9SZWFjdCRDb21wb25lbnQpO1xyXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoWUF4aXMsIFt7XHJcbiAgICBrZXk6IFwicmVuZGVyXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoWUF4aXNJbXBsLCB0aGlzLnByb3BzKTtcclxuICAgIH1cclxuICB9XSk7XHJcbn0oUmVhY3QuQ29tcG9uZW50KTtcclxuX2RlZmluZVByb3BlcnR5KFlBeGlzLCBcImRpc3BsYXlOYW1lXCIsICdZQXhpcycpO1xyXG5fZGVmaW5lUHJvcGVydHkoWUF4aXMsIFwiZGVmYXVsdFByb3BzXCIsIHtcclxuICBhbGxvd0R1cGxpY2F0ZWRDYXRlZ29yeTogdHJ1ZSxcclxuICBhbGxvd0RlY2ltYWxzOiB0cnVlLFxyXG4gIGhpZGU6IGZhbHNlLFxyXG4gIG9yaWVudGF0aW9uOiAnbGVmdCcsXHJcbiAgd2lkdGg6IDYwLFxyXG4gIGhlaWdodDogMCxcclxuICBtaXJyb3I6IGZhbHNlLFxyXG4gIHlBeGlzSWQ6IDAsXHJcbiAgdGlja0NvdW50OiA1LFxyXG4gIHR5cGU6ICdudW1iZXInLFxyXG4gIHBhZGRpbmc6IHtcclxuICAgIHRvcDogMCxcclxuICAgIGJvdHRvbTogMFxyXG4gIH0sXHJcbiAgYWxsb3dEYXRhT3ZlcmZsb3c6IGZhbHNlLFxyXG4gIHNjYWxlOiAnYXV0bycsXHJcbiAgcmV2ZXJzZWQ6IGZhbHNlXHJcbn0pOyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJZQXhpcyIsIlJlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX2Nsc3giLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2NoYXJ0TGF5b3V0Q29udGV4dCIsIl9DYXJ0ZXNpYW5BeGlzIiwiX0NoYXJ0VXRpbHMiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9Qcm9wZXJ0eUtleSIsImtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0IiwiYXBwbHkiLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiQm9vbGVhbiIsInZhbHVlT2YiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiYmluZCIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsInAiLCJfZGVmaW5lUHJvcGVydHkiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsIl9leHRlbmRzIiwiYXNzaWduIiwiYXJndW1lbnRzIiwic291cmNlIiwiWUF4aXNJbXBsIiwiX3JlZiIsInlBeGlzSWQiLCJ3aWR0aCIsInVzZUNoYXJ0V2lkdGgiLCJoZWlnaHQiLCJ1c2VDaGFydEhlaWdodCIsImF4aXNPcHRpb25zIiwidXNlWUF4aXNPclRocm93IiwiY3JlYXRlRWxlbWVudCIsIkNhcnRlc2lhbkF4aXMiLCJjbGFzc05hbWUiLCJjb25jYXQiLCJheGlzVHlwZSIsInZpZXdCb3giLCJ4IiwieSIsInRpY2tzR2VuZXJhdG9yIiwiYXhpcyIsImdldFRpY2tzT2ZBeGlzIiwiX1JlYWN0JENvbXBvbmVudCIsInJlbmRlciIsIkNvbXBvbmVudCIsImFsbG93RHVwbGljYXRlZENhdGVnb3J5IiwiYWxsb3dEZWNpbWFscyIsImhpZGUiLCJvcmllbnRhdGlvbiIsIm1pcnJvciIsInRpY2tDb3VudCIsInR5cGUiLCJwYWRkaW5nIiwidG9wIiwiYm90dG9tIiwiYWxsb3dEYXRhT3ZlcmZsb3ciLCJzY2FsZSIsInJldmVyc2VkIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/cartesian/YAxis.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/cartesian/ZAxis.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/ZAxis.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ZAxis = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Z Axis\r\n */ \n// eslint-disable-next-line react/prefer-stateless-function -- requires static defaultProps\nvar ZAxis = exports.ZAxis = /*#__PURE__*/ function(_React$Component) {\n    function ZAxis() {\n        _classCallCheck(this, ZAxis);\n        return _callSuper(this, ZAxis, arguments);\n    }\n    _inherits(ZAxis, _React$Component);\n    return _createClass(ZAxis, [\n        {\n            key: \"render\",\n            value: function render() {\n                return null;\n            }\n        }\n    ]);\n}(React.Component);\n_defineProperty(ZAxis, \"displayName\", 'ZAxis');\n_defineProperty(ZAxis, \"defaultProps\", {\n    zAxisId: 0,\n    range: [\n        64,\n        64\n    ],\n    scale: 'auto',\n    type: 'number'\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2FydGVzaWFuL1pBeGlzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxhQUFhLEdBQUcsS0FBSztBQUNyQixJQUFJRyxRQUFRQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ25ELFNBQVNDLHlCQUF5QkMsQ0FBQztJQUFJLElBQUksY0FBYyxPQUFPQyxTQUFTLE9BQU87SUFBTSxJQUFJQyxJQUFJLElBQUlELFdBQVdFLElBQUksSUFBSUY7SUFBVyxPQUFPLENBQUNGLDJCQUEyQixTQUFTQSx5QkFBeUJDLENBQUM7UUFBSSxPQUFPQSxJQUFJRyxJQUFJRDtJQUFHLEdBQUdGO0FBQUk7QUFDbk8sU0FBU0gsd0JBQXdCRyxDQUFDLEVBQUVFLENBQUM7SUFBSSxJQUFJLENBQUNBLEtBQUtGLEtBQUtBLEVBQUVJLFVBQVUsRUFBRSxPQUFPSjtJQUFHLElBQUksU0FBU0EsS0FBSyxZQUFZSyxRQUFRTCxNQUFNLGNBQWMsT0FBT0EsR0FBRyxPQUFPO1FBQUUsV0FBV0E7SUFBRTtJQUFHLElBQUlHLElBQUlKLHlCQUF5Qkc7SUFBSSxJQUFJQyxLQUFLQSxFQUFFRyxHQUFHLENBQUNOLElBQUksT0FBT0csRUFBRUksR0FBRyxDQUFDUDtJQUFJLElBQUlRLElBQUk7UUFBRUMsV0FBVztJQUFLLEdBQUdDLElBQUluQixPQUFPQyxjQUFjLElBQUlELE9BQU9vQix3QkFBd0I7SUFBRSxJQUFLLElBQUlDLEtBQUtaLEVBQUcsSUFBSSxjQUFjWSxLQUFLLEVBQUMsR0FBRUMsY0FBYyxDQUFDQyxJQUFJLENBQUNkLEdBQUdZLElBQUk7UUFBRSxJQUFJRyxJQUFJTCxJQUFJbkIsT0FBT29CLHdCQUF3QixDQUFDWCxHQUFHWSxLQUFLO1FBQU1HLEtBQU1BLENBQUFBLEVBQUVSLEdBQUcsSUFBSVEsRUFBRUMsR0FBRyxJQUFJ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RztJQUFXLE9BQU8sWUFBWUUsUUFBUVUsS0FBS0EsSUFBSUEsSUFBSTtBQUFJO0FBQzVHLFNBQVM4QyxhQUFhMUQsQ0FBQyxFQUFFRCxDQUFDO0lBQUksSUFBSSxZQUFZRyxRQUFRRixNQUFNLENBQUNBLEdBQUcsT0FBT0E7SUFBRyxJQUFJSCxJQUFJRyxDQUFDLENBQUNlLE9BQU80QyxXQUFXLENBQUM7SUFBRSxJQUFJLEtBQUssTUFBTTlELEdBQUc7UUFBRSxJQUFJZSxJQUFJZixFQUFFYyxJQUFJLENBQUNYLEdBQUdELEtBQUs7UUFBWSxJQUFJLFlBQVlHLFFBQVFVLElBQUksT0FBT0E7UUFBRyxNQUFNLElBQUlTLFVBQVU7SUFBaUQ7SUFBRSxPQUFPLENBQUMsYUFBYXRCLElBQUk2RCxTQUFTQyxNQUFLLEVBQUc3RDtBQUFJLEVBQUU7O0NBRTVUO0FBQ0QsMkZBQTJGO0FBQzNGLElBQUlSLFFBQVFGLGFBQWEsR0FBRyxXQUFXLEdBQUUsU0FBVXdFLGdCQUFnQjtJQUNqRSxTQUFTdEU7UUFDUDBCLGdCQUFnQixJQUFJLEVBQUUxQjtRQUN0QixPQUFPMkMsV0FBVyxJQUFJLEVBQUUzQyxPQUFPdUU7SUFDakM7SUFDQWIsVUFBVTFELE9BQU9zRTtJQUNqQixPQUFPOUIsYUFBYXhDLE9BQU87UUFBQztZQUMxQnVDLEtBQUs7WUFDTHhDLE9BQU8sU0FBU3lFO2dCQUNkLE9BQU87WUFDVDtRQUNGO0tBQUU7QUFDSixFQUFFdkUsTUFBTXdFLFNBQVM7QUFDakJULGdCQUFnQmhFLE9BQU8sZUFBZTtBQUN0Q2dFLGdCQUFnQmhFLE9BQU8sZ0JBQWdCO0lBQ3JDMEUsU0FBUztJQUNUQyxPQUFPO1FBQUM7UUFBSTtLQUFHO0lBQ2ZDLE9BQU87SUFDUEMsTUFBTTtBQUNSIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxjYXJ0ZXNpYW5cXFpBeGlzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuWkF4aXMgPSB2b2lkIDA7XHJcbnZhciBSZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBudWxsOyB2YXIgciA9IG5ldyBXZWFrTWFwKCksIHQgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IHJldHVybiBlID8gdCA6IHI7IH0pKGUpOyB9XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHUpKSB7IHZhciBpID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdSkgOiBudWxsOyBpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgdSwgaSkgOiBuW3VdID0gZVt1XTsgfSByZXR1cm4gbltcImRlZmF1bHRcIl0gPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XHJcbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cclxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cclxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cclxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XHJcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxyXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cclxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cclxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cclxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cclxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxyXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfSAvKipcclxuICogQGZpbGVPdmVydmlldyBaIEF4aXNcclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9wcmVmZXItc3RhdGVsZXNzLWZ1bmN0aW9uIC0tIHJlcXVpcmVzIHN0YXRpYyBkZWZhdWx0UHJvcHNcclxudmFyIFpBeGlzID0gZXhwb3J0cy5aQXhpcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xyXG4gIGZ1bmN0aW9uIFpBeGlzKCkge1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFpBeGlzKTtcclxuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIFpBeGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuICBfaW5oZXJpdHMoWkF4aXMsIF9SZWFjdCRDb21wb25lbnQpO1xyXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoWkF4aXMsIFt7XHJcbiAgICBrZXk6IFwicmVuZGVyXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XSk7XHJcbn0oUmVhY3QuQ29tcG9uZW50KTtcclxuX2RlZmluZVByb3BlcnR5KFpBeGlzLCBcImRpc3BsYXlOYW1lXCIsICdaQXhpcycpO1xyXG5fZGVmaW5lUHJvcGVydHkoWkF4aXMsIFwiZGVmYXVsdFByb3BzXCIsIHtcclxuICB6QXhpc0lkOiAwLFxyXG4gIHJhbmdlOiBbNjQsIDY0XSxcclxuICBzY2FsZTogJ2F1dG8nLFxyXG4gIHR5cGU6ICdudW1iZXInXHJcbn0pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlpBeGlzIiwiUmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX19lc01vZHVsZSIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwicHJvdG90eXBlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2FsbFN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsImFwcGx5Iiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsImJpbmQiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJfUmVhY3QkQ29tcG9uZW50IiwiYXJndW1lbnRzIiwicmVuZGVyIiwiQ29tcG9uZW50IiwiekF4aXNJZCIsInJhbmdlIiwic2NhbGUiLCJ0eXBlIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/cartesian/ZAxis.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/cartesian/getEquidistantTicks.js":
/*!********************************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/getEquidistantTicks.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getEquidistantTicks = getEquidistantTicks;\nvar _TickUtils = __webpack_require__(/*! ../util/TickUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/TickUtils.js\");\nvar _getEveryNthWithCondition = __webpack_require__(/*! ../util/getEveryNthWithCondition */ \"(pages-dir-node)/./node_modules/recharts/lib/util/getEveryNthWithCondition.js\");\nfunction getEquidistantTicks(sign, boundaries, getTickSize, ticks, minTickGap) {\n    var result = (ticks || []).slice();\n    var initialStart = boundaries.start, end = boundaries.end;\n    var index = 0;\n    // Premature optimisation idea 1: Estimate a lower bound, and start from there.\n    // For now, start from every tick\n    var stepsize = 1;\n    var start = initialStart;\n    var _loop = function _loop() {\n        // Given stepsize, evaluate whether every stepsize-th tick can be shown.\n        // If it can not, then increase the stepsize by 1, and try again.\n        var entry = ticks === null || ticks === void 0 ? void 0 : ticks[index];\n        // Break condition - If we have evaluate all the ticks, then we are done.\n        if (entry === undefined) {\n            return {\n                v: (0, _getEveryNthWithCondition.getEveryNthWithCondition)(ticks, stepsize)\n            };\n        }\n        // Check if the element collides with the next element\n        var i = index;\n        var size;\n        var getSize = function getSize() {\n            if (size === undefined) {\n                size = getTickSize(entry, i);\n            }\n            return size;\n        };\n        var tickCoord = entry.coordinate;\n        // We will always show the first tick.\n        var isShow = index === 0 || (0, _TickUtils.isVisible)(sign, tickCoord, getSize, start, end);\n        if (!isShow) {\n            // Start all over with a larger stepsize\n            index = 0;\n            start = initialStart;\n            stepsize += 1;\n        }\n        if (isShow) {\n            // If it can be shown, update the start\n            start = tickCoord + sign * (getSize() / 2 + minTickGap);\n            index += stepsize;\n        }\n    }, _ret;\n    while(stepsize <= result.length){\n        _ret = _loop();\n        if (_ret) return _ret.v;\n    }\n    return [];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2FydGVzaWFuL2dldEVxdWlkaXN0YW50VGlja3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELDJCQUEyQixHQUFHRTtBQUM5QixJQUFJQyxhQUFhQyxtQkFBT0EsQ0FBQyx5RkFBbUI7QUFDNUMsSUFBSUMsNEJBQTRCRCxtQkFBT0EsQ0FBQyx1SEFBa0M7QUFDMUUsU0FBU0Ysb0JBQW9CSSxJQUFJLEVBQUVDLFVBQVUsRUFBRUMsV0FBVyxFQUFFQyxLQUFLLEVBQUVDLFVBQVU7SUFDM0UsSUFBSUMsU0FBUyxDQUFDRixTQUFTLEVBQUUsRUFBRUcsS0FBSztJQUNoQyxJQUFJQyxlQUFlTixXQUFXTyxLQUFLLEVBQ2pDQyxNQUFNUixXQUFXUSxHQUFHO0lBQ3RCLElBQUlDLFFBQVE7SUFDWiwrRUFBK0U7SUFDL0UsaUNBQWlDO0lBQ2pDLElBQUlDLFdBQVc7SUFDZixJQUFJSCxRQUFRRDtJQUNaLElBQUlLLFFBQVEsU0FBU0E7UUFDakIsd0VBQXdFO1FBQ3hFLGlFQUFpRTtRQUVqRSxJQUFJQyxRQUFRVixVQUFVLFFBQVFBLFVBQVUsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBSyxDQUFDTyxNQUFNO1FBRXRFLHlFQUF5RTtRQUN6RSxJQUFJRyxVQUFVQyxXQUFXO1lBQ3ZCLE9BQU87Z0JBQ0xDLEdBQUcsQ0FBQyxHQUFHaEIsMEJBQTBCaUIsd0JBQXdCLEVBQUViLE9BQU9RO1lBQ3BFO1FBQ0Y7UUFFQSxzREFBc0Q7UUFDdEQsSUFBSU0sSUFBSVA7UUFDUixJQUFJUTtRQUNKLElBQUlDLFVBQVUsU0FBU0E7WUFDckIsSUFBSUQsU0FBU0osV0FBVztnQkFDdEJJLE9BQU9oQixZQUFZVyxPQUFPSTtZQUM1QjtZQUNBLE9BQU9DO1FBQ1Q7UUFDQSxJQUFJRSxZQUFZUCxNQUFNUSxVQUFVO1FBQ2hDLHNDQUFzQztRQUN0QyxJQUFJQyxTQUFTWixVQUFVLEtBQUssQ0FBQyxHQUFHYixXQUFXMEIsU0FBUyxFQUFFdkIsTUFBTW9CLFdBQVdELFNBQVNYLE9BQU9DO1FBQ3ZGLElBQUksQ0FBQ2EsUUFBUTtZQUNYLHdDQUF3QztZQUN4Q1osUUFBUTtZQUNSRixRQUFRRDtZQUNSSSxZQUFZO1FBQ2Q7UUFDQSxJQUFJVyxRQUFRO1lBQ1YsdUNBQXVDO1lBQ3ZDZCxRQUFRWSxZQUFZcEIsT0FBUW1CLENBQUFBLFlBQVksSUFBSWYsVUFBUztZQUNyRE0sU0FBU0M7UUFDWDtJQUNGLEdBQ0FhO0lBQ0YsTUFBT2IsWUFBWU4sT0FBT29CLE1BQU0sQ0FBRTtRQUNoQ0QsT0FBT1o7UUFDUCxJQUFJWSxNQUFNLE9BQU9BLEtBQUtULENBQUM7SUFDekI7SUFDQSxPQUFPLEVBQUU7QUFDWCIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcY2FydGVzaWFuXFxnZXRFcXVpZGlzdGFudFRpY2tzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZ2V0RXF1aWRpc3RhbnRUaWNrcyA9IGdldEVxdWlkaXN0YW50VGlja3M7XHJcbnZhciBfVGlja1V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvVGlja1V0aWxzXCIpO1xyXG52YXIgX2dldEV2ZXJ5TnRoV2l0aENvbmRpdGlvbiA9IHJlcXVpcmUoXCIuLi91dGlsL2dldEV2ZXJ5TnRoV2l0aENvbmRpdGlvblwiKTtcclxuZnVuY3Rpb24gZ2V0RXF1aWRpc3RhbnRUaWNrcyhzaWduLCBib3VuZGFyaWVzLCBnZXRUaWNrU2l6ZSwgdGlja3MsIG1pblRpY2tHYXApIHtcclxuICB2YXIgcmVzdWx0ID0gKHRpY2tzIHx8IFtdKS5zbGljZSgpO1xyXG4gIHZhciBpbml0aWFsU3RhcnQgPSBib3VuZGFyaWVzLnN0YXJ0LFxyXG4gICAgZW5kID0gYm91bmRhcmllcy5lbmQ7XHJcbiAgdmFyIGluZGV4ID0gMDtcclxuICAvLyBQcmVtYXR1cmUgb3B0aW1pc2F0aW9uIGlkZWEgMTogRXN0aW1hdGUgYSBsb3dlciBib3VuZCwgYW5kIHN0YXJ0IGZyb20gdGhlcmUuXHJcbiAgLy8gRm9yIG5vdywgc3RhcnQgZnJvbSBldmVyeSB0aWNrXHJcbiAgdmFyIHN0ZXBzaXplID0gMTtcclxuICB2YXIgc3RhcnQgPSBpbml0aWFsU3RhcnQ7XHJcbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XHJcbiAgICAgIC8vIEdpdmVuIHN0ZXBzaXplLCBldmFsdWF0ZSB3aGV0aGVyIGV2ZXJ5IHN0ZXBzaXplLXRoIHRpY2sgY2FuIGJlIHNob3duLlxyXG4gICAgICAvLyBJZiBpdCBjYW4gbm90LCB0aGVuIGluY3JlYXNlIHRoZSBzdGVwc2l6ZSBieSAxLCBhbmQgdHJ5IGFnYWluLlxyXG5cclxuICAgICAgdmFyIGVudHJ5ID0gdGlja3MgPT09IG51bGwgfHwgdGlja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRpY2tzW2luZGV4XTtcclxuXHJcbiAgICAgIC8vIEJyZWFrIGNvbmRpdGlvbiAtIElmIHdlIGhhdmUgZXZhbHVhdGUgYWxsIHRoZSB0aWNrcywgdGhlbiB3ZSBhcmUgZG9uZS5cclxuICAgICAgaWYgKGVudHJ5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdjogKDAsIF9nZXRFdmVyeU50aFdpdGhDb25kaXRpb24uZ2V0RXZlcnlOdGhXaXRoQ29uZGl0aW9uKSh0aWNrcywgc3RlcHNpemUpXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgY29sbGlkZXMgd2l0aCB0aGUgbmV4dCBlbGVtZW50XHJcbiAgICAgIHZhciBpID0gaW5kZXg7XHJcbiAgICAgIHZhciBzaXplO1xyXG4gICAgICB2YXIgZ2V0U2l6ZSA9IGZ1bmN0aW9uIGdldFNpemUoKSB7XHJcbiAgICAgICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgc2l6ZSA9IGdldFRpY2tTaXplKGVudHJ5LCBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNpemU7XHJcbiAgICAgIH07XHJcbiAgICAgIHZhciB0aWNrQ29vcmQgPSBlbnRyeS5jb29yZGluYXRlO1xyXG4gICAgICAvLyBXZSB3aWxsIGFsd2F5cyBzaG93IHRoZSBmaXJzdCB0aWNrLlxyXG4gICAgICB2YXIgaXNTaG93ID0gaW5kZXggPT09IDAgfHwgKDAsIF9UaWNrVXRpbHMuaXNWaXNpYmxlKShzaWduLCB0aWNrQ29vcmQsIGdldFNpemUsIHN0YXJ0LCBlbmQpO1xyXG4gICAgICBpZiAoIWlzU2hvdykge1xyXG4gICAgICAgIC8vIFN0YXJ0IGFsbCBvdmVyIHdpdGggYSBsYXJnZXIgc3RlcHNpemVcclxuICAgICAgICBpbmRleCA9IDA7XHJcbiAgICAgICAgc3RhcnQgPSBpbml0aWFsU3RhcnQ7XHJcbiAgICAgICAgc3RlcHNpemUgKz0gMTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNTaG93KSB7XHJcbiAgICAgICAgLy8gSWYgaXQgY2FuIGJlIHNob3duLCB1cGRhdGUgdGhlIHN0YXJ0XHJcbiAgICAgICAgc3RhcnQgPSB0aWNrQ29vcmQgKyBzaWduICogKGdldFNpemUoKSAvIDIgKyBtaW5UaWNrR2FwKTtcclxuICAgICAgICBpbmRleCArPSBzdGVwc2l6ZTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9yZXQ7XHJcbiAgd2hpbGUgKHN0ZXBzaXplIDw9IHJlc3VsdC5sZW5ndGgpIHtcclxuICAgIF9yZXQgPSBfbG9vcCgpO1xyXG4gICAgaWYgKF9yZXQpIHJldHVybiBfcmV0LnY7XHJcbiAgfVxyXG4gIHJldHVybiBbXTtcclxufSJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldEVxdWlkaXN0YW50VGlja3MiLCJfVGlja1V0aWxzIiwicmVxdWlyZSIsIl9nZXRFdmVyeU50aFdpdGhDb25kaXRpb24iLCJzaWduIiwiYm91bmRhcmllcyIsImdldFRpY2tTaXplIiwidGlja3MiLCJtaW5UaWNrR2FwIiwicmVzdWx0Iiwic2xpY2UiLCJpbml0aWFsU3RhcnQiLCJzdGFydCIsImVuZCIsImluZGV4Iiwic3RlcHNpemUiLCJfbG9vcCIsImVudHJ5IiwidW5kZWZpbmVkIiwidiIsImdldEV2ZXJ5TnRoV2l0aENvbmRpdGlvbiIsImkiLCJzaXplIiwiZ2V0U2l6ZSIsInRpY2tDb29yZCIsImNvb3JkaW5hdGUiLCJpc1Nob3ciLCJpc1Zpc2libGUiLCJfcmV0IiwibGVuZ3RoIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/cartesian/getEquidistantTicks.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/cartesian/getTicks.js":
/*!*********************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/getTicks.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getTicks = getTicks;\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _DOMUtils = __webpack_require__(/*! ../util/DOMUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DOMUtils.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"(pages-dir-node)/./node_modules/recharts/lib/util/Global.js\");\nvar _TickUtils = __webpack_require__(/*! ../util/TickUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/TickUtils.js\");\nvar _getEquidistantTicks = __webpack_require__(/*! ./getEquidistantTicks */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/getEquidistantTicks.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction getTicksEnd(sign, boundaries, getTickSize, ticks, minTickGap) {\n    var result = (ticks || []).slice();\n    var len = result.length;\n    var start = boundaries.start;\n    var end = boundaries.end;\n    var _loop = function _loop(i) {\n        var entry = result[i];\n        var size;\n        var getSize = function getSize() {\n            if (size === undefined) {\n                size = getTickSize(entry, i);\n            }\n            return size;\n        };\n        if (i === len - 1) {\n            var gap = sign * (entry.coordinate + sign * getSize() / 2 - end);\n            result[i] = entry = _objectSpread(_objectSpread({}, entry), {}, {\n                tickCoord: gap > 0 ? entry.coordinate - gap * sign : entry.coordinate\n            });\n        } else {\n            result[i] = entry = _objectSpread(_objectSpread({}, entry), {}, {\n                tickCoord: entry.coordinate\n            });\n        }\n        var isShow = (0, _TickUtils.isVisible)(sign, entry.tickCoord, getSize, start, end);\n        if (isShow) {\n            end = entry.tickCoord - sign * (getSize() / 2 + minTickGap);\n            result[i] = _objectSpread(_objectSpread({}, entry), {}, {\n                isShow: true\n            });\n        }\n    };\n    for(var i = len - 1; i >= 0; i--){\n        _loop(i);\n    }\n    return result;\n}\nfunction getTicksStart(sign, boundaries, getTickSize, ticks, minTickGap, preserveEnd) {\n    var result = (ticks || []).slice();\n    var len = result.length;\n    var start = boundaries.start, end = boundaries.end;\n    if (preserveEnd) {\n        // Try to guarantee the tail to be displayed\n        var tail = ticks[len - 1];\n        var tailSize = getTickSize(tail, len - 1);\n        var tailGap = sign * (tail.coordinate + sign * tailSize / 2 - end);\n        result[len - 1] = tail = _objectSpread(_objectSpread({}, tail), {}, {\n            tickCoord: tailGap > 0 ? tail.coordinate - tailGap * sign : tail.coordinate\n        });\n        var isTailShow = (0, _TickUtils.isVisible)(sign, tail.tickCoord, function() {\n            return tailSize;\n        }, start, end);\n        if (isTailShow) {\n            end = tail.tickCoord - sign * (tailSize / 2 + minTickGap);\n            result[len - 1] = _objectSpread(_objectSpread({}, tail), {}, {\n                isShow: true\n            });\n        }\n    }\n    var count = preserveEnd ? len - 1 : len;\n    var _loop2 = function _loop2(i) {\n        var entry = result[i];\n        var size;\n        var getSize = function getSize() {\n            if (size === undefined) {\n                size = getTickSize(entry, i);\n            }\n            return size;\n        };\n        if (i === 0) {\n            var gap = sign * (entry.coordinate - sign * getSize() / 2 - start);\n            result[i] = entry = _objectSpread(_objectSpread({}, entry), {}, {\n                tickCoord: gap < 0 ? entry.coordinate - gap * sign : entry.coordinate\n            });\n        } else {\n            result[i] = entry = _objectSpread(_objectSpread({}, entry), {}, {\n                tickCoord: entry.coordinate\n            });\n        }\n        var isShow = (0, _TickUtils.isVisible)(sign, entry.tickCoord, getSize, start, end);\n        if (isShow) {\n            start = entry.tickCoord + sign * (getSize() / 2 + minTickGap);\n            result[i] = _objectSpread(_objectSpread({}, entry), {}, {\n                isShow: true\n            });\n        }\n    };\n    for(var i = 0; i < count; i++){\n        _loop2(i);\n    }\n    return result;\n}\nfunction getTicks(props, fontSize, letterSpacing) {\n    var tick = props.tick, ticks = props.ticks, viewBox = props.viewBox, minTickGap = props.minTickGap, orientation = props.orientation, interval = props.interval, tickFormatter = props.tickFormatter, unit = props.unit, angle = props.angle;\n    if (!ticks || !ticks.length || !tick) {\n        return [];\n    }\n    if ((0, _DataUtils.isNumber)(interval) || _Global.Global.isSsr) {\n        return (0, _TickUtils.getNumberIntervalTicks)(ticks, typeof interval === 'number' && (0, _DataUtils.isNumber)(interval) ? interval : 0);\n    }\n    var candidates = [];\n    var sizeKey = orientation === 'top' || orientation === 'bottom' ? 'width' : 'height';\n    var unitSize = unit && sizeKey === 'width' ? (0, _DOMUtils.getStringSize)(unit, {\n        fontSize: fontSize,\n        letterSpacing: letterSpacing\n    }) : {\n        width: 0,\n        height: 0\n    };\n    var getTickSize = function getTickSize(content, index) {\n        var value = (0, _isFunction[\"default\"])(tickFormatter) ? tickFormatter(content.value, index) : content.value;\n        // Recharts only supports angles when sizeKey === 'width'\n        return sizeKey === 'width' ? (0, _TickUtils.getAngledTickWidth)((0, _DOMUtils.getStringSize)(value, {\n            fontSize: fontSize,\n            letterSpacing: letterSpacing\n        }), unitSize, angle) : (0, _DOMUtils.getStringSize)(value, {\n            fontSize: fontSize,\n            letterSpacing: letterSpacing\n        })[sizeKey];\n    };\n    var sign = ticks.length >= 2 ? (0, _DataUtils.mathSign)(ticks[1].coordinate - ticks[0].coordinate) : 1;\n    var boundaries = (0, _TickUtils.getTickBoundaries)(viewBox, sign, sizeKey);\n    if (interval === 'equidistantPreserveStart') {\n        return (0, _getEquidistantTicks.getEquidistantTicks)(sign, boundaries, getTickSize, ticks, minTickGap);\n    }\n    if (interval === 'preserveStart' || interval === 'preserveStartEnd') {\n        candidates = getTicksStart(sign, boundaries, getTickSize, ticks, minTickGap, interval === 'preserveStartEnd');\n    } else {\n        candidates = getTicksEnd(sign, boundaries, getTickSize, ticks, minTickGap);\n    }\n    return candidates.filter(function(entry) {\n        return entry.isShow;\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2FydGVzaWFuL2dldFRpY2tzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxnQkFBZ0IsR0FBR0U7QUFDbkIsSUFBSUMsY0FBY0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyw0Q0FBbUI7QUFDcEUsSUFBSUMsYUFBYUQsbUJBQU9BLENBQUMseUZBQW1CO0FBQzVDLElBQUlFLFlBQVlGLG1CQUFPQSxDQUFDLHVGQUFrQjtBQUMxQyxJQUFJRyxVQUFVSCxtQkFBT0EsQ0FBQyxtRkFBZ0I7QUFDdEMsSUFBSUksYUFBYUosbUJBQU9BLENBQUMseUZBQW1CO0FBQzVDLElBQUlLLHVCQUF1QkwsbUJBQU9BLENBQUMsNEdBQXVCO0FBQzFELFNBQVNELHVCQUF1Qk8sR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRSxXQUFXLEtBQUtDLFVBQVVELE1BQU1DLE9BQU9FLFNBQVMsR0FBRyxXQUFXLE9BQU9IO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSSxRQUFRQyxDQUFDLEVBQUVDLENBQUM7SUFBSSxJQUFJQyxJQUFJdkIsT0FBT3dCLElBQUksQ0FBQ0g7SUFBSSxJQUFJckIsT0FBT3lCLHFCQUFxQixFQUFFO1FBQUUsSUFBSVQsSUFBSWhCLE9BQU95QixxQkFBcUIsQ0FBQ0o7UUFBSUMsS0FBTU4sQ0FBQUEsSUFBSUEsRUFBRVUsTUFB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QUFNMkM7SUFDbEUsSUFBSVQsYUFBYSw0QkFBNEI7UUFDM0MsT0FBTyxDQUFDLEdBQUd4RSxxQkFBcUIyRixtQkFBbUIsRUFBRXJELE1BQU1DLFlBQVlDLGFBQWFDLE9BQU9DO0lBQzdGO0lBQ0EsSUFBSThCLGFBQWEsbUJBQW1CQSxhQUFhLG9CQUFvQjtRQUNuRVEsYUFBYXRCLGNBQWNwQixNQUFNQyxZQUFZQyxhQUFhQyxPQUFPQyxZQUFZOEIsYUFBYTtJQUM1RixPQUFPO1FBQ0xRLGFBQWEzQyxZQUFZQyxNQUFNQyxZQUFZQyxhQUFhQyxPQUFPQztJQUNqRTtJQUNBLE9BQU9zQyxXQUFXbEUsTUFBTSxDQUFDLFNBQVVtQyxLQUFLO1FBQ3RDLE9BQU9BLE1BQU1PLE1BQU07SUFDckI7QUFDRiIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcY2FydGVzaWFuXFxnZXRUaWNrcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmdldFRpY2tzID0gZ2V0VGlja3M7XHJcbnZhciBfaXNGdW5jdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpKTtcclxudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9EYXRhVXRpbHNcIik7XHJcbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9ET01VdGlsc1wiKTtcclxudmFyIF9HbG9iYWwgPSByZXF1aXJlKFwiLi4vdXRpbC9HbG9iYWxcIik7XHJcbnZhciBfVGlja1V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvVGlja1V0aWxzXCIpO1xyXG52YXIgX2dldEVxdWlkaXN0YW50VGlja3MgPSByZXF1aXJlKFwiLi9nZXRFcXVpZGlzdGFudFRpY2tzXCIpO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxyXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XHJcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XHJcbmZ1bmN0aW9uIGdldFRpY2tzRW5kKHNpZ24sIGJvdW5kYXJpZXMsIGdldFRpY2tTaXplLCB0aWNrcywgbWluVGlja0dhcCkge1xyXG4gIHZhciByZXN1bHQgPSAodGlja3MgfHwgW10pLnNsaWNlKCk7XHJcbiAgdmFyIGxlbiA9IHJlc3VsdC5sZW5ndGg7XHJcbiAgdmFyIHN0YXJ0ID0gYm91bmRhcmllcy5zdGFydDtcclxuICB2YXIgZW5kID0gYm91bmRhcmllcy5lbmQ7XHJcbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xyXG4gICAgdmFyIGVudHJ5ID0gcmVzdWx0W2ldO1xyXG4gICAgdmFyIHNpemU7XHJcbiAgICB2YXIgZ2V0U2l6ZSA9IGZ1bmN0aW9uIGdldFNpemUoKSB7XHJcbiAgICAgIGlmIChzaXplID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBzaXplID0gZ2V0VGlja1NpemUoZW50cnksIGkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzaXplO1xyXG4gICAgfTtcclxuICAgIGlmIChpID09PSBsZW4gLSAxKSB7XHJcbiAgICAgIHZhciBnYXAgPSBzaWduICogKGVudHJ5LmNvb3JkaW5hdGUgKyBzaWduICogZ2V0U2l6ZSgpIC8gMiAtIGVuZCk7XHJcbiAgICAgIHJlc3VsdFtpXSA9IGVudHJ5ID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeSksIHt9LCB7XHJcbiAgICAgICAgdGlja0Nvb3JkOiBnYXAgPiAwID8gZW50cnkuY29vcmRpbmF0ZSAtIGdhcCAqIHNpZ24gOiBlbnRyeS5jb29yZGluYXRlXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVzdWx0W2ldID0gZW50cnkgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcclxuICAgICAgICB0aWNrQ29vcmQ6IGVudHJ5LmNvb3JkaW5hdGVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB2YXIgaXNTaG93ID0gKDAsIF9UaWNrVXRpbHMuaXNWaXNpYmxlKShzaWduLCBlbnRyeS50aWNrQ29vcmQsIGdldFNpemUsIHN0YXJ0LCBlbmQpO1xyXG4gICAgaWYgKGlzU2hvdykge1xyXG4gICAgICBlbmQgPSBlbnRyeS50aWNrQ29vcmQgLSBzaWduICogKGdldFNpemUoKSAvIDIgKyBtaW5UaWNrR2FwKTtcclxuICAgICAgcmVzdWx0W2ldID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeSksIHt9LCB7XHJcbiAgICAgICAgaXNTaG93OiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICBfbG9vcChpKTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBnZXRUaWNrc1N0YXJ0KHNpZ24sIGJvdW5kYXJpZXMsIGdldFRpY2tTaXplLCB0aWNrcywgbWluVGlja0dhcCwgcHJlc2VydmVFbmQpIHtcclxuICB2YXIgcmVzdWx0ID0gKHRpY2tzIHx8IFtdKS5zbGljZSgpO1xyXG4gIHZhciBsZW4gPSByZXN1bHQubGVuZ3RoO1xyXG4gIHZhciBzdGFydCA9IGJvdW5kYXJpZXMuc3RhcnQsXHJcbiAgICBlbmQgPSBib3VuZGFyaWVzLmVuZDtcclxuICBpZiAocHJlc2VydmVFbmQpIHtcclxuICAgIC8vIFRyeSB0byBndWFyYW50ZWUgdGhlIHRhaWwgdG8gYmUgZGlzcGxheWVkXHJcbiAgICB2YXIgdGFpbCA9IHRpY2tzW2xlbiAtIDFdO1xyXG4gICAgdmFyIHRhaWxTaXplID0gZ2V0VGlja1NpemUodGFpbCwgbGVuIC0gMSk7XHJcbiAgICB2YXIgdGFpbEdhcCA9IHNpZ24gKiAodGFpbC5jb29yZGluYXRlICsgc2lnbiAqIHRhaWxTaXplIC8gMiAtIGVuZCk7XHJcbiAgICByZXN1bHRbbGVuIC0gMV0gPSB0YWlsID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0YWlsKSwge30sIHtcclxuICAgICAgdGlja0Nvb3JkOiB0YWlsR2FwID4gMCA/IHRhaWwuY29vcmRpbmF0ZSAtIHRhaWxHYXAgKiBzaWduIDogdGFpbC5jb29yZGluYXRlXHJcbiAgICB9KTtcclxuICAgIHZhciBpc1RhaWxTaG93ID0gKDAsIF9UaWNrVXRpbHMuaXNWaXNpYmxlKShzaWduLCB0YWlsLnRpY2tDb29yZCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGFpbFNpemU7XHJcbiAgICB9LCBzdGFydCwgZW5kKTtcclxuICAgIGlmIChpc1RhaWxTaG93KSB7XHJcbiAgICAgIGVuZCA9IHRhaWwudGlja0Nvb3JkIC0gc2lnbiAqICh0YWlsU2l6ZSAvIDIgKyBtaW5UaWNrR2FwKTtcclxuICAgICAgcmVzdWx0W2xlbiAtIDFdID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0YWlsKSwge30sIHtcclxuICAgICAgICBpc1Nob3c6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHZhciBjb3VudCA9IHByZXNlcnZlRW5kID8gbGVuIC0gMSA6IGxlbjtcclxuICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKGkpIHtcclxuICAgIHZhciBlbnRyeSA9IHJlc3VsdFtpXTtcclxuICAgIHZhciBzaXplO1xyXG4gICAgdmFyIGdldFNpemUgPSBmdW5jdGlvbiBnZXRTaXplKCkge1xyXG4gICAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgc2l6ZSA9IGdldFRpY2tTaXplKGVudHJ5LCBpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2l6ZTtcclxuICAgIH07XHJcbiAgICBpZiAoaSA9PT0gMCkge1xyXG4gICAgICB2YXIgZ2FwID0gc2lnbiAqIChlbnRyeS5jb29yZGluYXRlIC0gc2lnbiAqIGdldFNpemUoKSAvIDIgLSBzdGFydCk7XHJcbiAgICAgIHJlc3VsdFtpXSA9IGVudHJ5ID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeSksIHt9LCB7XHJcbiAgICAgICAgdGlja0Nvb3JkOiBnYXAgPCAwID8gZW50cnkuY29vcmRpbmF0ZSAtIGdhcCAqIHNpZ24gOiBlbnRyeS5jb29yZGluYXRlXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVzdWx0W2ldID0gZW50cnkgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcclxuICAgICAgICB0aWNrQ29vcmQ6IGVudHJ5LmNvb3JkaW5hdGVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB2YXIgaXNTaG93ID0gKDAsIF9UaWNrVXRpbHMuaXNWaXNpYmxlKShzaWduLCBlbnRyeS50aWNrQ29vcmQsIGdldFNpemUsIHN0YXJ0LCBlbmQpO1xyXG4gICAgaWYgKGlzU2hvdykge1xyXG4gICAgICBzdGFydCA9IGVudHJ5LnRpY2tDb29yZCArIHNpZ24gKiAoZ2V0U2l6ZSgpIC8gMiArIG1pblRpY2tHYXApO1xyXG4gICAgICByZXN1bHRbaV0gPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcclxuICAgICAgICBpc1Nob3c6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgIF9sb29wMihpKTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBnZXRUaWNrcyhwcm9wcywgZm9udFNpemUsIGxldHRlclNwYWNpbmcpIHtcclxuICB2YXIgdGljayA9IHByb3BzLnRpY2ssXHJcbiAgICB0aWNrcyA9IHByb3BzLnRpY2tzLFxyXG4gICAgdmlld0JveCA9IHByb3BzLnZpZXdCb3gsXHJcbiAgICBtaW5UaWNrR2FwID0gcHJvcHMubWluVGlja0dhcCxcclxuICAgIG9yaWVudGF0aW9uID0gcHJvcHMub3JpZW50YXRpb24sXHJcbiAgICBpbnRlcnZhbCA9IHByb3BzLmludGVydmFsLFxyXG4gICAgdGlja0Zvcm1hdHRlciA9IHByb3BzLnRpY2tGb3JtYXR0ZXIsXHJcbiAgICB1bml0ID0gcHJvcHMudW5pdCxcclxuICAgIGFuZ2xlID0gcHJvcHMuYW5nbGU7XHJcbiAgaWYgKCF0aWNrcyB8fCAhdGlja3MubGVuZ3RoIHx8ICF0aWNrKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG4gIGlmICgoMCwgX0RhdGFVdGlscy5pc051bWJlcikoaW50ZXJ2YWwpIHx8IF9HbG9iYWwuR2xvYmFsLmlzU3NyKSB7XHJcbiAgICByZXR1cm4gKDAsIF9UaWNrVXRpbHMuZ2V0TnVtYmVySW50ZXJ2YWxUaWNrcykodGlja3MsIHR5cGVvZiBpbnRlcnZhbCA9PT0gJ251bWJlcicgJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGludGVydmFsKSA/IGludGVydmFsIDogMCk7XHJcbiAgfVxyXG4gIHZhciBjYW5kaWRhdGVzID0gW107XHJcbiAgdmFyIHNpemVLZXkgPSBvcmllbnRhdGlvbiA9PT0gJ3RvcCcgfHwgb3JpZW50YXRpb24gPT09ICdib3R0b20nID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xyXG4gIHZhciB1bml0U2l6ZSA9IHVuaXQgJiYgc2l6ZUtleSA9PT0gJ3dpZHRoJyA/ICgwLCBfRE9NVXRpbHMuZ2V0U3RyaW5nU2l6ZSkodW5pdCwge1xyXG4gICAgZm9udFNpemU6IGZvbnRTaXplLFxyXG4gICAgbGV0dGVyU3BhY2luZzogbGV0dGVyU3BhY2luZ1xyXG4gIH0pIDoge1xyXG4gICAgd2lkdGg6IDAsXHJcbiAgICBoZWlnaHQ6IDBcclxuICB9O1xyXG4gIHZhciBnZXRUaWNrU2l6ZSA9IGZ1bmN0aW9uIGdldFRpY2tTaXplKGNvbnRlbnQsIGluZGV4KSB7XHJcbiAgICB2YXIgdmFsdWUgPSAoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKSh0aWNrRm9ybWF0dGVyKSA/IHRpY2tGb3JtYXR0ZXIoY29udGVudC52YWx1ZSwgaW5kZXgpIDogY29udGVudC52YWx1ZTtcclxuICAgIC8vIFJlY2hhcnRzIG9ubHkgc3VwcG9ydHMgYW5nbGVzIHdoZW4gc2l6ZUtleSA9PT0gJ3dpZHRoJ1xyXG4gICAgcmV0dXJuIHNpemVLZXkgPT09ICd3aWR0aCcgPyAoMCwgX1RpY2tVdGlscy5nZXRBbmdsZWRUaWNrV2lkdGgpKCgwLCBfRE9NVXRpbHMuZ2V0U3RyaW5nU2l6ZSkodmFsdWUsIHtcclxuICAgICAgZm9udFNpemU6IGZvbnRTaXplLFxyXG4gICAgICBsZXR0ZXJTcGFjaW5nOiBsZXR0ZXJTcGFjaW5nXHJcbiAgICB9KSwgdW5pdFNpemUsIGFuZ2xlKSA6ICgwLCBfRE9NVXRpbHMuZ2V0U3RyaW5nU2l6ZSkodmFsdWUsIHtcclxuICAgICAgZm9udFNpemU6IGZvbnRTaXplLFxyXG4gICAgICBsZXR0ZXJTcGFjaW5nOiBsZXR0ZXJTcGFjaW5nXHJcbiAgICB9KVtzaXplS2V5XTtcclxuICB9O1xyXG4gIHZhciBzaWduID0gdGlja3MubGVuZ3RoID49IDIgPyAoMCwgX0RhdGFVdGlscy5tYXRoU2lnbikodGlja3NbMV0uY29vcmRpbmF0ZSAtIHRpY2tzWzBdLmNvb3JkaW5hdGUpIDogMTtcclxuICB2YXIgYm91bmRhcmllcyA9ICgwLCBfVGlja1V0aWxzLmdldFRpY2tCb3VuZGFyaWVzKSh2aWV3Qm94LCBzaWduLCBzaXplS2V5KTtcclxuICBpZiAoaW50ZXJ2YWwgPT09ICdlcXVpZGlzdGFudFByZXNlcnZlU3RhcnQnKSB7XHJcbiAgICByZXR1cm4gKDAsIF9nZXRFcXVpZGlzdGFudFRpY2tzLmdldEVxdWlkaXN0YW50VGlja3MpKHNpZ24sIGJvdW5kYXJpZXMsIGdldFRpY2tTaXplLCB0aWNrcywgbWluVGlja0dhcCk7XHJcbiAgfVxyXG4gIGlmIChpbnRlcnZhbCA9PT0gJ3ByZXNlcnZlU3RhcnQnIHx8IGludGVydmFsID09PSAncHJlc2VydmVTdGFydEVuZCcpIHtcclxuICAgIGNhbmRpZGF0ZXMgPSBnZXRUaWNrc1N0YXJ0KHNpZ24sIGJvdW5kYXJpZXMsIGdldFRpY2tTaXplLCB0aWNrcywgbWluVGlja0dhcCwgaW50ZXJ2YWwgPT09ICdwcmVzZXJ2ZVN0YXJ0RW5kJyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNhbmRpZGF0ZXMgPSBnZXRUaWNrc0VuZChzaWduLCBib3VuZGFyaWVzLCBnZXRUaWNrU2l6ZSwgdGlja3MsIG1pblRpY2tHYXApO1xyXG4gIH1cclxuICByZXR1cm4gY2FuZGlkYXRlcy5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICByZXR1cm4gZW50cnkuaXNTaG93O1xyXG4gIH0pO1xyXG59Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0VGlja3MiLCJfaXNGdW5jdGlvbiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX0RhdGFVdGlscyIsIl9ET01VdGlscyIsIl9HbG9iYWwiLCJfVGlja1V0aWxzIiwiX2dldEVxdWlkaXN0YW50VGlja3MiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsIm93bktleXMiLCJlIiwiciIsInQiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJrZXkiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiaSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiY2FsbCIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsImdldFRpY2tzRW5kIiwic2lnbiIsImJvdW5kYXJpZXMiLCJnZXRUaWNrU2l6ZSIsInRpY2tzIiwibWluVGlja0dhcCIsInJlc3VsdCIsInNsaWNlIiwibGVuIiwic3RhcnQiLCJlbmQiLCJfbG9vcCIsImVudHJ5Iiwic2l6ZSIsImdldFNpemUiLCJ1bmRlZmluZWQiLCJnYXAiLCJjb29yZGluYXRlIiwidGlja0Nvb3JkIiwiaXNTaG93IiwiaXNWaXNpYmxlIiwiZ2V0VGlja3NTdGFydCIsInByZXNlcnZlRW5kIiwidGFpbCIsInRhaWxTaXplIiwidGFpbEdhcCIsImlzVGFpbFNob3ciLCJjb3VudCIsIl9sb29wMiIsInByb3BzIiwiZm9udFNpemUiLCJsZXR0ZXJTcGFjaW5nIiwidGljayIsInZpZXdCb3giLCJvcmllbnRhdGlvbiIsImludGVydmFsIiwidGlja0Zvcm1hdHRlciIsInVuaXQiLCJhbmdsZSIsImlzTnVtYmVyIiwiR2xvYmFsIiwiaXNTc3IiLCJnZXROdW1iZXJJbnRlcnZhbFRpY2tzIiwiY2FuZGlkYXRlcyIsInNpemVLZXkiLCJ1bml0U2l6ZSIsImdldFN0cmluZ1NpemUiLCJ3aWR0aCIsImhlaWdodCIsImNvbnRlbnQiLCJpbmRleCIsImdldEFuZ2xlZFRpY2tXaWR0aCIsIm1hdGhTaWduIiwiZ2V0VGlja0JvdW5kYXJpZXMiLCJnZXRFcXVpZGlzdGFudFRpY2tzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/cartesian/getTicks.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/chart/AccessibilityManager.js":
/*!*****************************************************************!*\
  !*** ./node_modules/recharts/lib/chart/AccessibilityManager.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AccessibilityManager = void 0;\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar AccessibilityManager = exports.AccessibilityManager = /*#__PURE__*/ function() {\n    function AccessibilityManager() {\n        _classCallCheck(this, AccessibilityManager);\n        _defineProperty(this, \"activeIndex\", 0);\n        _defineProperty(this, \"coordinateList\", []);\n        _defineProperty(this, \"layout\", 'horizontal');\n    }\n    return _createClass(AccessibilityManager, [\n        {\n            key: \"setDetails\",\n            value: function setDetails(_ref) {\n                var _ref2;\n                var _ref$coordinateList = _ref.coordinateList, coordinateList = _ref$coordinateList === void 0 ? null : _ref$coordinateList, _ref$container = _ref.container, container = _ref$container === void 0 ? null : _ref$container, _ref$layout = _ref.layout, layout = _ref$layout === void 0 ? null : _ref$layout, _ref$offset = _ref.offset, offset = _ref$offset === void 0 ? null : _ref$offset, _ref$mouseHandlerCall = _ref.mouseHandlerCallback, mouseHandlerCallback = _ref$mouseHandlerCall === void 0 ? null : _ref$mouseHandlerCall;\n                this.coordinateList = (_ref2 = coordinateList !== null && coordinateList !== void 0 ? coordinateList : this.coordinateList) !== null && _ref2 !== void 0 ? _ref2 : [];\n                this.container = container !== null && container !== void 0 ? container : this.container;\n                this.layout = layout !== null && layout !== void 0 ? layout : this.layout;\n                this.offset = offset !== null && offset !== void 0 ? offset : this.offset;\n                this.mouseHandlerCallback = mouseHandlerCallback !== null && mouseHandlerCallback !== void 0 ? mouseHandlerCallback : this.mouseHandlerCallback;\n                // Keep activeIndex in the bounds between 0 and the last coordinate index\n                this.activeIndex = Math.min(Math.max(this.activeIndex, 0), this.coordinateList.length - 1);\n            }\n        },\n        {\n            key: \"focus\",\n            value: function focus() {\n                this.spoofMouse();\n            }\n        },\n        {\n            key: \"keyboardEvent\",\n            value: function keyboardEvent(e) {\n                // The AccessibilityManager relies on the Tooltip component. When tooltips suddenly stop existing,\n                // it can cause errors. We use this function to check. We don't want arrow keys to be processed\n                // if there are no tooltips, since that will cause unexpected behavior of users.\n                if (this.coordinateList.length === 0) {\n                    return;\n                }\n                switch(e.key){\n                    case 'ArrowRight':\n                        {\n                            if (this.layout !== 'horizontal') {\n                                return;\n                            }\n                            this.activeIndex = Math.min(this.activeIndex + 1, this.coordinateList.length - 1);\n                            this.spoofMouse();\n                            break;\n                        }\n                    case 'ArrowLeft':\n                        {\n                            if (this.layout !== 'horizontal') {\n                                return;\n                            }\n                            this.activeIndex = Math.max(this.activeIndex - 1, 0);\n                            this.spoofMouse();\n                            break;\n                        }\n                    default:\n                        {\n                            break;\n                        }\n                }\n            }\n        },\n        {\n            key: \"setIndex\",\n            value: function setIndex(newIndex) {\n                this.activeIndex = newIndex;\n            }\n        },\n        {\n            key: \"spoofMouse\",\n            value: function spoofMouse() {\n                var _window, _window2;\n                if (this.layout !== 'horizontal') {\n                    return;\n                }\n                // This can happen when the tooltips suddenly stop existing as children of the component\n                // That update doesn't otherwise fire events, so we have to double check here.\n                if (this.coordinateList.length === 0) {\n                    return;\n                }\n                var _this$container$getBo = this.container.getBoundingClientRect(), x = _this$container$getBo.x, y = _this$container$getBo.y, height = _this$container$getBo.height;\n                var coordinate = this.coordinateList[this.activeIndex].coordinate;\n                var scrollOffsetX = ((_window = window) === null || _window === void 0 ? void 0 : _window.scrollX) || 0;\n                var scrollOffsetY = ((_window2 = window) === null || _window2 === void 0 ? void 0 : _window2.scrollY) || 0;\n                var pageX = x + coordinate + scrollOffsetX;\n                var pageY = y + this.offset.top + height / 2 + scrollOffsetY;\n                this.mouseHandlerCallback({\n                    pageX: pageX,\n                    pageY: pageY\n                });\n            }\n        }\n    ]);\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvQWNjZXNzaWJpbGl0eU1hbmFnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELDRCQUE0QixHQUFHLEtBQUs7QUFDcEMsU0FBU0csUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUUsV0FBVyxLQUFLQyxVQUFVRCxNQUFNQyxPQUFPRSxTQUFTLEdBQUcsV0FBVyxPQUFPSDtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1QsU0FBU0ksZ0JBQWdCQyxRQUFRLEVBQUVDLFdBQVc7SUFBSSxJQUFJLENBQUVELENBQUFBLG9CQUFvQkMsV0FBVSxHQUFJO1FBQUUsTUFBTSxJQUFJQyxVQUFVO0lBQXNDO0FBQUU7QUFDeEosU0FBU0Msa0JBQWtCQyxNQUFNLEVBQUVDLEtBQUs7SUFBSSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUQsTUFBTUUsTUFBTSxFQUFFRCxJQUFLO1FBQUUsSUFBSUUsYUFBYUgsS0FBSyxDQUFDQyxFQUFFO1FBQUVFLFdBQVdDLFVBQVUsR0FBR0QsV0FBV0MsVUFBVSxJQUFJO1FBQU9ELFdBQVdFLFlBQVksR0FBRztRQUFNLElBQUksV0FBV0YsWUFBWUEsV0FBV0csUUFBUSxHQUFHO1FBQU10QixPQUFPQyxjQUFjLENBQUNjLFFBQVFRLGVBQWVKLFdBQVdLLEdBQUcsR0FBR0w7SUFBYTtBQUFFO0FBQzVVLFNBQVNNLGFBQWFiLFdBQVcsRUFBRWMsVUFBVSxFQUFFQyxXQUFXO0lBQUksSUFBSUQsWUFBWVosa0JBQWtCRixZQUFZSCxTQUFTLEVB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LE9BQU8sU0FBU3FEO2dCQUNkLElBQUlJLFNBQVNDO2dCQUNiLElBQUksSUFBSSxDQUFDZixNQUFNLEtBQUssY0FBYztvQkFDaEM7Z0JBQ0Y7Z0JBRUEsd0ZBQXdGO2dCQUN4Riw4RUFBOEU7Z0JBQzlFLElBQUksSUFBSSxDQUFDSixjQUFjLENBQUN4QixNQUFNLEtBQUssR0FBRztvQkFDcEM7Z0JBQ0Y7Z0JBQ0EsSUFBSTRDLHdCQUF3QixJQUFJLENBQUNsQixTQUFTLENBQUNtQixxQkFBcUIsSUFDOURDLElBQUlGLHNCQUFzQkUsQ0FBQyxFQUMzQkMsSUFBSUgsc0JBQXNCRyxDQUFDLEVBQzNCQyxTQUFTSixzQkFBc0JJLE1BQU07Z0JBQ3ZDLElBQUlDLGFBQWEsSUFBSSxDQUFDekIsY0FBYyxDQUFDLElBQUksQ0FBQ1MsV0FBVyxDQUFDLENBQUNnQixVQUFVO2dCQUNqRSxJQUFJQyxnQkFBZ0IsQ0FBQyxDQUFDUixVQUFVUyxNQUFLLE1BQU8sUUFBUVQsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRVSxPQUFPLEtBQUs7Z0JBQ3RHLElBQUlDLGdCQUFnQixDQUFDLENBQUNWLFdBQVdRLE1BQUssTUFBTyxRQUFRUixhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVNXLE9BQU8sS0FBSztnQkFDekcsSUFBSUMsUUFBUVQsSUFBSUcsYUFBYUM7Z0JBQzdCLElBQUlNLFFBQVFULElBQUksSUFBSSxDQUFDakIsTUFBTSxDQUFDMkIsR0FBRyxHQUFHVCxTQUFTLElBQUlLO2dCQUMvQyxJQUFJLENBQUNyQixvQkFBb0IsQ0FBQztvQkFDeEJ1QixPQUFPQTtvQkFDUEMsT0FBT0E7Z0JBQ1Q7WUFDRjtRQUNGO0tBQUU7QUFDSiIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcY2hhcnRcXEFjY2Vzc2liaWxpdHlNYW5hZ2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuQWNjZXNzaWJpbGl0eU1hbmFnZXIgPSB2b2lkIDA7XHJcbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cclxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cclxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxyXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxyXG52YXIgQWNjZXNzaWJpbGl0eU1hbmFnZXIgPSBleHBvcnRzLkFjY2Vzc2liaWxpdHlNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBBY2Nlc3NpYmlsaXR5TWFuYWdlcigpIHtcclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBY2Nlc3NpYmlsaXR5TWFuYWdlcik7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJhY3RpdmVJbmRleFwiLCAwKTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvb3JkaW5hdGVMaXN0XCIsIFtdKTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxheW91dFwiLCAnaG9yaXpvbnRhbCcpO1xyXG4gIH1cclxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEFjY2Vzc2liaWxpdHlNYW5hZ2VyLCBbe1xyXG4gICAga2V5OiBcInNldERldGFpbHNcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREZXRhaWxzKF9yZWYpIHtcclxuICAgICAgdmFyIF9yZWYyO1xyXG4gICAgICB2YXIgX3JlZiRjb29yZGluYXRlTGlzdCA9IF9yZWYuY29vcmRpbmF0ZUxpc3QsXHJcbiAgICAgICAgY29vcmRpbmF0ZUxpc3QgPSBfcmVmJGNvb3JkaW5hdGVMaXN0ID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRjb29yZGluYXRlTGlzdCxcclxuICAgICAgICBfcmVmJGNvbnRhaW5lciA9IF9yZWYuY29udGFpbmVyLFxyXG4gICAgICAgIGNvbnRhaW5lciA9IF9yZWYkY29udGFpbmVyID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRjb250YWluZXIsXHJcbiAgICAgICAgX3JlZiRsYXlvdXQgPSBfcmVmLmxheW91dCxcclxuICAgICAgICBsYXlvdXQgPSBfcmVmJGxheW91dCA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYkbGF5b3V0LFxyXG4gICAgICAgIF9yZWYkb2Zmc2V0ID0gX3JlZi5vZmZzZXQsXHJcbiAgICAgICAgb2Zmc2V0ID0gX3JlZiRvZmZzZXQgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmJG9mZnNldCxcclxuICAgICAgICBfcmVmJG1vdXNlSGFuZGxlckNhbGwgPSBfcmVmLm1vdXNlSGFuZGxlckNhbGxiYWNrLFxyXG4gICAgICAgIG1vdXNlSGFuZGxlckNhbGxiYWNrID0gX3JlZiRtb3VzZUhhbmRsZXJDYWxsID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRtb3VzZUhhbmRsZXJDYWxsO1xyXG4gICAgICB0aGlzLmNvb3JkaW5hdGVMaXN0ID0gKF9yZWYyID0gY29vcmRpbmF0ZUxpc3QgIT09IG51bGwgJiYgY29vcmRpbmF0ZUxpc3QgIT09IHZvaWQgMCA/IGNvb3JkaW5hdGVMaXN0IDogdGhpcy5jb29yZGluYXRlTGlzdCkgIT09IG51bGwgJiYgX3JlZjIgIT09IHZvaWQgMCA/IF9yZWYyIDogW107XHJcbiAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyICE9PSBudWxsICYmIGNvbnRhaW5lciAhPT0gdm9pZCAwID8gY29udGFpbmVyIDogdGhpcy5jb250YWluZXI7XHJcbiAgICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0ICE9PSBudWxsICYmIGxheW91dCAhPT0gdm9pZCAwID8gbGF5b3V0IDogdGhpcy5sYXlvdXQ7XHJcbiAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0ICE9PSBudWxsICYmIG9mZnNldCAhPT0gdm9pZCAwID8gb2Zmc2V0IDogdGhpcy5vZmZzZXQ7XHJcbiAgICAgIHRoaXMubW91c2VIYW5kbGVyQ2FsbGJhY2sgPSBtb3VzZUhhbmRsZXJDYWxsYmFjayAhPT0gbnVsbCAmJiBtb3VzZUhhbmRsZXJDYWxsYmFjayAhPT0gdm9pZCAwID8gbW91c2VIYW5kbGVyQ2FsbGJhY2sgOiB0aGlzLm1vdXNlSGFuZGxlckNhbGxiYWNrO1xyXG5cclxuICAgICAgLy8gS2VlcCBhY3RpdmVJbmRleCBpbiB0aGUgYm91bmRzIGJldHdlZW4gMCBhbmQgdGhlIGxhc3QgY29vcmRpbmF0ZSBpbmRleFxyXG4gICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gTWF0aC5taW4oTWF0aC5tYXgodGhpcy5hY3RpdmVJbmRleCwgMCksIHRoaXMuY29vcmRpbmF0ZUxpc3QubGVuZ3RoIC0gMSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImZvY3VzXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9jdXMoKSB7XHJcbiAgICAgIHRoaXMuc3Bvb2ZNb3VzZSgpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJrZXlib2FyZEV2ZW50XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2V5Ym9hcmRFdmVudChlKSB7XHJcbiAgICAgIC8vIFRoZSBBY2Nlc3NpYmlsaXR5TWFuYWdlciByZWxpZXMgb24gdGhlIFRvb2x0aXAgY29tcG9uZW50LiBXaGVuIHRvb2x0aXBzIHN1ZGRlbmx5IHN0b3AgZXhpc3RpbmcsXHJcbiAgICAgIC8vIGl0IGNhbiBjYXVzZSBlcnJvcnMuIFdlIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNoZWNrLiBXZSBkb24ndCB3YW50IGFycm93IGtleXMgdG8gYmUgcHJvY2Vzc2VkXHJcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyB0b29sdGlwcywgc2luY2UgdGhhdCB3aWxsIGNhdXNlIHVuZXhwZWN0ZWQgYmVoYXZpb3Igb2YgdXNlcnMuXHJcbiAgICAgIGlmICh0aGlzLmNvb3JkaW5hdGVMaXN0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBzd2l0Y2ggKGUua2V5KSB7XHJcbiAgICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dCAhPT0gJ2hvcml6b250YWwnKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSBNYXRoLm1pbih0aGlzLmFjdGl2ZUluZGV4ICsgMSwgdGhpcy5jb29yZGluYXRlTGlzdC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgdGhpcy5zcG9vZk1vdXNlKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgJ0Fycm93TGVmdCc6XHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dCAhPT0gJ2hvcml6b250YWwnKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSBNYXRoLm1heCh0aGlzLmFjdGl2ZUluZGV4IC0gMSwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3Bvb2ZNb3VzZSgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJzZXRJbmRleFwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluZGV4KG5ld0luZGV4KSB7XHJcbiAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSBuZXdJbmRleDtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwic3Bvb2ZNb3VzZVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwb29mTW91c2UoKSB7XHJcbiAgICAgIHZhciBfd2luZG93LCBfd2luZG93MjtcclxuICAgICAgaWYgKHRoaXMubGF5b3V0ICE9PSAnaG9yaXpvbnRhbCcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHRoZSB0b29sdGlwcyBzdWRkZW5seSBzdG9wIGV4aXN0aW5nIGFzIGNoaWxkcmVuIG9mIHRoZSBjb21wb25lbnRcclxuICAgICAgLy8gVGhhdCB1cGRhdGUgZG9lc24ndCBvdGhlcndpc2UgZmlyZSBldmVudHMsIHNvIHdlIGhhdmUgdG8gZG91YmxlIGNoZWNrIGhlcmUuXHJcbiAgICAgIGlmICh0aGlzLmNvb3JkaW5hdGVMaXN0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB2YXIgX3RoaXMkY29udGFpbmVyJGdldEJvID0gdGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXHJcbiAgICAgICAgeCA9IF90aGlzJGNvbnRhaW5lciRnZXRCby54LFxyXG4gICAgICAgIHkgPSBfdGhpcyRjb250YWluZXIkZ2V0Qm8ueSxcclxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRjb250YWluZXIkZ2V0Qm8uaGVpZ2h0O1xyXG4gICAgICB2YXIgY29vcmRpbmF0ZSA9IHRoaXMuY29vcmRpbmF0ZUxpc3RbdGhpcy5hY3RpdmVJbmRleF0uY29vcmRpbmF0ZTtcclxuICAgICAgdmFyIHNjcm9sbE9mZnNldFggPSAoKF93aW5kb3cgPSB3aW5kb3cpID09PSBudWxsIHx8IF93aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93aW5kb3cuc2Nyb2xsWCkgfHwgMDtcclxuICAgICAgdmFyIHNjcm9sbE9mZnNldFkgPSAoKF93aW5kb3cyID0gd2luZG93KSA9PT0gbnVsbCB8fCBfd2luZG93MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3dpbmRvdzIuc2Nyb2xsWSkgfHwgMDtcclxuICAgICAgdmFyIHBhZ2VYID0geCArIGNvb3JkaW5hdGUgKyBzY3JvbGxPZmZzZXRYO1xyXG4gICAgICB2YXIgcGFnZVkgPSB5ICsgdGhpcy5vZmZzZXQudG9wICsgaGVpZ2h0IC8gMiArIHNjcm9sbE9mZnNldFk7XHJcbiAgICAgIHRoaXMubW91c2VIYW5kbGVyQ2FsbGJhY2soe1xyXG4gICAgICAgIHBhZ2VYOiBwYWdlWCxcclxuICAgICAgICBwYWdlWTogcGFnZVlcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfV0pO1xyXG59KCk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQWNjZXNzaWJpbGl0eU1hbmFnZXIiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwicHJvdG90eXBlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1Byb3BlcnR5S2V5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwidCIsIl90b1ByaW1pdGl2ZSIsInIiLCJlIiwidG9QcmltaXRpdmUiLCJjYWxsIiwiU3RyaW5nIiwiTnVtYmVyIiwic2V0RGV0YWlscyIsIl9yZWYiLCJfcmVmMiIsIl9yZWYkY29vcmRpbmF0ZUxpc3QiLCJjb29yZGluYXRlTGlzdCIsIl9yZWYkY29udGFpbmVyIiwiY29udGFpbmVyIiwiX3JlZiRsYXlvdXQiLCJsYXlvdXQiLCJfcmVmJG9mZnNldCIsIm9mZnNldCIsIl9yZWYkbW91c2VIYW5kbGVyQ2FsbCIsIm1vdXNlSGFuZGxlckNhbGxiYWNrIiwiYWN0aXZlSW5kZXgiLCJNYXRoIiwibWluIiwibWF4IiwiZm9jdXMiLCJzcG9vZk1vdXNlIiwia2V5Ym9hcmRFdmVudCIsInNldEluZGV4IiwibmV3SW5kZXgiLCJfd2luZG93IiwiX3dpbmRvdzIiLCJfdGhpcyRjb250YWluZXIkZ2V0Qm8iLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ4IiwieSIsImhlaWdodCIsImNvb3JkaW5hdGUiLCJzY3JvbGxPZmZzZXRYIiwid2luZG93Iiwic2Nyb2xsWCIsInNjcm9sbE9mZnNldFkiLCJzY3JvbGxZIiwicGFnZVgiLCJwYWdlWSIsInRvcCJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/chart/AccessibilityManager.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/chart/AreaChart.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/chart/AreaChart.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AreaChart = void 0;\nvar _generateCategoricalChart = __webpack_require__(/*! ./generateCategoricalChart */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/generateCategoricalChart.js\");\nvar _Area = __webpack_require__(/*! ../cartesian/Area */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/Area.js\");\nvar _XAxis = __webpack_require__(/*! ../cartesian/XAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/XAxis.js\");\nvar _YAxis = __webpack_require__(/*! ../cartesian/YAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/YAxis.js\");\nvar _CartesianUtils = __webpack_require__(/*! ../util/CartesianUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/CartesianUtils.js\");\n/**\r\n * @fileOverview Area Chart\r\n */ var AreaChart = exports.AreaChart = (0, _generateCategoricalChart.generateCategoricalChart)({\n    chartName: 'AreaChart',\n    GraphicalChild: _Area.Area,\n    axisComponents: [\n        {\n            axisType: 'xAxis',\n            AxisComp: _XAxis.XAxis\n        },\n        {\n            axisType: 'yAxis',\n            AxisComp: _YAxis.YAxis\n        }\n    ],\n    formatAxisMap: _CartesianUtils.formatAxisMap\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvQXJlYUNoYXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLElBQUlHLDRCQUE0QkMsbUJBQU9BLENBQUMsa0hBQTRCO0FBQ3BFLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDLHlGQUFtQjtBQUN2QyxJQUFJRSxTQUFTRixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDekMsSUFBSUcsU0FBU0gsbUJBQU9BLENBQUMsMkZBQW9CO0FBQ3pDLElBQUlJLGtCQUFrQkosbUJBQU9BLENBQUMsbUdBQXdCO0FBQ3REOztDQUVDLEdBRUQsSUFBSUYsWUFBWUYsaUJBQWlCLEdBQUcsQ0FBQyxHQUFHRywwQkFBMEJNLHdCQUF3QixFQUFFO0lBQzFGQyxXQUFXO0lBQ1hDLGdCQUFnQk4sTUFBTU8sSUFBSTtJQUMxQkMsZ0JBQWdCO1FBQUM7WUFDZkMsVUFBVTtZQUNWQyxVQUFVVCxPQUFPVSxLQUFLO1FBQ3hCO1FBQUc7WUFDREYsVUFBVTtZQUNWQyxVQUFVUixPQUFPVSxLQUFLO1FBQ3hCO0tBQUU7SUFDRkMsZUFBZVYsZ0JBQWdCVSxhQUFhO0FBQzlDIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxjaGFydFxcQXJlYUNoYXJ0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuQXJlYUNoYXJ0ID0gdm9pZCAwO1xyXG52YXIgX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydFwiKTtcclxudmFyIF9BcmVhID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9BcmVhXCIpO1xyXG52YXIgX1hBeGlzID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9YQXhpc1wiKTtcclxudmFyIF9ZQXhpcyA9IHJlcXVpcmUoXCIuLi9jYXJ0ZXNpYW4vWUF4aXNcIik7XHJcbnZhciBfQ2FydGVzaWFuVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9DYXJ0ZXNpYW5VdGlsc1wiKTtcclxuLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgQXJlYSBDaGFydFxyXG4gKi9cclxuXHJcbnZhciBBcmVhQ2hhcnQgPSBleHBvcnRzLkFyZWFDaGFydCA9ICgwLCBfZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0LmdlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCkoe1xyXG4gIGNoYXJ0TmFtZTogJ0FyZWFDaGFydCcsXHJcbiAgR3JhcGhpY2FsQ2hpbGQ6IF9BcmVhLkFyZWEsXHJcbiAgYXhpc0NvbXBvbmVudHM6IFt7XHJcbiAgICBheGlzVHlwZTogJ3hBeGlzJyxcclxuICAgIEF4aXNDb21wOiBfWEF4aXMuWEF4aXNcclxuICB9LCB7XHJcbiAgICBheGlzVHlwZTogJ3lBeGlzJyxcclxuICAgIEF4aXNDb21wOiBfWUF4aXMuWUF4aXNcclxuICB9XSxcclxuICBmb3JtYXRBeGlzTWFwOiBfQ2FydGVzaWFuVXRpbHMuZm9ybWF0QXhpc01hcFxyXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBcmVhQ2hhcnQiLCJfZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0IiwicmVxdWlyZSIsIl9BcmVhIiwiX1hBeGlzIiwiX1lBeGlzIiwiX0NhcnRlc2lhblV0aWxzIiwiZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0IiwiY2hhcnROYW1lIiwiR3JhcGhpY2FsQ2hpbGQiLCJBcmVhIiwiYXhpc0NvbXBvbmVudHMiLCJheGlzVHlwZSIsIkF4aXNDb21wIiwiWEF4aXMiLCJZQXhpcyIsImZvcm1hdEF4aXNNYXAiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/chart/AreaChart.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/chart/BarChart.js":
/*!*****************************************************!*\
  !*** ./node_modules/recharts/lib/chart/BarChart.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BarChart = void 0;\nvar _generateCategoricalChart = __webpack_require__(/*! ./generateCategoricalChart */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/generateCategoricalChart.js\");\nvar _Bar = __webpack_require__(/*! ../cartesian/Bar */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/Bar.js\");\nvar _XAxis = __webpack_require__(/*! ../cartesian/XAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/XAxis.js\");\nvar _YAxis = __webpack_require__(/*! ../cartesian/YAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/YAxis.js\");\nvar _CartesianUtils = __webpack_require__(/*! ../util/CartesianUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/CartesianUtils.js\");\n/**\r\n * @fileOverview Bar Chart\r\n */ var BarChart = exports.BarChart = (0, _generateCategoricalChart.generateCategoricalChart)({\n    chartName: 'BarChart',\n    GraphicalChild: _Bar.Bar,\n    defaultTooltipEventType: 'axis',\n    validateTooltipEventTypes: [\n        'axis',\n        'item'\n    ],\n    axisComponents: [\n        {\n            axisType: 'xAxis',\n            AxisComp: _XAxis.XAxis\n        },\n        {\n            axisType: 'yAxis',\n            AxisComp: _YAxis.YAxis\n        }\n    ],\n    formatAxisMap: _CartesianUtils.formatAxisMap\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvQmFyQ2hhcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGdCQUFnQixHQUFHLEtBQUs7QUFDeEIsSUFBSUcsNEJBQTRCQyxtQkFBT0EsQ0FBQyxrSEFBNEI7QUFDcEUsSUFBSUMsT0FBT0QsbUJBQU9BLENBQUMsdUZBQWtCO0FBQ3JDLElBQUlFLFNBQVNGLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUN6QyxJQUFJRyxTQUFTSCxtQkFBT0EsQ0FBQywyRkFBb0I7QUFDekMsSUFBSUksa0JBQWtCSixtQkFBT0EsQ0FBQyxtR0FBd0I7QUFDdEQ7O0NBRUMsR0FFRCxJQUFJRixXQUFXRixnQkFBZ0IsR0FBRyxDQUFDLEdBQUdHLDBCQUEwQk0sd0JBQXdCLEVBQUU7SUFDeEZDLFdBQVc7SUFDWEMsZ0JBQWdCTixLQUFLTyxHQUFHO0lBQ3hCQyx5QkFBeUI7SUFDekJDLDJCQUEyQjtRQUFDO1FBQVE7S0FBTztJQUMzQ0MsZ0JBQWdCO1FBQUM7WUFDZkMsVUFBVTtZQUNWQyxVQUFVWCxPQUFPWSxLQUFLO1FBQ3hCO1FBQUc7WUFDREYsVUFBVTtZQUNWQyxVQUFVVixPQUFPWSxLQUFLO1FBQ3hCO0tBQUU7SUFDRkMsZUFBZVosZ0JBQWdCWSxhQUFhO0FBQzlDIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxjaGFydFxcQmFyQ2hhcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5CYXJDaGFydCA9IHZvaWQgMDtcclxudmFyIF9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnRcIik7XHJcbnZhciBfQmFyID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9CYXJcIik7XHJcbnZhciBfWEF4aXMgPSByZXF1aXJlKFwiLi4vY2FydGVzaWFuL1hBeGlzXCIpO1xyXG52YXIgX1lBeGlzID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9ZQXhpc1wiKTtcclxudmFyIF9DYXJ0ZXNpYW5VdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NhcnRlc2lhblV0aWxzXCIpO1xyXG4vKipcclxuICogQGZpbGVPdmVydmlldyBCYXIgQ2hhcnRcclxuICovXHJcblxyXG52YXIgQmFyQ2hhcnQgPSBleHBvcnRzLkJhckNoYXJ0ID0gKDAsIF9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQuZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0KSh7XHJcbiAgY2hhcnROYW1lOiAnQmFyQ2hhcnQnLFxyXG4gIEdyYXBoaWNhbENoaWxkOiBfQmFyLkJhcixcclxuICBkZWZhdWx0VG9vbHRpcEV2ZW50VHlwZTogJ2F4aXMnLFxyXG4gIHZhbGlkYXRlVG9vbHRpcEV2ZW50VHlwZXM6IFsnYXhpcycsICdpdGVtJ10sXHJcbiAgYXhpc0NvbXBvbmVudHM6IFt7XHJcbiAgICBheGlzVHlwZTogJ3hBeGlzJyxcclxuICAgIEF4aXNDb21wOiBfWEF4aXMuWEF4aXNcclxuICB9LCB7XHJcbiAgICBheGlzVHlwZTogJ3lBeGlzJyxcclxuICAgIEF4aXNDb21wOiBfWUF4aXMuWUF4aXNcclxuICB9XSxcclxuICBmb3JtYXRBeGlzTWFwOiBfQ2FydGVzaWFuVXRpbHMuZm9ybWF0QXhpc01hcFxyXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJCYXJDaGFydCIsIl9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQiLCJyZXF1aXJlIiwiX0JhciIsIl9YQXhpcyIsIl9ZQXhpcyIsIl9DYXJ0ZXNpYW5VdGlscyIsImdlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCIsImNoYXJ0TmFtZSIsIkdyYXBoaWNhbENoaWxkIiwiQmFyIiwiZGVmYXVsdFRvb2x0aXBFdmVudFR5cGUiLCJ2YWxpZGF0ZVRvb2x0aXBFdmVudFR5cGVzIiwiYXhpc0NvbXBvbmVudHMiLCJheGlzVHlwZSIsIkF4aXNDb21wIiwiWEF4aXMiLCJZQXhpcyIsImZvcm1hdEF4aXNNYXAiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/chart/BarChart.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/chart/ComposedChart.js":
/*!**********************************************************!*\
  !*** ./node_modules/recharts/lib/chart/ComposedChart.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ComposedChart = void 0;\nvar _generateCategoricalChart = __webpack_require__(/*! ./generateCategoricalChart */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/generateCategoricalChart.js\");\nvar _Area = __webpack_require__(/*! ../cartesian/Area */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/Area.js\");\nvar _Bar = __webpack_require__(/*! ../cartesian/Bar */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/Bar.js\");\nvar _Line = __webpack_require__(/*! ../cartesian/Line */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/Line.js\");\nvar _Scatter = __webpack_require__(/*! ../cartesian/Scatter */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/Scatter.js\");\nvar _XAxis = __webpack_require__(/*! ../cartesian/XAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/XAxis.js\");\nvar _YAxis = __webpack_require__(/*! ../cartesian/YAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/YAxis.js\");\nvar _ZAxis = __webpack_require__(/*! ../cartesian/ZAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/ZAxis.js\");\nvar _CartesianUtils = __webpack_require__(/*! ../util/CartesianUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/CartesianUtils.js\");\n/**\r\n * @fileOverview Composed Chart\r\n */ var ComposedChart = exports.ComposedChart = (0, _generateCategoricalChart.generateCategoricalChart)({\n    chartName: 'ComposedChart',\n    GraphicalChild: [\n        _Line.Line,\n        _Area.Area,\n        _Bar.Bar,\n        _Scatter.Scatter\n    ],\n    axisComponents: [\n        {\n            axisType: 'xAxis',\n            AxisComp: _XAxis.XAxis\n        },\n        {\n            axisType: 'yAxis',\n            AxisComp: _YAxis.YAxis\n        },\n        {\n            axisType: 'zAxis',\n            AxisComp: _ZAxis.ZAxis\n        }\n    ],\n    formatAxisMap: _CartesianUtils.formatAxisMap\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvQ29tcG9zZWRDaGFydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQscUJBQXFCLEdBQUcsS0FBSztBQUM3QixJQUFJRyw0QkFBNEJDLG1CQUFPQSxDQUFDLGtIQUE0QjtBQUNwRSxJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQyx5RkFBbUI7QUFDdkMsSUFBSUUsT0FBT0YsbUJBQU9BLENBQUMsdUZBQWtCO0FBQ3JDLElBQUlHLFFBQVFILG1CQUFPQSxDQUFDLHlGQUFtQjtBQUN2QyxJQUFJSSxXQUFXSixtQkFBT0EsQ0FBQywrRkFBc0I7QUFDN0MsSUFBSUssU0FBU0wsbUJBQU9BLENBQUMsMkZBQW9CO0FBQ3pDLElBQUlNLFNBQVNOLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUN6QyxJQUFJTyxTQUFTUCxtQkFBT0EsQ0FBQywyRkFBb0I7QUFDekMsSUFBSVEsa0JBQWtCUixtQkFBT0EsQ0FBQyxtR0FBd0I7QUFDdEQ7O0NBRUMsR0FFRCxJQUFJRixnQkFBZ0JGLHFCQUFxQixHQUFHLENBQUMsR0FBR0csMEJBQTBCVSx3QkFBd0IsRUFBRTtJQUNsR0MsV0FBVztJQUNYQyxnQkFBZ0I7UUFBQ1IsTUFBTVMsSUFBSTtRQUFFWCxNQUFNWSxJQUFJO1FBQUVYLEtBQUtZLEdBQUc7UUFBRVYsU0FBU1csT0FBTztLQUFDO0lBQ3BFQyxnQkFBZ0I7UUFBQztZQUNmQyxVQUFVO1lBQ1ZDLFVBQVViLE9BQU9jLEtBQUs7UUFDeEI7UUFBRztZQUNERixVQUFVO1lBQ1ZDLFVBQVVaLE9BQU9jLEtBQUs7UUFDeEI7UUFBRztZQUNESCxVQUFVO1lBQ1ZDLFVBQVVYLE9BQU9jLEtBQUs7UUFDeEI7S0FBRTtJQUNGQyxlQUFlZCxnQkFBZ0JjLGFBQWE7QUFDOUMiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXGNoYXJ0XFxDb21wb3NlZENoYXJ0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuQ29tcG9zZWRDaGFydCA9IHZvaWQgMDtcclxudmFyIF9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnRcIik7XHJcbnZhciBfQXJlYSA9IHJlcXVpcmUoXCIuLi9jYXJ0ZXNpYW4vQXJlYVwiKTtcclxudmFyIF9CYXIgPSByZXF1aXJlKFwiLi4vY2FydGVzaWFuL0JhclwiKTtcclxudmFyIF9MaW5lID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9MaW5lXCIpO1xyXG52YXIgX1NjYXR0ZXIgPSByZXF1aXJlKFwiLi4vY2FydGVzaWFuL1NjYXR0ZXJcIik7XHJcbnZhciBfWEF4aXMgPSByZXF1aXJlKFwiLi4vY2FydGVzaWFuL1hBeGlzXCIpO1xyXG52YXIgX1lBeGlzID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9ZQXhpc1wiKTtcclxudmFyIF9aQXhpcyA9IHJlcXVpcmUoXCIuLi9jYXJ0ZXNpYW4vWkF4aXNcIik7XHJcbnZhciBfQ2FydGVzaWFuVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9DYXJ0ZXNpYW5VdGlsc1wiKTtcclxuLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgQ29tcG9zZWQgQ2hhcnRcclxuICovXHJcblxyXG52YXIgQ29tcG9zZWRDaGFydCA9IGV4cG9ydHMuQ29tcG9zZWRDaGFydCA9ICgwLCBfZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0LmdlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCkoe1xyXG4gIGNoYXJ0TmFtZTogJ0NvbXBvc2VkQ2hhcnQnLFxyXG4gIEdyYXBoaWNhbENoaWxkOiBbX0xpbmUuTGluZSwgX0FyZWEuQXJlYSwgX0Jhci5CYXIsIF9TY2F0dGVyLlNjYXR0ZXJdLFxyXG4gIGF4aXNDb21wb25lbnRzOiBbe1xyXG4gICAgYXhpc1R5cGU6ICd4QXhpcycsXHJcbiAgICBBeGlzQ29tcDogX1hBeGlzLlhBeGlzXHJcbiAgfSwge1xyXG4gICAgYXhpc1R5cGU6ICd5QXhpcycsXHJcbiAgICBBeGlzQ29tcDogX1lBeGlzLllBeGlzXHJcbiAgfSwge1xyXG4gICAgYXhpc1R5cGU6ICd6QXhpcycsXHJcbiAgICBBeGlzQ29tcDogX1pBeGlzLlpBeGlzXHJcbiAgfV0sXHJcbiAgZm9ybWF0QXhpc01hcDogX0NhcnRlc2lhblV0aWxzLmZvcm1hdEF4aXNNYXBcclxufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ29tcG9zZWRDaGFydCIsIl9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQiLCJyZXF1aXJlIiwiX0FyZWEiLCJfQmFyIiwiX0xpbmUiLCJfU2NhdHRlciIsIl9YQXhpcyIsIl9ZQXhpcyIsIl9aQXhpcyIsIl9DYXJ0ZXNpYW5VdGlscyIsImdlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCIsImNoYXJ0TmFtZSIsIkdyYXBoaWNhbENoaWxkIiwiTGluZSIsIkFyZWEiLCJCYXIiLCJTY2F0dGVyIiwiYXhpc0NvbXBvbmVudHMiLCJheGlzVHlwZSIsIkF4aXNDb21wIiwiWEF4aXMiLCJZQXhpcyIsIlpBeGlzIiwiZm9ybWF0QXhpc01hcCJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/chart/ComposedChart.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/chart/FunnelChart.js":
/*!********************************************************!*\
  !*** ./node_modules/recharts/lib/chart/FunnelChart.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FunnelChart = void 0;\nvar _generateCategoricalChart = __webpack_require__(/*! ./generateCategoricalChart */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/generateCategoricalChart.js\");\nvar _Funnel = __webpack_require__(/*! ../numberAxis/Funnel */ \"(pages-dir-node)/./node_modules/recharts/lib/numberAxis/Funnel.js\");\n/**\r\n * @fileOverview Funnel Chart\r\n */ var FunnelChart = exports.FunnelChart = (0, _generateCategoricalChart.generateCategoricalChart)({\n    chartName: 'FunnelChart',\n    GraphicalChild: _Funnel.Funnel,\n    validateTooltipEventTypes: [\n        'item'\n    ],\n    defaultTooltipEventType: 'item',\n    axisComponents: [],\n    defaultProps: {\n        layout: 'centric'\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvRnVubmVsQ2hhcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELG1CQUFtQixHQUFHLEtBQUs7QUFDM0IsSUFBSUcsNEJBQTRCQyxtQkFBT0EsQ0FBQyxrSEFBNEI7QUFDcEUsSUFBSUMsVUFBVUQsbUJBQU9BLENBQUMsK0ZBQXNCO0FBQzVDOztDQUVDLEdBRUQsSUFBSUYsY0FBY0YsbUJBQW1CLEdBQUcsQ0FBQyxHQUFHRywwQkFBMEJHLHdCQUF3QixFQUFFO0lBQzlGQyxXQUFXO0lBQ1hDLGdCQUFnQkgsUUFBUUksTUFBTTtJQUM5QkMsMkJBQTJCO1FBQUM7S0FBTztJQUNuQ0MseUJBQXlCO0lBQ3pCQyxnQkFBZ0IsRUFBRTtJQUNsQkMsY0FBYztRQUNaQyxRQUFRO0lBQ1Y7QUFDRiIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcY2hhcnRcXEZ1bm5lbENoYXJ0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuRnVubmVsQ2hhcnQgPSB2b2lkIDA7XHJcbnZhciBfZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0ID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0XCIpO1xyXG52YXIgX0Z1bm5lbCA9IHJlcXVpcmUoXCIuLi9udW1iZXJBeGlzL0Z1bm5lbFwiKTtcclxuLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgRnVubmVsIENoYXJ0XHJcbiAqL1xyXG5cclxudmFyIEZ1bm5lbENoYXJ0ID0gZXhwb3J0cy5GdW5uZWxDaGFydCA9ICgwLCBfZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0LmdlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCkoe1xyXG4gIGNoYXJ0TmFtZTogJ0Z1bm5lbENoYXJ0JyxcclxuICBHcmFwaGljYWxDaGlsZDogX0Z1bm5lbC5GdW5uZWwsXHJcbiAgdmFsaWRhdGVUb29sdGlwRXZlbnRUeXBlczogWydpdGVtJ10sXHJcbiAgZGVmYXVsdFRvb2x0aXBFdmVudFR5cGU6ICdpdGVtJyxcclxuICBheGlzQ29tcG9uZW50czogW10sXHJcbiAgZGVmYXVsdFByb3BzOiB7XHJcbiAgICBsYXlvdXQ6ICdjZW50cmljJ1xyXG4gIH1cclxufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRnVubmVsQ2hhcnQiLCJfZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0IiwicmVxdWlyZSIsIl9GdW5uZWwiLCJnZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQiLCJjaGFydE5hbWUiLCJHcmFwaGljYWxDaGlsZCIsIkZ1bm5lbCIsInZhbGlkYXRlVG9vbHRpcEV2ZW50VHlwZXMiLCJkZWZhdWx0VG9vbHRpcEV2ZW50VHlwZSIsImF4aXNDb21wb25lbnRzIiwiZGVmYXVsdFByb3BzIiwibGF5b3V0Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/chart/FunnelChart.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/chart/LineChart.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/chart/LineChart.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LineChart = void 0;\nvar _generateCategoricalChart = __webpack_require__(/*! ./generateCategoricalChart */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/generateCategoricalChart.js\");\nvar _Line = __webpack_require__(/*! ../cartesian/Line */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/Line.js\");\nvar _XAxis = __webpack_require__(/*! ../cartesian/XAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/XAxis.js\");\nvar _YAxis = __webpack_require__(/*! ../cartesian/YAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/YAxis.js\");\nvar _CartesianUtils = __webpack_require__(/*! ../util/CartesianUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/CartesianUtils.js\");\n/**\r\n * @fileOverview Line Chart\r\n */ var LineChart = exports.LineChart = (0, _generateCategoricalChart.generateCategoricalChart)({\n    chartName: 'LineChart',\n    GraphicalChild: _Line.Line,\n    axisComponents: [\n        {\n            axisType: 'xAxis',\n            AxisComp: _XAxis.XAxis\n        },\n        {\n            axisType: 'yAxis',\n            AxisComp: _YAxis.YAxis\n        }\n    ],\n    formatAxisMap: _CartesianUtils.formatAxisMap\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvTGluZUNoYXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLElBQUlHLDRCQUE0QkMsbUJBQU9BLENBQUMsa0hBQTRCO0FBQ3BFLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDLHlGQUFtQjtBQUN2QyxJQUFJRSxTQUFTRixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDekMsSUFBSUcsU0FBU0gsbUJBQU9BLENBQUMsMkZBQW9CO0FBQ3pDLElBQUlJLGtCQUFrQkosbUJBQU9BLENBQUMsbUdBQXdCO0FBQ3REOztDQUVDLEdBRUQsSUFBSUYsWUFBWUYsaUJBQWlCLEdBQUcsQ0FBQyxHQUFHRywwQkFBMEJNLHdCQUF3QixFQUFFO0lBQzFGQyxXQUFXO0lBQ1hDLGdCQUFnQk4sTUFBTU8sSUFBSTtJQUMxQkMsZ0JBQWdCO1FBQUM7WUFDZkMsVUFBVTtZQUNWQyxVQUFVVCxPQUFPVSxLQUFLO1FBQ3hCO1FBQUc7WUFDREYsVUFBVTtZQUNWQyxVQUFVUixPQUFPVSxLQUFLO1FBQ3hCO0tBQUU7SUFDRkMsZUFBZVYsZ0JBQWdCVSxhQUFhO0FBQzlDIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxjaGFydFxcTGluZUNoYXJ0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuTGluZUNoYXJ0ID0gdm9pZCAwO1xyXG52YXIgX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydFwiKTtcclxudmFyIF9MaW5lID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9MaW5lXCIpO1xyXG52YXIgX1hBeGlzID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9YQXhpc1wiKTtcclxudmFyIF9ZQXhpcyA9IHJlcXVpcmUoXCIuLi9jYXJ0ZXNpYW4vWUF4aXNcIik7XHJcbnZhciBfQ2FydGVzaWFuVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9DYXJ0ZXNpYW5VdGlsc1wiKTtcclxuLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgTGluZSBDaGFydFxyXG4gKi9cclxuXHJcbnZhciBMaW5lQ2hhcnQgPSBleHBvcnRzLkxpbmVDaGFydCA9ICgwLCBfZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0LmdlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCkoe1xyXG4gIGNoYXJ0TmFtZTogJ0xpbmVDaGFydCcsXHJcbiAgR3JhcGhpY2FsQ2hpbGQ6IF9MaW5lLkxpbmUsXHJcbiAgYXhpc0NvbXBvbmVudHM6IFt7XHJcbiAgICBheGlzVHlwZTogJ3hBeGlzJyxcclxuICAgIEF4aXNDb21wOiBfWEF4aXMuWEF4aXNcclxuICB9LCB7XHJcbiAgICBheGlzVHlwZTogJ3lBeGlzJyxcclxuICAgIEF4aXNDb21wOiBfWUF4aXMuWUF4aXNcclxuICB9XSxcclxuICBmb3JtYXRBeGlzTWFwOiBfQ2FydGVzaWFuVXRpbHMuZm9ybWF0QXhpc01hcFxyXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJMaW5lQ2hhcnQiLCJfZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0IiwicmVxdWlyZSIsIl9MaW5lIiwiX1hBeGlzIiwiX1lBeGlzIiwiX0NhcnRlc2lhblV0aWxzIiwiZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0IiwiY2hhcnROYW1lIiwiR3JhcGhpY2FsQ2hpbGQiLCJMaW5lIiwiYXhpc0NvbXBvbmVudHMiLCJheGlzVHlwZSIsIkF4aXNDb21wIiwiWEF4aXMiLCJZQXhpcyIsImZvcm1hdEF4aXNNYXAiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/chart/LineChart.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/chart/PieChart.js":
/*!*****************************************************!*\
  !*** ./node_modules/recharts/lib/chart/PieChart.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PieChart = void 0;\nvar _generateCategoricalChart = __webpack_require__(/*! ./generateCategoricalChart */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/generateCategoricalChart.js\");\nvar _PolarAngleAxis = __webpack_require__(/*! ../polar/PolarAngleAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/polar/PolarAngleAxis.js\");\nvar _PolarRadiusAxis = __webpack_require__(/*! ../polar/PolarRadiusAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/polar/PolarRadiusAxis.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _Pie = __webpack_require__(/*! ../polar/Pie */ \"(pages-dir-node)/./node_modules/recharts/lib/polar/Pie.js\");\n/**\r\n * @fileOverview Pie Chart\r\n */ var PieChart = exports.PieChart = (0, _generateCategoricalChart.generateCategoricalChart)({\n    chartName: 'PieChart',\n    GraphicalChild: _Pie.Pie,\n    validateTooltipEventTypes: [\n        'item'\n    ],\n    defaultTooltipEventType: 'item',\n    legendContent: 'children',\n    axisComponents: [\n        {\n            axisType: 'angleAxis',\n            AxisComp: _PolarAngleAxis.PolarAngleAxis\n        },\n        {\n            axisType: 'radiusAxis',\n            AxisComp: _PolarRadiusAxis.PolarRadiusAxis\n        }\n    ],\n    formatAxisMap: _PolarUtils.formatAxisMap,\n    defaultProps: {\n        layout: 'centric',\n        startAngle: 0,\n        endAngle: 360,\n        cx: '50%',\n        cy: '50%',\n        innerRadius: 0,\n        outerRadius: '80%'\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvUGllQ2hhcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGdCQUFnQixHQUFHLEtBQUs7QUFDeEIsSUFBSUcsNEJBQTRCQyxtQkFBT0EsQ0FBQyxrSEFBNEI7QUFDcEUsSUFBSUMsa0JBQWtCRCxtQkFBT0EsQ0FBQyxxR0FBeUI7QUFDdkQsSUFBSUUsbUJBQW1CRixtQkFBT0EsQ0FBQyx1R0FBMEI7QUFDekQsSUFBSUcsY0FBY0gsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlJLE9BQU9KLG1CQUFPQSxDQUFDLCtFQUFjO0FBQ2pDOztDQUVDLEdBRUQsSUFBSUYsV0FBV0YsZ0JBQWdCLEdBQUcsQ0FBQyxHQUFHRywwQkFBMEJNLHdCQUF3QixFQUFFO0lBQ3hGQyxXQUFXO0lBQ1hDLGdCQUFnQkgsS0FBS0ksR0FBRztJQUN4QkMsMkJBQTJCO1FBQUM7S0FBTztJQUNuQ0MseUJBQXlCO0lBQ3pCQyxlQUFlO0lBQ2ZDLGdCQUFnQjtRQUFDO1lBQ2ZDLFVBQVU7WUFDVkMsVUFBVWIsZ0JBQWdCYyxjQUFjO1FBQzFDO1FBQUc7WUFDREYsVUFBVTtZQUNWQyxVQUFVWixpQkFBaUJjLGVBQWU7UUFDNUM7S0FBRTtJQUNGQyxlQUFlZCxZQUFZYyxhQUFhO0lBQ3hDQyxjQUFjO1FBQ1pDLFFBQVE7UUFDUkMsWUFBWTtRQUNaQyxVQUFVO1FBQ1ZDLElBQUk7UUFDSkMsSUFBSTtRQUNKQyxhQUFhO1FBQ2JDLGFBQWE7SUFDZjtBQUNGIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxjaGFydFxcUGllQ2hhcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5QaWVDaGFydCA9IHZvaWQgMDtcclxudmFyIF9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnRcIik7XHJcbnZhciBfUG9sYXJBbmdsZUF4aXMgPSByZXF1aXJlKFwiLi4vcG9sYXIvUG9sYXJBbmdsZUF4aXNcIik7XHJcbnZhciBfUG9sYXJSYWRpdXNBeGlzID0gcmVxdWlyZShcIi4uL3BvbGFyL1BvbGFyUmFkaXVzQXhpc1wiKTtcclxudmFyIF9Qb2xhclV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUG9sYXJVdGlsc1wiKTtcclxudmFyIF9QaWUgPSByZXF1aXJlKFwiLi4vcG9sYXIvUGllXCIpO1xyXG4vKipcclxuICogQGZpbGVPdmVydmlldyBQaWUgQ2hhcnRcclxuICovXHJcblxyXG52YXIgUGllQ2hhcnQgPSBleHBvcnRzLlBpZUNoYXJ0ID0gKDAsIF9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQuZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0KSh7XHJcbiAgY2hhcnROYW1lOiAnUGllQ2hhcnQnLFxyXG4gIEdyYXBoaWNhbENoaWxkOiBfUGllLlBpZSxcclxuICB2YWxpZGF0ZVRvb2x0aXBFdmVudFR5cGVzOiBbJ2l0ZW0nXSxcclxuICBkZWZhdWx0VG9vbHRpcEV2ZW50VHlwZTogJ2l0ZW0nLFxyXG4gIGxlZ2VuZENvbnRlbnQ6ICdjaGlsZHJlbicsXHJcbiAgYXhpc0NvbXBvbmVudHM6IFt7XHJcbiAgICBheGlzVHlwZTogJ2FuZ2xlQXhpcycsXHJcbiAgICBBeGlzQ29tcDogX1BvbGFyQW5nbGVBeGlzLlBvbGFyQW5nbGVBeGlzXHJcbiAgfSwge1xyXG4gICAgYXhpc1R5cGU6ICdyYWRpdXNBeGlzJyxcclxuICAgIEF4aXNDb21wOiBfUG9sYXJSYWRpdXNBeGlzLlBvbGFyUmFkaXVzQXhpc1xyXG4gIH1dLFxyXG4gIGZvcm1hdEF4aXNNYXA6IF9Qb2xhclV0aWxzLmZvcm1hdEF4aXNNYXAsXHJcbiAgZGVmYXVsdFByb3BzOiB7XHJcbiAgICBsYXlvdXQ6ICdjZW50cmljJyxcclxuICAgIHN0YXJ0QW5nbGU6IDAsXHJcbiAgICBlbmRBbmdsZTogMzYwLFxyXG4gICAgY3g6ICc1MCUnLFxyXG4gICAgY3k6ICc1MCUnLFxyXG4gICAgaW5uZXJSYWRpdXM6IDAsXHJcbiAgICBvdXRlclJhZGl1czogJzgwJSdcclxuICB9XHJcbn0pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlBpZUNoYXJ0IiwiX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCIsInJlcXVpcmUiLCJfUG9sYXJBbmdsZUF4aXMiLCJfUG9sYXJSYWRpdXNBeGlzIiwiX1BvbGFyVXRpbHMiLCJfUGllIiwiZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0IiwiY2hhcnROYW1lIiwiR3JhcGhpY2FsQ2hpbGQiLCJQaWUiLCJ2YWxpZGF0ZVRvb2x0aXBFdmVudFR5cGVzIiwiZGVmYXVsdFRvb2x0aXBFdmVudFR5cGUiLCJsZWdlbmRDb250ZW50IiwiYXhpc0NvbXBvbmVudHMiLCJheGlzVHlwZSIsIkF4aXNDb21wIiwiUG9sYXJBbmdsZUF4aXMiLCJQb2xhclJhZGl1c0F4aXMiLCJmb3JtYXRBeGlzTWFwIiwiZGVmYXVsdFByb3BzIiwibGF5b3V0Iiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiY3giLCJjeSIsImlubmVyUmFkaXVzIiwib3V0ZXJSYWRpdXMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/chart/PieChart.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/chart/RadarChart.js":
/*!*******************************************************!*\
  !*** ./node_modules/recharts/lib/chart/RadarChart.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RadarChart = void 0;\nvar _generateCategoricalChart = __webpack_require__(/*! ./generateCategoricalChart */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/generateCategoricalChart.js\");\nvar _Radar = __webpack_require__(/*! ../polar/Radar */ \"(pages-dir-node)/./node_modules/recharts/lib/polar/Radar.js\");\nvar _PolarAngleAxis = __webpack_require__(/*! ../polar/PolarAngleAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/polar/PolarAngleAxis.js\");\nvar _PolarRadiusAxis = __webpack_require__(/*! ../polar/PolarRadiusAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/polar/PolarRadiusAxis.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/PolarUtils.js\");\n/**\r\n * @fileOverview Radar Chart\r\n */ var RadarChart = exports.RadarChart = (0, _generateCategoricalChart.generateCategoricalChart)({\n    chartName: 'RadarChart',\n    GraphicalChild: _Radar.Radar,\n    axisComponents: [\n        {\n            axisType: 'angleAxis',\n            AxisComp: _PolarAngleAxis.PolarAngleAxis\n        },\n        {\n            axisType: 'radiusAxis',\n            AxisComp: _PolarRadiusAxis.PolarRadiusAxis\n        }\n    ],\n    formatAxisMap: _PolarUtils.formatAxisMap,\n    defaultProps: {\n        layout: 'centric',\n        startAngle: 90,\n        endAngle: -270,\n        cx: '50%',\n        cy: '50%',\n        innerRadius: 0,\n        outerRadius: '80%'\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvUmFkYXJDaGFydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsa0JBQWtCLEdBQUcsS0FBSztBQUMxQixJQUFJRyw0QkFBNEJDLG1CQUFPQSxDQUFDLGtIQUE0QjtBQUNwRSxJQUFJQyxTQUFTRCxtQkFBT0EsQ0FBQyxtRkFBZ0I7QUFDckMsSUFBSUUsa0JBQWtCRixtQkFBT0EsQ0FBQyxxR0FBeUI7QUFDdkQsSUFBSUcsbUJBQW1CSCxtQkFBT0EsQ0FBQyx1R0FBMEI7QUFDekQsSUFBSUksY0FBY0osbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDOztDQUVDLEdBRUQsSUFBSUYsYUFBYUYsa0JBQWtCLEdBQUcsQ0FBQyxHQUFHRywwQkFBMEJNLHdCQUF3QixFQUFFO0lBQzVGQyxXQUFXO0lBQ1hDLGdCQUFnQk4sT0FBT08sS0FBSztJQUM1QkMsZ0JBQWdCO1FBQUM7WUFDZkMsVUFBVTtZQUNWQyxVQUFVVCxnQkFBZ0JVLGNBQWM7UUFDMUM7UUFBRztZQUNERixVQUFVO1lBQ1ZDLFVBQVVSLGlCQUFpQlUsZUFBZTtRQUM1QztLQUFFO0lBQ0ZDLGVBQWVWLFlBQVlVLGFBQWE7SUFDeENDLGNBQWM7UUFDWkMsUUFBUTtRQUNSQyxZQUFZO1FBQ1pDLFVBQVUsQ0FBQztRQUNYQyxJQUFJO1FBQ0pDLElBQUk7UUFDSkMsYUFBYTtRQUNiQyxhQUFhO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcY2hhcnRcXFJhZGFyQ2hhcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5SYWRhckNoYXJ0ID0gdm9pZCAwO1xyXG52YXIgX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydFwiKTtcclxudmFyIF9SYWRhciA9IHJlcXVpcmUoXCIuLi9wb2xhci9SYWRhclwiKTtcclxudmFyIF9Qb2xhckFuZ2xlQXhpcyA9IHJlcXVpcmUoXCIuLi9wb2xhci9Qb2xhckFuZ2xlQXhpc1wiKTtcclxudmFyIF9Qb2xhclJhZGl1c0F4aXMgPSByZXF1aXJlKFwiLi4vcG9sYXIvUG9sYXJSYWRpdXNBeGlzXCIpO1xyXG52YXIgX1BvbGFyVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9Qb2xhclV0aWxzXCIpO1xyXG4vKipcclxuICogQGZpbGVPdmVydmlldyBSYWRhciBDaGFydFxyXG4gKi9cclxuXHJcbnZhciBSYWRhckNoYXJ0ID0gZXhwb3J0cy5SYWRhckNoYXJ0ID0gKDAsIF9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQuZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0KSh7XHJcbiAgY2hhcnROYW1lOiAnUmFkYXJDaGFydCcsXHJcbiAgR3JhcGhpY2FsQ2hpbGQ6IF9SYWRhci5SYWRhcixcclxuICBheGlzQ29tcG9uZW50czogW3tcclxuICAgIGF4aXNUeXBlOiAnYW5nbGVBeGlzJyxcclxuICAgIEF4aXNDb21wOiBfUG9sYXJBbmdsZUF4aXMuUG9sYXJBbmdsZUF4aXNcclxuICB9LCB7XHJcbiAgICBheGlzVHlwZTogJ3JhZGl1c0F4aXMnLFxyXG4gICAgQXhpc0NvbXA6IF9Qb2xhclJhZGl1c0F4aXMuUG9sYXJSYWRpdXNBeGlzXHJcbiAgfV0sXHJcbiAgZm9ybWF0QXhpc01hcDogX1BvbGFyVXRpbHMuZm9ybWF0QXhpc01hcCxcclxuICBkZWZhdWx0UHJvcHM6IHtcclxuICAgIGxheW91dDogJ2NlbnRyaWMnLFxyXG4gICAgc3RhcnRBbmdsZTogOTAsXHJcbiAgICBlbmRBbmdsZTogLTI3MCxcclxuICAgIGN4OiAnNTAlJyxcclxuICAgIGN5OiAnNTAlJyxcclxuICAgIGlubmVyUmFkaXVzOiAwLFxyXG4gICAgb3V0ZXJSYWRpdXM6ICc4MCUnXHJcbiAgfVxyXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSYWRhckNoYXJ0IiwiX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCIsInJlcXVpcmUiLCJfUmFkYXIiLCJfUG9sYXJBbmdsZUF4aXMiLCJfUG9sYXJSYWRpdXNBeGlzIiwiX1BvbGFyVXRpbHMiLCJnZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQiLCJjaGFydE5hbWUiLCJHcmFwaGljYWxDaGlsZCIsIlJhZGFyIiwiYXhpc0NvbXBvbmVudHMiLCJheGlzVHlwZSIsIkF4aXNDb21wIiwiUG9sYXJBbmdsZUF4aXMiLCJQb2xhclJhZGl1c0F4aXMiLCJmb3JtYXRBeGlzTWFwIiwiZGVmYXVsdFByb3BzIiwibGF5b3V0Iiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiY3giLCJjeSIsImlubmVyUmFkaXVzIiwib3V0ZXJSYWRpdXMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/chart/RadarChart.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/chart/RadialBarChart.js":
/*!***********************************************************!*\
  !*** ./node_modules/recharts/lib/chart/RadialBarChart.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RadialBarChart = void 0;\nvar _generateCategoricalChart = __webpack_require__(/*! ./generateCategoricalChart */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/generateCategoricalChart.js\");\nvar _PolarAngleAxis = __webpack_require__(/*! ../polar/PolarAngleAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/polar/PolarAngleAxis.js\");\nvar _PolarRadiusAxis = __webpack_require__(/*! ../polar/PolarRadiusAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/polar/PolarRadiusAxis.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _RadialBar = __webpack_require__(/*! ../polar/RadialBar */ \"(pages-dir-node)/./node_modules/recharts/lib/polar/RadialBar.js\");\n/**\r\n * @fileOverview Radar Bar Chart\r\n */ var RadialBarChart = exports.RadialBarChart = (0, _generateCategoricalChart.generateCategoricalChart)({\n    chartName: 'RadialBarChart',\n    GraphicalChild: _RadialBar.RadialBar,\n    legendContent: 'children',\n    defaultTooltipEventType: 'axis',\n    validateTooltipEventTypes: [\n        'axis',\n        'item'\n    ],\n    axisComponents: [\n        {\n            axisType: 'angleAxis',\n            AxisComp: _PolarAngleAxis.PolarAngleAxis\n        },\n        {\n            axisType: 'radiusAxis',\n            AxisComp: _PolarRadiusAxis.PolarRadiusAxis\n        }\n    ],\n    formatAxisMap: _PolarUtils.formatAxisMap,\n    defaultProps: {\n        layout: 'radial',\n        startAngle: 0,\n        endAngle: 360,\n        cx: '50%',\n        cy: '50%',\n        innerRadius: 0,\n        outerRadius: '80%'\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvUmFkaWFsQmFyQ2hhcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELHNCQUFzQixHQUFHLEtBQUs7QUFDOUIsSUFBSUcsNEJBQTRCQyxtQkFBT0EsQ0FBQyxrSEFBNEI7QUFDcEUsSUFBSUMsa0JBQWtCRCxtQkFBT0EsQ0FBQyxxR0FBeUI7QUFDdkQsSUFBSUUsbUJBQW1CRixtQkFBT0EsQ0FBQyx1R0FBMEI7QUFDekQsSUFBSUcsY0FBY0gsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlJLGFBQWFKLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM3Qzs7Q0FFQyxHQUVELElBQUlGLGlCQUFpQkYsc0JBQXNCLEdBQUcsQ0FBQyxHQUFHRywwQkFBMEJNLHdCQUF3QixFQUFFO0lBQ3BHQyxXQUFXO0lBQ1hDLGdCQUFnQkgsV0FBV0ksU0FBUztJQUNwQ0MsZUFBZTtJQUNmQyx5QkFBeUI7SUFDekJDLDJCQUEyQjtRQUFDO1FBQVE7S0FBTztJQUMzQ0MsZ0JBQWdCO1FBQUM7WUFDZkMsVUFBVTtZQUNWQyxVQUFVYixnQkFBZ0JjLGNBQWM7UUFDMUM7UUFBRztZQUNERixVQUFVO1lBQ1ZDLFVBQVVaLGlCQUFpQmMsZUFBZTtRQUM1QztLQUFFO0lBQ0ZDLGVBQWVkLFlBQVljLGFBQWE7SUFDeENDLGNBQWM7UUFDWkMsUUFBUTtRQUNSQyxZQUFZO1FBQ1pDLFVBQVU7UUFDVkMsSUFBSTtRQUNKQyxJQUFJO1FBQ0pDLGFBQWE7UUFDYkMsYUFBYTtJQUNmO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXGNoYXJ0XFxSYWRpYWxCYXJDaGFydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLlJhZGlhbEJhckNoYXJ0ID0gdm9pZCAwO1xyXG52YXIgX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydFwiKTtcclxudmFyIF9Qb2xhckFuZ2xlQXhpcyA9IHJlcXVpcmUoXCIuLi9wb2xhci9Qb2xhckFuZ2xlQXhpc1wiKTtcclxudmFyIF9Qb2xhclJhZGl1c0F4aXMgPSByZXF1aXJlKFwiLi4vcG9sYXIvUG9sYXJSYWRpdXNBeGlzXCIpO1xyXG52YXIgX1BvbGFyVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9Qb2xhclV0aWxzXCIpO1xyXG52YXIgX1JhZGlhbEJhciA9IHJlcXVpcmUoXCIuLi9wb2xhci9SYWRpYWxCYXJcIik7XHJcbi8qKlxyXG4gKiBAZmlsZU92ZXJ2aWV3IFJhZGFyIEJhciBDaGFydFxyXG4gKi9cclxuXHJcbnZhciBSYWRpYWxCYXJDaGFydCA9IGV4cG9ydHMuUmFkaWFsQmFyQ2hhcnQgPSAoMCwgX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydC5nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQpKHtcclxuICBjaGFydE5hbWU6ICdSYWRpYWxCYXJDaGFydCcsXHJcbiAgR3JhcGhpY2FsQ2hpbGQ6IF9SYWRpYWxCYXIuUmFkaWFsQmFyLFxyXG4gIGxlZ2VuZENvbnRlbnQ6ICdjaGlsZHJlbicsXHJcbiAgZGVmYXVsdFRvb2x0aXBFdmVudFR5cGU6ICdheGlzJyxcclxuICB2YWxpZGF0ZVRvb2x0aXBFdmVudFR5cGVzOiBbJ2F4aXMnLCAnaXRlbSddLFxyXG4gIGF4aXNDb21wb25lbnRzOiBbe1xyXG4gICAgYXhpc1R5cGU6ICdhbmdsZUF4aXMnLFxyXG4gICAgQXhpc0NvbXA6IF9Qb2xhckFuZ2xlQXhpcy5Qb2xhckFuZ2xlQXhpc1xyXG4gIH0sIHtcclxuICAgIGF4aXNUeXBlOiAncmFkaXVzQXhpcycsXHJcbiAgICBBeGlzQ29tcDogX1BvbGFyUmFkaXVzQXhpcy5Qb2xhclJhZGl1c0F4aXNcclxuICB9XSxcclxuICBmb3JtYXRBeGlzTWFwOiBfUG9sYXJVdGlscy5mb3JtYXRBeGlzTWFwLFxyXG4gIGRlZmF1bHRQcm9wczoge1xyXG4gICAgbGF5b3V0OiAncmFkaWFsJyxcclxuICAgIHN0YXJ0QW5nbGU6IDAsXHJcbiAgICBlbmRBbmdsZTogMzYwLFxyXG4gICAgY3g6ICc1MCUnLFxyXG4gICAgY3k6ICc1MCUnLFxyXG4gICAgaW5uZXJSYWRpdXM6IDAsXHJcbiAgICBvdXRlclJhZGl1czogJzgwJSdcclxuICB9XHJcbn0pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlJhZGlhbEJhckNoYXJ0IiwiX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCIsInJlcXVpcmUiLCJfUG9sYXJBbmdsZUF4aXMiLCJfUG9sYXJSYWRpdXNBeGlzIiwiX1BvbGFyVXRpbHMiLCJfUmFkaWFsQmFyIiwiZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0IiwiY2hhcnROYW1lIiwiR3JhcGhpY2FsQ2hpbGQiLCJSYWRpYWxCYXIiLCJsZWdlbmRDb250ZW50IiwiZGVmYXVsdFRvb2x0aXBFdmVudFR5cGUiLCJ2YWxpZGF0ZVRvb2x0aXBFdmVudFR5cGVzIiwiYXhpc0NvbXBvbmVudHMiLCJheGlzVHlwZSIsIkF4aXNDb21wIiwiUG9sYXJBbmdsZUF4aXMiLCJQb2xhclJhZGl1c0F4aXMiLCJmb3JtYXRBeGlzTWFwIiwiZGVmYXVsdFByb3BzIiwibGF5b3V0Iiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiY3giLCJjeSIsImlubmVyUmFkaXVzIiwib3V0ZXJSYWRpdXMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/chart/RadialBarChart.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/chart/Sankey.js":
/*!***************************************************!*\
  !*** ./node_modules/recharts/lib/chart/Sankey.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Sankey = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _maxBy = _interopRequireDefault(__webpack_require__(/*! lodash/maxBy */ \"lodash/maxBy\"));\nvar _min = _interopRequireDefault(__webpack_require__(/*! lodash/min */ \"lodash/min\"));\nvar _get = _interopRequireDefault(__webpack_require__(/*! lodash/get */ \"lodash/get\"));\nvar _sumBy = _interopRequireDefault(__webpack_require__(/*! lodash/sumBy */ \"lodash/sumBy\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _Surface = __webpack_require__(/*! ../container/Surface */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Surface.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _Tooltip = __webpack_require__(/*! ../component/Tooltip */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Tooltip.js\");\nvar _Rectangle = __webpack_require__(/*! ../shape/Rectangle */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Rectangle.js\");\nvar _ShallowEqual = __webpack_require__(/*! ../util/ShallowEqual */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ShallowEqual.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _excluded = [\n    \"width\",\n    \"height\",\n    \"className\",\n    \"style\",\n    \"children\"\n], _excluded2 = [\n    \"sourceX\",\n    \"sourceY\",\n    \"sourceControlX\",\n    \"targetX\",\n    \"targetY\",\n    \"targetControlX\",\n    \"linkWidth\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @file TreemapChart\r\n */ \nvar defaultCoordinateOfTooltip = {\n    x: 0,\n    y: 0\n};\nvar interpolationGenerator = function interpolationGenerator(a, b) {\n    var ka = +a;\n    var kb = b - ka;\n    return function(t) {\n        return ka + kb * t;\n    };\n};\nvar centerY = function centerY(node) {\n    return node.y + node.dy / 2;\n};\nvar getValue = function getValue(entry) {\n    return entry && entry.value || 0;\n};\nvar getSumOfIds = function getSumOfIds(links, ids) {\n    return ids.reduce(function(result, id) {\n        return result + getValue(links[id]);\n    }, 0);\n};\nvar getSumWithWeightedSource = function getSumWithWeightedSource(tree, links, ids) {\n    return ids.reduce(function(result, id) {\n        var link = links[id];\n        var sourceNode = tree[link.source];\n        return result + centerY(sourceNode) * getValue(links[id]);\n    }, 0);\n};\nvar getSumWithWeightedTarget = function getSumWithWeightedTarget(tree, links, ids) {\n    return ids.reduce(function(result, id) {\n        var link = links[id];\n        var targetNode = tree[link.target];\n        return result + centerY(targetNode) * getValue(links[id]);\n    }, 0);\n};\nvar ascendingY = function ascendingY(a, b) {\n    return a.y - b.y;\n};\nvar searchTargetsAndSources = function searchTargetsAndSources(links, id) {\n    var sourceNodes = [];\n    var sourceLinks = [];\n    var targetNodes = [];\n    var targetLinks = [];\n    for(var i = 0, len = links.length; i < len; i++){\n        var link = links[i];\n        if (link.source === id) {\n            targetNodes.push(link.target);\n            targetLinks.push(i);\n        }\n        if (link.target === id) {\n            sourceNodes.push(link.source);\n            sourceLinks.push(i);\n        }\n    }\n    return {\n        sourceNodes: sourceNodes,\n        sourceLinks: sourceLinks,\n        targetLinks: targetLinks,\n        targetNodes: targetNodes\n    };\n};\nvar updateDepthOfTargets = function updateDepthOfTargets(tree, curNode) {\n    var targetNodes = curNode.targetNodes;\n    for(var i = 0, len = targetNodes.length; i < len; i++){\n        var target = tree[targetNodes[i]];\n        if (target) {\n            target.depth = Math.max(curNode.depth + 1, target.depth);\n            updateDepthOfTargets(tree, target);\n        }\n    }\n};\nvar getNodesTree = function getNodesTree(_ref, width, nodeWidth) {\n    var nodes = _ref.nodes, links = _ref.links;\n    var tree = nodes.map(function(entry, index) {\n        var result = searchTargetsAndSources(links, index);\n        return _objectSpread(_objectSpread(_objectSpread({}, entry), result), {}, {\n            value: Math.max(getSumOfIds(links, result.sourceLinks), getSumOfIds(links, result.targetLinks)),\n            depth: 0\n        });\n    });\n    for(var i = 0, len = tree.length; i < len; i++){\n        var node = tree[i];\n        if (!node.sourceNodes.length) {\n            updateDepthOfTargets(tree, node);\n        }\n    }\n    var maxDepth = (0, _maxBy[\"default\"])(tree, function(entry) {\n        return entry.depth;\n    }).depth;\n    if (maxDepth >= 1) {\n        var childWidth = (width - nodeWidth) / maxDepth;\n        for(var _i = 0, _len = tree.length; _i < _len; _i++){\n            var _node = tree[_i];\n            if (!_node.targetNodes.length) {\n                _node.depth = maxDepth;\n            }\n            _node.x = _node.depth * childWidth;\n            _node.dx = nodeWidth;\n        }\n    }\n    return {\n        tree: tree,\n        maxDepth: maxDepth\n    };\n};\nvar getDepthTree = function getDepthTree(tree) {\n    var result = [];\n    for(var i = 0, len = tree.length; i < len; i++){\n        var node = tree[i];\n        if (!result[node.depth]) {\n            result[node.depth] = [];\n        }\n        result[node.depth].push(node);\n    }\n    return result;\n};\nvar updateYOfTree = function updateYOfTree(depthTree, height, nodePadding, links) {\n    var yRatio = (0, _min[\"default\"])(depthTree.map(function(nodes) {\n        return (height - (nodes.length - 1) * nodePadding) / (0, _sumBy[\"default\"])(nodes, getValue);\n    }));\n    for(var d = 0, maxDepth = depthTree.length; d < maxDepth; d++){\n        for(var i = 0, len = depthTree[d].length; i < len; i++){\n            var node = depthTree[d][i];\n            node.y = i;\n            node.dy = node.value * yRatio;\n        }\n    }\n    return links.map(function(link) {\n        return _objectSpread(_objectSpread({}, link), {}, {\n            dy: getValue(link) * yRatio\n        });\n    });\n};\nvar resolveCollisions = function resolveCollisions(depthTree, height, nodePadding) {\n    var sort = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    for(var i = 0, len = depthTree.length; i < len; i++){\n        var nodes = depthTree[i];\n        var n = nodes.length;\n        // Sort by the value of y\n        if (sort) {\n            nodes.sort(ascendingY);\n        }\n        var y0 = 0;\n        for(var j = 0; j < n; j++){\n            var node = nodes[j];\n            var dy = y0 - node.y;\n            if (dy > 0) {\n                node.y += dy;\n            }\n            y0 = node.y + node.dy + nodePadding;\n        }\n        y0 = height + nodePadding;\n        for(var _j = n - 1; _j >= 0; _j--){\n            var _node2 = nodes[_j];\n            var _dy = _node2.y + _node2.dy + nodePadding - y0;\n            if (_dy > 0) {\n                _node2.y -= _dy;\n                y0 = _node2.y;\n            } else {\n                break;\n            }\n        }\n    }\n};\nvar relaxLeftToRight = function relaxLeftToRight(tree, depthTree, links, alpha) {\n    for(var i = 0, maxDepth = depthTree.length; i < maxDepth; i++){\n        var nodes = depthTree[i];\n        for(var j = 0, len = nodes.length; j < len; j++){\n            var node = nodes[j];\n            if (node.sourceLinks.length) {\n                var sourceSum = getSumOfIds(links, node.sourceLinks);\n                var weightedSum = getSumWithWeightedSource(tree, links, node.sourceLinks);\n                var y = weightedSum / sourceSum;\n                node.y += (y - centerY(node)) * alpha;\n            }\n        }\n    }\n};\nvar relaxRightToLeft = function relaxRightToLeft(tree, depthTree, links, alpha) {\n    for(var i = depthTree.length - 1; i >= 0; i--){\n        var nodes = depthTree[i];\n        for(var j = 0, len = nodes.length; j < len; j++){\n            var node = nodes[j];\n            if (node.targetLinks.length) {\n                var targetSum = getSumOfIds(links, node.targetLinks);\n                var weightedSum = getSumWithWeightedTarget(tree, links, node.targetLinks);\n                var y = weightedSum / targetSum;\n                node.y += (y - centerY(node)) * alpha;\n            }\n        }\n    }\n};\nvar updateYOfLinks = function updateYOfLinks(tree, links) {\n    for(var i = 0, len = tree.length; i < len; i++){\n        var node = tree[i];\n        var sy = 0;\n        var ty = 0;\n        node.targetLinks.sort(function(a, b) {\n            return tree[links[a].target].y - tree[links[b].target].y;\n        });\n        node.sourceLinks.sort(function(a, b) {\n            return tree[links[a].source].y - tree[links[b].source].y;\n        });\n        for(var j = 0, tLen = node.targetLinks.length; j < tLen; j++){\n            var link = links[node.targetLinks[j]];\n            if (link) {\n                link.sy = sy;\n                sy += link.dy;\n            }\n        }\n        for(var _j2 = 0, sLen = node.sourceLinks.length; _j2 < sLen; _j2++){\n            var _link = links[node.sourceLinks[_j2]];\n            if (_link) {\n                _link.ty = ty;\n                ty += _link.dy;\n            }\n        }\n    }\n};\nvar computeData = function computeData(_ref2) {\n    var data = _ref2.data, width = _ref2.width, height = _ref2.height, iterations = _ref2.iterations, nodeWidth = _ref2.nodeWidth, nodePadding = _ref2.nodePadding, sort = _ref2.sort;\n    var links = data.links;\n    var _getNodesTree = getNodesTree(data, width, nodeWidth), tree = _getNodesTree.tree;\n    var depthTree = getDepthTree(tree);\n    var newLinks = updateYOfTree(depthTree, height, nodePadding, links);\n    resolveCollisions(depthTree, height, nodePadding, sort);\n    var alpha = 1;\n    for(var i = 1; i <= iterations; i++){\n        relaxRightToLeft(tree, depthTree, newLinks, alpha *= 0.99);\n        resolveCollisions(depthTree, height, nodePadding, sort);\n        relaxLeftToRight(tree, depthTree, newLinks, alpha);\n        resolveCollisions(depthTree, height, nodePadding, sort);\n    }\n    updateYOfLinks(tree, newLinks);\n    return {\n        nodes: tree,\n        links: newLinks\n    };\n};\nvar getCoordinateOfTooltip = function getCoordinateOfTooltip(el, type) {\n    if (type === 'node') {\n        return {\n            x: el.x + el.width / 2,\n            y: el.y + el.height / 2\n        };\n    }\n    return {\n        x: (el.sourceX + el.targetX) / 2,\n        y: (el.sourceY + el.targetY) / 2\n    };\n};\nvar getPayloadOfTooltip = function getPayloadOfTooltip(el, type, nameKey) {\n    var payload = el.payload;\n    if (type === 'node') {\n        return [\n            {\n                payload: el,\n                name: (0, _ChartUtils.getValueByDataKey)(payload, nameKey, ''),\n                value: (0, _ChartUtils.getValueByDataKey)(payload, 'value')\n            }\n        ];\n    }\n    if (payload.source && payload.target) {\n        var sourceName = (0, _ChartUtils.getValueByDataKey)(payload.source, nameKey, '');\n        var targetName = (0, _ChartUtils.getValueByDataKey)(payload.target, nameKey, '');\n        return [\n            {\n                payload: el,\n                name: \"\".concat(sourceName, \" - \").concat(targetName),\n                value: (0, _ChartUtils.getValueByDataKey)(payload, 'value')\n            }\n        ];\n    }\n    return [];\n};\nvar Sankey = exports.Sankey = /*#__PURE__*/ function(_PureComponent) {\n    function Sankey() {\n        var _this;\n        _classCallCheck(this, Sankey);\n        for(var _len2 = arguments.length, args = new Array(_len2), _key = 0; _key < _len2; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, Sankey, [].concat(args));\n        _defineProperty(_this, \"state\", {\n            activeElement: null,\n            activeElementType: null,\n            isTooltipActive: false,\n            nodes: [],\n            links: []\n        });\n        return _this;\n    }\n    _inherits(Sankey, _PureComponent);\n    return _createClass(Sankey, [\n        {\n            key: \"handleMouseEnter\",\n            value: function handleMouseEnter(el, type, e) {\n                var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, children = _this$props.children;\n                var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                if (tooltipItem) {\n                    this.setState(function(prev) {\n                        if (tooltipItem.props.trigger === 'hover') {\n                            return _objectSpread(_objectSpread({}, prev), {}, {\n                                activeElement: el,\n                                activeElementType: type,\n                                isTooltipActive: true\n                            });\n                        }\n                        return prev;\n                    }, function() {\n                        if (onMouseEnter) {\n                            onMouseEnter(el, type, e);\n                        }\n                    });\n                } else if (onMouseEnter) {\n                    onMouseEnter(el, type, e);\n                }\n            }\n        },\n        {\n            key: \"handleMouseLeave\",\n            value: function handleMouseLeave(el, type, e) {\n                var _this$props2 = this.props, onMouseLeave = _this$props2.onMouseLeave, children = _this$props2.children;\n                var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                if (tooltipItem) {\n                    this.setState(function(prev) {\n                        if (tooltipItem.props.trigger === 'hover') {\n                            return _objectSpread(_objectSpread({}, prev), {}, {\n                                activeElement: undefined,\n                                activeElementType: undefined,\n                                isTooltipActive: false\n                            });\n                        }\n                        return prev;\n                    }, function() {\n                        if (onMouseLeave) {\n                            onMouseLeave(el, type, e);\n                        }\n                    });\n                } else if (onMouseLeave) {\n                    onMouseLeave(el, type, e);\n                }\n            }\n        },\n        {\n            key: \"handleClick\",\n            value: function handleClick(el, type, e) {\n                var _this$props3 = this.props, onClick = _this$props3.onClick, children = _this$props3.children;\n                var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                if (tooltipItem && tooltipItem.props.trigger === 'click') {\n                    if (this.state.isTooltipActive) {\n                        this.setState(function(prev) {\n                            return _objectSpread(_objectSpread({}, prev), {}, {\n                                activeElement: undefined,\n                                activeElementType: undefined,\n                                isTooltipActive: false\n                            });\n                        });\n                    } else {\n                        this.setState(function(prev) {\n                            return _objectSpread(_objectSpread({}, prev), {}, {\n                                activeElement: el,\n                                activeElementType: type,\n                                isTooltipActive: true\n                            });\n                        });\n                    }\n                }\n                if (onClick) onClick(el, type, e);\n            }\n        },\n        {\n            key: \"renderLinks\",\n            value: function renderLinks(links, nodes) {\n                var _this2 = this;\n                var _this$props4 = this.props, linkCurvature = _this$props4.linkCurvature, linkContent = _this$props4.link, margin = _this$props4.margin;\n                var top = (0, _get[\"default\"])(margin, 'top') || 0;\n                var left = (0, _get[\"default\"])(margin, 'left') || 0;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-sankey-links\",\n                    key: \"recharts-sankey-links\"\n                }, links.map(function(link, i) {\n                    var sourceRelativeY = link.sy, targetRelativeY = link.ty, linkWidth = link.dy;\n                    var source = nodes[link.source];\n                    var target = nodes[link.target];\n                    var sourceX = source.x + source.dx + left;\n                    var targetX = target.x + left;\n                    var interpolationFunc = interpolationGenerator(sourceX, targetX);\n                    var sourceControlX = interpolationFunc(linkCurvature);\n                    var targetControlX = interpolationFunc(1 - linkCurvature);\n                    var sourceY = source.y + sourceRelativeY + linkWidth / 2 + top;\n                    var targetY = target.y + targetRelativeY + linkWidth / 2 + top;\n                    var linkProps = _objectSpread({\n                        sourceX: sourceX,\n                        targetX: targetX,\n                        sourceY: sourceY,\n                        targetY: targetY,\n                        sourceControlX: sourceControlX,\n                        targetControlX: targetControlX,\n                        sourceRelativeY: sourceRelativeY,\n                        targetRelativeY: targetRelativeY,\n                        linkWidth: linkWidth,\n                        index: i,\n                        payload: _objectSpread(_objectSpread({}, link), {}, {\n                            source: source,\n                            target: target\n                        })\n                    }, (0, _ReactUtils.filterProps)(linkContent, false));\n                    var events = {\n                        onMouseEnter: _this2.handleMouseEnter.bind(_this2, linkProps, 'link'),\n                        onMouseLeave: _this2.handleMouseLeave.bind(_this2, linkProps, 'link'),\n                        onClick: _this2.handleClick.bind(_this2, linkProps, 'link')\n                    };\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                        key: \"link-\".concat(link.source, \"-\").concat(link.target, \"-\").concat(link.value)\n                    }, events), _this2.constructor.renderLinkItem(linkContent, linkProps));\n                }));\n            }\n        },\n        {\n            key: \"renderNodes\",\n            value: function renderNodes(nodes) {\n                var _this3 = this;\n                var _this$props5 = this.props, nodeContent = _this$props5.node, margin = _this$props5.margin;\n                var top = (0, _get[\"default\"])(margin, 'top') || 0;\n                var left = (0, _get[\"default\"])(margin, 'left') || 0;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-sankey-nodes\",\n                    key: \"recharts-sankey-nodes\"\n                }, nodes.map(function(node, i) {\n                    var x = node.x, y = node.y, dx = node.dx, dy = node.dy;\n                    var nodeProps = _objectSpread(_objectSpread({}, (0, _ReactUtils.filterProps)(nodeContent, false)), {}, {\n                        x: x + left,\n                        y: y + top,\n                        width: dx,\n                        height: dy,\n                        index: i,\n                        payload: node\n                    });\n                    var events = {\n                        onMouseEnter: _this3.handleMouseEnter.bind(_this3, nodeProps, 'node'),\n                        onMouseLeave: _this3.handleMouseLeave.bind(_this3, nodeProps, 'node'),\n                        onClick: _this3.handleClick.bind(_this3, nodeProps, 'node')\n                    };\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                        key: \"node-\".concat(node.x, \"-\").concat(node.y, \"-\").concat(node.value)\n                    }, events), _this3.constructor.renderNodeItem(nodeContent, nodeProps));\n                }));\n            }\n        },\n        {\n            key: \"renderTooltip\",\n            value: function renderTooltip() {\n                var _this$props6 = this.props, children = _this$props6.children, width = _this$props6.width, height = _this$props6.height, nameKey = _this$props6.nameKey;\n                var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                if (!tooltipItem) {\n                    return null;\n                }\n                var _this$state = this.state, isTooltipActive = _this$state.isTooltipActive, activeElement = _this$state.activeElement, activeElementType = _this$state.activeElementType;\n                var viewBox = {\n                    x: 0,\n                    y: 0,\n                    width: width,\n                    height: height\n                };\n                var coordinate = activeElement ? getCoordinateOfTooltip(activeElement, activeElementType) : defaultCoordinateOfTooltip;\n                var payload = activeElement ? getPayloadOfTooltip(activeElement, activeElementType, nameKey) : [];\n                return /*#__PURE__*/ _react[\"default\"].cloneElement(tooltipItem, {\n                    viewBox: viewBox,\n                    active: isTooltipActive,\n                    coordinate: coordinate,\n                    label: '',\n                    payload: payload\n                });\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                if (!(0, _ReactUtils.validateWidthHeight)(this)) {\n                    return null;\n                }\n                var _this$props7 = this.props, width = _this$props7.width, height = _this$props7.height, className = _this$props7.className, style = _this$props7.style, children = _this$props7.children, others = _objectWithoutProperties(_this$props7, _excluded);\n                var _this$state2 = this.state, links = _this$state2.links, nodes = _this$state2.nodes;\n                var attrs = (0, _ReactUtils.filterProps)(others, false);\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n                    className: (0, _clsx[\"default\"])('recharts-wrapper', className),\n                    style: _objectSpread(_objectSpread({}, style), {}, {\n                        position: 'relative',\n                        cursor: 'default',\n                        width: width,\n                        height: height\n                    }),\n                    role: \"region\"\n                }, /*#__PURE__*/ _react[\"default\"].createElement(_Surface.Surface, _extends({}, attrs, {\n                    width: width,\n                    height: height\n                }), (0, _ReactUtils.filterSvgElements)(children), this.renderLinks(links, nodes), this.renderNodes(nodes)), this.renderTooltip());\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                var data = nextProps.data, width = nextProps.width, height = nextProps.height, margin = nextProps.margin, iterations = nextProps.iterations, nodeWidth = nextProps.nodeWidth, nodePadding = nextProps.nodePadding, sort = nextProps.sort;\n                if (data !== prevState.prevData || width !== prevState.prevWidth || height !== prevState.prevHeight || !(0, _ShallowEqual.shallowEqual)(margin, prevState.prevMargin) || iterations !== prevState.prevIterations || nodeWidth !== prevState.prevNodeWidth || nodePadding !== prevState.prevNodePadding || sort !== prevState.sort) {\n                    var contentWidth = width - (margin && margin.left || 0) - (margin && margin.right || 0);\n                    var contentHeight = height - (margin && margin.top || 0) - (margin && margin.bottom || 0);\n                    var _computeData = computeData({\n                        data: data,\n                        width: contentWidth,\n                        height: contentHeight,\n                        iterations: iterations,\n                        nodeWidth: nodeWidth,\n                        nodePadding: nodePadding,\n                        sort: sort\n                    }), links = _computeData.links, nodes = _computeData.nodes;\n                    return _objectSpread(_objectSpread({}, prevState), {}, {\n                        nodes: nodes,\n                        links: links,\n                        prevData: data,\n                        prevWidth: iterations,\n                        prevHeight: height,\n                        prevMargin: margin,\n                        prevNodePadding: nodePadding,\n                        prevNodeWidth: nodeWidth,\n                        prevIterations: iterations,\n                        prevSort: sort\n                    });\n                }\n                return null;\n            }\n        },\n        {\n            key: \"renderLinkItem\",\n            value: function renderLinkItem(option, props) {\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n                    return /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n                }\n                if ((0, _isFunction[\"default\"])(option)) {\n                    return option(props);\n                }\n                var sourceX = props.sourceX, sourceY = props.sourceY, sourceControlX = props.sourceControlX, targetX = props.targetX, targetY = props.targetY, targetControlX = props.targetControlX, linkWidth = props.linkWidth, others = _objectWithoutProperties(props, _excluded2);\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({\n                    className: \"recharts-sankey-link\",\n                    d: \"\\n          M\".concat(sourceX, \",\").concat(sourceY, \"\\n          C\").concat(sourceControlX, \",\").concat(sourceY, \" \").concat(targetControlX, \",\").concat(targetY, \" \").concat(targetX, \",\").concat(targetY, \"\\n        \"),\n                    fill: \"none\",\n                    stroke: \"#333\",\n                    strokeWidth: linkWidth,\n                    strokeOpacity: \"0.2\"\n                }, (0, _ReactUtils.filterProps)(others, false)));\n            }\n        },\n        {\n            key: \"renderNodeItem\",\n            value: function renderNodeItem(option, props) {\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n                    return /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n                }\n                if ((0, _isFunction[\"default\"])(option)) {\n                    return option(props);\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Rectangle.Rectangle, _extends({\n                    className: \"recharts-sankey-node\",\n                    fill: \"#0088fe\",\n                    fillOpacity: \"0.8\"\n                }, (0, _ReactUtils.filterProps)(props, false), {\n                    role: \"img\"\n                }));\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(Sankey, \"displayName\", 'Sankey');\n_defineProperty(Sankey, \"defaultProps\", {\n    nameKey: 'name',\n    dataKey: 'value',\n    nodePadding: 10,\n    nodeWidth: 10,\n    linkCurvature: 0.5,\n    iterations: 32,\n    margin: {\n        top: 5,\n        right: 5,\n        bottom: 5,\n        left: 5\n    },\n    sort: true\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvU2Fua2V5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxjQUFjLEdBQUcsS0FBSztBQUN0QixJQUFJRyxTQUFTQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3BELElBQUlDLFNBQVNDLHVCQUF1QkYsbUJBQU9BLENBQUMsa0NBQWM7QUFDMUQsSUFBSUcsT0FBT0QsdUJBQXVCRixtQkFBT0EsQ0FBQyw4QkFBWTtBQUN0RCxJQUFJSSxPQUFPRix1QkFBdUJGLG1CQUFPQSxDQUFDLDhCQUFZO0FBQ3RELElBQUlLLFNBQVNILHVCQUF1QkYsbUJBQU9BLENBQUMsa0NBQWM7QUFDMUQsSUFBSU0sY0FBY0osdUJBQXVCRixtQkFBT0EsQ0FBQyw0Q0FBbUI7QUFDcEUsSUFBSU8sUUFBUUwsdUJBQXVCRixtQkFBT0EsQ0FBQyx1QkFBTTtBQUNqRCxJQUFJUSxXQUFXUixtQkFBT0EsQ0FBQywrRkFBc0I7QUFDN0MsSUFBSVMsU0FBU1QsbUJBQU9BLENBQUMsMkZBQW9CO0FBQ3pDLElBQUlVLFdBQVdWLG1CQUFPQSxDQUFDLCtGQUFzQjtBQUM3QyxJQUFJVyxhQUFhWCxtQkFBT0EsQ0FBQywyRkFBb0I7QUFDN0MsSUFBSVksZ0JBQWdCWixtQkFBT0EsQ0FBQywrRkFBc0I7QUFDbEQsSUFBSWEsY0FBY2IsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUljLGNBQWNkLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM5QyxJQUFJZSxZQUFZO0lBQUM7SUFBUztJQUFVO0lBQWE7SUFBUztDQUFXLEVBQ25FQyxhQUFhO0lBQUM7SUFBVztJQUFXO0lBQWtCO0lBQVc7SUFBVztJQUFrQjtDQUFZO0FBQzVHLFNBQVNkLHVCQUF1QmUsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFF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LGVBQWU7Z0JBQ2pCLEdBQUcsQ0FBQyxHQUFHMVIsWUFBWXVPLFdBQVcsRUFBRXFCLFFBQVE7WUFDMUM7UUFDRjtRQUFHO1lBQ0Q1TixLQUFLO1lBQ0xqRCxPQUFPLFNBQVNnUSxlQUFlc0MsTUFBTSxFQUFFck8sS0FBSztnQkFDMUMsSUFBSyxXQUFXLEdBQUUvRCxNQUFNLENBQUMsVUFBVSxDQUFDcVMsY0FBYyxDQUFDRCxTQUFTO29CQUMxRCxPQUFPLFdBQVcsR0FBRXBTLE1BQU0sQ0FBQyxVQUFVLENBQUNvUSxZQUFZLENBQUNnQyxRQUFRck87Z0JBQzdEO2dCQUNBLElBQUksQ0FBQyxHQUFHdkQsV0FBVyxDQUFDLFVBQVUsRUFBRTRSLFNBQVM7b0JBQ3ZDLE9BQU9BLE9BQU9yTztnQkFDaEI7Z0JBQ0EsT0FBTyxXQUFXLEdBQUUvRCxNQUFNLENBQUMsVUFBVSxDQUFDNE8sYUFBYSxDQUFDL04sV0FBVzZSLFNBQVMsRUFBRXJQLFNBQVM7b0JBQ2pGeUwsV0FBVztvQkFDWHdELE1BQU07b0JBQ05LLGFBQWE7Z0JBQ2YsR0FBRyxDQUFDLEdBQUc1UixZQUFZdU8sV0FBVyxFQUFFdkwsT0FBTyxRQUFRO29CQUM3Q2lOLE1BQU07Z0JBQ1I7WUFDRjtRQUNGO0tBQUU7QUFDSixFQUFFaFIsT0FBTzRTLGFBQWE7QUFDdEIzTSxnQkFBZ0JsRyxRQUFRLGVBQWU7QUFDdkNrRyxnQkFBZ0JsRyxRQUFRLGdCQUFnQjtJQUN0Q29NLFNBQVM7SUFDVDBHLFNBQVM7SUFDVGhKLGFBQWE7SUFDYmQsV0FBVztJQUNYd0YsZUFBZTtJQUNmL0MsWUFBWTtJQUNaaUQsUUFBUTtRQUNOQyxLQUFLO1FBQ0xxRCxPQUFPO1FBQ1BFLFFBQVE7UUFDUnRELE1BQU07SUFDUjtJQUNBMUUsTUFBTTtBQUNSIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxjaGFydFxcU2Fua2V5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuU2Fua2V5ID0gdm9pZCAwO1xyXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIF9tYXhCeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9tYXhCeVwiKSk7XHJcbnZhciBfbWluID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL21pblwiKSk7XHJcbnZhciBfZ2V0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2dldFwiKSk7XHJcbnZhciBfc3VtQnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvc3VtQnlcIikpO1xyXG52YXIgX2lzRnVuY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XHJcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xyXG52YXIgX1N1cmZhY2UgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL1N1cmZhY2VcIik7XHJcbnZhciBfTGF5ZXIgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL0xheWVyXCIpO1xyXG52YXIgX1Rvb2x0aXAgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50L1Rvb2x0aXBcIik7XHJcbnZhciBfUmVjdGFuZ2xlID0gcmVxdWlyZShcIi4uL3NoYXBlL1JlY3RhbmdsZVwiKTtcclxudmFyIF9TaGFsbG93RXF1YWwgPSByZXF1aXJlKFwiLi4vdXRpbC9TaGFsbG93RXF1YWxcIik7XHJcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XHJcbnZhciBfQ2hhcnRVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NoYXJ0VXRpbHNcIik7XHJcbnZhciBfZXhjbHVkZWQgPSBbXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcImNsYXNzTmFtZVwiLCBcInN0eWxlXCIsIFwiY2hpbGRyZW5cIl0sXHJcbiAgX2V4Y2x1ZGVkMiA9IFtcInNvdXJjZVhcIiwgXCJzb3VyY2VZXCIsIFwic291cmNlQ29udHJvbFhcIiwgXCJ0YXJnZXRYXCIsIFwidGFyZ2V0WVwiLCBcInRhcmdldENvbnRyb2xYXCIsIFwibGlua1dpZHRoXCJdO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XHJcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxyXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxyXG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxyXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cclxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XHJcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxyXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxyXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxyXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxyXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XHJcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxyXG4gKiBAZmlsZSBUcmVlbWFwQ2hhcnRcclxuICovXHJcbnZhciBkZWZhdWx0Q29vcmRpbmF0ZU9mVG9vbHRpcCA9IHtcclxuICB4OiAwLFxyXG4gIHk6IDBcclxufTtcclxudmFyIGludGVycG9sYXRpb25HZW5lcmF0b3IgPSBmdW5jdGlvbiBpbnRlcnBvbGF0aW9uR2VuZXJhdG9yKGEsIGIpIHtcclxuICB2YXIga2EgPSArYTtcclxuICB2YXIga2IgPSBiIC0ga2E7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XHJcbiAgICByZXR1cm4ga2EgKyBrYiAqIHQ7XHJcbiAgfTtcclxufTtcclxudmFyIGNlbnRlclkgPSBmdW5jdGlvbiBjZW50ZXJZKG5vZGUpIHtcclxuICByZXR1cm4gbm9kZS55ICsgbm9kZS5keSAvIDI7XHJcbn07XHJcbnZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKGVudHJ5KSB7XHJcbiAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnZhbHVlIHx8IDA7XHJcbn07XHJcbnZhciBnZXRTdW1PZklkcyA9IGZ1bmN0aW9uIGdldFN1bU9mSWRzKGxpbmtzLCBpZHMpIHtcclxuICByZXR1cm4gaWRzLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBpZCkge1xyXG4gICAgcmV0dXJuIHJlc3VsdCArIGdldFZhbHVlKGxpbmtzW2lkXSk7XHJcbiAgfSwgMCk7XHJcbn07XHJcbnZhciBnZXRTdW1XaXRoV2VpZ2h0ZWRTb3VyY2UgPSBmdW5jdGlvbiBnZXRTdW1XaXRoV2VpZ2h0ZWRTb3VyY2UodHJlZSwgbGlua3MsIGlkcykge1xyXG4gIHJldHVybiBpZHMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGlkKSB7XHJcbiAgICB2YXIgbGluayA9IGxpbmtzW2lkXTtcclxuICAgIHZhciBzb3VyY2VOb2RlID0gdHJlZVtsaW5rLnNvdXJjZV07XHJcbiAgICByZXR1cm4gcmVzdWx0ICsgY2VudGVyWShzb3VyY2VOb2RlKSAqIGdldFZhbHVlKGxpbmtzW2lkXSk7XHJcbiAgfSwgMCk7XHJcbn07XHJcbnZhciBnZXRTdW1XaXRoV2VpZ2h0ZWRUYXJnZXQgPSBmdW5jdGlvbiBnZXRTdW1XaXRoV2VpZ2h0ZWRUYXJnZXQodHJlZSwgbGlua3MsIGlkcykge1xyXG4gIHJldHVybiBpZHMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGlkKSB7XHJcbiAgICB2YXIgbGluayA9IGxpbmtzW2lkXTtcclxuICAgIHZhciB0YXJnZXROb2RlID0gdHJlZVtsaW5rLnRhcmdldF07XHJcbiAgICByZXR1cm4gcmVzdWx0ICsgY2VudGVyWSh0YXJnZXROb2RlKSAqIGdldFZhbHVlKGxpbmtzW2lkXSk7XHJcbiAgfSwgMCk7XHJcbn07XHJcbnZhciBhc2NlbmRpbmdZID0gZnVuY3Rpb24gYXNjZW5kaW5nWShhLCBiKSB7XHJcbiAgcmV0dXJuIGEueSAtIGIueTtcclxufTtcclxudmFyIHNlYXJjaFRhcmdldHNBbmRTb3VyY2VzID0gZnVuY3Rpb24gc2VhcmNoVGFyZ2V0c0FuZFNvdXJjZXMobGlua3MsIGlkKSB7XHJcbiAgdmFyIHNvdXJjZU5vZGVzID0gW107XHJcbiAgdmFyIHNvdXJjZUxpbmtzID0gW107XHJcbiAgdmFyIHRhcmdldE5vZGVzID0gW107XHJcbiAgdmFyIHRhcmdldExpbmtzID0gW107XHJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmtzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICB2YXIgbGluayA9IGxpbmtzW2ldO1xyXG4gICAgaWYgKGxpbmsuc291cmNlID09PSBpZCkge1xyXG4gICAgICB0YXJnZXROb2Rlcy5wdXNoKGxpbmsudGFyZ2V0KTtcclxuICAgICAgdGFyZ2V0TGlua3MucHVzaChpKTtcclxuICAgIH1cclxuICAgIGlmIChsaW5rLnRhcmdldCA9PT0gaWQpIHtcclxuICAgICAgc291cmNlTm9kZXMucHVzaChsaW5rLnNvdXJjZSk7XHJcbiAgICAgIHNvdXJjZUxpbmtzLnB1c2goaSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICBzb3VyY2VOb2Rlczogc291cmNlTm9kZXMsXHJcbiAgICBzb3VyY2VMaW5rczogc291cmNlTGlua3MsXHJcbiAgICB0YXJnZXRMaW5rczogdGFyZ2V0TGlua3MsXHJcbiAgICB0YXJnZXROb2RlczogdGFyZ2V0Tm9kZXNcclxuICB9O1xyXG59O1xyXG52YXIgdXBkYXRlRGVwdGhPZlRhcmdldHMgPSBmdW5jdGlvbiB1cGRhdGVEZXB0aE9mVGFyZ2V0cyh0cmVlLCBjdXJOb2RlKSB7XHJcbiAgdmFyIHRhcmdldE5vZGVzID0gY3VyTm9kZS50YXJnZXROb2RlcztcclxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGFyZ2V0Tm9kZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIHZhciB0YXJnZXQgPSB0cmVlW3RhcmdldE5vZGVzW2ldXTtcclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgdGFyZ2V0LmRlcHRoID0gTWF0aC5tYXgoY3VyTm9kZS5kZXB0aCArIDEsIHRhcmdldC5kZXB0aCk7XHJcbiAgICAgIHVwZGF0ZURlcHRoT2ZUYXJnZXRzKHRyZWUsIHRhcmdldCk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG52YXIgZ2V0Tm9kZXNUcmVlID0gZnVuY3Rpb24gZ2V0Tm9kZXNUcmVlKF9yZWYsIHdpZHRoLCBub2RlV2lkdGgpIHtcclxuICB2YXIgbm9kZXMgPSBfcmVmLm5vZGVzLFxyXG4gICAgbGlua3MgPSBfcmVmLmxpbmtzO1xyXG4gIHZhciB0cmVlID0gbm9kZXMubWFwKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHtcclxuICAgIHZhciByZXN1bHQgPSBzZWFyY2hUYXJnZXRzQW5kU291cmNlcyhsaW5rcywgaW5kZXgpO1xyXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeSksIHJlc3VsdCksIHt9LCB7XHJcbiAgICAgIHZhbHVlOiBNYXRoLm1heChnZXRTdW1PZklkcyhsaW5rcywgcmVzdWx0LnNvdXJjZUxpbmtzKSwgZ2V0U3VtT2ZJZHMobGlua3MsIHJlc3VsdC50YXJnZXRMaW5rcykpLFxyXG4gICAgICBkZXB0aDogMFxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRyZWUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIHZhciBub2RlID0gdHJlZVtpXTtcclxuICAgIGlmICghbm9kZS5zb3VyY2VOb2Rlcy5sZW5ndGgpIHtcclxuICAgICAgdXBkYXRlRGVwdGhPZlRhcmdldHModHJlZSwgbm9kZSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHZhciBtYXhEZXB0aCA9ICgwLCBfbWF4QnlbXCJkZWZhdWx0XCJdKSh0cmVlLCBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgIHJldHVybiBlbnRyeS5kZXB0aDtcclxuICB9KS5kZXB0aDtcclxuICBpZiAobWF4RGVwdGggPj0gMSkge1xyXG4gICAgdmFyIGNoaWxkV2lkdGggPSAod2lkdGggLSBub2RlV2lkdGgpIC8gbWF4RGVwdGg7XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9sZW4gPSB0cmVlLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XHJcbiAgICAgIHZhciBfbm9kZSA9IHRyZWVbX2ldO1xyXG4gICAgICBpZiAoIV9ub2RlLnRhcmdldE5vZGVzLmxlbmd0aCkge1xyXG4gICAgICAgIF9ub2RlLmRlcHRoID0gbWF4RGVwdGg7XHJcbiAgICAgIH1cclxuICAgICAgX25vZGUueCA9IF9ub2RlLmRlcHRoICogY2hpbGRXaWR0aDtcclxuICAgICAgX25vZGUuZHggPSBub2RlV2lkdGg7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICB0cmVlOiB0cmVlLFxyXG4gICAgbWF4RGVwdGg6IG1heERlcHRoXHJcbiAgfTtcclxufTtcclxudmFyIGdldERlcHRoVHJlZSA9IGZ1bmN0aW9uIGdldERlcHRoVHJlZSh0cmVlKSB7XHJcbiAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0cmVlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICB2YXIgbm9kZSA9IHRyZWVbaV07XHJcbiAgICBpZiAoIXJlc3VsdFtub2RlLmRlcHRoXSkge1xyXG4gICAgICByZXN1bHRbbm9kZS5kZXB0aF0gPSBbXTtcclxuICAgIH1cclxuICAgIHJlc3VsdFtub2RlLmRlcHRoXS5wdXNoKG5vZGUpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG52YXIgdXBkYXRlWU9mVHJlZSA9IGZ1bmN0aW9uIHVwZGF0ZVlPZlRyZWUoZGVwdGhUcmVlLCBoZWlnaHQsIG5vZGVQYWRkaW5nLCBsaW5rcykge1xyXG4gIHZhciB5UmF0aW8gPSAoMCwgX21pbltcImRlZmF1bHRcIl0pKGRlcHRoVHJlZS5tYXAoZnVuY3Rpb24gKG5vZGVzKSB7XHJcbiAgICByZXR1cm4gKGhlaWdodCAtIChub2Rlcy5sZW5ndGggLSAxKSAqIG5vZGVQYWRkaW5nKSAvICgwLCBfc3VtQnlbXCJkZWZhdWx0XCJdKShub2RlcywgZ2V0VmFsdWUpO1xyXG4gIH0pKTtcclxuICBmb3IgKHZhciBkID0gMCwgbWF4RGVwdGggPSBkZXB0aFRyZWUubGVuZ3RoOyBkIDwgbWF4RGVwdGg7IGQrKykge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRlcHRoVHJlZVtkXS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICB2YXIgbm9kZSA9IGRlcHRoVHJlZVtkXVtpXTtcclxuICAgICAgbm9kZS55ID0gaTtcclxuICAgICAgbm9kZS5keSA9IG5vZGUudmFsdWUgKiB5UmF0aW87XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBsaW5rcy5tYXAoZnVuY3Rpb24gKGxpbmspIHtcclxuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGxpbmspLCB7fSwge1xyXG4gICAgICBkeTogZ2V0VmFsdWUobGluaykgKiB5UmF0aW9cclxuICAgIH0pO1xyXG4gIH0pO1xyXG59O1xyXG52YXIgcmVzb2x2ZUNvbGxpc2lvbnMgPSBmdW5jdGlvbiByZXNvbHZlQ29sbGlzaW9ucyhkZXB0aFRyZWUsIGhlaWdodCwgbm9kZVBhZGRpbmcpIHtcclxuICB2YXIgc29ydCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcclxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGVwdGhUcmVlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICB2YXIgbm9kZXMgPSBkZXB0aFRyZWVbaV07XHJcbiAgICB2YXIgbiA9IG5vZGVzLmxlbmd0aDtcclxuXHJcbiAgICAvLyBTb3J0IGJ5IHRoZSB2YWx1ZSBvZiB5XHJcbiAgICBpZiAoc29ydCkge1xyXG4gICAgICBub2Rlcy5zb3J0KGFzY2VuZGluZ1kpO1xyXG4gICAgfVxyXG4gICAgdmFyIHkwID0gMDtcclxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XHJcbiAgICAgIHZhciBub2RlID0gbm9kZXNbal07XHJcbiAgICAgIHZhciBkeSA9IHkwIC0gbm9kZS55O1xyXG4gICAgICBpZiAoZHkgPiAwKSB7XHJcbiAgICAgICAgbm9kZS55ICs9IGR5O1xyXG4gICAgICB9XHJcbiAgICAgIHkwID0gbm9kZS55ICsgbm9kZS5keSArIG5vZGVQYWRkaW5nO1xyXG4gICAgfVxyXG4gICAgeTAgPSBoZWlnaHQgKyBub2RlUGFkZGluZztcclxuICAgIGZvciAodmFyIF9qID0gbiAtIDE7IF9qID49IDA7IF9qLS0pIHtcclxuICAgICAgdmFyIF9ub2RlMiA9IG5vZGVzW19qXTtcclxuICAgICAgdmFyIF9keSA9IF9ub2RlMi55ICsgX25vZGUyLmR5ICsgbm9kZVBhZGRpbmcgLSB5MDtcclxuICAgICAgaWYgKF9keSA+IDApIHtcclxuICAgICAgICBfbm9kZTIueSAtPSBfZHk7XHJcbiAgICAgICAgeTAgPSBfbm9kZTIueTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxudmFyIHJlbGF4TGVmdFRvUmlnaHQgPSBmdW5jdGlvbiByZWxheExlZnRUb1JpZ2h0KHRyZWUsIGRlcHRoVHJlZSwgbGlua3MsIGFscGhhKSB7XHJcbiAgZm9yICh2YXIgaSA9IDAsIG1heERlcHRoID0gZGVwdGhUcmVlLmxlbmd0aDsgaSA8IG1heERlcHRoOyBpKyspIHtcclxuICAgIHZhciBub2RlcyA9IGRlcHRoVHJlZVtpXTtcclxuICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xyXG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2pdO1xyXG4gICAgICBpZiAobm9kZS5zb3VyY2VMaW5rcy5sZW5ndGgpIHtcclxuICAgICAgICB2YXIgc291cmNlU3VtID0gZ2V0U3VtT2ZJZHMobGlua3MsIG5vZGUuc291cmNlTGlua3MpO1xyXG4gICAgICAgIHZhciB3ZWlnaHRlZFN1bSA9IGdldFN1bVdpdGhXZWlnaHRlZFNvdXJjZSh0cmVlLCBsaW5rcywgbm9kZS5zb3VyY2VMaW5rcyk7XHJcbiAgICAgICAgdmFyIHkgPSB3ZWlnaHRlZFN1bSAvIHNvdXJjZVN1bTtcclxuICAgICAgICBub2RlLnkgKz0gKHkgLSBjZW50ZXJZKG5vZGUpKSAqIGFscGhhO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG52YXIgcmVsYXhSaWdodFRvTGVmdCA9IGZ1bmN0aW9uIHJlbGF4UmlnaHRUb0xlZnQodHJlZSwgZGVwdGhUcmVlLCBsaW5rcywgYWxwaGEpIHtcclxuICBmb3IgKHZhciBpID0gZGVwdGhUcmVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICB2YXIgbm9kZXMgPSBkZXB0aFRyZWVbaV07XHJcbiAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gbm9kZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tqXTtcclxuICAgICAgaWYgKG5vZGUudGFyZ2V0TGlua3MubGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIHRhcmdldFN1bSA9IGdldFN1bU9mSWRzKGxpbmtzLCBub2RlLnRhcmdldExpbmtzKTtcclxuICAgICAgICB2YXIgd2VpZ2h0ZWRTdW0gPSBnZXRTdW1XaXRoV2VpZ2h0ZWRUYXJnZXQodHJlZSwgbGlua3MsIG5vZGUudGFyZ2V0TGlua3MpO1xyXG4gICAgICAgIHZhciB5ID0gd2VpZ2h0ZWRTdW0gLyB0YXJnZXRTdW07XHJcbiAgICAgICAgbm9kZS55ICs9ICh5IC0gY2VudGVyWShub2RlKSkgKiBhbHBoYTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxudmFyIHVwZGF0ZVlPZkxpbmtzID0gZnVuY3Rpb24gdXBkYXRlWU9mTGlua3ModHJlZSwgbGlua3MpIHtcclxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdHJlZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgdmFyIG5vZGUgPSB0cmVlW2ldO1xyXG4gICAgdmFyIHN5ID0gMDtcclxuICAgIHZhciB0eSA9IDA7XHJcbiAgICBub2RlLnRhcmdldExpbmtzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgcmV0dXJuIHRyZWVbbGlua3NbYV0udGFyZ2V0XS55IC0gdHJlZVtsaW5rc1tiXS50YXJnZXRdLnk7XHJcbiAgICB9KTtcclxuICAgIG5vZGUuc291cmNlTGlua3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICByZXR1cm4gdHJlZVtsaW5rc1thXS5zb3VyY2VdLnkgLSB0cmVlW2xpbmtzW2JdLnNvdXJjZV0ueTtcclxuICAgIH0pO1xyXG4gICAgZm9yICh2YXIgaiA9IDAsIHRMZW4gPSBub2RlLnRhcmdldExpbmtzLmxlbmd0aDsgaiA8IHRMZW47IGorKykge1xyXG4gICAgICB2YXIgbGluayA9IGxpbmtzW25vZGUudGFyZ2V0TGlua3Nbal1dO1xyXG4gICAgICBpZiAobGluaykge1xyXG4gICAgICAgIGxpbmsuc3kgPSBzeTtcclxuICAgICAgICBzeSArPSBsaW5rLmR5O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBfajIgPSAwLCBzTGVuID0gbm9kZS5zb3VyY2VMaW5rcy5sZW5ndGg7IF9qMiA8IHNMZW47IF9qMisrKSB7XHJcbiAgICAgIHZhciBfbGluayA9IGxpbmtzW25vZGUuc291cmNlTGlua3NbX2oyXV07XHJcbiAgICAgIGlmIChfbGluaykge1xyXG4gICAgICAgIF9saW5rLnR5ID0gdHk7XHJcbiAgICAgICAgdHkgKz0gX2xpbmsuZHk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcbnZhciBjb21wdXRlRGF0YSA9IGZ1bmN0aW9uIGNvbXB1dGVEYXRhKF9yZWYyKSB7XHJcbiAgdmFyIGRhdGEgPSBfcmVmMi5kYXRhLFxyXG4gICAgd2lkdGggPSBfcmVmMi53aWR0aCxcclxuICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodCxcclxuICAgIGl0ZXJhdGlvbnMgPSBfcmVmMi5pdGVyYXRpb25zLFxyXG4gICAgbm9kZVdpZHRoID0gX3JlZjIubm9kZVdpZHRoLFxyXG4gICAgbm9kZVBhZGRpbmcgPSBfcmVmMi5ub2RlUGFkZGluZyxcclxuICAgIHNvcnQgPSBfcmVmMi5zb3J0O1xyXG4gIHZhciBsaW5rcyA9IGRhdGEubGlua3M7XHJcbiAgdmFyIF9nZXROb2Rlc1RyZWUgPSBnZXROb2Rlc1RyZWUoZGF0YSwgd2lkdGgsIG5vZGVXaWR0aCksXHJcbiAgICB0cmVlID0gX2dldE5vZGVzVHJlZS50cmVlO1xyXG4gIHZhciBkZXB0aFRyZWUgPSBnZXREZXB0aFRyZWUodHJlZSk7XHJcbiAgdmFyIG5ld0xpbmtzID0gdXBkYXRlWU9mVHJlZShkZXB0aFRyZWUsIGhlaWdodCwgbm9kZVBhZGRpbmcsIGxpbmtzKTtcclxuICByZXNvbHZlQ29sbGlzaW9ucyhkZXB0aFRyZWUsIGhlaWdodCwgbm9kZVBhZGRpbmcsIHNvcnQpO1xyXG4gIHZhciBhbHBoYSA9IDE7XHJcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gaXRlcmF0aW9uczsgaSsrKSB7XHJcbiAgICByZWxheFJpZ2h0VG9MZWZ0KHRyZWUsIGRlcHRoVHJlZSwgbmV3TGlua3MsIGFscGhhICo9IDAuOTkpO1xyXG4gICAgcmVzb2x2ZUNvbGxpc2lvbnMoZGVwdGhUcmVlLCBoZWlnaHQsIG5vZGVQYWRkaW5nLCBzb3J0KTtcclxuICAgIHJlbGF4TGVmdFRvUmlnaHQodHJlZSwgZGVwdGhUcmVlLCBuZXdMaW5rcywgYWxwaGEpO1xyXG4gICAgcmVzb2x2ZUNvbGxpc2lvbnMoZGVwdGhUcmVlLCBoZWlnaHQsIG5vZGVQYWRkaW5nLCBzb3J0KTtcclxuICB9XHJcbiAgdXBkYXRlWU9mTGlua3ModHJlZSwgbmV3TGlua3MpO1xyXG4gIHJldHVybiB7XHJcbiAgICBub2RlczogdHJlZSxcclxuICAgIGxpbmtzOiBuZXdMaW5rc1xyXG4gIH07XHJcbn07XHJcbnZhciBnZXRDb29yZGluYXRlT2ZUb29sdGlwID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZU9mVG9vbHRpcChlbCwgdHlwZSkge1xyXG4gIGlmICh0eXBlID09PSAnbm9kZScpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IGVsLnggKyBlbC53aWR0aCAvIDIsXHJcbiAgICAgIHk6IGVsLnkgKyBlbC5oZWlnaHQgLyAyXHJcbiAgICB9O1xyXG4gIH1cclxuICByZXR1cm4ge1xyXG4gICAgeDogKGVsLnNvdXJjZVggKyBlbC50YXJnZXRYKSAvIDIsXHJcbiAgICB5OiAoZWwuc291cmNlWSArIGVsLnRhcmdldFkpIC8gMlxyXG4gIH07XHJcbn07XHJcbnZhciBnZXRQYXlsb2FkT2ZUb29sdGlwID0gZnVuY3Rpb24gZ2V0UGF5bG9hZE9mVG9vbHRpcChlbCwgdHlwZSwgbmFtZUtleSkge1xyXG4gIHZhciBwYXlsb2FkID0gZWwucGF5bG9hZDtcclxuICBpZiAodHlwZSA9PT0gJ25vZGUnKSB7XHJcbiAgICByZXR1cm4gW3tcclxuICAgICAgcGF5bG9hZDogZWwsXHJcbiAgICAgIG5hbWU6ICgwLCBfQ2hhcnRVdGlscy5nZXRWYWx1ZUJ5RGF0YUtleSkocGF5bG9hZCwgbmFtZUtleSwgJycpLFxyXG4gICAgICB2YWx1ZTogKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShwYXlsb2FkLCAndmFsdWUnKVxyXG4gICAgfV07XHJcbiAgfVxyXG4gIGlmIChwYXlsb2FkLnNvdXJjZSAmJiBwYXlsb2FkLnRhcmdldCkge1xyXG4gICAgdmFyIHNvdXJjZU5hbWUgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0VmFsdWVCeURhdGFLZXkpKHBheWxvYWQuc291cmNlLCBuYW1lS2V5LCAnJyk7XHJcbiAgICB2YXIgdGFyZ2V0TmFtZSA9ICgwLCBfQ2hhcnRVdGlscy5nZXRWYWx1ZUJ5RGF0YUtleSkocGF5bG9hZC50YXJnZXQsIG5hbWVLZXksICcnKTtcclxuICAgIHJldHVybiBbe1xyXG4gICAgICBwYXlsb2FkOiBlbCxcclxuICAgICAgbmFtZTogXCJcIi5jb25jYXQoc291cmNlTmFtZSwgXCIgLSBcIikuY29uY2F0KHRhcmdldE5hbWUpLFxyXG4gICAgICB2YWx1ZTogKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShwYXlsb2FkLCAndmFsdWUnKVxyXG4gICAgfV07XHJcbiAgfVxyXG4gIHJldHVybiBbXTtcclxufTtcclxudmFyIFNhbmtleSA9IGV4cG9ydHMuU2Fua2V5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xyXG4gIGZ1bmN0aW9uIFNhbmtleSgpIHtcclxuICAgIHZhciBfdGhpcztcclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTYW5rZXkpO1xyXG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuMjsgX2tleSsrKSB7XHJcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgICB9XHJcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgU2Fua2V5LCBbXS5jb25jYXQoYXJncykpO1xyXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInN0YXRlXCIsIHtcclxuICAgICAgYWN0aXZlRWxlbWVudDogbnVsbCxcclxuICAgICAgYWN0aXZlRWxlbWVudFR5cGU6IG51bGwsXHJcbiAgICAgIGlzVG9vbHRpcEFjdGl2ZTogZmFsc2UsXHJcbiAgICAgIG5vZGVzOiBbXSxcclxuICAgICAgbGlua3M6IFtdXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcbiAgX2luaGVyaXRzKFNhbmtleSwgX1B1cmVDb21wb25lbnQpO1xyXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoU2Fua2V5LCBbe1xyXG4gICAga2V5OiBcImhhbmRsZU1vdXNlRW50ZXJcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVNb3VzZUVudGVyKGVsLCB0eXBlLCBlKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgb25Nb3VzZUVudGVyID0gX3RoaXMkcHJvcHMub25Nb3VzZUVudGVyLFxyXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW47XHJcbiAgICAgIHZhciB0b29sdGlwSXRlbSA9ICgwLCBfUmVhY3RVdGlscy5maW5kQ2hpbGRCeVR5cGUpKGNoaWxkcmVuLCBfVG9vbHRpcC5Ub29sdGlwKTtcclxuICAgICAgaWYgKHRvb2x0aXBJdGVtKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAocHJldikge1xyXG4gICAgICAgICAgaWYgKHRvb2x0aXBJdGVtLnByb3BzLnRyaWdnZXIgPT09ICdob3ZlcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJldiksIHt9LCB7XHJcbiAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudDogZWwsXHJcbiAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudFR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgICAgaXNUb29sdGlwQWN0aXZlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHByZXY7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgaWYgKG9uTW91c2VFbnRlcikge1xyXG4gICAgICAgICAgICBvbk1vdXNlRW50ZXIoZWwsIHR5cGUsIGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2UgaWYgKG9uTW91c2VFbnRlcikge1xyXG4gICAgICAgIG9uTW91c2VFbnRlcihlbCwgdHlwZSwgZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiaGFuZGxlTW91c2VMZWF2ZVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTGVhdmUoZWwsIHR5cGUsIGUpIHtcclxuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgb25Nb3VzZUxlYXZlID0gX3RoaXMkcHJvcHMyLm9uTW91c2VMZWF2ZSxcclxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzMi5jaGlsZHJlbjtcclxuICAgICAgdmFyIHRvb2x0aXBJdGVtID0gKDAsIF9SZWFjdFV0aWxzLmZpbmRDaGlsZEJ5VHlwZSkoY2hpbGRyZW4sIF9Ub29sdGlwLlRvb2x0aXApO1xyXG4gICAgICBpZiAodG9vbHRpcEl0ZW0pIHtcclxuICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChwcmV2KSB7XHJcbiAgICAgICAgICBpZiAodG9vbHRpcEl0ZW0ucHJvcHMudHJpZ2dlciA9PT0gJ2hvdmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcmV2KSwge30sIHtcclxuICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50OiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudFR5cGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICBpc1Rvb2x0aXBBY3RpdmU6IGZhbHNlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHByZXY7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgaWYgKG9uTW91c2VMZWF2ZSkge1xyXG4gICAgICAgICAgICBvbk1vdXNlTGVhdmUoZWwsIHR5cGUsIGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2UgaWYgKG9uTW91c2VMZWF2ZSkge1xyXG4gICAgICAgIG9uTW91c2VMZWF2ZShlbCwgdHlwZSwgZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiaGFuZGxlQ2xpY2tcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDbGljayhlbCwgdHlwZSwgZSkge1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBvbkNsaWNrID0gX3RoaXMkcHJvcHMzLm9uQ2xpY2ssXHJcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczMuY2hpbGRyZW47XHJcbiAgICAgIHZhciB0b29sdGlwSXRlbSA9ICgwLCBfUmVhY3RVdGlscy5maW5kQ2hpbGRCeVR5cGUpKGNoaWxkcmVuLCBfVG9vbHRpcC5Ub29sdGlwKTtcclxuICAgICAgaWYgKHRvb2x0aXBJdGVtICYmIHRvb2x0aXBJdGVtLnByb3BzLnRyaWdnZXIgPT09ICdjbGljaycpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5pc1Rvb2x0aXBBY3RpdmUpIHtcclxuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHByZXYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJldiksIHt9LCB7XHJcbiAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnRUeXBlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgaXNUb29sdGlwQWN0aXZlOiBmYWxzZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChwcmV2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByZXYpLCB7fSwge1xyXG4gICAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQ6IGVsLFxyXG4gICAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnRUeXBlOiB0eXBlLFxyXG4gICAgICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAob25DbGljaykgb25DbGljayhlbCwgdHlwZSwgZSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJlbmRlckxpbmtzXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyTGlua3MobGlua3MsIG5vZGVzKSB7XHJcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBsaW5rQ3VydmF0dXJlID0gX3RoaXMkcHJvcHM0LmxpbmtDdXJ2YXR1cmUsXHJcbiAgICAgICAgbGlua0NvbnRlbnQgPSBfdGhpcyRwcm9wczQubGluayxcclxuICAgICAgICBtYXJnaW4gPSBfdGhpcyRwcm9wczQubWFyZ2luO1xyXG4gICAgICB2YXIgdG9wID0gKDAsIF9nZXRbXCJkZWZhdWx0XCJdKShtYXJnaW4sICd0b3AnKSB8fCAwO1xyXG4gICAgICB2YXIgbGVmdCA9ICgwLCBfZ2V0W1wiZGVmYXVsdFwiXSkobWFyZ2luLCAnbGVmdCcpIHx8IDA7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xyXG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1zYW5rZXktbGlua3NcIixcclxuICAgICAgICBrZXk6IFwicmVjaGFydHMtc2Fua2V5LWxpbmtzXCJcclxuICAgICAgfSwgbGlua3MubWFwKGZ1bmN0aW9uIChsaW5rLCBpKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZVJlbGF0aXZlWSA9IGxpbmsuc3ksXHJcbiAgICAgICAgICB0YXJnZXRSZWxhdGl2ZVkgPSBsaW5rLnR5LFxyXG4gICAgICAgICAgbGlua1dpZHRoID0gbGluay5keTtcclxuICAgICAgICB2YXIgc291cmNlID0gbm9kZXNbbGluay5zb3VyY2VdO1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSBub2Rlc1tsaW5rLnRhcmdldF07XHJcbiAgICAgICAgdmFyIHNvdXJjZVggPSBzb3VyY2UueCArIHNvdXJjZS5keCArIGxlZnQ7XHJcbiAgICAgICAgdmFyIHRhcmdldFggPSB0YXJnZXQueCArIGxlZnQ7XHJcbiAgICAgICAgdmFyIGludGVycG9sYXRpb25GdW5jID0gaW50ZXJwb2xhdGlvbkdlbmVyYXRvcihzb3VyY2VYLCB0YXJnZXRYKTtcclxuICAgICAgICB2YXIgc291cmNlQ29udHJvbFggPSBpbnRlcnBvbGF0aW9uRnVuYyhsaW5rQ3VydmF0dXJlKTtcclxuICAgICAgICB2YXIgdGFyZ2V0Q29udHJvbFggPSBpbnRlcnBvbGF0aW9uRnVuYygxIC0gbGlua0N1cnZhdHVyZSk7XHJcbiAgICAgICAgdmFyIHNvdXJjZVkgPSBzb3VyY2UueSArIHNvdXJjZVJlbGF0aXZlWSArIGxpbmtXaWR0aCAvIDIgKyB0b3A7XHJcbiAgICAgICAgdmFyIHRhcmdldFkgPSB0YXJnZXQueSArIHRhcmdldFJlbGF0aXZlWSArIGxpbmtXaWR0aCAvIDIgKyB0b3A7XHJcbiAgICAgICAgdmFyIGxpbmtQcm9wcyA9IF9vYmplY3RTcHJlYWQoe1xyXG4gICAgICAgICAgc291cmNlWDogc291cmNlWCxcclxuICAgICAgICAgIHRhcmdldFg6IHRhcmdldFgsXHJcbiAgICAgICAgICBzb3VyY2VZOiBzb3VyY2VZLFxyXG4gICAgICAgICAgdGFyZ2V0WTogdGFyZ2V0WSxcclxuICAgICAgICAgIHNvdXJjZUNvbnRyb2xYOiBzb3VyY2VDb250cm9sWCxcclxuICAgICAgICAgIHRhcmdldENvbnRyb2xYOiB0YXJnZXRDb250cm9sWCxcclxuICAgICAgICAgIHNvdXJjZVJlbGF0aXZlWTogc291cmNlUmVsYXRpdmVZLFxyXG4gICAgICAgICAgdGFyZ2V0UmVsYXRpdmVZOiB0YXJnZXRSZWxhdGl2ZVksXHJcbiAgICAgICAgICBsaW5rV2lkdGg6IGxpbmtXaWR0aCxcclxuICAgICAgICAgIGluZGV4OiBpLFxyXG4gICAgICAgICAgcGF5bG9hZDogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBsaW5rKSwge30sIHtcclxuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH0sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykobGlua0NvbnRlbnQsIGZhbHNlKSk7XHJcbiAgICAgICAgdmFyIGV2ZW50cyA9IHtcclxuICAgICAgICAgIG9uTW91c2VFbnRlcjogX3RoaXMyLmhhbmRsZU1vdXNlRW50ZXIuYmluZChfdGhpczIsIGxpbmtQcm9wcywgJ2xpbmsnKSxcclxuICAgICAgICAgIG9uTW91c2VMZWF2ZTogX3RoaXMyLmhhbmRsZU1vdXNlTGVhdmUuYmluZChfdGhpczIsIGxpbmtQcm9wcywgJ2xpbmsnKSxcclxuICAgICAgICAgIG9uQ2xpY2s6IF90aGlzMi5oYW5kbGVDbGljay5iaW5kKF90aGlzMiwgbGlua1Byb3BzLCAnbGluaycpXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIF9leHRlbmRzKHtcclxuICAgICAgICAgIGtleTogXCJsaW5rLVwiLmNvbmNhdChsaW5rLnNvdXJjZSwgXCItXCIpLmNvbmNhdChsaW5rLnRhcmdldCwgXCItXCIpLmNvbmNhdChsaW5rLnZhbHVlKVxyXG4gICAgICAgIH0sIGV2ZW50cyksIF90aGlzMi5jb25zdHJ1Y3Rvci5yZW5kZXJMaW5rSXRlbShsaW5rQ29udGVudCwgbGlua1Byb3BzKSk7XHJcbiAgICAgIH0pKTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyTm9kZXNcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJOb2Rlcyhub2Rlcykge1xyXG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcclxuICAgICAgdmFyIF90aGlzJHByb3BzNSA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgbm9kZUNvbnRlbnQgPSBfdGhpcyRwcm9wczUubm9kZSxcclxuICAgICAgICBtYXJnaW4gPSBfdGhpcyRwcm9wczUubWFyZ2luO1xyXG4gICAgICB2YXIgdG9wID0gKDAsIF9nZXRbXCJkZWZhdWx0XCJdKShtYXJnaW4sICd0b3AnKSB8fCAwO1xyXG4gICAgICB2YXIgbGVmdCA9ICgwLCBfZ2V0W1wiZGVmYXVsdFwiXSkobWFyZ2luLCAnbGVmdCcpIHx8IDA7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xyXG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1zYW5rZXktbm9kZXNcIixcclxuICAgICAgICBrZXk6IFwicmVjaGFydHMtc2Fua2V5LW5vZGVzXCJcclxuICAgICAgfSwgbm9kZXMubWFwKGZ1bmN0aW9uIChub2RlLCBpKSB7XHJcbiAgICAgICAgdmFyIHggPSBub2RlLngsXHJcbiAgICAgICAgICB5ID0gbm9kZS55LFxyXG4gICAgICAgICAgZHggPSBub2RlLmR4LFxyXG4gICAgICAgICAgZHkgPSBub2RlLmR5O1xyXG4gICAgICAgIHZhciBub2RlUHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykobm9kZUNvbnRlbnQsIGZhbHNlKSksIHt9LCB7XHJcbiAgICAgICAgICB4OiB4ICsgbGVmdCxcclxuICAgICAgICAgIHk6IHkgKyB0b3AsXHJcbiAgICAgICAgICB3aWR0aDogZHgsXHJcbiAgICAgICAgICBoZWlnaHQ6IGR5LFxyXG4gICAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgICBwYXlsb2FkOiBub2RlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGV2ZW50cyA9IHtcclxuICAgICAgICAgIG9uTW91c2VFbnRlcjogX3RoaXMzLmhhbmRsZU1vdXNlRW50ZXIuYmluZChfdGhpczMsIG5vZGVQcm9wcywgJ25vZGUnKSxcclxuICAgICAgICAgIG9uTW91c2VMZWF2ZTogX3RoaXMzLmhhbmRsZU1vdXNlTGVhdmUuYmluZChfdGhpczMsIG5vZGVQcm9wcywgJ25vZGUnKSxcclxuICAgICAgICAgIG9uQ2xpY2s6IF90aGlzMy5oYW5kbGVDbGljay5iaW5kKF90aGlzMywgbm9kZVByb3BzLCAnbm9kZScpXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIF9leHRlbmRzKHtcclxuICAgICAgICAgIGtleTogXCJub2RlLVwiLmNvbmNhdChub2RlLngsIFwiLVwiKS5jb25jYXQobm9kZS55LCBcIi1cIikuY29uY2F0KG5vZGUudmFsdWUpXHJcbiAgICAgICAgfSwgZXZlbnRzKSwgX3RoaXMzLmNvbnN0cnVjdG9yLnJlbmRlck5vZGVJdGVtKG5vZGVDb250ZW50LCBub2RlUHJvcHMpKTtcclxuICAgICAgfSkpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJUb29sdGlwXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVG9vbHRpcCgpIHtcclxuICAgICAgdmFyIF90aGlzJHByb3BzNiA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczYuY2hpbGRyZW4sXHJcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczYud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHM2LmhlaWdodCxcclxuICAgICAgICBuYW1lS2V5ID0gX3RoaXMkcHJvcHM2Lm5hbWVLZXk7XHJcbiAgICAgIHZhciB0b29sdGlwSXRlbSA9ICgwLCBfUmVhY3RVdGlscy5maW5kQ2hpbGRCeVR5cGUpKGNoaWxkcmVuLCBfVG9vbHRpcC5Ub29sdGlwKTtcclxuICAgICAgaWYgKCF0b29sdGlwSXRlbSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBfdGhpcyRzdGF0ZSA9IHRoaXMuc3RhdGUsXHJcbiAgICAgICAgaXNUb29sdGlwQWN0aXZlID0gX3RoaXMkc3RhdGUuaXNUb29sdGlwQWN0aXZlLFxyXG4gICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBfdGhpcyRzdGF0ZS5hY3RpdmVFbGVtZW50LFxyXG4gICAgICAgIGFjdGl2ZUVsZW1lbnRUeXBlID0gX3RoaXMkc3RhdGUuYWN0aXZlRWxlbWVudFR5cGU7XHJcbiAgICAgIHZhciB2aWV3Qm94ID0ge1xyXG4gICAgICAgIHg6IDAsXHJcbiAgICAgICAgeTogMCxcclxuICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcclxuICAgICAgfTtcclxuICAgICAgdmFyIGNvb3JkaW5hdGUgPSBhY3RpdmVFbGVtZW50ID8gZ2V0Q29vcmRpbmF0ZU9mVG9vbHRpcChhY3RpdmVFbGVtZW50LCBhY3RpdmVFbGVtZW50VHlwZSkgOiBkZWZhdWx0Q29vcmRpbmF0ZU9mVG9vbHRpcDtcclxuICAgICAgdmFyIHBheWxvYWQgPSBhY3RpdmVFbGVtZW50ID8gZ2V0UGF5bG9hZE9mVG9vbHRpcChhY3RpdmVFbGVtZW50LCBhY3RpdmVFbGVtZW50VHlwZSwgbmFtZUtleSkgOiBbXTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudCh0b29sdGlwSXRlbSwge1xyXG4gICAgICAgIHZpZXdCb3g6IHZpZXdCb3gsXHJcbiAgICAgICAgYWN0aXZlOiBpc1Rvb2x0aXBBY3RpdmUsXHJcbiAgICAgICAgY29vcmRpbmF0ZTogY29vcmRpbmF0ZSxcclxuICAgICAgICBsYWJlbDogJycsXHJcbiAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgICBpZiAoISgwLCBfUmVhY3RVdGlscy52YWxpZGF0ZVdpZHRoSGVpZ2h0KSh0aGlzKSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczcgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHM3LndpZHRoLFxyXG4gICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzNy5oZWlnaHQsXHJcbiAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHM3LmNsYXNzTmFtZSxcclxuICAgICAgICBzdHlsZSA9IF90aGlzJHByb3BzNy5zdHlsZSxcclxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzNy5jaGlsZHJlbixcclxuICAgICAgICBvdGhlcnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkcHJvcHM3LCBfZXhjbHVkZWQpO1xyXG4gICAgICB2YXIgX3RoaXMkc3RhdGUyID0gdGhpcy5zdGF0ZSxcclxuICAgICAgICBsaW5rcyA9IF90aGlzJHN0YXRlMi5saW5rcyxcclxuICAgICAgICBub2RlcyA9IF90aGlzJHN0YXRlMi5ub2RlcztcclxuICAgICAgdmFyIGF0dHJzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShvdGhlcnMsIGZhbHNlKTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xyXG4gICAgICAgIGNsYXNzTmFtZTogKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXdyYXBwZXInLCBjbGFzc05hbWUpLFxyXG4gICAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0eWxlKSwge30sIHtcclxuICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCcsXHJcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIHJvbGU6IFwicmVnaW9uXCJcclxuICAgICAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfU3VyZmFjZS5TdXJmYWNlLCBfZXh0ZW5kcyh7fSwgYXR0cnMsIHtcclxuICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcclxuICAgICAgfSksICgwLCBfUmVhY3RVdGlscy5maWx0ZXJTdmdFbGVtZW50cykoY2hpbGRyZW4pLCB0aGlzLnJlbmRlckxpbmtzKGxpbmtzLCBub2RlcyksIHRoaXMucmVuZGVyTm9kZXMobm9kZXMpKSwgdGhpcy5yZW5kZXJUb29sdGlwKCkpO1xyXG4gICAgfVxyXG4gIH1dLCBbe1xyXG4gICAga2V5OiBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1wiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSkge1xyXG4gICAgICB2YXIgZGF0YSA9IG5leHRQcm9wcy5kYXRhLFxyXG4gICAgICAgIHdpZHRoID0gbmV4dFByb3BzLndpZHRoLFxyXG4gICAgICAgIGhlaWdodCA9IG5leHRQcm9wcy5oZWlnaHQsXHJcbiAgICAgICAgbWFyZ2luID0gbmV4dFByb3BzLm1hcmdpbixcclxuICAgICAgICBpdGVyYXRpb25zID0gbmV4dFByb3BzLml0ZXJhdGlvbnMsXHJcbiAgICAgICAgbm9kZVdpZHRoID0gbmV4dFByb3BzLm5vZGVXaWR0aCxcclxuICAgICAgICBub2RlUGFkZGluZyA9IG5leHRQcm9wcy5ub2RlUGFkZGluZyxcclxuICAgICAgICBzb3J0ID0gbmV4dFByb3BzLnNvcnQ7XHJcbiAgICAgIGlmIChkYXRhICE9PSBwcmV2U3RhdGUucHJldkRhdGEgfHwgd2lkdGggIT09IHByZXZTdGF0ZS5wcmV2V2lkdGggfHwgaGVpZ2h0ICE9PSBwcmV2U3RhdGUucHJldkhlaWdodCB8fCAhKDAsIF9TaGFsbG93RXF1YWwuc2hhbGxvd0VxdWFsKShtYXJnaW4sIHByZXZTdGF0ZS5wcmV2TWFyZ2luKSB8fCBpdGVyYXRpb25zICE9PSBwcmV2U3RhdGUucHJldkl0ZXJhdGlvbnMgfHwgbm9kZVdpZHRoICE9PSBwcmV2U3RhdGUucHJldk5vZGVXaWR0aCB8fCBub2RlUGFkZGluZyAhPT0gcHJldlN0YXRlLnByZXZOb2RlUGFkZGluZyB8fCBzb3J0ICE9PSBwcmV2U3RhdGUuc29ydCkge1xyXG4gICAgICAgIHZhciBjb250ZW50V2lkdGggPSB3aWR0aCAtIChtYXJnaW4gJiYgbWFyZ2luLmxlZnQgfHwgMCkgLSAobWFyZ2luICYmIG1hcmdpbi5yaWdodCB8fCAwKTtcclxuICAgICAgICB2YXIgY29udGVudEhlaWdodCA9IGhlaWdodCAtIChtYXJnaW4gJiYgbWFyZ2luLnRvcCB8fCAwKSAtIChtYXJnaW4gJiYgbWFyZ2luLmJvdHRvbSB8fCAwKTtcclxuICAgICAgICB2YXIgX2NvbXB1dGVEYXRhID0gY29tcHV0ZURhdGEoe1xyXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICB3aWR0aDogY29udGVudFdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGNvbnRlbnRIZWlnaHQsXHJcbiAgICAgICAgICAgIGl0ZXJhdGlvbnM6IGl0ZXJhdGlvbnMsXHJcbiAgICAgICAgICAgIG5vZGVXaWR0aDogbm9kZVdpZHRoLFxyXG4gICAgICAgICAgICBub2RlUGFkZGluZzogbm9kZVBhZGRpbmcsXHJcbiAgICAgICAgICAgIHNvcnQ6IHNvcnRcclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgbGlua3MgPSBfY29tcHV0ZURhdGEubGlua3MsXHJcbiAgICAgICAgICBub2RlcyA9IF9jb21wdXRlRGF0YS5ub2RlcztcclxuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcmV2U3RhdGUpLCB7fSwge1xyXG4gICAgICAgICAgbm9kZXM6IG5vZGVzLFxyXG4gICAgICAgICAgbGlua3M6IGxpbmtzLFxyXG4gICAgICAgICAgcHJldkRhdGE6IGRhdGEsXHJcbiAgICAgICAgICBwcmV2V2lkdGg6IGl0ZXJhdGlvbnMsXHJcbiAgICAgICAgICBwcmV2SGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICBwcmV2TWFyZ2luOiBtYXJnaW4sXHJcbiAgICAgICAgICBwcmV2Tm9kZVBhZGRpbmc6IG5vZGVQYWRkaW5nLFxyXG4gICAgICAgICAgcHJldk5vZGVXaWR0aDogbm9kZVdpZHRoLFxyXG4gICAgICAgICAgcHJldkl0ZXJhdGlvbnM6IGl0ZXJhdGlvbnMsXHJcbiAgICAgICAgICBwcmV2U29ydDogc29ydFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJMaW5rSXRlbVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckxpbmtJdGVtKG9wdGlvbiwgcHJvcHMpIHtcclxuICAgICAgaWYgKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5pc1ZhbGlkRWxlbWVudChvcHRpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChvcHRpb24sIHByb3BzKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob3B0aW9uKSkge1xyXG4gICAgICAgIHJldHVybiBvcHRpb24ocHJvcHMpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBzb3VyY2VYID0gcHJvcHMuc291cmNlWCxcclxuICAgICAgICBzb3VyY2VZID0gcHJvcHMuc291cmNlWSxcclxuICAgICAgICBzb3VyY2VDb250cm9sWCA9IHByb3BzLnNvdXJjZUNvbnRyb2xYLFxyXG4gICAgICAgIHRhcmdldFggPSBwcm9wcy50YXJnZXRYLFxyXG4gICAgICAgIHRhcmdldFkgPSBwcm9wcy50YXJnZXRZLFxyXG4gICAgICAgIHRhcmdldENvbnRyb2xYID0gcHJvcHMudGFyZ2V0Q29udHJvbFgsXHJcbiAgICAgICAgbGlua1dpZHRoID0gcHJvcHMubGlua1dpZHRoLFxyXG4gICAgICAgIG90aGVycyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkMik7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCBfZXh0ZW5kcyh7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXNhbmtleS1saW5rXCIsXHJcbiAgICAgICAgZDogXCJcXG4gICAgICAgICAgTVwiLmNvbmNhdChzb3VyY2VYLCBcIixcIikuY29uY2F0KHNvdXJjZVksIFwiXFxuICAgICAgICAgIENcIikuY29uY2F0KHNvdXJjZUNvbnRyb2xYLCBcIixcIikuY29uY2F0KHNvdXJjZVksIFwiIFwiKS5jb25jYXQodGFyZ2V0Q29udHJvbFgsIFwiLFwiKS5jb25jYXQodGFyZ2V0WSwgXCIgXCIpLmNvbmNhdCh0YXJnZXRYLCBcIixcIikuY29uY2F0KHRhcmdldFksIFwiXFxuICAgICAgICBcIiksXHJcbiAgICAgICAgZmlsbDogXCJub25lXCIsXHJcbiAgICAgICAgc3Ryb2tlOiBcIiMzMzNcIixcclxuICAgICAgICBzdHJva2VXaWR0aDogbGlua1dpZHRoLFxyXG4gICAgICAgIHN0cm9rZU9wYWNpdHk6IFwiMC4yXCJcclxuICAgICAgfSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShvdGhlcnMsIGZhbHNlKSkpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJOb2RlSXRlbVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlck5vZGVJdGVtKG9wdGlvbiwgcHJvcHMpIHtcclxuICAgICAgaWYgKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5pc1ZhbGlkRWxlbWVudChvcHRpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChvcHRpb24sIHByb3BzKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob3B0aW9uKSkge1xyXG4gICAgICAgIHJldHVybiBvcHRpb24ocHJvcHMpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9SZWN0YW5nbGUuUmVjdGFuZ2xlLCBfZXh0ZW5kcyh7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXNhbmtleS1ub2RlXCIsXHJcbiAgICAgICAgZmlsbDogXCIjMDA4OGZlXCIsXHJcbiAgICAgICAgZmlsbE9wYWNpdHk6IFwiMC44XCJcclxuICAgICAgfSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShwcm9wcywgZmFsc2UpLCB7XHJcbiAgICAgICAgcm9sZTogXCJpbWdcIlxyXG4gICAgICB9KSk7XHJcbiAgICB9XHJcbiAgfV0pO1xyXG59KF9yZWFjdC5QdXJlQ29tcG9uZW50KTtcclxuX2RlZmluZVByb3BlcnR5KFNhbmtleSwgXCJkaXNwbGF5TmFtZVwiLCAnU2Fua2V5Jyk7XHJcbl9kZWZpbmVQcm9wZXJ0eShTYW5rZXksIFwiZGVmYXVsdFByb3BzXCIsIHtcclxuICBuYW1lS2V5OiAnbmFtZScsXHJcbiAgZGF0YUtleTogJ3ZhbHVlJyxcclxuICBub2RlUGFkZGluZzogMTAsXHJcbiAgbm9kZVdpZHRoOiAxMCxcclxuICBsaW5rQ3VydmF0dXJlOiAwLjUsXHJcbiAgaXRlcmF0aW9uczogMzIsXHJcbiAgbWFyZ2luOiB7XHJcbiAgICB0b3A6IDUsXHJcbiAgICByaWdodDogNSxcclxuICAgIGJvdHRvbTogNSxcclxuICAgIGxlZnQ6IDVcclxuICB9LFxyXG4gIHNvcnQ6IHRydWVcclxufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU2Fua2V5IiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX21heEJ5IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9taW4iLCJfZ2V0IiwiX3N1bUJ5IiwiX2lzRnVuY3Rpb24iLCJfY2xzeCIsIl9TdXJmYWNlIiwiX0xheWVyIiwiX1Rvb2x0aXAiLCJfUmVjdGFuZ2xlIiwiX1NoYWxsb3dFcXVhbCIsIl9SZWFjdFV0aWxzIiwiX0NoYXJ0VXRpbHMiLCJfZXhjbHVkZWQiLCJfZXhjbHVkZWQyIiwib2JqIiwiX19lc01vZHVsZSIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJfdHlwZW9mIiwiaGFzIiwiZ2V0IiwibiIsIl9fcHJvdG9fXyIsImEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ1IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaSIsInNldCIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsInNvdXJjZSIsImV4Y2x1ZGVkIiwidGFyZ2V0IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJrZXkiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzb3VyY2VTeW1ib2xLZXlzIiwibGVuZ3RoIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9Qcm9wZXJ0eUtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsInAiLCJvd25LZXlzIiwia2V5cyIsImZpbHRlciIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJkZWZhdWx0Q29vcmRpbmF0ZU9mVG9vbHRpcCIsIngiLCJ5IiwiaW50ZXJwb2xhdGlvbkdlbmVyYXRvciIsImIiLCJrYSIsImtiIiwiY2VudGVyWSIsIm5vZGUiLCJkeSIsImdldFZhbHVlIiwiZW50cnkiLCJnZXRTdW1PZklkcyIsImxpbmtzIiwiaWRzIiwicmVkdWNlIiwicmVzdWx0IiwiaWQiLCJnZXRTdW1XaXRoV2VpZ2h0ZWRTb3VyY2UiLCJ0cmVlIiwibGluayIsInNvdXJjZU5vZGUiLCJnZXRTdW1XaXRoV2VpZ2h0ZWRUYXJnZXQiLCJ0YXJnZXROb2RlIiwiYXNjZW5kaW5nWSIsInNlYXJjaFRhcmdldHNBbmRTb3VyY2VzIiwic291cmNlTm9kZXMiLCJzb3VyY2VMaW5rcyIsInRhcmdldE5vZGVzIiwidGFyZ2V0TGlua3MiLCJsZW4iLCJ1cGRhdGVEZXB0aE9mVGFyZ2V0cyIsImN1ck5vZGUiLCJkZXB0aCIsIk1hdGgiLCJtYXgiLCJnZXROb2Rlc1RyZWUiLCJfcmVmIiwid2lkdGgiLCJub2RlV2lkdGgiLCJub2RlcyIsIm1hcCIsImluZGV4IiwibWF4RGVwdGgiLCJjaGlsZFdpZHRoIiwiX2kiLCJfbGVuIiwiX25vZGUiLCJkeCIsImdldERlcHRoVHJlZSIsInVwZGF0ZVlPZlRyZWUiLCJkZXB0aFRyZWUiLCJoZWlnaHQiLCJub2RlUGFkZGluZyIsInlSYXRpbyIsImQiLCJyZXNvbHZlQ29sbGlzaW9ucyIsInNvcnQiLCJ1bmRlZmluZWQiLCJ5MCIsImoiLCJfaiIsIl9ub2RlMiIsIl9keSIsInJlbGF4TGVmdFRvUmlnaHQiLCJhbHBoYSIsInNvdXJjZVN1bSIsIndlaWdodGVkU3VtIiwicmVsYXhSaWdodFRvTGVmdCIsInRhcmdldFN1bSIsInVwZGF0ZVlPZkxpbmtzIiwic3kiLCJ0eSIsInRMZW4iLCJfajIiLCJzTGVuIiwiX2xpbmsiLCJjb21wdXRlRGF0YSIsIl9yZWYyIiwiZGF0YSIsIml0ZXJhdGlvbnMiLCJfZ2V0Tm9kZXNUcmVlIiwibmV3TGlua3MiLCJnZXRDb29yZGluYXRlT2ZUb29sdGlwIiwiZWwiLCJ0eXBlIiwic291cmNlWCIsInRhcmdldFgiLCJzb3VyY2VZIiwidGFyZ2V0WSIsImdldFBheWxvYWRPZlRvb2x0aXAiLCJuYW1lS2V5IiwicGF5bG9hZCIsIm5hbWUiLCJnZXRWYWx1ZUJ5RGF0YUtleSIsInNvdXJjZU5hbWUiLCJ0YXJnZXROYW1lIiwiY29uY2F0IiwiX1B1cmVDb21wb25lbnQiLCJfdGhpcyIsIl9sZW4yIiwiYXJncyIsIkFycmF5IiwiX2tleSIsImFjdGl2ZUVsZW1lbnQiLCJhY3RpdmVFbGVtZW50VHlwZSIsImlzVG9vbHRpcEFjdGl2ZSIsImhhbmRsZU1vdXNlRW50ZXIiLCJfdGhpcyRwcm9wcyIsIm9uTW91c2VFbnRlciIsImNoaWxkcmVuIiwidG9vbHRpcEl0ZW0iLCJmaW5kQ2hpbGRCeVR5cGUiLCJUb29sdGlwIiwic2V0U3RhdGUiLCJwcmV2IiwidHJpZ2dlciIsImhhbmRsZU1vdXNlTGVhdmUiLCJfdGhpcyRwcm9wczIiLCJvbk1vdXNlTGVhdmUiLCJoYW5kbGVDbGljayIsIl90aGlzJHByb3BzMyIsIm9uQ2xpY2siLCJzdGF0ZSIsInJlbmRlckxpbmtzIiwiX3RoaXMyIiwiX3RoaXMkcHJvcHM0IiwibGlua0N1cnZhdHVyZSIsImxpbmtDb250ZW50IiwibWFyZ2luIiwidG9wIiwibGVmdCIsImNyZWF0ZUVsZW1lbnQiLCJMYXllciIsImNsYXNzTmFtZSIsInNvdXJjZVJlbGF0aXZlWSIsInRhcmdldFJlbGF0aXZlWSIsImxpbmtXaWR0aCIsImludGVycG9sYXRpb25GdW5jIiwic291cmNlQ29udHJvbFgiLCJ0YXJnZXRDb250cm9sWCIsImxpbmtQcm9wcyIsImZpbHRlclByb3BzIiwiZXZlbnRzIiwicmVuZGVyTGlua0l0ZW0iLCJyZW5kZXJOb2RlcyIsIl90aGlzMyIsIl90aGlzJHByb3BzNSIsIm5vZGVDb250ZW50Iiwibm9kZVByb3BzIiwicmVuZGVyTm9kZUl0ZW0iLCJyZW5kZXJUb29sdGlwIiwiX3RoaXMkcHJvcHM2IiwiX3RoaXMkc3RhdGUiLCJ2aWV3Qm94IiwiY29vcmRpbmF0ZSIsImNsb25lRWxlbWVudCIsImFjdGl2ZSIsImxhYmVsIiwicmVuZGVyIiwidmFsaWRhdGVXaWR0aEhlaWdodCIsIl90aGlzJHByb3BzNyIsInN0eWxlIiwib3RoZXJzIiwiX3RoaXMkc3RhdGUyIiwiYXR0cnMiLCJwb3NpdGlvbiIsImN1cnNvciIsInJvbGUiLCJTdXJmYWNlIiwiZmlsdGVyU3ZnRWxlbWVudHMiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJuZXh0UHJvcHMiLCJwcmV2U3RhdGUiLCJwcmV2RGF0YSIsInByZXZXaWR0aCIsInByZXZIZWlnaHQiLCJzaGFsbG93RXF1YWwiLCJwcmV2TWFyZ2luIiwicHJldkl0ZXJhdGlvbnMiLCJwcmV2Tm9kZVdpZHRoIiwicHJldk5vZGVQYWRkaW5nIiwiY29udGVudFdpZHRoIiwicmlnaHQiLCJjb250ZW50SGVpZ2h0IiwiYm90dG9tIiwiX2NvbXB1dGVEYXRhIiwicHJldlNvcnQiLCJvcHRpb24iLCJpc1ZhbGlkRWxlbWVudCIsImZpbGwiLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsInN0cm9rZU9wYWNpdHkiLCJSZWN0YW5nbGUiLCJmaWxsT3BhY2l0eSIsIlB1cmVDb21wb25lbnQiLCJkYXRhS2V5Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/chart/Sankey.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/chart/ScatterChart.js":
/*!*********************************************************!*\
  !*** ./node_modules/recharts/lib/chart/ScatterChart.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ScatterChart = void 0;\nvar _generateCategoricalChart = __webpack_require__(/*! ./generateCategoricalChart */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/generateCategoricalChart.js\");\nvar _Scatter = __webpack_require__(/*! ../cartesian/Scatter */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/Scatter.js\");\nvar _XAxis = __webpack_require__(/*! ../cartesian/XAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/XAxis.js\");\nvar _YAxis = __webpack_require__(/*! ../cartesian/YAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/YAxis.js\");\nvar _ZAxis = __webpack_require__(/*! ../cartesian/ZAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/ZAxis.js\");\nvar _CartesianUtils = __webpack_require__(/*! ../util/CartesianUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/CartesianUtils.js\");\n/**\r\n * @fileOverview Scatter Chart\r\n */ var ScatterChart = exports.ScatterChart = (0, _generateCategoricalChart.generateCategoricalChart)({\n    chartName: 'ScatterChart',\n    GraphicalChild: _Scatter.Scatter,\n    defaultTooltipEventType: 'item',\n    validateTooltipEventTypes: [\n        'item'\n    ],\n    axisComponents: [\n        {\n            axisType: 'xAxis',\n            AxisComp: _XAxis.XAxis\n        },\n        {\n            axisType: 'yAxis',\n            AxisComp: _YAxis.YAxis\n        },\n        {\n            axisType: 'zAxis',\n            AxisComp: _ZAxis.ZAxis\n        }\n    ],\n    formatAxisMap: _CartesianUtils.formatAxisMap\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvU2NhdHRlckNoYXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxvQkFBb0IsR0FBRyxLQUFLO0FBQzVCLElBQUlHLDRCQUE0QkMsbUJBQU9BLENBQUMsa0hBQTRCO0FBQ3BFLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDLCtGQUFzQjtBQUM3QyxJQUFJRSxTQUFTRixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDekMsSUFBSUcsU0FBU0gsbUJBQU9BLENBQUMsMkZBQW9CO0FBQ3pDLElBQUlJLFNBQVNKLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUN6QyxJQUFJSyxrQkFBa0JMLG1CQUFPQSxDQUFDLG1HQUF3QjtBQUN0RDs7Q0FFQyxHQUVELElBQUlGLGVBQWVGLG9CQUFvQixHQUFHLENBQUMsR0FBR0csMEJBQTBCTyx3QkFBd0IsRUFBRTtJQUNoR0MsV0FBVztJQUNYQyxnQkFBZ0JQLFNBQVNRLE9BQU87SUFDaENDLHlCQUF5QjtJQUN6QkMsMkJBQTJCO1FBQUM7S0FBTztJQUNuQ0MsZ0JBQWdCO1FBQUM7WUFDZkMsVUFBVTtZQUNWQyxVQUFVWixPQUFPYSxLQUFLO1FBQ3hCO1FBQUc7WUFDREYsVUFBVTtZQUNWQyxVQUFVWCxPQUFPYSxLQUFLO1FBQ3hCO1FBQUc7WUFDREgsVUFBVTtZQUNWQyxVQUFVVixPQUFPYSxLQUFLO1FBQ3hCO0tBQUU7SUFDRkMsZUFBZWIsZ0JBQWdCYSxhQUFhO0FBQzlDIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxjaGFydFxcU2NhdHRlckNoYXJ0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuU2NhdHRlckNoYXJ0ID0gdm9pZCAwO1xyXG52YXIgX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydFwiKTtcclxudmFyIF9TY2F0dGVyID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9TY2F0dGVyXCIpO1xyXG52YXIgX1hBeGlzID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9YQXhpc1wiKTtcclxudmFyIF9ZQXhpcyA9IHJlcXVpcmUoXCIuLi9jYXJ0ZXNpYW4vWUF4aXNcIik7XHJcbnZhciBfWkF4aXMgPSByZXF1aXJlKFwiLi4vY2FydGVzaWFuL1pBeGlzXCIpO1xyXG52YXIgX0NhcnRlc2lhblV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvQ2FydGVzaWFuVXRpbHNcIik7XHJcbi8qKlxyXG4gKiBAZmlsZU92ZXJ2aWV3IFNjYXR0ZXIgQ2hhcnRcclxuICovXHJcblxyXG52YXIgU2NhdHRlckNoYXJ0ID0gZXhwb3J0cy5TY2F0dGVyQ2hhcnQgPSAoMCwgX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydC5nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQpKHtcclxuICBjaGFydE5hbWU6ICdTY2F0dGVyQ2hhcnQnLFxyXG4gIEdyYXBoaWNhbENoaWxkOiBfU2NhdHRlci5TY2F0dGVyLFxyXG4gIGRlZmF1bHRUb29sdGlwRXZlbnRUeXBlOiAnaXRlbScsXHJcbiAgdmFsaWRhdGVUb29sdGlwRXZlbnRUeXBlczogWydpdGVtJ10sXHJcbiAgYXhpc0NvbXBvbmVudHM6IFt7XHJcbiAgICBheGlzVHlwZTogJ3hBeGlzJyxcclxuICAgIEF4aXNDb21wOiBfWEF4aXMuWEF4aXNcclxuICB9LCB7XHJcbiAgICBheGlzVHlwZTogJ3lBeGlzJyxcclxuICAgIEF4aXNDb21wOiBfWUF4aXMuWUF4aXNcclxuICB9LCB7XHJcbiAgICBheGlzVHlwZTogJ3pBeGlzJyxcclxuICAgIEF4aXNDb21wOiBfWkF4aXMuWkF4aXNcclxuICB9XSxcclxuICBmb3JtYXRBeGlzTWFwOiBfQ2FydGVzaWFuVXRpbHMuZm9ybWF0QXhpc01hcFxyXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTY2F0dGVyQ2hhcnQiLCJfZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0IiwicmVxdWlyZSIsIl9TY2F0dGVyIiwiX1hBeGlzIiwiX1lBeGlzIiwiX1pBeGlzIiwiX0NhcnRlc2lhblV0aWxzIiwiZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0IiwiY2hhcnROYW1lIiwiR3JhcGhpY2FsQ2hpbGQiLCJTY2F0dGVyIiwiZGVmYXVsdFRvb2x0aXBFdmVudFR5cGUiLCJ2YWxpZGF0ZVRvb2x0aXBFdmVudFR5cGVzIiwiYXhpc0NvbXBvbmVudHMiLCJheGlzVHlwZSIsIkF4aXNDb21wIiwiWEF4aXMiLCJZQXhpcyIsIlpBeGlzIiwiZm9ybWF0QXhpc01hcCJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/chart/ScatterChart.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/chart/SunburstChart.js":
/*!**********************************************************!*\
  !*** ./node_modules/recharts/lib/chart/SunburstChart.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SunburstChart = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _d3Scale = __webpack_require__(/*! victory-vendor/d3-scale */ \"victory-vendor/d3-scale\");\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _Surface = __webpack_require__(/*! ../container/Surface */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Surface.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _Sector = __webpack_require__(/*! ../shape/Sector */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Sector.js\");\nvar _Text = __webpack_require__(/*! ../component/Text */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Text.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _Tooltip = __webpack_require__(/*! ../component/Tooltip */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Tooltip.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nvar defaultTextProps = {\n    fontWeight: 'bold',\n    paintOrder: 'stroke fill',\n    fontSize: '.75rem',\n    stroke: '#FFF',\n    fill: 'black',\n    pointerEvents: 'none'\n};\nfunction getMaxDepthOf(node) {\n    if (!node.children || node.children.length === 0) return 1;\n    // Calculate depth for each child and find the maximum\n    var childDepths = node.children.map(function(d) {\n        return getMaxDepthOf(d);\n    });\n    return 1 + Math.max.apply(Math, _toConsumableArray(childDepths));\n}\nvar SunburstChart = exports.SunburstChart = function SunburstChart(_ref) {\n    var className = _ref.className, data = _ref.data, children = _ref.children, width = _ref.width, height = _ref.height, _ref$padding = _ref.padding, padding = _ref$padding === void 0 ? 2 : _ref$padding, _ref$dataKey = _ref.dataKey, dataKey = _ref$dataKey === void 0 ? 'value' : _ref$dataKey, _ref$ringPadding = _ref.ringPadding, ringPadding = _ref$ringPadding === void 0 ? 2 : _ref$ringPadding, _ref$innerRadius = _ref.innerRadius, innerRadius = _ref$innerRadius === void 0 ? 50 : _ref$innerRadius, _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? '#333' : _ref$fill, _ref$stroke = _ref.stroke, stroke = _ref$stroke === void 0 ? '#FFF' : _ref$stroke, _ref$textOptions = _ref.textOptions, textOptions = _ref$textOptions === void 0 ? defaultTextProps : _ref$textOptions, _ref$outerRadius = _ref.outerRadius, outerRadius = _ref$outerRadius === void 0 ? Math.min(width, height) / 2 : _ref$outerRadius, _ref$cx = _ref.cx, cx = _ref$cx === void 0 ? width / 2 : _ref$cx, _ref$cy = _ref.cy, cy = _ref$cy === void 0 ? height / 2 : _ref$cy, _ref$startAngle = _ref.startAngle, startAngle = _ref$startAngle === void 0 ? 0 : _ref$startAngle, _ref$endAngle = _ref.endAngle, endAngle = _ref$endAngle === void 0 ? 360 : _ref$endAngle, onClick = _ref.onClick, onMouseEnter = _ref.onMouseEnter, onMouseLeave = _ref.onMouseLeave;\n    var _useState = (0, _react.useState)(false), _useState2 = _slicedToArray(_useState, 2), isTooltipActive = _useState2[0], setIsTooltipActive = _useState2[1];\n    var _useState3 = (0, _react.useState)(null), _useState4 = _slicedToArray(_useState3, 2), activeNode = _useState4[0], setActiveNode = _useState4[1];\n    var rScale = (0, _d3Scale.scaleLinear)([\n        0,\n        data[dataKey]\n    ], [\n        0,\n        endAngle\n    ]);\n    var treeDepth = getMaxDepthOf(data);\n    var thickness = (outerRadius - innerRadius) / treeDepth;\n    var sectors = [];\n    var positions = new Map([]);\n    // event handlers\n    function handleMouseEnter(node, e) {\n        if (onMouseEnter) onMouseEnter(node, e);\n        setActiveNode(node);\n        setIsTooltipActive(true);\n    }\n    function handleMouseLeave(node, e) {\n        if (onMouseLeave) onMouseLeave(node, e);\n        setActiveNode(null);\n        setIsTooltipActive(false);\n    }\n    function handleClick(node) {\n        if (onClick) onClick(node);\n    }\n    // recursively add nodes for each data point and its children\n    function drawArcs(childNodes, options) {\n        var radius = options.radius, innerR = options.innerR, initialAngle = options.initialAngle, childColor = options.childColor;\n        var currentAngle = initialAngle;\n        if (!childNodes) return; // base case: no children of this node\n        childNodes.forEach(function(d) {\n            var _ref2, _d$fill;\n            var arcLength = rScale(d[dataKey]);\n            var start = currentAngle;\n            // color priority - if there's a color on the individual point use that, otherwise use parent color or default\n            var fillColor = (_ref2 = (_d$fill = d === null || d === void 0 ? void 0 : d.fill) !== null && _d$fill !== void 0 ? _d$fill : childColor) !== null && _ref2 !== void 0 ? _ref2 : fill;\n            var _polarToCartesian = (0, _PolarUtils.polarToCartesian)(0, 0, innerR + radius / 2, -(start + arcLength - arcLength / 2)), textX = _polarToCartesian.x, textY = _polarToCartesian.y;\n            currentAngle += arcLength;\n            sectors.push(/*#__PURE__*/ // TODO: Missing key warning. Can we use `key={d.name}`?\n            _react[\"default\"].createElement(\"g\", {\n                \"aria-label\": d.name,\n                tabIndex: 0\n            }, /*#__PURE__*/ _react[\"default\"].createElement(_Sector.Sector, {\n                onClick: function onClick() {\n                    return handleClick(d);\n                },\n                onMouseEnter: function onMouseEnter(e) {\n                    return handleMouseEnter(d, e);\n                },\n                onMouseLeave: function onMouseLeave(e) {\n                    return handleMouseLeave(d, e);\n                },\n                fill: fillColor,\n                stroke: stroke,\n                strokeWidth: padding,\n                startAngle: start,\n                endAngle: start + arcLength,\n                innerRadius: innerR,\n                outerRadius: innerR + radius,\n                cx: cx,\n                cy: cy\n            }), /*#__PURE__*/ _react[\"default\"].createElement(_Text.Text, _extends({}, textOptions, {\n                alignmentBaseline: \"middle\",\n                textAnchor: \"middle\",\n                x: textX + cx,\n                y: cy - textY\n            }), d[dataKey])));\n            var _polarToCartesian2 = (0, _PolarUtils.polarToCartesian)(cx, cy, innerR + radius / 2, start), tooltipX = _polarToCartesian2.x, tooltipY = _polarToCartesian2.y;\n            positions.set(d.name, {\n                x: tooltipX,\n                y: tooltipY\n            });\n            return drawArcs(d.children, {\n                radius: radius,\n                innerR: innerR + radius + ringPadding,\n                initialAngle: start,\n                childColor: fillColor\n            });\n        });\n    }\n    drawArcs(data.children, {\n        radius: thickness,\n        innerR: innerRadius,\n        initialAngle: startAngle\n    });\n    var layerClass = (0, _clsx[\"default\"])('recharts-sunburst', className);\n    function renderTooltip() {\n        var tooltipComponent = (0, _ReactUtils.findChildByType)([\n            children\n        ], _Tooltip.Tooltip);\n        if (!tooltipComponent || !activeNode) return null;\n        var viewBox = {\n            x: 0,\n            y: 0,\n            width: width,\n            height: height\n        };\n        return /*#__PURE__*/ _react[\"default\"].cloneElement(tooltipComponent, {\n            viewBox: viewBox,\n            coordinate: positions.get(activeNode.name),\n            payload: [\n                activeNode\n            ],\n            active: isTooltipActive\n        });\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n        className: (0, _clsx[\"default\"])('recharts-wrapper', className),\n        style: {\n            position: 'relative',\n            width: width,\n            height: height\n        },\n        role: \"region\"\n    }, /*#__PURE__*/ _react[\"default\"].createElement(_Surface.Surface, {\n        width: width,\n        height: height\n    }, children, /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n        className: layerClass\n    }, sectors)), renderTooltip());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvU3VuYnVyc3RDaGFydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFLFdBQVcsS0FBS0MsVUFBVUQsTUFBTUMsT0FBT0UsU0FBUyxHQUFHLFdBQVcsT0FBT0g7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdUSSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQscUJBQXFCLEdBQUcsS0FBSztBQUM3QixJQUFJRyxTQUFTQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3BELElBQUlDLFdBQVdELG1CQUFPQSxDQUFDLHdEQUF5QjtBQUNoRCxJQUFJRSxRQUFRQyx1QkFBdUJILG1CQUFPQSxDQUFDLHVCQUFNO0FBQ2pELElBQUlJLGNBQWNKLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM5QyxJQUFJSyxXQUFXTCxtQkFBT0EsQ0FBQywrRkFBc0I7QUFDN0MsSUFBSU0sU0FBU04sbUJBQU9BLENBQUMsMkZBQW9CO0FBQ3pDLElBQUlPLFVBQVVQLG1CQUFPQSxDQUFDLHFGQUFpQjtBQUN2QyxJQUFJUSxRQUFRUixtQkFBT0EsQ0FBQyx5RkFBbUI7QUFDdkMsSUFBSVMsY0FBY1QsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlVLFdBQVdWLG1CQUFPQSxDQUFDLCtGQUFzQjtBQUM3QyxTQUFTRyx1QkFBdUJRLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UseUJB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LEtBQUssQ0FBQyxVQUFVLEVBQUUscUJBQXFCZ0Y7SUFDNUQsU0FBU2dGO1FBQ1AsSUFBSUMsbUJBQW1CLENBQUMsR0FBRy9KLFlBQVlnSyxlQUFlLEVBQUU7WUFBQ3pGO1NBQVMsRUFBRWpFLFNBQVMySixPQUFPO1FBQ3BGLElBQUksQ0FBQ0Ysb0JBQW9CLENBQUM1QyxZQUFZLE9BQU87UUFDN0MsSUFBSStDLFVBQVU7WUFDWmxCLEdBQUc7WUFDSEUsR0FBRztZQUNIbEUsT0FBT0E7WUFDUEMsUUFBUUE7UUFDVjtRQUNBLE9BQU8sV0FBVyxHQUFFdkYsTUFBTSxDQUFDLFVBQVUsQ0FBQ3lLLFlBQVksQ0FBQ0osa0JBQWtCO1lBQ25FRyxTQUFTQTtZQUNURSxZQUFZMUMsVUFBVTNHLEdBQUcsQ0FBQ29HLFdBQVczRCxJQUFJO1lBQ3pDNkcsU0FBUztnQkFBQ2xEO2FBQVc7WUFDckJtRCxRQUFRdkQ7UUFDVjtJQUNGO0lBQ0EsT0FBTyxXQUFXLEdBQUVySCxNQUFNLENBQUMsVUFBVSxDQUFDeUosYUFBYSxDQUFDLE9BQU87UUFDekRyRSxXQUFXLENBQUMsR0FBR2hGLEtBQUssQ0FBQyxVQUFVLEVBQUUsb0JBQW9CZ0Y7UUFDckR5RixPQUFPO1lBQ0xDLFVBQVU7WUFDVnhGLE9BQU9BO1lBQ1BDLFFBQVFBO1FBQ1Y7UUFDQXdGLE1BQU07SUFDUixHQUFHLFdBQVcsR0FBRS9LLE1BQU0sQ0FBQyxVQUFVLENBQUN5SixhQUFhLENBQUNsSixTQUFTeUssT0FBTyxFQUFFO1FBQ2hFMUYsT0FBT0E7UUFDUEMsUUFBUUE7SUFDVixHQUFHVixVQUFVLFdBQVcsR0FBRTdFLE1BQU0sQ0FBQyxVQUFVLENBQUN5SixhQUFhLENBQUNqSixPQUFPeUssS0FBSyxFQUFFO1FBQ3RFN0YsV0FBVytFO0lBQ2IsR0FBR3BDLFdBQVdxQztBQUNoQiIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcY2hhcnRcXFN1bmJ1cnN0Q2hhcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLlN1bmJ1cnN0Q2hhcnQgPSB2b2lkIDA7XHJcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgX2QzU2NhbGUgPSByZXF1aXJlKFwidmljdG9yeS12ZW5kb3IvZDMtc2NhbGVcIik7XHJcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xyXG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xyXG52YXIgX1N1cmZhY2UgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL1N1cmZhY2VcIik7XHJcbnZhciBfTGF5ZXIgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL0xheWVyXCIpO1xyXG52YXIgX1NlY3RvciA9IHJlcXVpcmUoXCIuLi9zaGFwZS9TZWN0b3JcIik7XHJcbnZhciBfVGV4dCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQvVGV4dFwiKTtcclxudmFyIF9Qb2xhclV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUG9sYXJVdGlsc1wiKTtcclxudmFyIF9Ub29sdGlwID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9Ub29sdGlwXCIpO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cclxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XHJcbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XHJcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cclxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XHJcbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxyXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cclxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxyXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cclxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XHJcbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cclxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cclxudmFyIGRlZmF1bHRUZXh0UHJvcHMgPSB7XHJcbiAgZm9udFdlaWdodDogJ2JvbGQnLFxyXG4gIHBhaW50T3JkZXI6ICdzdHJva2UgZmlsbCcsXHJcbiAgZm9udFNpemU6ICcuNzVyZW0nLFxyXG4gIHN0cm9rZTogJyNGRkYnLFxyXG4gIGZpbGw6ICdibGFjaycsXHJcbiAgcG9pbnRlckV2ZW50czogJ25vbmUnXHJcbn07XHJcbmZ1bmN0aW9uIGdldE1heERlcHRoT2Yobm9kZSkge1xyXG4gIGlmICghbm9kZS5jaGlsZHJlbiB8fCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDE7XHJcblxyXG4gIC8vIENhbGN1bGF0ZSBkZXB0aCBmb3IgZWFjaCBjaGlsZCBhbmQgZmluZCB0aGUgbWF4aW11bVxyXG4gIHZhciBjaGlsZERlcHRocyA9IG5vZGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChkKSB7XHJcbiAgICByZXR1cm4gZ2V0TWF4RGVwdGhPZihkKTtcclxuICB9KTtcclxuICByZXR1cm4gMSArIE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShjaGlsZERlcHRocykpO1xyXG59XHJcbnZhciBTdW5idXJzdENoYXJ0ID0gZXhwb3J0cy5TdW5idXJzdENoYXJ0ID0gZnVuY3Rpb24gU3VuYnVyc3RDaGFydChfcmVmKSB7XHJcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxyXG4gICAgZGF0YSA9IF9yZWYuZGF0YSxcclxuICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcclxuICAgIHdpZHRoID0gX3JlZi53aWR0aCxcclxuICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxyXG4gICAgX3JlZiRwYWRkaW5nID0gX3JlZi5wYWRkaW5nLFxyXG4gICAgcGFkZGluZyA9IF9yZWYkcGFkZGluZyA9PT0gdm9pZCAwID8gMiA6IF9yZWYkcGFkZGluZyxcclxuICAgIF9yZWYkZGF0YUtleSA9IF9yZWYuZGF0YUtleSxcclxuICAgIGRhdGFLZXkgPSBfcmVmJGRhdGFLZXkgPT09IHZvaWQgMCA/ICd2YWx1ZScgOiBfcmVmJGRhdGFLZXksXHJcbiAgICBfcmVmJHJpbmdQYWRkaW5nID0gX3JlZi5yaW5nUGFkZGluZyxcclxuICAgIHJpbmdQYWRkaW5nID0gX3JlZiRyaW5nUGFkZGluZyA9PT0gdm9pZCAwID8gMiA6IF9yZWYkcmluZ1BhZGRpbmcsXHJcbiAgICBfcmVmJGlubmVyUmFkaXVzID0gX3JlZi5pbm5lclJhZGl1cyxcclxuICAgIGlubmVyUmFkaXVzID0gX3JlZiRpbm5lclJhZGl1cyA9PT0gdm9pZCAwID8gNTAgOiBfcmVmJGlubmVyUmFkaXVzLFxyXG4gICAgX3JlZiRmaWxsID0gX3JlZi5maWxsLFxyXG4gICAgZmlsbCA9IF9yZWYkZmlsbCA9PT0gdm9pZCAwID8gJyMzMzMnIDogX3JlZiRmaWxsLFxyXG4gICAgX3JlZiRzdHJva2UgPSBfcmVmLnN0cm9rZSxcclxuICAgIHN0cm9rZSA9IF9yZWYkc3Ryb2tlID09PSB2b2lkIDAgPyAnI0ZGRicgOiBfcmVmJHN0cm9rZSxcclxuICAgIF9yZWYkdGV4dE9wdGlvbnMgPSBfcmVmLnRleHRPcHRpb25zLFxyXG4gICAgdGV4dE9wdGlvbnMgPSBfcmVmJHRleHRPcHRpb25zID09PSB2b2lkIDAgPyBkZWZhdWx0VGV4dFByb3BzIDogX3JlZiR0ZXh0T3B0aW9ucyxcclxuICAgIF9yZWYkb3V0ZXJSYWRpdXMgPSBfcmVmLm91dGVyUmFkaXVzLFxyXG4gICAgb3V0ZXJSYWRpdXMgPSBfcmVmJG91dGVyUmFkaXVzID09PSB2b2lkIDAgPyBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDIgOiBfcmVmJG91dGVyUmFkaXVzLFxyXG4gICAgX3JlZiRjeCA9IF9yZWYuY3gsXHJcbiAgICBjeCA9IF9yZWYkY3ggPT09IHZvaWQgMCA/IHdpZHRoIC8gMiA6IF9yZWYkY3gsXHJcbiAgICBfcmVmJGN5ID0gX3JlZi5jeSxcclxuICAgIGN5ID0gX3JlZiRjeSA9PT0gdm9pZCAwID8gaGVpZ2h0IC8gMiA6IF9yZWYkY3ksXHJcbiAgICBfcmVmJHN0YXJ0QW5nbGUgPSBfcmVmLnN0YXJ0QW5nbGUsXHJcbiAgICBzdGFydEFuZ2xlID0gX3JlZiRzdGFydEFuZ2xlID09PSB2b2lkIDAgPyAwIDogX3JlZiRzdGFydEFuZ2xlLFxyXG4gICAgX3JlZiRlbmRBbmdsZSA9IF9yZWYuZW5kQW5nbGUsXHJcbiAgICBlbmRBbmdsZSA9IF9yZWYkZW5kQW5nbGUgPT09IHZvaWQgMCA/IDM2MCA6IF9yZWYkZW5kQW5nbGUsXHJcbiAgICBvbkNsaWNrID0gX3JlZi5vbkNsaWNrLFxyXG4gICAgb25Nb3VzZUVudGVyID0gX3JlZi5vbk1vdXNlRW50ZXIsXHJcbiAgICBvbk1vdXNlTGVhdmUgPSBfcmVmLm9uTW91c2VMZWF2ZTtcclxuICB2YXIgX3VzZVN0YXRlID0gKDAsIF9yZWFjdC51c2VTdGF0ZSkoZmFsc2UpLFxyXG4gICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXHJcbiAgICBpc1Rvb2x0aXBBY3RpdmUgPSBfdXNlU3RhdGUyWzBdLFxyXG4gICAgc2V0SXNUb29sdGlwQWN0aXZlID0gX3VzZVN0YXRlMlsxXTtcclxuICB2YXIgX3VzZVN0YXRlMyA9ICgwLCBfcmVhY3QudXNlU3RhdGUpKG51bGwpLFxyXG4gICAgX3VzZVN0YXRlNCA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZTMsIDIpLFxyXG4gICAgYWN0aXZlTm9kZSA9IF91c2VTdGF0ZTRbMF0sXHJcbiAgICBzZXRBY3RpdmVOb2RlID0gX3VzZVN0YXRlNFsxXTtcclxuICB2YXIgclNjYWxlID0gKDAsIF9kM1NjYWxlLnNjYWxlTGluZWFyKShbMCwgZGF0YVtkYXRhS2V5XV0sIFswLCBlbmRBbmdsZV0pO1xyXG4gIHZhciB0cmVlRGVwdGggPSBnZXRNYXhEZXB0aE9mKGRhdGEpO1xyXG4gIHZhciB0aGlja25lc3MgPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyB0cmVlRGVwdGg7XHJcbiAgdmFyIHNlY3RvcnMgPSBbXTtcclxuICB2YXIgcG9zaXRpb25zID0gbmV3IE1hcChbXSk7XHJcblxyXG4gIC8vIGV2ZW50IGhhbmRsZXJzXHJcbiAgZnVuY3Rpb24gaGFuZGxlTW91c2VFbnRlcihub2RlLCBlKSB7XHJcbiAgICBpZiAob25Nb3VzZUVudGVyKSBvbk1vdXNlRW50ZXIobm9kZSwgZSk7XHJcbiAgICBzZXRBY3RpdmVOb2RlKG5vZGUpO1xyXG4gICAgc2V0SXNUb29sdGlwQWN0aXZlKHRydWUpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBoYW5kbGVNb3VzZUxlYXZlKG5vZGUsIGUpIHtcclxuICAgIGlmIChvbk1vdXNlTGVhdmUpIG9uTW91c2VMZWF2ZShub2RlLCBlKTtcclxuICAgIHNldEFjdGl2ZU5vZGUobnVsbCk7XHJcbiAgICBzZXRJc1Rvb2x0aXBBY3RpdmUoZmFsc2UpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBoYW5kbGVDbGljayhub2RlKSB7XHJcbiAgICBpZiAob25DbGljaykgb25DbGljayhub2RlKTtcclxuICB9XHJcblxyXG4gIC8vIHJlY3Vyc2l2ZWx5IGFkZCBub2RlcyBmb3IgZWFjaCBkYXRhIHBvaW50IGFuZCBpdHMgY2hpbGRyZW5cclxuICBmdW5jdGlvbiBkcmF3QXJjcyhjaGlsZE5vZGVzLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMsXHJcbiAgICAgIGlubmVyUiA9IG9wdGlvbnMuaW5uZXJSLFxyXG4gICAgICBpbml0aWFsQW5nbGUgPSBvcHRpb25zLmluaXRpYWxBbmdsZSxcclxuICAgICAgY2hpbGRDb2xvciA9IG9wdGlvbnMuY2hpbGRDb2xvcjtcclxuICAgIHZhciBjdXJyZW50QW5nbGUgPSBpbml0aWFsQW5nbGU7XHJcbiAgICBpZiAoIWNoaWxkTm9kZXMpIHJldHVybjsgLy8gYmFzZSBjYXNlOiBubyBjaGlsZHJlbiBvZiB0aGlzIG5vZGVcclxuXHJcbiAgICBjaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgdmFyIF9yZWYyLCBfZCRmaWxsO1xyXG4gICAgICB2YXIgYXJjTGVuZ3RoID0gclNjYWxlKGRbZGF0YUtleV0pO1xyXG4gICAgICB2YXIgc3RhcnQgPSBjdXJyZW50QW5nbGU7XHJcbiAgICAgIC8vIGNvbG9yIHByaW9yaXR5IC0gaWYgdGhlcmUncyBhIGNvbG9yIG9uIHRoZSBpbmRpdmlkdWFsIHBvaW50IHVzZSB0aGF0LCBvdGhlcndpc2UgdXNlIHBhcmVudCBjb2xvciBvciBkZWZhdWx0XHJcbiAgICAgIHZhciBmaWxsQ29sb3IgPSAoX3JlZjIgPSAoX2QkZmlsbCA9IGQgPT09IG51bGwgfHwgZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZC5maWxsKSAhPT0gbnVsbCAmJiBfZCRmaWxsICE9PSB2b2lkIDAgPyBfZCRmaWxsIDogY2hpbGRDb2xvcikgIT09IG51bGwgJiYgX3JlZjIgIT09IHZvaWQgMCA/IF9yZWYyIDogZmlsbDtcclxuICAgICAgdmFyIF9wb2xhclRvQ2FydGVzaWFuID0gKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKDAsIDAsIGlubmVyUiArIHJhZGl1cyAvIDIsIC0oc3RhcnQgKyBhcmNMZW5ndGggLSBhcmNMZW5ndGggLyAyKSksXHJcbiAgICAgICAgdGV4dFggPSBfcG9sYXJUb0NhcnRlc2lhbi54LFxyXG4gICAgICAgIHRleHRZID0gX3BvbGFyVG9DYXJ0ZXNpYW4ueTtcclxuICAgICAgY3VycmVudEFuZ2xlICs9IGFyY0xlbmd0aDtcclxuICAgICAgc2VjdG9ycy5wdXNoKFxyXG4gICAgICAvKiNfX1BVUkVfXyovXHJcbiAgICAgIC8vIFRPRE86IE1pc3Npbmcga2V5IHdhcm5pbmcuIENhbiB3ZSB1c2UgYGtleT17ZC5uYW1lfWA/XHJcbiAgICAgIF9yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImdcIiwge1xyXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBkLm5hbWUsXHJcbiAgICAgICAgdGFiSW5kZXg6IDBcclxuICAgICAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfU2VjdG9yLlNlY3Rvciwge1xyXG4gICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XHJcbiAgICAgICAgICByZXR1cm4gaGFuZGxlQ2xpY2soZCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1vdXNlRW50ZXI6IGZ1bmN0aW9uIG9uTW91c2VFbnRlcihlKSB7XHJcbiAgICAgICAgICByZXR1cm4gaGFuZGxlTW91c2VFbnRlcihkLCBlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uTW91c2VMZWF2ZTogZnVuY3Rpb24gb25Nb3VzZUxlYXZlKGUpIHtcclxuICAgICAgICAgIHJldHVybiBoYW5kbGVNb3VzZUxlYXZlKGQsIGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZmlsbDogZmlsbENvbG9yLFxyXG4gICAgICAgIHN0cm9rZTogc3Ryb2tlLFxyXG4gICAgICAgIHN0cm9rZVdpZHRoOiBwYWRkaW5nLFxyXG4gICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0LFxyXG4gICAgICAgIGVuZEFuZ2xlOiBzdGFydCArIGFyY0xlbmd0aCxcclxuICAgICAgICBpbm5lclJhZGl1czogaW5uZXJSLFxyXG4gICAgICAgIG91dGVyUmFkaXVzOiBpbm5lclIgKyByYWRpdXMsXHJcbiAgICAgICAgY3g6IGN4LFxyXG4gICAgICAgIGN5OiBjeVxyXG4gICAgICB9KSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfVGV4dC5UZXh0LCBfZXh0ZW5kcyh7fSwgdGV4dE9wdGlvbnMsIHtcclxuICAgICAgICBhbGlnbm1lbnRCYXNlbGluZTogXCJtaWRkbGVcIixcclxuICAgICAgICB0ZXh0QW5jaG9yOiBcIm1pZGRsZVwiLFxyXG4gICAgICAgIHg6IHRleHRYICsgY3gsXHJcbiAgICAgICAgeTogY3kgLSB0ZXh0WVxyXG4gICAgICB9KSwgZFtkYXRhS2V5XSkpKTtcclxuICAgICAgdmFyIF9wb2xhclRvQ2FydGVzaWFuMiA9ICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjeCwgY3ksIGlubmVyUiArIHJhZGl1cyAvIDIsIHN0YXJ0KSxcclxuICAgICAgICB0b29sdGlwWCA9IF9wb2xhclRvQ2FydGVzaWFuMi54LFxyXG4gICAgICAgIHRvb2x0aXBZID0gX3BvbGFyVG9DYXJ0ZXNpYW4yLnk7XHJcbiAgICAgIHBvc2l0aW9ucy5zZXQoZC5uYW1lLCB7XHJcbiAgICAgICAgeDogdG9vbHRpcFgsXHJcbiAgICAgICAgeTogdG9vbHRpcFlcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBkcmF3QXJjcyhkLmNoaWxkcmVuLCB7XHJcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXHJcbiAgICAgICAgaW5uZXJSOiBpbm5lclIgKyByYWRpdXMgKyByaW5nUGFkZGluZyxcclxuICAgICAgICBpbml0aWFsQW5nbGU6IHN0YXJ0LFxyXG4gICAgICAgIGNoaWxkQ29sb3I6IGZpbGxDb2xvclxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBkcmF3QXJjcyhkYXRhLmNoaWxkcmVuLCB7XHJcbiAgICByYWRpdXM6IHRoaWNrbmVzcyxcclxuICAgIGlubmVyUjogaW5uZXJSYWRpdXMsXHJcbiAgICBpbml0aWFsQW5nbGU6IHN0YXJ0QW5nbGVcclxuICB9KTtcclxuICB2YXIgbGF5ZXJDbGFzcyA9ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1zdW5idXJzdCcsIGNsYXNzTmFtZSk7XHJcbiAgZnVuY3Rpb24gcmVuZGVyVG9vbHRpcCgpIHtcclxuICAgIHZhciB0b29sdGlwQ29tcG9uZW50ID0gKDAsIF9SZWFjdFV0aWxzLmZpbmRDaGlsZEJ5VHlwZSkoW2NoaWxkcmVuXSwgX1Rvb2x0aXAuVG9vbHRpcCk7XHJcbiAgICBpZiAoIXRvb2x0aXBDb21wb25lbnQgfHwgIWFjdGl2ZU5vZGUpIHJldHVybiBudWxsO1xyXG4gICAgdmFyIHZpZXdCb3ggPSB7XHJcbiAgICAgIHg6IDAsXHJcbiAgICAgIHk6IDAsXHJcbiAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgaGVpZ2h0OiBoZWlnaHRcclxuICAgIH07XHJcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KHRvb2x0aXBDb21wb25lbnQsIHtcclxuICAgICAgdmlld0JveDogdmlld0JveCxcclxuICAgICAgY29vcmRpbmF0ZTogcG9zaXRpb25zLmdldChhY3RpdmVOb2RlLm5hbWUpLFxyXG4gICAgICBwYXlsb2FkOiBbYWN0aXZlTm9kZV0sXHJcbiAgICAgIGFjdGl2ZTogaXNUb29sdGlwQWN0aXZlXHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xyXG4gICAgY2xhc3NOYW1lOiAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtd3JhcHBlcicsIGNsYXNzTmFtZSksXHJcbiAgICBzdHlsZToge1xyXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IGhlaWdodFxyXG4gICAgfSxcclxuICAgIHJvbGU6IFwicmVnaW9uXCJcclxuICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9TdXJmYWNlLlN1cmZhY2UsIHtcclxuICAgIHdpZHRoOiB3aWR0aCxcclxuICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgfSwgY2hpbGRyZW4sIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XHJcbiAgICBjbGFzc05hbWU6IGxheWVyQ2xhc3NcclxuICB9LCBzZWN0b3JzKSksIHJlbmRlclRvb2x0aXAoKSk7XHJcbn07Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlN1bmJ1cnN0Q2hhcnQiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfZDNTY2FsZSIsIl9jbHN4IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9SZWFjdFV0aWxzIiwiX1N1cmZhY2UiLCJfTGF5ZXIiLCJfU2VjdG9yIiwiX1RleHQiLCJfUG9sYXJVdGlscyIsIl9Ub29sdGlwIiwib2JqIiwiX19lc01vZHVsZSIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwiYXBwbHkiLCJfc2xpY2VkVG9BcnJheSIsImFyciIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJUeXBlRXJyb3IiLCJsIiwiZiIsIm5leHQiLCJkb25lIiwicHVzaCIsIkFycmF5IiwiaXNBcnJheSIsIl90b0NvbnN1bWFibGVBcnJheSIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsInRvU3RyaW5nIiwic2xpY2UiLCJuYW1lIiwiZnJvbSIsInRlc3QiLCJpdGVyIiwibGVuIiwiYXJyMiIsImRlZmF1bHRUZXh0UHJvcHMiLCJmb250V2VpZ2h0IiwicGFpbnRPcmRlciIsImZvbnRTaXplIiwic3Ryb2tlIiwiZmlsbCIsInBvaW50ZXJFdmVudHMiLCJnZXRNYXhEZXB0aE9mIiwibm9kZSIsImNoaWxkcmVuIiwiY2hpbGREZXB0aHMiLCJtYXAiLCJkIiwiTWF0aCIsIm1heCIsIl9yZWYiLCJjbGFzc05hbWUiLCJkYXRhIiwid2lkdGgiLCJoZWlnaHQiLCJfcmVmJHBhZGRpbmciLCJwYWRkaW5nIiwiX3JlZiRkYXRhS2V5IiwiZGF0YUtleSIsIl9yZWYkcmluZ1BhZGRpbmciLCJyaW5nUGFkZGluZyIsIl9yZWYkaW5uZXJSYWRpdXMiLCJpbm5lclJhZGl1cyIsIl9yZWYkZmlsbCIsIl9yZWYkc3Ryb2tlIiwiX3JlZiR0ZXh0T3B0aW9ucyIsInRleHRPcHRpb25zIiwiX3JlZiRvdXRlclJhZGl1cyIsIm91dGVyUmFkaXVzIiwibWluIiwiX3JlZiRjeCIsImN4IiwiX3JlZiRjeSIsImN5IiwiX3JlZiRzdGFydEFuZ2xlIiwic3RhcnRBbmdsZSIsIl9yZWYkZW5kQW5nbGUiLCJlbmRBbmdsZSIsIm9uQ2xpY2siLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJfdXNlU3RhdGUiLCJ1c2VTdGF0ZSIsIl91c2VTdGF0ZTIiLCJpc1Rvb2x0aXBBY3RpdmUiLCJzZXRJc1Rvb2x0aXBBY3RpdmUiLCJfdXNlU3RhdGUzIiwiX3VzZVN0YXRlNCIsImFjdGl2ZU5vZGUiLCJzZXRBY3RpdmVOb2RlIiwiclNjYWxlIiwic2NhbGVMaW5lYXIiLCJ0cmVlRGVwdGgiLCJ0aGlja25lc3MiLCJzZWN0b3JzIiwicG9zaXRpb25zIiwiTWFwIiwiaGFuZGxlTW91c2VFbnRlciIsImhhbmRsZU1vdXNlTGVhdmUiLCJoYW5kbGVDbGljayIsImRyYXdBcmNzIiwiY2hpbGROb2RlcyIsIm9wdGlvbnMiLCJyYWRpdXMiLCJpbm5lclIiLCJpbml0aWFsQW5nbGUiLCJjaGlsZENvbG9yIiwiY3VycmVudEFuZ2xlIiwiZm9yRWFjaCIsIl9yZWYyIiwiX2QkZmlsbCIsImFyY0xlbmd0aCIsInN0YXJ0IiwiZmlsbENvbG9yIiwiX3BvbGFyVG9DYXJ0ZXNpYW4iLCJwb2xhclRvQ2FydGVzaWFuIiwidGV4dFgiLCJ4IiwidGV4dFkiLCJ5IiwiY3JlYXRlRWxlbWVudCIsInRhYkluZGV4IiwiU2VjdG9yIiwic3Ryb2tlV2lkdGgiLCJUZXh0IiwiYWxpZ25tZW50QmFzZWxpbmUiLCJ0ZXh0QW5jaG9yIiwiX3BvbGFyVG9DYXJ0ZXNpYW4yIiwidG9vbHRpcFgiLCJ0b29sdGlwWSIsImxheWVyQ2xhc3MiLCJyZW5kZXJUb29sdGlwIiwidG9vbHRpcENvbXBvbmVudCIsImZpbmRDaGlsZEJ5VHlwZSIsIlRvb2x0aXAiLCJ2aWV3Qm94IiwiY2xvbmVFbGVtZW50IiwiY29vcmRpbmF0ZSIsInBheWxvYWQiLCJhY3RpdmUiLCJzdHlsZSIsInBvc2l0aW9uIiwicm9sZSIsIlN1cmZhY2UiLCJMYXllciJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/chart/SunburstChart.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/chart/Treemap.js":
/*!****************************************************!*\
  !*** ./node_modules/recharts/lib/chart/Treemap.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Treemap = void 0;\nvar _isNaN = _interopRequireDefault(__webpack_require__(/*! lodash/isNaN */ \"lodash/isNaN\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _omit = _interopRequireDefault(__webpack_require__(/*! lodash/omit */ \"lodash/omit\"));\nvar _get = _interopRequireDefault(__webpack_require__(/*! lodash/get */ \"lodash/get\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _Tooltip = __webpack_require__(/*! ../component/Tooltip */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Tooltip.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _Surface = __webpack_require__(/*! ../container/Surface */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Surface.js\");\nvar _Polygon = __webpack_require__(/*! ../shape/Polygon */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Polygon.js\");\nvar _Rectangle = __webpack_require__(/*! ../shape/Rectangle */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Rectangle.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _Constants = __webpack_require__(/*! ../util/Constants */ \"(pages-dir-node)/./node_modules/recharts/lib/util/Constants.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _DOMUtils = __webpack_require__(/*! ../util/DOMUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DOMUtils.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"(pages-dir-node)/./node_modules/recharts/lib/util/Global.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"width\",\n    \"height\",\n    \"className\",\n    \"style\",\n    \"children\",\n    \"type\"\n];\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview TreemapChart\r\n */ \nvar NODE_VALUE_KEY = 'value';\nvar computeNode = function computeNode(_ref) {\n    var depth = _ref.depth, node = _ref.node, index = _ref.index, valueKey = _ref.valueKey;\n    var children = node.children;\n    var childDepth = depth + 1;\n    var computedChildren = children && children.length ? children.map(function(child, i) {\n        return computeNode({\n            depth: childDepth,\n            node: child,\n            index: i,\n            valueKey: valueKey\n        });\n    }) : null;\n    var nodeValue;\n    if (children && children.length) {\n        nodeValue = computedChildren.reduce(function(result, child) {\n            return result + child[NODE_VALUE_KEY];\n        }, 0);\n    } else {\n        // TODO need to verify valueKey\n        nodeValue = (0, _isNaN[\"default\"])(node[valueKey]) || node[valueKey] <= 0 ? 0 : node[valueKey];\n    }\n    return _objectSpread(_objectSpread({}, node), {}, _defineProperty(_defineProperty(_defineProperty({\n        children: computedChildren\n    }, NODE_VALUE_KEY, nodeValue), \"depth\", depth), \"index\", index));\n};\nvar filterRect = function filterRect(node) {\n    return {\n        x: node.x,\n        y: node.y,\n        width: node.width,\n        height: node.height\n    };\n};\n// Compute the area for each child based on value & scale.\nvar getAreaOfChildren = function getAreaOfChildren(children, areaValueRatio) {\n    var ratio = areaValueRatio < 0 ? 0 : areaValueRatio;\n    return children.map(function(child) {\n        var area = child[NODE_VALUE_KEY] * ratio;\n        return _objectSpread(_objectSpread({}, child), {}, {\n            area: (0, _isNaN[\"default\"])(area) || area <= 0 ? 0 : area\n        });\n    });\n};\n// Computes the score for the specified row, as the worst aspect ratio.\nvar getWorstScore = function getWorstScore(row, parentSize, aspectRatio) {\n    var parentArea = parentSize * parentSize;\n    var rowArea = row.area * row.area;\n    var _row$reduce = row.reduce(function(result, child) {\n        return {\n            min: Math.min(result.min, child.area),\n            max: Math.max(result.max, child.area)\n        };\n    }, {\n        min: Infinity,\n        max: 0\n    }), min = _row$reduce.min, max = _row$reduce.max;\n    return rowArea ? Math.max(parentArea * max * aspectRatio / rowArea, rowArea / (parentArea * min * aspectRatio)) : Infinity;\n};\nvar horizontalPosition = function horizontalPosition(row, parentSize, parentRect, isFlush) {\n    var rowHeight = parentSize ? Math.round(row.area / parentSize) : 0;\n    if (isFlush || rowHeight > parentRect.height) {\n        rowHeight = parentRect.height;\n    }\n    var curX = parentRect.x;\n    var child;\n    for(var i = 0, len = row.length; i < len; i++){\n        child = row[i];\n        child.x = curX;\n        child.y = parentRect.y;\n        child.height = rowHeight;\n        child.width = Math.min(rowHeight ? Math.round(child.area / rowHeight) : 0, parentRect.x + parentRect.width - curX);\n        curX += child.width;\n    }\n    // add the remain x to the last one of row\n    child.width += parentRect.x + parentRect.width - curX;\n    return _objectSpread(_objectSpread({}, parentRect), {}, {\n        y: parentRect.y + rowHeight,\n        height: parentRect.height - rowHeight\n    });\n};\nvar verticalPosition = function verticalPosition(row, parentSize, parentRect, isFlush) {\n    var rowWidth = parentSize ? Math.round(row.area / parentSize) : 0;\n    if (isFlush || rowWidth > parentRect.width) {\n        rowWidth = parentRect.width;\n    }\n    var curY = parentRect.y;\n    var child;\n    for(var i = 0, len = row.length; i < len; i++){\n        child = row[i];\n        child.x = parentRect.x;\n        child.y = curY;\n        child.width = rowWidth;\n        child.height = Math.min(rowWidth ? Math.round(child.area / rowWidth) : 0, parentRect.y + parentRect.height - curY);\n        curY += child.height;\n    }\n    if (child) {\n        child.height += parentRect.y + parentRect.height - curY;\n    }\n    return _objectSpread(_objectSpread({}, parentRect), {}, {\n        x: parentRect.x + rowWidth,\n        width: parentRect.width - rowWidth\n    });\n};\nvar position = function position(row, parentSize, parentRect, isFlush) {\n    if (parentSize === parentRect.width) {\n        return horizontalPosition(row, parentSize, parentRect, isFlush);\n    }\n    return verticalPosition(row, parentSize, parentRect, isFlush);\n};\n// Recursively arranges the specified node's children into squarified rows.\nvar squarify = function squarify(node, aspectRatio) {\n    var children = node.children;\n    if (children && children.length) {\n        var rect = filterRect(node);\n        // maybe a bug\n        var row = [];\n        var best = Infinity; // the best row score so far\n        var child, score; // the current row score\n        var size = Math.min(rect.width, rect.height); // initial orientation\n        var scaleChildren = getAreaOfChildren(children, rect.width * rect.height / node[NODE_VALUE_KEY]);\n        var tempChildren = scaleChildren.slice();\n        row.area = 0;\n        while(tempChildren.length > 0){\n            // row first\n            // eslint-disable-next-line prefer-destructuring\n            row.push(child = tempChildren[0]);\n            row.area += child.area;\n            score = getWorstScore(row, size, aspectRatio);\n            if (score <= best) {\n                // continue with this orientation\n                tempChildren.shift();\n                best = score;\n            } else {\n                // abort, and try a different orientation\n                row.area -= row.pop().area;\n                rect = position(row, size, rect, false);\n                size = Math.min(rect.width, rect.height);\n                row.length = row.area = 0;\n                best = Infinity;\n            }\n        }\n        if (row.length) {\n            rect = position(row, size, rect, true);\n            row.length = row.area = 0;\n        }\n        return _objectSpread(_objectSpread({}, node), {}, {\n            children: scaleChildren.map(function(c) {\n                return squarify(c, aspectRatio);\n            })\n        });\n    }\n    return node;\n};\nvar defaultState = {\n    isTooltipActive: false,\n    isAnimationFinished: false,\n    activeNode: null,\n    formatRoot: null,\n    currentRoot: null,\n    nestIndex: []\n};\nvar Treemap = exports.Treemap = /*#__PURE__*/ function(_PureComponent) {\n    function Treemap() {\n        var _this;\n        _classCallCheck(this, Treemap);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, Treemap, [].concat(args));\n        _defineProperty(_this, \"state\", _objectSpread({}, defaultState));\n        _defineProperty(_this, \"handleAnimationEnd\", function() {\n            var onAnimationEnd = _this.props.onAnimationEnd;\n            _this.setState({\n                isAnimationFinished: true\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationEnd)) {\n                onAnimationEnd();\n            }\n        });\n        _defineProperty(_this, \"handleAnimationStart\", function() {\n            var onAnimationStart = _this.props.onAnimationStart;\n            _this.setState({\n                isAnimationFinished: false\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationStart)) {\n                onAnimationStart();\n            }\n        });\n        return _this;\n    }\n    _inherits(Treemap, _PureComponent);\n    return _createClass(Treemap, [\n        {\n            key: \"handleMouseEnter\",\n            value: function handleMouseEnter(node, e) {\n                e.persist();\n                var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, children = _this$props.children;\n                var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                if (tooltipItem) {\n                    this.setState({\n                        isTooltipActive: true,\n                        activeNode: node\n                    }, function() {\n                        if (onMouseEnter) {\n                            onMouseEnter(node, e);\n                        }\n                    });\n                } else if (onMouseEnter) {\n                    onMouseEnter(node, e);\n                }\n            }\n        },\n        {\n            key: \"handleMouseLeave\",\n            value: function handleMouseLeave(node, e) {\n                e.persist();\n                var _this$props2 = this.props, onMouseLeave = _this$props2.onMouseLeave, children = _this$props2.children;\n                var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                if (tooltipItem) {\n                    this.setState({\n                        isTooltipActive: false,\n                        activeNode: null\n                    }, function() {\n                        if (onMouseLeave) {\n                            onMouseLeave(node, e);\n                        }\n                    });\n                } else if (onMouseLeave) {\n                    onMouseLeave(node, e);\n                }\n            }\n        },\n        {\n            key: \"handleClick\",\n            value: function handleClick(node) {\n                var _this$props3 = this.props, onClick = _this$props3.onClick, type = _this$props3.type;\n                if (type === 'nest' && node.children) {\n                    var _this$props4 = this.props, width = _this$props4.width, height = _this$props4.height, dataKey = _this$props4.dataKey, aspectRatio = _this$props4.aspectRatio;\n                    var root = computeNode({\n                        depth: 0,\n                        node: _objectSpread(_objectSpread({}, node), {}, {\n                            x: 0,\n                            y: 0,\n                            width: width,\n                            height: height\n                        }),\n                        index: 0,\n                        valueKey: dataKey\n                    });\n                    var formatRoot = squarify(root, aspectRatio);\n                    var nestIndex = this.state.nestIndex;\n                    nestIndex.push(node);\n                    this.setState({\n                        formatRoot: formatRoot,\n                        currentRoot: root,\n                        nestIndex: nestIndex\n                    });\n                }\n                if (onClick) {\n                    onClick(node);\n                }\n            }\n        },\n        {\n            key: \"handleNestIndex\",\n            value: function handleNestIndex(node, i) {\n                var nestIndex = this.state.nestIndex;\n                var _this$props5 = this.props, width = _this$props5.width, height = _this$props5.height, dataKey = _this$props5.dataKey, aspectRatio = _this$props5.aspectRatio;\n                var root = computeNode({\n                    depth: 0,\n                    node: _objectSpread(_objectSpread({}, node), {}, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    }),\n                    index: 0,\n                    valueKey: dataKey\n                });\n                var formatRoot = squarify(root, aspectRatio);\n                nestIndex = nestIndex.slice(0, i + 1);\n                this.setState({\n                    formatRoot: formatRoot,\n                    currentRoot: node,\n                    nestIndex: nestIndex\n                });\n            }\n        },\n        {\n            key: \"renderItem\",\n            value: function renderItem(content, nodeProps, isLeaf) {\n                var _this2 = this;\n                var _this$props6 = this.props, isAnimationActive = _this$props6.isAnimationActive, animationBegin = _this$props6.animationBegin, animationDuration = _this$props6.animationDuration, animationEasing = _this$props6.animationEasing, isUpdateAnimationActive = _this$props6.isUpdateAnimationActive, type = _this$props6.type, animationId = _this$props6.animationId, colorPanel = _this$props6.colorPanel;\n                var isAnimationFinished = this.state.isAnimationFinished;\n                var width = nodeProps.width, height = nodeProps.height, x = nodeProps.x, y = nodeProps.y, depth = nodeProps.depth;\n                var translateX = parseInt(\"\".concat((Math.random() * 2 - 1) * width), 10);\n                var event = {};\n                if (isLeaf || type === 'nest') {\n                    event = {\n                        onMouseEnter: this.handleMouseEnter.bind(this, nodeProps),\n                        onMouseLeave: this.handleMouseLeave.bind(this, nodeProps),\n                        onClick: this.handleClick.bind(this, nodeProps)\n                    };\n                }\n                if (!isAnimationActive) {\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, event, this.constructor.renderContentItem(content, _objectSpread(_objectSpread({}, nodeProps), {}, {\n                        isAnimationActive: false,\n                        isUpdateAnimationActive: false,\n                        width: width,\n                        height: height,\n                        x: x,\n                        y: y\n                    }), type, colorPanel));\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n                    begin: animationBegin,\n                    duration: animationDuration,\n                    isActive: isAnimationActive,\n                    easing: animationEasing,\n                    key: \"treemap-\".concat(animationId),\n                    from: {\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    },\n                    to: {\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    },\n                    onAnimationStart: this.handleAnimationStart,\n                    onAnimationEnd: this.handleAnimationEnd\n                }, function(_ref2) {\n                    var currX = _ref2.x, currY = _ref2.y, currWidth = _ref2.width, currHeight = _ref2.height;\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n                        from: \"translate(\".concat(translateX, \"px, \").concat(translateX, \"px)\"),\n                        to: \"translate(0, 0)\",\n                        attributeName: \"transform\",\n                        begin: animationBegin,\n                        easing: animationEasing,\n                        isActive: isAnimationActive,\n                        duration: animationDuration\n                    }, /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, event, function() {\n                        // when animation Duration , only render depth=1 nodes\n                        if (depth > 2 && !isAnimationFinished) {\n                            return null;\n                        }\n                        return _this2.constructor.renderContentItem(content, _objectSpread(_objectSpread({}, nodeProps), {}, {\n                            isAnimationActive: isAnimationActive,\n                            isUpdateAnimationActive: !isUpdateAnimationActive,\n                            width: currWidth,\n                            height: currHeight,\n                            x: currX,\n                            y: currY\n                        }), type, colorPanel);\n                    }()));\n                });\n            }\n        },\n        {\n            key: \"renderNode\",\n            value: function renderNode(root, node) {\n                var _this3 = this;\n                var _this$props7 = this.props, content = _this$props7.content, type = _this$props7.type;\n                var nodeProps = _objectSpread(_objectSpread(_objectSpread({}, (0, _ReactUtils.filterProps)(this.props, false)), node), {}, {\n                    root: root\n                });\n                var isLeaf = !node.children || !node.children.length;\n                var currentRoot = this.state.currentRoot;\n                var isCurrentRootChild = (currentRoot.children || []).filter(function(item) {\n                    return item.depth === node.depth && item.name === node.name;\n                });\n                if (!isCurrentRootChild.length && root.depth && type === 'nest') {\n                    return null;\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    key: \"recharts-treemap-node-\".concat(nodeProps.x, \"-\").concat(nodeProps.y, \"-\").concat(nodeProps.name),\n                    className: \"recharts-treemap-depth-\".concat(node.depth)\n                }, this.renderItem(content, nodeProps, isLeaf), node.children && node.children.length ? node.children.map(function(child) {\n                    return _this3.renderNode(node, child);\n                }) : null);\n            }\n        },\n        {\n            key: \"renderAllNodes\",\n            value: function renderAllNodes() {\n                var formatRoot = this.state.formatRoot;\n                if (!formatRoot) {\n                    return null;\n                }\n                return this.renderNode(formatRoot, formatRoot);\n            }\n        },\n        {\n            key: \"renderTooltip\",\n            value: function renderTooltip() {\n                var _this$props8 = this.props, children = _this$props8.children, nameKey = _this$props8.nameKey;\n                var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                if (!tooltipItem) {\n                    return null;\n                }\n                var _this$props9 = this.props, width = _this$props9.width, height = _this$props9.height;\n                var _this$state = this.state, isTooltipActive = _this$state.isTooltipActive, activeNode = _this$state.activeNode;\n                var viewBox = {\n                    x: 0,\n                    y: 0,\n                    width: width,\n                    height: height\n                };\n                var coordinate = activeNode ? {\n                    x: activeNode.x + activeNode.width / 2,\n                    y: activeNode.y + activeNode.height / 2\n                } : null;\n                var payload = isTooltipActive && activeNode ? [\n                    {\n                        payload: activeNode,\n                        name: (0, _ChartUtils.getValueByDataKey)(activeNode, nameKey, ''),\n                        value: (0, _ChartUtils.getValueByDataKey)(activeNode, NODE_VALUE_KEY)\n                    }\n                ] : [];\n                return /*#__PURE__*/ _react[\"default\"].cloneElement(tooltipItem, {\n                    viewBox: viewBox,\n                    active: isTooltipActive,\n                    coordinate: coordinate,\n                    label: '',\n                    payload: payload\n                });\n            }\n        },\n        {\n            key: \"renderNestIndex\",\n            value: function renderNestIndex() {\n                var _this4 = this;\n                var _this$props10 = this.props, nameKey = _this$props10.nameKey, nestIndexContent = _this$props10.nestIndexContent;\n                var nestIndex = this.state.nestIndex;\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n                    className: \"recharts-treemap-nest-index-wrapper\",\n                    style: {\n                        marginTop: '8px',\n                        textAlign: 'center'\n                    }\n                }, nestIndex.map(function(item, i) {\n                    // TODO need to verify nameKey type\n                    var name = (0, _get[\"default\"])(item, nameKey, 'root');\n                    var content = null;\n                    if (/*#__PURE__*/ _react[\"default\"].isValidElement(nestIndexContent)) {\n                        content = /*#__PURE__*/ _react[\"default\"].cloneElement(nestIndexContent, item, i);\n                    }\n                    if ((0, _isFunction[\"default\"])(nestIndexContent)) {\n                        content = nestIndexContent(item, i);\n                    } else {\n                        content = name;\n                    }\n                    return(/*#__PURE__*/ // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions\n                    _react[\"default\"].createElement(\"div\", {\n                        onClick: _this4.handleNestIndex.bind(_this4, item, i),\n                        key: \"nest-index-\".concat((0, _DataUtils.uniqueId)()),\n                        className: \"recharts-treemap-nest-index-box\",\n                        style: {\n                            cursor: 'pointer',\n                            display: 'inline-block',\n                            padding: '0 7px',\n                            background: '#000',\n                            color: '#fff',\n                            marginRight: '3px'\n                        }\n                    }, content));\n                }));\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                if (!(0, _ReactUtils.validateWidthHeight)(this)) {\n                    return null;\n                }\n                var _this$props11 = this.props, width = _this$props11.width, height = _this$props11.height, className = _this$props11.className, style = _this$props11.style, children = _this$props11.children, type = _this$props11.type, others = _objectWithoutProperties(_this$props11, _excluded);\n                var attrs = (0, _ReactUtils.filterProps)(others, false);\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n                    className: (0, _clsx[\"default\"])('recharts-wrapper', className),\n                    style: _objectSpread(_objectSpread({}, style), {}, {\n                        position: 'relative',\n                        cursor: 'default',\n                        width: width,\n                        height: height\n                    }),\n                    role: \"region\"\n                }, /*#__PURE__*/ _react[\"default\"].createElement(_Surface.Surface, _extends({}, attrs, {\n                    width: width,\n                    height: type === 'nest' ? height - 30 : height\n                }), this.renderAllNodes(), (0, _ReactUtils.filterSvgElements)(children)), this.renderTooltip(), type === 'nest' && this.renderNestIndex());\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                if (nextProps.data !== prevState.prevData || nextProps.type !== prevState.prevType || nextProps.width !== prevState.prevWidth || nextProps.height !== prevState.prevHeight || nextProps.dataKey !== prevState.prevDataKey || nextProps.aspectRatio !== prevState.prevAspectRatio) {\n                    var root = computeNode({\n                        depth: 0,\n                        node: {\n                            children: nextProps.data,\n                            x: 0,\n                            y: 0,\n                            width: nextProps.width,\n                            height: nextProps.height\n                        },\n                        index: 0,\n                        valueKey: nextProps.dataKey\n                    });\n                    var formatRoot = squarify(root, nextProps.aspectRatio);\n                    return _objectSpread(_objectSpread({}, prevState), {}, {\n                        formatRoot: formatRoot,\n                        currentRoot: root,\n                        nestIndex: [\n                            root\n                        ],\n                        prevAspectRatio: nextProps.aspectRatio,\n                        prevData: nextProps.data,\n                        prevWidth: nextProps.width,\n                        prevHeight: nextProps.height,\n                        prevDataKey: nextProps.dataKey,\n                        prevType: nextProps.type\n                    });\n                }\n                return null;\n            }\n        },\n        {\n            key: \"renderContentItem\",\n            value: function renderContentItem(content, nodeProps, type, colorPanel) {\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(content)) {\n                    return /*#__PURE__*/ _react[\"default\"].cloneElement(content, nodeProps);\n                }\n                if ((0, _isFunction[\"default\"])(content)) {\n                    return content(nodeProps);\n                }\n                // optimize default shape\n                var x = nodeProps.x, y = nodeProps.y, width = nodeProps.width, height = nodeProps.height, index = nodeProps.index;\n                var arrow = null;\n                if (width > 10 && height > 10 && nodeProps.children && type === 'nest') {\n                    arrow = /*#__PURE__*/ _react[\"default\"].createElement(_Polygon.Polygon, {\n                        points: [\n                            {\n                                x: x + 2,\n                                y: y + height / 2\n                            },\n                            {\n                                x: x + 6,\n                                y: y + height / 2 + 3\n                            },\n                            {\n                                x: x + 2,\n                                y: y + height / 2 + 6\n                            }\n                        ]\n                    });\n                }\n                var text = null;\n                var nameSize = (0, _DOMUtils.getStringSize)(nodeProps.name);\n                if (width > 20 && height > 20 && nameSize.width < width && nameSize.height < height) {\n                    text = /*#__PURE__*/ _react[\"default\"].createElement(\"text\", {\n                        x: x + 8,\n                        y: y + height / 2 + 7,\n                        fontSize: 14\n                    }, nodeProps.name);\n                }\n                var colors = colorPanel || _Constants.COLOR_PANEL;\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", null, /*#__PURE__*/ _react[\"default\"].createElement(_Rectangle.Rectangle, _extends({\n                    fill: nodeProps.depth < 2 ? colors[index % colors.length] : 'rgba(255,255,255,0)',\n                    stroke: \"#fff\"\n                }, (0, _omit[\"default\"])(nodeProps, 'children'), {\n                    role: \"img\"\n                })), arrow, text);\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(Treemap, \"displayName\", 'Treemap');\n_defineProperty(Treemap, \"defaultProps\", {\n    aspectRatio: 0.5 * (1 + Math.sqrt(5)),\n    dataKey: 'value',\n    type: 'flat',\n    isAnimationActive: !_Global.Global.isSsr,\n    isUpdateAnimationActive: !_Global.Global.isSsr,\n    animationBegin: 0,\n    animationDuration: 1500,\n    animationEasing: 'linear'\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvVHJlZW1hcC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsZUFBZSxHQUFHLEtBQUs7QUFDdkIsSUFBSUcsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJQyxjQUFjRix1QkFBdUJDLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJRSxRQUFRSCx1QkFBdUJDLG1CQUFPQSxDQUFDLGdDQUFhO0FBQ3hELElBQUlHLE9BQU9KLHVCQUF1QkMsbUJBQU9BLENBQUMsOEJBQVk7QUFDdEQsSUFBSUksUUFBUUwsdUJBQXVCQyxtQkFBT0EsQ0FBQyx1QkFBTTtBQUNqRCxJQUFJSyxTQUFTQyx3QkFBd0JOLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3BELElBQUlPLGVBQWVSLHVCQUF1QkMsbUJBQU9BLENBQUMsa0NBQWM7QUFDaEUsSUFBSVEsV0FBV1IsbUJBQU9BLENBQUMsK0ZBQXNCO0FBQzdDLElBQUlTLFNBQVNULG1CQUFPQSxDQUFDLDJGQUFvQjtBQUN6QyxJQUFJVSxXQUFXVixtQkFBT0EsQ0FBQywrRkFBc0I7QUFDN0MsSUFBSVcsV0FBV1gsbUJBQU9BLENBQUMsdUZBQWtCO0FBQ3pDLElBQUlZLGFBQWFaLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM3QyxJQUFJYSxjQUFjYixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDOUMsSUFBSWMsYUFBYWQsbUJBQU9BLENBQUMseUZBQW1CO0FBQzVDLElBQUllLGFBQWFmLG1CQUFPQSxDQUFDLHlGQUFtQjtBQUM1QyxJQUFJZ0IsWUFBWWhCLG1CQUFPQSxDQUFDLHVGQUFrQjtBQUMxQyxJQUFJaUIsVUFBVWpCLG1CQUFPQSxDQUFDLG1GQUFnQjtBQUN0QyxJQUFJa0IsY0FBY2xCLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM5QyxJQUFJbUIsWUFBWTtJQUFDO0lBQVM7SUFBVTtJQUFhO0lBQVM7SUFBWTtDQUFPO0FBQzdFLFNBQVNDLHlCQUF5QkMsQ0FBQztJQUFJLElBQUksY0FBYyxPQUFPQyxTQUFTLE9BQU87SUFBTSxJQUFJQyxJQUFJLElBQUlELFdBQVdFLElBQUksSUFBSUY7SUFBVyxPQUFPLENBQUNGLDJCQUEyQixTQUFTQSx5QkFBeUJDLENBQUM7UUFBSSxPQUFPQSxJQUFJRyxJQUFJRDtJQUFHLEdBQUdGO0FBQUk7QUFDbk8sU0FBU2Ysd0JBQXdCZSxDQUFDLEVBQUVFLENBQUM7SUFBSSxJQUFJLENBQUNBLEtBQUtGLEtBQUtBLEVBQUVJLFVBQVUsRUFBRSxPQUFPSjtJQUFHLElBQUksU0FBU0EsS0FBSyxZQUFZSyxRQUFRTCxNQUFNLGNBQWMsT0FBT0EsR0FBRyxPQUFPO1FBQUUsV0FBV0E7SUFBRTtJQUFHLElBQUlHLElBQUlKLHlCQUF5Qkc7SUFBSSxJQUFJQyxLQUFLQSxFQUFFRyxHQUFHLENBQUNOLElBQUksT0FBT0csRUFBRUksR0FBRyxDQUFDUDtJQUFJLElBQUlRLElBQUk7UUFBRUMsV0FBVztJQUFLLEdBQUdDLElBQUl0QyxPQUFPQyxjQUFjLElBQUlELE9BQU91Qyx3QkFBd0I7SUFBRSxJQUFLLElBQUlDLEtBQUtaLEVBQUcsSUFBSSxjQUFjWSxLQUFLLEVBQUMsR0FBRUMsY0FBYyxDQUFDQyxJQUFJLENBQUNkLEdBQUdZLElBQUk7UUFBRSxJQUFJRyxJQUFJTCxJQUFJdEMsT0FBT3VDLHdCQUF3QixDQUFDWCxHQUFHWSxLQUFLO1FBQU1HLEtBQU1BLENBQUFBLEVBQUVSLEdBQUcsSUFBSVEsRUFBRUMsR0FBRyxJQUFJNUMsT0FBT0MsY0FBYyxDQUFDbUMsR0FBR0ksR0FBR0csS0FBS1AsQ0FBQyxDQUFDSSxFQUFFLEdBQUdaLENBQUMsQ0FBQ1ksRUFBRTtJQUFFO0lBQUUsT0FBT0osQ0FBQyxDQUFDLFVBQVUsR0FBR1IsR0FBR0csS0FBS0EsRUFBRWEsR0FBRyxDQUFDaEIsR0FBR1EsSUFBSUE7QUFBRztBQUN6a0IsU0FBUzlCLHVCQUF1QnVDLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJYixVQUFVLEdBQUdhLE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU1osUUFBUWEsQ0FBQztJQUFJO0lBQTJCLE9BQU9iLFVBQVUsY0FBYyxPQUFPYyxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUUsV0FBVyxLQUFLQyxVQUFVRCxNQUFNQyxPQUFPRSxTQUFTLEdBQUcsV0FBVyxPQUFPSDtJQUFHLEdBQUdiLFFBQVFhO0FBQUk7QUFDN1QsU0FBU0k7SUFBYUEsV0FBV2xELE9BQU9tRCxNQUFNLEdBQUduRCxPQUFPbUQsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVUMsTUFBTTtRQUFJLElBQUssSUFBSVYsSUFBSSxHQUFHQSxJQUFJVyxVQUFVQyxNQUFNLEVBQUVaLElBQUs7WUFBRSxJQUFJYSxTQUFTRixTQUFTLENBQUNYLEVBQUU7WUFBRSxJQUFLLElBQUljLE9BQU9ELE9BQVE7Z0JBQUUsSUFBSXhELE9BQU9pRCxTQUFTLENBQUNSLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDYyxRQUFRQyxNQUFNO29CQUFFSixNQUFNLENBQUNJLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO2dCQUFFO1lBQUU7UUFBRTtRQUFFLE9BQU9KO0lBQVE7SUFBRyxPQUFPSCxTQUFTUSxLQUFLLENBQUMsSUFBSSxFQUFFSjtBQUFZO0FBQ2xWLFNBQVNLLHlCQUF5QkgsTUFBTSxFQUFFSSxRQUFRO0lBQUksSUFBSUosVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUFHLElBQUlILFNBQVNRLDhCQUE4QkwsUUFBUUk7SUFBVyxJQUFJSCxLQUFLZDtJQUFHLElBQUkzQyxPQUFPOEQscUJBQXFCLEVBQUU7UUFBRSxJQUFJQyxtQkFBbUIvRCxPQUFPOEQscUJBQXFCLENBQUNOO1FBQVMsSUFBS2IsSUFBSSxHQUFHQSxJQUFJb0IsaUJBQWlCUixNQUFNLEVBQUVaLElBQUs7WUFBRWMsTUFBTU0sZ0JBQWdCLENBQUNwQixFQUFFO1lBQUUsSUFBSWlCLFNBQVNJLE9BQU8sQ0FBQ1AsUUFBUSxHQUFHO1lBQVUsSUFBSSxDQUFDekQsT0FBT2lELFNBQVMsQ0FBQ2dCLG9CQUFvQixDQUFDdkIsSUFBSSxDQUFDYyxRQUFRQyxNQUFNO1lBQVVKLE1BQU0sQ0FBQ0ksSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7UUFBRTtJQUFFO0lBQUUsT0FBT0o7QUFBUTtBQUMzZSxTQUFTUSw4QkFBOEJMLE1BQU0sRUFBRUksUUFBUTtJQUFJLElBQUlKLFVBQVUsTUFBTSxPQUFPLENBQUM7SUFBRyxJQUFJSCxTQUFTLENBQUM7SUFBRyxJQUFLLElBQUlJLE9BQU9ELE9BQVE7UUFBRSxJQUFJeEQsT0FBT2lELFNBQVMsQ0FBQ1IsY0FBYyxDQUFDQyxJQUFJLENBQUNjLFFBQVFDLE1BQU07WUFBRSxJQUFJRyxTQUFTSSxPQUFPLENBQUNQLFFBQVEsR0FBRztZQUFVSixNQUFNLENBQUNJLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO1FBQUU7SUFBRTtJQUFFLE9BQU9KO0FBQVE7QUFDdFIsU0FBU2EsZ0JBQWdCQyxRQUFRLEVBQUVDLFdBQVc7SUFBSSxJQUFJLENBQUVELENBQUFBLG9CQUFvQkMsV0FBVSxHQUFJO1FBQUUsTUFBTSxJQUFJQyxVQUFVO0lBQXNDO0FBQUU7QUFDeEosU0FBU0Msa0JBQWtCakIsTUFBTSxFQUFFa0IsS0FBSztJQUFJLElBQUssSUFBSTVCLElBQUksR0FBR0EsSUFBSTRCLE1BQU1oQixNQUFNLEVBQUVaLElBQUs7UUFBRSxJQUFJNkIsYUFBYUQsS0FBSyxDQUFDNUIsRUFBRTtRQUFFNkIsV0FBV0MsVUFBVSxHQUFHRCxXQUFXQyxVQUFVLElBQUk7UUFBT0QsV0FBV0UsWUFBWSxHQUFHO1FBQU0sSUFBSSxXQUFXRixZQUFZQSxXQUFXRyxRQUFRLEdBQUc7UUFBTTNFLE9BQU9DLGNBQWMsQ0FBQ29ELFFBQVF1QixlQUFlSixXQUFXZixHQUFHLEdBQUdlO0lBQWE7QUFBRTtBQUM1VSxTQUFTSyxhQUFhVCxXQUFXLEVBQUVVLFVBQVUsRUFBRUMsV0FBVztJQUFJLElBQUlELFlBQVlSLGtCQUFrQkYsWUFBWW5CLFNBQVMsRUFBRTZCO0lBQWEsSUFBSUMsYUFBYVQsa0JBQWtCRixhQUFhVztJQUFjL0UsT0FBT0MsY0FBYyxDQUFDbUUsYUFBYSxhQUFhO1FBQUVPLFVBQVU7SUFBTTtJQUFJLE9BQU9QO0FBQWE7QUFDNVIsU0FBU1ksV0FBV2pELENBQUMsRUFBRWUsQ0FBQyxFQUFFbEIsQ0FBQztJQUFJLE9BQU9rQixJQUFJbUMsZ0JBQWdCbkMsSUFBSW9DLDJCQUEyQm5ELEdBQUdvRCw4QkFBOEJDLFFBQVFDLFNBQVMsQ0FBQ3ZDLEdBQUdsQixLQUFLLEVBQUUsRUFBRXFELGdCQUFnQmxELEdBQUcsV0FBVyxJQUFJZSxFQUFFWSxLQUFLLENBQUMzQixHQUFHSDtBQUFLO0FBQzFNLFNBQVNzRCwyQkFBMkJJLElBQUksRUFBRTVDLElBQUk7SUFBSSxJQUFJQSxRQUFTVCxDQUFBQSxRQUFRUyxVQUFVLFlBQVksT0FBT0EsU0FBUyxVQUFTLEdBQUk7UUFBRSxPQUFPQTtJQUFNLE9BQU8sSUFBSUEsU0FBUyxLQUFLLEdBQUc7UUFBRSxNQUFNLElBQUkyQixVQUFVO0lBQTZEO0lBQUUsT0FBT2tCLHVCQUF1QkQ7QUFBTztBQUMvUixTQUFTQyx1QkFBdUJELElBQUk7SUFBSSxJQUFJQSxTQUFTLEtBQUssR0FBRztRQUFFLE1BQU0sSUFBSUUsZUFBZTtJQUE4RDtJQUFFLE9BQU9GO0FBQU07QUFDckssU0FBU0g7SUFBOEIsSUFBSTtRQUFFLElBQUlwRCxJQUFJLENBQUMwRCxRQUFReEMsU0FBUyxDQUFDeUMsT0FBTyxDQUFDaEQsSUFBSSxDQUFDMEMsUUFBUUMsU0FBUyxDQUFDSSxTQUFTLEVBQUUsRUFBRSxZQUFhO0lBQUssRUFBRSxPQUFPMUQsR0FBRyxDQUFDO0lBQUUsT0FBTyxDQUFDb0QsNEJBQTRCLFNBQVNBO1FBQThCLE9BQU8sQ0FBQyxDQUFDcEQ7SUFBRztBQUFNO0FBQ2xQLFNBQVNrRCxnQkFBZ0JuQyxDQUFDO0lBQUltQyxrQkFBa0JqRixPQUFPMkYsY0FBYyxHQUFHM0YsT0FBTzRGLGNBQWMsQ0FBQ3hDLElBQUksS0FBSyxTQUFTNkIsZ0JBQWdCbkMsQ0FBQztRQUFJLE9BQU9BLEVBQUVULFNBQVMsSUFBSXJDLE9BQU80RixjQUFjLENBQUM5QztJQUFJO0lBQUcsT0FBT21DLGdCQUFnQm5DO0FBQUk7QUFDbk4sU0FBUytDLFVBQVVDLFFBQVEsRUFBRUMsVUFBVTtJQUFJLElBQUksT0FBT0EsZUFBZSxjQUFjQSxlQUFlLE1BQU07UUFBRSxNQUFNLElBQUkxQixVQUFVO0lBQXVEO0lBQUV5QixTQUFTN0MsU0FBUyxHQUFHakQsT0FBT2dHLE1BQU0sQ0FBQ0QsY0FBY0EsV0FBVzlDLFNBQVMsRUFBRTtRQUFFLGFBQWE7WUFBRTlDLE9BQU8yRjtZQUFVbkIsVUFBVTtZQUFNRCxjQUFjO1FBQUs7SUFBRTtJQUFJMUUsT0FBT0MsY0FBYyxDQUFDNkYsVUFBVSxhQUFhO1FBQUVuQixVQUFVO0lBQU07SUFBSSxJQUFJb0IsWUFBWUUsZ0JBQWdCSCxVQUFVQztBQUFhO0FBQ25jLFNBQVNFLGdCQUFnQm5ELENBQUMsRUFBRW9ELENBQUM7SUFBSUQsa0JBQWtCakcsT0FBTzJGLGNBQWMsR0FBRzNGLE9BQU8yRixjQUFjLENBQUN2QyxJQUFJLEtBQUssU0FBUzZDLGdCQUFnQm5ELENBQUMsRUFBRW9ELENBQUM7UUFBSXBELEVBQUVULFNBQVMsR0FBRzZEO1FBQUcsT0FBT3BEO0lBQUc7SUFBRyxPQUFPbUQsZ0JBQWdCbkQsR0FBR29EO0FBQUk7QUFDdk0sU0FBU0MsUUFBUXZFLENBQUMsRUFBRUUsQ0FBQztJQUFJLElBQUlDLElBQUkvQixPQUFPb0csSUFBSSxDQUFDeEU7SUFBSSxJQUFJNUIsT0FBTzhELHFCQUFxQixFQUFFO1FBQUUsSUFBSWhCLElBQUk5QyxPQUFPOEQscUJBQXFCLENBQUNsQztRQUFJRSxLQUFNZ0IsQ0FBQUEsSUFBSUEsRUFBRXVELE1BQU0sQ0FBQyxTQUFVdkUsQ0FBQztZQUFJLE9BQU85QixPQUFPdUMsd0JBQXdCLENBQUNYLEdBQUdFLEdBQUcyQyxVQUFVO1FBQUUsRUFBQyxHQUFJMUMsRUFBRXVFLElBQUksQ0FBQzVDLEtBQUssQ0FBQzNCLEdBQUdlO0lBQUk7SUFBRSxPQUFPZjtBQUFHO0FBQzlQLFNBQVN3RSxjQUFjM0UsQ0FBQztJQUFJLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJd0IsVUFBVUMsTUFBTSxFQUFFekIsSUFBSztRQUFFLElBQUlDLElBQUksUUFBUXVCLFNBQVMsQ0FBQ3hCLEVBQUUsR0FBR3dCLFNBQVMsQ0FBQ3hCLEVBQUUsR0FBRyxDQUFDO1FBQUdBLElBQUksSUFBSXFFLFFBQVFuRyxPQUFPK0IsSUFBSSxDQUFDLEdBQUd5RSxPQUFPLENBQUMsU0FBVTFFLENBQUM7WUFBSTJFLGdCQUFnQjdFLEdBQUdFLEdBQUdDLENBQUMsQ0FBQ0QsRUFBRTtRQUFHLEtBQUs5QixPQUFPMEcseUJBQXlCLEdBQUcxRyxPQUFPMkcsZ0JBQWdCLENBQUMvRSxHQUFHNUIsT0FBTzBHLHlCQUF5QixDQUFDM0UsTUFBTW9FLFFBQVFuRyxPQUFPK0IsSUFBSXlFLE9BQU8sQ0FBQyxTQUFVMUUsQ0FBQztZQUFJOUIsT0FBT0MsY0FBYyxDQUFDMkIsR0FBR0UsR0FBRzlCLE9BQU91Qyx3QkFBd0IsQ0FBQ1IsR0FBR0Q7UUFBSztJQUFJO0lBQUUsT0FBT0Y7QUFBRztBQUN0YixTQUFTNkUsZ0JBQWdCNUQsR0FBRyxFQUFFWSxHQUFHLEVBQUV0RCxLQUFLO0lBQUlzRCxNQUFNbUIsZUFBZW5CO0lBQU0sSUFBSUEsT0FBT1osS0FBSztRQUFFN0MsT0FBT0MsY0FBYyxDQUFDNEMsS0FBS1ksS0FBSztZQUFFdEQsT0FBT0E7WUFBT3NFLFlBQVk7WUFBTUMsY0FBYztZQUFNQyxVQUFVO1FBQUs7SUFBSSxPQUFPO1FBQUU5QixHQUFHLENBQUNZLElBQUksR0FBR3REO0lBQU87SUFBRSxPQUFPMEM7QUFBSztBQUMzTyxTQUFTK0IsZUFBZTdDLENBQUM7SUFBSSxJQUFJWSxJQUFJaUUsYUFBYTdFLEdBQUc7SUFBVyxPQUFPLFlBQVlFLFFBQVFVLEtBQUtBLElBQUlBLElBQUk7QUFBSTtBQUM1RyxTQUFTaUUsYUFBYTdFLENBQUMsRUFBRUQsQ0FBQztJQUFJLElBQUksWUFBWUcsUUFBUUYsTUFBTSxDQUFDQSxHQUFHLE9BQU9BO0lBQUcsSUFBSUgsSUFBSUcsQ0FBQyxDQUFDZ0IsT0FBTzhELFdBQVcsQ0FBQztJQUFFLElBQUksS0FBSyxNQUFNakYsR0FBRztRQUFFLElBQUllLElBQUlmLEVBQUVjLElBQUksQ0FBQ1gsR0FBR0QsS0FBSztRQUFZLElBQUksWUFBWUcsUUFBUVUsSUFBSSxPQUFPQTtRQUFHLE1BQU0sSUFBSTBCLFVBQVU7SUFBaUQ7SUFBRSxPQUFPLENBQUMsYUFBYXZDLElBQUlnRixTQUFTQyxNQUFLLEVBQUdoRjtBQUFJLEVBQUU7O0NBRTVUO0FBQ0QsSUFBSWlGLGlCQUFpQjtBQUNyQixJQUFJQyxjQUFjLFNBQVNBLFlBQVlDLElBQUk7SUFDekMsSUFBSUMsUUFBUUQsS0FBS0MsS0FBSyxFQUNwQkMsT0FBT0YsS0FBS0UsSUFBSSxFQUNoQkMsUUFBUUgsS0FBS0csS0FBSyxFQUNsQkMsV0FBV0osS0FBS0ksUUFBUTtJQUMxQixJQUFJQyxXQUFXSCxLQUFLRyxRQUFRO0lBQzVCLElBQUlDLGFBQWFMLFFBQVE7SUFDekIsSUFBSU0sbUJBQW1CRixZQUFZQSxTQUFTaEUsTUFBTSxHQUFHZ0UsU0FBU0csR0FBRyxDQUFDLFNBQVVDLEtBQUssRUFBRWhGLENBQUM7UUFDbEYsT0FBT3NFLFlBQVk7WUFDakJFLE9BQU9LO1lBQ1BKLE1BQU1PO1lBQ05OLE9BQU8xRTtZQUNQMkUsVUFBVUE7UUFDWjtJQUNGLEtBQUs7SUFDTCxJQUFJTTtJQUNKLElBQUlMLFlBQVlBLFNBQVNoRSxNQUFNLEVBQUU7UUFDL0JxRSxZQUFZSCxpQkFBaUJJLE1BQU0sQ0FBQyxTQUFVQyxNQUFNLEVBQUVILEtBQUs7WUFDekQsT0FBT0csU0FBU0gsS0FBSyxDQUFDWCxlQUFlO1FBQ3ZDLEdBQUc7SUFDTCxPQUFPO1FBQ0wsK0JBQStCO1FBQy9CWSxZQUFZLENBQUMsR0FBR3ZILE1BQU0sQ0FBQyxVQUFVLEVBQUUrRyxJQUFJLENBQUNFLFNBQVMsS0FBS0YsSUFBSSxDQUFDRSxTQUFTLElBQUksSUFBSSxJQUFJRixJQUFJLENBQUNFLFNBQVM7SUFDaEc7SUFDQSxPQUFPZixjQUFjQSxjQUFjLENBQUMsR0FBR2EsT0FBTyxDQUFDLEdBQUdYLGdCQUFnQkEsZ0JBQWdCQSxnQkFBZ0I7UUFDaEdjLFVBQVVFO0lBQ1osR0FBR1QsZ0JBQWdCWSxZQUFZLFNBQVNULFFBQVEsU0FBU0U7QUFDM0Q7QUFDQSxJQUFJVSxhQUFhLFNBQVNBLFdBQVdYLElBQUk7SUFDdkMsT0FBTztRQUNMWSxHQUFHWixLQUFLWSxDQUFDO1FBQ1RDLEdBQUdiLEtBQUthLENBQUM7UUFDVEMsT0FBT2QsS0FBS2MsS0FBSztRQUNqQkMsUUFBUWYsS0FBS2UsTUFBTTtJQUNyQjtBQUNGO0FBRUEsMERBQTBEO0FBQzFELElBQUlDLG9CQUFvQixTQUFTQSxrQkFBa0JiLFFBQVEsRUFBRWMsY0FBYztJQUN6RSxJQUFJQyxRQUFRRCxpQkFBaUIsSUFBSSxJQUFJQTtJQUNyQyxPQUFPZCxTQUFTRyxHQUFHLENBQUMsU0FBVUMsS0FBSztRQUNqQyxJQUFJWSxPQUFPWixLQUFLLENBQUNYLGVBQWUsR0FBR3NCO1FBQ25DLE9BQU8vQixjQUFjQSxjQUFjLENBQUMsR0FBR29CLFFBQVEsQ0FBQyxHQUFHO1lBQ2pEWSxNQUFNLENBQUMsR0FBR2xJLE1BQU0sQ0FBQyxVQUFVLEVBQUVrSSxTQUFTQSxRQUFRLElBQUksSUFBSUE7UUFDeEQ7SUFDRjtBQUNGO0FBRUEsdUVBQXVFO0FBQ3ZFLElBQUlDLGdCQUFnQixTQUFTQSxjQUFjQyxHQUFHLEVBQUVDLFVBQVUsRUFBRUMsV0FBVztJQUNyRSxJQUFJQyxhQUFhRixhQUFhQTtJQUM5QixJQUFJRyxVQUFVSixJQUFJRixJQUFJLEdBQUdFLElBQUlGLElBQUk7SUFDakMsSUFBSU8sY0FBY0wsSUFBSVosTUFBTSxDQUFDLFNBQVVDLE1BQU0sRUFBRUgsS0FBSztRQUNoRCxPQUFPO1lBQ0xvQixLQUFLQyxLQUFLRCxHQUFHLENBQUNqQixPQUFPaUIsR0FBRyxFQUFFcEIsTUFBTVksSUFBSTtZQUNwQ1UsS0FBS0QsS0FBS0MsR0FBRyxDQUFDbkIsT0FBT21CLEdBQUcsRUFBRXRCLE1BQU1ZLElBQUk7UUFDdEM7SUFDRixHQUFHO1FBQ0RRLEtBQUtHO1FBQ0xELEtBQUs7SUFDUCxJQUNBRixNQUFNRCxZQUFZQyxHQUFHLEVBQ3JCRSxNQUFNSCxZQUFZRyxHQUFHO0lBQ3ZCLE9BQU9KLFVBQVVHLEtBQUtDLEdBQUcsQ0FBQ0wsYUFBYUssTUFBTU4sY0FBY0UsU0FBU0EsVUFBV0QsQ0FBQUEsYUFBYUcsTUFBTUosV0FBVSxLQUFNTztBQUNwSDtBQUNBLElBQUlDLHFCQUFxQixTQUFTQSxtQkFBbUJWLEdBQUcsRUFBRUMsVUFBVSxFQUFFVSxVQUFVLEVBQUVDLE9BQU87SUFDdkYsSUFBSUMsWUFBWVosYUFBYU0sS0FBS08sS0FBSyxDQUFDZCxJQUFJRixJQUFJLEdBQUdHLGNBQWM7SUFDakUsSUFBSVcsV0FBV0MsWUFBWUYsV0FBV2pCLE1BQU0sRUFBRTtRQUM1Q21CLFlBQVlGLFdBQVdqQixNQUFNO0lBQy9CO0lBQ0EsSUFBSXFCLE9BQU9KLFdBQVdwQixDQUFDO0lBQ3ZCLElBQUlMO0lBQ0osSUFBSyxJQUFJaEYsSUFBSSxHQUFHOEcsTUFBTWhCLElBQUlsRixNQUFNLEVBQUVaLElBQUk4RyxLQUFLOUcsSUFBSztRQUM5Q2dGLFFBQVFjLEdBQUcsQ0FBQzlGLEVBQUU7UUFDZGdGLE1BQU1LLENBQUMsR0FBR3dCO1FBQ1Y3QixNQUFNTSxDQUFDLEdBQUdtQixXQUFXbkIsQ0FBQztRQUN0Qk4sTUFBTVEsTUFBTSxHQUFHbUI7UUFDZjNCLE1BQU1PLEtBQUssR0FBR2MsS0FBS0QsR0FBRyxDQUFDTyxZQUFZTixLQUFLTyxLQUFLLENBQUM1QixNQUFNWSxJQUFJLEdBQUdlLGFBQWEsR0FBR0YsV0FBV3BCLENBQUMsR0FBR29CLFdBQVdsQixLQUFLLEdBQUdzQjtRQUM3R0EsUUFBUTdCLE1BQU1PLEtBQUs7SUFDckI7SUFDQSwwQ0FBMEM7SUFDMUNQLE1BQU1PLEtBQUssSUFBSWtCLFdBQVdwQixDQUFDLEdBQUdvQixXQUFXbEIsS0FBSyxHQUFHc0I7SUFDakQsT0FBT2pELGNBQWNBLGNBQWMsQ0FBQyxHQUFHNkMsYUFBYSxDQUFDLEdBQUc7UUFDdERuQixHQUFHbUIsV0FBV25CLENBQUMsR0FBR3FCO1FBQ2xCbkIsUUFBUWlCLFdBQVdqQixNQUFNLEdBQUdtQjtJQUM5QjtBQUNGO0FBQ0EsSUFBSUksbUJBQW1CLFNBQVNBLGlCQUFpQmpCLEdBQUcsRUFBRUMsVUFBVSxFQUFFVSxVQUFVLEVBQUVDLE9BQU87SUFDbkYsSUFBSU0sV0FBV2pCLGFBQWFNLEtBQUtPLEtBQUssQ0FBQ2QsSUFBSUYsSUFBSSxHQUFHRyxjQUFjO0lBQ2hFLElBQUlXLFdBQVdNLFdBQVdQLFdBQVdsQixLQUFLLEVBQUU7UUFDMUN5QixXQUFXUCxXQUFXbEIsS0FBSztJQUM3QjtJQUNBLElBQUkwQixPQUFPUixXQUFXbkIsQ0FBQztJQUN2QixJQUFJTjtJQUNKLElBQUssSUFBSWhGLElBQUksR0FBRzhHLE1BQU1oQixJQUFJbEYsTUFBTSxFQUFFWixJQUFJOEcsS0FBSzlHLElBQUs7UUFDOUNnRixRQUFRYyxHQUFHLENBQUM5RixFQUFFO1FBQ2RnRixNQUFNSyxDQUFDLEdBQUdvQixXQUFXcEIsQ0FBQztRQUN0QkwsTUFBTU0sQ0FBQyxHQUFHMkI7UUFDVmpDLE1BQU1PLEtBQUssR0FBR3lCO1FBQ2RoQyxNQUFNUSxNQUFNLEdBQUdhLEtBQUtELEdBQUcsQ0FBQ1ksV0FBV1gsS0FBS08sS0FBSyxDQUFDNUIsTUFBTVksSUFBSSxHQUFHb0IsWUFBWSxHQUFHUCxXQUFXbkIsQ0FBQyxHQUFHbUIsV0FBV2pCLE1BQU0sR0FBR3lCO1FBQzdHQSxRQUFRakMsTUFBTVEsTUFBTTtJQUN0QjtJQUNBLElBQUlSLE9BQU87UUFDVEEsTUFBTVEsTUFBTSxJQUFJaUIsV0FBV25CLENBQUMsR0FBR21CLFdBQVdqQixNQUFNLEdBQUd5QjtJQUNyRDtJQUNBLE9BQU9yRCxjQUFjQSxjQUFjLENBQUMsR0FBRzZDLGFBQWEsQ0FBQyxHQUFHO1FBQ3REcEIsR0FBR29CLFdBQVdwQixDQUFDLEdBQUcyQjtRQUNsQnpCLE9BQU9rQixXQUFXbEIsS0FBSyxHQUFHeUI7SUFDNUI7QUFDRjtBQUNBLElBQUlFLFdBQVcsU0FBU0EsU0FBU3BCLEdBQUcsRUFBRUMsVUFBVSxFQUFFVSxVQUFVLEVBQUVDLE9BQU87SUFDbkUsSUFBSVgsZUFBZVUsV0FBV2xCLEtBQUssRUFBRTtRQUNuQyxPQUFPaUIsbUJBQW1CVixLQUFLQyxZQUFZVSxZQUFZQztJQUN6RDtJQUNBLE9BQU9LLGlCQUFpQmpCLEtBQUtDLFlBQVlVLFlBQVlDO0FBQ3ZEO0FBRUEsMkVBQTJFO0FBQzNFLElBQUlTLFdBQVcsU0FBU0EsU0FBUzFDLElBQUksRUFBRXVCLFdBQVc7SUFDaEQsSUFBSXBCLFdBQVdILEtBQUtHLFFBQVE7SUFDNUIsSUFBSUEsWUFBWUEsU0FBU2hFLE1BQU0sRUFBRTtRQUMvQixJQUFJd0csT0FBT2hDLFdBQVdYO1FBQ3RCLGNBQWM7UUFDZCxJQUFJcUIsTUFBTSxFQUFFO1FBQ1osSUFBSXVCLE9BQU9kLFVBQVUsNEJBQTRCO1FBQ2pELElBQUl2QixPQUFPc0MsT0FBTyx3QkFBd0I7UUFDMUMsSUFBSUMsT0FBT2xCLEtBQUtELEdBQUcsQ0FBQ2dCLEtBQUs3QixLQUFLLEVBQUU2QixLQUFLNUIsTUFBTSxHQUFHLHNCQUFzQjtRQUNwRSxJQUFJZ0MsZ0JBQWdCL0Isa0JBQWtCYixVQUFVd0MsS0FBSzdCLEtBQUssR0FBRzZCLEtBQUs1QixNQUFNLEdBQUdmLElBQUksQ0FBQ0osZUFBZTtRQUMvRixJQUFJb0QsZUFBZUQsY0FBY0UsS0FBSztRQUN0QzVCLElBQUlGLElBQUksR0FBRztRQUNYLE1BQU82QixhQUFhN0csTUFBTSxHQUFHLEVBQUc7WUFDOUIsWUFBWTtZQUNaLGdEQUFnRDtZQUNoRGtGLElBQUluQyxJQUFJLENBQUNxQixRQUFReUMsWUFBWSxDQUFDLEVBQUU7WUFDaEMzQixJQUFJRixJQUFJLElBQUlaLE1BQU1ZLElBQUk7WUFDdEIwQixRQUFRekIsY0FBY0MsS0FBS3lCLE1BQU12QjtZQUNqQyxJQUFJc0IsU0FBU0QsTUFBTTtnQkFDakIsaUNBQWlDO2dCQUNqQ0ksYUFBYUUsS0FBSztnQkFDbEJOLE9BQU9DO1lBQ1QsT0FBTztnQkFDTCx5Q0FBeUM7Z0JBQ3pDeEIsSUFBSUYsSUFBSSxJQUFJRSxJQUFJOEIsR0FBRyxHQUFHaEMsSUFBSTtnQkFDMUJ3QixPQUFPRixTQUFTcEIsS0FBS3lCLE1BQU1ILE1BQU07Z0JBQ2pDRyxPQUFPbEIsS0FBS0QsR0FBRyxDQUFDZ0IsS0FBSzdCLEtBQUssRUFBRTZCLEtBQUs1QixNQUFNO2dCQUN2Q00sSUFBSWxGLE1BQU0sR0FBR2tGLElBQUlGLElBQUksR0FBRztnQkFDeEJ5QixPQUFPZDtZQUNUO1FBQ0Y7UUFDQSxJQUFJVCxJQUFJbEYsTUFBTSxFQUFFO1lBQ2R3RyxPQUFPRixTQUFTcEIsS0FBS3lCLE1BQU1ILE1BQU07WUFDakN0QixJQUFJbEYsTUFBTSxHQUFHa0YsSUFBSUYsSUFBSSxHQUFHO1FBQzFCO1FBQ0EsT0FBT2hDLGNBQWNBLGNBQWMsQ0FBQyxHQUFHYSxPQUFPLENBQUMsR0FBRztZQUNoREcsVUFBVTRDLGNBQWN6QyxHQUFHLENBQUMsU0FBVThDLENBQUM7Z0JBQ3JDLE9BQU9WLFNBQVNVLEdBQUc3QjtZQUNyQjtRQUNGO0lBQ0Y7SUFDQSxPQUFPdkI7QUFDVDtBQUNBLElBQUlxRCxlQUFlO0lBQ2pCQyxpQkFBaUI7SUFDakJDLHFCQUFxQjtJQUNyQkMsWUFBWTtJQUNaQyxZQUFZO0lBQ1pDLGFBQWE7SUFDYkMsV0FBVyxFQUFFO0FBQ2Y7QUFDQSxJQUFJM0ssVUFBVUYsZUFBZSxHQUFHLFdBQVcsR0FBRSxTQUFVOEssY0FBYztJQUNuRSxTQUFTNUs7UUFDUCxJQUFJNks7UUFDSi9HLGdCQUFnQixJQUFJLEVBQUU5RDtRQUN0QixJQUFLLElBQUk4SyxPQUFPNUgsVUFBVUMsTUFBTSxFQUFFNEgsT0FBTyxJQUFJQyxNQUFNRixPQUFPRyxPQUFPLEdBQUdBLE9BQU9ILE1BQU1HLE9BQVE7WUFDdkZGLElBQUksQ0FBQ0UsS0FBSyxHQUFHL0gsU0FBUyxDQUFDK0gsS0FBSztRQUM5QjtRQUNBSixRQUFRakcsV0FBVyxJQUFJLEVBQUU1RSxTQUFTLEVBQUUsQ0FBQ2tMLE1BQU0sQ0FBQ0g7UUFDNUMxRSxnQkFBZ0J3RSxPQUFPLFNBQVMxRSxjQUFjLENBQUMsR0FBR2tFO1FBQ2xEaEUsZ0JBQWdCd0UsT0FBTyxzQkFBc0I7WUFDM0MsSUFBSU0saUJBQWlCTixNQUFNMUcsS0FBSyxDQUFDZ0gsY0FBYztZQUMvQ04sTUFBTU8sUUFBUSxDQUFDO2dCQUNiYixxQkFBcUI7WUFDdkI7WUFDQSxJQUFJLENBQUMsR0FBR25LLFdBQVcsQ0FBQyxVQUFVLEVBQUUrSyxpQkFBaUI7Z0JBQy9DQTtZQUNGO1FBQ0Y7UUFDQTlFLGdCQUFnQndFLE9BQU8sd0JBQXdCO1lBQzdDLElBQUlRLG1CQUFtQlIsTUFBTTFHLEtBQUssQ0FBQ2tILGdCQUFnQjtZQUNuRFIsTUFBTU8sUUFBUSxDQUFDO2dCQUNiYixxQkFBcUI7WUFDdkI7WUFDQSxJQUFJLENBQUMsR0FBR25LLFdBQVcsQ0FBQyxVQUFVLEVBQUVpTCxtQkFBbUI7Z0JBQ2pEQTtZQUNGO1FBQ0Y7UUFDQSxPQUFPUjtJQUNUO0lBQ0FwRixVQUFVekYsU0FBUzRLO0lBQ25CLE9BQU9uRyxhQUFhekUsU0FBUztRQUFDO1lBQzVCcUQsS0FBSztZQUNMdEQsT0FBTyxTQUFTdUwsaUJBQWlCdEUsSUFBSSxFQUFFeEYsQ0FBQztnQkFDdENBLEVBQUUrSixPQUFPO2dCQUNULElBQUlDLGNBQWMsSUFBSSxDQUFDckgsS0FBSyxFQUMxQnNILGVBQWVELFlBQVlDLFlBQVksRUFDdkN0RSxXQUFXcUUsWUFBWXJFLFFBQVE7Z0JBQ2pDLElBQUl1RSxjQUFjLENBQUMsR0FBR3JLLFlBQVlzSyxlQUFlLEVBQUV4RSxVQUFVeEcsU0FBU2lMLE9BQU87Z0JBQzdFLElBQUlGLGFBQWE7b0JBQ2YsSUFBSSxDQUFDTixRQUFRLENBQUM7d0JBQ1pkLGlCQUFpQjt3QkFDakJFLFlBQVl4RDtvQkFDZCxHQUFHO3dCQUNELElBQUl5RSxjQUFjOzRCQUNoQkEsYUFBYXpFLE1BQU14Rjt3QkFDckI7b0JBQ0Y7Z0JBQ0YsT0FBTyxJQUFJaUssY0FBYztvQkFDdkJBLGFBQWF6RSxNQUFNeEY7Z0JBQ3JCO1lBQ0Y7UUFDRjtRQUFHO1lBQ0Q2QixLQUFLO1lBQ0x0RCxPQUFPLFNBQVM4TCxpQkFBaUI3RSxJQUFJLEVBQUV4RixDQUFDO2dCQUN0Q0EsRUFBRStKLE9BQU87Z0JBQ1QsSUFBSU8sZUFBZSxJQUFJLENBQUMzSCxLQUFLLEVBQzNCNEgsZUFBZUQsYUFBYUMsWUFBWSxFQUN4QzVFLFdBQVcyRSxhQUFhM0UsUUFBUTtnQkFDbEMsSUFBSXVFLGNBQWMsQ0FBQyxHQUFHckssWUFBWXNLLGVBQWUsRUFBRXhFLFVBQVV4RyxTQUFTaUwsT0FBTztnQkFDN0UsSUFBSUYsYUFBYTtvQkFDZixJQUFJLENBQUNOLFFBQVEsQ0FBQzt3QkFDWmQsaUJBQWlCO3dCQUNqQkUsWUFBWTtvQkFDZCxHQUFHO3dCQUNELElBQUl1QixjQUFjOzRCQUNoQkEsYUFBYS9FLE1BQU14Rjt3QkFDckI7b0JBQ0Y7Z0JBQ0YsT0FBTyxJQUFJdUssY0FBYztvQkFDdkJBLGFBQWEvRSxNQUFNeEY7Z0JBQ3JCO1lBQ0Y7UUFDRjtRQUFHO1lBQ0Q2QixLQUFLO1lBQ0x0RCxPQUFPLFNBQVNpTSxZQUFZaEYsSUFBSTtnQkFDOUIsSUFBSWlGLGVBQWUsSUFBSSxDQUFDOUgsS0FBSyxFQUMzQitILFVBQVVELGFBQWFDLE9BQU8sRUFDOUJDLE9BQU9GLGFBQWFFLElBQUk7Z0JBQzFCLElBQUlBLFNBQVMsVUFBVW5GLEtBQUtHLFFBQVEsRUFBRTtvQkFDcEMsSUFBSWlGLGVBQWUsSUFBSSxDQUFDakksS0FBSyxFQUMzQjJELFFBQVFzRSxhQUFhdEUsS0FBSyxFQUMxQkMsU0FBU3FFLGFBQWFyRSxNQUFNLEVBQzVCc0UsVUFBVUQsYUFBYUMsT0FBTyxFQUM5QjlELGNBQWM2RCxhQUFhN0QsV0FBVztvQkFDeEMsSUFBSStELE9BQU96RixZQUFZO3dCQUNyQkUsT0FBTzt3QkFDUEMsTUFBTWIsY0FBY0EsY0FBYyxDQUFDLEdBQUdhLE9BQU8sQ0FBQyxHQUFHOzRCQUMvQ1ksR0FBRzs0QkFDSEMsR0FBRzs0QkFDSEMsT0FBT0E7NEJBQ1BDLFFBQVFBO3dCQUNWO3dCQUNBZCxPQUFPO3dCQUNQQyxVQUFVbUY7b0JBQ1o7b0JBQ0EsSUFBSTVCLGFBQWFmLFNBQVM0QyxNQUFNL0Q7b0JBQ2hDLElBQUlvQyxZQUFZLElBQUksQ0FBQzRCLEtBQUssQ0FBQzVCLFNBQVM7b0JBQ3BDQSxVQUFVekUsSUFBSSxDQUFDYztvQkFDZixJQUFJLENBQUNvRSxRQUFRLENBQUM7d0JBQ1pYLFlBQVlBO3dCQUNaQyxhQUFhNEI7d0JBQ2IzQixXQUFXQTtvQkFDYjtnQkFDRjtnQkFDQSxJQUFJdUIsU0FBUztvQkFDWEEsUUFBUWxGO2dCQUNWO1lBQ0Y7UUFDRjtRQUFHO1lBQ0QzRCxLQUFLO1lBQ0x0RCxPQUFPLFNBQVN5TSxnQkFBZ0J4RixJQUFJLEVBQUV6RSxDQUFDO2dCQUNyQyxJQUFJb0ksWUFBWSxJQUFJLENBQUM0QixLQUFLLENBQUM1QixTQUFTO2dCQUNwQyxJQUFJOEIsZUFBZSxJQUFJLENBQUN0SSxLQUFLLEVBQzNCMkQsUUFBUTJFLGFBQWEzRSxLQUFLLEVBQzFCQyxTQUFTMEUsYUFBYTFFLE1BQU0sRUFDNUJzRSxVQUFVSSxhQUFhSixPQUFPLEVBQzlCOUQsY0FBY2tFLGFBQWFsRSxXQUFXO2dCQUN4QyxJQUFJK0QsT0FBT3pGLFlBQVk7b0JBQ3JCRSxPQUFPO29CQUNQQyxNQUFNYixjQUFjQSxjQUFjLENBQUMsR0FBR2EsT0FBTyxDQUFDLEdBQUc7d0JBQy9DWSxHQUFHO3dCQUNIQyxHQUFHO3dCQUNIQyxPQUFPQTt3QkFDUEMsUUFBUUE7b0JBQ1Y7b0JBQ0FkLE9BQU87b0JBQ1BDLFVBQVVtRjtnQkFDWjtnQkFDQSxJQUFJNUIsYUFBYWYsU0FBUzRDLE1BQU0vRDtnQkFDaENvQyxZQUFZQSxVQUFVVixLQUFLLENBQUMsR0FBRzFILElBQUk7Z0JBQ25DLElBQUksQ0FBQzZJLFFBQVEsQ0FBQztvQkFDWlgsWUFBWUE7b0JBQ1pDLGFBQWExRDtvQkFDYjJELFdBQVdBO2dCQUNiO1lBQ0Y7UUFDRjtRQUFHO1lBQ0R0SCxLQUFLO1lBQ0x0RCxPQUFPLFNBQVMyTSxXQUFXQyxPQUFPLEVBQUVDLFNBQVMsRUFBRUMsTUFBTTtnQkFDbkQsSUFBSUMsU0FBUyxJQUFJO2dCQUNqQixJQUFJQyxlQUFlLElBQUksQ0FBQzVJLEtBQUssRUFDM0I2SSxvQkFBb0JELGFBQWFDLGlCQUFpQixFQUNsREMsaUJBQWlCRixhQUFhRSxjQUFjLEVBQzVDQyxvQkFBb0JILGFBQWFHLGlCQUFpQixFQUNsREMsa0JBQWtCSixhQUFhSSxlQUFlLEVBQzlDQywwQkFBMEJMLGFBQWFLLHVCQUF1QixFQUM5RGpCLE9BQU9ZLGFBQWFaLElBQUksRUFDeEJrQixjQUFjTixhQUFhTSxXQUFXLEVBQ3RDQyxhQUFhUCxhQUFhTyxVQUFVO2dCQUN0QyxJQUFJL0Msc0JBQXNCLElBQUksQ0FBQ2dDLEtBQUssQ0FBQ2hDLG1CQUFtQjtnQkFDeEQsSUFBSXpDLFFBQVE4RSxVQUFVOUUsS0FBSyxFQUN6QkMsU0FBUzZFLFVBQVU3RSxNQUFNLEVBQ3pCSCxJQUFJZ0YsVUFBVWhGLENBQUMsRUFDZkMsSUFBSStFLFVBQVUvRSxDQUFDLEVBQ2ZkLFFBQVE2RixVQUFVN0YsS0FBSztnQkFDekIsSUFBSXdHLGFBQWFDLFNBQVMsR0FBR3RDLE1BQU0sQ0FBQyxDQUFDdEMsS0FBSzZFLE1BQU0sS0FBSyxJQUFJLEtBQUszRixRQUFRO2dCQUN0RSxJQUFJNEYsUUFBUSxDQUFDO2dCQUNiLElBQUliLFVBQVVWLFNBQVMsUUFBUTtvQkFDN0J1QixRQUFRO3dCQUNOakMsY0FBYyxJQUFJLENBQUNILGdCQUFnQixDQUFDdEksSUFBSSxDQUFDLElBQUksRUFBRTRKO3dCQUMvQ2IsY0FBYyxJQUFJLENBQUNGLGdCQUFnQixDQUFDN0ksSUFBSSxDQUFDLElBQUksRUFBRTRKO3dCQUMvQ1YsU0FBUyxJQUFJLENBQUNGLFdBQVcsQ0FBQ2hKLElBQUksQ0FBQyxJQUFJLEVBQUU0SjtvQkFDdkM7Z0JBQ0Y7Z0JBQ0EsSUFBSSxDQUFDSSxtQkFBbUI7b0JBQ3RCLE9BQU8sV0FBVyxHQUFFeE0sTUFBTSxDQUFDLFVBQVUsQ0FBQ21OLGFBQWEsQ0FBQy9NLE9BQU9nTixLQUFLLEVBQUVGLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQ0csaUJBQWlCLENBQUNsQixTQUFTeEcsY0FBY0EsY0FBYyxDQUFDLEdBQUd5RyxZQUFZLENBQUMsR0FBRzt3QkFDbktJLG1CQUFtQjt3QkFDbkJJLHlCQUF5Qjt3QkFDekJ0RixPQUFPQTt3QkFDUEMsUUFBUUE7d0JBQ1JILEdBQUdBO3dCQUNIQyxHQUFHQTtvQkFDTCxJQUFJc0UsTUFBTW1CO2dCQUNaO2dCQUNBLE9BQU8sV0FBVyxHQUFFOU0sTUFBTSxDQUFDLFVBQVUsQ0FBQ21OLGFBQWEsQ0FBQ2pOLFlBQVksQ0FBQyxVQUFVLEVBQUU7b0JBQzNFb04sT0FBT2I7b0JBQ1BjLFVBQVViO29CQUNWYyxVQUFVaEI7b0JBQ1ZpQixRQUFRZDtvQkFDUjlKLEtBQUssV0FBVzZILE1BQU0sQ0FBQ21DO29CQUN2QmEsTUFBTTt3QkFDSnRHLEdBQUdBO3dCQUNIQyxHQUFHQTt3QkFDSEMsT0FBT0E7d0JBQ1BDLFFBQVFBO29CQUNWO29CQUNBb0csSUFBSTt3QkFDRnZHLEdBQUdBO3dCQUNIQyxHQUFHQTt3QkFDSEMsT0FBT0E7d0JBQ1BDLFFBQVFBO29CQUNWO29CQUNBc0Qsa0JBQWtCLElBQUksQ0FBQytDLG9CQUFvQjtvQkFDM0NqRCxnQkFBZ0IsSUFBSSxDQUFDa0Qsa0JBQWtCO2dCQUN6QyxHQUFHLFNBQVVDLEtBQUs7b0JBQ2hCLElBQUlDLFFBQVFELE1BQU0xRyxDQUFDLEVBQ2pCNEcsUUFBUUYsTUFBTXpHLENBQUMsRUFDZjRHLFlBQVlILE1BQU14RyxLQUFLLEVBQ3ZCNEcsYUFBYUosTUFBTXZHLE1BQU07b0JBQzNCLE9BQU8sV0FBVyxHQUFFdkgsTUFBTSxDQUFDLFVBQVUsQ0FBQ21OLGFBQWEsQ0FBQ2pOLFlBQVksQ0FBQyxVQUFVLEVBQUU7d0JBQzNFd04sTUFBTSxhQUFhaEQsTUFBTSxDQUFDcUMsWUFBWSxRQUFRckMsTUFBTSxDQUFDcUMsWUFBWTt3QkFDakVZLElBQUk7d0JBQ0pRLGVBQWU7d0JBQ2ZiLE9BQU9iO3dCQUNQZ0IsUUFBUWQ7d0JBQ1JhLFVBQVVoQjt3QkFDVmUsVUFBVWI7b0JBQ1osR0FBRyxXQUFXLEdBQUUxTSxNQUFNLENBQUMsVUFBVSxDQUFDbU4sYUFBYSxDQUFDL00sT0FBT2dOLEtBQUssRUFBRUYsT0FBTzt3QkFDbkUsc0RBQXNEO3dCQUN0RCxJQUFJM0csUUFBUSxLQUFLLENBQUN3RCxxQkFBcUI7NEJBQ3JDLE9BQU87d0JBQ1Q7d0JBQ0EsT0FBT3VDLE9BQU8sV0FBVyxDQUFDZSxpQkFBaUIsQ0FBQ2xCLFNBQVN4RyxjQUFjQSxjQUFjLENBQUMsR0FBR3lHLFlBQVksQ0FBQyxHQUFHOzRCQUNuR0ksbUJBQW1CQTs0QkFDbkJJLHlCQUF5QixDQUFDQTs0QkFDMUJ0RixPQUFPMkc7NEJBQ1AxRyxRQUFRMkc7NEJBQ1I5RyxHQUFHMkc7NEJBQ0gxRyxHQUFHMkc7d0JBQ0wsSUFBSXJDLE1BQU1tQjtvQkFDWjtnQkFDRjtZQUNGO1FBQ0Y7UUFBRztZQUNEakssS0FBSztZQUNMdEQsT0FBTyxTQUFTNk8sV0FBV3RDLElBQUksRUFBRXRGLElBQUk7Z0JBQ25DLElBQUk2SCxTQUFTLElBQUk7Z0JBQ2pCLElBQUlDLGVBQWUsSUFBSSxDQUFDM0ssS0FBSyxFQUMzQndJLFVBQVVtQyxhQUFhbkMsT0FBTyxFQUM5QlIsT0FBTzJDLGFBQWEzQyxJQUFJO2dCQUMxQixJQUFJUyxZQUFZekcsY0FBY0EsY0FBY0EsY0FBYyxDQUFDLEdBQUcsQ0FBQyxHQUFHOUUsWUFBWTBOLFdBQVcsRUFBRSxJQUFJLENBQUM1SyxLQUFLLEVBQUUsU0FBUzZDLE9BQU8sQ0FBQyxHQUFHO29CQUN6SHNGLE1BQU1BO2dCQUNSO2dCQUNBLElBQUlPLFNBQVMsQ0FBQzdGLEtBQUtHLFFBQVEsSUFBSSxDQUFDSCxLQUFLRyxRQUFRLENBQUNoRSxNQUFNO2dCQUNwRCxJQUFJdUgsY0FBYyxJQUFJLENBQUM2QixLQUFLLENBQUM3QixXQUFXO2dCQUN4QyxJQUFJc0UscUJBQXFCLENBQUN0RSxZQUFZdkQsUUFBUSxJQUFJLEVBQUUsRUFBRWxCLE1BQU0sQ0FBQyxTQUFVZ0osSUFBSTtvQkFDekUsT0FBT0EsS0FBS2xJLEtBQUssS0FBS0MsS0FBS0QsS0FBSyxJQUFJa0ksS0FBS0MsSUFBSSxLQUFLbEksS0FBS2tJLElBQUk7Z0JBQzdEO2dCQUNBLElBQUksQ0FBQ0YsbUJBQW1CN0wsTUFBTSxJQUFJbUosS0FBS3ZGLEtBQUssSUFBSW9GLFNBQVMsUUFBUTtvQkFDL0QsT0FBTztnQkFDVDtnQkFDQSxPQUFPLFdBQVcsR0FBRTNMLE1BQU0sQ0FBQyxVQUFVLENBQUNtTixhQUFhLENBQUMvTSxPQUFPZ04sS0FBSyxFQUFFO29CQUNoRXZLLEtBQUsseUJBQXlCNkgsTUFBTSxDQUFDMEIsVUFBVWhGLENBQUMsRUFBRSxLQUFLc0QsTUFBTSxDQUFDMEIsVUFBVS9FLENBQUMsRUFBRSxLQUFLcUQsTUFBTSxDQUFDMEIsVUFBVXNDLElBQUk7b0JBQ3JHQyxXQUFXLDBCQUEwQmpFLE1BQU0sQ0FBQ2xFLEtBQUtELEtBQUs7Z0JBQ3hELEdBQUcsSUFBSSxDQUFDMkYsVUFBVSxDQUFDQyxTQUFTQyxXQUFXQyxTQUFTN0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLRyxRQUFRLENBQUNoRSxNQUFNLEdBQUc2RCxLQUFLRyxRQUFRLENBQUNHLEdBQUcsQ0FBQyxTQUFVQyxLQUFLO29CQUN2SCxPQUFPc0gsT0FBT0QsVUFBVSxDQUFDNUgsTUFBTU87Z0JBQ2pDLEtBQUs7WUFDUDtRQUNGO1FBQUc7WUFDRGxFLEtBQUs7WUFDTHRELE9BQU8sU0FBU3FQO2dCQUNkLElBQUkzRSxhQUFhLElBQUksQ0FBQzhCLEtBQUssQ0FBQzlCLFVBQVU7Z0JBQ3RDLElBQUksQ0FBQ0EsWUFBWTtvQkFDZixPQUFPO2dCQUNUO2dCQUNBLE9BQU8sSUFBSSxDQUFDbUUsVUFBVSxDQUFDbkUsWUFBWUE7WUFDckM7UUFDRjtRQUFHO1lBQ0RwSCxLQUFLO1lBQ0x0RCxPQUFPLFNBQVNzUDtnQkFDZCxJQUFJQyxlQUFlLElBQUksQ0FBQ25MLEtBQUssRUFDM0JnRCxXQUFXbUksYUFBYW5JLFFBQVEsRUFDaENvSSxVQUFVRCxhQUFhQyxPQUFPO2dCQUNoQyxJQUFJN0QsY0FBYyxDQUFDLEdBQUdySyxZQUFZc0ssZUFBZSxFQUFFeEUsVUFBVXhHLFNBQVNpTCxPQUFPO2dCQUM3RSxJQUFJLENBQUNGLGFBQWE7b0JBQ2hCLE9BQU87Z0JBQ1Q7Z0JBQ0EsSUFBSThELGVBQWUsSUFBSSxDQUFDckwsS0FBSyxFQUMzQjJELFFBQVEwSCxhQUFhMUgsS0FBSyxFQUMxQkMsU0FBU3lILGFBQWF6SCxNQUFNO2dCQUM5QixJQUFJMEgsY0FBYyxJQUFJLENBQUNsRCxLQUFLLEVBQzFCakMsa0JBQWtCbUYsWUFBWW5GLGVBQWUsRUFDN0NFLGFBQWFpRixZQUFZakYsVUFBVTtnQkFDckMsSUFBSWtGLFVBQVU7b0JBQ1o5SCxHQUFHO29CQUNIQyxHQUFHO29CQUNIQyxPQUFPQTtvQkFDUEMsUUFBUUE7Z0JBQ1Y7Z0JBQ0EsSUFBSTRILGFBQWFuRixhQUFhO29CQUM1QjVDLEdBQUc0QyxXQUFXNUMsQ0FBQyxHQUFHNEMsV0FBVzFDLEtBQUssR0FBRztvQkFDckNELEdBQUcyQyxXQUFXM0MsQ0FBQyxHQUFHMkMsV0FBV3pDLE1BQU0sR0FBRztnQkFDeEMsSUFBSTtnQkFDSixJQUFJNkgsVUFBVXRGLG1CQUFtQkUsYUFBYTtvQkFBQzt3QkFDN0NvRixTQUFTcEY7d0JBQ1QwRSxNQUFNLENBQUMsR0FBR2xPLFlBQVk2TyxpQkFBaUIsRUFBRXJGLFlBQVkrRSxTQUFTO3dCQUM5RHhQLE9BQU8sQ0FBQyxHQUFHaUIsWUFBWTZPLGlCQUFpQixFQUFFckYsWUFBWTVEO29CQUN4RDtpQkFBRSxHQUFHLEVBQUU7Z0JBQ1AsT0FBTyxXQUFXLEdBQUVwRyxNQUFNLENBQUMsVUFBVSxDQUFDc1AsWUFBWSxDQUFDcEUsYUFBYTtvQkFDOURnRSxTQUFTQTtvQkFDVEssUUFBUXpGO29CQUNScUYsWUFBWUE7b0JBQ1pLLE9BQU87b0JBQ1BKLFNBQVNBO2dCQUNYO1lBQ0Y7UUFHRjtRQUFHO1lBQ0R2TSxLQUFLO1lBQ0x0RCxPQUFPLFNBQVNrUTtnQkFDZCxJQUFJQyxTQUFTLElBQUk7Z0JBQ2pCLElBQUlDLGdCQUFnQixJQUFJLENBQUNoTSxLQUFLLEVBQzVCb0wsVUFBVVksY0FBY1osT0FBTyxFQUMvQmEsbUJBQW1CRCxjQUFjQyxnQkFBZ0I7Z0JBQ25ELElBQUl6RixZQUFZLElBQUksQ0FBQzRCLEtBQUssQ0FBQzVCLFNBQVM7Z0JBQ3BDLE9BQU8sV0FBVyxHQUFFbkssTUFBTSxDQUFDLFVBQVUsQ0FBQ21OLGFBQWEsQ0FBQyxPQUFPO29CQUN6RHdCLFdBQVc7b0JBQ1hrQixPQUFPO3dCQUNMQyxXQUFXO3dCQUNYQyxXQUFXO29CQUNiO2dCQUNGLEdBQUc1RixVQUFVckQsR0FBRyxDQUFDLFNBQVUySCxJQUFJLEVBQUUxTSxDQUFDO29CQUNoQyxtQ0FBbUM7b0JBQ25DLElBQUkyTSxPQUFPLENBQUMsR0FBRzVPLElBQUksQ0FBQyxVQUFVLEVBQUUyTyxNQUFNTSxTQUFTO29CQUMvQyxJQUFJNUMsVUFBVTtvQkFDZCxJQUFLLFdBQVcsR0FBRW5NLE1BQU0sQ0FBQyxVQUFVLENBQUNnUSxjQUFjLENBQUNKLG1CQUFtQjt3QkFDcEV6RCxVQUFVLFdBQVcsR0FBRW5NLE1BQU0sQ0FBQyxVQUFVLENBQUNzUCxZQUFZLENBQUNNLGtCQUFrQm5CLE1BQU0xTTtvQkFDaEY7b0JBQ0EsSUFBSSxDQUFDLEdBQUduQyxXQUFXLENBQUMsVUFBVSxFQUFFZ1EsbUJBQW1CO3dCQUNqRHpELFVBQVV5RCxpQkFBaUJuQixNQUFNMU07b0JBQ25DLE9BQU87d0JBQ0xvSyxVQUFVdUM7b0JBQ1o7b0JBQ0EsT0FDRSxXQUFXLEdBQ1gsMEdBQTBHO29CQUMxRzFPLE1BQU0sQ0FBQyxVQUFVLENBQUNtTixhQUFhLENBQUMsT0FBTzt3QkFDckN6QixTQUFTZ0UsT0FBTzFELGVBQWUsQ0FBQ3hKLElBQUksQ0FBQ2tOLFFBQVFqQixNQUFNMU07d0JBQ25EYyxLQUFLLGNBQWM2SCxNQUFNLENBQUMsQ0FBQyxHQUFHaEssV0FBV3VQLFFBQVE7d0JBQ2pEdEIsV0FBVzt3QkFDWGtCLE9BQU87NEJBQ0xLLFFBQVE7NEJBQ1JDLFNBQVM7NEJBQ1RDLFNBQVM7NEJBQ1RDLFlBQVk7NEJBQ1pDLE9BQU87NEJBQ1BDLGFBQWE7d0JBQ2Y7b0JBQ0YsR0FBR3BFO2dCQUVQO1lBQ0Y7UUFDRjtRQUFHO1lBQ0R0SixLQUFLO1lBQ0x0RCxPQUFPLFNBQVNpUjtnQkFDZCxJQUFJLENBQUMsQ0FBQyxHQUFHM1AsWUFBWTRQLG1CQUFtQixFQUFFLElBQUksR0FBRztvQkFDL0MsT0FBTztnQkFDVDtnQkFDQSxJQUFJQyxnQkFBZ0IsSUFBSSxDQUFDL00sS0FBSyxFQUM1QjJELFFBQVFvSixjQUFjcEosS0FBSyxFQUMzQkMsU0FBU21KLGNBQWNuSixNQUFNLEVBQzdCb0gsWUFBWStCLGNBQWMvQixTQUFTLEVBQ25Da0IsUUFBUWEsY0FBY2IsS0FBSyxFQUMzQmxKLFdBQVcrSixjQUFjL0osUUFBUSxFQUNqQ2dGLE9BQU8rRSxjQUFjL0UsSUFBSSxFQUN6QmdGLFNBQVM1Tix5QkFBeUIyTixlQUFlNVA7Z0JBQ25ELElBQUk4UCxRQUFRLENBQUMsR0FBRy9QLFlBQVkwTixXQUFXLEVBQUVvQyxRQUFRO2dCQUNqRCxPQUFPLFdBQVcsR0FBRTNRLE1BQU0sQ0FBQyxVQUFVLENBQUNtTixhQUFhLENBQUMsT0FBTztvQkFDekR3QixXQUFXLENBQUMsR0FBRzVPLEtBQUssQ0FBQyxVQUFVLEVBQUUsb0JBQW9CNE87b0JBQ3JEa0IsT0FBT2xLLGNBQWNBLGNBQWMsQ0FBQyxHQUFHa0ssUUFBUSxDQUFDLEdBQUc7d0JBQ2pENUcsVUFBVTt3QkFDVmlILFFBQVE7d0JBQ1I1SSxPQUFPQTt3QkFDUEMsUUFBUUE7b0JBQ1Y7b0JBQ0FzSixNQUFNO2dCQUNSLEdBQUcsV0FBVyxHQUFFN1EsTUFBTSxDQUFDLFVBQVUsQ0FBQ21OLGFBQWEsQ0FBQzlNLFNBQVN5USxPQUFPLEVBQUV4TyxTQUFTLENBQUMsR0FBR3NPLE9BQU87b0JBQ3BGdEosT0FBT0E7b0JBQ1BDLFFBQVFvRSxTQUFTLFNBQVNwRSxTQUFTLEtBQUtBO2dCQUMxQyxJQUFJLElBQUksQ0FBQ3FILGNBQWMsSUFBSSxDQUFDLEdBQUcvTixZQUFZa1EsaUJBQWlCLEVBQUVwSyxZQUFZLElBQUksQ0FBQ2tJLGFBQWEsSUFBSWxELFNBQVMsVUFBVSxJQUFJLENBQUM4RCxlQUFlO1lBQ3pJO1FBQ0Y7S0FBRSxFQUFFO1FBQUM7WUFDSDVNLEtBQUs7WUFDTHRELE9BQU8sU0FBU3lSLHlCQUF5QkMsU0FBUyxFQUFFQyxTQUFTO2dCQUMzRCxJQUFJRCxVQUFVRSxJQUFJLEtBQUtELFVBQVVFLFFBQVEsSUFBSUgsVUFBVXRGLElBQUksS0FBS3VGLFVBQVVHLFFBQVEsSUFBSUosVUFBVTNKLEtBQUssS0FBSzRKLFVBQVVJLFNBQVMsSUFBSUwsVUFBVTFKLE1BQU0sS0FBSzJKLFVBQVVLLFVBQVUsSUFBSU4sVUFBVXBGLE9BQU8sS0FBS3FGLFVBQVVNLFdBQVcsSUFBSVAsVUFBVWxKLFdBQVcsS0FBS21KLFVBQVVPLGVBQWUsRUFBRTtvQkFDaFIsSUFBSTNGLE9BQU96RixZQUFZO3dCQUNyQkUsT0FBTzt3QkFDUEMsTUFBTTs0QkFDSkcsVUFBVXNLLFVBQVVFLElBQUk7NEJBQ3hCL0osR0FBRzs0QkFDSEMsR0FBRzs0QkFDSEMsT0FBTzJKLFVBQVUzSixLQUFLOzRCQUN0QkMsUUFBUTBKLFVBQVUxSixNQUFNO3dCQUMxQjt3QkFDQWQsT0FBTzt3QkFDUEMsVUFBVXVLLFVBQVVwRixPQUFPO29CQUM3QjtvQkFDQSxJQUFJNUIsYUFBYWYsU0FBUzRDLE1BQU1tRixVQUFVbEosV0FBVztvQkFDckQsT0FBT3BDLGNBQWNBLGNBQWMsQ0FBQyxHQUFHdUwsWUFBWSxDQUFDLEdBQUc7d0JBQ3JEakgsWUFBWUE7d0JBQ1pDLGFBQWE0Qjt3QkFDYjNCLFdBQVc7NEJBQUMyQjt5QkFBSzt3QkFDakIyRixpQkFBaUJSLFVBQVVsSixXQUFXO3dCQUN0Q3FKLFVBQVVILFVBQVVFLElBQUk7d0JBQ3hCRyxXQUFXTCxVQUFVM0osS0FBSzt3QkFDMUJpSyxZQUFZTixVQUFVMUosTUFBTTt3QkFDNUJpSyxhQUFhUCxVQUFVcEYsT0FBTzt3QkFDOUJ3RixVQUFVSixVQUFVdEYsSUFBSTtvQkFDMUI7Z0JBQ0Y7Z0JBQ0EsT0FBTztZQUNUO1FBQ0Y7UUFBRztZQUNEOUksS0FBSztZQUNMdEQsT0FBTyxTQUFTOE4sa0JBQWtCbEIsT0FBTyxFQUFFQyxTQUFTLEVBQUVULElBQUksRUFBRW1CLFVBQVU7Z0JBQ3BFLElBQUssV0FBVyxHQUFFOU0sTUFBTSxDQUFDLFVBQVUsQ0FBQ2dRLGNBQWMsQ0FBQzdELFVBQVU7b0JBQzNELE9BQU8sV0FBVyxHQUFFbk0sTUFBTSxDQUFDLFVBQVUsQ0FBQ3NQLFlBQVksQ0FBQ25ELFNBQVNDO2dCQUM5RDtnQkFDQSxJQUFJLENBQUMsR0FBR3hNLFdBQVcsQ0FBQyxVQUFVLEVBQUV1TSxVQUFVO29CQUN4QyxPQUFPQSxRQUFRQztnQkFDakI7Z0JBQ0EseUJBQXlCO2dCQUN6QixJQUFJaEYsSUFBSWdGLFVBQVVoRixDQUFDLEVBQ2pCQyxJQUFJK0UsVUFBVS9FLENBQUMsRUFDZkMsUUFBUThFLFVBQVU5RSxLQUFLLEVBQ3ZCQyxTQUFTNkUsVUFBVTdFLE1BQU0sRUFDekJkLFFBQVEyRixVQUFVM0YsS0FBSztnQkFDekIsSUFBSWlMLFFBQVE7Z0JBQ1osSUFBSXBLLFFBQVEsTUFBTUMsU0FBUyxNQUFNNkUsVUFBVXpGLFFBQVEsSUFBSWdGLFNBQVMsUUFBUTtvQkFDdEUrRixRQUFRLFdBQVcsR0FBRTFSLE1BQU0sQ0FBQyxVQUFVLENBQUNtTixhQUFhLENBQUM3TSxTQUFTcVIsT0FBTyxFQUFFO3dCQUNyRUMsUUFBUTs0QkFBQztnQ0FDUHhLLEdBQUdBLElBQUk7Z0NBQ1BDLEdBQUdBLElBQUlFLFNBQVM7NEJBQ2xCOzRCQUFHO2dDQUNESCxHQUFHQSxJQUFJO2dDQUNQQyxHQUFHQSxJQUFJRSxTQUFTLElBQUk7NEJBQ3RCOzRCQUFHO2dDQUNESCxHQUFHQSxJQUFJO2dDQUNQQyxHQUFHQSxJQUFJRSxTQUFTLElBQUk7NEJBQ3RCO3lCQUFFO29CQUNKO2dCQUNGO2dCQUNBLElBQUlzSyxPQUFPO2dCQUNYLElBQUlDLFdBQVcsQ0FBQyxHQUFHblIsVUFBVW9SLGFBQWEsRUFBRTNGLFVBQVVzQyxJQUFJO2dCQUMxRCxJQUFJcEgsUUFBUSxNQUFNQyxTQUFTLE1BQU11SyxTQUFTeEssS0FBSyxHQUFHQSxTQUFTd0ssU0FBU3ZLLE1BQU0sR0FBR0EsUUFBUTtvQkFDbkZzSyxPQUFPLFdBQVcsR0FBRTdSLE1BQU0sQ0FBQyxVQUFVLENBQUNtTixhQUFhLENBQUMsUUFBUTt3QkFDMUQvRixHQUFHQSxJQUFJO3dCQUNQQyxHQUFHQSxJQUFJRSxTQUFTLElBQUk7d0JBQ3BCeUssVUFBVTtvQkFDWixHQUFHNUYsVUFBVXNDLElBQUk7Z0JBQ25CO2dCQUNBLElBQUl1RCxTQUFTbkYsY0FBY3JNLFdBQVd5UixXQUFXO2dCQUNqRCxPQUFPLFdBQVcsR0FBRWxTLE1BQU0sQ0FBQyxVQUFVLENBQUNtTixhQUFhLENBQUMsS0FBSyxNQUFNLFdBQVcsR0FBRW5OLE1BQU0sQ0FBQyxVQUFVLENBQUNtTixhQUFhLENBQUM1TSxXQUFXNFIsU0FBUyxFQUFFN1AsU0FBUztvQkFDekk4UCxNQUFNaEcsVUFBVTdGLEtBQUssR0FBRyxJQUFJMEwsTUFBTSxDQUFDeEwsUUFBUXdMLE9BQU90UCxNQUFNLENBQUMsR0FBRztvQkFDNUQwUCxRQUFRO2dCQUNWLEdBQUcsQ0FBQyxHQUFHeFMsS0FBSyxDQUFDLFVBQVUsRUFBRXVNLFdBQVcsYUFBYTtvQkFDL0N5RSxNQUFNO2dCQUNSLEtBQUthLE9BQU9HO1lBQ2Q7UUFDRjtLQUFFO0FBQ0osRUFBRTdSLE9BQU9zUyxhQUFhO0FBQ3RCek0sZ0JBQWdCckcsU0FBUyxlQUFlO0FBQ3hDcUcsZ0JBQWdCckcsU0FBUyxnQkFBZ0I7SUFDdkN1SSxhQUFhLE1BQU8sS0FBSUssS0FBS21LLElBQUksQ0FBQyxFQUFDO0lBQ25DMUcsU0FBUztJQUNURixNQUFNO0lBQ05hLG1CQUFtQixDQUFDNUwsUUFBUTRSLE1BQU0sQ0FBQ0MsS0FBSztJQUN4QzdGLHlCQUF5QixDQUFDaE0sUUFBUTRSLE1BQU0sQ0FBQ0MsS0FBSztJQUM5Q2hHLGdCQUFnQjtJQUNoQkMsbUJBQW1CO0lBQ25CQyxpQkFBaUI7QUFDbkIiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXGNoYXJ0XFxUcmVlbWFwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuVHJlZW1hcCA9IHZvaWQgMDtcclxudmFyIF9pc05hTiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc05hTlwiKSk7XHJcbnZhciBfaXNGdW5jdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpKTtcclxudmFyIF9vbWl0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL29taXRcIikpO1xyXG52YXIgX2dldCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9nZXRcIikpO1xyXG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcclxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBfcmVhY3RTbW9vdGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1zbW9vdGhcIikpO1xyXG52YXIgX1Rvb2x0aXAgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50L1Rvb2x0aXBcIik7XHJcbnZhciBfTGF5ZXIgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL0xheWVyXCIpO1xyXG52YXIgX1N1cmZhY2UgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL1N1cmZhY2VcIik7XHJcbnZhciBfUG9seWdvbiA9IHJlcXVpcmUoXCIuLi9zaGFwZS9Qb2x5Z29uXCIpO1xyXG52YXIgX1JlY3RhbmdsZSA9IHJlcXVpcmUoXCIuLi9zaGFwZS9SZWN0YW5nbGVcIik7XHJcbnZhciBfQ2hhcnRVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NoYXJ0VXRpbHNcIik7XHJcbnZhciBfQ29uc3RhbnRzID0gcmVxdWlyZShcIi4uL3V0aWwvQ29uc3RhbnRzXCIpO1xyXG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0RhdGFVdGlsc1wiKTtcclxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0RPTVV0aWxzXCIpO1xyXG52YXIgX0dsb2JhbCA9IHJlcXVpcmUoXCIuLi91dGlsL0dsb2JhbFwiKTtcclxudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmVhY3RVdGlsc1wiKTtcclxudmFyIF9leGNsdWRlZCA9IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwiY2xhc3NOYW1lXCIsIFwic3R5bGVcIiwgXCJjaGlsZHJlblwiLCBcInR5cGVcIl07XHJcbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBudWxsOyB2YXIgciA9IG5ldyBXZWFrTWFwKCksIHQgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IHJldHVybiBlID8gdCA6IHI7IH0pKGUpOyB9XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHUpKSB7IHZhciBpID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdSkgOiBudWxsOyBpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgdSwgaSkgOiBuW3VdID0gZVt1XTsgfSByZXR1cm4gbltcImRlZmF1bHRcIl0gPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XHJcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XHJcbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XHJcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxyXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cclxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XHJcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XHJcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XHJcbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cclxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH0gLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgVHJlZW1hcENoYXJ0XHJcbiAqL1xyXG52YXIgTk9ERV9WQUxVRV9LRVkgPSAndmFsdWUnO1xyXG52YXIgY29tcHV0ZU5vZGUgPSBmdW5jdGlvbiBjb21wdXRlTm9kZShfcmVmKSB7XHJcbiAgdmFyIGRlcHRoID0gX3JlZi5kZXB0aCxcclxuICAgIG5vZGUgPSBfcmVmLm5vZGUsXHJcbiAgICBpbmRleCA9IF9yZWYuaW5kZXgsXHJcbiAgICB2YWx1ZUtleSA9IF9yZWYudmFsdWVLZXk7XHJcbiAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcclxuICB2YXIgY2hpbGREZXB0aCA9IGRlcHRoICsgMTtcclxuICB2YXIgY29tcHV0ZWRDaGlsZHJlbiA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQsIGkpIHtcclxuICAgIHJldHVybiBjb21wdXRlTm9kZSh7XHJcbiAgICAgIGRlcHRoOiBjaGlsZERlcHRoLFxyXG4gICAgICBub2RlOiBjaGlsZCxcclxuICAgICAgaW5kZXg6IGksXHJcbiAgICAgIHZhbHVlS2V5OiB2YWx1ZUtleVxyXG4gICAgfSk7XHJcbiAgfSkgOiBudWxsO1xyXG4gIHZhciBub2RlVmFsdWU7XHJcbiAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgbm9kZVZhbHVlID0gY29tcHV0ZWRDaGlsZHJlbi5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgY2hpbGQpIHtcclxuICAgICAgcmV0dXJuIHJlc3VsdCArIGNoaWxkW05PREVfVkFMVUVfS0VZXTtcclxuICAgIH0sIDApO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBUT0RPIG5lZWQgdG8gdmVyaWZ5IHZhbHVlS2V5XHJcbiAgICBub2RlVmFsdWUgPSAoMCwgX2lzTmFOW1wiZGVmYXVsdFwiXSkobm9kZVt2YWx1ZUtleV0pIHx8IG5vZGVbdmFsdWVLZXldIDw9IDAgPyAwIDogbm9kZVt2YWx1ZUtleV07XHJcbiAgfVxyXG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG5vZGUpLCB7fSwgX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoe1xyXG4gICAgY2hpbGRyZW46IGNvbXB1dGVkQ2hpbGRyZW5cclxuICB9LCBOT0RFX1ZBTFVFX0tFWSwgbm9kZVZhbHVlKSwgXCJkZXB0aFwiLCBkZXB0aCksIFwiaW5kZXhcIiwgaW5kZXgpKTtcclxufTtcclxudmFyIGZpbHRlclJlY3QgPSBmdW5jdGlvbiBmaWx0ZXJSZWN0KG5vZGUpIHtcclxuICByZXR1cm4ge1xyXG4gICAgeDogbm9kZS54LFxyXG4gICAgeTogbm9kZS55LFxyXG4gICAgd2lkdGg6IG5vZGUud2lkdGgsXHJcbiAgICBoZWlnaHQ6IG5vZGUuaGVpZ2h0XHJcbiAgfTtcclxufTtcclxuXHJcbi8vIENvbXB1dGUgdGhlIGFyZWEgZm9yIGVhY2ggY2hpbGQgYmFzZWQgb24gdmFsdWUgJiBzY2FsZS5cclxudmFyIGdldEFyZWFPZkNoaWxkcmVuID0gZnVuY3Rpb24gZ2V0QXJlYU9mQ2hpbGRyZW4oY2hpbGRyZW4sIGFyZWFWYWx1ZVJhdGlvKSB7XHJcbiAgdmFyIHJhdGlvID0gYXJlYVZhbHVlUmF0aW8gPCAwID8gMCA6IGFyZWFWYWx1ZVJhdGlvO1xyXG4gIHJldHVybiBjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICB2YXIgYXJlYSA9IGNoaWxkW05PREVfVkFMVUVfS0VZXSAqIHJhdGlvO1xyXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY2hpbGQpLCB7fSwge1xyXG4gICAgICBhcmVhOiAoMCwgX2lzTmFOW1wiZGVmYXVsdFwiXSkoYXJlYSkgfHwgYXJlYSA8PSAwID8gMCA6IGFyZWFcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59O1xyXG5cclxuLy8gQ29tcHV0ZXMgdGhlIHNjb3JlIGZvciB0aGUgc3BlY2lmaWVkIHJvdywgYXMgdGhlIHdvcnN0IGFzcGVjdCByYXRpby5cclxudmFyIGdldFdvcnN0U2NvcmUgPSBmdW5jdGlvbiBnZXRXb3JzdFNjb3JlKHJvdywgcGFyZW50U2l6ZSwgYXNwZWN0UmF0aW8pIHtcclxuICB2YXIgcGFyZW50QXJlYSA9IHBhcmVudFNpemUgKiBwYXJlbnRTaXplO1xyXG4gIHZhciByb3dBcmVhID0gcm93LmFyZWEgKiByb3cuYXJlYTtcclxuICB2YXIgX3JvdyRyZWR1Y2UgPSByb3cucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGNoaWxkKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbWluOiBNYXRoLm1pbihyZXN1bHQubWluLCBjaGlsZC5hcmVhKSxcclxuICAgICAgICBtYXg6IE1hdGgubWF4KHJlc3VsdC5tYXgsIGNoaWxkLmFyZWEpXHJcbiAgICAgIH07XHJcbiAgICB9LCB7XHJcbiAgICAgIG1pbjogSW5maW5pdHksXHJcbiAgICAgIG1heDogMFxyXG4gICAgfSksXHJcbiAgICBtaW4gPSBfcm93JHJlZHVjZS5taW4sXHJcbiAgICBtYXggPSBfcm93JHJlZHVjZS5tYXg7XHJcbiAgcmV0dXJuIHJvd0FyZWEgPyBNYXRoLm1heChwYXJlbnRBcmVhICogbWF4ICogYXNwZWN0UmF0aW8gLyByb3dBcmVhLCByb3dBcmVhIC8gKHBhcmVudEFyZWEgKiBtaW4gKiBhc3BlY3RSYXRpbykpIDogSW5maW5pdHk7XHJcbn07XHJcbnZhciBob3Jpem9udGFsUG9zaXRpb24gPSBmdW5jdGlvbiBob3Jpem9udGFsUG9zaXRpb24ocm93LCBwYXJlbnRTaXplLCBwYXJlbnRSZWN0LCBpc0ZsdXNoKSB7XHJcbiAgdmFyIHJvd0hlaWdodCA9IHBhcmVudFNpemUgPyBNYXRoLnJvdW5kKHJvdy5hcmVhIC8gcGFyZW50U2l6ZSkgOiAwO1xyXG4gIGlmIChpc0ZsdXNoIHx8IHJvd0hlaWdodCA+IHBhcmVudFJlY3QuaGVpZ2h0KSB7XHJcbiAgICByb3dIZWlnaHQgPSBwYXJlbnRSZWN0LmhlaWdodDtcclxuICB9XHJcbiAgdmFyIGN1clggPSBwYXJlbnRSZWN0Lng7XHJcbiAgdmFyIGNoaWxkO1xyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb3cubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIGNoaWxkID0gcm93W2ldO1xyXG4gICAgY2hpbGQueCA9IGN1clg7XHJcbiAgICBjaGlsZC55ID0gcGFyZW50UmVjdC55O1xyXG4gICAgY2hpbGQuaGVpZ2h0ID0gcm93SGVpZ2h0O1xyXG4gICAgY2hpbGQud2lkdGggPSBNYXRoLm1pbihyb3dIZWlnaHQgPyBNYXRoLnJvdW5kKGNoaWxkLmFyZWEgLyByb3dIZWlnaHQpIDogMCwgcGFyZW50UmVjdC54ICsgcGFyZW50UmVjdC53aWR0aCAtIGN1clgpO1xyXG4gICAgY3VyWCArPSBjaGlsZC53aWR0aDtcclxuICB9XHJcbiAgLy8gYWRkIHRoZSByZW1haW4geCB0byB0aGUgbGFzdCBvbmUgb2Ygcm93XHJcbiAgY2hpbGQud2lkdGggKz0gcGFyZW50UmVjdC54ICsgcGFyZW50UmVjdC53aWR0aCAtIGN1clg7XHJcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGFyZW50UmVjdCksIHt9LCB7XHJcbiAgICB5OiBwYXJlbnRSZWN0LnkgKyByb3dIZWlnaHQsXHJcbiAgICBoZWlnaHQ6IHBhcmVudFJlY3QuaGVpZ2h0IC0gcm93SGVpZ2h0XHJcbiAgfSk7XHJcbn07XHJcbnZhciB2ZXJ0aWNhbFBvc2l0aW9uID0gZnVuY3Rpb24gdmVydGljYWxQb3NpdGlvbihyb3csIHBhcmVudFNpemUsIHBhcmVudFJlY3QsIGlzRmx1c2gpIHtcclxuICB2YXIgcm93V2lkdGggPSBwYXJlbnRTaXplID8gTWF0aC5yb3VuZChyb3cuYXJlYSAvIHBhcmVudFNpemUpIDogMDtcclxuICBpZiAoaXNGbHVzaCB8fCByb3dXaWR0aCA+IHBhcmVudFJlY3Qud2lkdGgpIHtcclxuICAgIHJvd1dpZHRoID0gcGFyZW50UmVjdC53aWR0aDtcclxuICB9XHJcbiAgdmFyIGN1clkgPSBwYXJlbnRSZWN0Lnk7XHJcbiAgdmFyIGNoaWxkO1xyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb3cubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIGNoaWxkID0gcm93W2ldO1xyXG4gICAgY2hpbGQueCA9IHBhcmVudFJlY3QueDtcclxuICAgIGNoaWxkLnkgPSBjdXJZO1xyXG4gICAgY2hpbGQud2lkdGggPSByb3dXaWR0aDtcclxuICAgIGNoaWxkLmhlaWdodCA9IE1hdGgubWluKHJvd1dpZHRoID8gTWF0aC5yb3VuZChjaGlsZC5hcmVhIC8gcm93V2lkdGgpIDogMCwgcGFyZW50UmVjdC55ICsgcGFyZW50UmVjdC5oZWlnaHQgLSBjdXJZKTtcclxuICAgIGN1clkgKz0gY2hpbGQuaGVpZ2h0O1xyXG4gIH1cclxuICBpZiAoY2hpbGQpIHtcclxuICAgIGNoaWxkLmhlaWdodCArPSBwYXJlbnRSZWN0LnkgKyBwYXJlbnRSZWN0LmhlaWdodCAtIGN1clk7XHJcbiAgfVxyXG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBhcmVudFJlY3QpLCB7fSwge1xyXG4gICAgeDogcGFyZW50UmVjdC54ICsgcm93V2lkdGgsXHJcbiAgICB3aWR0aDogcGFyZW50UmVjdC53aWR0aCAtIHJvd1dpZHRoXHJcbiAgfSk7XHJcbn07XHJcbnZhciBwb3NpdGlvbiA9IGZ1bmN0aW9uIHBvc2l0aW9uKHJvdywgcGFyZW50U2l6ZSwgcGFyZW50UmVjdCwgaXNGbHVzaCkge1xyXG4gIGlmIChwYXJlbnRTaXplID09PSBwYXJlbnRSZWN0LndpZHRoKSB7XHJcbiAgICByZXR1cm4gaG9yaXpvbnRhbFBvc2l0aW9uKHJvdywgcGFyZW50U2l6ZSwgcGFyZW50UmVjdCwgaXNGbHVzaCk7XHJcbiAgfVxyXG4gIHJldHVybiB2ZXJ0aWNhbFBvc2l0aW9uKHJvdywgcGFyZW50U2l6ZSwgcGFyZW50UmVjdCwgaXNGbHVzaCk7XHJcbn07XHJcblxyXG4vLyBSZWN1cnNpdmVseSBhcnJhbmdlcyB0aGUgc3BlY2lmaWVkIG5vZGUncyBjaGlsZHJlbiBpbnRvIHNxdWFyaWZpZWQgcm93cy5cclxudmFyIHNxdWFyaWZ5ID0gZnVuY3Rpb24gc3F1YXJpZnkobm9kZSwgYXNwZWN0UmF0aW8pIHtcclxuICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xyXG4gIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgIHZhciByZWN0ID0gZmlsdGVyUmVjdChub2RlKTtcclxuICAgIC8vIG1heWJlIGEgYnVnXHJcbiAgICB2YXIgcm93ID0gW107XHJcbiAgICB2YXIgYmVzdCA9IEluZmluaXR5OyAvLyB0aGUgYmVzdCByb3cgc2NvcmUgc28gZmFyXHJcbiAgICB2YXIgY2hpbGQsIHNjb3JlOyAvLyB0aGUgY3VycmVudCByb3cgc2NvcmVcclxuICAgIHZhciBzaXplID0gTWF0aC5taW4ocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpOyAvLyBpbml0aWFsIG9yaWVudGF0aW9uXHJcbiAgICB2YXIgc2NhbGVDaGlsZHJlbiA9IGdldEFyZWFPZkNoaWxkcmVuKGNoaWxkcmVuLCByZWN0LndpZHRoICogcmVjdC5oZWlnaHQgLyBub2RlW05PREVfVkFMVUVfS0VZXSk7XHJcbiAgICB2YXIgdGVtcENoaWxkcmVuID0gc2NhbGVDaGlsZHJlbi5zbGljZSgpO1xyXG4gICAgcm93LmFyZWEgPSAwO1xyXG4gICAgd2hpbGUgKHRlbXBDaGlsZHJlbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgIC8vIHJvdyBmaXJzdFxyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcclxuICAgICAgcm93LnB1c2goY2hpbGQgPSB0ZW1wQ2hpbGRyZW5bMF0pO1xyXG4gICAgICByb3cuYXJlYSArPSBjaGlsZC5hcmVhO1xyXG4gICAgICBzY29yZSA9IGdldFdvcnN0U2NvcmUocm93LCBzaXplLCBhc3BlY3RSYXRpbyk7XHJcbiAgICAgIGlmIChzY29yZSA8PSBiZXN0KSB7XHJcbiAgICAgICAgLy8gY29udGludWUgd2l0aCB0aGlzIG9yaWVudGF0aW9uXHJcbiAgICAgICAgdGVtcENoaWxkcmVuLnNoaWZ0KCk7XHJcbiAgICAgICAgYmVzdCA9IHNjb3JlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGFib3J0LCBhbmQgdHJ5IGEgZGlmZmVyZW50IG9yaWVudGF0aW9uXHJcbiAgICAgICAgcm93LmFyZWEgLT0gcm93LnBvcCgpLmFyZWE7XHJcbiAgICAgICAgcmVjdCA9IHBvc2l0aW9uKHJvdywgc2l6ZSwgcmVjdCwgZmFsc2UpO1xyXG4gICAgICAgIHNpemUgPSBNYXRoLm1pbihyZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XHJcbiAgICAgICAgcm93Lmxlbmd0aCA9IHJvdy5hcmVhID0gMDtcclxuICAgICAgICBiZXN0ID0gSW5maW5pdHk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChyb3cubGVuZ3RoKSB7XHJcbiAgICAgIHJlY3QgPSBwb3NpdGlvbihyb3csIHNpemUsIHJlY3QsIHRydWUpO1xyXG4gICAgICByb3cubGVuZ3RoID0gcm93LmFyZWEgPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbm9kZSksIHt9LCB7XHJcbiAgICAgIGNoaWxkcmVuOiBzY2FsZUNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykge1xyXG4gICAgICAgIHJldHVybiBzcXVhcmlmeShjLCBhc3BlY3RSYXRpbyk7XHJcbiAgICAgIH0pXHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIG5vZGU7XHJcbn07XHJcbnZhciBkZWZhdWx0U3RhdGUgPSB7XHJcbiAgaXNUb29sdGlwQWN0aXZlOiBmYWxzZSxcclxuICBpc0FuaW1hdGlvbkZpbmlzaGVkOiBmYWxzZSxcclxuICBhY3RpdmVOb2RlOiBudWxsLFxyXG4gIGZvcm1hdFJvb3Q6IG51bGwsXHJcbiAgY3VycmVudFJvb3Q6IG51bGwsXHJcbiAgbmVzdEluZGV4OiBbXVxyXG59O1xyXG52YXIgVHJlZW1hcCA9IGV4cG9ydHMuVHJlZW1hcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1B1cmVDb21wb25lbnQpIHtcclxuICBmdW5jdGlvbiBUcmVlbWFwKCkge1xyXG4gICAgdmFyIF90aGlzO1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyZWVtYXApO1xyXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgICB9XHJcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgVHJlZW1hcCwgW10uY29uY2F0KGFyZ3MpKTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJzdGF0ZVwiLCBfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0U3RhdGUpKTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVBbmltYXRpb25FbmRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgb25BbmltYXRpb25FbmQgPSBfdGhpcy5wcm9wcy5vbkFuaW1hdGlvbkVuZDtcclxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvbkFuaW1hdGlvbkVuZCkpIHtcclxuICAgICAgICBvbkFuaW1hdGlvbkVuZCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVBbmltYXRpb25TdGFydFwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBvbkFuaW1hdGlvblN0YXJ0ID0gX3RoaXMucHJvcHMub25BbmltYXRpb25TdGFydDtcclxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6IGZhbHNlXHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob25BbmltYXRpb25TdGFydCkpIHtcclxuICAgICAgICBvbkFuaW1hdGlvblN0YXJ0KCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuICBfaW5oZXJpdHMoVHJlZW1hcCwgX1B1cmVDb21wb25lbnQpO1xyXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoVHJlZW1hcCwgW3tcclxuICAgIGtleTogXCJoYW5kbGVNb3VzZUVudGVyXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTW91c2VFbnRlcihub2RlLCBlKSB7XHJcbiAgICAgIGUucGVyc2lzdCgpO1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIG9uTW91c2VFbnRlciA9IF90aGlzJHByb3BzLm9uTW91c2VFbnRlcixcclxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuO1xyXG4gICAgICB2YXIgdG9vbHRpcEl0ZW0gPSAoMCwgX1JlYWN0VXRpbHMuZmluZENoaWxkQnlUeXBlKShjaGlsZHJlbiwgX1Rvb2x0aXAuVG9vbHRpcCk7XHJcbiAgICAgIGlmICh0b29sdGlwSXRlbSkge1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgaXNUb29sdGlwQWN0aXZlOiB0cnVlLFxyXG4gICAgICAgICAgYWN0aXZlTm9kZTogbm9kZVxyXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGlmIChvbk1vdXNlRW50ZXIpIHtcclxuICAgICAgICAgICAgb25Nb3VzZUVudGVyKG5vZGUsIGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2UgaWYgKG9uTW91c2VFbnRlcikge1xyXG4gICAgICAgIG9uTW91c2VFbnRlcihub2RlLCBlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJoYW5kbGVNb3VzZUxlYXZlXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTW91c2VMZWF2ZShub2RlLCBlKSB7XHJcbiAgICAgIGUucGVyc2lzdCgpO1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBvbk1vdXNlTGVhdmUgPSBfdGhpcyRwcm9wczIub25Nb3VzZUxlYXZlLFxyXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMyLmNoaWxkcmVuO1xyXG4gICAgICB2YXIgdG9vbHRpcEl0ZW0gPSAoMCwgX1JlYWN0VXRpbHMuZmluZENoaWxkQnlUeXBlKShjaGlsZHJlbiwgX1Rvb2x0aXAuVG9vbHRpcCk7XHJcbiAgICAgIGlmICh0b29sdGlwSXRlbSkge1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgaXNUb29sdGlwQWN0aXZlOiBmYWxzZSxcclxuICAgICAgICAgIGFjdGl2ZU5vZGU6IG51bGxcclxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBpZiAob25Nb3VzZUxlYXZlKSB7XHJcbiAgICAgICAgICAgIG9uTW91c2VMZWF2ZShub2RlLCBlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIGlmIChvbk1vdXNlTGVhdmUpIHtcclxuICAgICAgICBvbk1vdXNlTGVhdmUobm9kZSwgZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiaGFuZGxlQ2xpY2tcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDbGljayhub2RlKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIG9uQ2xpY2sgPSBfdGhpcyRwcm9wczMub25DbGljayxcclxuICAgICAgICB0eXBlID0gX3RoaXMkcHJvcHMzLnR5cGU7XHJcbiAgICAgIGlmICh0eXBlID09PSAnbmVzdCcgJiYgbm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczQud2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczQuaGVpZ2h0LFxyXG4gICAgICAgICAgZGF0YUtleSA9IF90aGlzJHByb3BzNC5kYXRhS2V5LFxyXG4gICAgICAgICAgYXNwZWN0UmF0aW8gPSBfdGhpcyRwcm9wczQuYXNwZWN0UmF0aW87XHJcbiAgICAgICAgdmFyIHJvb3QgPSBjb21wdXRlTm9kZSh7XHJcbiAgICAgICAgICBkZXB0aDogMCxcclxuICAgICAgICAgIG5vZGU6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbm9kZSksIHt9LCB7XHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgaW5kZXg6IDAsXHJcbiAgICAgICAgICB2YWx1ZUtleTogZGF0YUtleVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBmb3JtYXRSb290ID0gc3F1YXJpZnkocm9vdCwgYXNwZWN0UmF0aW8pO1xyXG4gICAgICAgIHZhciBuZXN0SW5kZXggPSB0aGlzLnN0YXRlLm5lc3RJbmRleDtcclxuICAgICAgICBuZXN0SW5kZXgucHVzaChub2RlKTtcclxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgIGZvcm1hdFJvb3Q6IGZvcm1hdFJvb3QsXHJcbiAgICAgICAgICBjdXJyZW50Um9vdDogcm9vdCxcclxuICAgICAgICAgIG5lc3RJbmRleDogbmVzdEluZGV4XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG9uQ2xpY2spIHtcclxuICAgICAgICBvbkNsaWNrKG5vZGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImhhbmRsZU5lc3RJbmRleFwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU5lc3RJbmRleChub2RlLCBpKSB7XHJcbiAgICAgIHZhciBuZXN0SW5kZXggPSB0aGlzLnN0YXRlLm5lc3RJbmRleDtcclxuICAgICAgdmFyIF90aGlzJHByb3BzNSA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczUud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHM1LmhlaWdodCxcclxuICAgICAgICBkYXRhS2V5ID0gX3RoaXMkcHJvcHM1LmRhdGFLZXksXHJcbiAgICAgICAgYXNwZWN0UmF0aW8gPSBfdGhpcyRwcm9wczUuYXNwZWN0UmF0aW87XHJcbiAgICAgIHZhciByb290ID0gY29tcHV0ZU5vZGUoe1xyXG4gICAgICAgIGRlcHRoOiAwLFxyXG4gICAgICAgIG5vZGU6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbm9kZSksIHt9LCB7XHJcbiAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgeTogMCxcclxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgaW5kZXg6IDAsXHJcbiAgICAgICAgdmFsdWVLZXk6IGRhdGFLZXlcclxuICAgICAgfSk7XHJcbiAgICAgIHZhciBmb3JtYXRSb290ID0gc3F1YXJpZnkocm9vdCwgYXNwZWN0UmF0aW8pO1xyXG4gICAgICBuZXN0SW5kZXggPSBuZXN0SW5kZXguc2xpY2UoMCwgaSArIDEpO1xyXG4gICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICBmb3JtYXRSb290OiBmb3JtYXRSb290LFxyXG4gICAgICAgIGN1cnJlbnRSb290OiBub2RlLFxyXG4gICAgICAgIG5lc3RJbmRleDogbmVzdEluZGV4XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJJdGVtXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVySXRlbShjb250ZW50LCBub2RlUHJvcHMsIGlzTGVhZikge1xyXG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuICAgICAgdmFyIF90aGlzJHByb3BzNiA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wczYuaXNBbmltYXRpb25BY3RpdmUsXHJcbiAgICAgICAgYW5pbWF0aW9uQmVnaW4gPSBfdGhpcyRwcm9wczYuYW5pbWF0aW9uQmVnaW4sXHJcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb24gPSBfdGhpcyRwcm9wczYuYW5pbWF0aW9uRHVyYXRpb24sXHJcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nID0gX3RoaXMkcHJvcHM2LmFuaW1hdGlvbkVhc2luZyxcclxuICAgICAgICBpc1VwZGF0ZUFuaW1hdGlvbkFjdGl2ZSA9IF90aGlzJHByb3BzNi5pc1VwZGF0ZUFuaW1hdGlvbkFjdGl2ZSxcclxuICAgICAgICB0eXBlID0gX3RoaXMkcHJvcHM2LnR5cGUsXHJcbiAgICAgICAgYW5pbWF0aW9uSWQgPSBfdGhpcyRwcm9wczYuYW5pbWF0aW9uSWQsXHJcbiAgICAgICAgY29sb3JQYW5lbCA9IF90aGlzJHByb3BzNi5jb2xvclBhbmVsO1xyXG4gICAgICB2YXIgaXNBbmltYXRpb25GaW5pc2hlZCA9IHRoaXMuc3RhdGUuaXNBbmltYXRpb25GaW5pc2hlZDtcclxuICAgICAgdmFyIHdpZHRoID0gbm9kZVByb3BzLndpZHRoLFxyXG4gICAgICAgIGhlaWdodCA9IG5vZGVQcm9wcy5oZWlnaHQsXHJcbiAgICAgICAgeCA9IG5vZGVQcm9wcy54LFxyXG4gICAgICAgIHkgPSBub2RlUHJvcHMueSxcclxuICAgICAgICBkZXB0aCA9IG5vZGVQcm9wcy5kZXB0aDtcclxuICAgICAgdmFyIHRyYW5zbGF0ZVggPSBwYXJzZUludChcIlwiLmNvbmNhdCgoTWF0aC5yYW5kb20oKSAqIDIgLSAxKSAqIHdpZHRoKSwgMTApO1xyXG4gICAgICB2YXIgZXZlbnQgPSB7fTtcclxuICAgICAgaWYgKGlzTGVhZiB8fCB0eXBlID09PSAnbmVzdCcpIHtcclxuICAgICAgICBldmVudCA9IHtcclxuICAgICAgICAgIG9uTW91c2VFbnRlcjogdGhpcy5oYW5kbGVNb3VzZUVudGVyLmJpbmQodGhpcywgbm9kZVByb3BzKSxcclxuICAgICAgICAgIG9uTW91c2VMZWF2ZTogdGhpcy5oYW5kbGVNb3VzZUxlYXZlLmJpbmQodGhpcywgbm9kZVByb3BzKSxcclxuICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xpY2suYmluZCh0aGlzLCBub2RlUHJvcHMpXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWlzQW5pbWF0aW9uQWN0aXZlKSB7XHJcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCBldmVudCwgdGhpcy5jb25zdHJ1Y3Rvci5yZW5kZXJDb250ZW50SXRlbShjb250ZW50LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG5vZGVQcm9wcyksIHt9LCB7XHJcbiAgICAgICAgICBpc0FuaW1hdGlvbkFjdGl2ZTogZmFsc2UsXHJcbiAgICAgICAgICBpc1VwZGF0ZUFuaW1hdGlvbkFjdGl2ZTogZmFsc2UsXHJcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICB5OiB5XHJcbiAgICAgICAgfSksIHR5cGUsIGNvbG9yUGFuZWwpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfcmVhY3RTbW9vdGhbXCJkZWZhdWx0XCJdLCB7XHJcbiAgICAgICAgYmVnaW46IGFuaW1hdGlvbkJlZ2luLFxyXG4gICAgICAgIGR1cmF0aW9uOiBhbmltYXRpb25EdXJhdGlvbixcclxuICAgICAgICBpc0FjdGl2ZTogaXNBbmltYXRpb25BY3RpdmUsXHJcbiAgICAgICAgZWFzaW5nOiBhbmltYXRpb25FYXNpbmcsXHJcbiAgICAgICAga2V5OiBcInRyZWVtYXAtXCIuY29uY2F0KGFuaW1hdGlvbklkKSxcclxuICAgICAgICBmcm9tOiB7XHJcbiAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgeTogeSxcclxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0bzoge1xyXG4gICAgICAgICAgeDogeCxcclxuICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25BbmltYXRpb25TdGFydDogdGhpcy5oYW5kbGVBbmltYXRpb25TdGFydCxcclxuICAgICAgICBvbkFuaW1hdGlvbkVuZDogdGhpcy5oYW5kbGVBbmltYXRpb25FbmRcclxuICAgICAgfSwgZnVuY3Rpb24gKF9yZWYyKSB7XHJcbiAgICAgICAgdmFyIGN1cnJYID0gX3JlZjIueCxcclxuICAgICAgICAgIGN1cnJZID0gX3JlZjIueSxcclxuICAgICAgICAgIGN1cnJXaWR0aCA9IF9yZWYyLndpZHRoLFxyXG4gICAgICAgICAgY3VyckhlaWdodCA9IF9yZWYyLmhlaWdodDtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfcmVhY3RTbW9vdGhbXCJkZWZhdWx0XCJdLCB7XHJcbiAgICAgICAgICBmcm9tOiBcInRyYW5zbGF0ZShcIi5jb25jYXQodHJhbnNsYXRlWCwgXCJweCwgXCIpLmNvbmNhdCh0cmFuc2xhdGVYLCBcInB4KVwiKSxcclxuICAgICAgICAgIHRvOiBcInRyYW5zbGF0ZSgwLCAwKVwiLFxyXG4gICAgICAgICAgYXR0cmlidXRlTmFtZTogXCJ0cmFuc2Zvcm1cIixcclxuICAgICAgICAgIGJlZ2luOiBhbmltYXRpb25CZWdpbixcclxuICAgICAgICAgIGVhc2luZzogYW5pbWF0aW9uRWFzaW5nLFxyXG4gICAgICAgICAgaXNBY3RpdmU6IGlzQW5pbWF0aW9uQWN0aXZlLFxyXG4gICAgICAgICAgZHVyYXRpb246IGFuaW1hdGlvbkR1cmF0aW9uXHJcbiAgICAgICAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIGV2ZW50LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAvLyB3aGVuIGFuaW1hdGlvbiBEdXJhdGlvbiAsIG9ubHkgcmVuZGVyIGRlcHRoPTEgbm9kZXNcclxuICAgICAgICAgIGlmIChkZXB0aCA+IDIgJiYgIWlzQW5pbWF0aW9uRmluaXNoZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmNvbnN0cnVjdG9yLnJlbmRlckNvbnRlbnRJdGVtKGNvbnRlbnQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbm9kZVByb3BzKSwge30sIHtcclxuICAgICAgICAgICAgaXNBbmltYXRpb25BY3RpdmU6IGlzQW5pbWF0aW9uQWN0aXZlLFxyXG4gICAgICAgICAgICBpc1VwZGF0ZUFuaW1hdGlvbkFjdGl2ZTogIWlzVXBkYXRlQW5pbWF0aW9uQWN0aXZlLFxyXG4gICAgICAgICAgICB3aWR0aDogY3VycldpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGN1cnJIZWlnaHQsXHJcbiAgICAgICAgICAgIHg6IGN1cnJYLFxyXG4gICAgICAgICAgICB5OiBjdXJyWVxyXG4gICAgICAgICAgfSksIHR5cGUsIGNvbG9yUGFuZWwpO1xyXG4gICAgICAgIH0oKSkpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyTm9kZVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlck5vZGUocm9vdCwgbm9kZSkge1xyXG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcclxuICAgICAgdmFyIF90aGlzJHByb3BzNyA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgY29udGVudCA9IF90aGlzJHByb3BzNy5jb250ZW50LFxyXG4gICAgICAgIHR5cGUgPSBfdGhpcyRwcm9wczcudHlwZTtcclxuICAgICAgdmFyIG5vZGVQcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRoaXMucHJvcHMsIGZhbHNlKSksIG5vZGUpLCB7fSwge1xyXG4gICAgICAgIHJvb3Q6IHJvb3RcclxuICAgICAgfSk7XHJcbiAgICAgIHZhciBpc0xlYWYgPSAhbm9kZS5jaGlsZHJlbiB8fCAhbm9kZS5jaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgIHZhciBjdXJyZW50Um9vdCA9IHRoaXMuc3RhdGUuY3VycmVudFJvb3Q7XHJcbiAgICAgIHZhciBpc0N1cnJlbnRSb290Q2hpbGQgPSAoY3VycmVudFJvb3QuY2hpbGRyZW4gfHwgW10pLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpdGVtLmRlcHRoID09PSBub2RlLmRlcHRoICYmIGl0ZW0ubmFtZSA9PT0gbm9kZS5uYW1lO1xyXG4gICAgICB9KTtcclxuICAgICAgaWYgKCFpc0N1cnJlbnRSb290Q2hpbGQubGVuZ3RoICYmIHJvb3QuZGVwdGggJiYgdHlwZSA9PT0gJ25lc3QnKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XHJcbiAgICAgICAga2V5OiBcInJlY2hhcnRzLXRyZWVtYXAtbm9kZS1cIi5jb25jYXQobm9kZVByb3BzLngsIFwiLVwiKS5jb25jYXQobm9kZVByb3BzLnksIFwiLVwiKS5jb25jYXQobm9kZVByb3BzLm5hbWUpLFxyXG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy10cmVlbWFwLWRlcHRoLVwiLmNvbmNhdChub2RlLmRlcHRoKVxyXG4gICAgICB9LCB0aGlzLnJlbmRlckl0ZW0oY29udGVudCwgbm9kZVByb3BzLCBpc0xlYWYpLCBub2RlLmNoaWxkcmVuICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID8gbm9kZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzMy5yZW5kZXJOb2RlKG5vZGUsIGNoaWxkKTtcclxuICAgICAgfSkgOiBudWxsKTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyQWxsTm9kZXNcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJBbGxOb2RlcygpIHtcclxuICAgICAgdmFyIGZvcm1hdFJvb3QgPSB0aGlzLnN0YXRlLmZvcm1hdFJvb3Q7XHJcbiAgICAgIGlmICghZm9ybWF0Um9vdCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlck5vZGUoZm9ybWF0Um9vdCwgZm9ybWF0Um9vdCk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJlbmRlclRvb2x0aXBcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJUb29sdGlwKCkge1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHM4ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzOC5jaGlsZHJlbixcclxuICAgICAgICBuYW1lS2V5ID0gX3RoaXMkcHJvcHM4Lm5hbWVLZXk7XHJcbiAgICAgIHZhciB0b29sdGlwSXRlbSA9ICgwLCBfUmVhY3RVdGlscy5maW5kQ2hpbGRCeVR5cGUpKGNoaWxkcmVuLCBfVG9vbHRpcC5Ub29sdGlwKTtcclxuICAgICAgaWYgKCF0b29sdGlwSXRlbSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczkgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHM5LndpZHRoLFxyXG4gICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzOS5oZWlnaHQ7XHJcbiAgICAgIHZhciBfdGhpcyRzdGF0ZSA9IHRoaXMuc3RhdGUsXHJcbiAgICAgICAgaXNUb29sdGlwQWN0aXZlID0gX3RoaXMkc3RhdGUuaXNUb29sdGlwQWN0aXZlLFxyXG4gICAgICAgIGFjdGl2ZU5vZGUgPSBfdGhpcyRzdGF0ZS5hY3RpdmVOb2RlO1xyXG4gICAgICB2YXIgdmlld0JveCA9IHtcclxuICAgICAgICB4OiAwLFxyXG4gICAgICAgIHk6IDAsXHJcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICAgIH07XHJcbiAgICAgIHZhciBjb29yZGluYXRlID0gYWN0aXZlTm9kZSA/IHtcclxuICAgICAgICB4OiBhY3RpdmVOb2RlLnggKyBhY3RpdmVOb2RlLndpZHRoIC8gMixcclxuICAgICAgICB5OiBhY3RpdmVOb2RlLnkgKyBhY3RpdmVOb2RlLmhlaWdodCAvIDJcclxuICAgICAgfSA6IG51bGw7XHJcbiAgICAgIHZhciBwYXlsb2FkID0gaXNUb29sdGlwQWN0aXZlICYmIGFjdGl2ZU5vZGUgPyBbe1xyXG4gICAgICAgIHBheWxvYWQ6IGFjdGl2ZU5vZGUsXHJcbiAgICAgICAgbmFtZTogKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShhY3RpdmVOb2RlLCBuYW1lS2V5LCAnJyksXHJcbiAgICAgICAgdmFsdWU6ICgwLCBfQ2hhcnRVdGlscy5nZXRWYWx1ZUJ5RGF0YUtleSkoYWN0aXZlTm9kZSwgTk9ERV9WQUxVRV9LRVkpXHJcbiAgICAgIH1dIDogW107XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQodG9vbHRpcEl0ZW0sIHtcclxuICAgICAgICB2aWV3Qm94OiB2aWV3Qm94LFxyXG4gICAgICAgIGFjdGl2ZTogaXNUb29sdGlwQWN0aXZlLFxyXG4gICAgICAgIGNvb3JkaW5hdGU6IGNvb3JkaW5hdGUsXHJcbiAgICAgICAgbGFiZWw6ICcnLFxyXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWRcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmVuZGVyIG5lc3QgdHJlZW1hcFxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJOZXN0SW5kZXhcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJOZXN0SW5kZXgoKSB7XHJcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHMxMCA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgbmFtZUtleSA9IF90aGlzJHByb3BzMTAubmFtZUtleSxcclxuICAgICAgICBuZXN0SW5kZXhDb250ZW50ID0gX3RoaXMkcHJvcHMxMC5uZXN0SW5kZXhDb250ZW50O1xyXG4gICAgICB2YXIgbmVzdEluZGV4ID0gdGhpcy5zdGF0ZS5uZXN0SW5kZXg7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcclxuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtdHJlZW1hcC1uZXN0LWluZGV4LXdyYXBwZXJcIixcclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgbWFyZ2luVG9wOiAnOHB4JyxcclxuICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcidcclxuICAgICAgICB9XHJcbiAgICAgIH0sIG5lc3RJbmRleC5tYXAoZnVuY3Rpb24gKGl0ZW0sIGkpIHtcclxuICAgICAgICAvLyBUT0RPIG5lZWQgdG8gdmVyaWZ5IG5hbWVLZXkgdHlwZVxyXG4gICAgICAgIHZhciBuYW1lID0gKDAsIF9nZXRbXCJkZWZhdWx0XCJdKShpdGVtLCBuYW1lS2V5LCAncm9vdCcpO1xyXG4gICAgICAgIHZhciBjb250ZW50ID0gbnVsbDtcclxuICAgICAgICBpZiAoIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KG5lc3RJbmRleENvbnRlbnQpKSB7XHJcbiAgICAgICAgICBjb250ZW50ID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KG5lc3RJbmRleENvbnRlbnQsIGl0ZW0sIGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkobmVzdEluZGV4Q29udGVudCkpIHtcclxuICAgICAgICAgIGNvbnRlbnQgPSBuZXN0SW5kZXhDb250ZW50KGl0ZW0sIGkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb250ZW50ID0gbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgIC8qI19fUFVSRV9fKi9cclxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc3gtYTExeS9jbGljay1ldmVudHMtaGF2ZS1rZXktZXZlbnRzLCBqc3gtYTExeS9uby1zdGF0aWMtZWxlbWVudC1pbnRlcmFjdGlvbnNcclxuICAgICAgICAgIF9yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XHJcbiAgICAgICAgICAgIG9uQ2xpY2s6IF90aGlzNC5oYW5kbGVOZXN0SW5kZXguYmluZChfdGhpczQsIGl0ZW0sIGkpLFxyXG4gICAgICAgICAgICBrZXk6IFwibmVzdC1pbmRleC1cIi5jb25jYXQoKDAsIF9EYXRhVXRpbHMudW5pcXVlSWQpKCkpLFxyXG4gICAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtdHJlZW1hcC1uZXN0LWluZGV4LWJveFwiLFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxyXG4gICAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxyXG4gICAgICAgICAgICAgIHBhZGRpbmc6ICcwIDdweCcsXHJcbiAgICAgICAgICAgICAgYmFja2dyb3VuZDogJyMwMDAnLFxyXG4gICAgICAgICAgICAgIGNvbG9yOiAnI2ZmZicsXHJcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICczcHgnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sIGNvbnRlbnQpXHJcbiAgICAgICAgKTtcclxuICAgICAgfSkpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAgICAgIGlmICghKDAsIF9SZWFjdFV0aWxzLnZhbGlkYXRlV2lkdGhIZWlnaHQpKHRoaXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIF90aGlzJHByb3BzMTEgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHMxMS53aWR0aCxcclxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczExLmhlaWdodCxcclxuICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczExLmNsYXNzTmFtZSxcclxuICAgICAgICBzdHlsZSA9IF90aGlzJHByb3BzMTEuc3R5bGUsXHJcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczExLmNoaWxkcmVuLFxyXG4gICAgICAgIHR5cGUgPSBfdGhpcyRwcm9wczExLnR5cGUsXHJcbiAgICAgICAgb3RoZXJzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzMTEsIF9leGNsdWRlZCk7XHJcbiAgICAgIHZhciBhdHRycyA9ICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykob3RoZXJzLCBmYWxzZSk7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcclxuICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy13cmFwcGVyJywgY2xhc3NOYW1lKSxcclxuICAgICAgICBzdHlsZTogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdHlsZSksIHt9LCB7XHJcbiAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxyXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcclxuICAgICAgICB9KSxcclxuICAgICAgICByb2xlOiBcInJlZ2lvblwiXHJcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX1N1cmZhY2UuU3VyZmFjZSwgX2V4dGVuZHMoe30sIGF0dHJzLCB7XHJcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogdHlwZSA9PT0gJ25lc3QnID8gaGVpZ2h0IC0gMzAgOiBoZWlnaHRcclxuICAgICAgfSksIHRoaXMucmVuZGVyQWxsTm9kZXMoKSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclN2Z0VsZW1lbnRzKShjaGlsZHJlbikpLCB0aGlzLnJlbmRlclRvb2x0aXAoKSwgdHlwZSA9PT0gJ25lc3QnICYmIHRoaXMucmVuZGVyTmVzdEluZGV4KCkpO1xyXG4gICAgfVxyXG4gIH1dLCBbe1xyXG4gICAga2V5OiBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1wiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSkge1xyXG4gICAgICBpZiAobmV4dFByb3BzLmRhdGEgIT09IHByZXZTdGF0ZS5wcmV2RGF0YSB8fCBuZXh0UHJvcHMudHlwZSAhPT0gcHJldlN0YXRlLnByZXZUeXBlIHx8IG5leHRQcm9wcy53aWR0aCAhPT0gcHJldlN0YXRlLnByZXZXaWR0aCB8fCBuZXh0UHJvcHMuaGVpZ2h0ICE9PSBwcmV2U3RhdGUucHJldkhlaWdodCB8fCBuZXh0UHJvcHMuZGF0YUtleSAhPT0gcHJldlN0YXRlLnByZXZEYXRhS2V5IHx8IG5leHRQcm9wcy5hc3BlY3RSYXRpbyAhPT0gcHJldlN0YXRlLnByZXZBc3BlY3RSYXRpbykge1xyXG4gICAgICAgIHZhciByb290ID0gY29tcHV0ZU5vZGUoe1xyXG4gICAgICAgICAgZGVwdGg6IDAsXHJcbiAgICAgICAgICBub2RlOiB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiBuZXh0UHJvcHMuZGF0YSxcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IG5leHRQcm9wcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBuZXh0UHJvcHMuaGVpZ2h0XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgaW5kZXg6IDAsXHJcbiAgICAgICAgICB2YWx1ZUtleTogbmV4dFByb3BzLmRhdGFLZXlcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgZm9ybWF0Um9vdCA9IHNxdWFyaWZ5KHJvb3QsIG5leHRQcm9wcy5hc3BlY3RSYXRpbyk7XHJcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJldlN0YXRlKSwge30sIHtcclxuICAgICAgICAgIGZvcm1hdFJvb3Q6IGZvcm1hdFJvb3QsXHJcbiAgICAgICAgICBjdXJyZW50Um9vdDogcm9vdCxcclxuICAgICAgICAgIG5lc3RJbmRleDogW3Jvb3RdLFxyXG4gICAgICAgICAgcHJldkFzcGVjdFJhdGlvOiBuZXh0UHJvcHMuYXNwZWN0UmF0aW8sXHJcbiAgICAgICAgICBwcmV2RGF0YTogbmV4dFByb3BzLmRhdGEsXHJcbiAgICAgICAgICBwcmV2V2lkdGg6IG5leHRQcm9wcy53aWR0aCxcclxuICAgICAgICAgIHByZXZIZWlnaHQ6IG5leHRQcm9wcy5oZWlnaHQsXHJcbiAgICAgICAgICBwcmV2RGF0YUtleTogbmV4dFByb3BzLmRhdGFLZXksXHJcbiAgICAgICAgICBwcmV2VHlwZTogbmV4dFByb3BzLnR5cGVcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyQ29udGVudEl0ZW1cIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDb250ZW50SXRlbShjb250ZW50LCBub2RlUHJvcHMsIHR5cGUsIGNvbG9yUGFuZWwpIHtcclxuICAgICAgaWYgKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5pc1ZhbGlkRWxlbWVudChjb250ZW50KSkge1xyXG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQoY29udGVudCwgbm9kZVByb3BzKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkoY29udGVudCkpIHtcclxuICAgICAgICByZXR1cm4gY29udGVudChub2RlUHJvcHMpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIG9wdGltaXplIGRlZmF1bHQgc2hhcGVcclxuICAgICAgdmFyIHggPSBub2RlUHJvcHMueCxcclxuICAgICAgICB5ID0gbm9kZVByb3BzLnksXHJcbiAgICAgICAgd2lkdGggPSBub2RlUHJvcHMud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0ID0gbm9kZVByb3BzLmhlaWdodCxcclxuICAgICAgICBpbmRleCA9IG5vZGVQcm9wcy5pbmRleDtcclxuICAgICAgdmFyIGFycm93ID0gbnVsbDtcclxuICAgICAgaWYgKHdpZHRoID4gMTAgJiYgaGVpZ2h0ID4gMTAgJiYgbm9kZVByb3BzLmNoaWxkcmVuICYmIHR5cGUgPT09ICduZXN0Jykge1xyXG4gICAgICAgIGFycm93ID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfUG9seWdvbi5Qb2x5Z29uLCB7XHJcbiAgICAgICAgICBwb2ludHM6IFt7XHJcbiAgICAgICAgICAgIHg6IHggKyAyLFxyXG4gICAgICAgICAgICB5OiB5ICsgaGVpZ2h0IC8gMlxyXG4gICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICB4OiB4ICsgNixcclxuICAgICAgICAgICAgeTogeSArIGhlaWdodCAvIDIgKyAzXHJcbiAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgIHg6IHggKyAyLFxyXG4gICAgICAgICAgICB5OiB5ICsgaGVpZ2h0IC8gMiArIDZcclxuICAgICAgICAgIH1dXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHRleHQgPSBudWxsO1xyXG4gICAgICB2YXIgbmFtZVNpemUgPSAoMCwgX0RPTVV0aWxzLmdldFN0cmluZ1NpemUpKG5vZGVQcm9wcy5uYW1lKTtcclxuICAgICAgaWYgKHdpZHRoID4gMjAgJiYgaGVpZ2h0ID4gMjAgJiYgbmFtZVNpemUud2lkdGggPCB3aWR0aCAmJiBuYW1lU2l6ZS5oZWlnaHQgPCBoZWlnaHQpIHtcclxuICAgICAgICB0ZXh0ID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInRleHRcIiwge1xyXG4gICAgICAgICAgeDogeCArIDgsXHJcbiAgICAgICAgICB5OiB5ICsgaGVpZ2h0IC8gMiArIDcsXHJcbiAgICAgICAgICBmb250U2l6ZTogMTRcclxuICAgICAgICB9LCBub2RlUHJvcHMubmFtZSk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGNvbG9ycyA9IGNvbG9yUGFuZWwgfHwgX0NvbnN0YW50cy5DT0xPUl9QQU5FTDtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIG51bGwsIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX1JlY3RhbmdsZS5SZWN0YW5nbGUsIF9leHRlbmRzKHtcclxuICAgICAgICBmaWxsOiBub2RlUHJvcHMuZGVwdGggPCAyID8gY29sb3JzW2luZGV4ICUgY29sb3JzLmxlbmd0aF0gOiAncmdiYSgyNTUsMjU1LDI1NSwwKScsXHJcbiAgICAgICAgc3Ryb2tlOiBcIiNmZmZcIlxyXG4gICAgICB9LCAoMCwgX29taXRbXCJkZWZhdWx0XCJdKShub2RlUHJvcHMsICdjaGlsZHJlbicpLCB7XHJcbiAgICAgICAgcm9sZTogXCJpbWdcIlxyXG4gICAgICB9KSksIGFycm93LCB0ZXh0KTtcclxuICAgIH1cclxuICB9XSk7XHJcbn0oX3JlYWN0LlB1cmVDb21wb25lbnQpO1xyXG5fZGVmaW5lUHJvcGVydHkoVHJlZW1hcCwgXCJkaXNwbGF5TmFtZVwiLCAnVHJlZW1hcCcpO1xyXG5fZGVmaW5lUHJvcGVydHkoVHJlZW1hcCwgXCJkZWZhdWx0UHJvcHNcIiwge1xyXG4gIGFzcGVjdFJhdGlvOiAwLjUgKiAoMSArIE1hdGguc3FydCg1KSksXHJcbiAgZGF0YUtleTogJ3ZhbHVlJyxcclxuICB0eXBlOiAnZmxhdCcsXHJcbiAgaXNBbmltYXRpb25BY3RpdmU6ICFfR2xvYmFsLkdsb2JhbC5pc1NzcixcclxuICBpc1VwZGF0ZUFuaW1hdGlvbkFjdGl2ZTogIV9HbG9iYWwuR2xvYmFsLmlzU3NyLFxyXG4gIGFuaW1hdGlvbkJlZ2luOiAwLFxyXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiAxNTAwLFxyXG4gIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcidcclxufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVHJlZW1hcCIsIl9pc05hTiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2lzRnVuY3Rpb24iLCJfb21pdCIsIl9nZXQiLCJfY2xzeCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwiX3JlYWN0U21vb3RoIiwiX1Rvb2x0aXAiLCJfTGF5ZXIiLCJfU3VyZmFjZSIsIl9Qb2x5Z29uIiwiX1JlY3RhbmdsZSIsIl9DaGFydFV0aWxzIiwiX0NvbnN0YW50cyIsIl9EYXRhVXRpbHMiLCJfRE9NVXRpbHMiLCJfR2xvYmFsIiwiX1JlYWN0VXRpbHMiLCJfZXhjbHVkZWQiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX19lc01vZHVsZSIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0Iiwib2JqIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwicHJvdG90eXBlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwiYXBwbHkiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJleGNsdWRlZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1Byb3BlcnR5S2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NhbGxTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiQm9vbGVhbiIsInZhbHVlT2YiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwicCIsIm93bktleXMiLCJrZXlzIiwiZmlsdGVyIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsIk5PREVfVkFMVUVfS0VZIiwiY29tcHV0ZU5vZGUiLCJfcmVmIiwiZGVwdGgiLCJub2RlIiwiaW5kZXgiLCJ2YWx1ZUtleSIsImNoaWxkcmVuIiwiY2hpbGREZXB0aCIsImNvbXB1dGVkQ2hpbGRyZW4iLCJtYXAiLCJjaGlsZCIsIm5vZGVWYWx1ZSIsInJlZHVjZSIsInJlc3VsdCIsImZpbHRlclJlY3QiLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0IiwiZ2V0QXJlYU9mQ2hpbGRyZW4iLCJhcmVhVmFsdWVSYXRpbyIsInJhdGlvIiwiYXJlYSIsImdldFdvcnN0U2NvcmUiLCJyb3ciLCJwYXJlbnRTaXplIiwiYXNwZWN0UmF0aW8iLCJwYXJlbnRBcmVhIiwicm93QXJlYSIsIl9yb3ckcmVkdWNlIiwibWluIiwiTWF0aCIsIm1heCIsIkluZmluaXR5IiwiaG9yaXpvbnRhbFBvc2l0aW9uIiwicGFyZW50UmVjdCIsImlzRmx1c2giLCJyb3dIZWlnaHQiLCJyb3VuZCIsImN1clgiLCJsZW4iLCJ2ZXJ0aWNhbFBvc2l0aW9uIiwicm93V2lkdGgiLCJjdXJZIiwicG9zaXRpb24iLCJzcXVhcmlmeSIsInJlY3QiLCJiZXN0Iiwic2NvcmUiLCJzaXplIiwic2NhbGVDaGlsZHJlbiIsInRlbXBDaGlsZHJlbiIsInNsaWNlIiwic2hpZnQiLCJwb3AiLCJjIiwiZGVmYXVsdFN0YXRlIiwiaXNUb29sdGlwQWN0aXZlIiwiaXNBbmltYXRpb25GaW5pc2hlZCIsImFjdGl2ZU5vZGUiLCJmb3JtYXRSb290IiwiY3VycmVudFJvb3QiLCJuZXN0SW5kZXgiLCJfUHVyZUNvbXBvbmVudCIsIl90aGlzIiwiX2xlbiIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJjb25jYXQiLCJvbkFuaW1hdGlvbkVuZCIsInNldFN0YXRlIiwib25BbmltYXRpb25TdGFydCIsImhhbmRsZU1vdXNlRW50ZXIiLCJwZXJzaXN0IiwiX3RoaXMkcHJvcHMiLCJvbk1vdXNlRW50ZXIiLCJ0b29sdGlwSXRlbSIsImZpbmRDaGlsZEJ5VHlwZSIsIlRvb2x0aXAiLCJoYW5kbGVNb3VzZUxlYXZlIiwiX3RoaXMkcHJvcHMyIiwib25Nb3VzZUxlYXZlIiwiaGFuZGxlQ2xpY2siLCJfdGhpcyRwcm9wczMiLCJvbkNsaWNrIiwidHlwZSIsIl90aGlzJHByb3BzNCIsImRhdGFLZXkiLCJyb290Iiwic3RhdGUiLCJoYW5kbGVOZXN0SW5kZXgiLCJfdGhpcyRwcm9wczUiLCJyZW5kZXJJdGVtIiwiY29udGVudCIsIm5vZGVQcm9wcyIsImlzTGVhZiIsIl90aGlzMiIsIl90aGlzJHByb3BzNiIsImlzQW5pbWF0aW9uQWN0aXZlIiwiYW5pbWF0aW9uQmVnaW4iLCJhbmltYXRpb25EdXJhdGlvbiIsImFuaW1hdGlvbkVhc2luZyIsImlzVXBkYXRlQW5pbWF0aW9uQWN0aXZlIiwiYW5pbWF0aW9uSWQiLCJjb2xvclBhbmVsIiwidHJhbnNsYXRlWCIsInBhcnNlSW50IiwicmFuZG9tIiwiZXZlbnQiLCJjcmVhdGVFbGVtZW50IiwiTGF5ZXIiLCJyZW5kZXJDb250ZW50SXRlbSIsImJlZ2luIiwiZHVyYXRpb24iLCJpc0FjdGl2ZSIsImVhc2luZyIsImZyb20iLCJ0byIsImhhbmRsZUFuaW1hdGlvblN0YXJ0IiwiaGFuZGxlQW5pbWF0aW9uRW5kIiwiX3JlZjIiLCJjdXJyWCIsImN1cnJZIiwiY3VycldpZHRoIiwiY3VyckhlaWdodCIsImF0dHJpYnV0ZU5hbWUiLCJyZW5kZXJOb2RlIiwiX3RoaXMzIiwiX3RoaXMkcHJvcHM3IiwiZmlsdGVyUHJvcHMiLCJpc0N1cnJlbnRSb290Q2hpbGQiLCJpdGVtIiwibmFtZSIsImNsYXNzTmFtZSIsInJlbmRlckFsbE5vZGVzIiwicmVuZGVyVG9vbHRpcCIsIl90aGlzJHByb3BzOCIsIm5hbWVLZXkiLCJfdGhpcyRwcm9wczkiLCJfdGhpcyRzdGF0ZSIsInZpZXdCb3giLCJjb29yZGluYXRlIiwicGF5bG9hZCIsImdldFZhbHVlQnlEYXRhS2V5IiwiY2xvbmVFbGVtZW50IiwiYWN0aXZlIiwibGFiZWwiLCJyZW5kZXJOZXN0SW5kZXgiLCJfdGhpczQiLCJfdGhpcyRwcm9wczEwIiwibmVzdEluZGV4Q29udGVudCIsInN0eWxlIiwibWFyZ2luVG9wIiwidGV4dEFsaWduIiwiaXNWYWxpZEVsZW1lbnQiLCJ1bmlxdWVJZCIsImN1cnNvciIsImRpc3BsYXkiLCJwYWRkaW5nIiwiYmFja2dyb3VuZCIsImNvbG9yIiwibWFyZ2luUmlnaHQiLCJyZW5kZXIiLCJ2YWxpZGF0ZVdpZHRoSGVpZ2h0IiwiX3RoaXMkcHJvcHMxMSIsIm90aGVycyIsImF0dHJzIiwicm9sZSIsIlN1cmZhY2UiLCJmaWx0ZXJTdmdFbGVtZW50cyIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIm5leHRQcm9wcyIsInByZXZTdGF0ZSIsImRhdGEiLCJwcmV2RGF0YSIsInByZXZUeXBlIiwicHJldldpZHRoIiwicHJldkhlaWdodCIsInByZXZEYXRhS2V5IiwicHJldkFzcGVjdFJhdGlvIiwiYXJyb3ciLCJQb2x5Z29uIiwicG9pbnRzIiwidGV4dCIsIm5hbWVTaXplIiwiZ2V0U3RyaW5nU2l6ZSIsImZvbnRTaXplIiwiY29sb3JzIiwiQ09MT1JfUEFORUwiLCJSZWN0YW5nbGUiLCJmaWxsIiwic3Ryb2tlIiwiUHVyZUNvbXBvbmVudCIsInNxcnQiLCJHbG9iYWwiLCJpc1NzciJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/chart/Treemap.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/chart/generateCategoricalChart.js":
/*!*********************************************************************!*\
  !*** ./node_modules/recharts/lib/chart/generateCategoricalChart.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getAxisMapByAxes = exports.generateCategoricalChart = exports.createDefaultState = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _range = _interopRequireDefault(__webpack_require__(/*! lodash/range */ \"lodash/range\"));\nvar _get = _interopRequireDefault(__webpack_require__(/*! lodash/get */ \"lodash/get\"));\nvar _sortBy = _interopRequireDefault(__webpack_require__(/*! lodash/sortBy */ \"lodash/sortBy\"));\nvar _throttle = _interopRequireDefault(__webpack_require__(/*! lodash/throttle */ \"lodash/throttle\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _tinyInvariant = _interopRequireDefault(__webpack_require__(/*! tiny-invariant */ \"tiny-invariant\"));\nvar _Surface = __webpack_require__(/*! ../container/Surface */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Surface.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _Tooltip = __webpack_require__(/*! ../component/Tooltip */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Tooltip.js\");\nvar _Legend = __webpack_require__(/*! ../component/Legend */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Legend.js\");\nvar _Dot = __webpack_require__(/*! ../shape/Dot */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Dot.js\");\nvar _Rectangle = __webpack_require__(/*! ../shape/Rectangle */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Rectangle.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _Brush = __webpack_require__(/*! ../cartesian/Brush */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/Brush.js\");\nvar _DOMUtils = __webpack_require__(/*! ../util/DOMUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DOMUtils.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _DetectReferenceElementsDomain = __webpack_require__(/*! ../util/DetectReferenceElementsDomain */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DetectReferenceElementsDomain.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _ShallowEqual = __webpack_require__(/*! ../util/ShallowEqual */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ShallowEqual.js\");\nvar _Events = __webpack_require__(/*! ../util/Events */ \"(pages-dir-node)/./node_modules/recharts/lib/util/Events.js\");\nvar _types = __webpack_require__(/*! ../util/types */ \"(pages-dir-node)/./node_modules/recharts/lib/util/types.js\");\nvar _AccessibilityManager = __webpack_require__(/*! ./AccessibilityManager */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/AccessibilityManager.js\");\nvar _isDomainSpecifiedByUser = __webpack_require__(/*! ../util/isDomainSpecifiedByUser */ \"(pages-dir-node)/./node_modules/recharts/lib/util/isDomainSpecifiedByUser.js\");\nvar _ActiveShapeUtils = __webpack_require__(/*! ../util/ActiveShapeUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ActiveShapeUtils.js\");\nvar _Cursor = __webpack_require__(/*! ../component/Cursor */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Cursor.js\");\nvar _chartLayoutContext = __webpack_require__(/*! ../context/chartLayoutContext */ \"(pages-dir-node)/./node_modules/recharts/lib/context/chartLayoutContext.js\");\nvar _excluded = [\n    \"item\"\n], _excluded2 = [\n    \"children\",\n    \"className\",\n    \"width\",\n    \"height\",\n    \"style\",\n    \"compact\",\n    \"title\",\n    \"desc\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} // eslint-disable-next-line no-restricted-imports\nvar ORIENT_MAP = {\n    xAxis: [\n        'bottom',\n        'top'\n    ],\n    yAxis: [\n        'left',\n        'right'\n    ]\n};\nvar FULL_WIDTH_AND_HEIGHT = {\n    width: '100%',\n    height: '100%'\n};\nvar originCoordinate = {\n    x: 0,\n    y: 0\n};\n/**\r\n * This function exists as a temporary workaround.\r\n *\r\n * Why? generateCategoricalChart does not render `{children}` directly;\r\n * instead it passes them through `renderByOrder` function which reads their handlers.\r\n *\r\n * So, this is a handler that does nothing.\r\n * Once we get rid of `renderByOrder` and switch to JSX only, we can get rid of this handler too.\r\n *\r\n * @param {JSX} element as is in JSX\r\n * @returns {JSX} the same element\r\n */ function renderAsIs(element) {\n    return element;\n}\nvar calculateTooltipPos = function calculateTooltipPos(rangeObj, layout) {\n    if (layout === 'horizontal') {\n        return rangeObj.x;\n    }\n    if (layout === 'vertical') {\n        return rangeObj.y;\n    }\n    if (layout === 'centric') {\n        return rangeObj.angle;\n    }\n    return rangeObj.radius;\n};\nvar getActiveCoordinate = function getActiveCoordinate(layout, tooltipTicks, activeIndex, rangeObj) {\n    var entry = tooltipTicks.find(function(tick) {\n        return tick && tick.index === activeIndex;\n    });\n    if (entry) {\n        if (layout === 'horizontal') {\n            return {\n                x: entry.coordinate,\n                y: rangeObj.y\n            };\n        }\n        if (layout === 'vertical') {\n            return {\n                x: rangeObj.x,\n                y: entry.coordinate\n            };\n        }\n        if (layout === 'centric') {\n            var _angle = entry.coordinate;\n            var _radius = rangeObj.radius;\n            return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), (0, _PolarUtils.polarToCartesian)(rangeObj.cx, rangeObj.cy, _radius, _angle)), {}, {\n                angle: _angle,\n                radius: _radius\n            });\n        }\n        var radius = entry.coordinate;\n        var angle = rangeObj.angle;\n        return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), (0, _PolarUtils.polarToCartesian)(rangeObj.cx, rangeObj.cy, radius, angle)), {}, {\n            angle: angle,\n            radius: radius\n        });\n    }\n    return originCoordinate;\n};\nvar getDisplayedData = function getDisplayedData(data, _ref) {\n    var graphicalItems = _ref.graphicalItems, dataStartIndex = _ref.dataStartIndex, dataEndIndex = _ref.dataEndIndex;\n    var itemsData = (graphicalItems !== null && graphicalItems !== void 0 ? graphicalItems : []).reduce(function(result, child) {\n        var itemData = child.props.data;\n        if (itemData && itemData.length) {\n            return [].concat(_toConsumableArray(result), _toConsumableArray(itemData));\n        }\n        return result;\n    }, []);\n    if (itemsData.length > 0) {\n        return itemsData;\n    }\n    if (data && data.length && (0, _DataUtils.isNumber)(dataStartIndex) && (0, _DataUtils.isNumber)(dataEndIndex)) {\n        return data.slice(dataStartIndex, dataEndIndex + 1);\n    }\n    return [];\n};\nfunction getDefaultDomainByAxisType(axisType) {\n    return axisType === 'number' ? [\n        0,\n        'auto'\n    ] : undefined;\n}\n/**\r\n * Get the content to be displayed in the tooltip\r\n * @param  {Object} state          Current state\r\n * @param  {Array}  chartData      The data defined in chart\r\n * @param  {Number} activeIndex    Active index of data\r\n * @param  {String} activeLabel    Active label of data\r\n * @return {Array}                 The content of tooltip\r\n */ var getTooltipContent = function getTooltipContent(state, chartData, activeIndex, activeLabel) {\n    var graphicalItems = state.graphicalItems, tooltipAxis = state.tooltipAxis;\n    var displayedData = getDisplayedData(chartData, state);\n    if (activeIndex < 0 || !graphicalItems || !graphicalItems.length || activeIndex >= displayedData.length) {\n        return null;\n    }\n    // get data by activeIndex when the axis don't allow duplicated category\n    return graphicalItems.reduce(function(result, child) {\n        var _child$props$data;\n        /**\r\n     * Fixes: https://github.com/recharts/recharts/issues/3669\r\n     * Defaulting to chartData below to fix an edge case where the tooltip does not include data from all charts\r\n     * when a separate dataset is passed to chart prop data and specified on Line/Area/etc prop data\r\n     */ var data = (_child$props$data = child.props.data) !== null && _child$props$data !== void 0 ? _child$props$data : chartData;\n        if (data && state.dataStartIndex + state.dataEndIndex !== 0 && // https://github.com/recharts/recharts/issues/4717\n        // The data is sliced only when the active index is within the start/end index range.\n        state.dataEndIndex - state.dataStartIndex >= activeIndex) {\n            data = data.slice(state.dataStartIndex, state.dataEndIndex + 1);\n        }\n        var payload;\n        if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) {\n            // graphic child has data props\n            var entries = data === undefined ? displayedData : data;\n            payload = (0, _DataUtils.findEntryInArray)(entries, tooltipAxis.dataKey, activeLabel);\n        } else {\n            payload = data && data[activeIndex] || displayedData[activeIndex];\n        }\n        if (!payload) {\n            return result;\n        }\n        return [].concat(_toConsumableArray(result), [\n            (0, _ChartUtils.getTooltipItem)(child, payload)\n        ]);\n    }, []);\n};\n/**\r\n * Returns tooltip data based on a mouse position (as a parameter or in state)\r\n * @param  {Object} state     current state\r\n * @param  {Array}  chartData the data defined in chart\r\n * @param  {String} layout     The layout type of chart\r\n * @param  {Object} rangeObj  { x, y } coordinates\r\n * @return {Object}           Tooltip data data\r\n */ var getTooltipData = function getTooltipData(state, chartData, layout, rangeObj) {\n    var rangeData = rangeObj || {\n        x: state.chartX,\n        y: state.chartY\n    };\n    var pos = calculateTooltipPos(rangeData, layout);\n    var ticks = state.orderedTooltipTicks, axis = state.tooltipAxis, tooltipTicks = state.tooltipTicks;\n    var activeIndex = (0, _ChartUtils.calculateActiveTickIndex)(pos, ticks, tooltipTicks, axis);\n    if (activeIndex >= 0 && tooltipTicks) {\n        var activeLabel = tooltipTicks[activeIndex] && tooltipTicks[activeIndex].value;\n        var activePayload = getTooltipContent(state, chartData, activeIndex, activeLabel);\n        var activeCoordinate = getActiveCoordinate(layout, ticks, activeIndex, rangeData);\n        return {\n            activeTooltipIndex: activeIndex,\n            activeLabel: activeLabel,\n            activePayload: activePayload,\n            activeCoordinate: activeCoordinate\n        };\n    }\n    return null;\n};\n/**\r\n * Get the configuration of axis by the options of axis instance\r\n * @param  {Object} props         Latest props\r\n * @param {Array}  axes           The instance of axes\r\n * @param  {Array} graphicalItems The instances of item\r\n * @param  {String} axisType      The type of axis, xAxis - x-axis, yAxis - y-axis\r\n * @param  {String} axisIdKey     The unique id of an axis\r\n * @param  {Object} stackGroups   The items grouped by axisId and stackId\r\n * @param {Number} dataStartIndex The start index of the data series when a brush is applied\r\n * @param {Number} dataEndIndex   The end index of the data series when a brush is applied\r\n * @return {Object}      Configuration\r\n */ var getAxisMapByAxes = exports.getAxisMapByAxes = function getAxisMapByAxes(props, _ref2) {\n    var axes = _ref2.axes, graphicalItems = _ref2.graphicalItems, axisType = _ref2.axisType, axisIdKey = _ref2.axisIdKey, stackGroups = _ref2.stackGroups, dataStartIndex = _ref2.dataStartIndex, dataEndIndex = _ref2.dataEndIndex;\n    var layout = props.layout, children = props.children, stackOffset = props.stackOffset;\n    var isCategorical = (0, _ChartUtils.isCategoricalAxis)(layout, axisType);\n    // Eliminate duplicated axes\n    return axes.reduce(function(result, child) {\n        var _childProps$domain2;\n        var childProps = child.type.defaultProps !== undefined ? _objectSpread(_objectSpread({}, child.type.defaultProps), child.props) : child.props;\n        var type = childProps.type, dataKey = childProps.dataKey, allowDataOverflow = childProps.allowDataOverflow, allowDuplicatedCategory = childProps.allowDuplicatedCategory, scale = childProps.scale, ticks = childProps.ticks, includeHidden = childProps.includeHidden;\n        var axisId = childProps[axisIdKey];\n        if (result[axisId]) {\n            return result;\n        }\n        var displayedData = getDisplayedData(props.data, {\n            graphicalItems: graphicalItems.filter(function(item) {\n                var _defaultProps;\n                var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : (_defaultProps = item.type.defaultProps) === null || _defaultProps === void 0 ? void 0 : _defaultProps[axisIdKey];\n                return itemAxisId === axisId;\n            }),\n            dataStartIndex: dataStartIndex,\n            dataEndIndex: dataEndIndex\n        });\n        var len = displayedData.length;\n        var domain, duplicateDomain, categoricalDomain;\n        /*\r\n     * This is a hack to short-circuit the domain creation here to enhance performance.\r\n     * Usually, the data is used to determine the domain, but when the user specifies\r\n     * a domain upfront (via props), there is no need to calculate the domain start and end,\r\n     * which is very expensive for a larger amount of data.\r\n     * The only thing that would prohibit short-circuiting is when the user doesn't allow data overflow,\r\n     * because the axis is supposed to ignore the specified domain that way.\r\n     */ if ((0, _isDomainSpecifiedByUser.isDomainSpecifiedByUser)(childProps.domain, allowDataOverflow, type)) {\n            domain = (0, _ChartUtils.parseSpecifiedDomain)(childProps.domain, null, allowDataOverflow);\n            /* The chart can be categorical and have the domain specified in numbers\r\n       * we still need to calculate the categorical domain\r\n       * TODO: refactor this more\r\n       */ if (isCategorical && (type === 'number' || scale !== 'auto')) {\n                categoricalDomain = (0, _ChartUtils.getDomainOfDataByKey)(displayedData, dataKey, 'category');\n            }\n        }\n        // if the domain is defaulted we need this for `originalDomain` as well\n        var defaultDomain = getDefaultDomainByAxisType(type);\n        // we didn't create the domain from user's props above, so we need to calculate it\n        if (!domain || domain.length === 0) {\n            var _childProps$domain;\n            var childDomain = (_childProps$domain = childProps.domain) !== null && _childProps$domain !== void 0 ? _childProps$domain : defaultDomain;\n            if (dataKey) {\n                // has dataKey in <Axis />\n                domain = (0, _ChartUtils.getDomainOfDataByKey)(displayedData, dataKey, type);\n                if (type === 'category' && isCategorical) {\n                    // the field type is category data and this axis is categorical axis\n                    var duplicate = (0, _DataUtils.hasDuplicate)(domain);\n                    if (allowDuplicatedCategory && duplicate) {\n                        duplicateDomain = domain;\n                        // When category axis has duplicated text, serial numbers are used to generate scale\n                        domain = (0, _range[\"default\"])(0, len);\n                    } else if (!allowDuplicatedCategory) {\n                        // remove duplicated category\n                        domain = (0, _ChartUtils.parseDomainOfCategoryAxis)(childDomain, domain, child).reduce(function(finalDomain, entry) {\n                            return finalDomain.indexOf(entry) >= 0 ? finalDomain : [].concat(_toConsumableArray(finalDomain), [\n                                entry\n                            ]);\n                        }, []);\n                    }\n                } else if (type === 'category') {\n                    // the field type is category data and this axis is numerical axis\n                    if (!allowDuplicatedCategory) {\n                        domain = (0, _ChartUtils.parseDomainOfCategoryAxis)(childDomain, domain, child).reduce(function(finalDomain, entry) {\n                            return finalDomain.indexOf(entry) >= 0 || entry === '' || (0, _isNil[\"default\"])(entry) ? finalDomain : [].concat(_toConsumableArray(finalDomain), [\n                                entry\n                            ]);\n                        }, []);\n                    } else {\n                        // eliminate undefined or null or empty string\n                        domain = domain.filter(function(entry) {\n                            return entry !== '' && !(0, _isNil[\"default\"])(entry);\n                        });\n                    }\n                } else if (type === 'number') {\n                    // the field type is numerical\n                    var errorBarsDomain = (0, _ChartUtils.parseErrorBarsOfAxis)(displayedData, graphicalItems.filter(function(item) {\n                        var _defaultProps2, _defaultProps3;\n                        var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : (_defaultProps2 = item.type.defaultProps) === null || _defaultProps2 === void 0 ? void 0 : _defaultProps2[axisIdKey];\n                        var itemHide = 'hide' in item.props ? item.props.hide : (_defaultProps3 = item.type.defaultProps) === null || _defaultProps3 === void 0 ? void 0 : _defaultProps3.hide;\n                        return itemAxisId === axisId && (includeHidden || !itemHide);\n                    }), dataKey, axisType, layout);\n                    if (errorBarsDomain) {\n                        domain = errorBarsDomain;\n                    }\n                }\n                if (isCategorical && (type === 'number' || scale !== 'auto')) {\n                    categoricalDomain = (0, _ChartUtils.getDomainOfDataByKey)(displayedData, dataKey, 'category');\n                }\n            } else if (isCategorical) {\n                // the axis is a categorical axis\n                domain = (0, _range[\"default\"])(0, len);\n            } else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack && type === 'number') {\n                // when stackOffset is 'expand', the domain may be calculated as [0, 1.000000000002]\n                domain = stackOffset === 'expand' ? [\n                    0,\n                    1\n                ] : (0, _ChartUtils.getDomainOfStackGroups)(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);\n            } else {\n                domain = (0, _ChartUtils.getDomainOfItemsWithSameAxis)(displayedData, graphicalItems.filter(function(item) {\n                    var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : item.type.defaultProps[axisIdKey];\n                    var itemHide = 'hide' in item.props ? item.props.hide : item.type.defaultProps.hide;\n                    return itemAxisId === axisId && (includeHidden || !itemHide);\n                }), type, layout, true);\n            }\n            if (type === 'number') {\n                // To detect wether there is any reference lines whose props alwaysShow is true\n                domain = (0, _DetectReferenceElementsDomain.detectReferenceElementsDomain)(children, domain, axisId, axisType, ticks);\n                if (childDomain) {\n                    domain = (0, _ChartUtils.parseSpecifiedDomain)(childDomain, domain, allowDataOverflow);\n                }\n            } else if (type === 'category' && childDomain) {\n                var axisDomain = childDomain;\n                var isDomainValid = domain.every(function(entry) {\n                    return axisDomain.indexOf(entry) >= 0;\n                });\n                if (isDomainValid) {\n                    domain = axisDomain;\n                }\n            }\n        }\n        return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, _objectSpread(_objectSpread({}, childProps), {}, {\n            axisType: axisType,\n            domain: domain,\n            categoricalDomain: categoricalDomain,\n            duplicateDomain: duplicateDomain,\n            originalDomain: (_childProps$domain2 = childProps.domain) !== null && _childProps$domain2 !== void 0 ? _childProps$domain2 : defaultDomain,\n            isCategorical: isCategorical,\n            layout: layout\n        })));\n    }, {});\n};\n/**\r\n * Get the configuration of axis by the options of item,\r\n * this kind of axis does not display in chart\r\n * @param  {Object} props         Latest props\r\n * @param  {Array} graphicalItems The instances of item\r\n * @param  {ReactElement} Axis    Axis Component\r\n * @param  {String} axisType      The type of axis, xAxis - x-axis, yAxis - y-axis\r\n * @param  {String} axisIdKey     The unique id of an axis\r\n * @param  {Object} stackGroups   The items grouped by axisId and stackId\r\n * @param {Number} dataStartIndex The start index of the data series when a brush is applied\r\n * @param {Number} dataEndIndex   The end index of the data series when a brush is applied\r\n * @return {Object}               Configuration\r\n */ var getAxisMapByItems = function getAxisMapByItems(props, _ref3) {\n    var graphicalItems = _ref3.graphicalItems, Axis = _ref3.Axis, axisType = _ref3.axisType, axisIdKey = _ref3.axisIdKey, stackGroups = _ref3.stackGroups, dataStartIndex = _ref3.dataStartIndex, dataEndIndex = _ref3.dataEndIndex;\n    var layout = props.layout, children = props.children;\n    var displayedData = getDisplayedData(props.data, {\n        graphicalItems: graphicalItems,\n        dataStartIndex: dataStartIndex,\n        dataEndIndex: dataEndIndex\n    });\n    var len = displayedData.length;\n    var isCategorical = (0, _ChartUtils.isCategoricalAxis)(layout, axisType);\n    var index = -1;\n    // The default type of x-axis is category axis,\n    // The default contents of x-axis is the serial numbers of data\n    // The default type of y-axis is number axis\n    // The default contents of y-axis is the domain of data\n    return graphicalItems.reduce(function(result, child) {\n        var childProps = child.type.defaultProps !== undefined ? _objectSpread(_objectSpread({}, child.type.defaultProps), child.props) : child.props;\n        var axisId = childProps[axisIdKey];\n        var originalDomain = getDefaultDomainByAxisType('number');\n        if (!result[axisId]) {\n            index++;\n            var domain;\n            if (isCategorical) {\n                domain = (0, _range[\"default\"])(0, len);\n            } else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack) {\n                domain = (0, _ChartUtils.getDomainOfStackGroups)(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);\n                domain = (0, _DetectReferenceElementsDomain.detectReferenceElementsDomain)(children, domain, axisId, axisType);\n            } else {\n                domain = (0, _ChartUtils.parseSpecifiedDomain)(originalDomain, (0, _ChartUtils.getDomainOfItemsWithSameAxis)(displayedData, graphicalItems.filter(function(item) {\n                    var _defaultProps4, _defaultProps5;\n                    var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : (_defaultProps4 = item.type.defaultProps) === null || _defaultProps4 === void 0 ? void 0 : _defaultProps4[axisIdKey];\n                    var itemHide = 'hide' in item.props ? item.props.hide : (_defaultProps5 = item.type.defaultProps) === null || _defaultProps5 === void 0 ? void 0 : _defaultProps5.hide;\n                    return itemAxisId === axisId && !itemHide;\n                }), 'number', layout), Axis.defaultProps.allowDataOverflow);\n                domain = (0, _DetectReferenceElementsDomain.detectReferenceElementsDomain)(children, domain, axisId, axisType);\n            }\n            return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, _objectSpread(_objectSpread({\n                axisType: axisType\n            }, Axis.defaultProps), {}, {\n                hide: true,\n                orientation: (0, _get[\"default\"])(ORIENT_MAP, \"\".concat(axisType, \".\").concat(index % 2), null),\n                domain: domain,\n                originalDomain: originalDomain,\n                isCategorical: isCategorical,\n                layout: layout\n            })));\n        }\n        return result;\n    }, {});\n};\n/**\r\n * Get the configuration of all x-axis or y-axis\r\n * @param  {Object} props          Latest props\r\n * @param  {String} axisType       The type of axis\r\n * @param  {React.ComponentType}  [AxisComp]      Axis Component\r\n * @param  {Array}  graphicalItems The instances of item\r\n * @param  {Object} stackGroups    The items grouped by axisId and stackId\r\n * @param {Number} dataStartIndex  The start index of the data series when a brush is applied\r\n * @param {Number} dataEndIndex    The end index of the data series when a brush is applied\r\n * @return {Object}          Configuration\r\n */ var getAxisMap = function getAxisMap(props, _ref4) {\n    var _ref4$axisType = _ref4.axisType, axisType = _ref4$axisType === void 0 ? 'xAxis' : _ref4$axisType, AxisComp = _ref4.AxisComp, graphicalItems = _ref4.graphicalItems, stackGroups = _ref4.stackGroups, dataStartIndex = _ref4.dataStartIndex, dataEndIndex = _ref4.dataEndIndex;\n    var children = props.children;\n    var axisIdKey = \"\".concat(axisType, \"Id\");\n    // Get all the instance of Axis\n    var axes = (0, _ReactUtils.findAllByType)(children, AxisComp);\n    var axisMap = {};\n    if (axes && axes.length) {\n        axisMap = getAxisMapByAxes(props, {\n            axes: axes,\n            graphicalItems: graphicalItems,\n            axisType: axisType,\n            axisIdKey: axisIdKey,\n            stackGroups: stackGroups,\n            dataStartIndex: dataStartIndex,\n            dataEndIndex: dataEndIndex\n        });\n    } else if (graphicalItems && graphicalItems.length) {\n        axisMap = getAxisMapByItems(props, {\n            Axis: AxisComp,\n            graphicalItems: graphicalItems,\n            axisType: axisType,\n            axisIdKey: axisIdKey,\n            stackGroups: stackGroups,\n            dataStartIndex: dataStartIndex,\n            dataEndIndex: dataEndIndex\n        });\n    }\n    return axisMap;\n};\nvar tooltipTicksGenerator = function tooltipTicksGenerator(axisMap) {\n    var axis = (0, _DataUtils.getAnyElementOfObject)(axisMap);\n    var tooltipTicks = (0, _ChartUtils.getTicksOfAxis)(axis, false, true);\n    return {\n        tooltipTicks: tooltipTicks,\n        orderedTooltipTicks: (0, _sortBy[\"default\"])(tooltipTicks, function(o) {\n            return o.coordinate;\n        }),\n        tooltipAxis: axis,\n        tooltipAxisBandSize: (0, _ChartUtils.getBandSizeOfAxis)(axis, tooltipTicks)\n    };\n};\n/**\r\n * Returns default, reset state for the categorical chart.\r\n * @param {Object} props Props object to use when creating the default state\r\n * @return {Object} Whole new state\r\n */ var createDefaultState = exports.createDefaultState = function createDefaultState(props) {\n    var children = props.children, defaultShowTooltip = props.defaultShowTooltip;\n    var brushItem = (0, _ReactUtils.findChildByType)(children, _Brush.Brush);\n    var startIndex = 0;\n    var endIndex = 0;\n    if (props.data && props.data.length !== 0) {\n        endIndex = props.data.length - 1;\n    }\n    if (brushItem && brushItem.props) {\n        if (brushItem.props.startIndex >= 0) {\n            startIndex = brushItem.props.startIndex;\n        }\n        if (brushItem.props.endIndex >= 0) {\n            endIndex = brushItem.props.endIndex;\n        }\n    }\n    return {\n        chartX: 0,\n        chartY: 0,\n        dataStartIndex: startIndex,\n        dataEndIndex: endIndex,\n        activeTooltipIndex: -1,\n        isTooltipActive: Boolean(defaultShowTooltip)\n    };\n};\nvar hasGraphicalBarItem = function hasGraphicalBarItem(graphicalItems) {\n    if (!graphicalItems || !graphicalItems.length) {\n        return false;\n    }\n    return graphicalItems.some(function(item) {\n        var name = (0, _ReactUtils.getDisplayName)(item && item.type);\n        return name && name.indexOf('Bar') >= 0;\n    });\n};\nvar getAxisNameByLayout = function getAxisNameByLayout(layout) {\n    if (layout === 'horizontal') {\n        return {\n            numericAxisName: 'yAxis',\n            cateAxisName: 'xAxis'\n        };\n    }\n    if (layout === 'vertical') {\n        return {\n            numericAxisName: 'xAxis',\n            cateAxisName: 'yAxis'\n        };\n    }\n    if (layout === 'centric') {\n        return {\n            numericAxisName: 'radiusAxis',\n            cateAxisName: 'angleAxis'\n        };\n    }\n    return {\n        numericAxisName: 'angleAxis',\n        cateAxisName: 'radiusAxis'\n    };\n};\n/**\r\n * Calculate the offset of main part in the svg element\r\n * @param  {Object} params.props          Latest props\r\n * @param  {Array}  params.graphicalItems The instances of item\r\n * @param  {Object} params.xAxisMap       The configuration of x-axis\r\n * @param  {Object} params.yAxisMap       The configuration of y-axis\r\n * @param  {Object} prevLegendBBox        The boundary box of legend\r\n * @return {Object} The offset of main part in the svg element\r\n */ var calculateOffset = function calculateOffset(_ref5, prevLegendBBox) {\n    var props = _ref5.props, graphicalItems = _ref5.graphicalItems, _ref5$xAxisMap = _ref5.xAxisMap, xAxisMap = _ref5$xAxisMap === void 0 ? {} : _ref5$xAxisMap, _ref5$yAxisMap = _ref5.yAxisMap, yAxisMap = _ref5$yAxisMap === void 0 ? {} : _ref5$yAxisMap;\n    var width = props.width, height = props.height, children = props.children;\n    var margin = props.margin || {};\n    var brushItem = (0, _ReactUtils.findChildByType)(children, _Brush.Brush);\n    var legendItem = (0, _ReactUtils.findChildByType)(children, _Legend.Legend);\n    var offsetH = Object.keys(yAxisMap).reduce(function(result, id) {\n        var entry = yAxisMap[id];\n        var orientation = entry.orientation;\n        if (!entry.mirror && !entry.hide) {\n            return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, orientation, result[orientation] + entry.width));\n        }\n        return result;\n    }, {\n        left: margin.left || 0,\n        right: margin.right || 0\n    });\n    var offsetV = Object.keys(xAxisMap).reduce(function(result, id) {\n        var entry = xAxisMap[id];\n        var orientation = entry.orientation;\n        if (!entry.mirror && !entry.hide) {\n            return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, orientation, (0, _get[\"default\"])(result, \"\".concat(orientation)) + entry.height));\n        }\n        return result;\n    }, {\n        top: margin.top || 0,\n        bottom: margin.bottom || 0\n    });\n    var offset = _objectSpread(_objectSpread({}, offsetV), offsetH);\n    var brushBottom = offset.bottom;\n    if (brushItem) {\n        offset.bottom += brushItem.props.height || _Brush.Brush.defaultProps.height;\n    }\n    if (legendItem && prevLegendBBox) {\n        // @ts-expect-error margin is optional in props but required in appendOffsetOfLegend\n        offset = (0, _ChartUtils.appendOffsetOfLegend)(offset, graphicalItems, props, prevLegendBBox);\n    }\n    var offsetWidth = width - offset.left - offset.right;\n    var offsetHeight = height - offset.top - offset.bottom;\n    return _objectSpread(_objectSpread({\n        brushBottom: brushBottom\n    }, offset), {}, {\n        // never return negative values for height and width\n        width: Math.max(offsetWidth, 0),\n        height: Math.max(offsetHeight, 0)\n    });\n};\n// Determine the size of the axis, used for calculation of relative bar sizes\nvar getCartesianAxisSize = function getCartesianAxisSize(axisObj, axisName) {\n    if (axisName === 'xAxis') {\n        return axisObj[axisName].width;\n    }\n    if (axisName === 'yAxis') {\n        return axisObj[axisName].height;\n    }\n    // This is only supported for Bar charts (i.e. charts with cartesian axes), so we should never get here\n    return undefined;\n};\nvar generateCategoricalChart = exports.generateCategoricalChart = function generateCategoricalChart(_ref6) {\n    var chartName = _ref6.chartName, GraphicalChild = _ref6.GraphicalChild, _ref6$defaultTooltipE = _ref6.defaultTooltipEventType, defaultTooltipEventType = _ref6$defaultTooltipE === void 0 ? 'axis' : _ref6$defaultTooltipE, _ref6$validateTooltip = _ref6.validateTooltipEventTypes, validateTooltipEventTypes = _ref6$validateTooltip === void 0 ? [\n        'axis'\n    ] : _ref6$validateTooltip, axisComponents = _ref6.axisComponents, legendContent = _ref6.legendContent, formatAxisMap = _ref6.formatAxisMap, defaultProps = _ref6.defaultProps;\n    var getFormatItems = function getFormatItems(props, currentState) {\n        var graphicalItems = currentState.graphicalItems, stackGroups = currentState.stackGroups, offset = currentState.offset, updateId = currentState.updateId, dataStartIndex = currentState.dataStartIndex, dataEndIndex = currentState.dataEndIndex;\n        var barSize = props.barSize, layout = props.layout, barGap = props.barGap, barCategoryGap = props.barCategoryGap, globalMaxBarSize = props.maxBarSize;\n        var _getAxisNameByLayout = getAxisNameByLayout(layout), numericAxisName = _getAxisNameByLayout.numericAxisName, cateAxisName = _getAxisNameByLayout.cateAxisName;\n        var hasBar = hasGraphicalBarItem(graphicalItems);\n        var formattedItems = [];\n        graphicalItems.forEach(function(item, index) {\n            var displayedData = getDisplayedData(props.data, {\n                graphicalItems: [\n                    item\n                ],\n                dataStartIndex: dataStartIndex,\n                dataEndIndex: dataEndIndex\n            });\n            var itemProps = item.type.defaultProps !== undefined ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;\n            var dataKey = itemProps.dataKey, childMaxBarSize = itemProps.maxBarSize;\n            // axisId of the numerical axis\n            var numericAxisId = itemProps[\"\".concat(numericAxisName, \"Id\")];\n            // axisId of the categorical axis\n            var cateAxisId = itemProps[\"\".concat(cateAxisName, \"Id\")];\n            var axisObjInitialValue = {};\n            var axisObj = axisComponents.reduce(function(result, entry) {\n                var _item$type$displayNam, _item$type;\n                // map of axisId to axis for a specific axis type\n                var axisMap = currentState[\"\".concat(entry.axisType, \"Map\")];\n                // axisId of axis we are currently computing\n                var id = itemProps[\"\".concat(entry.axisType, \"Id\")];\n                /**\r\n         * tell the user in dev mode that their configuration is incorrect if we cannot find a match between\r\n         * axisId on the chart and axisId on the axis. zAxis does not get passed in the map for ComposedChart,\r\n         * leave it out of the check for now.\r\n         */ !(axisMap && axisMap[id] || entry.axisType === 'zAxis') ?  true ? (0, _tinyInvariant[\"default\"])(false, \"Specifying a(n) \".concat(entry.axisType, \"Id requires a corresponding \").concat(entry.axisType, \"Id on the targeted graphical component \").concat((_item$type$displayNam = item === null || item === void 0 || (_item$type = item.type) === null || _item$type === void 0 ? void 0 : _item$type.displayName) !== null && _item$type$displayNam !== void 0 ? _item$type$displayNam : '')) : 0 : void 0;\n                // the axis we are currently formatting\n                var axis = axisMap[id];\n                return _objectSpread(_objectSpread({}, result), {}, _defineProperty(_defineProperty({}, entry.axisType, axis), \"\".concat(entry.axisType, \"Ticks\"), (0, _ChartUtils.getTicksOfAxis)(axis)));\n            }, axisObjInitialValue);\n            var cateAxis = axisObj[cateAxisName];\n            var cateTicks = axisObj[\"\".concat(cateAxisName, \"Ticks\")];\n            var stackedData = stackGroups && stackGroups[numericAxisId] && stackGroups[numericAxisId].hasStack && (0, _ChartUtils.getStackedDataOfItem)(item, stackGroups[numericAxisId].stackGroups);\n            var itemIsBar = (0, _ReactUtils.getDisplayName)(item.type).indexOf('Bar') >= 0;\n            var bandSize = (0, _ChartUtils.getBandSizeOfAxis)(cateAxis, cateTicks);\n            var barPosition = [];\n            var sizeList = hasBar && (0, _ChartUtils.getBarSizeList)({\n                barSize: barSize,\n                stackGroups: stackGroups,\n                totalSize: getCartesianAxisSize(axisObj, cateAxisName)\n            });\n            if (itemIsBar) {\n                var _ref7, _getBandSizeOfAxis;\n                // If it is bar, calculate the position of bar\n                var maxBarSize = (0, _isNil[\"default\"])(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;\n                var barBandSize = (_ref7 = (_getBandSizeOfAxis = (0, _ChartUtils.getBandSizeOfAxis)(cateAxis, cateTicks, true)) !== null && _getBandSizeOfAxis !== void 0 ? _getBandSizeOfAxis : maxBarSize) !== null && _ref7 !== void 0 ? _ref7 : 0;\n                barPosition = (0, _ChartUtils.getBarPosition)({\n                    barGap: barGap,\n                    barCategoryGap: barCategoryGap,\n                    bandSize: barBandSize !== bandSize ? barBandSize : bandSize,\n                    sizeList: sizeList[cateAxisId],\n                    maxBarSize: maxBarSize\n                });\n                if (barBandSize !== bandSize) {\n                    barPosition = barPosition.map(function(pos) {\n                        return _objectSpread(_objectSpread({}, pos), {}, {\n                            position: _objectSpread(_objectSpread({}, pos.position), {}, {\n                                offset: pos.position.offset - barBandSize / 2\n                            })\n                        });\n                    });\n                }\n            }\n            // @ts-expect-error we should stop reading data from ReactElements\n            var composedFn = item && item.type && item.type.getComposedData;\n            if (composedFn) {\n                formattedItems.push({\n                    props: _objectSpread(_objectSpread({}, composedFn(_objectSpread(_objectSpread({}, axisObj), {}, {\n                        displayedData: displayedData,\n                        props: props,\n                        dataKey: dataKey,\n                        item: item,\n                        bandSize: bandSize,\n                        barPosition: barPosition,\n                        offset: offset,\n                        stackedData: stackedData,\n                        layout: layout,\n                        dataStartIndex: dataStartIndex,\n                        dataEndIndex: dataEndIndex\n                    }))), {}, _defineProperty(_defineProperty(_defineProperty({\n                        key: item.key || \"item-\".concat(index)\n                    }, numericAxisName, axisObj[numericAxisName]), cateAxisName, axisObj[cateAxisName]), \"animationId\", updateId)),\n                    childIndex: (0, _ReactUtils.parseChildIndex)(item, props.children),\n                    item: item\n                });\n            }\n        });\n        return formattedItems;\n    };\n    /**\r\n   * The AxisMaps are expensive to render on large data sets\r\n   * so provide the ability to store them in state and only update them when necessary\r\n   * they are dependent upon the start and end index of\r\n   * the brush so it's important that this method is called _after_\r\n   * the state is updated with any new start/end indices\r\n   *\r\n   * @param {Object} props          The props object to be used for updating the axismaps\r\n   * dataStartIndex: The start index of the data series when a brush is applied\r\n   * dataEndIndex: The end index of the data series when a brush is applied\r\n   * updateId: The update id\r\n   * @param {Object} prevState      Prev state\r\n   * @return {Object} state New state to set\r\n   */ var updateStateOfAxisMapsOffsetAndStackGroups = function updateStateOfAxisMapsOffsetAndStackGroups(_ref8, prevState) {\n        var props = _ref8.props, dataStartIndex = _ref8.dataStartIndex, dataEndIndex = _ref8.dataEndIndex, updateId = _ref8.updateId;\n        if (!(0, _ReactUtils.validateWidthHeight)({\n            props: props\n        })) {\n            return null;\n        }\n        var children = props.children, layout = props.layout, stackOffset = props.stackOffset, data = props.data, reverseStackOrder = props.reverseStackOrder;\n        var _getAxisNameByLayout2 = getAxisNameByLayout(layout), numericAxisName = _getAxisNameByLayout2.numericAxisName, cateAxisName = _getAxisNameByLayout2.cateAxisName;\n        var graphicalItems = (0, _ReactUtils.findAllByType)(children, GraphicalChild);\n        var stackGroups = (0, _ChartUtils.getStackGroupsByAxisId)(data, graphicalItems, \"\".concat(numericAxisName, \"Id\"), \"\".concat(cateAxisName, \"Id\"), stackOffset, reverseStackOrder);\n        var axisObj = axisComponents.reduce(function(result, entry) {\n            var name = \"\".concat(entry.axisType, \"Map\");\n            return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, name, getAxisMap(props, _objectSpread(_objectSpread({}, entry), {}, {\n                graphicalItems: graphicalItems,\n                stackGroups: entry.axisType === numericAxisName && stackGroups,\n                dataStartIndex: dataStartIndex,\n                dataEndIndex: dataEndIndex\n            }))));\n        }, {});\n        var offset = calculateOffset(_objectSpread(_objectSpread({}, axisObj), {}, {\n            props: props,\n            graphicalItems: graphicalItems\n        }), prevState === null || prevState === void 0 ? void 0 : prevState.legendBBox);\n        Object.keys(axisObj).forEach(function(key) {\n            axisObj[key] = formatAxisMap(props, axisObj[key], offset, key.replace('Map', ''), chartName);\n        });\n        var cateAxisMap = axisObj[\"\".concat(cateAxisName, \"Map\")];\n        var ticksObj = tooltipTicksGenerator(cateAxisMap);\n        var formattedGraphicalItems = getFormatItems(props, _objectSpread(_objectSpread({}, axisObj), {}, {\n            dataStartIndex: dataStartIndex,\n            dataEndIndex: dataEndIndex,\n            updateId: updateId,\n            graphicalItems: graphicalItems,\n            stackGroups: stackGroups,\n            offset: offset\n        }));\n        return _objectSpread(_objectSpread({\n            formattedGraphicalItems: formattedGraphicalItems,\n            graphicalItems: graphicalItems,\n            offset: offset,\n            stackGroups: stackGroups\n        }, ticksObj), axisObj);\n    };\n    var CategoricalChartWrapper = /*#__PURE__*/ function(_Component) {\n        function CategoricalChartWrapper(_props) {\n            var _props$id, _props$throttleDelay;\n            var _this;\n            _classCallCheck(this, CategoricalChartWrapper);\n            _this = _callSuper(this, CategoricalChartWrapper, [\n                _props\n            ]);\n            _defineProperty(_this, \"eventEmitterSymbol\", Symbol('rechartsEventEmitter'));\n            _defineProperty(_this, \"accessibilityManager\", new _AccessibilityManager.AccessibilityManager());\n            _defineProperty(_this, \"handleLegendBBoxUpdate\", function(box) {\n                if (box) {\n                    var _this$state = _this.state, dataStartIndex = _this$state.dataStartIndex, dataEndIndex = _this$state.dataEndIndex, updateId = _this$state.updateId;\n                    _this.setState(_objectSpread({\n                        legendBBox: box\n                    }, updateStateOfAxisMapsOffsetAndStackGroups({\n                        props: _this.props,\n                        dataStartIndex: dataStartIndex,\n                        dataEndIndex: dataEndIndex,\n                        updateId: updateId\n                    }, _objectSpread(_objectSpread({}, _this.state), {}, {\n                        legendBBox: box\n                    }))));\n                }\n            });\n            _defineProperty(_this, \"handleReceiveSyncEvent\", function(cId, data, emitter) {\n                if (_this.props.syncId === cId) {\n                    if (emitter === _this.eventEmitterSymbol && typeof _this.props.syncMethod !== 'function') {\n                        return;\n                    }\n                    _this.applySyncEvent(data);\n                }\n            });\n            _defineProperty(_this, \"handleBrushChange\", function(_ref9) {\n                var startIndex = _ref9.startIndex, endIndex = _ref9.endIndex;\n                // Only trigger changes if the extents of the brush have actually changed\n                if (startIndex !== _this.state.dataStartIndex || endIndex !== _this.state.dataEndIndex) {\n                    var updateId = _this.state.updateId;\n                    _this.setState(function() {\n                        return _objectSpread({\n                            dataStartIndex: startIndex,\n                            dataEndIndex: endIndex\n                        }, updateStateOfAxisMapsOffsetAndStackGroups({\n                            props: _this.props,\n                            dataStartIndex: startIndex,\n                            dataEndIndex: endIndex,\n                            updateId: updateId\n                        }, _this.state));\n                    });\n                    _this.triggerSyncEvent({\n                        dataStartIndex: startIndex,\n                        dataEndIndex: endIndex\n                    });\n                }\n            });\n            /**\r\n       * The handler of mouse entering chart\r\n       * @param  {Object} e              Event object\r\n       * @return {Null}                  null\r\n       */ _defineProperty(_this, \"handleMouseEnter\", function(e) {\n                var mouse = _this.getMouseInfo(e);\n                if (mouse) {\n                    var _nextState = _objectSpread(_objectSpread({}, mouse), {}, {\n                        isTooltipActive: true\n                    });\n                    _this.setState(_nextState);\n                    _this.triggerSyncEvent(_nextState);\n                    var onMouseEnter = _this.props.onMouseEnter;\n                    if ((0, _isFunction[\"default\"])(onMouseEnter)) {\n                        onMouseEnter(_nextState, e);\n                    }\n                }\n            });\n            _defineProperty(_this, \"triggeredAfterMouseMove\", function(e) {\n                var mouse = _this.getMouseInfo(e);\n                var nextState = mouse ? _objectSpread(_objectSpread({}, mouse), {}, {\n                    isTooltipActive: true\n                }) : {\n                    isTooltipActive: false\n                };\n                _this.setState(nextState);\n                _this.triggerSyncEvent(nextState);\n                var onMouseMove = _this.props.onMouseMove;\n                if ((0, _isFunction[\"default\"])(onMouseMove)) {\n                    onMouseMove(nextState, e);\n                }\n            });\n            /**\r\n       * The handler of mouse entering a scatter\r\n       * @param {Object} el The active scatter\r\n       * @return {Object} no return\r\n       */ _defineProperty(_this, \"handleItemMouseEnter\", function(el) {\n                _this.setState(function() {\n                    return {\n                        isTooltipActive: true,\n                        activeItem: el,\n                        activePayload: el.tooltipPayload,\n                        activeCoordinate: el.tooltipPosition || {\n                            x: el.cx,\n                            y: el.cy\n                        }\n                    };\n                });\n            });\n            /**\r\n       * The handler of mouse leaving a scatter\r\n       * @return {Object} no return\r\n       */ _defineProperty(_this, \"handleItemMouseLeave\", function() {\n                _this.setState(function() {\n                    return {\n                        isTooltipActive: false\n                    };\n                });\n            });\n            /**\r\n       * The handler of mouse moving in chart\r\n       * @param  {React.MouseEvent} e        Event object\r\n       * @return {void} no return\r\n       */ _defineProperty(_this, \"handleMouseMove\", function(e) {\n                e.persist();\n                _this.throttleTriggeredAfterMouseMove(e);\n            });\n            /**\r\n       * The handler if mouse leaving chart\r\n       * @param {Object} e Event object\r\n       * @return {Null} no return\r\n       */ _defineProperty(_this, \"handleMouseLeave\", function(e) {\n                _this.throttleTriggeredAfterMouseMove.cancel();\n                var nextState = {\n                    isTooltipActive: false\n                };\n                _this.setState(nextState);\n                _this.triggerSyncEvent(nextState);\n                var onMouseLeave = _this.props.onMouseLeave;\n                if ((0, _isFunction[\"default\"])(onMouseLeave)) {\n                    onMouseLeave(nextState, e);\n                }\n            });\n            _defineProperty(_this, \"handleOuterEvent\", function(e) {\n                var eventName = (0, _ReactUtils.getReactEventByType)(e);\n                var event = (0, _get[\"default\"])(_this.props, \"\".concat(eventName));\n                if (eventName && (0, _isFunction[\"default\"])(event)) {\n                    var _mouse;\n                    var mouse;\n                    if (/.*touch.*/i.test(eventName)) {\n                        mouse = _this.getMouseInfo(e.changedTouches[0]);\n                    } else {\n                        mouse = _this.getMouseInfo(e);\n                    }\n                    event((_mouse = mouse) !== null && _mouse !== void 0 ? _mouse : {}, e);\n                }\n            });\n            _defineProperty(_this, \"handleClick\", function(e) {\n                var mouse = _this.getMouseInfo(e);\n                if (mouse) {\n                    var _nextState2 = _objectSpread(_objectSpread({}, mouse), {}, {\n                        isTooltipActive: true\n                    });\n                    _this.setState(_nextState2);\n                    _this.triggerSyncEvent(_nextState2);\n                    var onClick = _this.props.onClick;\n                    if ((0, _isFunction[\"default\"])(onClick)) {\n                        onClick(_nextState2, e);\n                    }\n                }\n            });\n            _defineProperty(_this, \"handleMouseDown\", function(e) {\n                var onMouseDown = _this.props.onMouseDown;\n                if ((0, _isFunction[\"default\"])(onMouseDown)) {\n                    var _nextState3 = _this.getMouseInfo(e);\n                    onMouseDown(_nextState3, e);\n                }\n            });\n            _defineProperty(_this, \"handleMouseUp\", function(e) {\n                var onMouseUp = _this.props.onMouseUp;\n                if ((0, _isFunction[\"default\"])(onMouseUp)) {\n                    var _nextState4 = _this.getMouseInfo(e);\n                    onMouseUp(_nextState4, e);\n                }\n            });\n            _defineProperty(_this, \"handleTouchMove\", function(e) {\n                if (e.changedTouches != null && e.changedTouches.length > 0) {\n                    _this.throttleTriggeredAfterMouseMove(e.changedTouches[0]);\n                }\n            });\n            _defineProperty(_this, \"handleTouchStart\", function(e) {\n                if (e.changedTouches != null && e.changedTouches.length > 0) {\n                    _this.handleMouseDown(e.changedTouches[0]);\n                }\n            });\n            _defineProperty(_this, \"handleTouchEnd\", function(e) {\n                if (e.changedTouches != null && e.changedTouches.length > 0) {\n                    _this.handleMouseUp(e.changedTouches[0]);\n                }\n            });\n            _defineProperty(_this, \"handleDoubleClick\", function(e) {\n                var onDoubleClick = _this.props.onDoubleClick;\n                if ((0, _isFunction[\"default\"])(onDoubleClick)) {\n                    var _nextState5 = _this.getMouseInfo(e);\n                    onDoubleClick(_nextState5, e);\n                }\n            });\n            _defineProperty(_this, \"handleContextMenu\", function(e) {\n                var onContextMenu = _this.props.onContextMenu;\n                if ((0, _isFunction[\"default\"])(onContextMenu)) {\n                    var _nextState6 = _this.getMouseInfo(e);\n                    onContextMenu(_nextState6, e);\n                }\n            });\n            _defineProperty(_this, \"triggerSyncEvent\", function(data) {\n                if (_this.props.syncId !== undefined) {\n                    _Events.eventCenter.emit(_Events.SYNC_EVENT, _this.props.syncId, data, _this.eventEmitterSymbol);\n                }\n            });\n            _defineProperty(_this, \"applySyncEvent\", function(data) {\n                var _this$props = _this.props, layout = _this$props.layout, syncMethod = _this$props.syncMethod;\n                var updateId = _this.state.updateId;\n                var dataStartIndex = data.dataStartIndex, dataEndIndex = data.dataEndIndex;\n                if (data.dataStartIndex !== undefined || data.dataEndIndex !== undefined) {\n                    _this.setState(_objectSpread({\n                        dataStartIndex: dataStartIndex,\n                        dataEndIndex: dataEndIndex\n                    }, updateStateOfAxisMapsOffsetAndStackGroups({\n                        props: _this.props,\n                        dataStartIndex: dataStartIndex,\n                        dataEndIndex: dataEndIndex,\n                        updateId: updateId\n                    }, _this.state)));\n                } else if (data.activeTooltipIndex !== undefined) {\n                    var chartX = data.chartX, chartY = data.chartY;\n                    var activeTooltipIndex = data.activeTooltipIndex;\n                    var _this$state2 = _this.state, offset = _this$state2.offset, tooltipTicks = _this$state2.tooltipTicks;\n                    if (!offset) {\n                        return;\n                    }\n                    if (typeof syncMethod === 'function') {\n                        // Call a callback function. If there is an application specific algorithm\n                        activeTooltipIndex = syncMethod(tooltipTicks, data);\n                    } else if (syncMethod === 'value') {\n                        // Set activeTooltipIndex to the index with the same value as data.activeLabel\n                        // For loop instead of findIndex because the latter is very slow in some browsers\n                        activeTooltipIndex = -1; // in case we cannot find the element\n                        for(var i = 0; i < tooltipTicks.length; i++){\n                            if (tooltipTicks[i].value === data.activeLabel) {\n                                activeTooltipIndex = i;\n                                break;\n                            }\n                        }\n                    }\n                    var viewBox = _objectSpread(_objectSpread({}, offset), {}, {\n                        x: offset.left,\n                        y: offset.top\n                    });\n                    // When a categorical chart is combined with another chart, the value of chartX\n                    // and chartY may beyond the boundaries.\n                    var validateChartX = Math.min(chartX, viewBox.x + viewBox.width);\n                    var validateChartY = Math.min(chartY, viewBox.y + viewBox.height);\n                    var activeLabel = tooltipTicks[activeTooltipIndex] && tooltipTicks[activeTooltipIndex].value;\n                    var activePayload = getTooltipContent(_this.state, _this.props.data, activeTooltipIndex);\n                    var activeCoordinate = tooltipTicks[activeTooltipIndex] ? {\n                        x: layout === 'horizontal' ? tooltipTicks[activeTooltipIndex].coordinate : validateChartX,\n                        y: layout === 'horizontal' ? validateChartY : tooltipTicks[activeTooltipIndex].coordinate\n                    } : originCoordinate;\n                    _this.setState(_objectSpread(_objectSpread({}, data), {}, {\n                        activeLabel: activeLabel,\n                        activeCoordinate: activeCoordinate,\n                        activePayload: activePayload,\n                        activeTooltipIndex: activeTooltipIndex\n                    }));\n                } else {\n                    _this.setState(data);\n                }\n            });\n            _defineProperty(_this, \"renderCursor\", function(element) {\n                var _element$props$active;\n                var _this$state3 = _this.state, isTooltipActive = _this$state3.isTooltipActive, activeCoordinate = _this$state3.activeCoordinate, activePayload = _this$state3.activePayload, offset = _this$state3.offset, activeTooltipIndex = _this$state3.activeTooltipIndex, tooltipAxisBandSize = _this$state3.tooltipAxisBandSize;\n                var tooltipEventType = _this.getTooltipEventType();\n                // The cursor is a part of the Tooltip, and it should be shown (by default) when the Tooltip is active.\n                var isActive = (_element$props$active = element.props.active) !== null && _element$props$active !== void 0 ? _element$props$active : isTooltipActive;\n                var layout = _this.props.layout;\n                var key = element.key || '_recharts-cursor';\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Cursor.Cursor, {\n                    key: key,\n                    activeCoordinate: activeCoordinate,\n                    activePayload: activePayload,\n                    activeTooltipIndex: activeTooltipIndex,\n                    chartName: chartName,\n                    element: element,\n                    isActive: isActive,\n                    layout: layout,\n                    offset: offset,\n                    tooltipAxisBandSize: tooltipAxisBandSize,\n                    tooltipEventType: tooltipEventType\n                });\n            });\n            _defineProperty(_this, \"renderPolarAxis\", function(element, displayName, index) {\n                var axisType = (0, _get[\"default\"])(element, 'type.axisType');\n                var axisMap = (0, _get[\"default\"])(_this.state, \"\".concat(axisType, \"Map\"));\n                var elementDefaultProps = element.type.defaultProps;\n                var elementProps = elementDefaultProps !== undefined ? _objectSpread(_objectSpread({}, elementDefaultProps), element.props) : element.props;\n                var axisOption = axisMap && axisMap[elementProps[\"\".concat(axisType, \"Id\")]];\n                return /*#__PURE__*/ (0, _react.cloneElement)(element, _objectSpread(_objectSpread({}, axisOption), {}, {\n                    className: (0, _clsx[\"default\"])(axisType, axisOption.className),\n                    key: element.key || \"\".concat(displayName, \"-\").concat(index),\n                    ticks: (0, _ChartUtils.getTicksOfAxis)(axisOption, true)\n                }));\n            });\n            _defineProperty(_this, \"renderPolarGrid\", function(element) {\n                var _element$props = element.props, radialLines = _element$props.radialLines, polarAngles = _element$props.polarAngles, polarRadius = _element$props.polarRadius;\n                var _this$state4 = _this.state, radiusAxisMap = _this$state4.radiusAxisMap, angleAxisMap = _this$state4.angleAxisMap;\n                var radiusAxis = (0, _DataUtils.getAnyElementOfObject)(radiusAxisMap);\n                var angleAxis = (0, _DataUtils.getAnyElementOfObject)(angleAxisMap);\n                var cx = angleAxis.cx, cy = angleAxis.cy, innerRadius = angleAxis.innerRadius, outerRadius = angleAxis.outerRadius;\n                return /*#__PURE__*/ (0, _react.cloneElement)(element, {\n                    polarAngles: Array.isArray(polarAngles) ? polarAngles : (0, _ChartUtils.getTicksOfAxis)(angleAxis, true).map(function(entry) {\n                        return entry.coordinate;\n                    }),\n                    polarRadius: Array.isArray(polarRadius) ? polarRadius : (0, _ChartUtils.getTicksOfAxis)(radiusAxis, true).map(function(entry) {\n                        return entry.coordinate;\n                    }),\n                    cx: cx,\n                    cy: cy,\n                    innerRadius: innerRadius,\n                    outerRadius: outerRadius,\n                    key: element.key || 'polar-grid',\n                    radialLines: radialLines\n                });\n            });\n            /**\r\n       * Draw legend\r\n       * @return {ReactElement}            The instance of Legend\r\n       */ _defineProperty(_this, \"renderLegend\", function() {\n                var formattedGraphicalItems = _this.state.formattedGraphicalItems;\n                var _this$props2 = _this.props, children = _this$props2.children, width = _this$props2.width, height = _this$props2.height;\n                var margin = _this.props.margin || {};\n                var legendWidth = width - (margin.left || 0) - (margin.right || 0);\n                var props = (0, _ChartUtils.getLegendProps)({\n                    children: children,\n                    formattedGraphicalItems: formattedGraphicalItems,\n                    legendWidth: legendWidth,\n                    legendContent: legendContent\n                });\n                if (!props) {\n                    return null;\n                }\n                var item = props.item, otherProps = _objectWithoutProperties(props, _excluded);\n                return /*#__PURE__*/ (0, _react.cloneElement)(item, _objectSpread(_objectSpread({}, otherProps), {}, {\n                    chartWidth: width,\n                    chartHeight: height,\n                    margin: margin,\n                    onBBoxUpdate: _this.handleLegendBBoxUpdate\n                }));\n            });\n            /**\r\n       * Draw Tooltip\r\n       * @return {ReactElement}  The instance of Tooltip\r\n       */ _defineProperty(_this, \"renderTooltip\", function() {\n                var _tooltipItem$props$ac;\n                var _this$props3 = _this.props, children = _this$props3.children, accessibilityLayer = _this$props3.accessibilityLayer;\n                var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                if (!tooltipItem) {\n                    return null;\n                }\n                var _this$state5 = _this.state, isTooltipActive = _this$state5.isTooltipActive, activeCoordinate = _this$state5.activeCoordinate, activePayload = _this$state5.activePayload, activeLabel = _this$state5.activeLabel, offset = _this$state5.offset;\n                // The user can set isActive on the Tooltip,\n                // and we respect the user to enable customisation.\n                // The Tooltip is active if the user has set isActive, or if the tooltip is active due to a mouse event.\n                var isActive = (_tooltipItem$props$ac = tooltipItem.props.active) !== null && _tooltipItem$props$ac !== void 0 ? _tooltipItem$props$ac : isTooltipActive;\n                return /*#__PURE__*/ (0, _react.cloneElement)(tooltipItem, {\n                    viewBox: _objectSpread(_objectSpread({}, offset), {}, {\n                        x: offset.left,\n                        y: offset.top\n                    }),\n                    active: isActive,\n                    label: activeLabel,\n                    payload: isActive ? activePayload : [],\n                    coordinate: activeCoordinate,\n                    accessibilityLayer: accessibilityLayer\n                });\n            });\n            _defineProperty(_this, \"renderBrush\", function(element) {\n                var _this$props4 = _this.props, margin = _this$props4.margin, data = _this$props4.data;\n                var _this$state6 = _this.state, offset = _this$state6.offset, dataStartIndex = _this$state6.dataStartIndex, dataEndIndex = _this$state6.dataEndIndex, updateId = _this$state6.updateId;\n                // TODO: update brush when children update\n                return /*#__PURE__*/ (0, _react.cloneElement)(element, {\n                    key: element.key || '_recharts-brush',\n                    onChange: (0, _ChartUtils.combineEventHandlers)(_this.handleBrushChange, element.props.onChange),\n                    data: data,\n                    x: (0, _DataUtils.isNumber)(element.props.x) ? element.props.x : offset.left,\n                    y: (0, _DataUtils.isNumber)(element.props.y) ? element.props.y : offset.top + offset.height + offset.brushBottom - (margin.bottom || 0),\n                    width: (0, _DataUtils.isNumber)(element.props.width) ? element.props.width : offset.width,\n                    startIndex: dataStartIndex,\n                    endIndex: dataEndIndex,\n                    updateId: \"brush-\".concat(updateId)\n                });\n            });\n            _defineProperty(_this, \"renderReferenceElement\", function(element, displayName, index) {\n                if (!element) {\n                    return null;\n                }\n                var _this2 = _this, clipPathId = _this2.clipPathId;\n                var _this$state7 = _this.state, xAxisMap = _this$state7.xAxisMap, yAxisMap = _this$state7.yAxisMap, offset = _this$state7.offset;\n                var elementDefaultProps = element.type.defaultProps || {};\n                var _element$props2 = element.props, _element$props2$xAxis = _element$props2.xAxisId, xAxisId = _element$props2$xAxis === void 0 ? elementDefaultProps.xAxisId : _element$props2$xAxis, _element$props2$yAxis = _element$props2.yAxisId, yAxisId = _element$props2$yAxis === void 0 ? elementDefaultProps.yAxisId : _element$props2$yAxis;\n                return /*#__PURE__*/ (0, _react.cloneElement)(element, {\n                    key: element.key || \"\".concat(displayName, \"-\").concat(index),\n                    xAxis: xAxisMap[xAxisId],\n                    yAxis: yAxisMap[yAxisId],\n                    viewBox: {\n                        x: offset.left,\n                        y: offset.top,\n                        width: offset.width,\n                        height: offset.height\n                    },\n                    clipPathId: clipPathId\n                });\n            });\n            _defineProperty(_this, \"renderActivePoints\", function(_ref10) {\n                var item = _ref10.item, activePoint = _ref10.activePoint, basePoint = _ref10.basePoint, childIndex = _ref10.childIndex, isRange = _ref10.isRange;\n                var result = [];\n                // item is not a React Element so we don't need to resolve defaultProps.\n                var key = item.props.key;\n                var itemItemProps = item.item.type.defaultProps !== undefined ? _objectSpread(_objectSpread({}, item.item.type.defaultProps), item.item.props) : item.item.props;\n                var activeDot = itemItemProps.activeDot, dataKey = itemItemProps.dataKey;\n                var dotProps = _objectSpread(_objectSpread({\n                    index: childIndex,\n                    dataKey: dataKey,\n                    cx: activePoint.x,\n                    cy: activePoint.y,\n                    r: 4,\n                    fill: (0, _ChartUtils.getMainColorOfGraphicItem)(item.item),\n                    strokeWidth: 2,\n                    stroke: '#fff',\n                    payload: activePoint.payload,\n                    value: activePoint.value\n                }, (0, _ReactUtils.filterProps)(activeDot, false)), (0, _types.adaptEventHandlers)(activeDot));\n                result.push(CategoricalChartWrapper.renderActiveDot(activeDot, dotProps, \"\".concat(key, \"-activePoint-\").concat(childIndex)));\n                if (basePoint) {\n                    result.push(CategoricalChartWrapper.renderActiveDot(activeDot, _objectSpread(_objectSpread({}, dotProps), {}, {\n                        cx: basePoint.x,\n                        cy: basePoint.y\n                    }), \"\".concat(key, \"-basePoint-\").concat(childIndex)));\n                } else if (isRange) {\n                    result.push(null);\n                }\n                return result;\n            });\n            _defineProperty(_this, \"renderGraphicChild\", function(element, displayName, index) {\n                var item = _this.filterFormatItem(element, displayName, index);\n                if (!item) {\n                    return null;\n                }\n                var tooltipEventType = _this.getTooltipEventType();\n                var _this$state8 = _this.state, isTooltipActive = _this$state8.isTooltipActive, tooltipAxis = _this$state8.tooltipAxis, activeTooltipIndex = _this$state8.activeTooltipIndex, activeLabel = _this$state8.activeLabel;\n                var children = _this.props.children;\n                var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                // item is not a React Element so we don't need to resolve defaultProps\n                var _item$props = item.props, points = _item$props.points, isRange = _item$props.isRange, baseLine = _item$props.baseLine;\n                var itemItemProps = item.item.type.defaultProps !== undefined ? _objectSpread(_objectSpread({}, item.item.type.defaultProps), item.item.props) : item.item.props;\n                var activeDot = itemItemProps.activeDot, hide = itemItemProps.hide, activeBar = itemItemProps.activeBar, activeShape = itemItemProps.activeShape;\n                var hasActive = Boolean(!hide && isTooltipActive && tooltipItem && (activeDot || activeBar || activeShape));\n                var itemEvents = {};\n                if (tooltipEventType !== 'axis' && tooltipItem && tooltipItem.props.trigger === 'click') {\n                    itemEvents = {\n                        onClick: (0, _ChartUtils.combineEventHandlers)(_this.handleItemMouseEnter, element.props.onClick)\n                    };\n                } else if (tooltipEventType !== 'axis') {\n                    itemEvents = {\n                        onMouseLeave: (0, _ChartUtils.combineEventHandlers)(_this.handleItemMouseLeave, element.props.onMouseLeave),\n                        onMouseEnter: (0, _ChartUtils.combineEventHandlers)(_this.handleItemMouseEnter, element.props.onMouseEnter)\n                    };\n                }\n                var graphicalItem = /*#__PURE__*/ (0, _react.cloneElement)(element, _objectSpread(_objectSpread({}, item.props), itemEvents));\n                function findWithPayload(entry) {\n                    // TODO needs to verify dataKey is Function\n                    return typeof tooltipAxis.dataKey === 'function' ? tooltipAxis.dataKey(entry.payload) : null;\n                }\n                if (hasActive) {\n                    if (activeTooltipIndex >= 0) {\n                        var activePoint, basePoint;\n                        if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) {\n                            // number transform to string\n                            var specifiedKey = typeof tooltipAxis.dataKey === 'function' ? findWithPayload : 'payload.'.concat(tooltipAxis.dataKey.toString());\n                            activePoint = (0, _DataUtils.findEntryInArray)(points, specifiedKey, activeLabel);\n                            basePoint = isRange && baseLine && (0, _DataUtils.findEntryInArray)(baseLine, specifiedKey, activeLabel);\n                        } else {\n                            activePoint = points === null || points === void 0 ? void 0 : points[activeTooltipIndex];\n                            basePoint = isRange && baseLine && baseLine[activeTooltipIndex];\n                        }\n                        if (activeShape || activeBar) {\n                            var activeIndex = element.props.activeIndex !== undefined ? element.props.activeIndex : activeTooltipIndex;\n                            return [\n                                /*#__PURE__*/ (0, _react.cloneElement)(element, _objectSpread(_objectSpread(_objectSpread({}, item.props), itemEvents), {}, {\n                                    activeIndex: activeIndex\n                                })),\n                                null,\n                                null\n                            ];\n                        }\n                        if (!(0, _isNil[\"default\"])(activePoint)) {\n                            return [\n                                graphicalItem\n                            ].concat(_toConsumableArray(_this.renderActivePoints({\n                                item: item,\n                                activePoint: activePoint,\n                                basePoint: basePoint,\n                                childIndex: activeTooltipIndex,\n                                isRange: isRange\n                            })));\n                        }\n                    } else {\n                        var _this$getItemByXY;\n                        /**\r\n             * We hit this block if consumer uses a Tooltip without XAxis and/or YAxis.\r\n             * In which case, this.state.activeTooltipIndex never gets set\r\n             * because the mouse events that trigger that value getting set never get trigged without the axis components.\r\n             *\r\n             * An example usage case is a FunnelChart\r\n             */ var _ref11 = (_this$getItemByXY = _this.getItemByXY(_this.state.activeCoordinate)) !== null && _this$getItemByXY !== void 0 ? _this$getItemByXY : {\n                            graphicalItem: graphicalItem\n                        }, _ref11$graphicalItem = _ref11.graphicalItem, _ref11$graphicalItem$ = _ref11$graphicalItem.item, xyItem = _ref11$graphicalItem$ === void 0 ? element : _ref11$graphicalItem$, childIndex = _ref11$graphicalItem.childIndex;\n                        var elementProps = _objectSpread(_objectSpread(_objectSpread({}, item.props), itemEvents), {}, {\n                            activeIndex: childIndex\n                        });\n                        return [\n                            /*#__PURE__*/ (0, _react.cloneElement)(xyItem, elementProps),\n                            null,\n                            null\n                        ];\n                    }\n                }\n                if (isRange) {\n                    return [\n                        graphicalItem,\n                        null,\n                        null\n                    ];\n                }\n                return [\n                    graphicalItem,\n                    null\n                ];\n            });\n            _defineProperty(_this, \"renderCustomized\", function(element, displayName, index) {\n                return /*#__PURE__*/ (0, _react.cloneElement)(element, _objectSpread(_objectSpread({\n                    key: \"recharts-customized-\".concat(index)\n                }, _this.props), _this.state));\n            });\n            _defineProperty(_this, \"renderMap\", {\n                CartesianGrid: {\n                    handler: renderAsIs,\n                    once: true\n                },\n                ReferenceArea: {\n                    handler: _this.renderReferenceElement\n                },\n                ReferenceLine: {\n                    handler: renderAsIs\n                },\n                ReferenceDot: {\n                    handler: _this.renderReferenceElement\n                },\n                XAxis: {\n                    handler: renderAsIs\n                },\n                YAxis: {\n                    handler: renderAsIs\n                },\n                Brush: {\n                    handler: _this.renderBrush,\n                    once: true\n                },\n                Bar: {\n                    handler: _this.renderGraphicChild\n                },\n                Line: {\n                    handler: _this.renderGraphicChild\n                },\n                Area: {\n                    handler: _this.renderGraphicChild\n                },\n                Radar: {\n                    handler: _this.renderGraphicChild\n                },\n                RadialBar: {\n                    handler: _this.renderGraphicChild\n                },\n                Scatter: {\n                    handler: _this.renderGraphicChild\n                },\n                Pie: {\n                    handler: _this.renderGraphicChild\n                },\n                Funnel: {\n                    handler: _this.renderGraphicChild\n                },\n                Tooltip: {\n                    handler: _this.renderCursor,\n                    once: true\n                },\n                PolarGrid: {\n                    handler: _this.renderPolarGrid,\n                    once: true\n                },\n                PolarAngleAxis: {\n                    handler: _this.renderPolarAxis\n                },\n                PolarRadiusAxis: {\n                    handler: _this.renderPolarAxis\n                },\n                Customized: {\n                    handler: _this.renderCustomized\n                }\n            });\n            _this.clipPathId = \"\".concat((_props$id = _props.id) !== null && _props$id !== void 0 ? _props$id : (0, _DataUtils.uniqueId)('recharts'), \"-clip\");\n            // trigger 60fps\n            _this.throttleTriggeredAfterMouseMove = (0, _throttle[\"default\"])(_this.triggeredAfterMouseMove, (_props$throttleDelay = _props.throttleDelay) !== null && _props$throttleDelay !== void 0 ? _props$throttleDelay : 1000 / 60);\n            _this.state = {};\n            return _this;\n        }\n        _inherits(CategoricalChartWrapper, _Component);\n        return _createClass(CategoricalChartWrapper, [\n            {\n                key: \"componentDidMount\",\n                value: function componentDidMount() {\n                    var _this$props$margin$le, _this$props$margin$to;\n                    this.addListener();\n                    this.accessibilityManager.setDetails({\n                        container: this.container,\n                        offset: {\n                            left: (_this$props$margin$le = this.props.margin.left) !== null && _this$props$margin$le !== void 0 ? _this$props$margin$le : 0,\n                            top: (_this$props$margin$to = this.props.margin.top) !== null && _this$props$margin$to !== void 0 ? _this$props$margin$to : 0\n                        },\n                        coordinateList: this.state.tooltipTicks,\n                        mouseHandlerCallback: this.triggeredAfterMouseMove,\n                        layout: this.props.layout\n                    });\n                    this.displayDefaultTooltip();\n                }\n            },\n            {\n                key: \"displayDefaultTooltip\",\n                value: function displayDefaultTooltip() {\n                    var _this$props5 = this.props, children = _this$props5.children, data = _this$props5.data, height = _this$props5.height, layout = _this$props5.layout;\n                    var tooltipElem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                    // If the chart doesn't include a <Tooltip /> element, there's no tooltip to display\n                    if (!tooltipElem) {\n                        return;\n                    }\n                    var defaultIndex = tooltipElem.props.defaultIndex;\n                    // Protect against runtime errors\n                    if (typeof defaultIndex !== 'number' || defaultIndex < 0 || defaultIndex > this.state.tooltipTicks.length - 1) {\n                        return;\n                    }\n                    var activeLabel = this.state.tooltipTicks[defaultIndex] && this.state.tooltipTicks[defaultIndex].value;\n                    var activePayload = getTooltipContent(this.state, data, defaultIndex, activeLabel);\n                    var independentAxisCoord = this.state.tooltipTicks[defaultIndex].coordinate;\n                    var dependentAxisCoord = (this.state.offset.top + height) / 2;\n                    var isHorizontal = layout === 'horizontal';\n                    var activeCoordinate = isHorizontal ? {\n                        x: independentAxisCoord,\n                        y: dependentAxisCoord\n                    } : {\n                        y: independentAxisCoord,\n                        x: dependentAxisCoord\n                    };\n                    // Unlike other chart types, scatter plot's tooltip positions rely on both X and Y coordinates. Only the scatter plot\n                    // element knows its own Y coordinates.\n                    // If there's a scatter plot, we'll want to grab that element for an interrogation.\n                    var scatterPlotElement = this.state.formattedGraphicalItems.find(function(_ref12) {\n                        var item = _ref12.item;\n                        return item.type.name === 'Scatter';\n                    });\n                    if (scatterPlotElement) {\n                        activeCoordinate = _objectSpread(_objectSpread({}, activeCoordinate), scatterPlotElement.props.points[defaultIndex].tooltipPosition);\n                        activePayload = scatterPlotElement.props.points[defaultIndex].tooltipPayload;\n                    }\n                    var nextState = {\n                        activeTooltipIndex: defaultIndex,\n                        isTooltipActive: true,\n                        activeLabel: activeLabel,\n                        activePayload: activePayload,\n                        activeCoordinate: activeCoordinate\n                    };\n                    this.setState(nextState);\n                    this.renderCursor(tooltipElem);\n                    // Make sure that anyone who keyboard-only users who tab to the chart will start their\n                    // cursors at defaultIndex\n                    this.accessibilityManager.setIndex(defaultIndex);\n                }\n            },\n            {\n                key: \"getSnapshotBeforeUpdate\",\n                value: function getSnapshotBeforeUpdate(prevProps, prevState) {\n                    if (!this.props.accessibilityLayer) {\n                        return null;\n                    }\n                    if (this.state.tooltipTicks !== prevState.tooltipTicks) {\n                        this.accessibilityManager.setDetails({\n                            coordinateList: this.state.tooltipTicks\n                        });\n                    }\n                    if (this.props.layout !== prevProps.layout) {\n                        this.accessibilityManager.setDetails({\n                            layout: this.props.layout\n                        });\n                    }\n                    if (this.props.margin !== prevProps.margin) {\n                        var _this$props$margin$le2, _this$props$margin$to2;\n                        this.accessibilityManager.setDetails({\n                            offset: {\n                                left: (_this$props$margin$le2 = this.props.margin.left) !== null && _this$props$margin$le2 !== void 0 ? _this$props$margin$le2 : 0,\n                                top: (_this$props$margin$to2 = this.props.margin.top) !== null && _this$props$margin$to2 !== void 0 ? _this$props$margin$to2 : 0\n                            }\n                        });\n                    }\n                    // Something has to be returned for getSnapshotBeforeUpdate\n                    return null;\n                }\n            },\n            {\n                key: \"componentDidUpdate\",\n                value: function componentDidUpdate(prevProps) {\n                    // Check to see if the Tooltip updated. If so, re-check default tooltip position\n                    if (!(0, _ReactUtils.isChildrenEqual)([\n                        (0, _ReactUtils.findChildByType)(prevProps.children, _Tooltip.Tooltip)\n                    ], [\n                        (0, _ReactUtils.findChildByType)(this.props.children, _Tooltip.Tooltip)\n                    ])) {\n                        this.displayDefaultTooltip();\n                    }\n                }\n            },\n            {\n                key: \"componentWillUnmount\",\n                value: function componentWillUnmount() {\n                    this.removeListener();\n                    this.throttleTriggeredAfterMouseMove.cancel();\n                }\n            },\n            {\n                key: \"getTooltipEventType\",\n                value: function getTooltipEventType() {\n                    var tooltipItem = (0, _ReactUtils.findChildByType)(this.props.children, _Tooltip.Tooltip);\n                    if (tooltipItem && typeof tooltipItem.props.shared === 'boolean') {\n                        var eventType = tooltipItem.props.shared ? 'axis' : 'item';\n                        return validateTooltipEventTypes.indexOf(eventType) >= 0 ? eventType : defaultTooltipEventType;\n                    }\n                    return defaultTooltipEventType;\n                }\n            },\n            {\n                key: \"getMouseInfo\",\n                value: function getMouseInfo(event) {\n                    if (!this.container) {\n                        return null;\n                    }\n                    var element = this.container;\n                    var boundingRect = element.getBoundingClientRect();\n                    var containerOffset = (0, _DOMUtils.getOffset)(boundingRect);\n                    var e = {\n                        chartX: Math.round(event.pageX - containerOffset.left),\n                        chartY: Math.round(event.pageY - containerOffset.top)\n                    };\n                    var scale = boundingRect.width / element.offsetWidth || 1;\n                    var rangeObj = this.inRange(e.chartX, e.chartY, scale);\n                    if (!rangeObj) {\n                        return null;\n                    }\n                    var _this$state9 = this.state, xAxisMap = _this$state9.xAxisMap, yAxisMap = _this$state9.yAxisMap;\n                    var tooltipEventType = this.getTooltipEventType();\n                    var toolTipData = getTooltipData(this.state, this.props.data, this.props.layout, rangeObj);\n                    if (tooltipEventType !== 'axis' && xAxisMap && yAxisMap) {\n                        var xScale = (0, _DataUtils.getAnyElementOfObject)(xAxisMap).scale;\n                        var yScale = (0, _DataUtils.getAnyElementOfObject)(yAxisMap).scale;\n                        var xValue = xScale && xScale.invert ? xScale.invert(e.chartX) : null;\n                        var yValue = yScale && yScale.invert ? yScale.invert(e.chartY) : null;\n                        return _objectSpread(_objectSpread({}, e), {}, {\n                            xValue: xValue,\n                            yValue: yValue\n                        }, toolTipData);\n                    }\n                    if (toolTipData) {\n                        return _objectSpread(_objectSpread({}, e), toolTipData);\n                    }\n                    return null;\n                }\n            },\n            {\n                key: \"inRange\",\n                value: function inRange(x, y) {\n                    var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n                    var layout = this.props.layout;\n                    var scaledX = x / scale, scaledY = y / scale;\n                    if (layout === 'horizontal' || layout === 'vertical') {\n                        var offset = this.state.offset;\n                        var isInRange = scaledX >= offset.left && scaledX <= offset.left + offset.width && scaledY >= offset.top && scaledY <= offset.top + offset.height;\n                        return isInRange ? {\n                            x: scaledX,\n                            y: scaledY\n                        } : null;\n                    }\n                    var _this$state10 = this.state, angleAxisMap = _this$state10.angleAxisMap, radiusAxisMap = _this$state10.radiusAxisMap;\n                    if (angleAxisMap && radiusAxisMap) {\n                        var angleAxis = (0, _DataUtils.getAnyElementOfObject)(angleAxisMap);\n                        return (0, _PolarUtils.inRangeOfSector)({\n                            x: scaledX,\n                            y: scaledY\n                        }, angleAxis);\n                    }\n                    return null;\n                }\n            },\n            {\n                key: \"parseEventsOfWrapper\",\n                value: function parseEventsOfWrapper() {\n                    var children = this.props.children;\n                    var tooltipEventType = this.getTooltipEventType();\n                    var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                    var tooltipEvents = {};\n                    if (tooltipItem && tooltipEventType === 'axis') {\n                        if (tooltipItem.props.trigger === 'click') {\n                            tooltipEvents = {\n                                onClick: this.handleClick\n                            };\n                        } else {\n                            tooltipEvents = {\n                                onMouseEnter: this.handleMouseEnter,\n                                onDoubleClick: this.handleDoubleClick,\n                                onMouseMove: this.handleMouseMove,\n                                onMouseLeave: this.handleMouseLeave,\n                                onTouchMove: this.handleTouchMove,\n                                onTouchStart: this.handleTouchStart,\n                                onTouchEnd: this.handleTouchEnd,\n                                onContextMenu: this.handleContextMenu\n                            };\n                        }\n                    }\n                    // @ts-expect-error adaptEventHandlers expects DOM Event but generateCategoricalChart works with React UIEvents\n                    var outerEvents = (0, _types.adaptEventHandlers)(this.props, this.handleOuterEvent);\n                    return _objectSpread(_objectSpread({}, outerEvents), tooltipEvents);\n                }\n            },\n            {\n                key: \"addListener\",\n                value: function addListener() {\n                    _Events.eventCenter.on(_Events.SYNC_EVENT, this.handleReceiveSyncEvent);\n                }\n            },\n            {\n                key: \"removeListener\",\n                value: function removeListener() {\n                    _Events.eventCenter.removeListener(_Events.SYNC_EVENT, this.handleReceiveSyncEvent);\n                }\n            },\n            {\n                key: \"filterFormatItem\",\n                value: function filterFormatItem(item, displayName, childIndex) {\n                    var formattedGraphicalItems = this.state.formattedGraphicalItems;\n                    for(var i = 0, len = formattedGraphicalItems.length; i < len; i++){\n                        var entry = formattedGraphicalItems[i];\n                        if (entry.item === item || entry.props.key === item.key || displayName === (0, _ReactUtils.getDisplayName)(entry.item.type) && childIndex === entry.childIndex) {\n                            return entry;\n                        }\n                    }\n                    return null;\n                }\n            },\n            {\n                key: \"renderClipPath\",\n                value: function renderClipPath() {\n                    var clipPathId = this.clipPathId;\n                    var _this$state$offset = this.state.offset, left = _this$state$offset.left, top = _this$state$offset.top, height = _this$state$offset.height, width = _this$state$offset.width;\n                    return /*#__PURE__*/ _react[\"default\"].createElement(\"defs\", null, /*#__PURE__*/ _react[\"default\"].createElement(\"clipPath\", {\n                        id: clipPathId\n                    }, /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                        x: left,\n                        y: top,\n                        height: height,\n                        width: width\n                    })));\n                }\n            },\n            {\n                key: \"getXScales\",\n                value: function getXScales() {\n                    var xAxisMap = this.state.xAxisMap;\n                    return xAxisMap ? Object.entries(xAxisMap).reduce(function(res, _ref13) {\n                        var _ref14 = _slicedToArray(_ref13, 2), axisId = _ref14[0], axisProps = _ref14[1];\n                        return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, axisId, axisProps.scale));\n                    }, {}) : null;\n                }\n            },\n            {\n                key: \"getYScales\",\n                value: function getYScales() {\n                    var yAxisMap = this.state.yAxisMap;\n                    return yAxisMap ? Object.entries(yAxisMap).reduce(function(res, _ref15) {\n                        var _ref16 = _slicedToArray(_ref15, 2), axisId = _ref16[0], axisProps = _ref16[1];\n                        return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, axisId, axisProps.scale));\n                    }, {}) : null;\n                }\n            },\n            {\n                key: \"getXScaleByAxisId\",\n                value: function getXScaleByAxisId(axisId) {\n                    var _this$state$xAxisMap;\n                    return (_this$state$xAxisMap = this.state.xAxisMap) === null || _this$state$xAxisMap === void 0 || (_this$state$xAxisMap = _this$state$xAxisMap[axisId]) === null || _this$state$xAxisMap === void 0 ? void 0 : _this$state$xAxisMap.scale;\n                }\n            },\n            {\n                key: \"getYScaleByAxisId\",\n                value: function getYScaleByAxisId(axisId) {\n                    var _this$state$yAxisMap;\n                    return (_this$state$yAxisMap = this.state.yAxisMap) === null || _this$state$yAxisMap === void 0 || (_this$state$yAxisMap = _this$state$yAxisMap[axisId]) === null || _this$state$yAxisMap === void 0 ? void 0 : _this$state$yAxisMap.scale;\n                }\n            },\n            {\n                key: \"getItemByXY\",\n                value: function getItemByXY(chartXY) {\n                    var _this$state11 = this.state, formattedGraphicalItems = _this$state11.formattedGraphicalItems, activeItem = _this$state11.activeItem;\n                    if (formattedGraphicalItems && formattedGraphicalItems.length) {\n                        for(var i = 0, len = formattedGraphicalItems.length; i < len; i++){\n                            var graphicalItem = formattedGraphicalItems[i];\n                            // graphicalItem is not a React Element so we don't need to resolve defaultProps\n                            var props = graphicalItem.props, item = graphicalItem.item;\n                            var itemProps = item.type.defaultProps !== undefined ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;\n                            var itemDisplayName = (0, _ReactUtils.getDisplayName)(item.type);\n                            if (itemDisplayName === 'Bar') {\n                                var activeBarItem = (props.data || []).find(function(entry) {\n                                    return (0, _Rectangle.isInRectangle)(chartXY, entry);\n                                });\n                                if (activeBarItem) {\n                                    return {\n                                        graphicalItem: graphicalItem,\n                                        payload: activeBarItem\n                                    };\n                                }\n                            } else if (itemDisplayName === 'RadialBar') {\n                                var _activeBarItem = (props.data || []).find(function(entry) {\n                                    return (0, _PolarUtils.inRangeOfSector)(chartXY, entry);\n                                });\n                                if (_activeBarItem) {\n                                    return {\n                                        graphicalItem: graphicalItem,\n                                        payload: _activeBarItem\n                                    };\n                                }\n                            } else if ((0, _ActiveShapeUtils.isFunnel)(graphicalItem, activeItem) || (0, _ActiveShapeUtils.isPie)(graphicalItem, activeItem) || (0, _ActiveShapeUtils.isScatter)(graphicalItem, activeItem)) {\n                                var activeIndex = (0, _ActiveShapeUtils.getActiveShapeIndexForTooltip)({\n                                    graphicalItem: graphicalItem,\n                                    activeTooltipItem: activeItem,\n                                    itemData: itemProps.data\n                                });\n                                var childIndex = itemProps.activeIndex === undefined ? activeIndex : itemProps.activeIndex;\n                                return {\n                                    graphicalItem: _objectSpread(_objectSpread({}, graphicalItem), {}, {\n                                        childIndex: childIndex\n                                    }),\n                                    payload: (0, _ActiveShapeUtils.isScatter)(graphicalItem, activeItem) ? itemProps.data[activeIndex] : graphicalItem.props.data[activeIndex]\n                                };\n                            }\n                        }\n                    }\n                    return null;\n                }\n            },\n            {\n                key: \"render\",\n                value: function render() {\n                    var _this3 = this;\n                    if (!(0, _ReactUtils.validateWidthHeight)(this)) {\n                        return null;\n                    }\n                    var _this$props6 = this.props, children = _this$props6.children, className = _this$props6.className, width = _this$props6.width, height = _this$props6.height, style = _this$props6.style, compact = _this$props6.compact, title = _this$props6.title, desc = _this$props6.desc, others = _objectWithoutProperties(_this$props6, _excluded2);\n                    var attrs = (0, _ReactUtils.filterProps)(others, false);\n                    // The \"compact\" mode is mainly used as the panorama within Brush\n                    if (compact) {\n                        return /*#__PURE__*/ _react[\"default\"].createElement(_chartLayoutContext.ChartLayoutContextProvider, {\n                            state: this.state,\n                            width: this.props.width,\n                            height: this.props.height,\n                            clipPathId: this.clipPathId\n                        }, /*#__PURE__*/ _react[\"default\"].createElement(_Surface.Surface, _extends({}, attrs, {\n                            width: width,\n                            height: height,\n                            title: title,\n                            desc: desc\n                        }), this.renderClipPath(), (0, _ReactUtils.renderByOrder)(children, this.renderMap)));\n                    }\n                    if (this.props.accessibilityLayer) {\n                        var _this$props$tabIndex, _this$props$role;\n                        // Set tabIndex to 0 by default (can be overwritten)\n                        attrs.tabIndex = (_this$props$tabIndex = this.props.tabIndex) !== null && _this$props$tabIndex !== void 0 ? _this$props$tabIndex : 0;\n                        // Set role to img by default (can be overwritten)\n                        attrs.role = (_this$props$role = this.props.role) !== null && _this$props$role !== void 0 ? _this$props$role : 'application';\n                        attrs.onKeyDown = function(e) {\n                            _this3.accessibilityManager.keyboardEvent(e);\n                        // 'onKeyDown' is not currently a supported prop that can be passed through\n                        // if it's added, this should be added: this.props.onKeyDown(e);\n                        };\n                        attrs.onFocus = function() {\n                            _this3.accessibilityManager.focus();\n                        // 'onFocus' is not currently a supported prop that can be passed through\n                        // if it's added, the focus event should be forwarded to the prop\n                        };\n                    }\n                    var events = this.parseEventsOfWrapper();\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_chartLayoutContext.ChartLayoutContextProvider, {\n                        state: this.state,\n                        width: this.props.width,\n                        height: this.props.height,\n                        clipPathId: this.clipPathId\n                    }, /*#__PURE__*/ _react[\"default\"].createElement(\"div\", _extends({\n                        className: (0, _clsx[\"default\"])('recharts-wrapper', className),\n                        style: _objectSpread({\n                            position: 'relative',\n                            cursor: 'default',\n                            width: width,\n                            height: height\n                        }, style)\n                    }, events, {\n                        ref: function ref(node) {\n                            _this3.container = node;\n                        }\n                    }), /*#__PURE__*/ _react[\"default\"].createElement(_Surface.Surface, _extends({}, attrs, {\n                        width: width,\n                        height: height,\n                        title: title,\n                        desc: desc,\n                        style: FULL_WIDTH_AND_HEIGHT\n                    }), this.renderClipPath(), (0, _ReactUtils.renderByOrder)(children, this.renderMap)), this.renderLegend(), this.renderTooltip()));\n                }\n            }\n        ]);\n    }(_react.Component);\n    _defineProperty(CategoricalChartWrapper, \"displayName\", chartName);\n    // todo join specific chart propTypes\n    _defineProperty(CategoricalChartWrapper, \"defaultProps\", _objectSpread({\n        layout: 'horizontal',\n        stackOffset: 'none',\n        barCategoryGap: '10%',\n        barGap: 4,\n        margin: {\n            top: 5,\n            right: 5,\n            bottom: 5,\n            left: 5\n        },\n        reverseStackOrder: false,\n        syncMethod: 'index'\n    }, defaultProps));\n    _defineProperty(CategoricalChartWrapper, \"getDerivedStateFromProps\", function(nextProps, prevState) {\n        var dataKey = nextProps.dataKey, data = nextProps.data, children = nextProps.children, width = nextProps.width, height = nextProps.height, layout = nextProps.layout, stackOffset = nextProps.stackOffset, margin = nextProps.margin;\n        var dataStartIndex = prevState.dataStartIndex, dataEndIndex = prevState.dataEndIndex;\n        if (prevState.updateId === undefined) {\n            var defaultState = createDefaultState(nextProps);\n            return _objectSpread(_objectSpread(_objectSpread({}, defaultState), {}, {\n                updateId: 0\n            }, updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread(_objectSpread({\n                props: nextProps\n            }, defaultState), {}, {\n                updateId: 0\n            }), prevState)), {}, {\n                prevDataKey: dataKey,\n                prevData: data,\n                prevWidth: width,\n                prevHeight: height,\n                prevLayout: layout,\n                prevStackOffset: stackOffset,\n                prevMargin: margin,\n                prevChildren: children\n            });\n        }\n        if (dataKey !== prevState.prevDataKey || data !== prevState.prevData || width !== prevState.prevWidth || height !== prevState.prevHeight || layout !== prevState.prevLayout || stackOffset !== prevState.prevStackOffset || !(0, _ShallowEqual.shallowEqual)(margin, prevState.prevMargin)) {\n            var _defaultState = createDefaultState(nextProps);\n            // Fixes https://github.com/recharts/recharts/issues/2143\n            var keepFromPrevState = {\n                // (chartX, chartY) are (0,0) in default state, but we want to keep the last mouse position to avoid\n                // any flickering\n                chartX: prevState.chartX,\n                chartY: prevState.chartY,\n                // The tooltip should stay active when it was active in the previous render. If this is not\n                // the case, the tooltip disappears and immediately re-appears, causing a flickering effect\n                isTooltipActive: prevState.isTooltipActive\n            };\n            var updatesToState = _objectSpread(_objectSpread({}, getTooltipData(prevState, data, layout)), {}, {\n                updateId: prevState.updateId + 1\n            });\n            var newState = _objectSpread(_objectSpread(_objectSpread({}, _defaultState), keepFromPrevState), updatesToState);\n            return _objectSpread(_objectSpread(_objectSpread({}, newState), updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread({\n                props: nextProps\n            }, newState), prevState)), {}, {\n                prevDataKey: dataKey,\n                prevData: data,\n                prevWidth: width,\n                prevHeight: height,\n                prevLayout: layout,\n                prevStackOffset: stackOffset,\n                prevMargin: margin,\n                prevChildren: children\n            });\n        }\n        if (!(0, _ReactUtils.isChildrenEqual)(children, prevState.prevChildren)) {\n            var _brush$props$startInd, _brush$props, _brush$props$endIndex, _brush$props2;\n            // specifically check for Brush - if it exists and the start and end indexes are different, re-render with the new ones\n            var brush = (0, _ReactUtils.findChildByType)(children, _Brush.Brush);\n            var startIndex = brush ? (_brush$props$startInd = (_brush$props = brush.props) === null || _brush$props === void 0 ? void 0 : _brush$props.startIndex) !== null && _brush$props$startInd !== void 0 ? _brush$props$startInd : dataStartIndex : dataStartIndex;\n            var endIndex = brush ? (_brush$props$endIndex = (_brush$props2 = brush.props) === null || _brush$props2 === void 0 ? void 0 : _brush$props2.endIndex) !== null && _brush$props$endIndex !== void 0 ? _brush$props$endIndex : dataEndIndex : dataEndIndex;\n            var hasDifferentStartOrEndIndex = startIndex !== dataStartIndex || endIndex !== dataEndIndex;\n            // update configuration in children\n            var hasGlobalData = !(0, _isNil[\"default\"])(data);\n            var newUpdateId = hasGlobalData && !hasDifferentStartOrEndIndex ? prevState.updateId : prevState.updateId + 1;\n            return _objectSpread(_objectSpread({\n                updateId: newUpdateId\n            }, updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread(_objectSpread({\n                props: nextProps\n            }, prevState), {}, {\n                updateId: newUpdateId,\n                dataStartIndex: startIndex,\n                dataEndIndex: endIndex\n            }), prevState)), {}, {\n                prevChildren: children,\n                dataStartIndex: startIndex,\n                dataEndIndex: endIndex\n            });\n        }\n        return null;\n    });\n    _defineProperty(CategoricalChartWrapper, \"renderActiveDot\", function(option, props, key) {\n        var dot;\n        if (/*#__PURE__*/ (0, _react.isValidElement)(option)) {\n            dot = /*#__PURE__*/ (0, _react.cloneElement)(option, props);\n        } else if ((0, _isFunction[\"default\"])(option)) {\n            dot = option(props);\n        } else {\n            dot = /*#__PURE__*/ _react[\"default\"].createElement(_Dot.Dot, props);\n        }\n        return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n            className: \"recharts-active-dot\",\n            key: key\n        }, dot);\n    });\n    var CategoricalChart = /*#__PURE__*/ (0, _react.forwardRef)(function CategoricalChart(props, ref) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(CategoricalChartWrapper, _extends({}, props, {\n            ref: ref\n        }));\n    });\n    CategoricalChart.displayName = CategoricalChartWrapper.displayName;\n    return CategoricalChart;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCx3QkFBd0IsR0FBR0EsZ0NBQWdDLEdBQUdBLDBCQUEwQixHQUFHLEtBQUs7QUFDaEcsSUFBSUssU0FBU0Msd0JBQXdCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNwRCxJQUFJQyxTQUFTQyx1QkFBdUJGLG1CQUFPQSxDQUFDLGtDQUFjO0FBQzFELElBQUlHLGNBQWNELHVCQUF1QkYsbUJBQU9BLENBQUMsNENBQW1CO0FBQ3BFLElBQUlJLFNBQVNGLHVCQUF1QkYsbUJBQU9BLENBQUMsa0NBQWM7QUFDMUQsSUFBSUssT0FBT0gsdUJBQXVCRixtQkFBT0EsQ0FBQyw4QkFBWTtBQUN0RCxJQUFJTSxVQUFVSix1QkFBdUJGLG1CQUFPQSxDQUFDLG9DQUFlO0FBQzVELElBQUlPLFlBQVlMLHVCQUF1QkYsbUJBQU9BLENBQUMsd0NBQWlCO0FBQ2hFLElBQUlRLFFBQVFOLHVCQUF1QkYsbUJBQU9BLENBQUMsdUJBQU07QUFDakQsSUFBSVMsaUJBQWlCUCx1QkFBdUJGLG1CQUFPQSxDQUFDLHNDQUFnQjtBQUNwRSxJQUFJVSxXQUFXVixtQkFBT0EsQ0FBQywrRkFBc0I7QUFDN0MsSUFBSVcsU0FBU1gsbUJBQU9BLENBQUMsMkZBQW9CO0FBQ3pDLElBQUlZLFdBQVdaLG1CQUFPQSxDQUFDLCtGQUFzQjtBQUM3QyxJQUFJYSxVQUFVYixtQkFBT0EsQ0FBQyw2RkFBcUI7QUFDM0MsSUFBSWMsT0FBT2QsbUJBQU9BLENBQUMsK0VBQWM7QUFDakMsSUFBSWUsYUFBYWYsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzdDLElBQUlnQixjQUFjaEIsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlpQixTQUFTakIsbUJBQU9BLENBQUMs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QU9xVztBQUNUIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxjaGFydFxcZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZ2V0QXhpc01hcEJ5QXhlcyA9IGV4cG9ydHMuZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0ID0gZXhwb3J0cy5jcmVhdGVEZWZhdWx0U3RhdGUgPSB2b2lkIDA7XHJcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgX2lzTmlsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzTmlsXCIpKTtcclxudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xyXG52YXIgX3JhbmdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL3JhbmdlXCIpKTtcclxudmFyIF9nZXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZ2V0XCIpKTtcclxudmFyIF9zb3J0QnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvc29ydEJ5XCIpKTtcclxudmFyIF90aHJvdHRsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC90aHJvdHRsZVwiKSk7XHJcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xyXG52YXIgX3RpbnlJbnZhcmlhbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJ0aW55LWludmFyaWFudFwiKSk7XHJcbnZhciBfU3VyZmFjZSA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvU3VyZmFjZVwiKTtcclxudmFyIF9MYXllciA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvTGF5ZXJcIik7XHJcbnZhciBfVG9vbHRpcCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQvVG9vbHRpcFwiKTtcclxudmFyIF9MZWdlbmQgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50L0xlZ2VuZFwiKTtcclxudmFyIF9Eb3QgPSByZXF1aXJlKFwiLi4vc2hhcGUvRG90XCIpO1xyXG52YXIgX1JlY3RhbmdsZSA9IHJlcXVpcmUoXCIuLi9zaGFwZS9SZWN0YW5nbGVcIik7XHJcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XHJcbnZhciBfQnJ1c2ggPSByZXF1aXJlKFwiLi4vY2FydGVzaWFuL0JydXNoXCIpO1xyXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRE9NVXRpbHNcIik7XHJcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRGF0YVV0aWxzXCIpO1xyXG52YXIgX0NoYXJ0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9DaGFydFV0aWxzXCIpO1xyXG52YXIgX0RldGVjdFJlZmVyZW5jZUVsZW1lbnRzRG9tYWluID0gcmVxdWlyZShcIi4uL3V0aWwvRGV0ZWN0UmVmZXJlbmNlRWxlbWVudHNEb21haW5cIik7XHJcbnZhciBfUG9sYXJVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1BvbGFyVXRpbHNcIik7XHJcbnZhciBfU2hhbGxvd0VxdWFsID0gcmVxdWlyZShcIi4uL3V0aWwvU2hhbGxvd0VxdWFsXCIpO1xyXG52YXIgX0V2ZW50cyA9IHJlcXVpcmUoXCIuLi91dGlsL0V2ZW50c1wiKTtcclxudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuLi91dGlsL3R5cGVzXCIpO1xyXG52YXIgX0FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gcmVxdWlyZShcIi4vQWNjZXNzaWJpbGl0eU1hbmFnZXJcIik7XHJcbnZhciBfaXNEb21haW5TcGVjaWZpZWRCeVVzZXIgPSByZXF1aXJlKFwiLi4vdXRpbC9pc0RvbWFpblNwZWNpZmllZEJ5VXNlclwiKTtcclxudmFyIF9BY3RpdmVTaGFwZVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvQWN0aXZlU2hhcGVVdGlsc1wiKTtcclxudmFyIF9DdXJzb3IgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50L0N1cnNvclwiKTtcclxudmFyIF9jaGFydExheW91dENvbnRleHQgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jaGFydExheW91dENvbnRleHRcIik7XHJcbnZhciBfZXhjbHVkZWQgPSBbXCJpdGVtXCJdLFxyXG4gIF9leGNsdWRlZDIgPSBbXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwic3R5bGVcIiwgXCJjb21wYWN0XCIsIFwidGl0bGVcIiwgXCJkZXNjXCJdO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cclxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cclxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxyXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cclxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cclxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cclxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cclxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XHJcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxyXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cclxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cclxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cclxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cclxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XHJcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cclxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XHJcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxyXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XHJcbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XHJcbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cclxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtaW1wb3J0c1xyXG52YXIgT1JJRU5UX01BUCA9IHtcclxuICB4QXhpczogWydib3R0b20nLCAndG9wJ10sXHJcbiAgeUF4aXM6IFsnbGVmdCcsICdyaWdodCddXHJcbn07XHJcbnZhciBGVUxMX1dJRFRIX0FORF9IRUlHSFQgPSB7XHJcbiAgd2lkdGg6ICcxMDAlJyxcclxuICBoZWlnaHQ6ICcxMDAlJ1xyXG59O1xyXG52YXIgb3JpZ2luQ29vcmRpbmF0ZSA9IHtcclxuICB4OiAwLFxyXG4gIHk6IDBcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGV4aXN0cyBhcyBhIHRlbXBvcmFyeSB3b3JrYXJvdW5kLlxyXG4gKlxyXG4gKiBXaHk/IGdlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCBkb2VzIG5vdCByZW5kZXIgYHtjaGlsZHJlbn1gIGRpcmVjdGx5O1xyXG4gKiBpbnN0ZWFkIGl0IHBhc3NlcyB0aGVtIHRocm91Z2ggYHJlbmRlckJ5T3JkZXJgIGZ1bmN0aW9uIHdoaWNoIHJlYWRzIHRoZWlyIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBTbywgdGhpcyBpcyBhIGhhbmRsZXIgdGhhdCBkb2VzIG5vdGhpbmcuXHJcbiAqIE9uY2Ugd2UgZ2V0IHJpZCBvZiBgcmVuZGVyQnlPcmRlcmAgYW5kIHN3aXRjaCB0byBKU1ggb25seSwgd2UgY2FuIGdldCByaWQgb2YgdGhpcyBoYW5kbGVyIHRvby5cclxuICpcclxuICogQHBhcmFtIHtKU1h9IGVsZW1lbnQgYXMgaXMgaW4gSlNYXHJcbiAqIEByZXR1cm5zIHtKU1h9IHRoZSBzYW1lIGVsZW1lbnRcclxuICovXHJcbmZ1bmN0aW9uIHJlbmRlckFzSXMoZWxlbWVudCkge1xyXG4gIHJldHVybiBlbGVtZW50O1xyXG59XHJcbnZhciBjYWxjdWxhdGVUb29sdGlwUG9zID0gZnVuY3Rpb24gY2FsY3VsYXRlVG9vbHRpcFBvcyhyYW5nZU9iaiwgbGF5b3V0KSB7XHJcbiAgaWYgKGxheW91dCA9PT0gJ2hvcml6b250YWwnKSB7XHJcbiAgICByZXR1cm4gcmFuZ2VPYmoueDtcclxuICB9XHJcbiAgaWYgKGxheW91dCA9PT0gJ3ZlcnRpY2FsJykge1xyXG4gICAgcmV0dXJuIHJhbmdlT2JqLnk7XHJcbiAgfVxyXG4gIGlmIChsYXlvdXQgPT09ICdjZW50cmljJykge1xyXG4gICAgcmV0dXJuIHJhbmdlT2JqLmFuZ2xlO1xyXG4gIH1cclxuICByZXR1cm4gcmFuZ2VPYmoucmFkaXVzO1xyXG59O1xyXG52YXIgZ2V0QWN0aXZlQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldEFjdGl2ZUNvb3JkaW5hdGUobGF5b3V0LCB0b29sdGlwVGlja3MsIGFjdGl2ZUluZGV4LCByYW5nZU9iaikge1xyXG4gIHZhciBlbnRyeSA9IHRvb2x0aXBUaWNrcy5maW5kKGZ1bmN0aW9uICh0aWNrKSB7XHJcbiAgICByZXR1cm4gdGljayAmJiB0aWNrLmluZGV4ID09PSBhY3RpdmVJbmRleDtcclxuICB9KTtcclxuICBpZiAoZW50cnkpIHtcclxuICAgIGlmIChsYXlvdXQgPT09ICdob3Jpem9udGFsJykge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IGVudHJ5LmNvb3JkaW5hdGUsXHJcbiAgICAgICAgeTogcmFuZ2VPYmoueVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKGxheW91dCA9PT0gJ3ZlcnRpY2FsJykge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHJhbmdlT2JqLngsXHJcbiAgICAgICAgeTogZW50cnkuY29vcmRpbmF0ZVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKGxheW91dCA9PT0gJ2NlbnRyaWMnKSB7XHJcbiAgICAgIHZhciBfYW5nbGUgPSBlbnRyeS5jb29yZGluYXRlO1xyXG4gICAgICB2YXIgX3JhZGl1cyA9IHJhbmdlT2JqLnJhZGl1cztcclxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByYW5nZU9iaiksICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShyYW5nZU9iai5jeCwgcmFuZ2VPYmouY3ksIF9yYWRpdXMsIF9hbmdsZSkpLCB7fSwge1xyXG4gICAgICAgIGFuZ2xlOiBfYW5nbGUsXHJcbiAgICAgICAgcmFkaXVzOiBfcmFkaXVzXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdmFyIHJhZGl1cyA9IGVudHJ5LmNvb3JkaW5hdGU7XHJcbiAgICB2YXIgYW5nbGUgPSByYW5nZU9iai5hbmdsZTtcclxuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmFuZ2VPYmopLCAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikocmFuZ2VPYmouY3gsIHJhbmdlT2JqLmN5LCByYWRpdXMsIGFuZ2xlKSksIHt9LCB7XHJcbiAgICAgIGFuZ2xlOiBhbmdsZSxcclxuICAgICAgcmFkaXVzOiByYWRpdXNcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gb3JpZ2luQ29vcmRpbmF0ZTtcclxufTtcclxudmFyIGdldERpc3BsYXllZERhdGEgPSBmdW5jdGlvbiBnZXREaXNwbGF5ZWREYXRhKGRhdGEsIF9yZWYpIHtcclxuICB2YXIgZ3JhcGhpY2FsSXRlbXMgPSBfcmVmLmdyYXBoaWNhbEl0ZW1zLFxyXG4gICAgZGF0YVN0YXJ0SW5kZXggPSBfcmVmLmRhdGFTdGFydEluZGV4LFxyXG4gICAgZGF0YUVuZEluZGV4ID0gX3JlZi5kYXRhRW5kSW5kZXg7XHJcbiAgdmFyIGl0ZW1zRGF0YSA9IChncmFwaGljYWxJdGVtcyAhPT0gbnVsbCAmJiBncmFwaGljYWxJdGVtcyAhPT0gdm9pZCAwID8gZ3JhcGhpY2FsSXRlbXMgOiBbXSkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGNoaWxkKSB7XHJcbiAgICB2YXIgaXRlbURhdGEgPSBjaGlsZC5wcm9wcy5kYXRhO1xyXG4gICAgaWYgKGl0ZW1EYXRhICYmIGl0ZW1EYXRhLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZXN1bHQpLCBfdG9Db25zdW1hYmxlQXJyYXkoaXRlbURhdGEpKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSwgW10pO1xyXG4gIGlmIChpdGVtc0RhdGEubGVuZ3RoID4gMCkge1xyXG4gICAgcmV0dXJuIGl0ZW1zRGF0YTtcclxuICB9XHJcbiAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGggJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGRhdGFTdGFydEluZGV4KSAmJiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikoZGF0YUVuZEluZGV4KSkge1xyXG4gICAgcmV0dXJuIGRhdGEuc2xpY2UoZGF0YVN0YXJ0SW5kZXgsIGRhdGFFbmRJbmRleCArIDEpO1xyXG4gIH1cclxuICByZXR1cm4gW107XHJcbn07XHJcbmZ1bmN0aW9uIGdldERlZmF1bHREb21haW5CeUF4aXNUeXBlKGF4aXNUeXBlKSB7XHJcbiAgcmV0dXJuIGF4aXNUeXBlID09PSAnbnVtYmVyJyA/IFswLCAnYXV0byddIDogdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBjb250ZW50IHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgdG9vbHRpcFxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IHN0YXRlICAgICAgICAgIEN1cnJlbnQgc3RhdGVcclxuICogQHBhcmFtICB7QXJyYXl9ICBjaGFydERhdGEgICAgICBUaGUgZGF0YSBkZWZpbmVkIGluIGNoYXJ0XHJcbiAqIEBwYXJhbSAge051bWJlcn0gYWN0aXZlSW5kZXggICAgQWN0aXZlIGluZGV4IG9mIGRhdGFcclxuICogQHBhcmFtICB7U3RyaW5nfSBhY3RpdmVMYWJlbCAgICBBY3RpdmUgbGFiZWwgb2YgZGF0YVxyXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgICAgIFRoZSBjb250ZW50IG9mIHRvb2x0aXBcclxuICovXHJcbnZhciBnZXRUb29sdGlwQ29udGVudCA9IGZ1bmN0aW9uIGdldFRvb2x0aXBDb250ZW50KHN0YXRlLCBjaGFydERhdGEsIGFjdGl2ZUluZGV4LCBhY3RpdmVMYWJlbCkge1xyXG4gIHZhciBncmFwaGljYWxJdGVtcyA9IHN0YXRlLmdyYXBoaWNhbEl0ZW1zLFxyXG4gICAgdG9vbHRpcEF4aXMgPSBzdGF0ZS50b29sdGlwQXhpcztcclxuICB2YXIgZGlzcGxheWVkRGF0YSA9IGdldERpc3BsYXllZERhdGEoY2hhcnREYXRhLCBzdGF0ZSk7XHJcbiAgaWYgKGFjdGl2ZUluZGV4IDwgMCB8fCAhZ3JhcGhpY2FsSXRlbXMgfHwgIWdyYXBoaWNhbEl0ZW1zLmxlbmd0aCB8fCBhY3RpdmVJbmRleCA+PSBkaXNwbGF5ZWREYXRhLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIC8vIGdldCBkYXRhIGJ5IGFjdGl2ZUluZGV4IHdoZW4gdGhlIGF4aXMgZG9uJ3QgYWxsb3cgZHVwbGljYXRlZCBjYXRlZ29yeVxyXG4gIHJldHVybiBncmFwaGljYWxJdGVtcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgY2hpbGQpIHtcclxuICAgIHZhciBfY2hpbGQkcHJvcHMkZGF0YTtcclxuICAgIC8qKlxyXG4gICAgICogRml4ZXM6IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWNoYXJ0cy9yZWNoYXJ0cy9pc3N1ZXMvMzY2OVxyXG4gICAgICogRGVmYXVsdGluZyB0byBjaGFydERhdGEgYmVsb3cgdG8gZml4IGFuIGVkZ2UgY2FzZSB3aGVyZSB0aGUgdG9vbHRpcCBkb2VzIG5vdCBpbmNsdWRlIGRhdGEgZnJvbSBhbGwgY2hhcnRzXHJcbiAgICAgKiB3aGVuIGEgc2VwYXJhdGUgZGF0YXNldCBpcyBwYXNzZWQgdG8gY2hhcnQgcHJvcCBkYXRhIGFuZCBzcGVjaWZpZWQgb24gTGluZS9BcmVhL2V0YyBwcm9wIGRhdGFcclxuICAgICAqL1xyXG4gICAgdmFyIGRhdGEgPSAoX2NoaWxkJHByb3BzJGRhdGEgPSBjaGlsZC5wcm9wcy5kYXRhKSAhPT0gbnVsbCAmJiBfY2hpbGQkcHJvcHMkZGF0YSAhPT0gdm9pZCAwID8gX2NoaWxkJHByb3BzJGRhdGEgOiBjaGFydERhdGE7XHJcbiAgICBpZiAoZGF0YSAmJiBzdGF0ZS5kYXRhU3RhcnRJbmRleCArIHN0YXRlLmRhdGFFbmRJbmRleCAhPT0gMCAmJlxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlY2hhcnRzL3JlY2hhcnRzL2lzc3Vlcy80NzE3XHJcbiAgICAvLyBUaGUgZGF0YSBpcyBzbGljZWQgb25seSB3aGVuIHRoZSBhY3RpdmUgaW5kZXggaXMgd2l0aGluIHRoZSBzdGFydC9lbmQgaW5kZXggcmFuZ2UuXHJcbiAgICBzdGF0ZS5kYXRhRW5kSW5kZXggLSBzdGF0ZS5kYXRhU3RhcnRJbmRleCA+PSBhY3RpdmVJbmRleCkge1xyXG4gICAgICBkYXRhID0gZGF0YS5zbGljZShzdGF0ZS5kYXRhU3RhcnRJbmRleCwgc3RhdGUuZGF0YUVuZEluZGV4ICsgMSk7XHJcbiAgICB9XHJcbiAgICB2YXIgcGF5bG9hZDtcclxuICAgIGlmICh0b29sdGlwQXhpcy5kYXRhS2V5ICYmICF0b29sdGlwQXhpcy5hbGxvd0R1cGxpY2F0ZWRDYXRlZ29yeSkge1xyXG4gICAgICAvLyBncmFwaGljIGNoaWxkIGhhcyBkYXRhIHByb3BzXHJcbiAgICAgIHZhciBlbnRyaWVzID0gZGF0YSA9PT0gdW5kZWZpbmVkID8gZGlzcGxheWVkRGF0YSA6IGRhdGE7XHJcbiAgICAgIHBheWxvYWQgPSAoMCwgX0RhdGFVdGlscy5maW5kRW50cnlJbkFycmF5KShlbnRyaWVzLCB0b29sdGlwQXhpcy5kYXRhS2V5LCBhY3RpdmVMYWJlbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwYXlsb2FkID0gZGF0YSAmJiBkYXRhW2FjdGl2ZUluZGV4XSB8fCBkaXNwbGF5ZWREYXRhW2FjdGl2ZUluZGV4XTtcclxuICAgIH1cclxuICAgIGlmICghcGF5bG9hZCkge1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocmVzdWx0KSwgWygwLCBfQ2hhcnRVdGlscy5nZXRUb29sdGlwSXRlbSkoY2hpbGQsIHBheWxvYWQpXSk7XHJcbiAgfSwgW10pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdG9vbHRpcCBkYXRhIGJhc2VkIG9uIGEgbW91c2UgcG9zaXRpb24gKGFzIGEgcGFyYW1ldGVyIG9yIGluIHN0YXRlKVxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IHN0YXRlICAgICBjdXJyZW50IHN0YXRlXHJcbiAqIEBwYXJhbSAge0FycmF5fSAgY2hhcnREYXRhIHRoZSBkYXRhIGRlZmluZWQgaW4gY2hhcnRcclxuICogQHBhcmFtICB7U3RyaW5nfSBsYXlvdXQgICAgIFRoZSBsYXlvdXQgdHlwZSBvZiBjaGFydFxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IHJhbmdlT2JqICB7IHgsIHkgfSBjb29yZGluYXRlc1xyXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICBUb29sdGlwIGRhdGEgZGF0YVxyXG4gKi9cclxudmFyIGdldFRvb2x0aXBEYXRhID0gZnVuY3Rpb24gZ2V0VG9vbHRpcERhdGEoc3RhdGUsIGNoYXJ0RGF0YSwgbGF5b3V0LCByYW5nZU9iaikge1xyXG4gIHZhciByYW5nZURhdGEgPSByYW5nZU9iaiB8fCB7XHJcbiAgICB4OiBzdGF0ZS5jaGFydFgsXHJcbiAgICB5OiBzdGF0ZS5jaGFydFlcclxuICB9O1xyXG4gIHZhciBwb3MgPSBjYWxjdWxhdGVUb29sdGlwUG9zKHJhbmdlRGF0YSwgbGF5b3V0KTtcclxuICB2YXIgdGlja3MgPSBzdGF0ZS5vcmRlcmVkVG9vbHRpcFRpY2tzLFxyXG4gICAgYXhpcyA9IHN0YXRlLnRvb2x0aXBBeGlzLFxyXG4gICAgdG9vbHRpcFRpY2tzID0gc3RhdGUudG9vbHRpcFRpY2tzO1xyXG4gIHZhciBhY3RpdmVJbmRleCA9ICgwLCBfQ2hhcnRVdGlscy5jYWxjdWxhdGVBY3RpdmVUaWNrSW5kZXgpKHBvcywgdGlja3MsIHRvb2x0aXBUaWNrcywgYXhpcyk7XHJcbiAgaWYgKGFjdGl2ZUluZGV4ID49IDAgJiYgdG9vbHRpcFRpY2tzKSB7XHJcbiAgICB2YXIgYWN0aXZlTGFiZWwgPSB0b29sdGlwVGlja3NbYWN0aXZlSW5kZXhdICYmIHRvb2x0aXBUaWNrc1thY3RpdmVJbmRleF0udmFsdWU7XHJcbiAgICB2YXIgYWN0aXZlUGF5bG9hZCA9IGdldFRvb2x0aXBDb250ZW50KHN0YXRlLCBjaGFydERhdGEsIGFjdGl2ZUluZGV4LCBhY3RpdmVMYWJlbCk7XHJcbiAgICB2YXIgYWN0aXZlQ29vcmRpbmF0ZSA9IGdldEFjdGl2ZUNvb3JkaW5hdGUobGF5b3V0LCB0aWNrcywgYWN0aXZlSW5kZXgsIHJhbmdlRGF0YSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBhY3RpdmVUb29sdGlwSW5kZXg6IGFjdGl2ZUluZGV4LFxyXG4gICAgICBhY3RpdmVMYWJlbDogYWN0aXZlTGFiZWwsXHJcbiAgICAgIGFjdGl2ZVBheWxvYWQ6IGFjdGl2ZVBheWxvYWQsXHJcbiAgICAgIGFjdGl2ZUNvb3JkaW5hdGU6IGFjdGl2ZUNvb3JkaW5hdGVcclxuICAgIH07XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgY29uZmlndXJhdGlvbiBvZiBheGlzIGJ5IHRoZSBvcHRpb25zIG9mIGF4aXMgaW5zdGFuY2VcclxuICogQHBhcmFtICB7T2JqZWN0fSBwcm9wcyAgICAgICAgIExhdGVzdCBwcm9wc1xyXG4gKiBAcGFyYW0ge0FycmF5fSAgYXhlcyAgICAgICAgICAgVGhlIGluc3RhbmNlIG9mIGF4ZXNcclxuICogQHBhcmFtICB7QXJyYXl9IGdyYXBoaWNhbEl0ZW1zIFRoZSBpbnN0YW5jZXMgb2YgaXRlbVxyXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGF4aXNUeXBlICAgICAgVGhlIHR5cGUgb2YgYXhpcywgeEF4aXMgLSB4LWF4aXMsIHlBeGlzIC0geS1heGlzXHJcbiAqIEBwYXJhbSAge1N0cmluZ30gYXhpc0lkS2V5ICAgICBUaGUgdW5pcXVlIGlkIG9mIGFuIGF4aXNcclxuICogQHBhcmFtICB7T2JqZWN0fSBzdGFja0dyb3VwcyAgIFRoZSBpdGVtcyBncm91cGVkIGJ5IGF4aXNJZCBhbmQgc3RhY2tJZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gZGF0YVN0YXJ0SW5kZXggVGhlIHN0YXJ0IGluZGV4IG9mIHRoZSBkYXRhIHNlcmllcyB3aGVuIGEgYnJ1c2ggaXMgYXBwbGllZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gZGF0YUVuZEluZGV4ICAgVGhlIGVuZCBpbmRleCBvZiB0aGUgZGF0YSBzZXJpZXMgd2hlbiBhIGJydXNoIGlzIGFwcGxpZWRcclxuICogQHJldHVybiB7T2JqZWN0fSAgICAgIENvbmZpZ3VyYXRpb25cclxuICovXHJcbnZhciBnZXRBeGlzTWFwQnlBeGVzID0gZXhwb3J0cy5nZXRBeGlzTWFwQnlBeGVzID0gZnVuY3Rpb24gZ2V0QXhpc01hcEJ5QXhlcyhwcm9wcywgX3JlZjIpIHtcclxuICB2YXIgYXhlcyA9IF9yZWYyLmF4ZXMsXHJcbiAgICBncmFwaGljYWxJdGVtcyA9IF9yZWYyLmdyYXBoaWNhbEl0ZW1zLFxyXG4gICAgYXhpc1R5cGUgPSBfcmVmMi5heGlzVHlwZSxcclxuICAgIGF4aXNJZEtleSA9IF9yZWYyLmF4aXNJZEtleSxcclxuICAgIHN0YWNrR3JvdXBzID0gX3JlZjIuc3RhY2tHcm91cHMsXHJcbiAgICBkYXRhU3RhcnRJbmRleCA9IF9yZWYyLmRhdGFTdGFydEluZGV4LFxyXG4gICAgZGF0YUVuZEluZGV4ID0gX3JlZjIuZGF0YUVuZEluZGV4O1xyXG4gIHZhciBsYXlvdXQgPSBwcm9wcy5sYXlvdXQsXHJcbiAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxyXG4gICAgc3RhY2tPZmZzZXQgPSBwcm9wcy5zdGFja09mZnNldDtcclxuICB2YXIgaXNDYXRlZ29yaWNhbCA9ICgwLCBfQ2hhcnRVdGlscy5pc0NhdGVnb3JpY2FsQXhpcykobGF5b3V0LCBheGlzVHlwZSk7XHJcblxyXG4gIC8vIEVsaW1pbmF0ZSBkdXBsaWNhdGVkIGF4ZXNcclxuICByZXR1cm4gYXhlcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgY2hpbGQpIHtcclxuICAgIHZhciBfY2hpbGRQcm9wcyRkb21haW4yO1xyXG4gICAgdmFyIGNoaWxkUHJvcHMgPSBjaGlsZC50eXBlLmRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjaGlsZC50eXBlLmRlZmF1bHRQcm9wcyksIGNoaWxkLnByb3BzKSA6IGNoaWxkLnByb3BzO1xyXG4gICAgdmFyIHR5cGUgPSBjaGlsZFByb3BzLnR5cGUsXHJcbiAgICAgIGRhdGFLZXkgPSBjaGlsZFByb3BzLmRhdGFLZXksXHJcbiAgICAgIGFsbG93RGF0YU92ZXJmbG93ID0gY2hpbGRQcm9wcy5hbGxvd0RhdGFPdmVyZmxvdyxcclxuICAgICAgYWxsb3dEdXBsaWNhdGVkQ2F0ZWdvcnkgPSBjaGlsZFByb3BzLmFsbG93RHVwbGljYXRlZENhdGVnb3J5LFxyXG4gICAgICBzY2FsZSA9IGNoaWxkUHJvcHMuc2NhbGUsXHJcbiAgICAgIHRpY2tzID0gY2hpbGRQcm9wcy50aWNrcyxcclxuICAgICAgaW5jbHVkZUhpZGRlbiA9IGNoaWxkUHJvcHMuaW5jbHVkZUhpZGRlbjtcclxuICAgIHZhciBheGlzSWQgPSBjaGlsZFByb3BzW2F4aXNJZEtleV07XHJcbiAgICBpZiAocmVzdWx0W2F4aXNJZF0pIHtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHZhciBkaXNwbGF5ZWREYXRhID0gZ2V0RGlzcGxheWVkRGF0YShwcm9wcy5kYXRhLCB7XHJcbiAgICAgIGdyYXBoaWNhbEl0ZW1zOiBncmFwaGljYWxJdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB2YXIgX2RlZmF1bHRQcm9wcztcclxuICAgICAgICB2YXIgaXRlbUF4aXNJZCA9IGF4aXNJZEtleSBpbiBpdGVtLnByb3BzID8gaXRlbS5wcm9wc1theGlzSWRLZXldIDogKF9kZWZhdWx0UHJvcHMgPSBpdGVtLnR5cGUuZGVmYXVsdFByb3BzKSA9PT0gbnVsbCB8fCBfZGVmYXVsdFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGVmYXVsdFByb3BzW2F4aXNJZEtleV07XHJcbiAgICAgICAgcmV0dXJuIGl0ZW1BeGlzSWQgPT09IGF4aXNJZDtcclxuICAgICAgfSksXHJcbiAgICAgIGRhdGFTdGFydEluZGV4OiBkYXRhU3RhcnRJbmRleCxcclxuICAgICAgZGF0YUVuZEluZGV4OiBkYXRhRW5kSW5kZXhcclxuICAgIH0pO1xyXG4gICAgdmFyIGxlbiA9IGRpc3BsYXllZERhdGEubGVuZ3RoO1xyXG4gICAgdmFyIGRvbWFpbiwgZHVwbGljYXRlRG9tYWluLCBjYXRlZ29yaWNhbERvbWFpbjtcclxuXHJcbiAgICAvKlxyXG4gICAgICogVGhpcyBpcyBhIGhhY2sgdG8gc2hvcnQtY2lyY3VpdCB0aGUgZG9tYWluIGNyZWF0aW9uIGhlcmUgdG8gZW5oYW5jZSBwZXJmb3JtYW5jZS5cclxuICAgICAqIFVzdWFsbHksIHRoZSBkYXRhIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBkb21haW4sIGJ1dCB3aGVuIHRoZSB1c2VyIHNwZWNpZmllc1xyXG4gICAgICogYSBkb21haW4gdXBmcm9udCAodmlhIHByb3BzKSwgdGhlcmUgaXMgbm8gbmVlZCB0byBjYWxjdWxhdGUgdGhlIGRvbWFpbiBzdGFydCBhbmQgZW5kLFxyXG4gICAgICogd2hpY2ggaXMgdmVyeSBleHBlbnNpdmUgZm9yIGEgbGFyZ2VyIGFtb3VudCBvZiBkYXRhLlxyXG4gICAgICogVGhlIG9ubHkgdGhpbmcgdGhhdCB3b3VsZCBwcm9oaWJpdCBzaG9ydC1jaXJjdWl0aW5nIGlzIHdoZW4gdGhlIHVzZXIgZG9lc24ndCBhbGxvdyBkYXRhIG92ZXJmbG93LFxyXG4gICAgICogYmVjYXVzZSB0aGUgYXhpcyBpcyBzdXBwb3NlZCB0byBpZ25vcmUgdGhlIHNwZWNpZmllZCBkb21haW4gdGhhdCB3YXkuXHJcbiAgICAgKi9cclxuICAgIGlmICgoMCwgX2lzRG9tYWluU3BlY2lmaWVkQnlVc2VyLmlzRG9tYWluU3BlY2lmaWVkQnlVc2VyKShjaGlsZFByb3BzLmRvbWFpbiwgYWxsb3dEYXRhT3ZlcmZsb3csIHR5cGUpKSB7XHJcbiAgICAgIGRvbWFpbiA9ICgwLCBfQ2hhcnRVdGlscy5wYXJzZVNwZWNpZmllZERvbWFpbikoY2hpbGRQcm9wcy5kb21haW4sIG51bGwsIGFsbG93RGF0YU92ZXJmbG93KTtcclxuICAgICAgLyogVGhlIGNoYXJ0IGNhbiBiZSBjYXRlZ29yaWNhbCBhbmQgaGF2ZSB0aGUgZG9tYWluIHNwZWNpZmllZCBpbiBudW1iZXJzXHJcbiAgICAgICAqIHdlIHN0aWxsIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBjYXRlZ29yaWNhbCBkb21haW5cclxuICAgICAgICogVE9ETzogcmVmYWN0b3IgdGhpcyBtb3JlXHJcbiAgICAgICAqL1xyXG4gICAgICBpZiAoaXNDYXRlZ29yaWNhbCAmJiAodHlwZSA9PT0gJ251bWJlcicgfHwgc2NhbGUgIT09ICdhdXRvJykpIHtcclxuICAgICAgICBjYXRlZ29yaWNhbERvbWFpbiA9ICgwLCBfQ2hhcnRVdGlscy5nZXREb21haW5PZkRhdGFCeUtleSkoZGlzcGxheWVkRGF0YSwgZGF0YUtleSwgJ2NhdGVnb3J5Jyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiB0aGUgZG9tYWluIGlzIGRlZmF1bHRlZCB3ZSBuZWVkIHRoaXMgZm9yIGBvcmlnaW5hbERvbWFpbmAgYXMgd2VsbFxyXG4gICAgdmFyIGRlZmF1bHREb21haW4gPSBnZXREZWZhdWx0RG9tYWluQnlBeGlzVHlwZSh0eXBlKTtcclxuXHJcbiAgICAvLyB3ZSBkaWRuJ3QgY3JlYXRlIHRoZSBkb21haW4gZnJvbSB1c2VyJ3MgcHJvcHMgYWJvdmUsIHNvIHdlIG5lZWQgdG8gY2FsY3VsYXRlIGl0XHJcbiAgICBpZiAoIWRvbWFpbiB8fCBkb21haW4ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHZhciBfY2hpbGRQcm9wcyRkb21haW47XHJcbiAgICAgIHZhciBjaGlsZERvbWFpbiA9IChfY2hpbGRQcm9wcyRkb21haW4gPSBjaGlsZFByb3BzLmRvbWFpbikgIT09IG51bGwgJiYgX2NoaWxkUHJvcHMkZG9tYWluICE9PSB2b2lkIDAgPyBfY2hpbGRQcm9wcyRkb21haW4gOiBkZWZhdWx0RG9tYWluO1xyXG4gICAgICBpZiAoZGF0YUtleSkge1xyXG4gICAgICAgIC8vIGhhcyBkYXRhS2V5IGluIDxBeGlzIC8+XHJcbiAgICAgICAgZG9tYWluID0gKDAsIF9DaGFydFV0aWxzLmdldERvbWFpbk9mRGF0YUJ5S2V5KShkaXNwbGF5ZWREYXRhLCBkYXRhS2V5LCB0eXBlKTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NhdGVnb3J5JyAmJiBpc0NhdGVnb3JpY2FsKSB7XHJcbiAgICAgICAgICAvLyB0aGUgZmllbGQgdHlwZSBpcyBjYXRlZ29yeSBkYXRhIGFuZCB0aGlzIGF4aXMgaXMgY2F0ZWdvcmljYWwgYXhpc1xyXG4gICAgICAgICAgdmFyIGR1cGxpY2F0ZSA9ICgwLCBfRGF0YVV0aWxzLmhhc0R1cGxpY2F0ZSkoZG9tYWluKTtcclxuICAgICAgICAgIGlmIChhbGxvd0R1cGxpY2F0ZWRDYXRlZ29yeSAmJiBkdXBsaWNhdGUpIHtcclxuICAgICAgICAgICAgZHVwbGljYXRlRG9tYWluID0gZG9tYWluO1xyXG4gICAgICAgICAgICAvLyBXaGVuIGNhdGVnb3J5IGF4aXMgaGFzIGR1cGxpY2F0ZWQgdGV4dCwgc2VyaWFsIG51bWJlcnMgYXJlIHVzZWQgdG8gZ2VuZXJhdGUgc2NhbGVcclxuICAgICAgICAgICAgZG9tYWluID0gKDAsIF9yYW5nZVtcImRlZmF1bHRcIl0pKDAsIGxlbik7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKCFhbGxvd0R1cGxpY2F0ZWRDYXRlZ29yeSkge1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgZHVwbGljYXRlZCBjYXRlZ29yeVxyXG4gICAgICAgICAgICBkb21haW4gPSAoMCwgX0NoYXJ0VXRpbHMucGFyc2VEb21haW5PZkNhdGVnb3J5QXhpcykoY2hpbGREb21haW4sIGRvbWFpbiwgY2hpbGQpLnJlZHVjZShmdW5jdGlvbiAoZmluYWxEb21haW4sIGVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmFsRG9tYWluLmluZGV4T2YoZW50cnkpID49IDAgPyBmaW5hbERvbWFpbiA6IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZmluYWxEb21haW4pLCBbZW50cnldKTtcclxuICAgICAgICAgICAgfSwgW10pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xyXG4gICAgICAgICAgLy8gdGhlIGZpZWxkIHR5cGUgaXMgY2F0ZWdvcnkgZGF0YSBhbmQgdGhpcyBheGlzIGlzIG51bWVyaWNhbCBheGlzXHJcbiAgICAgICAgICBpZiAoIWFsbG93RHVwbGljYXRlZENhdGVnb3J5KSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9ICgwLCBfQ2hhcnRVdGlscy5wYXJzZURvbWFpbk9mQ2F0ZWdvcnlBeGlzKShjaGlsZERvbWFpbiwgZG9tYWluLCBjaGlsZCkucmVkdWNlKGZ1bmN0aW9uIChmaW5hbERvbWFpbiwgZW50cnkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZmluYWxEb21haW4uaW5kZXhPZihlbnRyeSkgPj0gMCB8fCBlbnRyeSA9PT0gJycgfHwgKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGVudHJ5KSA/IGZpbmFsRG9tYWluIDogW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShmaW5hbERvbWFpbiksIFtlbnRyeV0pO1xyXG4gICAgICAgICAgICB9LCBbXSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBlbGltaW5hdGUgdW5kZWZpbmVkIG9yIG51bGwgb3IgZW1wdHkgc3RyaW5nXHJcbiAgICAgICAgICAgIGRvbWFpbiA9IGRvbWFpbi5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5ICE9PSAnJyAmJiAhKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGVudHJ5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgLy8gdGhlIGZpZWxkIHR5cGUgaXMgbnVtZXJpY2FsXHJcbiAgICAgICAgICB2YXIgZXJyb3JCYXJzRG9tYWluID0gKDAsIF9DaGFydFV0aWxzLnBhcnNlRXJyb3JCYXJzT2ZBeGlzKShkaXNwbGF5ZWREYXRhLCBncmFwaGljYWxJdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgdmFyIF9kZWZhdWx0UHJvcHMyLCBfZGVmYXVsdFByb3BzMztcclxuICAgICAgICAgICAgdmFyIGl0ZW1BeGlzSWQgPSBheGlzSWRLZXkgaW4gaXRlbS5wcm9wcyA/IGl0ZW0ucHJvcHNbYXhpc0lkS2V5XSA6IChfZGVmYXVsdFByb3BzMiA9IGl0ZW0udHlwZS5kZWZhdWx0UHJvcHMpID09PSBudWxsIHx8IF9kZWZhdWx0UHJvcHMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGVmYXVsdFByb3BzMltheGlzSWRLZXldO1xyXG4gICAgICAgICAgICB2YXIgaXRlbUhpZGUgPSAnaGlkZScgaW4gaXRlbS5wcm9wcyA/IGl0ZW0ucHJvcHMuaGlkZSA6IChfZGVmYXVsdFByb3BzMyA9IGl0ZW0udHlwZS5kZWZhdWx0UHJvcHMpID09PSBudWxsIHx8IF9kZWZhdWx0UHJvcHMzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGVmYXVsdFByb3BzMy5oaWRlO1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlbUF4aXNJZCA9PT0gYXhpc0lkICYmIChpbmNsdWRlSGlkZGVuIHx8ICFpdGVtSGlkZSk7XHJcbiAgICAgICAgICB9KSwgZGF0YUtleSwgYXhpc1R5cGUsIGxheW91dCk7XHJcbiAgICAgICAgICBpZiAoZXJyb3JCYXJzRG9tYWluKSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IGVycm9yQmFyc0RvbWFpbjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQ2F0ZWdvcmljYWwgJiYgKHR5cGUgPT09ICdudW1iZXInIHx8IHNjYWxlICE9PSAnYXV0bycpKSB7XHJcbiAgICAgICAgICBjYXRlZ29yaWNhbERvbWFpbiA9ICgwLCBfQ2hhcnRVdGlscy5nZXREb21haW5PZkRhdGFCeUtleSkoZGlzcGxheWVkRGF0YSwgZGF0YUtleSwgJ2NhdGVnb3J5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGlzQ2F0ZWdvcmljYWwpIHtcclxuICAgICAgICAvLyB0aGUgYXhpcyBpcyBhIGNhdGVnb3JpY2FsIGF4aXNcclxuICAgICAgICBkb21haW4gPSAoMCwgX3JhbmdlW1wiZGVmYXVsdFwiXSkoMCwgbGVuKTtcclxuICAgICAgfSBlbHNlIGlmIChzdGFja0dyb3VwcyAmJiBzdGFja0dyb3Vwc1theGlzSWRdICYmIHN0YWNrR3JvdXBzW2F4aXNJZF0uaGFzU3RhY2sgJiYgdHlwZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAvLyB3aGVuIHN0YWNrT2Zmc2V0IGlzICdleHBhbmQnLCB0aGUgZG9tYWluIG1heSBiZSBjYWxjdWxhdGVkIGFzIFswLCAxLjAwMDAwMDAwMDAwMl1cclxuICAgICAgICBkb21haW4gPSBzdGFja09mZnNldCA9PT0gJ2V4cGFuZCcgPyBbMCwgMV0gOiAoMCwgX0NoYXJ0VXRpbHMuZ2V0RG9tYWluT2ZTdGFja0dyb3Vwcykoc3RhY2tHcm91cHNbYXhpc0lkXS5zdGFja0dyb3VwcywgZGF0YVN0YXJ0SW5kZXgsIGRhdGFFbmRJbmRleCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZG9tYWluID0gKDAsIF9DaGFydFV0aWxzLmdldERvbWFpbk9mSXRlbXNXaXRoU2FtZUF4aXMpKGRpc3BsYXllZERhdGEsIGdyYXBoaWNhbEl0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgdmFyIGl0ZW1BeGlzSWQgPSBheGlzSWRLZXkgaW4gaXRlbS5wcm9wcyA/IGl0ZW0ucHJvcHNbYXhpc0lkS2V5XSA6IGl0ZW0udHlwZS5kZWZhdWx0UHJvcHNbYXhpc0lkS2V5XTtcclxuICAgICAgICAgIHZhciBpdGVtSGlkZSA9ICdoaWRlJyBpbiBpdGVtLnByb3BzID8gaXRlbS5wcm9wcy5oaWRlIDogaXRlbS50eXBlLmRlZmF1bHRQcm9wcy5oaWRlO1xyXG4gICAgICAgICAgcmV0dXJuIGl0ZW1BeGlzSWQgPT09IGF4aXNJZCAmJiAoaW5jbHVkZUhpZGRlbiB8fCAhaXRlbUhpZGUpO1xyXG4gICAgICAgIH0pLCB0eXBlLCBsYXlvdXQsIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIC8vIFRvIGRldGVjdCB3ZXRoZXIgdGhlcmUgaXMgYW55IHJlZmVyZW5jZSBsaW5lcyB3aG9zZSBwcm9wcyBhbHdheXNTaG93IGlzIHRydWVcclxuICAgICAgICBkb21haW4gPSAoMCwgX0RldGVjdFJlZmVyZW5jZUVsZW1lbnRzRG9tYWluLmRldGVjdFJlZmVyZW5jZUVsZW1lbnRzRG9tYWluKShjaGlsZHJlbiwgZG9tYWluLCBheGlzSWQsIGF4aXNUeXBlLCB0aWNrcyk7XHJcbiAgICAgICAgaWYgKGNoaWxkRG9tYWluKSB7XHJcbiAgICAgICAgICBkb21haW4gPSAoMCwgX0NoYXJ0VXRpbHMucGFyc2VTcGVjaWZpZWREb21haW4pKGNoaWxkRG9tYWluLCBkb21haW4sIGFsbG93RGF0YU92ZXJmbG93KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NhdGVnb3J5JyAmJiBjaGlsZERvbWFpbikge1xyXG4gICAgICAgIHZhciBheGlzRG9tYWluID0gY2hpbGREb21haW47XHJcbiAgICAgICAgdmFyIGlzRG9tYWluVmFsaWQgPSBkb21haW4uZXZlcnkoZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICByZXR1cm4gYXhpc0RvbWFpbi5pbmRleE9mKGVudHJ5KSA+PSAwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpc0RvbWFpblZhbGlkKSB7XHJcbiAgICAgICAgICBkb21haW4gPSBheGlzRG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmVzdWx0KSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwgYXhpc0lkLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNoaWxkUHJvcHMpLCB7fSwge1xyXG4gICAgICBheGlzVHlwZTogYXhpc1R5cGUsXHJcbiAgICAgIGRvbWFpbjogZG9tYWluLFxyXG4gICAgICBjYXRlZ29yaWNhbERvbWFpbjogY2F0ZWdvcmljYWxEb21haW4sXHJcbiAgICAgIGR1cGxpY2F0ZURvbWFpbjogZHVwbGljYXRlRG9tYWluLFxyXG4gICAgICBvcmlnaW5hbERvbWFpbjogKF9jaGlsZFByb3BzJGRvbWFpbjIgPSBjaGlsZFByb3BzLmRvbWFpbikgIT09IG51bGwgJiYgX2NoaWxkUHJvcHMkZG9tYWluMiAhPT0gdm9pZCAwID8gX2NoaWxkUHJvcHMkZG9tYWluMiA6IGRlZmF1bHREb21haW4sXHJcbiAgICAgIGlzQ2F0ZWdvcmljYWw6IGlzQ2F0ZWdvcmljYWwsXHJcbiAgICAgIGxheW91dDogbGF5b3V0XHJcbiAgICB9KSkpO1xyXG4gIH0sIHt9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGNvbmZpZ3VyYXRpb24gb2YgYXhpcyBieSB0aGUgb3B0aW9ucyBvZiBpdGVtLFxyXG4gKiB0aGlzIGtpbmQgb2YgYXhpcyBkb2VzIG5vdCBkaXNwbGF5IGluIGNoYXJ0XHJcbiAqIEBwYXJhbSAge09iamVjdH0gcHJvcHMgICAgICAgICBMYXRlc3QgcHJvcHNcclxuICogQHBhcmFtICB7QXJyYXl9IGdyYXBoaWNhbEl0ZW1zIFRoZSBpbnN0YW5jZXMgb2YgaXRlbVxyXG4gKiBAcGFyYW0gIHtSZWFjdEVsZW1lbnR9IEF4aXMgICAgQXhpcyBDb21wb25lbnRcclxuICogQHBhcmFtICB7U3RyaW5nfSBheGlzVHlwZSAgICAgIFRoZSB0eXBlIG9mIGF4aXMsIHhBeGlzIC0geC1heGlzLCB5QXhpcyAtIHktYXhpc1xyXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGF4aXNJZEtleSAgICAgVGhlIHVuaXF1ZSBpZCBvZiBhbiBheGlzXHJcbiAqIEBwYXJhbSAge09iamVjdH0gc3RhY2tHcm91cHMgICBUaGUgaXRlbXMgZ3JvdXBlZCBieSBheGlzSWQgYW5kIHN0YWNrSWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGFTdGFydEluZGV4IFRoZSBzdGFydCBpbmRleCBvZiB0aGUgZGF0YSBzZXJpZXMgd2hlbiBhIGJydXNoIGlzIGFwcGxpZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGFFbmRJbmRleCAgIFRoZSBlbmQgaW5kZXggb2YgdGhlIGRhdGEgc2VyaWVzIHdoZW4gYSBicnVzaCBpcyBhcHBsaWVkXHJcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICBDb25maWd1cmF0aW9uXHJcbiAqL1xyXG52YXIgZ2V0QXhpc01hcEJ5SXRlbXMgPSBmdW5jdGlvbiBnZXRBeGlzTWFwQnlJdGVtcyhwcm9wcywgX3JlZjMpIHtcclxuICB2YXIgZ3JhcGhpY2FsSXRlbXMgPSBfcmVmMy5ncmFwaGljYWxJdGVtcyxcclxuICAgIEF4aXMgPSBfcmVmMy5BeGlzLFxyXG4gICAgYXhpc1R5cGUgPSBfcmVmMy5heGlzVHlwZSxcclxuICAgIGF4aXNJZEtleSA9IF9yZWYzLmF4aXNJZEtleSxcclxuICAgIHN0YWNrR3JvdXBzID0gX3JlZjMuc3RhY2tHcm91cHMsXHJcbiAgICBkYXRhU3RhcnRJbmRleCA9IF9yZWYzLmRhdGFTdGFydEluZGV4LFxyXG4gICAgZGF0YUVuZEluZGV4ID0gX3JlZjMuZGF0YUVuZEluZGV4O1xyXG4gIHZhciBsYXlvdXQgPSBwcm9wcy5sYXlvdXQsXHJcbiAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xyXG4gIHZhciBkaXNwbGF5ZWREYXRhID0gZ2V0RGlzcGxheWVkRGF0YShwcm9wcy5kYXRhLCB7XHJcbiAgICBncmFwaGljYWxJdGVtczogZ3JhcGhpY2FsSXRlbXMsXHJcbiAgICBkYXRhU3RhcnRJbmRleDogZGF0YVN0YXJ0SW5kZXgsXHJcbiAgICBkYXRhRW5kSW5kZXg6IGRhdGFFbmRJbmRleFxyXG4gIH0pO1xyXG4gIHZhciBsZW4gPSBkaXNwbGF5ZWREYXRhLmxlbmd0aDtcclxuICB2YXIgaXNDYXRlZ29yaWNhbCA9ICgwLCBfQ2hhcnRVdGlscy5pc0NhdGVnb3JpY2FsQXhpcykobGF5b3V0LCBheGlzVHlwZSk7XHJcbiAgdmFyIGluZGV4ID0gLTE7XHJcblxyXG4gIC8vIFRoZSBkZWZhdWx0IHR5cGUgb2YgeC1heGlzIGlzIGNhdGVnb3J5IGF4aXMsXHJcbiAgLy8gVGhlIGRlZmF1bHQgY29udGVudHMgb2YgeC1heGlzIGlzIHRoZSBzZXJpYWwgbnVtYmVycyBvZiBkYXRhXHJcbiAgLy8gVGhlIGRlZmF1bHQgdHlwZSBvZiB5LWF4aXMgaXMgbnVtYmVyIGF4aXNcclxuICAvLyBUaGUgZGVmYXVsdCBjb250ZW50cyBvZiB5LWF4aXMgaXMgdGhlIGRvbWFpbiBvZiBkYXRhXHJcbiAgcmV0dXJuIGdyYXBoaWNhbEl0ZW1zLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBjaGlsZCkge1xyXG4gICAgdmFyIGNoaWxkUHJvcHMgPSBjaGlsZC50eXBlLmRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjaGlsZC50eXBlLmRlZmF1bHRQcm9wcyksIGNoaWxkLnByb3BzKSA6IGNoaWxkLnByb3BzO1xyXG4gICAgdmFyIGF4aXNJZCA9IGNoaWxkUHJvcHNbYXhpc0lkS2V5XTtcclxuICAgIHZhciBvcmlnaW5hbERvbWFpbiA9IGdldERlZmF1bHREb21haW5CeUF4aXNUeXBlKCdudW1iZXInKTtcclxuICAgIGlmICghcmVzdWx0W2F4aXNJZF0pIHtcclxuICAgICAgaW5kZXgrKztcclxuICAgICAgdmFyIGRvbWFpbjtcclxuICAgICAgaWYgKGlzQ2F0ZWdvcmljYWwpIHtcclxuICAgICAgICBkb21haW4gPSAoMCwgX3JhbmdlW1wiZGVmYXVsdFwiXSkoMCwgbGVuKTtcclxuICAgICAgfSBlbHNlIGlmIChzdGFja0dyb3VwcyAmJiBzdGFja0dyb3Vwc1theGlzSWRdICYmIHN0YWNrR3JvdXBzW2F4aXNJZF0uaGFzU3RhY2spIHtcclxuICAgICAgICBkb21haW4gPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0RG9tYWluT2ZTdGFja0dyb3Vwcykoc3RhY2tHcm91cHNbYXhpc0lkXS5zdGFja0dyb3VwcywgZGF0YVN0YXJ0SW5kZXgsIGRhdGFFbmRJbmRleCk7XHJcbiAgICAgICAgZG9tYWluID0gKDAsIF9EZXRlY3RSZWZlcmVuY2VFbGVtZW50c0RvbWFpbi5kZXRlY3RSZWZlcmVuY2VFbGVtZW50c0RvbWFpbikoY2hpbGRyZW4sIGRvbWFpbiwgYXhpc0lkLCBheGlzVHlwZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZG9tYWluID0gKDAsIF9DaGFydFV0aWxzLnBhcnNlU3BlY2lmaWVkRG9tYWluKShvcmlnaW5hbERvbWFpbiwgKDAsIF9DaGFydFV0aWxzLmdldERvbWFpbk9mSXRlbXNXaXRoU2FtZUF4aXMpKGRpc3BsYXllZERhdGEsIGdyYXBoaWNhbEl0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgdmFyIF9kZWZhdWx0UHJvcHM0LCBfZGVmYXVsdFByb3BzNTtcclxuICAgICAgICAgIHZhciBpdGVtQXhpc0lkID0gYXhpc0lkS2V5IGluIGl0ZW0ucHJvcHMgPyBpdGVtLnByb3BzW2F4aXNJZEtleV0gOiAoX2RlZmF1bHRQcm9wczQgPSBpdGVtLnR5cGUuZGVmYXVsdFByb3BzKSA9PT0gbnVsbCB8fCBfZGVmYXVsdFByb3BzNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RlZmF1bHRQcm9wczRbYXhpc0lkS2V5XTtcclxuICAgICAgICAgIHZhciBpdGVtSGlkZSA9ICdoaWRlJyBpbiBpdGVtLnByb3BzID8gaXRlbS5wcm9wcy5oaWRlIDogKF9kZWZhdWx0UHJvcHM1ID0gaXRlbS50eXBlLmRlZmF1bHRQcm9wcykgPT09IG51bGwgfHwgX2RlZmF1bHRQcm9wczUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kZWZhdWx0UHJvcHM1LmhpZGU7XHJcbiAgICAgICAgICByZXR1cm4gaXRlbUF4aXNJZCA9PT0gYXhpc0lkICYmICFpdGVtSGlkZTtcclxuICAgICAgICB9KSwgJ251bWJlcicsIGxheW91dCksIEF4aXMuZGVmYXVsdFByb3BzLmFsbG93RGF0YU92ZXJmbG93KTtcclxuICAgICAgICBkb21haW4gPSAoMCwgX0RldGVjdFJlZmVyZW5jZUVsZW1lbnRzRG9tYWluLmRldGVjdFJlZmVyZW5jZUVsZW1lbnRzRG9tYWluKShjaGlsZHJlbiwgZG9tYWluLCBheGlzSWQsIGF4aXNUeXBlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXN1bHQpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBheGlzSWQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XHJcbiAgICAgICAgYXhpc1R5cGU6IGF4aXNUeXBlXHJcbiAgICAgIH0sIEF4aXMuZGVmYXVsdFByb3BzKSwge30sIHtcclxuICAgICAgICBoaWRlOiB0cnVlLFxyXG4gICAgICAgIG9yaWVudGF0aW9uOiAoMCwgX2dldFtcImRlZmF1bHRcIl0pKE9SSUVOVF9NQVAsIFwiXCIuY29uY2F0KGF4aXNUeXBlLCBcIi5cIikuY29uY2F0KGluZGV4ICUgMiksIG51bGwpLFxyXG4gICAgICAgIGRvbWFpbjogZG9tYWluLFxyXG4gICAgICAgIG9yaWdpbmFsRG9tYWluOiBvcmlnaW5hbERvbWFpbixcclxuICAgICAgICBpc0NhdGVnb3JpY2FsOiBpc0NhdGVnb3JpY2FsLFxyXG4gICAgICAgIGxheW91dDogbGF5b3V0XHJcbiAgICAgICAgLy8gc3BlY2lmeSBzY2FsZSB3aGVuIG5vIEF4aXNcclxuICAgICAgICAvLyBzY2FsZTogaXNDYXRlZ29yaWNhbCA/ICdiYW5kJyA6ICdsaW5lYXInLFxyXG4gICAgICB9KSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9LCB7fSk7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBjb25maWd1cmF0aW9uIG9mIGFsbCB4LWF4aXMgb3IgeS1heGlzXHJcbiAqIEBwYXJhbSAge09iamVjdH0gcHJvcHMgICAgICAgICAgTGF0ZXN0IHByb3BzXHJcbiAqIEBwYXJhbSAge1N0cmluZ30gYXhpc1R5cGUgICAgICAgVGhlIHR5cGUgb2YgYXhpc1xyXG4gKiBAcGFyYW0gIHtSZWFjdC5Db21wb25lbnRUeXBlfSAgW0F4aXNDb21wXSAgICAgIEF4aXMgQ29tcG9uZW50XHJcbiAqIEBwYXJhbSAge0FycmF5fSAgZ3JhcGhpY2FsSXRlbXMgVGhlIGluc3RhbmNlcyBvZiBpdGVtXHJcbiAqIEBwYXJhbSAge09iamVjdH0gc3RhY2tHcm91cHMgICAgVGhlIGl0ZW1zIGdyb3VwZWQgYnkgYXhpc0lkIGFuZCBzdGFja0lkXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhU3RhcnRJbmRleCAgVGhlIHN0YXJ0IGluZGV4IG9mIHRoZSBkYXRhIHNlcmllcyB3aGVuIGEgYnJ1c2ggaXMgYXBwbGllZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gZGF0YUVuZEluZGV4ICAgIFRoZSBlbmQgaW5kZXggb2YgdGhlIGRhdGEgc2VyaWVzIHdoZW4gYSBicnVzaCBpcyBhcHBsaWVkXHJcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgQ29uZmlndXJhdGlvblxyXG4gKi9cclxudmFyIGdldEF4aXNNYXAgPSBmdW5jdGlvbiBnZXRBeGlzTWFwKHByb3BzLCBfcmVmNCkge1xyXG4gIHZhciBfcmVmNCRheGlzVHlwZSA9IF9yZWY0LmF4aXNUeXBlLFxyXG4gICAgYXhpc1R5cGUgPSBfcmVmNCRheGlzVHlwZSA9PT0gdm9pZCAwID8gJ3hBeGlzJyA6IF9yZWY0JGF4aXNUeXBlLFxyXG4gICAgQXhpc0NvbXAgPSBfcmVmNC5BeGlzQ29tcCxcclxuICAgIGdyYXBoaWNhbEl0ZW1zID0gX3JlZjQuZ3JhcGhpY2FsSXRlbXMsXHJcbiAgICBzdGFja0dyb3VwcyA9IF9yZWY0LnN0YWNrR3JvdXBzLFxyXG4gICAgZGF0YVN0YXJ0SW5kZXggPSBfcmVmNC5kYXRhU3RhcnRJbmRleCxcclxuICAgIGRhdGFFbmRJbmRleCA9IF9yZWY0LmRhdGFFbmRJbmRleDtcclxuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcclxuICB2YXIgYXhpc0lkS2V5ID0gXCJcIi5jb25jYXQoYXhpc1R5cGUsIFwiSWRcIik7XHJcbiAgLy8gR2V0IGFsbCB0aGUgaW5zdGFuY2Ugb2YgQXhpc1xyXG4gIHZhciBheGVzID0gKDAsIF9SZWFjdFV0aWxzLmZpbmRBbGxCeVR5cGUpKGNoaWxkcmVuLCBBeGlzQ29tcCk7XHJcbiAgdmFyIGF4aXNNYXAgPSB7fTtcclxuICBpZiAoYXhlcyAmJiBheGVzLmxlbmd0aCkge1xyXG4gICAgYXhpc01hcCA9IGdldEF4aXNNYXBCeUF4ZXMocHJvcHMsIHtcclxuICAgICAgYXhlczogYXhlcyxcclxuICAgICAgZ3JhcGhpY2FsSXRlbXM6IGdyYXBoaWNhbEl0ZW1zLFxyXG4gICAgICBheGlzVHlwZTogYXhpc1R5cGUsXHJcbiAgICAgIGF4aXNJZEtleTogYXhpc0lkS2V5LFxyXG4gICAgICBzdGFja0dyb3Vwczogc3RhY2tHcm91cHMsXHJcbiAgICAgIGRhdGFTdGFydEluZGV4OiBkYXRhU3RhcnRJbmRleCxcclxuICAgICAgZGF0YUVuZEluZGV4OiBkYXRhRW5kSW5kZXhcclxuICAgIH0pO1xyXG4gIH0gZWxzZSBpZiAoZ3JhcGhpY2FsSXRlbXMgJiYgZ3JhcGhpY2FsSXRlbXMubGVuZ3RoKSB7XHJcbiAgICBheGlzTWFwID0gZ2V0QXhpc01hcEJ5SXRlbXMocHJvcHMsIHtcclxuICAgICAgQXhpczogQXhpc0NvbXAsXHJcbiAgICAgIGdyYXBoaWNhbEl0ZW1zOiBncmFwaGljYWxJdGVtcyxcclxuICAgICAgYXhpc1R5cGU6IGF4aXNUeXBlLFxyXG4gICAgICBheGlzSWRLZXk6IGF4aXNJZEtleSxcclxuICAgICAgc3RhY2tHcm91cHM6IHN0YWNrR3JvdXBzLFxyXG4gICAgICBkYXRhU3RhcnRJbmRleDogZGF0YVN0YXJ0SW5kZXgsXHJcbiAgICAgIGRhdGFFbmRJbmRleDogZGF0YUVuZEluZGV4XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIGF4aXNNYXA7XHJcbn07XHJcbnZhciB0b29sdGlwVGlja3NHZW5lcmF0b3IgPSBmdW5jdGlvbiB0b29sdGlwVGlja3NHZW5lcmF0b3IoYXhpc01hcCkge1xyXG4gIHZhciBheGlzID0gKDAsIF9EYXRhVXRpbHMuZ2V0QW55RWxlbWVudE9mT2JqZWN0KShheGlzTWFwKTtcclxuICB2YXIgdG9vbHRpcFRpY2tzID0gKDAsIF9DaGFydFV0aWxzLmdldFRpY2tzT2ZBeGlzKShheGlzLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHRvb2x0aXBUaWNrczogdG9vbHRpcFRpY2tzLFxyXG4gICAgb3JkZXJlZFRvb2x0aXBUaWNrczogKDAsIF9zb3J0QnlbXCJkZWZhdWx0XCJdKSh0b29sdGlwVGlja3MsIGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgIHJldHVybiBvLmNvb3JkaW5hdGU7XHJcbiAgICB9KSxcclxuICAgIHRvb2x0aXBBeGlzOiBheGlzLFxyXG4gICAgdG9vbHRpcEF4aXNCYW5kU2l6ZTogKDAsIF9DaGFydFV0aWxzLmdldEJhbmRTaXplT2ZBeGlzKShheGlzLCB0b29sdGlwVGlja3MpXHJcbiAgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGRlZmF1bHQsIHJlc2V0IHN0YXRlIGZvciB0aGUgY2F0ZWdvcmljYWwgY2hhcnQuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBQcm9wcyBvYmplY3QgdG8gdXNlIHdoZW4gY3JlYXRpbmcgdGhlIGRlZmF1bHQgc3RhdGVcclxuICogQHJldHVybiB7T2JqZWN0fSBXaG9sZSBuZXcgc3RhdGVcclxuICovXHJcbnZhciBjcmVhdGVEZWZhdWx0U3RhdGUgPSBleHBvcnRzLmNyZWF0ZURlZmF1bHRTdGF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRTdGF0ZShwcm9wcykge1xyXG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxyXG4gICAgZGVmYXVsdFNob3dUb29sdGlwID0gcHJvcHMuZGVmYXVsdFNob3dUb29sdGlwO1xyXG4gIHZhciBicnVzaEl0ZW0gPSAoMCwgX1JlYWN0VXRpbHMuZmluZENoaWxkQnlUeXBlKShjaGlsZHJlbiwgX0JydXNoLkJydXNoKTtcclxuICB2YXIgc3RhcnRJbmRleCA9IDA7XHJcbiAgdmFyIGVuZEluZGV4ID0gMDtcclxuICBpZiAocHJvcHMuZGF0YSAmJiBwcm9wcy5kYXRhLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgZW5kSW5kZXggPSBwcm9wcy5kYXRhLmxlbmd0aCAtIDE7XHJcbiAgfVxyXG4gIGlmIChicnVzaEl0ZW0gJiYgYnJ1c2hJdGVtLnByb3BzKSB7XHJcbiAgICBpZiAoYnJ1c2hJdGVtLnByb3BzLnN0YXJ0SW5kZXggPj0gMCkge1xyXG4gICAgICBzdGFydEluZGV4ID0gYnJ1c2hJdGVtLnByb3BzLnN0YXJ0SW5kZXg7XHJcbiAgICB9XHJcbiAgICBpZiAoYnJ1c2hJdGVtLnByb3BzLmVuZEluZGV4ID49IDApIHtcclxuICAgICAgZW5kSW5kZXggPSBicnVzaEl0ZW0ucHJvcHMuZW5kSW5kZXg7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICBjaGFydFg6IDAsXHJcbiAgICBjaGFydFk6IDAsXHJcbiAgICBkYXRhU3RhcnRJbmRleDogc3RhcnRJbmRleCxcclxuICAgIGRhdGFFbmRJbmRleDogZW5kSW5kZXgsXHJcbiAgICBhY3RpdmVUb29sdGlwSW5kZXg6IC0xLFxyXG4gICAgaXNUb29sdGlwQWN0aXZlOiBCb29sZWFuKGRlZmF1bHRTaG93VG9vbHRpcClcclxuICB9O1xyXG59O1xyXG52YXIgaGFzR3JhcGhpY2FsQmFySXRlbSA9IGZ1bmN0aW9uIGhhc0dyYXBoaWNhbEJhckl0ZW0oZ3JhcGhpY2FsSXRlbXMpIHtcclxuICBpZiAoIWdyYXBoaWNhbEl0ZW1zIHx8ICFncmFwaGljYWxJdGVtcy5sZW5ndGgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIGdyYXBoaWNhbEl0ZW1zLnNvbWUoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgIHZhciBuYW1lID0gKDAsIF9SZWFjdFV0aWxzLmdldERpc3BsYXlOYW1lKShpdGVtICYmIGl0ZW0udHlwZSk7XHJcbiAgICByZXR1cm4gbmFtZSAmJiBuYW1lLmluZGV4T2YoJ0JhcicpID49IDA7XHJcbiAgfSk7XHJcbn07XHJcbnZhciBnZXRBeGlzTmFtZUJ5TGF5b3V0ID0gZnVuY3Rpb24gZ2V0QXhpc05hbWVCeUxheW91dChsYXlvdXQpIHtcclxuICBpZiAobGF5b3V0ID09PSAnaG9yaXpvbnRhbCcpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG51bWVyaWNBeGlzTmFtZTogJ3lBeGlzJyxcclxuICAgICAgY2F0ZUF4aXNOYW1lOiAneEF4aXMnXHJcbiAgICB9O1xyXG4gIH1cclxuICBpZiAobGF5b3V0ID09PSAndmVydGljYWwnKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBudW1lcmljQXhpc05hbWU6ICd4QXhpcycsXHJcbiAgICAgIGNhdGVBeGlzTmFtZTogJ3lBeGlzJ1xyXG4gICAgfTtcclxuICB9XHJcbiAgaWYgKGxheW91dCA9PT0gJ2NlbnRyaWMnKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBudW1lcmljQXhpc05hbWU6ICdyYWRpdXNBeGlzJyxcclxuICAgICAgY2F0ZUF4aXNOYW1lOiAnYW5nbGVBeGlzJ1xyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIG51bWVyaWNBeGlzTmFtZTogJ2FuZ2xlQXhpcycsXHJcbiAgICBjYXRlQXhpc05hbWU6ICdyYWRpdXNBeGlzJ1xyXG4gIH07XHJcbn07XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBvZmZzZXQgb2YgbWFpbiBwYXJ0IGluIHRoZSBzdmcgZWxlbWVudFxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBhcmFtcy5wcm9wcyAgICAgICAgICBMYXRlc3QgcHJvcHNcclxuICogQHBhcmFtICB7QXJyYXl9ICBwYXJhbXMuZ3JhcGhpY2FsSXRlbXMgVGhlIGluc3RhbmNlcyBvZiBpdGVtXHJcbiAqIEBwYXJhbSAge09iamVjdH0gcGFyYW1zLnhBeGlzTWFwICAgICAgIFRoZSBjb25maWd1cmF0aW9uIG9mIHgtYXhpc1xyXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBhcmFtcy55QXhpc01hcCAgICAgICBUaGUgY29uZmlndXJhdGlvbiBvZiB5LWF4aXNcclxuICogQHBhcmFtICB7T2JqZWN0fSBwcmV2TGVnZW5kQkJveCAgICAgICAgVGhlIGJvdW5kYXJ5IGJveCBvZiBsZWdlbmRcclxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgb2Zmc2V0IG9mIG1haW4gcGFydCBpbiB0aGUgc3ZnIGVsZW1lbnRcclxuICovXHJcbnZhciBjYWxjdWxhdGVPZmZzZXQgPSBmdW5jdGlvbiBjYWxjdWxhdGVPZmZzZXQoX3JlZjUsIHByZXZMZWdlbmRCQm94KSB7XHJcbiAgdmFyIHByb3BzID0gX3JlZjUucHJvcHMsXHJcbiAgICBncmFwaGljYWxJdGVtcyA9IF9yZWY1LmdyYXBoaWNhbEl0ZW1zLFxyXG4gICAgX3JlZjUkeEF4aXNNYXAgPSBfcmVmNS54QXhpc01hcCxcclxuICAgIHhBeGlzTWFwID0gX3JlZjUkeEF4aXNNYXAgPT09IHZvaWQgMCA/IHt9IDogX3JlZjUkeEF4aXNNYXAsXHJcbiAgICBfcmVmNSR5QXhpc01hcCA9IF9yZWY1LnlBeGlzTWFwLFxyXG4gICAgeUF4aXNNYXAgPSBfcmVmNSR5QXhpc01hcCA9PT0gdm9pZCAwID8ge30gOiBfcmVmNSR5QXhpc01hcDtcclxuICB2YXIgd2lkdGggPSBwcm9wcy53aWR0aCxcclxuICAgIGhlaWdodCA9IHByb3BzLmhlaWdodCxcclxuICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XHJcbiAgdmFyIG1hcmdpbiA9IHByb3BzLm1hcmdpbiB8fCB7fTtcclxuICB2YXIgYnJ1c2hJdGVtID0gKDAsIF9SZWFjdFV0aWxzLmZpbmRDaGlsZEJ5VHlwZSkoY2hpbGRyZW4sIF9CcnVzaC5CcnVzaCk7XHJcbiAgdmFyIGxlZ2VuZEl0ZW0gPSAoMCwgX1JlYWN0VXRpbHMuZmluZENoaWxkQnlUeXBlKShjaGlsZHJlbiwgX0xlZ2VuZC5MZWdlbmQpO1xyXG4gIHZhciBvZmZzZXRIID0gT2JqZWN0LmtleXMoeUF4aXNNYXApLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBpZCkge1xyXG4gICAgdmFyIGVudHJ5ID0geUF4aXNNYXBbaWRdO1xyXG4gICAgdmFyIG9yaWVudGF0aW9uID0gZW50cnkub3JpZW50YXRpb247XHJcbiAgICBpZiAoIWVudHJ5Lm1pcnJvciAmJiAhZW50cnkuaGlkZSkge1xyXG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXN1bHQpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBvcmllbnRhdGlvbiwgcmVzdWx0W29yaWVudGF0aW9uXSArIGVudHJ5LndpZHRoKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH0sIHtcclxuICAgIGxlZnQ6IG1hcmdpbi5sZWZ0IHx8IDAsXHJcbiAgICByaWdodDogbWFyZ2luLnJpZ2h0IHx8IDBcclxuICB9KTtcclxuICB2YXIgb2Zmc2V0ViA9IE9iamVjdC5rZXlzKHhBeGlzTWFwKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgaWQpIHtcclxuICAgIHZhciBlbnRyeSA9IHhBeGlzTWFwW2lkXTtcclxuICAgIHZhciBvcmllbnRhdGlvbiA9IGVudHJ5Lm9yaWVudGF0aW9uO1xyXG4gICAgaWYgKCFlbnRyeS5taXJyb3IgJiYgIWVudHJ5LmhpZGUpIHtcclxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmVzdWx0KSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwgb3JpZW50YXRpb24sICgwLCBfZ2V0W1wiZGVmYXVsdFwiXSkocmVzdWx0LCBcIlwiLmNvbmNhdChvcmllbnRhdGlvbikpICsgZW50cnkuaGVpZ2h0KSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH0sIHtcclxuICAgIHRvcDogbWFyZ2luLnRvcCB8fCAwLFxyXG4gICAgYm90dG9tOiBtYXJnaW4uYm90dG9tIHx8IDBcclxuICB9KTtcclxuICB2YXIgb2Zmc2V0ID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvZmZzZXRWKSwgb2Zmc2V0SCk7XHJcbiAgdmFyIGJydXNoQm90dG9tID0gb2Zmc2V0LmJvdHRvbTtcclxuICBpZiAoYnJ1c2hJdGVtKSB7XHJcbiAgICBvZmZzZXQuYm90dG9tICs9IGJydXNoSXRlbS5wcm9wcy5oZWlnaHQgfHwgX0JydXNoLkJydXNoLmRlZmF1bHRQcm9wcy5oZWlnaHQ7XHJcbiAgfVxyXG4gIGlmIChsZWdlbmRJdGVtICYmIHByZXZMZWdlbmRCQm94KSB7XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG1hcmdpbiBpcyBvcHRpb25hbCBpbiBwcm9wcyBidXQgcmVxdWlyZWQgaW4gYXBwZW5kT2Zmc2V0T2ZMZWdlbmRcclxuICAgIG9mZnNldCA9ICgwLCBfQ2hhcnRVdGlscy5hcHBlbmRPZmZzZXRPZkxlZ2VuZCkob2Zmc2V0LCBncmFwaGljYWxJdGVtcywgcHJvcHMsIHByZXZMZWdlbmRCQm94KTtcclxuICB9XHJcbiAgdmFyIG9mZnNldFdpZHRoID0gd2lkdGggLSBvZmZzZXQubGVmdCAtIG9mZnNldC5yaWdodDtcclxuICB2YXIgb2Zmc2V0SGVpZ2h0ID0gaGVpZ2h0IC0gb2Zmc2V0LnRvcCAtIG9mZnNldC5ib3R0b207XHJcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XHJcbiAgICBicnVzaEJvdHRvbTogYnJ1c2hCb3R0b21cclxuICB9LCBvZmZzZXQpLCB7fSwge1xyXG4gICAgLy8gbmV2ZXIgcmV0dXJuIG5lZ2F0aXZlIHZhbHVlcyBmb3IgaGVpZ2h0IGFuZCB3aWR0aFxyXG4gICAgd2lkdGg6IE1hdGgubWF4KG9mZnNldFdpZHRoLCAwKSxcclxuICAgIGhlaWdodDogTWF0aC5tYXgob2Zmc2V0SGVpZ2h0LCAwKVxyXG4gIH0pO1xyXG59O1xyXG4vLyBEZXRlcm1pbmUgdGhlIHNpemUgb2YgdGhlIGF4aXMsIHVzZWQgZm9yIGNhbGN1bGF0aW9uIG9mIHJlbGF0aXZlIGJhciBzaXplc1xyXG52YXIgZ2V0Q2FydGVzaWFuQXhpc1NpemUgPSBmdW5jdGlvbiBnZXRDYXJ0ZXNpYW5BeGlzU2l6ZShheGlzT2JqLCBheGlzTmFtZSkge1xyXG4gIGlmIChheGlzTmFtZSA9PT0gJ3hBeGlzJykge1xyXG4gICAgcmV0dXJuIGF4aXNPYmpbYXhpc05hbWVdLndpZHRoO1xyXG4gIH1cclxuICBpZiAoYXhpc05hbWUgPT09ICd5QXhpcycpIHtcclxuICAgIHJldHVybiBheGlzT2JqW2F4aXNOYW1lXS5oZWlnaHQ7XHJcbiAgfVxyXG4gIC8vIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIEJhciBjaGFydHMgKGkuZS4gY2hhcnRzIHdpdGggY2FydGVzaWFuIGF4ZXMpLCBzbyB3ZSBzaG91bGQgbmV2ZXIgZ2V0IGhlcmVcclxuICByZXR1cm4gdW5kZWZpbmVkO1xyXG59O1xyXG52YXIgZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0ID0gZXhwb3J0cy5nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQgPSBmdW5jdGlvbiBnZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQoX3JlZjYpIHtcclxuICB2YXIgY2hhcnROYW1lID0gX3JlZjYuY2hhcnROYW1lLFxyXG4gICAgR3JhcGhpY2FsQ2hpbGQgPSBfcmVmNi5HcmFwaGljYWxDaGlsZCxcclxuICAgIF9yZWY2JGRlZmF1bHRUb29sdGlwRSA9IF9yZWY2LmRlZmF1bHRUb29sdGlwRXZlbnRUeXBlLFxyXG4gICAgZGVmYXVsdFRvb2x0aXBFdmVudFR5cGUgPSBfcmVmNiRkZWZhdWx0VG9vbHRpcEUgPT09IHZvaWQgMCA/ICdheGlzJyA6IF9yZWY2JGRlZmF1bHRUb29sdGlwRSxcclxuICAgIF9yZWY2JHZhbGlkYXRlVG9vbHRpcCA9IF9yZWY2LnZhbGlkYXRlVG9vbHRpcEV2ZW50VHlwZXMsXHJcbiAgICB2YWxpZGF0ZVRvb2x0aXBFdmVudFR5cGVzID0gX3JlZjYkdmFsaWRhdGVUb29sdGlwID09PSB2b2lkIDAgPyBbJ2F4aXMnXSA6IF9yZWY2JHZhbGlkYXRlVG9vbHRpcCxcclxuICAgIGF4aXNDb21wb25lbnRzID0gX3JlZjYuYXhpc0NvbXBvbmVudHMsXHJcbiAgICBsZWdlbmRDb250ZW50ID0gX3JlZjYubGVnZW5kQ29udGVudCxcclxuICAgIGZvcm1hdEF4aXNNYXAgPSBfcmVmNi5mb3JtYXRBeGlzTWFwLFxyXG4gICAgZGVmYXVsdFByb3BzID0gX3JlZjYuZGVmYXVsdFByb3BzO1xyXG4gIHZhciBnZXRGb3JtYXRJdGVtcyA9IGZ1bmN0aW9uIGdldEZvcm1hdEl0ZW1zKHByb3BzLCBjdXJyZW50U3RhdGUpIHtcclxuICAgIHZhciBncmFwaGljYWxJdGVtcyA9IGN1cnJlbnRTdGF0ZS5ncmFwaGljYWxJdGVtcyxcclxuICAgICAgc3RhY2tHcm91cHMgPSBjdXJyZW50U3RhdGUuc3RhY2tHcm91cHMsXHJcbiAgICAgIG9mZnNldCA9IGN1cnJlbnRTdGF0ZS5vZmZzZXQsXHJcbiAgICAgIHVwZGF0ZUlkID0gY3VycmVudFN0YXRlLnVwZGF0ZUlkLFxyXG4gICAgICBkYXRhU3RhcnRJbmRleCA9IGN1cnJlbnRTdGF0ZS5kYXRhU3RhcnRJbmRleCxcclxuICAgICAgZGF0YUVuZEluZGV4ID0gY3VycmVudFN0YXRlLmRhdGFFbmRJbmRleDtcclxuICAgIHZhciBiYXJTaXplID0gcHJvcHMuYmFyU2l6ZSxcclxuICAgICAgbGF5b3V0ID0gcHJvcHMubGF5b3V0LFxyXG4gICAgICBiYXJHYXAgPSBwcm9wcy5iYXJHYXAsXHJcbiAgICAgIGJhckNhdGVnb3J5R2FwID0gcHJvcHMuYmFyQ2F0ZWdvcnlHYXAsXHJcbiAgICAgIGdsb2JhbE1heEJhclNpemUgPSBwcm9wcy5tYXhCYXJTaXplO1xyXG4gICAgdmFyIF9nZXRBeGlzTmFtZUJ5TGF5b3V0ID0gZ2V0QXhpc05hbWVCeUxheW91dChsYXlvdXQpLFxyXG4gICAgICBudW1lcmljQXhpc05hbWUgPSBfZ2V0QXhpc05hbWVCeUxheW91dC5udW1lcmljQXhpc05hbWUsXHJcbiAgICAgIGNhdGVBeGlzTmFtZSA9IF9nZXRBeGlzTmFtZUJ5TGF5b3V0LmNhdGVBeGlzTmFtZTtcclxuICAgIHZhciBoYXNCYXIgPSBoYXNHcmFwaGljYWxCYXJJdGVtKGdyYXBoaWNhbEl0ZW1zKTtcclxuICAgIHZhciBmb3JtYXR0ZWRJdGVtcyA9IFtdO1xyXG4gICAgZ3JhcGhpY2FsSXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcclxuICAgICAgdmFyIGRpc3BsYXllZERhdGEgPSBnZXREaXNwbGF5ZWREYXRhKHByb3BzLmRhdGEsIHtcclxuICAgICAgICBncmFwaGljYWxJdGVtczogW2l0ZW1dLFxyXG4gICAgICAgIGRhdGFTdGFydEluZGV4OiBkYXRhU3RhcnRJbmRleCxcclxuICAgICAgICBkYXRhRW5kSW5kZXg6IGRhdGFFbmRJbmRleFxyXG4gICAgICB9KTtcclxuICAgICAgdmFyIGl0ZW1Qcm9wcyA9IGl0ZW0udHlwZS5kZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaXRlbS50eXBlLmRlZmF1bHRQcm9wcyksIGl0ZW0ucHJvcHMpIDogaXRlbS5wcm9wcztcclxuICAgICAgdmFyIGRhdGFLZXkgPSBpdGVtUHJvcHMuZGF0YUtleSxcclxuICAgICAgICBjaGlsZE1heEJhclNpemUgPSBpdGVtUHJvcHMubWF4QmFyU2l6ZTtcclxuICAgICAgLy8gYXhpc0lkIG9mIHRoZSBudW1lcmljYWwgYXhpc1xyXG4gICAgICB2YXIgbnVtZXJpY0F4aXNJZCA9IGl0ZW1Qcm9wc1tcIlwiLmNvbmNhdChudW1lcmljQXhpc05hbWUsIFwiSWRcIildO1xyXG4gICAgICAvLyBheGlzSWQgb2YgdGhlIGNhdGVnb3JpY2FsIGF4aXNcclxuICAgICAgdmFyIGNhdGVBeGlzSWQgPSBpdGVtUHJvcHNbXCJcIi5jb25jYXQoY2F0ZUF4aXNOYW1lLCBcIklkXCIpXTtcclxuICAgICAgdmFyIGF4aXNPYmpJbml0aWFsVmFsdWUgPSB7fTtcclxuICAgICAgdmFyIGF4aXNPYmogPSBheGlzQ29tcG9uZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgZW50cnkpIHtcclxuICAgICAgICB2YXIgX2l0ZW0kdHlwZSRkaXNwbGF5TmFtLCBfaXRlbSR0eXBlO1xyXG4gICAgICAgIC8vIG1hcCBvZiBheGlzSWQgdG8gYXhpcyBmb3IgYSBzcGVjaWZpYyBheGlzIHR5cGVcclxuICAgICAgICB2YXIgYXhpc01hcCA9IGN1cnJlbnRTdGF0ZVtcIlwiLmNvbmNhdChlbnRyeS5heGlzVHlwZSwgXCJNYXBcIildO1xyXG4gICAgICAgIC8vIGF4aXNJZCBvZiBheGlzIHdlIGFyZSBjdXJyZW50bHkgY29tcHV0aW5nXHJcbiAgICAgICAgdmFyIGlkID0gaXRlbVByb3BzW1wiXCIuY29uY2F0KGVudHJ5LmF4aXNUeXBlLCBcIklkXCIpXTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogdGVsbCB0aGUgdXNlciBpbiBkZXYgbW9kZSB0aGF0IHRoZWlyIGNvbmZpZ3VyYXRpb24gaXMgaW5jb3JyZWN0IGlmIHdlIGNhbm5vdCBmaW5kIGEgbWF0Y2ggYmV0d2VlblxyXG4gICAgICAgICAqIGF4aXNJZCBvbiB0aGUgY2hhcnQgYW5kIGF4aXNJZCBvbiB0aGUgYXhpcy4gekF4aXMgZG9lcyBub3QgZ2V0IHBhc3NlZCBpbiB0aGUgbWFwIGZvciBDb21wb3NlZENoYXJ0LFxyXG4gICAgICAgICAqIGxlYXZlIGl0IG91dCBvZiB0aGUgY2hlY2sgZm9yIG5vdy5cclxuICAgICAgICAgKi9cclxuICAgICAgICAhKGF4aXNNYXAgJiYgYXhpc01hcFtpZF0gfHwgZW50cnkuYXhpc1R5cGUgPT09ICd6QXhpcycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gKDAsIF90aW55SW52YXJpYW50W1wiZGVmYXVsdFwiXSkoZmFsc2UsIFwiU3BlY2lmeWluZyBhKG4pIFwiLmNvbmNhdChlbnRyeS5heGlzVHlwZSwgXCJJZCByZXF1aXJlcyBhIGNvcnJlc3BvbmRpbmcgXCIpLmNvbmNhdChlbnRyeS5heGlzVHlwZVxyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igd2Ugc2hvdWxkIHN0b3AgcmVhZGluZyBkYXRhIGZyb20gUmVhY3RFbGVtZW50c1xyXG4gICAgICAgICwgXCJJZCBvbiB0aGUgdGFyZ2V0ZWQgZ3JhcGhpY2FsIGNvbXBvbmVudCBcIikuY29uY2F0KChfaXRlbSR0eXBlJGRpc3BsYXlOYW0gPSBpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHZvaWQgMCB8fCAoX2l0ZW0kdHlwZSA9IGl0ZW0udHlwZSkgPT09IG51bGwgfHwgX2l0ZW0kdHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2l0ZW0kdHlwZS5kaXNwbGF5TmFtZSkgIT09IG51bGwgJiYgX2l0ZW0kdHlwZSRkaXNwbGF5TmFtICE9PSB2b2lkIDAgPyBfaXRlbSR0eXBlJGRpc3BsYXlOYW0gOiAnJykpIDogKDAsIF90aW55SW52YXJpYW50W1wiZGVmYXVsdFwiXSkoZmFsc2UpIDogdm9pZCAwO1xyXG5cclxuICAgICAgICAvLyB0aGUgYXhpcyB3ZSBhcmUgY3VycmVudGx5IGZvcm1hdHRpbmdcclxuICAgICAgICB2YXIgYXhpcyA9IGF4aXNNYXBbaWRdO1xyXG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlc3VsdCksIHt9LCBfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KHt9LCBlbnRyeS5heGlzVHlwZSwgYXhpcyksIFwiXCIuY29uY2F0KGVudHJ5LmF4aXNUeXBlLCBcIlRpY2tzXCIpLCAoMCwgX0NoYXJ0VXRpbHMuZ2V0VGlja3NPZkF4aXMpKGF4aXMpKSk7XHJcbiAgICAgIH0sIGF4aXNPYmpJbml0aWFsVmFsdWUpO1xyXG4gICAgICB2YXIgY2F0ZUF4aXMgPSBheGlzT2JqW2NhdGVBeGlzTmFtZV07XHJcbiAgICAgIHZhciBjYXRlVGlja3MgPSBheGlzT2JqW1wiXCIuY29uY2F0KGNhdGVBeGlzTmFtZSwgXCJUaWNrc1wiKV07XHJcbiAgICAgIHZhciBzdGFja2VkRGF0YSA9IHN0YWNrR3JvdXBzICYmIHN0YWNrR3JvdXBzW251bWVyaWNBeGlzSWRdICYmIHN0YWNrR3JvdXBzW251bWVyaWNBeGlzSWRdLmhhc1N0YWNrICYmICgwLCBfQ2hhcnRVdGlscy5nZXRTdGFja2VkRGF0YU9mSXRlbSkoaXRlbSwgc3RhY2tHcm91cHNbbnVtZXJpY0F4aXNJZF0uc3RhY2tHcm91cHMpO1xyXG4gICAgICB2YXIgaXRlbUlzQmFyID0gKDAsIF9SZWFjdFV0aWxzLmdldERpc3BsYXlOYW1lKShpdGVtLnR5cGUpLmluZGV4T2YoJ0JhcicpID49IDA7XHJcbiAgICAgIHZhciBiYW5kU2l6ZSA9ICgwLCBfQ2hhcnRVdGlscy5nZXRCYW5kU2l6ZU9mQXhpcykoY2F0ZUF4aXMsIGNhdGVUaWNrcyk7XHJcbiAgICAgIHZhciBiYXJQb3NpdGlvbiA9IFtdO1xyXG4gICAgICB2YXIgc2l6ZUxpc3QgPSBoYXNCYXIgJiYgKDAsIF9DaGFydFV0aWxzLmdldEJhclNpemVMaXN0KSh7XHJcbiAgICAgICAgYmFyU2l6ZTogYmFyU2l6ZSxcclxuICAgICAgICBzdGFja0dyb3Vwczogc3RhY2tHcm91cHMsXHJcbiAgICAgICAgdG90YWxTaXplOiBnZXRDYXJ0ZXNpYW5BeGlzU2l6ZShheGlzT2JqLCBjYXRlQXhpc05hbWUpXHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoaXRlbUlzQmFyKSB7XHJcbiAgICAgICAgdmFyIF9yZWY3LCBfZ2V0QmFuZFNpemVPZkF4aXM7XHJcbiAgICAgICAgLy8gSWYgaXQgaXMgYmFyLCBjYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9mIGJhclxyXG4gICAgICAgIHZhciBtYXhCYXJTaXplID0gKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGNoaWxkTWF4QmFyU2l6ZSkgPyBnbG9iYWxNYXhCYXJTaXplIDogY2hpbGRNYXhCYXJTaXplO1xyXG4gICAgICAgIHZhciBiYXJCYW5kU2l6ZSA9IChfcmVmNyA9IChfZ2V0QmFuZFNpemVPZkF4aXMgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0QmFuZFNpemVPZkF4aXMpKGNhdGVBeGlzLCBjYXRlVGlja3MsIHRydWUpKSAhPT0gbnVsbCAmJiBfZ2V0QmFuZFNpemVPZkF4aXMgIT09IHZvaWQgMCA/IF9nZXRCYW5kU2l6ZU9mQXhpcyA6IG1heEJhclNpemUpICE9PSBudWxsICYmIF9yZWY3ICE9PSB2b2lkIDAgPyBfcmVmNyA6IDA7XHJcbiAgICAgICAgYmFyUG9zaXRpb24gPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0QmFyUG9zaXRpb24pKHtcclxuICAgICAgICAgIGJhckdhcDogYmFyR2FwLFxyXG4gICAgICAgICAgYmFyQ2F0ZWdvcnlHYXA6IGJhckNhdGVnb3J5R2FwLFxyXG4gICAgICAgICAgYmFuZFNpemU6IGJhckJhbmRTaXplICE9PSBiYW5kU2l6ZSA/IGJhckJhbmRTaXplIDogYmFuZFNpemUsXHJcbiAgICAgICAgICBzaXplTGlzdDogc2l6ZUxpc3RbY2F0ZUF4aXNJZF0sXHJcbiAgICAgICAgICBtYXhCYXJTaXplOiBtYXhCYXJTaXplXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGJhckJhbmRTaXplICE9PSBiYW5kU2l6ZSkge1xyXG4gICAgICAgICAgYmFyUG9zaXRpb24gPSBiYXJQb3NpdGlvbi5tYXAoZnVuY3Rpb24gKHBvcykge1xyXG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwb3MpLCB7fSwge1xyXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBvcy5wb3NpdGlvbiksIHt9LCB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHBvcy5wb3NpdGlvbi5vZmZzZXQgLSBiYXJCYW5kU2l6ZSAvIDJcclxuICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHdlIHNob3VsZCBzdG9wIHJlYWRpbmcgZGF0YSBmcm9tIFJlYWN0RWxlbWVudHNcclxuICAgICAgdmFyIGNvbXBvc2VkRm4gPSBpdGVtICYmIGl0ZW0udHlwZSAmJiBpdGVtLnR5cGUuZ2V0Q29tcG9zZWREYXRhO1xyXG4gICAgICBpZiAoY29tcG9zZWRGbikge1xyXG4gICAgICAgIGZvcm1hdHRlZEl0ZW1zLnB1c2goe1xyXG4gICAgICAgICAgcHJvcHM6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY29tcG9zZWRGbihfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGF4aXNPYmopLCB7fSwge1xyXG4gICAgICAgICAgICBkaXNwbGF5ZWREYXRhOiBkaXNwbGF5ZWREYXRhLFxyXG4gICAgICAgICAgICBwcm9wczogcHJvcHMsXHJcbiAgICAgICAgICAgIGRhdGFLZXk6IGRhdGFLZXksXHJcbiAgICAgICAgICAgIGl0ZW06IGl0ZW0sXHJcbiAgICAgICAgICAgIGJhbmRTaXplOiBiYW5kU2l6ZSxcclxuICAgICAgICAgICAgYmFyUG9zaXRpb246IGJhclBvc2l0aW9uLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcclxuICAgICAgICAgICAgc3RhY2tlZERhdGE6IHN0YWNrZWREYXRhLFxyXG4gICAgICAgICAgICBsYXlvdXQ6IGxheW91dCxcclxuICAgICAgICAgICAgZGF0YVN0YXJ0SW5kZXg6IGRhdGFTdGFydEluZGV4LFxyXG4gICAgICAgICAgICBkYXRhRW5kSW5kZXg6IGRhdGFFbmRJbmRleFxyXG4gICAgICAgICAgfSkpKSwge30sIF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KHtcclxuICAgICAgICAgICAga2V5OiBpdGVtLmtleSB8fCBcIml0ZW0tXCIuY29uY2F0KGluZGV4KVxyXG4gICAgICAgICAgfSwgbnVtZXJpY0F4aXNOYW1lLCBheGlzT2JqW251bWVyaWNBeGlzTmFtZV0pLCBjYXRlQXhpc05hbWUsIGF4aXNPYmpbY2F0ZUF4aXNOYW1lXSksIFwiYW5pbWF0aW9uSWRcIiwgdXBkYXRlSWQpKSxcclxuICAgICAgICAgIGNoaWxkSW5kZXg6ICgwLCBfUmVhY3RVdGlscy5wYXJzZUNoaWxkSW5kZXgpKGl0ZW0sIHByb3BzLmNoaWxkcmVuKSxcclxuICAgICAgICAgIGl0ZW06IGl0ZW1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZm9ybWF0dGVkSXRlbXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIEF4aXNNYXBzIGFyZSBleHBlbnNpdmUgdG8gcmVuZGVyIG9uIGxhcmdlIGRhdGEgc2V0c1xyXG4gICAqIHNvIHByb3ZpZGUgdGhlIGFiaWxpdHkgdG8gc3RvcmUgdGhlbSBpbiBzdGF0ZSBhbmQgb25seSB1cGRhdGUgdGhlbSB3aGVuIG5lY2Vzc2FyeVxyXG4gICAqIHRoZXkgYXJlIGRlcGVuZGVudCB1cG9uIHRoZSBzdGFydCBhbmQgZW5kIGluZGV4IG9mXHJcbiAgICogdGhlIGJydXNoIHNvIGl0J3MgaW1wb3J0YW50IHRoYXQgdGhpcyBtZXRob2QgaXMgY2FsbGVkIF9hZnRlcl9cclxuICAgKiB0aGUgc3RhdGUgaXMgdXBkYXRlZCB3aXRoIGFueSBuZXcgc3RhcnQvZW5kIGluZGljZXNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAgICAgICAgICBUaGUgcHJvcHMgb2JqZWN0IHRvIGJlIHVzZWQgZm9yIHVwZGF0aW5nIHRoZSBheGlzbWFwc1xyXG4gICAqIGRhdGFTdGFydEluZGV4OiBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIGRhdGEgc2VyaWVzIHdoZW4gYSBicnVzaCBpcyBhcHBsaWVkXHJcbiAgICogZGF0YUVuZEluZGV4OiBUaGUgZW5kIGluZGV4IG9mIHRoZSBkYXRhIHNlcmllcyB3aGVuIGEgYnJ1c2ggaXMgYXBwbGllZFxyXG4gICAqIHVwZGF0ZUlkOiBUaGUgdXBkYXRlIGlkXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHByZXZTdGF0ZSAgICAgIFByZXYgc3RhdGVcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHN0YXRlIE5ldyBzdGF0ZSB0byBzZXRcclxuICAgKi9cclxuICB2YXIgdXBkYXRlU3RhdGVPZkF4aXNNYXBzT2Zmc2V0QW5kU3RhY2tHcm91cHMgPSBmdW5jdGlvbiB1cGRhdGVTdGF0ZU9mQXhpc01hcHNPZmZzZXRBbmRTdGFja0dyb3VwcyhfcmVmOCwgcHJldlN0YXRlKSB7XHJcbiAgICB2YXIgcHJvcHMgPSBfcmVmOC5wcm9wcyxcclxuICAgICAgZGF0YVN0YXJ0SW5kZXggPSBfcmVmOC5kYXRhU3RhcnRJbmRleCxcclxuICAgICAgZGF0YUVuZEluZGV4ID0gX3JlZjguZGF0YUVuZEluZGV4LFxyXG4gICAgICB1cGRhdGVJZCA9IF9yZWY4LnVwZGF0ZUlkO1xyXG4gICAgaWYgKCEoMCwgX1JlYWN0VXRpbHMudmFsaWRhdGVXaWR0aEhlaWdodCkoe1xyXG4gICAgICBwcm9wczogcHJvcHNcclxuICAgIH0pKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXHJcbiAgICAgIGxheW91dCA9IHByb3BzLmxheW91dCxcclxuICAgICAgc3RhY2tPZmZzZXQgPSBwcm9wcy5zdGFja09mZnNldCxcclxuICAgICAgZGF0YSA9IHByb3BzLmRhdGEsXHJcbiAgICAgIHJldmVyc2VTdGFja09yZGVyID0gcHJvcHMucmV2ZXJzZVN0YWNrT3JkZXI7XHJcbiAgICB2YXIgX2dldEF4aXNOYW1lQnlMYXlvdXQyID0gZ2V0QXhpc05hbWVCeUxheW91dChsYXlvdXQpLFxyXG4gICAgICBudW1lcmljQXhpc05hbWUgPSBfZ2V0QXhpc05hbWVCeUxheW91dDIubnVtZXJpY0F4aXNOYW1lLFxyXG4gICAgICBjYXRlQXhpc05hbWUgPSBfZ2V0QXhpc05hbWVCeUxheW91dDIuY2F0ZUF4aXNOYW1lO1xyXG4gICAgdmFyIGdyYXBoaWNhbEl0ZW1zID0gKDAsIF9SZWFjdFV0aWxzLmZpbmRBbGxCeVR5cGUpKGNoaWxkcmVuLCBHcmFwaGljYWxDaGlsZCk7XHJcbiAgICB2YXIgc3RhY2tHcm91cHMgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0U3RhY2tHcm91cHNCeUF4aXNJZCkoZGF0YSwgZ3JhcGhpY2FsSXRlbXMsIFwiXCIuY29uY2F0KG51bWVyaWNBeGlzTmFtZSwgXCJJZFwiKSwgXCJcIi5jb25jYXQoY2F0ZUF4aXNOYW1lLCBcIklkXCIpLCBzdGFja09mZnNldCwgcmV2ZXJzZVN0YWNrT3JkZXIpO1xyXG4gICAgdmFyIGF4aXNPYmogPSBheGlzQ29tcG9uZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgZW50cnkpIHtcclxuICAgICAgdmFyIG5hbWUgPSBcIlwiLmNvbmNhdChlbnRyeS5heGlzVHlwZSwgXCJNYXBcIik7XHJcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlc3VsdCksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIG5hbWUsIGdldEF4aXNNYXAocHJvcHMsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xyXG4gICAgICAgIGdyYXBoaWNhbEl0ZW1zOiBncmFwaGljYWxJdGVtcyxcclxuICAgICAgICBzdGFja0dyb3VwczogZW50cnkuYXhpc1R5cGUgPT09IG51bWVyaWNBeGlzTmFtZSAmJiBzdGFja0dyb3VwcyxcclxuICAgICAgICBkYXRhU3RhcnRJbmRleDogZGF0YVN0YXJ0SW5kZXgsXHJcbiAgICAgICAgZGF0YUVuZEluZGV4OiBkYXRhRW5kSW5kZXhcclxuICAgICAgfSkpKSk7XHJcbiAgICB9LCB7fSk7XHJcbiAgICB2YXIgb2Zmc2V0ID0gY2FsY3VsYXRlT2Zmc2V0KF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgYXhpc09iaiksIHt9LCB7XHJcbiAgICAgIHByb3BzOiBwcm9wcyxcclxuICAgICAgZ3JhcGhpY2FsSXRlbXM6IGdyYXBoaWNhbEl0ZW1zXHJcbiAgICB9KSwgcHJldlN0YXRlID09PSBudWxsIHx8IHByZXZTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldlN0YXRlLmxlZ2VuZEJCb3gpO1xyXG4gICAgT2JqZWN0LmtleXMoYXhpc09iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIGF4aXNPYmpba2V5XSA9IGZvcm1hdEF4aXNNYXAocHJvcHMsIGF4aXNPYmpba2V5XSwgb2Zmc2V0LCBrZXkucmVwbGFjZSgnTWFwJywgJycpLCBjaGFydE5hbWUpO1xyXG4gICAgfSk7XHJcbiAgICB2YXIgY2F0ZUF4aXNNYXAgPSBheGlzT2JqW1wiXCIuY29uY2F0KGNhdGVBeGlzTmFtZSwgXCJNYXBcIildO1xyXG4gICAgdmFyIHRpY2tzT2JqID0gdG9vbHRpcFRpY2tzR2VuZXJhdG9yKGNhdGVBeGlzTWFwKTtcclxuICAgIHZhciBmb3JtYXR0ZWRHcmFwaGljYWxJdGVtcyA9IGdldEZvcm1hdEl0ZW1zKHByb3BzLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGF4aXNPYmopLCB7fSwge1xyXG4gICAgICBkYXRhU3RhcnRJbmRleDogZGF0YVN0YXJ0SW5kZXgsXHJcbiAgICAgIGRhdGFFbmRJbmRleDogZGF0YUVuZEluZGV4LFxyXG4gICAgICB1cGRhdGVJZDogdXBkYXRlSWQsXHJcbiAgICAgIGdyYXBoaWNhbEl0ZW1zOiBncmFwaGljYWxJdGVtcyxcclxuICAgICAgc3RhY2tHcm91cHM6IHN0YWNrR3JvdXBzLFxyXG4gICAgICBvZmZzZXQ6IG9mZnNldFxyXG4gICAgfSkpO1xyXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XHJcbiAgICAgIGZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zOiBmb3JtYXR0ZWRHcmFwaGljYWxJdGVtcyxcclxuICAgICAgZ3JhcGhpY2FsSXRlbXM6IGdyYXBoaWNhbEl0ZW1zLFxyXG4gICAgICBvZmZzZXQ6IG9mZnNldCxcclxuICAgICAgc3RhY2tHcm91cHM6IHN0YWNrR3JvdXBzXHJcbiAgICB9LCB0aWNrc09iaiksIGF4aXNPYmopO1xyXG4gIH07XHJcbiAgdmFyIENhdGVnb3JpY2FsQ2hhcnRXcmFwcGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29tcG9uZW50KSB7XHJcbiAgICBmdW5jdGlvbiBDYXRlZ29yaWNhbENoYXJ0V3JhcHBlcihfcHJvcHMpIHtcclxuICAgICAgdmFyIF9wcm9wcyRpZCwgX3Byb3BzJHRocm90dGxlRGVsYXk7XHJcbiAgICAgIHZhciBfdGhpcztcclxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhdGVnb3JpY2FsQ2hhcnRXcmFwcGVyKTtcclxuICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIENhdGVnb3JpY2FsQ2hhcnRXcmFwcGVyLCBbX3Byb3BzXSk7XHJcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJldmVudEVtaXR0ZXJTeW1ib2xcIiwgU3ltYm9sKCdyZWNoYXJ0c0V2ZW50RW1pdHRlcicpKTtcclxuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImFjY2Vzc2liaWxpdHlNYW5hZ2VyXCIsIG5ldyBfQWNjZXNzaWJpbGl0eU1hbmFnZXIuQWNjZXNzaWJpbGl0eU1hbmFnZXIoKSk7XHJcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVMZWdlbmRCQm94VXBkYXRlXCIsIGZ1bmN0aW9uIChib3gpIHtcclxuICAgICAgICBpZiAoYm94KSB7XHJcbiAgICAgICAgICB2YXIgX3RoaXMkc3RhdGUgPSBfdGhpcy5zdGF0ZSxcclxuICAgICAgICAgICAgZGF0YVN0YXJ0SW5kZXggPSBfdGhpcyRzdGF0ZS5kYXRhU3RhcnRJbmRleCxcclxuICAgICAgICAgICAgZGF0YUVuZEluZGV4ID0gX3RoaXMkc3RhdGUuZGF0YUVuZEluZGV4LFxyXG4gICAgICAgICAgICB1cGRhdGVJZCA9IF90aGlzJHN0YXRlLnVwZGF0ZUlkO1xyXG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoX29iamVjdFNwcmVhZCh7XHJcbiAgICAgICAgICAgIGxlZ2VuZEJCb3g6IGJveFxyXG4gICAgICAgICAgfSwgdXBkYXRlU3RhdGVPZkF4aXNNYXBzT2Zmc2V0QW5kU3RhY2tHcm91cHMoe1xyXG4gICAgICAgICAgICBwcm9wczogX3RoaXMucHJvcHMsXHJcbiAgICAgICAgICAgIGRhdGFTdGFydEluZGV4OiBkYXRhU3RhcnRJbmRleCxcclxuICAgICAgICAgICAgZGF0YUVuZEluZGV4OiBkYXRhRW5kSW5kZXgsXHJcbiAgICAgICAgICAgIHVwZGF0ZUlkOiB1cGRhdGVJZFxyXG4gICAgICAgICAgfSwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfdGhpcy5zdGF0ZSksIHt9LCB7XHJcbiAgICAgICAgICAgIGxlZ2VuZEJCb3g6IGJveFxyXG4gICAgICAgICAgfSkpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZVJlY2VpdmVTeW5jRXZlbnRcIiwgZnVuY3Rpb24gKGNJZCwgZGF0YSwgZW1pdHRlcikge1xyXG4gICAgICAgIGlmIChfdGhpcy5wcm9wcy5zeW5jSWQgPT09IGNJZCkge1xyXG4gICAgICAgICAgaWYgKGVtaXR0ZXIgPT09IF90aGlzLmV2ZW50RW1pdHRlclN5bWJvbCAmJiB0eXBlb2YgX3RoaXMucHJvcHMuc3luY01ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBfdGhpcy5hcHBseVN5bmNFdmVudChkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlQnJ1c2hDaGFuZ2VcIiwgZnVuY3Rpb24gKF9yZWY5KSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBfcmVmOS5zdGFydEluZGV4LFxyXG4gICAgICAgICAgZW5kSW5kZXggPSBfcmVmOS5lbmRJbmRleDtcclxuICAgICAgICAvLyBPbmx5IHRyaWdnZXIgY2hhbmdlcyBpZiB0aGUgZXh0ZW50cyBvZiB0aGUgYnJ1c2ggaGF2ZSBhY3R1YWxseSBjaGFuZ2VkXHJcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggIT09IF90aGlzLnN0YXRlLmRhdGFTdGFydEluZGV4IHx8IGVuZEluZGV4ICE9PSBfdGhpcy5zdGF0ZS5kYXRhRW5kSW5kZXgpIHtcclxuICAgICAgICAgIHZhciB1cGRhdGVJZCA9IF90aGlzLnN0YXRlLnVwZGF0ZUlkO1xyXG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7XHJcbiAgICAgICAgICAgICAgZGF0YVN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXgsXHJcbiAgICAgICAgICAgICAgZGF0YUVuZEluZGV4OiBlbmRJbmRleFxyXG4gICAgICAgICAgICB9LCB1cGRhdGVTdGF0ZU9mQXhpc01hcHNPZmZzZXRBbmRTdGFja0dyb3Vwcyh7XHJcbiAgICAgICAgICAgICAgcHJvcHM6IF90aGlzLnByb3BzLFxyXG4gICAgICAgICAgICAgIGRhdGFTdGFydEluZGV4OiBzdGFydEluZGV4LFxyXG4gICAgICAgICAgICAgIGRhdGFFbmRJbmRleDogZW5kSW5kZXgsXHJcbiAgICAgICAgICAgICAgdXBkYXRlSWQ6IHVwZGF0ZUlkXHJcbiAgICAgICAgICAgIH0sIF90aGlzLnN0YXRlKSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIF90aGlzLnRyaWdnZXJTeW5jRXZlbnQoe1xyXG4gICAgICAgICAgICBkYXRhU3RhcnRJbmRleDogc3RhcnRJbmRleCxcclxuICAgICAgICAgICAgZGF0YUVuZEluZGV4OiBlbmRJbmRleFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFRoZSBoYW5kbGVyIG9mIG1vdXNlIGVudGVyaW5nIGNoYXJ0XHJcbiAgICAgICAqIEBwYXJhbSAge09iamVjdH0gZSAgICAgICAgICAgICAgRXZlbnQgb2JqZWN0XHJcbiAgICAgICAqIEByZXR1cm4ge051bGx9ICAgICAgICAgICAgICAgICAgbnVsbFxyXG4gICAgICAgKi9cclxuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZU1vdXNlRW50ZXJcIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICB2YXIgbW91c2UgPSBfdGhpcy5nZXRNb3VzZUluZm8oZSk7XHJcbiAgICAgICAgaWYgKG1vdXNlKSB7XHJcbiAgICAgICAgICB2YXIgX25leHRTdGF0ZSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbW91c2UpLCB7fSwge1xyXG4gICAgICAgICAgICBpc1Rvb2x0aXBBY3RpdmU6IHRydWVcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoX25leHRTdGF0ZSk7XHJcbiAgICAgICAgICBfdGhpcy50cmlnZ2VyU3luY0V2ZW50KF9uZXh0U3RhdGUpO1xyXG4gICAgICAgICAgdmFyIG9uTW91c2VFbnRlciA9IF90aGlzLnByb3BzLm9uTW91c2VFbnRlcjtcclxuICAgICAgICAgIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvbk1vdXNlRW50ZXIpKSB7XHJcbiAgICAgICAgICAgIG9uTW91c2VFbnRlcihfbmV4dFN0YXRlLCBlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwidHJpZ2dlcmVkQWZ0ZXJNb3VzZU1vdmVcIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICB2YXIgbW91c2UgPSBfdGhpcy5nZXRNb3VzZUluZm8oZSk7XHJcbiAgICAgICAgdmFyIG5leHRTdGF0ZSA9IG1vdXNlID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBtb3VzZSksIHt9LCB7XHJcbiAgICAgICAgICBpc1Rvb2x0aXBBY3RpdmU6IHRydWVcclxuICAgICAgICB9KSA6IHtcclxuICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogZmFsc2VcclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLnNldFN0YXRlKG5leHRTdGF0ZSk7XHJcbiAgICAgICAgX3RoaXMudHJpZ2dlclN5bmNFdmVudChuZXh0U3RhdGUpO1xyXG4gICAgICAgIHZhciBvbk1vdXNlTW92ZSA9IF90aGlzLnByb3BzLm9uTW91c2VNb3ZlO1xyXG4gICAgICAgIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvbk1vdXNlTW92ZSkpIHtcclxuICAgICAgICAgIG9uTW91c2VNb3ZlKG5leHRTdGF0ZSwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFRoZSBoYW5kbGVyIG9mIG1vdXNlIGVudGVyaW5nIGEgc2NhdHRlclxyXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWwgVGhlIGFjdGl2ZSBzY2F0dGVyXHJcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gbm8gcmV0dXJuXHJcbiAgICAgICAqL1xyXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlSXRlbU1vdXNlRW50ZXJcIiwgZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaXNUb29sdGlwQWN0aXZlOiB0cnVlLFxyXG4gICAgICAgICAgICBhY3RpdmVJdGVtOiBlbCxcclxuICAgICAgICAgICAgYWN0aXZlUGF5bG9hZDogZWwudG9vbHRpcFBheWxvYWQsXHJcbiAgICAgICAgICAgIGFjdGl2ZUNvb3JkaW5hdGU6IGVsLnRvb2x0aXBQb3NpdGlvbiB8fCB7XHJcbiAgICAgICAgICAgICAgeDogZWwuY3gsXHJcbiAgICAgICAgICAgICAgeTogZWwuY3lcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBUaGUgaGFuZGxlciBvZiBtb3VzZSBsZWF2aW5nIGEgc2NhdHRlclxyXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG5vIHJldHVyblxyXG4gICAgICAgKi9cclxuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZUl0ZW1Nb3VzZUxlYXZlXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpc1Rvb2x0aXBBY3RpdmU6IGZhbHNlXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFRoZSBoYW5kbGVyIG9mIG1vdXNlIG1vdmluZyBpbiBjaGFydFxyXG4gICAgICAgKiBAcGFyYW0gIHtSZWFjdC5Nb3VzZUV2ZW50fSBlICAgICAgICBFdmVudCBvYmplY3RcclxuICAgICAgICogQHJldHVybiB7dm9pZH0gbm8gcmV0dXJuXHJcbiAgICAgICAqL1xyXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlTW91c2VNb3ZlXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgZS5wZXJzaXN0KCk7XHJcbiAgICAgICAgX3RoaXMudGhyb3R0bGVUcmlnZ2VyZWRBZnRlck1vdXNlTW92ZShlKTtcclxuICAgICAgfSk7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBUaGUgaGFuZGxlciBpZiBtb3VzZSBsZWF2aW5nIGNoYXJ0XHJcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlIEV2ZW50IG9iamVjdFxyXG4gICAgICAgKiBAcmV0dXJuIHtOdWxsfSBubyByZXR1cm5cclxuICAgICAgICovXHJcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVNb3VzZUxlYXZlXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgX3RoaXMudGhyb3R0bGVUcmlnZ2VyZWRBZnRlck1vdXNlTW92ZS5jYW5jZWwoKTtcclxuICAgICAgICB2YXIgbmV4dFN0YXRlID0ge1xyXG4gICAgICAgICAgaXNUb29sdGlwQWN0aXZlOiBmYWxzZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUobmV4dFN0YXRlKTtcclxuICAgICAgICBfdGhpcy50cmlnZ2VyU3luY0V2ZW50KG5leHRTdGF0ZSk7XHJcbiAgICAgICAgdmFyIG9uTW91c2VMZWF2ZSA9IF90aGlzLnByb3BzLm9uTW91c2VMZWF2ZTtcclxuICAgICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob25Nb3VzZUxlYXZlKSkge1xyXG4gICAgICAgICAgb25Nb3VzZUxlYXZlKG5leHRTdGF0ZSwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZU91dGVyRXZlbnRcIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICB2YXIgZXZlbnROYW1lID0gKDAsIF9SZWFjdFV0aWxzLmdldFJlYWN0RXZlbnRCeVR5cGUpKGUpO1xyXG4gICAgICAgIHZhciBldmVudCA9ICgwLCBfZ2V0W1wiZGVmYXVsdFwiXSkoX3RoaXMucHJvcHMsIFwiXCIuY29uY2F0KGV2ZW50TmFtZSkpO1xyXG4gICAgICAgIGlmIChldmVudE5hbWUgJiYgKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkoZXZlbnQpKSB7XHJcbiAgICAgICAgICB2YXIgX21vdXNlO1xyXG4gICAgICAgICAgdmFyIG1vdXNlO1xyXG4gICAgICAgICAgaWYgKC8uKnRvdWNoLiovaS50ZXN0KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgbW91c2UgPSBfdGhpcy5nZXRNb3VzZUluZm8oZS5jaGFuZ2VkVG91Y2hlc1swXSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtb3VzZSA9IF90aGlzLmdldE1vdXNlSW5mbyhlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGV2ZW50KChfbW91c2UgPSBtb3VzZSkgIT09IG51bGwgJiYgX21vdXNlICE9PSB2b2lkIDAgPyBfbW91c2UgOiB7fSwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZUNsaWNrXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgdmFyIG1vdXNlID0gX3RoaXMuZ2V0TW91c2VJbmZvKGUpO1xyXG4gICAgICAgIGlmIChtb3VzZSkge1xyXG4gICAgICAgICAgdmFyIF9uZXh0U3RhdGUyID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBtb3VzZSksIHt9LCB7XHJcbiAgICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogdHJ1ZVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShfbmV4dFN0YXRlMik7XHJcbiAgICAgICAgICBfdGhpcy50cmlnZ2VyU3luY0V2ZW50KF9uZXh0U3RhdGUyKTtcclxuICAgICAgICAgIHZhciBvbkNsaWNrID0gX3RoaXMucHJvcHMub25DbGljaztcclxuICAgICAgICAgIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvbkNsaWNrKSkge1xyXG4gICAgICAgICAgICBvbkNsaWNrKF9uZXh0U3RhdGUyLCBlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlTW91c2VEb3duXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgdmFyIG9uTW91c2VEb3duID0gX3RoaXMucHJvcHMub25Nb3VzZURvd247XHJcbiAgICAgICAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9uTW91c2VEb3duKSkge1xyXG4gICAgICAgICAgdmFyIF9uZXh0U3RhdGUzID0gX3RoaXMuZ2V0TW91c2VJbmZvKGUpO1xyXG4gICAgICAgICAgb25Nb3VzZURvd24oX25leHRTdGF0ZTMsIGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVNb3VzZVVwXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgdmFyIG9uTW91c2VVcCA9IF90aGlzLnByb3BzLm9uTW91c2VVcDtcclxuICAgICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob25Nb3VzZVVwKSkge1xyXG4gICAgICAgICAgdmFyIF9uZXh0U3RhdGU0ID0gX3RoaXMuZ2V0TW91c2VJbmZvKGUpO1xyXG4gICAgICAgICAgb25Nb3VzZVVwKF9uZXh0U3RhdGU0LCBlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlVG91Y2hNb3ZlXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgaWYgKGUuY2hhbmdlZFRvdWNoZXMgIT0gbnVsbCAmJiBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIF90aGlzLnRocm90dGxlVHJpZ2dlcmVkQWZ0ZXJNb3VzZU1vdmUoZS5jaGFuZ2VkVG91Y2hlc1swXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZVRvdWNoU3RhcnRcIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBpZiAoZS5jaGFuZ2VkVG91Y2hlcyAhPSBudWxsICYmIGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgX3RoaXMuaGFuZGxlTW91c2VEb3duKGUuY2hhbmdlZFRvdWNoZXNbMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVUb3VjaEVuZFwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGlmIChlLmNoYW5nZWRUb3VjaGVzICE9IG51bGwgJiYgZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBfdGhpcy5oYW5kbGVNb3VzZVVwKGUuY2hhbmdlZFRvdWNoZXNbMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVEb3VibGVDbGlja1wiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHZhciBvbkRvdWJsZUNsaWNrID0gX3RoaXMucHJvcHMub25Eb3VibGVDbGljaztcclxuICAgICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob25Eb3VibGVDbGljaykpIHtcclxuICAgICAgICAgIHZhciBfbmV4dFN0YXRlNSA9IF90aGlzLmdldE1vdXNlSW5mbyhlKTtcclxuICAgICAgICAgIG9uRG91YmxlQ2xpY2soX25leHRTdGF0ZTUsIGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVDb250ZXh0TWVudVwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHZhciBvbkNvbnRleHRNZW51ID0gX3RoaXMucHJvcHMub25Db250ZXh0TWVudTtcclxuICAgICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob25Db250ZXh0TWVudSkpIHtcclxuICAgICAgICAgIHZhciBfbmV4dFN0YXRlNiA9IF90aGlzLmdldE1vdXNlSW5mbyhlKTtcclxuICAgICAgICAgIG9uQ29udGV4dE1lbnUoX25leHRTdGF0ZTYsIGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ0cmlnZ2VyU3luY0V2ZW50XCIsIGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgaWYgKF90aGlzLnByb3BzLnN5bmNJZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBfRXZlbnRzLmV2ZW50Q2VudGVyLmVtaXQoX0V2ZW50cy5TWU5DX0VWRU5ULCBfdGhpcy5wcm9wcy5zeW5jSWQsIGRhdGEsIF90aGlzLmV2ZW50RW1pdHRlclN5bWJvbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImFwcGx5U3luY0V2ZW50XCIsIGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsXHJcbiAgICAgICAgICBsYXlvdXQgPSBfdGhpcyRwcm9wcy5sYXlvdXQsXHJcbiAgICAgICAgICBzeW5jTWV0aG9kID0gX3RoaXMkcHJvcHMuc3luY01ldGhvZDtcclxuICAgICAgICB2YXIgdXBkYXRlSWQgPSBfdGhpcy5zdGF0ZS51cGRhdGVJZDtcclxuICAgICAgICB2YXIgZGF0YVN0YXJ0SW5kZXggPSBkYXRhLmRhdGFTdGFydEluZGV4LFxyXG4gICAgICAgICAgZGF0YUVuZEluZGV4ID0gZGF0YS5kYXRhRW5kSW5kZXg7XHJcbiAgICAgICAgaWYgKGRhdGEuZGF0YVN0YXJ0SW5kZXggIT09IHVuZGVmaW5lZCB8fCBkYXRhLmRhdGFFbmRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShfb2JqZWN0U3ByZWFkKHtcclxuICAgICAgICAgICAgZGF0YVN0YXJ0SW5kZXg6IGRhdGFTdGFydEluZGV4LFxyXG4gICAgICAgICAgICBkYXRhRW5kSW5kZXg6IGRhdGFFbmRJbmRleFxyXG4gICAgICAgICAgfSwgdXBkYXRlU3RhdGVPZkF4aXNNYXBzT2Zmc2V0QW5kU3RhY2tHcm91cHMoe1xyXG4gICAgICAgICAgICBwcm9wczogX3RoaXMucHJvcHMsXHJcbiAgICAgICAgICAgIGRhdGFTdGFydEluZGV4OiBkYXRhU3RhcnRJbmRleCxcclxuICAgICAgICAgICAgZGF0YUVuZEluZGV4OiBkYXRhRW5kSW5kZXgsXHJcbiAgICAgICAgICAgIHVwZGF0ZUlkOiB1cGRhdGVJZFxyXG4gICAgICAgICAgfSwgX3RoaXMuc3RhdGUpKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmFjdGl2ZVRvb2x0aXBJbmRleCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB2YXIgY2hhcnRYID0gZGF0YS5jaGFydFgsXHJcbiAgICAgICAgICAgIGNoYXJ0WSA9IGRhdGEuY2hhcnRZO1xyXG4gICAgICAgICAgdmFyIGFjdGl2ZVRvb2x0aXBJbmRleCA9IGRhdGEuYWN0aXZlVG9vbHRpcEluZGV4O1xyXG4gICAgICAgICAgdmFyIF90aGlzJHN0YXRlMiA9IF90aGlzLnN0YXRlLFxyXG4gICAgICAgICAgICBvZmZzZXQgPSBfdGhpcyRzdGF0ZTIub2Zmc2V0LFxyXG4gICAgICAgICAgICB0b29sdGlwVGlja3MgPSBfdGhpcyRzdGF0ZTIudG9vbHRpcFRpY2tzO1xyXG4gICAgICAgICAgaWYgKCFvZmZzZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBzeW5jTWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIC8vIENhbGwgYSBjYWxsYmFjayBmdW5jdGlvbi4gSWYgdGhlcmUgaXMgYW4gYXBwbGljYXRpb24gc3BlY2lmaWMgYWxnb3JpdGhtXHJcbiAgICAgICAgICAgIGFjdGl2ZVRvb2x0aXBJbmRleCA9IHN5bmNNZXRob2QodG9vbHRpcFRpY2tzLCBkYXRhKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoc3luY01ldGhvZCA9PT0gJ3ZhbHVlJykge1xyXG4gICAgICAgICAgICAvLyBTZXQgYWN0aXZlVG9vbHRpcEluZGV4IHRvIHRoZSBpbmRleCB3aXRoIHRoZSBzYW1lIHZhbHVlIGFzIGRhdGEuYWN0aXZlTGFiZWxcclxuICAgICAgICAgICAgLy8gRm9yIGxvb3AgaW5zdGVhZCBvZiBmaW5kSW5kZXggYmVjYXVzZSB0aGUgbGF0dGVyIGlzIHZlcnkgc2xvdyBpbiBzb21lIGJyb3dzZXJzXHJcbiAgICAgICAgICAgIGFjdGl2ZVRvb2x0aXBJbmRleCA9IC0xOyAvLyBpbiBjYXNlIHdlIGNhbm5vdCBmaW5kIHRoZSBlbGVtZW50XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9vbHRpcFRpY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHRvb2x0aXBUaWNrc1tpXS52YWx1ZSA9PT0gZGF0YS5hY3RpdmVMYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlVG9vbHRpcEluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFyIHZpZXdCb3ggPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9mZnNldCksIHt9LCB7XHJcbiAgICAgICAgICAgIHg6IG9mZnNldC5sZWZ0LFxyXG4gICAgICAgICAgICB5OiBvZmZzZXQudG9wXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIC8vIFdoZW4gYSBjYXRlZ29yaWNhbCBjaGFydCBpcyBjb21iaW5lZCB3aXRoIGFub3RoZXIgY2hhcnQsIHRoZSB2YWx1ZSBvZiBjaGFydFhcclxuICAgICAgICAgIC8vIGFuZCBjaGFydFkgbWF5IGJleW9uZCB0aGUgYm91bmRhcmllcy5cclxuICAgICAgICAgIHZhciB2YWxpZGF0ZUNoYXJ0WCA9IE1hdGgubWluKGNoYXJ0WCwgdmlld0JveC54ICsgdmlld0JveC53aWR0aCk7XHJcbiAgICAgICAgICB2YXIgdmFsaWRhdGVDaGFydFkgPSBNYXRoLm1pbihjaGFydFksIHZpZXdCb3gueSArIHZpZXdCb3guaGVpZ2h0KTtcclxuICAgICAgICAgIHZhciBhY3RpdmVMYWJlbCA9IHRvb2x0aXBUaWNrc1thY3RpdmVUb29sdGlwSW5kZXhdICYmIHRvb2x0aXBUaWNrc1thY3RpdmVUb29sdGlwSW5kZXhdLnZhbHVlO1xyXG4gICAgICAgICAgdmFyIGFjdGl2ZVBheWxvYWQgPSBnZXRUb29sdGlwQ29udGVudChfdGhpcy5zdGF0ZSwgX3RoaXMucHJvcHMuZGF0YSwgYWN0aXZlVG9vbHRpcEluZGV4KTtcclxuICAgICAgICAgIHZhciBhY3RpdmVDb29yZGluYXRlID0gdG9vbHRpcFRpY2tzW2FjdGl2ZVRvb2x0aXBJbmRleF0gPyB7XHJcbiAgICAgICAgICAgIHg6IGxheW91dCA9PT0gJ2hvcml6b250YWwnID8gdG9vbHRpcFRpY2tzW2FjdGl2ZVRvb2x0aXBJbmRleF0uY29vcmRpbmF0ZSA6IHZhbGlkYXRlQ2hhcnRYLFxyXG4gICAgICAgICAgICB5OiBsYXlvdXQgPT09ICdob3Jpem9udGFsJyA/IHZhbGlkYXRlQ2hhcnRZIDogdG9vbHRpcFRpY2tzW2FjdGl2ZVRvb2x0aXBJbmRleF0uY29vcmRpbmF0ZVxyXG4gICAgICAgICAgfSA6IG9yaWdpbkNvb3JkaW5hdGU7XHJcbiAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRhdGEpLCB7fSwge1xyXG4gICAgICAgICAgICBhY3RpdmVMYWJlbDogYWN0aXZlTGFiZWwsXHJcbiAgICAgICAgICAgIGFjdGl2ZUNvb3JkaW5hdGU6IGFjdGl2ZUNvb3JkaW5hdGUsXHJcbiAgICAgICAgICAgIGFjdGl2ZVBheWxvYWQ6IGFjdGl2ZVBheWxvYWQsXHJcbiAgICAgICAgICAgIGFjdGl2ZVRvb2x0aXBJbmRleDogYWN0aXZlVG9vbHRpcEluZGV4XHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIF90aGlzLnNldFN0YXRlKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyZW5kZXJDdXJzb3JcIiwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgX2VsZW1lbnQkcHJvcHMkYWN0aXZlO1xyXG4gICAgICAgIHZhciBfdGhpcyRzdGF0ZTMgPSBfdGhpcy5zdGF0ZSxcclxuICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZSA9IF90aGlzJHN0YXRlMy5pc1Rvb2x0aXBBY3RpdmUsXHJcbiAgICAgICAgICBhY3RpdmVDb29yZGluYXRlID0gX3RoaXMkc3RhdGUzLmFjdGl2ZUNvb3JkaW5hdGUsXHJcbiAgICAgICAgICBhY3RpdmVQYXlsb2FkID0gX3RoaXMkc3RhdGUzLmFjdGl2ZVBheWxvYWQsXHJcbiAgICAgICAgICBvZmZzZXQgPSBfdGhpcyRzdGF0ZTMub2Zmc2V0LFxyXG4gICAgICAgICAgYWN0aXZlVG9vbHRpcEluZGV4ID0gX3RoaXMkc3RhdGUzLmFjdGl2ZVRvb2x0aXBJbmRleCxcclxuICAgICAgICAgIHRvb2x0aXBBeGlzQmFuZFNpemUgPSBfdGhpcyRzdGF0ZTMudG9vbHRpcEF4aXNCYW5kU2l6ZTtcclxuICAgICAgICB2YXIgdG9vbHRpcEV2ZW50VHlwZSA9IF90aGlzLmdldFRvb2x0aXBFdmVudFR5cGUoKTtcclxuICAgICAgICAvLyBUaGUgY3Vyc29yIGlzIGEgcGFydCBvZiB0aGUgVG9vbHRpcCwgYW5kIGl0IHNob3VsZCBiZSBzaG93biAoYnkgZGVmYXVsdCkgd2hlbiB0aGUgVG9vbHRpcCBpcyBhY3RpdmUuXHJcbiAgICAgICAgdmFyIGlzQWN0aXZlID0gKF9lbGVtZW50JHByb3BzJGFjdGl2ZSA9IGVsZW1lbnQucHJvcHMuYWN0aXZlKSAhPT0gbnVsbCAmJiBfZWxlbWVudCRwcm9wcyRhY3RpdmUgIT09IHZvaWQgMCA/IF9lbGVtZW50JHByb3BzJGFjdGl2ZSA6IGlzVG9vbHRpcEFjdGl2ZTtcclxuICAgICAgICB2YXIgbGF5b3V0ID0gX3RoaXMucHJvcHMubGF5b3V0O1xyXG4gICAgICAgIHZhciBrZXkgPSBlbGVtZW50LmtleSB8fCAnX3JlY2hhcnRzLWN1cnNvcic7XHJcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0N1cnNvci5DdXJzb3IsIHtcclxuICAgICAgICAgIGtleToga2V5LFxyXG4gICAgICAgICAgYWN0aXZlQ29vcmRpbmF0ZTogYWN0aXZlQ29vcmRpbmF0ZSxcclxuICAgICAgICAgIGFjdGl2ZVBheWxvYWQ6IGFjdGl2ZVBheWxvYWQsXHJcbiAgICAgICAgICBhY3RpdmVUb29sdGlwSW5kZXg6IGFjdGl2ZVRvb2x0aXBJbmRleCxcclxuICAgICAgICAgIGNoYXJ0TmFtZTogY2hhcnROYW1lLFxyXG4gICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcclxuICAgICAgICAgIGlzQWN0aXZlOiBpc0FjdGl2ZSxcclxuICAgICAgICAgIGxheW91dDogbGF5b3V0LFxyXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXHJcbiAgICAgICAgICB0b29sdGlwQXhpc0JhbmRTaXplOiB0b29sdGlwQXhpc0JhbmRTaXplLFxyXG4gICAgICAgICAgdG9vbHRpcEV2ZW50VHlwZTogdG9vbHRpcEV2ZW50VHlwZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInJlbmRlclBvbGFyQXhpc1wiLCBmdW5jdGlvbiAoZWxlbWVudCwgZGlzcGxheU5hbWUsIGluZGV4KSB7XHJcbiAgICAgICAgdmFyIGF4aXNUeXBlID0gKDAsIF9nZXRbXCJkZWZhdWx0XCJdKShlbGVtZW50LCAndHlwZS5heGlzVHlwZScpO1xyXG4gICAgICAgIHZhciBheGlzTWFwID0gKDAsIF9nZXRbXCJkZWZhdWx0XCJdKShfdGhpcy5zdGF0ZSwgXCJcIi5jb25jYXQoYXhpc1R5cGUsIFwiTWFwXCIpKTtcclxuICAgICAgICB2YXIgZWxlbWVudERlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRQcm9wcyA9IGVsZW1lbnREZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZWxlbWVudERlZmF1bHRQcm9wcyksIGVsZW1lbnQucHJvcHMpIDogZWxlbWVudC5wcm9wcztcclxuICAgICAgICB2YXIgYXhpc09wdGlvbiA9IGF4aXNNYXAgJiYgYXhpc01hcFtlbGVtZW50UHJvcHNbXCJcIi5jb25jYXQoYXhpc1R5cGUsIFwiSWRcIildXTtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLygwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShlbGVtZW50LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGF4aXNPcHRpb24pLCB7fSwge1xyXG4gICAgICAgICAgY2xhc3NOYW1lOiAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKShheGlzVHlwZSwgYXhpc09wdGlvbi5jbGFzc05hbWUpLFxyXG4gICAgICAgICAga2V5OiBlbGVtZW50LmtleSB8fCBcIlwiLmNvbmNhdChkaXNwbGF5TmFtZSwgXCItXCIpLmNvbmNhdChpbmRleCksXHJcbiAgICAgICAgICB0aWNrczogKDAsIF9DaGFydFV0aWxzLmdldFRpY2tzT2ZBeGlzKShheGlzT3B0aW9uLCB0cnVlKVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgfSk7XHJcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyZW5kZXJQb2xhckdyaWRcIiwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgX2VsZW1lbnQkcHJvcHMgPSBlbGVtZW50LnByb3BzLFxyXG4gICAgICAgICAgcmFkaWFsTGluZXMgPSBfZWxlbWVudCRwcm9wcy5yYWRpYWxMaW5lcyxcclxuICAgICAgICAgIHBvbGFyQW5nbGVzID0gX2VsZW1lbnQkcHJvcHMucG9sYXJBbmdsZXMsXHJcbiAgICAgICAgICBwb2xhclJhZGl1cyA9IF9lbGVtZW50JHByb3BzLnBvbGFyUmFkaXVzO1xyXG4gICAgICAgIHZhciBfdGhpcyRzdGF0ZTQgPSBfdGhpcy5zdGF0ZSxcclxuICAgICAgICAgIHJhZGl1c0F4aXNNYXAgPSBfdGhpcyRzdGF0ZTQucmFkaXVzQXhpc01hcCxcclxuICAgICAgICAgIGFuZ2xlQXhpc01hcCA9IF90aGlzJHN0YXRlNC5hbmdsZUF4aXNNYXA7XHJcbiAgICAgICAgdmFyIHJhZGl1c0F4aXMgPSAoMCwgX0RhdGFVdGlscy5nZXRBbnlFbGVtZW50T2ZPYmplY3QpKHJhZGl1c0F4aXNNYXApO1xyXG4gICAgICAgIHZhciBhbmdsZUF4aXMgPSAoMCwgX0RhdGFVdGlscy5nZXRBbnlFbGVtZW50T2ZPYmplY3QpKGFuZ2xlQXhpc01hcCk7XHJcbiAgICAgICAgdmFyIGN4ID0gYW5nbGVBeGlzLmN4LFxyXG4gICAgICAgICAgY3kgPSBhbmdsZUF4aXMuY3ksXHJcbiAgICAgICAgICBpbm5lclJhZGl1cyA9IGFuZ2xlQXhpcy5pbm5lclJhZGl1cyxcclxuICAgICAgICAgIG91dGVyUmFkaXVzID0gYW5nbGVBeGlzLm91dGVyUmFkaXVzO1xyXG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jbG9uZUVsZW1lbnQpKGVsZW1lbnQsIHtcclxuICAgICAgICAgIHBvbGFyQW5nbGVzOiBBcnJheS5pc0FycmF5KHBvbGFyQW5nbGVzKSA/IHBvbGFyQW5nbGVzIDogKDAsIF9DaGFydFV0aWxzLmdldFRpY2tzT2ZBeGlzKShhbmdsZUF4aXMsIHRydWUpLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5LmNvb3JkaW5hdGU7XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICAgIHBvbGFyUmFkaXVzOiBBcnJheS5pc0FycmF5KHBvbGFyUmFkaXVzKSA/IHBvbGFyUmFkaXVzIDogKDAsIF9DaGFydFV0aWxzLmdldFRpY2tzT2ZBeGlzKShyYWRpdXNBeGlzLCB0cnVlKS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5jb29yZGluYXRlO1xyXG4gICAgICAgICAgfSksXHJcbiAgICAgICAgICBjeDogY3gsXHJcbiAgICAgICAgICBjeTogY3ksXHJcbiAgICAgICAgICBpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXHJcbiAgICAgICAgICBvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXHJcbiAgICAgICAgICBrZXk6IGVsZW1lbnQua2V5IHx8ICdwb2xhci1ncmlkJyxcclxuICAgICAgICAgIHJhZGlhbExpbmVzOiByYWRpYWxMaW5lc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIERyYXcgbGVnZW5kXHJcbiAgICAgICAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gICAgICAgICAgICBUaGUgaW5zdGFuY2Ugb2YgTGVnZW5kXHJcbiAgICAgICAqL1xyXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmVuZGVyTGVnZW5kXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXMgPSBfdGhpcy5zdGF0ZS5mb3JtYXR0ZWRHcmFwaGljYWxJdGVtcztcclxuICAgICAgICB2YXIgX3RoaXMkcHJvcHMyID0gX3RoaXMucHJvcHMsXHJcbiAgICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzMi5jaGlsZHJlbixcclxuICAgICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHMyLndpZHRoLFxyXG4gICAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHMyLmhlaWdodDtcclxuICAgICAgICB2YXIgbWFyZ2luID0gX3RoaXMucHJvcHMubWFyZ2luIHx8IHt9O1xyXG4gICAgICAgIHZhciBsZWdlbmRXaWR0aCA9IHdpZHRoIC0gKG1hcmdpbi5sZWZ0IHx8IDApIC0gKG1hcmdpbi5yaWdodCB8fCAwKTtcclxuICAgICAgICB2YXIgcHJvcHMgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0TGVnZW5kUHJvcHMpKHtcclxuICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcclxuICAgICAgICAgIGZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zOiBmb3JtYXR0ZWRHcmFwaGljYWxJdGVtcyxcclxuICAgICAgICAgIGxlZ2VuZFdpZHRoOiBsZWdlbmRXaWR0aCxcclxuICAgICAgICAgIGxlZ2VuZENvbnRlbnQ6IGxlZ2VuZENvbnRlbnRcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIXByb3BzKSB7XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBwcm9wcy5pdGVtLFxyXG4gICAgICAgICAgb3RoZXJQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkKTtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLygwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShpdGVtLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG90aGVyUHJvcHMpLCB7fSwge1xyXG4gICAgICAgICAgY2hhcnRXaWR0aDogd2lkdGgsXHJcbiAgICAgICAgICBjaGFydEhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgICAgbWFyZ2luOiBtYXJnaW4sXHJcbiAgICAgICAgICBvbkJCb3hVcGRhdGU6IF90aGlzLmhhbmRsZUxlZ2VuZEJCb3hVcGRhdGVcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICAvKipcclxuICAgICAgICogRHJhdyBUb29sdGlwXHJcbiAgICAgICAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gIFRoZSBpbnN0YW5jZSBvZiBUb29sdGlwXHJcbiAgICAgICAqL1xyXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmVuZGVyVG9vbHRpcFwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90b29sdGlwSXRlbSRwcm9wcyRhYztcclxuICAgICAgICB2YXIgX3RoaXMkcHJvcHMzID0gX3RoaXMucHJvcHMsXHJcbiAgICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzMy5jaGlsZHJlbixcclxuICAgICAgICAgIGFjY2Vzc2liaWxpdHlMYXllciA9IF90aGlzJHByb3BzMy5hY2Nlc3NpYmlsaXR5TGF5ZXI7XHJcbiAgICAgICAgdmFyIHRvb2x0aXBJdGVtID0gKDAsIF9SZWFjdFV0aWxzLmZpbmRDaGlsZEJ5VHlwZSkoY2hpbGRyZW4sIF9Ub29sdGlwLlRvb2x0aXApO1xyXG4gICAgICAgIGlmICghdG9vbHRpcEl0ZW0pIHtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX3RoaXMkc3RhdGU1ID0gX3RoaXMuc3RhdGUsXHJcbiAgICAgICAgICBpc1Rvb2x0aXBBY3RpdmUgPSBfdGhpcyRzdGF0ZTUuaXNUb29sdGlwQWN0aXZlLFxyXG4gICAgICAgICAgYWN0aXZlQ29vcmRpbmF0ZSA9IF90aGlzJHN0YXRlNS5hY3RpdmVDb29yZGluYXRlLFxyXG4gICAgICAgICAgYWN0aXZlUGF5bG9hZCA9IF90aGlzJHN0YXRlNS5hY3RpdmVQYXlsb2FkLFxyXG4gICAgICAgICAgYWN0aXZlTGFiZWwgPSBfdGhpcyRzdGF0ZTUuYWN0aXZlTGFiZWwsXHJcbiAgICAgICAgICBvZmZzZXQgPSBfdGhpcyRzdGF0ZTUub2Zmc2V0O1xyXG5cclxuICAgICAgICAvLyBUaGUgdXNlciBjYW4gc2V0IGlzQWN0aXZlIG9uIHRoZSBUb29sdGlwLFxyXG4gICAgICAgIC8vIGFuZCB3ZSByZXNwZWN0IHRoZSB1c2VyIHRvIGVuYWJsZSBjdXN0b21pc2F0aW9uLlxyXG4gICAgICAgIC8vIFRoZSBUb29sdGlwIGlzIGFjdGl2ZSBpZiB0aGUgdXNlciBoYXMgc2V0IGlzQWN0aXZlLCBvciBpZiB0aGUgdG9vbHRpcCBpcyBhY3RpdmUgZHVlIHRvIGEgbW91c2UgZXZlbnQuXHJcbiAgICAgICAgdmFyIGlzQWN0aXZlID0gKF90b29sdGlwSXRlbSRwcm9wcyRhYyA9IHRvb2x0aXBJdGVtLnByb3BzLmFjdGl2ZSkgIT09IG51bGwgJiYgX3Rvb2x0aXBJdGVtJHByb3BzJGFjICE9PSB2b2lkIDAgPyBfdG9vbHRpcEl0ZW0kcHJvcHMkYWMgOiBpc1Rvb2x0aXBBY3RpdmU7XHJcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNsb25lRWxlbWVudCkodG9vbHRpcEl0ZW0sIHtcclxuICAgICAgICAgIHZpZXdCb3g6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb2Zmc2V0KSwge30sIHtcclxuICAgICAgICAgICAgeDogb2Zmc2V0LmxlZnQsXHJcbiAgICAgICAgICAgIHk6IG9mZnNldC50b3BcclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgYWN0aXZlOiBpc0FjdGl2ZSxcclxuICAgICAgICAgIGxhYmVsOiBhY3RpdmVMYWJlbCxcclxuICAgICAgICAgIHBheWxvYWQ6IGlzQWN0aXZlID8gYWN0aXZlUGF5bG9hZCA6IFtdLFxyXG4gICAgICAgICAgY29vcmRpbmF0ZTogYWN0aXZlQ29vcmRpbmF0ZSxcclxuICAgICAgICAgIGFjY2Vzc2liaWxpdHlMYXllcjogYWNjZXNzaWJpbGl0eUxheWVyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmVuZGVyQnJ1c2hcIiwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gX3RoaXMucHJvcHMsXHJcbiAgICAgICAgICBtYXJnaW4gPSBfdGhpcyRwcm9wczQubWFyZ2luLFxyXG4gICAgICAgICAgZGF0YSA9IF90aGlzJHByb3BzNC5kYXRhO1xyXG4gICAgICAgIHZhciBfdGhpcyRzdGF0ZTYgPSBfdGhpcy5zdGF0ZSxcclxuICAgICAgICAgIG9mZnNldCA9IF90aGlzJHN0YXRlNi5vZmZzZXQsXHJcbiAgICAgICAgICBkYXRhU3RhcnRJbmRleCA9IF90aGlzJHN0YXRlNi5kYXRhU3RhcnRJbmRleCxcclxuICAgICAgICAgIGRhdGFFbmRJbmRleCA9IF90aGlzJHN0YXRlNi5kYXRhRW5kSW5kZXgsXHJcbiAgICAgICAgICB1cGRhdGVJZCA9IF90aGlzJHN0YXRlNi51cGRhdGVJZDtcclxuXHJcbiAgICAgICAgLy8gVE9ETzogdXBkYXRlIGJydXNoIHdoZW4gY2hpbGRyZW4gdXBkYXRlXHJcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNsb25lRWxlbWVudCkoZWxlbWVudCwge1xyXG4gICAgICAgICAga2V5OiBlbGVtZW50LmtleSB8fCAnX3JlY2hhcnRzLWJydXNoJyxcclxuICAgICAgICAgIG9uQ2hhbmdlOiAoMCwgX0NoYXJ0VXRpbHMuY29tYmluZUV2ZW50SGFuZGxlcnMpKF90aGlzLmhhbmRsZUJydXNoQ2hhbmdlLCBlbGVtZW50LnByb3BzLm9uQ2hhbmdlKSxcclxuICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICB4OiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikoZWxlbWVudC5wcm9wcy54KSA/IGVsZW1lbnQucHJvcHMueCA6IG9mZnNldC5sZWZ0LFxyXG4gICAgICAgICAgeTogKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGVsZW1lbnQucHJvcHMueSkgPyBlbGVtZW50LnByb3BzLnkgOiBvZmZzZXQudG9wICsgb2Zmc2V0LmhlaWdodCArIG9mZnNldC5icnVzaEJvdHRvbSAtIChtYXJnaW4uYm90dG9tIHx8IDApLFxyXG4gICAgICAgICAgd2lkdGg6ICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShlbGVtZW50LnByb3BzLndpZHRoKSA/IGVsZW1lbnQucHJvcHMud2lkdGggOiBvZmZzZXQud2lkdGgsXHJcbiAgICAgICAgICBzdGFydEluZGV4OiBkYXRhU3RhcnRJbmRleCxcclxuICAgICAgICAgIGVuZEluZGV4OiBkYXRhRW5kSW5kZXgsXHJcbiAgICAgICAgICB1cGRhdGVJZDogXCJicnVzaC1cIi5jb25jYXQodXBkYXRlSWQpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmVuZGVyUmVmZXJlbmNlRWxlbWVudFwiLCBmdW5jdGlvbiAoZWxlbWVudCwgZGlzcGxheU5hbWUsIGluZGV4KSB7XHJcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF90aGlzMiA9IF90aGlzLFxyXG4gICAgICAgICAgY2xpcFBhdGhJZCA9IF90aGlzMi5jbGlwUGF0aElkO1xyXG4gICAgICAgIHZhciBfdGhpcyRzdGF0ZTcgPSBfdGhpcy5zdGF0ZSxcclxuICAgICAgICAgIHhBeGlzTWFwID0gX3RoaXMkc3RhdGU3LnhBeGlzTWFwLFxyXG4gICAgICAgICAgeUF4aXNNYXAgPSBfdGhpcyRzdGF0ZTcueUF4aXNNYXAsXHJcbiAgICAgICAgICBvZmZzZXQgPSBfdGhpcyRzdGF0ZTcub2Zmc2V0O1xyXG4gICAgICAgIHZhciBlbGVtZW50RGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcyB8fCB7fTtcclxuICAgICAgICB2YXIgX2VsZW1lbnQkcHJvcHMyID0gZWxlbWVudC5wcm9wcyxcclxuICAgICAgICAgIF9lbGVtZW50JHByb3BzMiR4QXhpcyA9IF9lbGVtZW50JHByb3BzMi54QXhpc0lkLFxyXG4gICAgICAgICAgeEF4aXNJZCA9IF9lbGVtZW50JHByb3BzMiR4QXhpcyA9PT0gdm9pZCAwID8gZWxlbWVudERlZmF1bHRQcm9wcy54QXhpc0lkIDogX2VsZW1lbnQkcHJvcHMyJHhBeGlzLFxyXG4gICAgICAgICAgX2VsZW1lbnQkcHJvcHMyJHlBeGlzID0gX2VsZW1lbnQkcHJvcHMyLnlBeGlzSWQsXHJcbiAgICAgICAgICB5QXhpc0lkID0gX2VsZW1lbnQkcHJvcHMyJHlBeGlzID09PSB2b2lkIDAgPyBlbGVtZW50RGVmYXVsdFByb3BzLnlBeGlzSWQgOiBfZWxlbWVudCRwcm9wczIkeUF4aXM7XHJcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNsb25lRWxlbWVudCkoZWxlbWVudCwge1xyXG4gICAgICAgICAga2V5OiBlbGVtZW50LmtleSB8fCBcIlwiLmNvbmNhdChkaXNwbGF5TmFtZSwgXCItXCIpLmNvbmNhdChpbmRleCksXHJcbiAgICAgICAgICB4QXhpczogeEF4aXNNYXBbeEF4aXNJZF0sXHJcbiAgICAgICAgICB5QXhpczogeUF4aXNNYXBbeUF4aXNJZF0sXHJcbiAgICAgICAgICB2aWV3Qm94OiB7XHJcbiAgICAgICAgICAgIHg6IG9mZnNldC5sZWZ0LFxyXG4gICAgICAgICAgICB5OiBvZmZzZXQudG9wLFxyXG4gICAgICAgICAgICB3aWR0aDogb2Zmc2V0LndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IG9mZnNldC5oZWlnaHRcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBjbGlwUGF0aElkOiBjbGlwUGF0aElkXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmVuZGVyQWN0aXZlUG9pbnRzXCIsIGZ1bmN0aW9uIChfcmVmMTApIHtcclxuICAgICAgICB2YXIgaXRlbSA9IF9yZWYxMC5pdGVtLFxyXG4gICAgICAgICAgYWN0aXZlUG9pbnQgPSBfcmVmMTAuYWN0aXZlUG9pbnQsXHJcbiAgICAgICAgICBiYXNlUG9pbnQgPSBfcmVmMTAuYmFzZVBvaW50LFxyXG4gICAgICAgICAgY2hpbGRJbmRleCA9IF9yZWYxMC5jaGlsZEluZGV4LFxyXG4gICAgICAgICAgaXNSYW5nZSA9IF9yZWYxMC5pc1JhbmdlO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICAvLyBpdGVtIGlzIG5vdCBhIFJlYWN0IEVsZW1lbnQgc28gd2UgZG9uJ3QgbmVlZCB0byByZXNvbHZlIGRlZmF1bHRQcm9wcy5cclxuICAgICAgICB2YXIga2V5ID0gaXRlbS5wcm9wcy5rZXk7XHJcbiAgICAgICAgdmFyIGl0ZW1JdGVtUHJvcHMgPSBpdGVtLml0ZW0udHlwZS5kZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaXRlbS5pdGVtLnR5cGUuZGVmYXVsdFByb3BzKSwgaXRlbS5pdGVtLnByb3BzKSA6IGl0ZW0uaXRlbS5wcm9wcztcclxuICAgICAgICB2YXIgYWN0aXZlRG90ID0gaXRlbUl0ZW1Qcm9wcy5hY3RpdmVEb3QsXHJcbiAgICAgICAgICBkYXRhS2V5ID0gaXRlbUl0ZW1Qcm9wcy5kYXRhS2V5O1xyXG4gICAgICAgIHZhciBkb3RQcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XHJcbiAgICAgICAgICBpbmRleDogY2hpbGRJbmRleCxcclxuICAgICAgICAgIGRhdGFLZXk6IGRhdGFLZXksXHJcbiAgICAgICAgICBjeDogYWN0aXZlUG9pbnQueCxcclxuICAgICAgICAgIGN5OiBhY3RpdmVQb2ludC55LFxyXG4gICAgICAgICAgcjogNCxcclxuICAgICAgICAgIGZpbGw6ICgwLCBfQ2hhcnRVdGlscy5nZXRNYWluQ29sb3JPZkdyYXBoaWNJdGVtKShpdGVtLml0ZW0pLFxyXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXHJcbiAgICAgICAgICBzdHJva2U6ICcjZmZmJyxcclxuICAgICAgICAgIHBheWxvYWQ6IGFjdGl2ZVBvaW50LnBheWxvYWQsXHJcbiAgICAgICAgICB2YWx1ZTogYWN0aXZlUG9pbnQudmFsdWVcclxuICAgICAgICB9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKGFjdGl2ZURvdCwgZmFsc2UpKSwgKDAsIF90eXBlcy5hZGFwdEV2ZW50SGFuZGxlcnMpKGFjdGl2ZURvdCkpO1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKENhdGVnb3JpY2FsQ2hhcnRXcmFwcGVyLnJlbmRlckFjdGl2ZURvdChhY3RpdmVEb3QsIGRvdFByb3BzLCBcIlwiLmNvbmNhdChrZXksIFwiLWFjdGl2ZVBvaW50LVwiKS5jb25jYXQoY2hpbGRJbmRleCkpKTtcclxuICAgICAgICBpZiAoYmFzZVBvaW50KSB7XHJcbiAgICAgICAgICByZXN1bHQucHVzaChDYXRlZ29yaWNhbENoYXJ0V3JhcHBlci5yZW5kZXJBY3RpdmVEb3QoYWN0aXZlRG90LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRvdFByb3BzKSwge30sIHtcclxuICAgICAgICAgICAgY3g6IGJhc2VQb2ludC54LFxyXG4gICAgICAgICAgICBjeTogYmFzZVBvaW50LnlcclxuICAgICAgICAgIH0pLCBcIlwiLmNvbmNhdChrZXksIFwiLWJhc2VQb2ludC1cIikuY29uY2F0KGNoaWxkSW5kZXgpKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc1JhbmdlKSB7XHJcbiAgICAgICAgICByZXN1bHQucHVzaChudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfSk7XHJcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyZW5kZXJHcmFwaGljQ2hpbGRcIiwgZnVuY3Rpb24gKGVsZW1lbnQsIGRpc3BsYXlOYW1lLCBpbmRleCkge1xyXG4gICAgICAgIHZhciBpdGVtID0gX3RoaXMuZmlsdGVyRm9ybWF0SXRlbShlbGVtZW50LCBkaXNwbGF5TmFtZSwgaW5kZXgpO1xyXG4gICAgICAgIGlmICghaXRlbSkge1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0b29sdGlwRXZlbnRUeXBlID0gX3RoaXMuZ2V0VG9vbHRpcEV2ZW50VHlwZSgpO1xyXG4gICAgICAgIHZhciBfdGhpcyRzdGF0ZTggPSBfdGhpcy5zdGF0ZSxcclxuICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZSA9IF90aGlzJHN0YXRlOC5pc1Rvb2x0aXBBY3RpdmUsXHJcbiAgICAgICAgICB0b29sdGlwQXhpcyA9IF90aGlzJHN0YXRlOC50b29sdGlwQXhpcyxcclxuICAgICAgICAgIGFjdGl2ZVRvb2x0aXBJbmRleCA9IF90aGlzJHN0YXRlOC5hY3RpdmVUb29sdGlwSW5kZXgsXHJcbiAgICAgICAgICBhY3RpdmVMYWJlbCA9IF90aGlzJHN0YXRlOC5hY3RpdmVMYWJlbDtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBfdGhpcy5wcm9wcy5jaGlsZHJlbjtcclxuICAgICAgICB2YXIgdG9vbHRpcEl0ZW0gPSAoMCwgX1JlYWN0VXRpbHMuZmluZENoaWxkQnlUeXBlKShjaGlsZHJlbiwgX1Rvb2x0aXAuVG9vbHRpcCk7XHJcbiAgICAgICAgLy8gaXRlbSBpcyBub3QgYSBSZWFjdCBFbGVtZW50IHNvIHdlIGRvbid0IG5lZWQgdG8gcmVzb2x2ZSBkZWZhdWx0UHJvcHNcclxuICAgICAgICB2YXIgX2l0ZW0kcHJvcHMgPSBpdGVtLnByb3BzLFxyXG4gICAgICAgICAgcG9pbnRzID0gX2l0ZW0kcHJvcHMucG9pbnRzLFxyXG4gICAgICAgICAgaXNSYW5nZSA9IF9pdGVtJHByb3BzLmlzUmFuZ2UsXHJcbiAgICAgICAgICBiYXNlTGluZSA9IF9pdGVtJHByb3BzLmJhc2VMaW5lO1xyXG4gICAgICAgIHZhciBpdGVtSXRlbVByb3BzID0gaXRlbS5pdGVtLnR5cGUuZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGl0ZW0uaXRlbS50eXBlLmRlZmF1bHRQcm9wcyksIGl0ZW0uaXRlbS5wcm9wcykgOiBpdGVtLml0ZW0ucHJvcHM7XHJcbiAgICAgICAgdmFyIGFjdGl2ZURvdCA9IGl0ZW1JdGVtUHJvcHMuYWN0aXZlRG90LFxyXG4gICAgICAgICAgaGlkZSA9IGl0ZW1JdGVtUHJvcHMuaGlkZSxcclxuICAgICAgICAgIGFjdGl2ZUJhciA9IGl0ZW1JdGVtUHJvcHMuYWN0aXZlQmFyLFxyXG4gICAgICAgICAgYWN0aXZlU2hhcGUgPSBpdGVtSXRlbVByb3BzLmFjdGl2ZVNoYXBlO1xyXG4gICAgICAgIHZhciBoYXNBY3RpdmUgPSBCb29sZWFuKCFoaWRlICYmIGlzVG9vbHRpcEFjdGl2ZSAmJiB0b29sdGlwSXRlbSAmJiAoYWN0aXZlRG90IHx8IGFjdGl2ZUJhciB8fCBhY3RpdmVTaGFwZSkpO1xyXG4gICAgICAgIHZhciBpdGVtRXZlbnRzID0ge307XHJcbiAgICAgICAgaWYgKHRvb2x0aXBFdmVudFR5cGUgIT09ICdheGlzJyAmJiB0b29sdGlwSXRlbSAmJiB0b29sdGlwSXRlbS5wcm9wcy50cmlnZ2VyID09PSAnY2xpY2snKSB7XHJcbiAgICAgICAgICBpdGVtRXZlbnRzID0ge1xyXG4gICAgICAgICAgICBvbkNsaWNrOiAoMCwgX0NoYXJ0VXRpbHMuY29tYmluZUV2ZW50SGFuZGxlcnMpKF90aGlzLmhhbmRsZUl0ZW1Nb3VzZUVudGVyLCBlbGVtZW50LnByb3BzLm9uQ2xpY2spXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSBpZiAodG9vbHRpcEV2ZW50VHlwZSAhPT0gJ2F4aXMnKSB7XHJcbiAgICAgICAgICBpdGVtRXZlbnRzID0ge1xyXG4gICAgICAgICAgICBvbk1vdXNlTGVhdmU6ICgwLCBfQ2hhcnRVdGlscy5jb21iaW5lRXZlbnRIYW5kbGVycykoX3RoaXMuaGFuZGxlSXRlbU1vdXNlTGVhdmUsIGVsZW1lbnQucHJvcHMub25Nb3VzZUxlYXZlKSxcclxuICAgICAgICAgICAgb25Nb3VzZUVudGVyOiAoMCwgX0NoYXJ0VXRpbHMuY29tYmluZUV2ZW50SGFuZGxlcnMpKF90aGlzLmhhbmRsZUl0ZW1Nb3VzZUVudGVyLCBlbGVtZW50LnByb3BzLm9uTW91c2VFbnRlcilcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBncmFwaGljYWxJdGVtID0gLyojX19QVVJFX18qLygwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShlbGVtZW50LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGl0ZW0ucHJvcHMpLCBpdGVtRXZlbnRzKSk7XHJcbiAgICAgICAgZnVuY3Rpb24gZmluZFdpdGhQYXlsb2FkKGVudHJ5KSB7XHJcbiAgICAgICAgICAvLyBUT0RPIG5lZWRzIHRvIHZlcmlmeSBkYXRhS2V5IGlzIEZ1bmN0aW9uXHJcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHRvb2x0aXBBeGlzLmRhdGFLZXkgPT09ICdmdW5jdGlvbicgPyB0b29sdGlwQXhpcy5kYXRhS2V5KGVudHJ5LnBheWxvYWQpIDogbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhhc0FjdGl2ZSkge1xyXG4gICAgICAgICAgaWYgKGFjdGl2ZVRvb2x0aXBJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3RpdmVQb2ludCwgYmFzZVBvaW50O1xyXG4gICAgICAgICAgICBpZiAodG9vbHRpcEF4aXMuZGF0YUtleSAmJiAhdG9vbHRpcEF4aXMuYWxsb3dEdXBsaWNhdGVkQ2F0ZWdvcnkpIHtcclxuICAgICAgICAgICAgICAvLyBudW1iZXIgdHJhbnNmb3JtIHRvIHN0cmluZ1xyXG4gICAgICAgICAgICAgIHZhciBzcGVjaWZpZWRLZXkgPSB0eXBlb2YgdG9vbHRpcEF4aXMuZGF0YUtleSA9PT0gJ2Z1bmN0aW9uJyA/IGZpbmRXaXRoUGF5bG9hZCA6ICdwYXlsb2FkLicuY29uY2F0KHRvb2x0aXBBeGlzLmRhdGFLZXkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgYWN0aXZlUG9pbnQgPSAoMCwgX0RhdGFVdGlscy5maW5kRW50cnlJbkFycmF5KShwb2ludHMsIHNwZWNpZmllZEtleSwgYWN0aXZlTGFiZWwpO1xyXG4gICAgICAgICAgICAgIGJhc2VQb2ludCA9IGlzUmFuZ2UgJiYgYmFzZUxpbmUgJiYgKDAsIF9EYXRhVXRpbHMuZmluZEVudHJ5SW5BcnJheSkoYmFzZUxpbmUsIHNwZWNpZmllZEtleSwgYWN0aXZlTGFiZWwpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGFjdGl2ZVBvaW50ID0gcG9pbnRzID09PSBudWxsIHx8IHBvaW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9pbnRzW2FjdGl2ZVRvb2x0aXBJbmRleF07XHJcbiAgICAgICAgICAgICAgYmFzZVBvaW50ID0gaXNSYW5nZSAmJiBiYXNlTGluZSAmJiBiYXNlTGluZVthY3RpdmVUb29sdGlwSW5kZXhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhY3RpdmVTaGFwZSB8fCBhY3RpdmVCYXIpIHtcclxuICAgICAgICAgICAgICB2YXIgYWN0aXZlSW5kZXggPSBlbGVtZW50LnByb3BzLmFjdGl2ZUluZGV4ICE9PSB1bmRlZmluZWQgPyBlbGVtZW50LnByb3BzLmFjdGl2ZUluZGV4IDogYWN0aXZlVG9vbHRpcEluZGV4O1xyXG4gICAgICAgICAgICAgIHJldHVybiBbLyojX19QVVJFX18qLygwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShlbGVtZW50LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaXRlbS5wcm9wcyksIGl0ZW1FdmVudHMpLCB7fSwge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlSW5kZXg6IGFjdGl2ZUluZGV4XHJcbiAgICAgICAgICAgICAgfSkpLCBudWxsLCBudWxsXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoISgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShhY3RpdmVQb2ludCkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gW2dyYXBoaWNhbEl0ZW1dLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoX3RoaXMucmVuZGVyQWN0aXZlUG9pbnRzKHtcclxuICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXHJcbiAgICAgICAgICAgICAgICBhY3RpdmVQb2ludDogYWN0aXZlUG9pbnQsXHJcbiAgICAgICAgICAgICAgICBiYXNlUG9pbnQ6IGJhc2VQb2ludCxcclxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IGFjdGl2ZVRvb2x0aXBJbmRleCxcclxuICAgICAgICAgICAgICAgIGlzUmFuZ2U6IGlzUmFuZ2VcclxuICAgICAgICAgICAgICB9KSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMkZ2V0SXRlbUJ5WFk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXZSBoaXQgdGhpcyBibG9jayBpZiBjb25zdW1lciB1c2VzIGEgVG9vbHRpcCB3aXRob3V0IFhBeGlzIGFuZC9vciBZQXhpcy5cclxuICAgICAgICAgICAgICogSW4gd2hpY2ggY2FzZSwgdGhpcy5zdGF0ZS5hY3RpdmVUb29sdGlwSW5kZXggbmV2ZXIgZ2V0cyBzZXRcclxuICAgICAgICAgICAgICogYmVjYXVzZSB0aGUgbW91c2UgZXZlbnRzIHRoYXQgdHJpZ2dlciB0aGF0IHZhbHVlIGdldHRpbmcgc2V0IG5ldmVyIGdldCB0cmlnZ2VkIHdpdGhvdXQgdGhlIGF4aXMgY29tcG9uZW50cy5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQW4gZXhhbXBsZSB1c2FnZSBjYXNlIGlzIGEgRnVubmVsQ2hhcnRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBfcmVmMTEgPSAoX3RoaXMkZ2V0SXRlbUJ5WFkgPSBfdGhpcy5nZXRJdGVtQnlYWShfdGhpcy5zdGF0ZS5hY3RpdmVDb29yZGluYXRlKSkgIT09IG51bGwgJiYgX3RoaXMkZ2V0SXRlbUJ5WFkgIT09IHZvaWQgMCA/IF90aGlzJGdldEl0ZW1CeVhZIDoge1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhpY2FsSXRlbTogZ3JhcGhpY2FsSXRlbVxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgX3JlZjExJGdyYXBoaWNhbEl0ZW0gPSBfcmVmMTEuZ3JhcGhpY2FsSXRlbSxcclxuICAgICAgICAgICAgICBfcmVmMTEkZ3JhcGhpY2FsSXRlbSQgPSBfcmVmMTEkZ3JhcGhpY2FsSXRlbS5pdGVtLFxyXG4gICAgICAgICAgICAgIHh5SXRlbSA9IF9yZWYxMSRncmFwaGljYWxJdGVtJCA9PT0gdm9pZCAwID8gZWxlbWVudCA6IF9yZWYxMSRncmFwaGljYWxJdGVtJCxcclxuICAgICAgICAgICAgICBjaGlsZEluZGV4ID0gX3JlZjExJGdyYXBoaWNhbEl0ZW0uY2hpbGRJbmRleDtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRQcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBpdGVtLnByb3BzKSwgaXRlbUV2ZW50cyksIHt9LCB7XHJcbiAgICAgICAgICAgICAgYWN0aXZlSW5kZXg6IGNoaWxkSW5kZXhcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBbLyojX19QVVJFX18qLygwLCBfcmVhY3QuY2xvbmVFbGVtZW50KSh4eUl0ZW0sIGVsZW1lbnRQcm9wcyksIG51bGwsIG51bGxdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNSYW5nZSkge1xyXG4gICAgICAgICAgcmV0dXJuIFtncmFwaGljYWxJdGVtLCBudWxsLCBudWxsXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtncmFwaGljYWxJdGVtLCBudWxsXTtcclxuICAgICAgfSk7XHJcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyZW5kZXJDdXN0b21pemVkXCIsIGZ1bmN0aW9uIChlbGVtZW50LCBkaXNwbGF5TmFtZSwgaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLygwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShlbGVtZW50LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xyXG4gICAgICAgICAga2V5OiBcInJlY2hhcnRzLWN1c3RvbWl6ZWQtXCIuY29uY2F0KGluZGV4KVxyXG4gICAgICAgIH0sIF90aGlzLnByb3BzKSwgX3RoaXMuc3RhdGUpKTtcclxuICAgICAgfSk7XHJcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyZW5kZXJNYXBcIiwge1xyXG4gICAgICAgIENhcnRlc2lhbkdyaWQ6IHtcclxuICAgICAgICAgIGhhbmRsZXI6IHJlbmRlckFzSXMsXHJcbiAgICAgICAgICBvbmNlOiB0cnVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBSZWZlcmVuY2VBcmVhOiB7XHJcbiAgICAgICAgICBoYW5kbGVyOiBfdGhpcy5yZW5kZXJSZWZlcmVuY2VFbGVtZW50XHJcbiAgICAgICAgfSxcclxuICAgICAgICBSZWZlcmVuY2VMaW5lOiB7XHJcbiAgICAgICAgICBoYW5kbGVyOiByZW5kZXJBc0lzXHJcbiAgICAgICAgfSxcclxuICAgICAgICBSZWZlcmVuY2VEb3Q6IHtcclxuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlclJlZmVyZW5jZUVsZW1lbnRcclxuICAgICAgICB9LFxyXG4gICAgICAgIFhBeGlzOiB7XHJcbiAgICAgICAgICBoYW5kbGVyOiByZW5kZXJBc0lzXHJcbiAgICAgICAgfSxcclxuICAgICAgICBZQXhpczoge1xyXG4gICAgICAgICAgaGFuZGxlcjogcmVuZGVyQXNJc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgQnJ1c2g6IHtcclxuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlckJydXNoLFxyXG4gICAgICAgICAgb25jZTogdHJ1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgQmFyOiB7XHJcbiAgICAgICAgICBoYW5kbGVyOiBfdGhpcy5yZW5kZXJHcmFwaGljQ2hpbGRcclxuICAgICAgICB9LFxyXG4gICAgICAgIExpbmU6IHtcclxuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlckdyYXBoaWNDaGlsZFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgQXJlYToge1xyXG4gICAgICAgICAgaGFuZGxlcjogX3RoaXMucmVuZGVyR3JhcGhpY0NoaWxkXHJcbiAgICAgICAgfSxcclxuICAgICAgICBSYWRhcjoge1xyXG4gICAgICAgICAgaGFuZGxlcjogX3RoaXMucmVuZGVyR3JhcGhpY0NoaWxkXHJcbiAgICAgICAgfSxcclxuICAgICAgICBSYWRpYWxCYXI6IHtcclxuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlckdyYXBoaWNDaGlsZFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgU2NhdHRlcjoge1xyXG4gICAgICAgICAgaGFuZGxlcjogX3RoaXMucmVuZGVyR3JhcGhpY0NoaWxkXHJcbiAgICAgICAgfSxcclxuICAgICAgICBQaWU6IHtcclxuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlckdyYXBoaWNDaGlsZFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgRnVubmVsOiB7XHJcbiAgICAgICAgICBoYW5kbGVyOiBfdGhpcy5yZW5kZXJHcmFwaGljQ2hpbGRcclxuICAgICAgICB9LFxyXG4gICAgICAgIFRvb2x0aXA6IHtcclxuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlckN1cnNvcixcclxuICAgICAgICAgIG9uY2U6IHRydWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIFBvbGFyR3JpZDoge1xyXG4gICAgICAgICAgaGFuZGxlcjogX3RoaXMucmVuZGVyUG9sYXJHcmlkLFxyXG4gICAgICAgICAgb25jZTogdHJ1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgUG9sYXJBbmdsZUF4aXM6IHtcclxuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlclBvbGFyQXhpc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgUG9sYXJSYWRpdXNBeGlzOiB7XHJcbiAgICAgICAgICBoYW5kbGVyOiBfdGhpcy5yZW5kZXJQb2xhckF4aXNcclxuICAgICAgICB9LFxyXG4gICAgICAgIEN1c3RvbWl6ZWQ6IHtcclxuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlckN1c3RvbWl6ZWRcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBfdGhpcy5jbGlwUGF0aElkID0gXCJcIi5jb25jYXQoKF9wcm9wcyRpZCA9IF9wcm9wcy5pZCkgIT09IG51bGwgJiYgX3Byb3BzJGlkICE9PSB2b2lkIDAgPyBfcHJvcHMkaWQgOiAoMCwgX0RhdGFVdGlscy51bmlxdWVJZCkoJ3JlY2hhcnRzJyksIFwiLWNsaXBcIik7XHJcblxyXG4gICAgICAvLyB0cmlnZ2VyIDYwZnBzXHJcbiAgICAgIF90aGlzLnRocm90dGxlVHJpZ2dlcmVkQWZ0ZXJNb3VzZU1vdmUgPSAoMCwgX3Rocm90dGxlW1wiZGVmYXVsdFwiXSkoX3RoaXMudHJpZ2dlcmVkQWZ0ZXJNb3VzZU1vdmUsIChfcHJvcHMkdGhyb3R0bGVEZWxheSA9IF9wcm9wcy50aHJvdHRsZURlbGF5KSAhPT0gbnVsbCAmJiBfcHJvcHMkdGhyb3R0bGVEZWxheSAhPT0gdm9pZCAwID8gX3Byb3BzJHRocm90dGxlRGVsYXkgOiAxMDAwIC8gNjApO1xyXG4gICAgICBfdGhpcy5zdGF0ZSA9IHt9O1xyXG4gICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBfaW5oZXJpdHMoQ2F0ZWdvcmljYWxDaGFydFdyYXBwZXIsIF9Db21wb25lbnQpO1xyXG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDYXRlZ29yaWNhbENoYXJ0V3JhcHBlciwgW3tcclxuICAgICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXHJcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMkcHJvcHMkbWFyZ2luJGxlLCBfdGhpcyRwcm9wcyRtYXJnaW4kdG87XHJcbiAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcigpO1xyXG4gICAgICAgIHRoaXMuYWNjZXNzaWJpbGl0eU1hbmFnZXIuc2V0RGV0YWlscyh7XHJcbiAgICAgICAgICBjb250YWluZXI6IHRoaXMuY29udGFpbmVyLFxyXG4gICAgICAgICAgb2Zmc2V0OiB7XHJcbiAgICAgICAgICAgIGxlZnQ6IChfdGhpcyRwcm9wcyRtYXJnaW4kbGUgPSB0aGlzLnByb3BzLm1hcmdpbi5sZWZ0KSAhPT0gbnVsbCAmJiBfdGhpcyRwcm9wcyRtYXJnaW4kbGUgIT09IHZvaWQgMCA/IF90aGlzJHByb3BzJG1hcmdpbiRsZSA6IDAsXHJcbiAgICAgICAgICAgIHRvcDogKF90aGlzJHByb3BzJG1hcmdpbiR0byA9IHRoaXMucHJvcHMubWFyZ2luLnRvcCkgIT09IG51bGwgJiYgX3RoaXMkcHJvcHMkbWFyZ2luJHRvICE9PSB2b2lkIDAgPyBfdGhpcyRwcm9wcyRtYXJnaW4kdG8gOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgY29vcmRpbmF0ZUxpc3Q6IHRoaXMuc3RhdGUudG9vbHRpcFRpY2tzLFxyXG4gICAgICAgICAgbW91c2VIYW5kbGVyQ2FsbGJhY2s6IHRoaXMudHJpZ2dlcmVkQWZ0ZXJNb3VzZU1vdmUsXHJcbiAgICAgICAgICBsYXlvdXQ6IHRoaXMucHJvcHMubGF5b3V0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5RGVmYXVsdFRvb2x0aXAoKTtcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICBrZXk6IFwiZGlzcGxheURlZmF1bHRUb29sdGlwXCIsXHJcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwbGF5RGVmYXVsdFRvb2x0aXAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzJHByb3BzNSA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzNS5jaGlsZHJlbixcclxuICAgICAgICAgIGRhdGEgPSBfdGhpcyRwcm9wczUuZGF0YSxcclxuICAgICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzNS5oZWlnaHQsXHJcbiAgICAgICAgICBsYXlvdXQgPSBfdGhpcyRwcm9wczUubGF5b3V0O1xyXG4gICAgICAgIHZhciB0b29sdGlwRWxlbSA9ICgwLCBfUmVhY3RVdGlscy5maW5kQ2hpbGRCeVR5cGUpKGNoaWxkcmVuLCBfVG9vbHRpcC5Ub29sdGlwKTtcclxuICAgICAgICAvLyBJZiB0aGUgY2hhcnQgZG9lc24ndCBpbmNsdWRlIGEgPFRvb2x0aXAgLz4gZWxlbWVudCwgdGhlcmUncyBubyB0b29sdGlwIHRvIGRpc3BsYXlcclxuICAgICAgICBpZiAoIXRvb2x0aXBFbGVtKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkZWZhdWx0SW5kZXggPSB0b29sdGlwRWxlbS5wcm9wcy5kZWZhdWx0SW5kZXg7XHJcblxyXG4gICAgICAgIC8vIFByb3RlY3QgYWdhaW5zdCBydW50aW1lIGVycm9yc1xyXG4gICAgICAgIGlmICh0eXBlb2YgZGVmYXVsdEluZGV4ICE9PSAnbnVtYmVyJyB8fCBkZWZhdWx0SW5kZXggPCAwIHx8IGRlZmF1bHRJbmRleCA+IHRoaXMuc3RhdGUudG9vbHRpcFRpY2tzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFjdGl2ZUxhYmVsID0gdGhpcy5zdGF0ZS50b29sdGlwVGlja3NbZGVmYXVsdEluZGV4XSAmJiB0aGlzLnN0YXRlLnRvb2x0aXBUaWNrc1tkZWZhdWx0SW5kZXhdLnZhbHVlO1xyXG4gICAgICAgIHZhciBhY3RpdmVQYXlsb2FkID0gZ2V0VG9vbHRpcENvbnRlbnQodGhpcy5zdGF0ZSwgZGF0YSwgZGVmYXVsdEluZGV4LCBhY3RpdmVMYWJlbCk7XHJcbiAgICAgICAgdmFyIGluZGVwZW5kZW50QXhpc0Nvb3JkID0gdGhpcy5zdGF0ZS50b29sdGlwVGlja3NbZGVmYXVsdEluZGV4XS5jb29yZGluYXRlO1xyXG4gICAgICAgIHZhciBkZXBlbmRlbnRBeGlzQ29vcmQgPSAodGhpcy5zdGF0ZS5vZmZzZXQudG9wICsgaGVpZ2h0KSAvIDI7XHJcbiAgICAgICAgdmFyIGlzSG9yaXpvbnRhbCA9IGxheW91dCA9PT0gJ2hvcml6b250YWwnO1xyXG4gICAgICAgIHZhciBhY3RpdmVDb29yZGluYXRlID0gaXNIb3Jpem9udGFsID8ge1xyXG4gICAgICAgICAgeDogaW5kZXBlbmRlbnRBeGlzQ29vcmQsXHJcbiAgICAgICAgICB5OiBkZXBlbmRlbnRBeGlzQ29vcmRcclxuICAgICAgICB9IDoge1xyXG4gICAgICAgICAgeTogaW5kZXBlbmRlbnRBeGlzQ29vcmQsXHJcbiAgICAgICAgICB4OiBkZXBlbmRlbnRBeGlzQ29vcmRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBVbmxpa2Ugb3RoZXIgY2hhcnQgdHlwZXMsIHNjYXR0ZXIgcGxvdCdzIHRvb2x0aXAgcG9zaXRpb25zIHJlbHkgb24gYm90aCBYIGFuZCBZIGNvb3JkaW5hdGVzLiBPbmx5IHRoZSBzY2F0dGVyIHBsb3RcclxuICAgICAgICAvLyBlbGVtZW50IGtub3dzIGl0cyBvd24gWSBjb29yZGluYXRlcy5cclxuICAgICAgICAvLyBJZiB0aGVyZSdzIGEgc2NhdHRlciBwbG90LCB3ZSdsbCB3YW50IHRvIGdyYWIgdGhhdCBlbGVtZW50IGZvciBhbiBpbnRlcnJvZ2F0aW9uLlxyXG4gICAgICAgIHZhciBzY2F0dGVyUGxvdEVsZW1lbnQgPSB0aGlzLnN0YXRlLmZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zLmZpbmQoZnVuY3Rpb24gKF9yZWYxMikge1xyXG4gICAgICAgICAgdmFyIGl0ZW0gPSBfcmVmMTIuaXRlbTtcclxuICAgICAgICAgIHJldHVybiBpdGVtLnR5cGUubmFtZSA9PT0gJ1NjYXR0ZXInO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChzY2F0dGVyUGxvdEVsZW1lbnQpIHtcclxuICAgICAgICAgIGFjdGl2ZUNvb3JkaW5hdGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGFjdGl2ZUNvb3JkaW5hdGUpLCBzY2F0dGVyUGxvdEVsZW1lbnQucHJvcHMucG9pbnRzW2RlZmF1bHRJbmRleF0udG9vbHRpcFBvc2l0aW9uKTtcclxuICAgICAgICAgIGFjdGl2ZVBheWxvYWQgPSBzY2F0dGVyUGxvdEVsZW1lbnQucHJvcHMucG9pbnRzW2RlZmF1bHRJbmRleF0udG9vbHRpcFBheWxvYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuZXh0U3RhdGUgPSB7XHJcbiAgICAgICAgICBhY3RpdmVUb29sdGlwSW5kZXg6IGRlZmF1bHRJbmRleCxcclxuICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogdHJ1ZSxcclxuICAgICAgICAgIGFjdGl2ZUxhYmVsOiBhY3RpdmVMYWJlbCxcclxuICAgICAgICAgIGFjdGl2ZVBheWxvYWQ6IGFjdGl2ZVBheWxvYWQsXHJcbiAgICAgICAgICBhY3RpdmVDb29yZGluYXRlOiBhY3RpdmVDb29yZGluYXRlXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnNldFN0YXRlKG5leHRTdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJDdXJzb3IodG9vbHRpcEVsZW0pO1xyXG5cclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBhbnlvbmUgd2hvIGtleWJvYXJkLW9ubHkgdXNlcnMgd2hvIHRhYiB0byB0aGUgY2hhcnQgd2lsbCBzdGFydCB0aGVpclxyXG4gICAgICAgIC8vIGN1cnNvcnMgYXQgZGVmYXVsdEluZGV4XHJcbiAgICAgICAgdGhpcy5hY2Nlc3NpYmlsaXR5TWFuYWdlci5zZXRJbmRleChkZWZhdWx0SW5kZXgpO1xyXG4gICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgIGtleTogXCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVwiLFxyXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcclxuICAgICAgICBpZiAoIXRoaXMucHJvcHMuYWNjZXNzaWJpbGl0eUxheWVyKSB7XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUudG9vbHRpcFRpY2tzICE9PSBwcmV2U3RhdGUudG9vbHRpcFRpY2tzKSB7XHJcbiAgICAgICAgICB0aGlzLmFjY2Vzc2liaWxpdHlNYW5hZ2VyLnNldERldGFpbHMoe1xyXG4gICAgICAgICAgICBjb29yZGluYXRlTGlzdDogdGhpcy5zdGF0ZS50b29sdGlwVGlja3NcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5sYXlvdXQgIT09IHByZXZQcm9wcy5sYXlvdXQpIHtcclxuICAgICAgICAgIHRoaXMuYWNjZXNzaWJpbGl0eU1hbmFnZXIuc2V0RGV0YWlscyh7XHJcbiAgICAgICAgICAgIGxheW91dDogdGhpcy5wcm9wcy5sYXlvdXRcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5tYXJnaW4gIT09IHByZXZQcm9wcy5tYXJnaW4pIHtcclxuICAgICAgICAgIHZhciBfdGhpcyRwcm9wcyRtYXJnaW4kbGUyLCBfdGhpcyRwcm9wcyRtYXJnaW4kdG8yO1xyXG4gICAgICAgICAgdGhpcy5hY2Nlc3NpYmlsaXR5TWFuYWdlci5zZXREZXRhaWxzKHtcclxuICAgICAgICAgICAgb2Zmc2V0OiB7XHJcbiAgICAgICAgICAgICAgbGVmdDogKF90aGlzJHByb3BzJG1hcmdpbiRsZTIgPSB0aGlzLnByb3BzLm1hcmdpbi5sZWZ0KSAhPT0gbnVsbCAmJiBfdGhpcyRwcm9wcyRtYXJnaW4kbGUyICE9PSB2b2lkIDAgPyBfdGhpcyRwcm9wcyRtYXJnaW4kbGUyIDogMCxcclxuICAgICAgICAgICAgICB0b3A6IChfdGhpcyRwcm9wcyRtYXJnaW4kdG8yID0gdGhpcy5wcm9wcy5tYXJnaW4udG9wKSAhPT0gbnVsbCAmJiBfdGhpcyRwcm9wcyRtYXJnaW4kdG8yICE9PSB2b2lkIDAgPyBfdGhpcyRwcm9wcyRtYXJnaW4kdG8yIDogMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNvbWV0aGluZyBoYXMgdG8gYmUgcmV0dXJuZWQgZm9yIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0sIHtcclxuICAgICAga2V5OiBcImNvbXBvbmVudERpZFVwZGF0ZVwiLFxyXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xyXG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgVG9vbHRpcCB1cGRhdGVkLiBJZiBzbywgcmUtY2hlY2sgZGVmYXVsdCB0b29sdGlwIHBvc2l0aW9uXHJcbiAgICAgICAgaWYgKCEoMCwgX1JlYWN0VXRpbHMuaXNDaGlsZHJlbkVxdWFsKShbKDAsIF9SZWFjdFV0aWxzLmZpbmRDaGlsZEJ5VHlwZSkocHJldlByb3BzLmNoaWxkcmVuLCBfVG9vbHRpcC5Ub29sdGlwKV0sIFsoMCwgX1JlYWN0VXRpbHMuZmluZENoaWxkQnlUeXBlKSh0aGlzLnByb3BzLmNoaWxkcmVuLCBfVG9vbHRpcC5Ub29sdGlwKV0pKSB7XHJcbiAgICAgICAgICB0aGlzLmRpc3BsYXlEZWZhdWx0VG9vbHRpcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcclxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoKTtcclxuICAgICAgICB0aGlzLnRocm90dGxlVHJpZ2dlcmVkQWZ0ZXJNb3VzZU1vdmUuY2FuY2VsKCk7XHJcbiAgICAgIH1cclxuICAgIH0sIHtcclxuICAgICAga2V5OiBcImdldFRvb2x0aXBFdmVudFR5cGVcIixcclxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRvb2x0aXBFdmVudFR5cGUoKSB7XHJcbiAgICAgICAgdmFyIHRvb2x0aXBJdGVtID0gKDAsIF9SZWFjdFV0aWxzLmZpbmRDaGlsZEJ5VHlwZSkodGhpcy5wcm9wcy5jaGlsZHJlbiwgX1Rvb2x0aXAuVG9vbHRpcCk7XHJcbiAgICAgICAgaWYgKHRvb2x0aXBJdGVtICYmIHR5cGVvZiB0b29sdGlwSXRlbS5wcm9wcy5zaGFyZWQgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgdmFyIGV2ZW50VHlwZSA9IHRvb2x0aXBJdGVtLnByb3BzLnNoYXJlZCA/ICdheGlzJyA6ICdpdGVtJztcclxuICAgICAgICAgIHJldHVybiB2YWxpZGF0ZVRvb2x0aXBFdmVudFR5cGVzLmluZGV4T2YoZXZlbnRUeXBlKSA+PSAwID8gZXZlbnRUeXBlIDogZGVmYXVsdFRvb2x0aXBFdmVudFR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWZhdWx0VG9vbHRpcEV2ZW50VHlwZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEdldCB0aGUgaW5mb3JtYXRpb24gb2YgbW91c2UgaW4gY2hhcnQsIHJldHVybiBudWxsIHdoZW4gdGhlIG1vdXNlIGlzIG5vdCBpbiB0aGUgY2hhcnRcclxuICAgICAgICogQHBhcmFtICB7TW91c2VQb2ludGVyfSBldmVudCAgICBUaGUgZXZlbnQgb2JqZWN0XHJcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgTW91c2UgZGF0YVxyXG4gICAgICAgKi9cclxuICAgIH0sIHtcclxuICAgICAga2V5OiBcImdldE1vdXNlSW5mb1wiLFxyXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TW91c2VJbmZvKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lcikge1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5jb250YWluZXI7XHJcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgdmFyIGNvbnRhaW5lck9mZnNldCA9ICgwLCBfRE9NVXRpbHMuZ2V0T2Zmc2V0KShib3VuZGluZ1JlY3QpO1xyXG4gICAgICAgIHZhciBlID0ge1xyXG4gICAgICAgICAgY2hhcnRYOiBNYXRoLnJvdW5kKGV2ZW50LnBhZ2VYIC0gY29udGFpbmVyT2Zmc2V0LmxlZnQpLFxyXG4gICAgICAgICAgY2hhcnRZOiBNYXRoLnJvdW5kKGV2ZW50LnBhZ2VZIC0gY29udGFpbmVyT2Zmc2V0LnRvcClcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBzY2FsZSA9IGJvdW5kaW5nUmVjdC53aWR0aCAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMTtcclxuICAgICAgICB2YXIgcmFuZ2VPYmogPSB0aGlzLmluUmFuZ2UoZS5jaGFydFgsIGUuY2hhcnRZLCBzY2FsZSk7XHJcbiAgICAgICAgaWYgKCFyYW5nZU9iaikge1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfdGhpcyRzdGF0ZTkgPSB0aGlzLnN0YXRlLFxyXG4gICAgICAgICAgeEF4aXNNYXAgPSBfdGhpcyRzdGF0ZTkueEF4aXNNYXAsXHJcbiAgICAgICAgICB5QXhpc01hcCA9IF90aGlzJHN0YXRlOS55QXhpc01hcDtcclxuICAgICAgICB2YXIgdG9vbHRpcEV2ZW50VHlwZSA9IHRoaXMuZ2V0VG9vbHRpcEV2ZW50VHlwZSgpO1xyXG4gICAgICAgIHZhciB0b29sVGlwRGF0YSA9IGdldFRvb2x0aXBEYXRhKHRoaXMuc3RhdGUsIHRoaXMucHJvcHMuZGF0YSwgdGhpcy5wcm9wcy5sYXlvdXQsIHJhbmdlT2JqKTtcclxuICAgICAgICBpZiAodG9vbHRpcEV2ZW50VHlwZSAhPT0gJ2F4aXMnICYmIHhBeGlzTWFwICYmIHlBeGlzTWFwKSB7XHJcbiAgICAgICAgICB2YXIgeFNjYWxlID0gKDAsIF9EYXRhVXRpbHMuZ2V0QW55RWxlbWVudE9mT2JqZWN0KSh4QXhpc01hcCkuc2NhbGU7XHJcbiAgICAgICAgICB2YXIgeVNjYWxlID0gKDAsIF9EYXRhVXRpbHMuZ2V0QW55RWxlbWVudE9mT2JqZWN0KSh5QXhpc01hcCkuc2NhbGU7XHJcbiAgICAgICAgICB2YXIgeFZhbHVlID0geFNjYWxlICYmIHhTY2FsZS5pbnZlcnQgPyB4U2NhbGUuaW52ZXJ0KGUuY2hhcnRYKSA6IG51bGw7XHJcbiAgICAgICAgICB2YXIgeVZhbHVlID0geVNjYWxlICYmIHlTY2FsZS5pbnZlcnQgPyB5U2NhbGUuaW52ZXJ0KGUuY2hhcnRZKSA6IG51bGw7XHJcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlKSwge30sIHtcclxuICAgICAgICAgICAgeFZhbHVlOiB4VmFsdWUsXHJcbiAgICAgICAgICAgIHlWYWx1ZTogeVZhbHVlXHJcbiAgICAgICAgICB9LCB0b29sVGlwRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b29sVGlwRGF0YSkge1xyXG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZSksIHRvb2xUaXBEYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0sIHtcclxuICAgICAga2V5OiBcImluUmFuZ2VcIixcclxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluUmFuZ2UoeCwgeSkge1xyXG4gICAgICAgIHZhciBzY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcclxuICAgICAgICB2YXIgbGF5b3V0ID0gdGhpcy5wcm9wcy5sYXlvdXQ7XHJcbiAgICAgICAgdmFyIHNjYWxlZFggPSB4IC8gc2NhbGUsXHJcbiAgICAgICAgICBzY2FsZWRZID0geSAvIHNjYWxlO1xyXG4gICAgICAgIGlmIChsYXlvdXQgPT09ICdob3Jpem9udGFsJyB8fCBsYXlvdXQgPT09ICd2ZXJ0aWNhbCcpIHtcclxuICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnN0YXRlLm9mZnNldDtcclxuICAgICAgICAgIHZhciBpc0luUmFuZ2UgPSBzY2FsZWRYID49IG9mZnNldC5sZWZ0ICYmIHNjYWxlZFggPD0gb2Zmc2V0LmxlZnQgKyBvZmZzZXQud2lkdGggJiYgc2NhbGVkWSA+PSBvZmZzZXQudG9wICYmIHNjYWxlZFkgPD0gb2Zmc2V0LnRvcCArIG9mZnNldC5oZWlnaHQ7XHJcbiAgICAgICAgICByZXR1cm4gaXNJblJhbmdlID8ge1xyXG4gICAgICAgICAgICB4OiBzY2FsZWRYLFxyXG4gICAgICAgICAgICB5OiBzY2FsZWRZXHJcbiAgICAgICAgICB9IDogbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF90aGlzJHN0YXRlMTAgPSB0aGlzLnN0YXRlLFxyXG4gICAgICAgICAgYW5nbGVBeGlzTWFwID0gX3RoaXMkc3RhdGUxMC5hbmdsZUF4aXNNYXAsXHJcbiAgICAgICAgICByYWRpdXNBeGlzTWFwID0gX3RoaXMkc3RhdGUxMC5yYWRpdXNBeGlzTWFwO1xyXG4gICAgICAgIGlmIChhbmdsZUF4aXNNYXAgJiYgcmFkaXVzQXhpc01hcCkge1xyXG4gICAgICAgICAgdmFyIGFuZ2xlQXhpcyA9ICgwLCBfRGF0YVV0aWxzLmdldEFueUVsZW1lbnRPZk9iamVjdCkoYW5nbGVBeGlzTWFwKTtcclxuICAgICAgICAgIHJldHVybiAoMCwgX1BvbGFyVXRpbHMuaW5SYW5nZU9mU2VjdG9yKSh7XHJcbiAgICAgICAgICAgIHg6IHNjYWxlZFgsXHJcbiAgICAgICAgICAgIHk6IHNjYWxlZFlcclxuICAgICAgICAgIH0sIGFuZ2xlQXhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgIGtleTogXCJwYXJzZUV2ZW50c09mV3JhcHBlclwiLFxyXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VFdmVudHNPZldyYXBwZXIoKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcclxuICAgICAgICB2YXIgdG9vbHRpcEV2ZW50VHlwZSA9IHRoaXMuZ2V0VG9vbHRpcEV2ZW50VHlwZSgpO1xyXG4gICAgICAgIHZhciB0b29sdGlwSXRlbSA9ICgwLCBfUmVhY3RVdGlscy5maW5kQ2hpbGRCeVR5cGUpKGNoaWxkcmVuLCBfVG9vbHRpcC5Ub29sdGlwKTtcclxuICAgICAgICB2YXIgdG9vbHRpcEV2ZW50cyA9IHt9O1xyXG4gICAgICAgIGlmICh0b29sdGlwSXRlbSAmJiB0b29sdGlwRXZlbnRUeXBlID09PSAnYXhpcycpIHtcclxuICAgICAgICAgIGlmICh0b29sdGlwSXRlbS5wcm9wcy50cmlnZ2VyID09PSAnY2xpY2snKSB7XHJcbiAgICAgICAgICAgIHRvb2x0aXBFdmVudHMgPSB7XHJcbiAgICAgICAgICAgICAgb25DbGljazogdGhpcy5oYW5kbGVDbGlja1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdG9vbHRpcEV2ZW50cyA9IHtcclxuICAgICAgICAgICAgICBvbk1vdXNlRW50ZXI6IHRoaXMuaGFuZGxlTW91c2VFbnRlcixcclxuICAgICAgICAgICAgICBvbkRvdWJsZUNsaWNrOiB0aGlzLmhhbmRsZURvdWJsZUNsaWNrLFxyXG4gICAgICAgICAgICAgIG9uTW91c2VNb3ZlOiB0aGlzLmhhbmRsZU1vdXNlTW92ZSxcclxuICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU6IHRoaXMuaGFuZGxlTW91c2VMZWF2ZSxcclxuICAgICAgICAgICAgICBvblRvdWNoTW92ZTogdGhpcy5oYW5kbGVUb3VjaE1vdmUsXHJcbiAgICAgICAgICAgICAgb25Ub3VjaFN0YXJ0OiB0aGlzLmhhbmRsZVRvdWNoU3RhcnQsXHJcbiAgICAgICAgICAgICAgb25Ub3VjaEVuZDogdGhpcy5oYW5kbGVUb3VjaEVuZCxcclxuICAgICAgICAgICAgICBvbkNvbnRleHRNZW51OiB0aGlzLmhhbmRsZUNvbnRleHRNZW51XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGFkYXB0RXZlbnRIYW5kbGVycyBleHBlY3RzIERPTSBFdmVudCBidXQgZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0IHdvcmtzIHdpdGggUmVhY3QgVUlFdmVudHNcclxuICAgICAgICB2YXIgb3V0ZXJFdmVudHMgPSAoMCwgX3R5cGVzLmFkYXB0RXZlbnRIYW5kbGVycykodGhpcy5wcm9wcywgdGhpcy5oYW5kbGVPdXRlckV2ZW50KTtcclxuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvdXRlckV2ZW50cyksIHRvb2x0aXBFdmVudHMpO1xyXG4gICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgIGtleTogXCJhZGRMaXN0ZW5lclwiLFxyXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTGlzdGVuZXIoKSB7XHJcbiAgICAgICAgX0V2ZW50cy5ldmVudENlbnRlci5vbihfRXZlbnRzLlNZTkNfRVZFTlQsIHRoaXMuaGFuZGxlUmVjZWl2ZVN5bmNFdmVudCk7XHJcbiAgICAgIH1cclxuICAgIH0sIHtcclxuICAgICAga2V5OiBcInJlbW92ZUxpc3RlbmVyXCIsXHJcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcigpIHtcclxuICAgICAgICBfRXZlbnRzLmV2ZW50Q2VudGVyLnJlbW92ZUxpc3RlbmVyKF9FdmVudHMuU1lOQ19FVkVOVCwgdGhpcy5oYW5kbGVSZWNlaXZlU3luY0V2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICBrZXk6IFwiZmlsdGVyRm9ybWF0SXRlbVwiLFxyXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmlsdGVyRm9ybWF0SXRlbShpdGVtLCBkaXNwbGF5TmFtZSwgY2hpbGRJbmRleCkge1xyXG4gICAgICAgIHZhciBmb3JtYXR0ZWRHcmFwaGljYWxJdGVtcyA9IHRoaXMuc3RhdGUuZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgZW50cnkgPSBmb3JtYXR0ZWRHcmFwaGljYWxJdGVtc1tpXTtcclxuICAgICAgICAgIGlmIChlbnRyeS5pdGVtID09PSBpdGVtIHx8IGVudHJ5LnByb3BzLmtleSA9PT0gaXRlbS5rZXkgfHwgZGlzcGxheU5hbWUgPT09ICgwLCBfUmVhY3RVdGlscy5nZXREaXNwbGF5TmFtZSkoZW50cnkuaXRlbS50eXBlKSAmJiBjaGlsZEluZGV4ID09PSBlbnRyeS5jaGlsZEluZGV4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyeTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0sIHtcclxuICAgICAga2V5OiBcInJlbmRlckNsaXBQYXRoXCIsXHJcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDbGlwUGF0aCgpIHtcclxuICAgICAgICB2YXIgY2xpcFBhdGhJZCA9IHRoaXMuY2xpcFBhdGhJZDtcclxuICAgICAgICB2YXIgX3RoaXMkc3RhdGUkb2Zmc2V0ID0gdGhpcy5zdGF0ZS5vZmZzZXQsXHJcbiAgICAgICAgICBsZWZ0ID0gX3RoaXMkc3RhdGUkb2Zmc2V0LmxlZnQsXHJcbiAgICAgICAgICB0b3AgPSBfdGhpcyRzdGF0ZSRvZmZzZXQudG9wLFxyXG4gICAgICAgICAgaGVpZ2h0ID0gX3RoaXMkc3RhdGUkb2Zmc2V0LmhlaWdodCxcclxuICAgICAgICAgIHdpZHRoID0gX3RoaXMkc3RhdGUkb2Zmc2V0LndpZHRoO1xyXG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiLCBudWxsLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIiwge1xyXG4gICAgICAgICAgaWQ6IGNsaXBQYXRoSWRcclxuICAgICAgICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XHJcbiAgICAgICAgICB4OiBsZWZ0LFxyXG4gICAgICAgICAgeTogdG9wLFxyXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICB3aWR0aDogd2lkdGhcclxuICAgICAgICB9KSkpO1xyXG4gICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgIGtleTogXCJnZXRYU2NhbGVzXCIsXHJcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRYU2NhbGVzKCkge1xyXG4gICAgICAgIHZhciB4QXhpc01hcCA9IHRoaXMuc3RhdGUueEF4aXNNYXA7XHJcbiAgICAgICAgcmV0dXJuIHhBeGlzTWFwID8gT2JqZWN0LmVudHJpZXMoeEF4aXNNYXApLnJlZHVjZShmdW5jdGlvbiAocmVzLCBfcmVmMTMpIHtcclxuICAgICAgICAgIHZhciBfcmVmMTQgPSBfc2xpY2VkVG9BcnJheShfcmVmMTMsIDIpLFxyXG4gICAgICAgICAgICBheGlzSWQgPSBfcmVmMTRbMF0sXHJcbiAgICAgICAgICAgIGF4aXNQcm9wcyA9IF9yZWYxNFsxXTtcclxuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlcyksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGF4aXNJZCwgYXhpc1Byb3BzLnNjYWxlKSk7XHJcbiAgICAgICAgfSwge30pIDogbnVsbDtcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICBrZXk6IFwiZ2V0WVNjYWxlc1wiLFxyXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0WVNjYWxlcygpIHtcclxuICAgICAgICB2YXIgeUF4aXNNYXAgPSB0aGlzLnN0YXRlLnlBeGlzTWFwO1xyXG4gICAgICAgIHJldHVybiB5QXhpc01hcCA/IE9iamVjdC5lbnRyaWVzKHlBeGlzTWFwKS5yZWR1Y2UoZnVuY3Rpb24gKHJlcywgX3JlZjE1KSB7XHJcbiAgICAgICAgICB2YXIgX3JlZjE2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjE1LCAyKSxcclxuICAgICAgICAgICAgYXhpc0lkID0gX3JlZjE2WzBdLFxyXG4gICAgICAgICAgICBheGlzUHJvcHMgPSBfcmVmMTZbMV07XHJcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXMpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBheGlzSWQsIGF4aXNQcm9wcy5zY2FsZSkpO1xyXG4gICAgICAgIH0sIHt9KSA6IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0sIHtcclxuICAgICAga2V5OiBcImdldFhTY2FsZUJ5QXhpc0lkXCIsXHJcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRYU2NhbGVCeUF4aXNJZChheGlzSWQpIHtcclxuICAgICAgICB2YXIgX3RoaXMkc3RhdGUkeEF4aXNNYXA7XHJcbiAgICAgICAgcmV0dXJuIChfdGhpcyRzdGF0ZSR4QXhpc01hcCA9IHRoaXMuc3RhdGUueEF4aXNNYXApID09PSBudWxsIHx8IF90aGlzJHN0YXRlJHhBeGlzTWFwID09PSB2b2lkIDAgfHwgKF90aGlzJHN0YXRlJHhBeGlzTWFwID0gX3RoaXMkc3RhdGUkeEF4aXNNYXBbYXhpc0lkXSkgPT09IG51bGwgfHwgX3RoaXMkc3RhdGUkeEF4aXNNYXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHN0YXRlJHhBeGlzTWFwLnNjYWxlO1xyXG4gICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgIGtleTogXCJnZXRZU2NhbGVCeUF4aXNJZFwiLFxyXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0WVNjYWxlQnlBeGlzSWQoYXhpc0lkKSB7XHJcbiAgICAgICAgdmFyIF90aGlzJHN0YXRlJHlBeGlzTWFwO1xyXG4gICAgICAgIHJldHVybiAoX3RoaXMkc3RhdGUkeUF4aXNNYXAgPSB0aGlzLnN0YXRlLnlBeGlzTWFwKSA9PT0gbnVsbCB8fCBfdGhpcyRzdGF0ZSR5QXhpc01hcCA9PT0gdm9pZCAwIHx8IChfdGhpcyRzdGF0ZSR5QXhpc01hcCA9IF90aGlzJHN0YXRlJHlBeGlzTWFwW2F4aXNJZF0pID09PSBudWxsIHx8IF90aGlzJHN0YXRlJHlBeGlzTWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRzdGF0ZSR5QXhpc01hcC5zY2FsZTtcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICBrZXk6IFwiZ2V0SXRlbUJ5WFlcIixcclxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEl0ZW1CeVhZKGNoYXJ0WFkpIHtcclxuICAgICAgICB2YXIgX3RoaXMkc3RhdGUxMSA9IHRoaXMuc3RhdGUsXHJcbiAgICAgICAgICBmb3JtYXR0ZWRHcmFwaGljYWxJdGVtcyA9IF90aGlzJHN0YXRlMTEuZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXMsXHJcbiAgICAgICAgICBhY3RpdmVJdGVtID0gX3RoaXMkc3RhdGUxMS5hY3RpdmVJdGVtO1xyXG4gICAgICAgIGlmIChmb3JtYXR0ZWRHcmFwaGljYWxJdGVtcyAmJiBmb3JtYXR0ZWRHcmFwaGljYWxJdGVtcy5sZW5ndGgpIHtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmb3JtYXR0ZWRHcmFwaGljYWxJdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgZ3JhcGhpY2FsSXRlbSA9IGZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zW2ldO1xyXG4gICAgICAgICAgICAvLyBncmFwaGljYWxJdGVtIGlzIG5vdCBhIFJlYWN0IEVsZW1lbnQgc28gd2UgZG9uJ3QgbmVlZCB0byByZXNvbHZlIGRlZmF1bHRQcm9wc1xyXG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBncmFwaGljYWxJdGVtLnByb3BzLFxyXG4gICAgICAgICAgICAgIGl0ZW0gPSBncmFwaGljYWxJdGVtLml0ZW07XHJcbiAgICAgICAgICAgIHZhciBpdGVtUHJvcHMgPSBpdGVtLnR5cGUuZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGl0ZW0udHlwZS5kZWZhdWx0UHJvcHMpLCBpdGVtLnByb3BzKSA6IGl0ZW0ucHJvcHM7XHJcbiAgICAgICAgICAgIHZhciBpdGVtRGlzcGxheU5hbWUgPSAoMCwgX1JlYWN0VXRpbHMuZ2V0RGlzcGxheU5hbWUpKGl0ZW0udHlwZSk7XHJcbiAgICAgICAgICAgIGlmIChpdGVtRGlzcGxheU5hbWUgPT09ICdCYXInKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGFjdGl2ZUJhckl0ZW0gPSAocHJvcHMuZGF0YSB8fCBbXSkuZmluZChmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX1JlY3RhbmdsZS5pc0luUmVjdGFuZ2xlKShjaGFydFhZLCBlbnRyeSk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgaWYgKGFjdGl2ZUJhckl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgIGdyYXBoaWNhbEl0ZW06IGdyYXBoaWNhbEl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGFjdGl2ZUJhckl0ZW1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW1EaXNwbGF5TmFtZSA9PT0gJ1JhZGlhbEJhcicpIHtcclxuICAgICAgICAgICAgICB2YXIgX2FjdGl2ZUJhckl0ZW0gPSAocHJvcHMuZGF0YSB8fCBbXSkuZmluZChmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX1BvbGFyVXRpbHMuaW5SYW5nZU9mU2VjdG9yKShjaGFydFhZLCBlbnRyeSk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgaWYgKF9hY3RpdmVCYXJJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICBncmFwaGljYWxJdGVtOiBncmFwaGljYWxJdGVtLFxyXG4gICAgICAgICAgICAgICAgICBwYXlsb2FkOiBfYWN0aXZlQmFySXRlbVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKDAsIF9BY3RpdmVTaGFwZVV0aWxzLmlzRnVubmVsKShncmFwaGljYWxJdGVtLCBhY3RpdmVJdGVtKSB8fCAoMCwgX0FjdGl2ZVNoYXBlVXRpbHMuaXNQaWUpKGdyYXBoaWNhbEl0ZW0sIGFjdGl2ZUl0ZW0pIHx8ICgwLCBfQWN0aXZlU2hhcGVVdGlscy5pc1NjYXR0ZXIpKGdyYXBoaWNhbEl0ZW0sIGFjdGl2ZUl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGFjdGl2ZUluZGV4ID0gKDAsIF9BY3RpdmVTaGFwZVV0aWxzLmdldEFjdGl2ZVNoYXBlSW5kZXhGb3JUb29sdGlwKSh7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljYWxJdGVtOiBncmFwaGljYWxJdGVtLFxyXG4gICAgICAgICAgICAgICAgYWN0aXZlVG9vbHRpcEl0ZW06IGFjdGl2ZUl0ZW0sXHJcbiAgICAgICAgICAgICAgICBpdGVtRGF0YTogaXRlbVByb3BzLmRhdGFcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB2YXIgY2hpbGRJbmRleCA9IGl0ZW1Qcm9wcy5hY3RpdmVJbmRleCA9PT0gdW5kZWZpbmVkID8gYWN0aXZlSW5kZXggOiBpdGVtUHJvcHMuYWN0aXZlSW5kZXg7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWNhbEl0ZW06IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZ3JhcGhpY2FsSXRlbSksIHt9LCB7XHJcbiAgICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IGNoaWxkSW5kZXhcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogKDAsIF9BY3RpdmVTaGFwZVV0aWxzLmlzU2NhdHRlcikoZ3JhcGhpY2FsSXRlbSwgYWN0aXZlSXRlbSkgPyBpdGVtUHJvcHMuZGF0YVthY3RpdmVJbmRleF0gOiBncmFwaGljYWxJdGVtLnByb3BzLmRhdGFbYWN0aXZlSW5kZXhdXHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICBrZXk6IFwicmVuZGVyXCIsXHJcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCEoMCwgX1JlYWN0VXRpbHMudmFsaWRhdGVXaWR0aEhlaWdodCkodGhpcykpIHtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX3RoaXMkcHJvcHM2ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHM2LmNoaWxkcmVuLFxyXG4gICAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHM2LmNsYXNzTmFtZSxcclxuICAgICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHM2LndpZHRoLFxyXG4gICAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHM2LmhlaWdodCxcclxuICAgICAgICAgIHN0eWxlID0gX3RoaXMkcHJvcHM2LnN0eWxlLFxyXG4gICAgICAgICAgY29tcGFjdCA9IF90aGlzJHByb3BzNi5jb21wYWN0LFxyXG4gICAgICAgICAgdGl0bGUgPSBfdGhpcyRwcm9wczYudGl0bGUsXHJcbiAgICAgICAgICBkZXNjID0gX3RoaXMkcHJvcHM2LmRlc2MsXHJcbiAgICAgICAgICBvdGhlcnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkcHJvcHM2LCBfZXhjbHVkZWQyKTtcclxuICAgICAgICB2YXIgYXR0cnMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKG90aGVycywgZmFsc2UpO1xyXG5cclxuICAgICAgICAvLyBUaGUgXCJjb21wYWN0XCIgbW9kZSBpcyBtYWlubHkgdXNlZCBhcyB0aGUgcGFub3JhbWEgd2l0aGluIEJydXNoXHJcbiAgICAgICAgaWYgKGNvbXBhY3QpIHtcclxuICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9jaGFydExheW91dENvbnRleHQuQ2hhcnRMYXlvdXRDb250ZXh0UHJvdmlkZXIsIHtcclxuICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLnByb3BzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMucHJvcHMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBjbGlwUGF0aElkOiB0aGlzLmNsaXBQYXRoSWRcclxuICAgICAgICAgIH0sIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX1N1cmZhY2UuU3VyZmFjZSwgX2V4dGVuZHMoe30sIGF0dHJzLCB7XHJcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcclxuICAgICAgICAgICAgZGVzYzogZGVzY1xyXG4gICAgICAgICAgfSksIHRoaXMucmVuZGVyQ2xpcFBhdGgoKSwgKDAsIF9SZWFjdFV0aWxzLnJlbmRlckJ5T3JkZXIpKGNoaWxkcmVuLCB0aGlzLnJlbmRlck1hcCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuYWNjZXNzaWJpbGl0eUxheWVyKSB7XHJcbiAgICAgICAgICB2YXIgX3RoaXMkcHJvcHMkdGFiSW5kZXgsIF90aGlzJHByb3BzJHJvbGU7XHJcbiAgICAgICAgICAvLyBTZXQgdGFiSW5kZXggdG8gMCBieSBkZWZhdWx0IChjYW4gYmUgb3ZlcndyaXR0ZW4pXHJcbiAgICAgICAgICBhdHRycy50YWJJbmRleCA9IChfdGhpcyRwcm9wcyR0YWJJbmRleCA9IHRoaXMucHJvcHMudGFiSW5kZXgpICE9PSBudWxsICYmIF90aGlzJHByb3BzJHRhYkluZGV4ICE9PSB2b2lkIDAgPyBfdGhpcyRwcm9wcyR0YWJJbmRleCA6IDA7XHJcbiAgICAgICAgICAvLyBTZXQgcm9sZSB0byBpbWcgYnkgZGVmYXVsdCAoY2FuIGJlIG92ZXJ3cml0dGVuKVxyXG4gICAgICAgICAgYXR0cnMucm9sZSA9IChfdGhpcyRwcm9wcyRyb2xlID0gdGhpcy5wcm9wcy5yb2xlKSAhPT0gbnVsbCAmJiBfdGhpcyRwcm9wcyRyb2xlICE9PSB2b2lkIDAgPyBfdGhpcyRwcm9wcyRyb2xlIDogJ2FwcGxpY2F0aW9uJztcclxuICAgICAgICAgIGF0dHJzLm9uS2V5RG93biA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIF90aGlzMy5hY2Nlc3NpYmlsaXR5TWFuYWdlci5rZXlib2FyZEV2ZW50KGUpO1xyXG4gICAgICAgICAgICAvLyAnb25LZXlEb3duJyBpcyBub3QgY3VycmVudGx5IGEgc3VwcG9ydGVkIHByb3AgdGhhdCBjYW4gYmUgcGFzc2VkIHRocm91Z2hcclxuICAgICAgICAgICAgLy8gaWYgaXQncyBhZGRlZCwgdGhpcyBzaG91bGQgYmUgYWRkZWQ6IHRoaXMucHJvcHMub25LZXlEb3duKGUpO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGF0dHJzLm9uRm9jdXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzMy5hY2Nlc3NpYmlsaXR5TWFuYWdlci5mb2N1cygpO1xyXG4gICAgICAgICAgICAvLyAnb25Gb2N1cycgaXMgbm90IGN1cnJlbnRseSBhIHN1cHBvcnRlZCBwcm9wIHRoYXQgY2FuIGJlIHBhc3NlZCB0aHJvdWdoXHJcbiAgICAgICAgICAgIC8vIGlmIGl0J3MgYWRkZWQsIHRoZSBmb2N1cyBldmVudCBzaG91bGQgYmUgZm9yd2FyZGVkIHRvIHRoZSBwcm9wXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5wYXJzZUV2ZW50c09mV3JhcHBlcigpO1xyXG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9jaGFydExheW91dENvbnRleHQuQ2hhcnRMYXlvdXRDb250ZXh0UHJvdmlkZXIsIHtcclxuICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxyXG4gICAgICAgICAgd2lkdGg6IHRoaXMucHJvcHMud2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQ6IHRoaXMucHJvcHMuaGVpZ2h0LFxyXG4gICAgICAgICAgY2xpcFBhdGhJZDogdGhpcy5jbGlwUGF0aElkXHJcbiAgICAgICAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XHJcbiAgICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy13cmFwcGVyJywgY2xhc3NOYW1lKSxcclxuICAgICAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKHtcclxuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxyXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICAgICAgICB9LCBzdHlsZSlcclxuICAgICAgICB9LCBldmVudHMsIHtcclxuICAgICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKG5vZGUpIHtcclxuICAgICAgICAgICAgX3RoaXMzLmNvbnRhaW5lciA9IG5vZGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSksIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX1N1cmZhY2UuU3VyZmFjZSwgX2V4dGVuZHMoe30sIGF0dHJzLCB7XHJcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgIHRpdGxlOiB0aXRsZSxcclxuICAgICAgICAgIGRlc2M6IGRlc2MsXHJcbiAgICAgICAgICBzdHlsZTogRlVMTF9XSURUSF9BTkRfSEVJR0hUXHJcbiAgICAgICAgfSksIHRoaXMucmVuZGVyQ2xpcFBhdGgoKSwgKDAsIF9SZWFjdFV0aWxzLnJlbmRlckJ5T3JkZXIpKGNoaWxkcmVuLCB0aGlzLnJlbmRlck1hcCkpLCB0aGlzLnJlbmRlckxlZ2VuZCgpLCB0aGlzLnJlbmRlclRvb2x0aXAoKSkpO1xyXG4gICAgICB9XHJcbiAgICB9XSk7XHJcbiAgfShfcmVhY3QuQ29tcG9uZW50KTtcclxuICBfZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcmljYWxDaGFydFdyYXBwZXIsIFwiZGlzcGxheU5hbWVcIiwgY2hhcnROYW1lKTtcclxuICAvLyB0b2RvIGpvaW4gc3BlY2lmaWMgY2hhcnQgcHJvcFR5cGVzXHJcbiAgX2RlZmluZVByb3BlcnR5KENhdGVnb3JpY2FsQ2hhcnRXcmFwcGVyLCBcImRlZmF1bHRQcm9wc1wiLCBfb2JqZWN0U3ByZWFkKHtcclxuICAgIGxheW91dDogJ2hvcml6b250YWwnLFxyXG4gICAgc3RhY2tPZmZzZXQ6ICdub25lJyxcclxuICAgIGJhckNhdGVnb3J5R2FwOiAnMTAlJyxcclxuICAgIGJhckdhcDogNCxcclxuICAgIG1hcmdpbjoge1xyXG4gICAgICB0b3A6IDUsXHJcbiAgICAgIHJpZ2h0OiA1LFxyXG4gICAgICBib3R0b206IDUsXHJcbiAgICAgIGxlZnQ6IDVcclxuICAgIH0sXHJcbiAgICByZXZlcnNlU3RhY2tPcmRlcjogZmFsc2UsXHJcbiAgICBzeW5jTWV0aG9kOiAnaW5kZXgnXHJcbiAgfSwgZGVmYXVsdFByb3BzKSk7XHJcbiAgX2RlZmluZVByb3BlcnR5KENhdGVnb3JpY2FsQ2hhcnRXcmFwcGVyLCBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1wiLCBmdW5jdGlvbiAobmV4dFByb3BzLCBwcmV2U3RhdGUpIHtcclxuICAgIHZhciBkYXRhS2V5ID0gbmV4dFByb3BzLmRhdGFLZXksXHJcbiAgICAgIGRhdGEgPSBuZXh0UHJvcHMuZGF0YSxcclxuICAgICAgY2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW4sXHJcbiAgICAgIHdpZHRoID0gbmV4dFByb3BzLndpZHRoLFxyXG4gICAgICBoZWlnaHQgPSBuZXh0UHJvcHMuaGVpZ2h0LFxyXG4gICAgICBsYXlvdXQgPSBuZXh0UHJvcHMubGF5b3V0LFxyXG4gICAgICBzdGFja09mZnNldCA9IG5leHRQcm9wcy5zdGFja09mZnNldCxcclxuICAgICAgbWFyZ2luID0gbmV4dFByb3BzLm1hcmdpbjtcclxuICAgIHZhciBkYXRhU3RhcnRJbmRleCA9IHByZXZTdGF0ZS5kYXRhU3RhcnRJbmRleCxcclxuICAgICAgZGF0YUVuZEluZGV4ID0gcHJldlN0YXRlLmRhdGFFbmRJbmRleDtcclxuICAgIGlmIChwcmV2U3RhdGUudXBkYXRlSWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB2YXIgZGVmYXVsdFN0YXRlID0gY3JlYXRlRGVmYXVsdFN0YXRlKG5leHRQcm9wcyk7XHJcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdFN0YXRlKSwge30sIHtcclxuICAgICAgICB1cGRhdGVJZDogMFxyXG4gICAgICB9LCB1cGRhdGVTdGF0ZU9mQXhpc01hcHNPZmZzZXRBbmRTdGFja0dyb3Vwcyhfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xyXG4gICAgICAgIHByb3BzOiBuZXh0UHJvcHNcclxuICAgICAgfSwgZGVmYXVsdFN0YXRlKSwge30sIHtcclxuICAgICAgICB1cGRhdGVJZDogMFxyXG4gICAgICB9KSwgcHJldlN0YXRlKSksIHt9LCB7XHJcbiAgICAgICAgcHJldkRhdGFLZXk6IGRhdGFLZXksXHJcbiAgICAgICAgcHJldkRhdGE6IGRhdGEsXHJcbiAgICAgICAgcHJldldpZHRoOiB3aWR0aCxcclxuICAgICAgICBwcmV2SGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgcHJldkxheW91dDogbGF5b3V0LFxyXG4gICAgICAgIHByZXZTdGFja09mZnNldDogc3RhY2tPZmZzZXQsXHJcbiAgICAgICAgcHJldk1hcmdpbjogbWFyZ2luLFxyXG4gICAgICAgIHByZXZDaGlsZHJlbjogY2hpbGRyZW5cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGF0YUtleSAhPT0gcHJldlN0YXRlLnByZXZEYXRhS2V5IHx8IGRhdGEgIT09IHByZXZTdGF0ZS5wcmV2RGF0YSB8fCB3aWR0aCAhPT0gcHJldlN0YXRlLnByZXZXaWR0aCB8fCBoZWlnaHQgIT09IHByZXZTdGF0ZS5wcmV2SGVpZ2h0IHx8IGxheW91dCAhPT0gcHJldlN0YXRlLnByZXZMYXlvdXQgfHwgc3RhY2tPZmZzZXQgIT09IHByZXZTdGF0ZS5wcmV2U3RhY2tPZmZzZXQgfHwgISgwLCBfU2hhbGxvd0VxdWFsLnNoYWxsb3dFcXVhbCkobWFyZ2luLCBwcmV2U3RhdGUucHJldk1hcmdpbikpIHtcclxuICAgICAgdmFyIF9kZWZhdWx0U3RhdGUgPSBjcmVhdGVEZWZhdWx0U3RhdGUobmV4dFByb3BzKTtcclxuXHJcbiAgICAgIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWNoYXJ0cy9yZWNoYXJ0cy9pc3N1ZXMvMjE0M1xyXG4gICAgICB2YXIga2VlcEZyb21QcmV2U3RhdGUgPSB7XHJcbiAgICAgICAgLy8gKGNoYXJ0WCwgY2hhcnRZKSBhcmUgKDAsMCkgaW4gZGVmYXVsdCBzdGF0ZSwgYnV0IHdlIHdhbnQgdG8ga2VlcCB0aGUgbGFzdCBtb3VzZSBwb3NpdGlvbiB0byBhdm9pZFxyXG4gICAgICAgIC8vIGFueSBmbGlja2VyaW5nXHJcbiAgICAgICAgY2hhcnRYOiBwcmV2U3RhdGUuY2hhcnRYLFxyXG4gICAgICAgIGNoYXJ0WTogcHJldlN0YXRlLmNoYXJ0WSxcclxuICAgICAgICAvLyBUaGUgdG9vbHRpcCBzaG91bGQgc3RheSBhY3RpdmUgd2hlbiBpdCB3YXMgYWN0aXZlIGluIHRoZSBwcmV2aW91cyByZW5kZXIuIElmIHRoaXMgaXMgbm90XHJcbiAgICAgICAgLy8gdGhlIGNhc2UsIHRoZSB0b29sdGlwIGRpc2FwcGVhcnMgYW5kIGltbWVkaWF0ZWx5IHJlLWFwcGVhcnMsIGNhdXNpbmcgYSBmbGlja2VyaW5nIGVmZmVjdFxyXG4gICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogcHJldlN0YXRlLmlzVG9vbHRpcEFjdGl2ZVxyXG4gICAgICB9O1xyXG4gICAgICB2YXIgdXBkYXRlc1RvU3RhdGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGdldFRvb2x0aXBEYXRhKHByZXZTdGF0ZSwgZGF0YSwgbGF5b3V0KSksIHt9LCB7XHJcbiAgICAgICAgdXBkYXRlSWQ6IHByZXZTdGF0ZS51cGRhdGVJZCArIDFcclxuICAgICAgfSk7XHJcbiAgICAgIHZhciBuZXdTdGF0ZSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfZGVmYXVsdFN0YXRlKSwga2VlcEZyb21QcmV2U3RhdGUpLCB1cGRhdGVzVG9TdGF0ZSk7XHJcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbmV3U3RhdGUpLCB1cGRhdGVTdGF0ZU9mQXhpc01hcHNPZmZzZXRBbmRTdGFja0dyb3Vwcyhfb2JqZWN0U3ByZWFkKHtcclxuICAgICAgICBwcm9wczogbmV4dFByb3BzXHJcbiAgICAgIH0sIG5ld1N0YXRlKSwgcHJldlN0YXRlKSksIHt9LCB7XHJcbiAgICAgICAgcHJldkRhdGFLZXk6IGRhdGFLZXksXHJcbiAgICAgICAgcHJldkRhdGE6IGRhdGEsXHJcbiAgICAgICAgcHJldldpZHRoOiB3aWR0aCxcclxuICAgICAgICBwcmV2SGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgcHJldkxheW91dDogbGF5b3V0LFxyXG4gICAgICAgIHByZXZTdGFja09mZnNldDogc3RhY2tPZmZzZXQsXHJcbiAgICAgICAgcHJldk1hcmdpbjogbWFyZ2luLFxyXG4gICAgICAgIHByZXZDaGlsZHJlbjogY2hpbGRyZW5cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoISgwLCBfUmVhY3RVdGlscy5pc0NoaWxkcmVuRXF1YWwpKGNoaWxkcmVuLCBwcmV2U3RhdGUucHJldkNoaWxkcmVuKSkge1xyXG4gICAgICB2YXIgX2JydXNoJHByb3BzJHN0YXJ0SW5kLCBfYnJ1c2gkcHJvcHMsIF9icnVzaCRwcm9wcyRlbmRJbmRleCwgX2JydXNoJHByb3BzMjtcclxuICAgICAgLy8gc3BlY2lmaWNhbGx5IGNoZWNrIGZvciBCcnVzaCAtIGlmIGl0IGV4aXN0cyBhbmQgdGhlIHN0YXJ0IGFuZCBlbmQgaW5kZXhlcyBhcmUgZGlmZmVyZW50LCByZS1yZW5kZXIgd2l0aCB0aGUgbmV3IG9uZXNcclxuICAgICAgdmFyIGJydXNoID0gKDAsIF9SZWFjdFV0aWxzLmZpbmRDaGlsZEJ5VHlwZSkoY2hpbGRyZW4sIF9CcnVzaC5CcnVzaCk7XHJcbiAgICAgIHZhciBzdGFydEluZGV4ID0gYnJ1c2ggPyAoX2JydXNoJHByb3BzJHN0YXJ0SW5kID0gKF9icnVzaCRwcm9wcyA9IGJydXNoLnByb3BzKSA9PT0gbnVsbCB8fCBfYnJ1c2gkcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9icnVzaCRwcm9wcy5zdGFydEluZGV4KSAhPT0gbnVsbCAmJiBfYnJ1c2gkcHJvcHMkc3RhcnRJbmQgIT09IHZvaWQgMCA/IF9icnVzaCRwcm9wcyRzdGFydEluZCA6IGRhdGFTdGFydEluZGV4IDogZGF0YVN0YXJ0SW5kZXg7XHJcbiAgICAgIHZhciBlbmRJbmRleCA9IGJydXNoID8gKF9icnVzaCRwcm9wcyRlbmRJbmRleCA9IChfYnJ1c2gkcHJvcHMyID0gYnJ1c2gucHJvcHMpID09PSBudWxsIHx8IF9icnVzaCRwcm9wczIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9icnVzaCRwcm9wczIuZW5kSW5kZXgpICE9PSBudWxsICYmIF9icnVzaCRwcm9wcyRlbmRJbmRleCAhPT0gdm9pZCAwID8gX2JydXNoJHByb3BzJGVuZEluZGV4IDogZGF0YUVuZEluZGV4IDogZGF0YUVuZEluZGV4O1xyXG4gICAgICB2YXIgaGFzRGlmZmVyZW50U3RhcnRPckVuZEluZGV4ID0gc3RhcnRJbmRleCAhPT0gZGF0YVN0YXJ0SW5kZXggfHwgZW5kSW5kZXggIT09IGRhdGFFbmRJbmRleDtcclxuXHJcbiAgICAgIC8vIHVwZGF0ZSBjb25maWd1cmF0aW9uIGluIGNoaWxkcmVuXHJcbiAgICAgIHZhciBoYXNHbG9iYWxEYXRhID0gISgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShkYXRhKTtcclxuICAgICAgdmFyIG5ld1VwZGF0ZUlkID0gaGFzR2xvYmFsRGF0YSAmJiAhaGFzRGlmZmVyZW50U3RhcnRPckVuZEluZGV4ID8gcHJldlN0YXRlLnVwZGF0ZUlkIDogcHJldlN0YXRlLnVwZGF0ZUlkICsgMTtcclxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XHJcbiAgICAgICAgdXBkYXRlSWQ6IG5ld1VwZGF0ZUlkXHJcbiAgICAgIH0sIHVwZGF0ZVN0YXRlT2ZBeGlzTWFwc09mZnNldEFuZFN0YWNrR3JvdXBzKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XHJcbiAgICAgICAgcHJvcHM6IG5leHRQcm9wc1xyXG4gICAgICB9LCBwcmV2U3RhdGUpLCB7fSwge1xyXG4gICAgICAgIHVwZGF0ZUlkOiBuZXdVcGRhdGVJZCxcclxuICAgICAgICBkYXRhU3RhcnRJbmRleDogc3RhcnRJbmRleCxcclxuICAgICAgICBkYXRhRW5kSW5kZXg6IGVuZEluZGV4XHJcbiAgICAgIH0pLCBwcmV2U3RhdGUpKSwge30sIHtcclxuICAgICAgICBwcmV2Q2hpbGRyZW46IGNoaWxkcmVuLFxyXG4gICAgICAgIGRhdGFTdGFydEluZGV4OiBzdGFydEluZGV4LFxyXG4gICAgICAgIGRhdGFFbmRJbmRleDogZW5kSW5kZXhcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9KTtcclxuICBfZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcmljYWxDaGFydFdyYXBwZXIsIFwicmVuZGVyQWN0aXZlRG90XCIsIGZ1bmN0aW9uIChvcHRpb24sIHByb3BzLCBrZXkpIHtcclxuICAgIHZhciBkb3Q7XHJcbiAgICBpZiAoIC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmlzVmFsaWRFbGVtZW50KShvcHRpb24pKSB7XHJcbiAgICAgIGRvdCA9IC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNsb25lRWxlbWVudCkob3B0aW9uLCBwcm9wcyk7XHJcbiAgICB9IGVsc2UgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9wdGlvbikpIHtcclxuICAgICAgZG90ID0gb3B0aW9uKHByb3BzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRvdCA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0RvdC5Eb3QsIHByb3BzKTtcclxuICAgIH1cclxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xyXG4gICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtYWN0aXZlLWRvdFwiLFxyXG4gICAgICBrZXk6IGtleVxyXG4gICAgfSwgZG90KTtcclxuICB9KTtcclxuICB2YXIgQ2F0ZWdvcmljYWxDaGFydCA9IC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmZvcndhcmRSZWYpKGZ1bmN0aW9uIENhdGVnb3JpY2FsQ2hhcnQocHJvcHMsIHJlZikge1xyXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoQ2F0ZWdvcmljYWxDaGFydFdyYXBwZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xyXG4gICAgICByZWY6IHJlZlxyXG4gICAgfSkpO1xyXG4gIH0pO1xyXG4gIENhdGVnb3JpY2FsQ2hhcnQuZGlzcGxheU5hbWUgPSBDYXRlZ29yaWNhbENoYXJ0V3JhcHBlci5kaXNwbGF5TmFtZTtcclxuICByZXR1cm4gQ2F0ZWdvcmljYWxDaGFydDtcclxufTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRBeGlzTWFwQnlBeGVzIiwiZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0IiwiY3JlYXRlRGVmYXVsdFN0YXRlIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX2lzTmlsIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9pc0Z1bmN0aW9uIiwiX3JhbmdlIiwiX2dldCIsIl9zb3J0QnkiLCJfdGhyb3R0bGUiLCJfY2xzeCIsIl90aW55SW52YXJpYW50IiwiX1N1cmZhY2UiLCJfTGF5ZXIiLCJfVG9vbHRpcCIsIl9MZWdlbmQiLCJfRG90IiwiX1JlY3RhbmdsZSIsIl9SZWFjdFV0aWxzIiwiX0JydXNoIiwiX0RPTVV0aWxzIiwiX0RhdGFVdGlscyIsIl9DaGFydFV0aWxzIiwiX0RldGVjdFJlZmVyZW5jZUVsZW1lbnRzRG9tYWluIiwiX1BvbGFyVXRpbHMiLCJfU2hhbGxvd0VxdWFsIiwiX0V2ZW50cyIsIl90eXBlcyIsIl9BY2Nlc3NpYmlsaXR5TWFuYWdlciIsIl9pc0RvbWFpblNwZWNpZmllZEJ5VXNlciIsIl9BY3RpdmVTaGFwZVV0aWxzIiwiX0N1cnNvciIsIl9jaGFydExheW91dENvbnRleHQiLCJfZXhjbHVkZWQiLCJfZXhjbHVkZWQyIiwib2JqIiwiX19lc01vZHVsZSIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJfdHlwZW9mIiwiaGFzIiwiZ2V0IiwibiIsIl9fcHJvdG9fXyIsImEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ1IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaSIsInNldCIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsImFwcGx5IiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiVHlwZUVycm9yIiwibCIsImYiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJBcnJheSIsImlzQXJyYXkiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJleGNsdWRlZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1Byb3BlcnR5S2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NhbGxTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiQm9vbGVhbiIsInZhbHVlT2YiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwicCIsIl90b0NvbnN1bWFibGVBcnJheSIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsInRvU3RyaW5nIiwic2xpY2UiLCJuYW1lIiwiZnJvbSIsInRlc3QiLCJpdGVyIiwibGVuIiwiYXJyMiIsIm93bktleXMiLCJrZXlzIiwiZmlsdGVyIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiT1JJRU5UX01BUCIsInhBeGlzIiwieUF4aXMiLCJGVUxMX1dJRFRIX0FORF9IRUlHSFQiLCJ3aWR0aCIsImhlaWdodCIsIm9yaWdpbkNvb3JkaW5hdGUiLCJ4IiwieSIsInJlbmRlckFzSXMiLCJlbGVtZW50IiwiY2FsY3VsYXRlVG9vbHRpcFBvcyIsInJhbmdlT2JqIiwibGF5b3V0IiwiYW5nbGUiLCJyYWRpdXMiLCJnZXRBY3RpdmVDb29yZGluYXRlIiwidG9vbHRpcFRpY2tzIiwiYWN0aXZlSW5kZXgiLCJlbnRyeSIsImZpbmQiLCJ0aWNrIiwiaW5kZXgiLCJjb29yZGluYXRlIiwiX2FuZ2xlIiwiX3JhZGl1cyIsInBvbGFyVG9DYXJ0ZXNpYW4iLCJjeCIsImN5IiwiZ2V0RGlzcGxheWVkRGF0YSIsImRhdGEiLCJfcmVmIiwiZ3JhcGhpY2FsSXRlbXMiLCJkYXRhU3RhcnRJbmRleCIsImRhdGFFbmRJbmRleCIsIml0ZW1zRGF0YSIsInJlZHVjZSIsInJlc3VsdCIsImNoaWxkIiwiaXRlbURhdGEiLCJjb25jYXQiLCJpc051bWJlciIsImdldERlZmF1bHREb21haW5CeUF4aXNUeXBlIiwiYXhpc1R5cGUiLCJ1bmRlZmluZWQiLCJnZXRUb29sdGlwQ29udGVudCIsInN0YXRlIiwiY2hhcnREYXRhIiwiYWN0aXZlTGFiZWwiLCJ0b29sdGlwQXhpcyIsImRpc3BsYXllZERhdGEiLCJfY2hpbGQkcHJvcHMkZGF0YSIsInBheWxvYWQiLCJkYXRhS2V5IiwiYWxsb3dEdXBsaWNhdGVkQ2F0ZWdvcnkiLCJlbnRyaWVzIiwiZmluZEVudHJ5SW5BcnJheSIsImdldFRvb2x0aXBJdGVtIiwiZ2V0VG9vbHRpcERhdGEiLCJyYW5nZURhdGEiLCJjaGFydFgiLCJjaGFydFkiLCJwb3MiLCJ0aWNrcyIsIm9yZGVyZWRUb29sdGlwVGlja3MiLCJheGlzIiwiY2FsY3VsYXRlQWN0aXZlVGlja0luZGV4IiwiYWN0aXZlUGF5bG9hZCIsImFjdGl2ZUNvb3JkaW5hdGUiLCJhY3RpdmVUb29sdGlwSW5kZXgiLCJfcmVmMiIsImF4ZXMiLCJheGlzSWRLZXkiLCJzdGFja0dyb3VwcyIsImNoaWxkcmVuIiwic3RhY2tPZmZzZXQiLCJpc0NhdGVnb3JpY2FsIiwiaXNDYXRlZ29yaWNhbEF4aXMiLCJfY2hpbGRQcm9wcyRkb21haW4yIiwiY2hpbGRQcm9wcyIsInR5cGUiLCJkZWZhdWx0UHJvcHMiLCJhbGxvd0RhdGFPdmVyZmxvdyIsInNjYWxlIiwiaW5jbHVkZUhpZGRlbiIsImF4aXNJZCIsIml0ZW0iLCJfZGVmYXVsdFByb3BzIiwiaXRlbUF4aXNJZCIsImRvbWFpbiIsImR1cGxpY2F0ZURvbWFpbiIsImNhdGVnb3JpY2FsRG9tYWluIiwiaXNEb21haW5TcGVjaWZpZWRCeVVzZXIiLCJwYXJzZVNwZWNpZmllZERvbWFpbiIsImdldERvbWFpbk9mRGF0YUJ5S2V5IiwiZGVmYXVsdERvbWFpbiIsIl9jaGlsZFByb3BzJGRvbWFpbiIsImNoaWxkRG9tYWluIiwiZHVwbGljYXRlIiwiaGFzRHVwbGljYXRlIiwicGFyc2VEb21haW5PZkNhdGVnb3J5QXhpcyIsImZpbmFsRG9tYWluIiwiZXJyb3JCYXJzRG9tYWluIiwicGFyc2VFcnJvckJhcnNPZkF4aXMiLCJfZGVmYXVsdFByb3BzMiIsIl9kZWZhdWx0UHJvcHMzIiwiaXRlbUhpZGUiLCJoaWRlIiwiaGFzU3RhY2siLCJnZXREb21haW5PZlN0YWNrR3JvdXBzIiwiZ2V0RG9tYWluT2ZJdGVtc1dpdGhTYW1lQXhpcyIsImRldGVjdFJlZmVyZW5jZUVsZW1lbnRzRG9tYWluIiwiYXhpc0RvbWFpbiIsImlzRG9tYWluVmFsaWQiLCJldmVyeSIsIm9yaWdpbmFsRG9tYWluIiwiZ2V0QXhpc01hcEJ5SXRlbXMiLCJfcmVmMyIsIkF4aXMiLCJfZGVmYXVsdFByb3BzNCIsIl9kZWZhdWx0UHJvcHM1Iiwib3JpZW50YXRpb24iLCJnZXRBeGlzTWFwIiwiX3JlZjQiLCJfcmVmNCRheGlzVHlwZSIsIkF4aXNDb21wIiwiZmluZEFsbEJ5VHlwZSIsImF4aXNNYXAiLCJ0b29sdGlwVGlja3NHZW5lcmF0b3IiLCJnZXRBbnlFbGVtZW50T2ZPYmplY3QiLCJnZXRUaWNrc09mQXhpcyIsInRvb2x0aXBBeGlzQmFuZFNpemUiLCJnZXRCYW5kU2l6ZU9mQXhpcyIsImRlZmF1bHRTaG93VG9vbHRpcCIsImJydXNoSXRlbSIsImZpbmRDaGlsZEJ5VHlwZSIsIkJydXNoIiwic3RhcnRJbmRleCIsImVuZEluZGV4IiwiaXNUb29sdGlwQWN0aXZlIiwiaGFzR3JhcGhpY2FsQmFySXRlbSIsInNvbWUiLCJnZXREaXNwbGF5TmFtZSIsImdldEF4aXNOYW1lQnlMYXlvdXQiLCJudW1lcmljQXhpc05hbWUiLCJjYXRlQXhpc05hbWUiLCJjYWxjdWxhdGVPZmZzZXQiLCJfcmVmNSIsInByZXZMZWdlbmRCQm94IiwiX3JlZjUkeEF4aXNNYXAiLCJ4QXhpc01hcCIsIl9yZWY1JHlBeGlzTWFwIiwieUF4aXNNYXAiLCJtYXJnaW4iLCJsZWdlbmRJdGVtIiwiTGVnZW5kIiwib2Zmc2V0SCIsImlkIiwibWlycm9yIiwibGVmdCIsInJpZ2h0Iiwib2Zmc2V0ViIsInRvcCIsImJvdHRvbSIsIm9mZnNldCIsImJydXNoQm90dG9tIiwiYXBwZW5kT2Zmc2V0T2ZMZWdlbmQiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsIk1hdGgiLCJtYXgiLCJnZXRDYXJ0ZXNpYW5BeGlzU2l6ZSIsImF4aXNPYmoiLCJheGlzTmFtZSIsIl9yZWY2IiwiY2hhcnROYW1lIiwiR3JhcGhpY2FsQ2hpbGQiLCJfcmVmNiRkZWZhdWx0VG9vbHRpcEUiLCJkZWZhdWx0VG9vbHRpcEV2ZW50VHlwZSIsIl9yZWY2JHZhbGlkYXRlVG9vbHRpcCIsInZhbGlkYXRlVG9vbHRpcEV2ZW50VHlwZXMiLCJheGlzQ29tcG9uZW50cyIsImxlZ2VuZENvbnRlbnQiLCJmb3JtYXRBeGlzTWFwIiwiZ2V0Rm9ybWF0SXRlbXMiLCJjdXJyZW50U3RhdGUiLCJ1cGRhdGVJZCIsImJhclNpemUiLCJiYXJHYXAiLCJiYXJDYXRlZ29yeUdhcCIsImdsb2JhbE1heEJhclNpemUiLCJtYXhCYXJTaXplIiwiX2dldEF4aXNOYW1lQnlMYXlvdXQiLCJoYXNCYXIiLCJmb3JtYXR0ZWRJdGVtcyIsIml0ZW1Qcm9wcyIsImNoaWxkTWF4QmFyU2l6ZSIsIm51bWVyaWNBeGlzSWQiLCJjYXRlQXhpc0lkIiwiYXhpc09iakluaXRpYWxWYWx1ZSIsIl9pdGVtJHR5cGUkZGlzcGxheU5hbSIsIl9pdGVtJHR5cGUiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiLCJjYXRlQXhpcyIsImNhdGVUaWNrcyIsInN0YWNrZWREYXRhIiwiZ2V0U3RhY2tlZERhdGFPZkl0ZW0iLCJpdGVtSXNCYXIiLCJiYW5kU2l6ZSIsImJhclBvc2l0aW9uIiwic2l6ZUxpc3QiLCJnZXRCYXJTaXplTGlzdCIsInRvdGFsU2l6ZSIsIl9yZWY3IiwiX2dldEJhbmRTaXplT2ZBeGlzIiwiYmFyQmFuZFNpemUiLCJnZXRCYXJQb3NpdGlvbiIsIm1hcCIsInBvc2l0aW9uIiwiY29tcG9zZWRGbiIsImdldENvbXBvc2VkRGF0YSIsImNoaWxkSW5kZXgiLCJwYXJzZUNoaWxkSW5kZXgiLCJ1cGRhdGVTdGF0ZU9mQXhpc01hcHNPZmZzZXRBbmRTdGFja0dyb3VwcyIsIl9yZWY4IiwicHJldlN0YXRlIiwidmFsaWRhdGVXaWR0aEhlaWdodCIsInJldmVyc2VTdGFja09yZGVyIiwiX2dldEF4aXNOYW1lQnlMYXlvdXQyIiwiZ2V0U3RhY2tHcm91cHNCeUF4aXNJZCIsImxlZ2VuZEJCb3giLCJyZXBsYWNlIiwiY2F0ZUF4aXNNYXAiLCJ0aWNrc09iaiIsImZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zIiwiQ2F0ZWdvcmljYWxDaGFydFdyYXBwZXIiLCJfQ29tcG9uZW50IiwiX3Byb3BzIiwiX3Byb3BzJGlkIiwiX3Byb3BzJHRocm90dGxlRGVsYXkiLCJfdGhpcyIsIkFjY2Vzc2liaWxpdHlNYW5hZ2VyIiwiYm94IiwiX3RoaXMkc3RhdGUiLCJzZXRTdGF0ZSIsImNJZCIsImVtaXR0ZXIiLCJzeW5jSWQiLCJldmVudEVtaXR0ZXJTeW1ib2wiLCJzeW5jTWV0aG9kIiwiYXBwbHlTeW5jRXZlbnQiLCJfcmVmOSIsInRyaWdnZXJTeW5jRXZlbnQiLCJtb3VzZSIsImdldE1vdXNlSW5mbyIsIl9uZXh0U3RhdGUiLCJvbk1vdXNlRW50ZXIiLCJuZXh0U3RhdGUiLCJvbk1vdXNlTW92ZSIsImVsIiwiYWN0aXZlSXRlbSIsInRvb2x0aXBQYXlsb2FkIiwidG9vbHRpcFBvc2l0aW9uIiwicGVyc2lzdCIsInRocm90dGxlVHJpZ2dlcmVkQWZ0ZXJNb3VzZU1vdmUiLCJjYW5jZWwiLCJvbk1vdXNlTGVhdmUiLCJldmVudE5hbWUiLCJnZXRSZWFjdEV2ZW50QnlUeXBlIiwiZXZlbnQiLCJfbW91c2UiLCJjaGFuZ2VkVG91Y2hlcyIsIl9uZXh0U3RhdGUyIiwib25DbGljayIsIm9uTW91c2VEb3duIiwiX25leHRTdGF0ZTMiLCJvbk1vdXNlVXAiLCJfbmV4dFN0YXRlNCIsImhhbmRsZU1vdXNlRG93biIsImhhbmRsZU1vdXNlVXAiLCJvbkRvdWJsZUNsaWNrIiwiX25leHRTdGF0ZTUiLCJvbkNvbnRleHRNZW51IiwiX25leHRTdGF0ZTYiLCJldmVudENlbnRlciIsImVtaXQiLCJTWU5DX0VWRU5UIiwiX3RoaXMkcHJvcHMiLCJfdGhpcyRzdGF0ZTIiLCJ2aWV3Qm94IiwidmFsaWRhdGVDaGFydFgiLCJtaW4iLCJ2YWxpZGF0ZUNoYXJ0WSIsIl9lbGVtZW50JHByb3BzJGFjdGl2ZSIsIl90aGlzJHN0YXRlMyIsInRvb2x0aXBFdmVudFR5cGUiLCJnZXRUb29sdGlwRXZlbnRUeXBlIiwiaXNBY3RpdmUiLCJhY3RpdmUiLCJjcmVhdGVFbGVtZW50IiwiQ3Vyc29yIiwiZWxlbWVudERlZmF1bHRQcm9wcyIsImVsZW1lbnRQcm9wcyIsImF4aXNPcHRpb24iLCJjbG9uZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJfZWxlbWVudCRwcm9wcyIsInJhZGlhbExpbmVzIiwicG9sYXJBbmdsZXMiLCJwb2xhclJhZGl1cyIsIl90aGlzJHN0YXRlNCIsInJhZGl1c0F4aXNNYXAiLCJhbmdsZUF4aXNNYXAiLCJyYWRpdXNBeGlzIiwiYW5nbGVBeGlzIiwiaW5uZXJSYWRpdXMiLCJvdXRlclJhZGl1cyIsIl90aGlzJHByb3BzMiIsImxlZ2VuZFdpZHRoIiwiZ2V0TGVnZW5kUHJvcHMiLCJvdGhlclByb3BzIiwiY2hhcnRXaWR0aCIsImNoYXJ0SGVpZ2h0Iiwib25CQm94VXBkYXRlIiwiaGFuZGxlTGVnZW5kQkJveFVwZGF0ZSIsIl90b29sdGlwSXRlbSRwcm9wcyRhYyIsIl90aGlzJHByb3BzMyIsImFjY2Vzc2liaWxpdHlMYXllciIsInRvb2x0aXBJdGVtIiwiVG9vbHRpcCIsIl90aGlzJHN0YXRlNSIsImxhYmVsIiwiX3RoaXMkcHJvcHM0IiwiX3RoaXMkc3RhdGU2Iiwib25DaGFuZ2UiLCJjb21iaW5lRXZlbnRIYW5kbGVycyIsImhhbmRsZUJydXNoQ2hhbmdlIiwiX3RoaXMyIiwiY2xpcFBhdGhJZCIsIl90aGlzJHN0YXRlNyIsIl9lbGVtZW50JHByb3BzMiIsIl9lbGVtZW50JHByb3BzMiR4QXhpcyIsInhBeGlzSWQiLCJfZWxlbWVudCRwcm9wczIkeUF4aXMiLCJ5QXhpc0lkIiwiX3JlZjEwIiwiYWN0aXZlUG9pbnQiLCJiYXNlUG9pbnQiLCJpc1JhbmdlIiwiaXRlbUl0ZW1Qcm9wcyIsImFjdGl2ZURvdCIsImRvdFByb3BzIiwiZmlsbCIsImdldE1haW5Db2xvck9mR3JhcGhpY0l0ZW0iLCJzdHJva2VXaWR0aCIsInN0cm9rZSIsImZpbHRlclByb3BzIiwiYWRhcHRFdmVudEhhbmRsZXJzIiwicmVuZGVyQWN0aXZlRG90IiwiZmlsdGVyRm9ybWF0SXRlbSIsIl90aGlzJHN0YXRlOCIsIl9pdGVtJHByb3BzIiwicG9pbnRzIiwiYmFzZUxpbmUiLCJhY3RpdmVCYXIiLCJhY3RpdmVTaGFwZSIsImhhc0FjdGl2ZSIsIml0ZW1FdmVudHMiLCJ0cmlnZ2VyIiwiaGFuZGxlSXRlbU1vdXNlRW50ZXIiLCJoYW5kbGVJdGVtTW91c2VMZWF2ZSIsImdyYXBoaWNhbEl0ZW0iLCJmaW5kV2l0aFBheWxvYWQiLCJzcGVjaWZpZWRLZXkiLCJyZW5kZXJBY3RpdmVQb2ludHMiLCJfdGhpcyRnZXRJdGVtQnlYWSIsIl9yZWYxMSIsImdldEl0ZW1CeVhZIiwiX3JlZjExJGdyYXBoaWNhbEl0ZW0iLCJfcmVmMTEkZ3JhcGhpY2FsSXRlbSQiLCJ4eUl0ZW0iLCJDYXJ0ZXNpYW5HcmlkIiwiaGFuZGxlciIsIm9uY2UiLCJSZWZlcmVuY2VBcmVhIiwicmVuZGVyUmVmZXJlbmNlRWxlbWVudCIsIlJlZmVyZW5jZUxpbmUiLCJSZWZlcmVuY2VEb3QiLCJYQXhpcyIsIllBeGlzIiwicmVuZGVyQnJ1c2giLCJCYXIiLCJyZW5kZXJHcmFwaGljQ2hpbGQiLCJMaW5lIiwiQXJlYSIsIlJhZGFyIiwiUmFkaWFsQmFyIiwiU2NhdHRlciIsIlBpZSIsIkZ1bm5lbCIsInJlbmRlckN1cnNvciIsIlBvbGFyR3JpZCIsInJlbmRlclBvbGFyR3JpZCIsIlBvbGFyQW5nbGVBeGlzIiwicmVuZGVyUG9sYXJBeGlzIiwiUG9sYXJSYWRpdXNBeGlzIiwiQ3VzdG9taXplZCIsInJlbmRlckN1c3RvbWl6ZWQiLCJ1bmlxdWVJZCIsInRyaWdnZXJlZEFmdGVyTW91c2VNb3ZlIiwidGhyb3R0bGVEZWxheSIsImNvbXBvbmVudERpZE1vdW50IiwiX3RoaXMkcHJvcHMkbWFyZ2luJGxlIiwiX3RoaXMkcHJvcHMkbWFyZ2luJHRvIiwiYWRkTGlzdGVuZXIiLCJhY2Nlc3NpYmlsaXR5TWFuYWdlciIsInNldERldGFpbHMiLCJjb250YWluZXIiLCJjb29yZGluYXRlTGlzdCIsIm1vdXNlSGFuZGxlckNhbGxiYWNrIiwiZGlzcGxheURlZmF1bHRUb29sdGlwIiwiX3RoaXMkcHJvcHM1IiwidG9vbHRpcEVsZW0iLCJkZWZhdWx0SW5kZXgiLCJpbmRlcGVuZGVudEF4aXNDb29yZCIsImRlcGVuZGVudEF4aXNDb29yZCIsImlzSG9yaXpvbnRhbCIsInNjYXR0ZXJQbG90RWxlbWVudCIsIl9yZWYxMiIsInNldEluZGV4IiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJwcmV2UHJvcHMiLCJfdGhpcyRwcm9wcyRtYXJnaW4kbGUyIiwiX3RoaXMkcHJvcHMkbWFyZ2luJHRvMiIsImNvbXBvbmVudERpZFVwZGF0ZSIsImlzQ2hpbGRyZW5FcXVhbCIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVtb3ZlTGlzdGVuZXIiLCJzaGFyZWQiLCJldmVudFR5cGUiLCJib3VuZGluZ1JlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjb250YWluZXJPZmZzZXQiLCJnZXRPZmZzZXQiLCJyb3VuZCIsInBhZ2VYIiwicGFnZVkiLCJpblJhbmdlIiwiX3RoaXMkc3RhdGU5IiwidG9vbFRpcERhdGEiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJ4VmFsdWUiLCJpbnZlcnQiLCJ5VmFsdWUiLCJzY2FsZWRYIiwic2NhbGVkWSIsImlzSW5SYW5nZSIsIl90aGlzJHN0YXRlMTAiLCJpblJhbmdlT2ZTZWN0b3IiLCJwYXJzZUV2ZW50c09mV3JhcHBlciIsInRvb2x0aXBFdmVudHMiLCJoYW5kbGVDbGljayIsImhhbmRsZU1vdXNlRW50ZXIiLCJoYW5kbGVEb3VibGVDbGljayIsImhhbmRsZU1vdXNlTW92ZSIsImhhbmRsZU1vdXNlTGVhdmUiLCJvblRvdWNoTW92ZSIsImhhbmRsZVRvdWNoTW92ZSIsIm9uVG91Y2hTdGFydCIsImhhbmRsZVRvdWNoU3RhcnQiLCJvblRvdWNoRW5kIiwiaGFuZGxlVG91Y2hFbmQiLCJoYW5kbGVDb250ZXh0TWVudSIsIm91dGVyRXZlbnRzIiwiaGFuZGxlT3V0ZXJFdmVudCIsIm9uIiwiaGFuZGxlUmVjZWl2ZVN5bmNFdmVudCIsInJlbmRlckNsaXBQYXRoIiwiX3RoaXMkc3RhdGUkb2Zmc2V0IiwiZ2V0WFNjYWxlcyIsInJlcyIsIl9yZWYxMyIsIl9yZWYxNCIsImF4aXNQcm9wcyIsImdldFlTY2FsZXMiLCJfcmVmMTUiLCJfcmVmMTYiLCJnZXRYU2NhbGVCeUF4aXNJZCIsIl90aGlzJHN0YXRlJHhBeGlzTWFwIiwiZ2V0WVNjYWxlQnlBeGlzSWQiLCJfdGhpcyRzdGF0ZSR5QXhpc01hcCIsImNoYXJ0WFkiLCJfdGhpcyRzdGF0ZTExIiwiaXRlbURpc3BsYXlOYW1lIiwiYWN0aXZlQmFySXRlbSIsImlzSW5SZWN0YW5nbGUiLCJfYWN0aXZlQmFySXRlbSIsImlzRnVubmVsIiwiaXNQaWUiLCJpc1NjYXR0ZXIiLCJnZXRBY3RpdmVTaGFwZUluZGV4Rm9yVG9vbHRpcCIsImFjdGl2ZVRvb2x0aXBJdGVtIiwicmVuZGVyIiwiX3RoaXMzIiwiX3RoaXMkcHJvcHM2Iiwic3R5bGUiLCJjb21wYWN0IiwidGl0bGUiLCJkZXNjIiwib3RoZXJzIiwiYXR0cnMiLCJDaGFydExheW91dENvbnRleHRQcm92aWRlciIsIlN1cmZhY2UiLCJyZW5kZXJCeU9yZGVyIiwicmVuZGVyTWFwIiwiX3RoaXMkcHJvcHMkdGFiSW5kZXgiLCJfdGhpcyRwcm9wcyRyb2xlIiwidGFiSW5kZXgiLCJyb2xlIiwib25LZXlEb3duIiwia2V5Ym9hcmRFdmVudCIsIm9uRm9jdXMiLCJmb2N1cyIsImV2ZW50cyIsImN1cnNvciIsInJlZiIsIm5vZGUiLCJyZW5kZXJMZWdlbmQiLCJyZW5kZXJUb29sdGlwIiwiQ29tcG9uZW50IiwibmV4dFByb3BzIiwiZGVmYXVsdFN0YXRlIiwicHJldkRhdGFLZXkiLCJwcmV2RGF0YSIsInByZXZXaWR0aCIsInByZXZIZWlnaHQiLCJwcmV2TGF5b3V0IiwicHJldlN0YWNrT2Zmc2V0IiwicHJldk1hcmdpbiIsInByZXZDaGlsZHJlbiIsInNoYWxsb3dFcXVhbCIsIl9kZWZhdWx0U3RhdGUiLCJrZWVwRnJvbVByZXZTdGF0ZSIsInVwZGF0ZXNUb1N0YXRlIiwibmV3U3RhdGUiLCJfYnJ1c2gkcHJvcHMkc3RhcnRJbmQiLCJfYnJ1c2gkcHJvcHMiLCJfYnJ1c2gkcHJvcHMkZW5kSW5kZXgiLCJfYnJ1c2gkcHJvcHMyIiwiYnJ1c2giLCJoYXNEaWZmZXJlbnRTdGFydE9yRW5kSW5kZXgiLCJoYXNHbG9iYWxEYXRhIiwibmV3VXBkYXRlSWQiLCJvcHRpb24iLCJkb3QiLCJpc1ZhbGlkRWxlbWVudCIsIkRvdCIsIkxheWVyIiwiQ2F0ZWdvcmljYWxDaGFydCIsImZvcndhcmRSZWYiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/chart/generateCategoricalChart.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/component/Cell.js":
/*!*****************************************************!*\
  !*** ./node_modules/recharts/lib/component/Cell.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Cell = void 0;\n/**\r\n * @fileOverview Cross\r\n */ var Cell = exports.Cell = function Cell(_props) {\n    return null;\n};\nCell.displayName = 'Cell';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY29tcG9uZW50L0NlbGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELFlBQVksR0FBRyxLQUFLO0FBQ3BCOztDQUVDLEdBRUQsSUFBSUUsT0FBT0YsWUFBWSxHQUFHLFNBQVNFLEtBQUtDLE1BQU07SUFDNUMsT0FBTztBQUNUO0FBQ0FELEtBQUtFLFdBQVcsR0FBRyIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcY29tcG9uZW50XFxDZWxsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuQ2VsbCA9IHZvaWQgMDtcclxuLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgQ3Jvc3NcclxuICovXHJcblxyXG52YXIgQ2VsbCA9IGV4cG9ydHMuQ2VsbCA9IGZ1bmN0aW9uIENlbGwoX3Byb3BzKSB7XHJcbiAgcmV0dXJuIG51bGw7XHJcbn07XHJcbkNlbGwuZGlzcGxheU5hbWUgPSAnQ2VsbCc7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2VsbCIsIl9wcm9wcyIsImRpc3BsYXlOYW1lIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/component/Cell.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/component/Cursor.js":
/*!*******************************************************!*\
  !*** ./node_modules/recharts/lib/component/Cursor.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Cursor = Cursor;\nvar _react = __webpack_require__(/*! react */ \"react\");\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _Curve = __webpack_require__(/*! ../shape/Curve */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Curve.js\");\nvar _Cross = __webpack_require__(/*! ../shape/Cross */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Cross.js\");\nvar _getCursorRectangle = __webpack_require__(/*! ../util/cursor/getCursorRectangle */ \"(pages-dir-node)/./node_modules/recharts/lib/util/cursor/getCursorRectangle.js\");\nvar _Rectangle = __webpack_require__(/*! ../shape/Rectangle */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Rectangle.js\");\nvar _getRadialCursorPoints = __webpack_require__(/*! ../util/cursor/getRadialCursorPoints */ \"(pages-dir-node)/./node_modules/recharts/lib/util/cursor/getRadialCursorPoints.js\");\nvar _Sector = __webpack_require__(/*! ../shape/Sector */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Sector.js\");\nvar _getCursorPoints = __webpack_require__(/*! ../util/cursor/getCursorPoints */ \"(pages-dir-node)/./node_modules/recharts/lib/util/cursor/getCursorPoints.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n/*\r\n * Cursor is the background, or a highlight,\r\n * that shows when user mouses over or activates\r\n * an area.\r\n *\r\n * It usually shows together with a tooltip\r\n * to emphasise which part of the chart does the tooltip refer to.\r\n */ function Cursor(props) {\n    var _element$props$cursor, _defaultProps;\n    var element = props.element, tooltipEventType = props.tooltipEventType, isActive = props.isActive, activeCoordinate = props.activeCoordinate, activePayload = props.activePayload, offset = props.offset, activeTooltipIndex = props.activeTooltipIndex, tooltipAxisBandSize = props.tooltipAxisBandSize, layout = props.layout, chartName = props.chartName;\n    var elementPropsCursor = (_element$props$cursor = element.props.cursor) !== null && _element$props$cursor !== void 0 ? _element$props$cursor : (_defaultProps = element.type.defaultProps) === null || _defaultProps === void 0 ? void 0 : _defaultProps.cursor;\n    if (!element || !elementPropsCursor || !isActive || !activeCoordinate || chartName !== 'ScatterChart' && tooltipEventType !== 'axis') {\n        return null;\n    }\n    var restProps;\n    var cursorComp = _Curve.Curve;\n    if (chartName === 'ScatterChart') {\n        restProps = activeCoordinate;\n        cursorComp = _Cross.Cross;\n    } else if (chartName === 'BarChart') {\n        restProps = (0, _getCursorRectangle.getCursorRectangle)(layout, activeCoordinate, offset, tooltipAxisBandSize);\n        cursorComp = _Rectangle.Rectangle;\n    } else if (layout === 'radial') {\n        var _getRadialCursorPoint = (0, _getRadialCursorPoints.getRadialCursorPoints)(activeCoordinate), cx = _getRadialCursorPoint.cx, cy = _getRadialCursorPoint.cy, radius = _getRadialCursorPoint.radius, startAngle = _getRadialCursorPoint.startAngle, endAngle = _getRadialCursorPoint.endAngle;\n        restProps = {\n            cx: cx,\n            cy: cy,\n            startAngle: startAngle,\n            endAngle: endAngle,\n            innerRadius: radius,\n            outerRadius: radius\n        };\n        cursorComp = _Sector.Sector;\n    } else {\n        restProps = {\n            points: (0, _getCursorPoints.getCursorPoints)(layout, activeCoordinate, offset)\n        };\n        cursorComp = _Curve.Curve;\n    }\n    var cursorProps = _objectSpread(_objectSpread(_objectSpread(_objectSpread({\n        stroke: '#ccc',\n        pointerEvents: 'none'\n    }, offset), restProps), (0, _ReactUtils.filterProps)(elementPropsCursor, false)), {}, {\n        payload: activePayload,\n        payloadIndex: activeTooltipIndex,\n        className: (0, _clsx[\"default\"])('recharts-tooltip-cursor', elementPropsCursor.className)\n    });\n    return /*#__PURE__*/ (0, _react.isValidElement)(elementPropsCursor) ? /*#__PURE__*/ (0, _react.cloneElement)(elementPropsCursor, cursorProps) : /*#__PURE__*/ (0, _react.createElement)(cursorComp, cursorProps);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY29tcG9uZW50L0N1cnNvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsY0FBYyxHQUFHRTtBQUNqQixJQUFJQyxTQUFTQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUM1QixJQUFJQyxRQUFRQyx1QkFBdUJGLG1CQUFPQSxDQUFDLHVCQUFNO0FBQ2pELElBQUlHLFNBQVNILG1CQUFPQSxDQUFDLG1GQUFnQjtBQUNyQyxJQUFJSSxTQUFTSixtQkFBT0EsQ0FBQyxtRkFBZ0I7QUFDckMsSUFBSUssc0JBQXNCTCxtQkFBT0EsQ0FBQyx5SEFBbUM7QUFDckUsSUFBSU0sYUFBYU4sbUJBQU9BLENBQUMsMkZBQW9CO0FBQzdDLElBQUlPLHlCQUF5QlAsbUJBQU9BLENBQUMsK0hBQXNDO0FBQzNFLElBQUlRLFVBQVVSLG1CQUFPQSxDQUFDLHFGQUFpQjtBQUN2QyxJQUFJUyxtQkFBbUJULG1CQUFPQSxDQUFDLG1IQUFnQztBQUMvRCxJQUFJVSxjQUFjVixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDOUMsU0FBU0UsdUJBQXVCUyxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFLFdBQVcsS0FBS0MsVUFBVUQsTUFBTUMsT0FBT0UsU0FBUyxHQUFHLFdBQVcsT0FBT0g7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNJLFFBQVFDLENBQUMsRUFB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Y3JELGNBQWNBLGNBQWNBLGNBQWNBLGNBQWM7UUFDeEVzRCxRQUFRO1FBQ1JDLGVBQWU7SUFDakIsR0FBRzdCLFNBQVNTLFlBQVksQ0FBQyxHQUFHdEQsWUFBWTJFLFdBQVcsRUFBRXpCLG9CQUFvQixTQUFTLENBQUMsR0FBRztRQUNwRjBCLFNBQVNoQztRQUNUaUMsY0FBYy9CO1FBQ2RnQyxXQUFXLENBQUMsR0FBR3ZGLEtBQUssQ0FBQyxVQUFVLEVBQUUsMkJBQTJCMkQsbUJBQW1CNEIsU0FBUztJQUMxRjtJQUNBLE9BQW9CLFdBQUYsR0FBRyxJQUFHekYsT0FBTzBGLGNBQWMsRUFBRTdCLHNCQUFtQyxXQUFGLEdBQUcsSUFBRzdELE9BQU8yRixZQUFZLEVBQUU5QixvQkFBb0JzQixlQUE0QixXQUFGLEdBQUcsSUFBR25GLE9BQU80RixhQUFhLEVBQUUxQixZQUFZaUI7QUFDbk0iLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXGNvbXBvbmVudFxcQ3Vyc29yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuQ3Vyc29yID0gQ3Vyc29yO1xyXG52YXIgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcclxudmFyIF9DdXJ2ZSA9IHJlcXVpcmUoXCIuLi9zaGFwZS9DdXJ2ZVwiKTtcclxudmFyIF9Dcm9zcyA9IHJlcXVpcmUoXCIuLi9zaGFwZS9Dcm9zc1wiKTtcclxudmFyIF9nZXRDdXJzb3JSZWN0YW5nbGUgPSByZXF1aXJlKFwiLi4vdXRpbC9jdXJzb3IvZ2V0Q3Vyc29yUmVjdGFuZ2xlXCIpO1xyXG52YXIgX1JlY3RhbmdsZSA9IHJlcXVpcmUoXCIuLi9zaGFwZS9SZWN0YW5nbGVcIik7XHJcbnZhciBfZ2V0UmFkaWFsQ3Vyc29yUG9pbnRzID0gcmVxdWlyZShcIi4uL3V0aWwvY3Vyc29yL2dldFJhZGlhbEN1cnNvclBvaW50c1wiKTtcclxudmFyIF9TZWN0b3IgPSByZXF1aXJlKFwiLi4vc2hhcGUvU2VjdG9yXCIpO1xyXG52YXIgX2dldEN1cnNvclBvaW50cyA9IHJlcXVpcmUoXCIuLi91dGlsL2N1cnNvci9nZXRDdXJzb3JQb2ludHNcIik7XHJcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cclxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cclxuLypcclxuICogQ3Vyc29yIGlzIHRoZSBiYWNrZ3JvdW5kLCBvciBhIGhpZ2hsaWdodCxcclxuICogdGhhdCBzaG93cyB3aGVuIHVzZXIgbW91c2VzIG92ZXIgb3IgYWN0aXZhdGVzXHJcbiAqIGFuIGFyZWEuXHJcbiAqXHJcbiAqIEl0IHVzdWFsbHkgc2hvd3MgdG9nZXRoZXIgd2l0aCBhIHRvb2x0aXBcclxuICogdG8gZW1waGFzaXNlIHdoaWNoIHBhcnQgb2YgdGhlIGNoYXJ0IGRvZXMgdGhlIHRvb2x0aXAgcmVmZXIgdG8uXHJcbiAqL1xyXG5mdW5jdGlvbiBDdXJzb3IocHJvcHMpIHtcclxuICB2YXIgX2VsZW1lbnQkcHJvcHMkY3Vyc29yLCBfZGVmYXVsdFByb3BzO1xyXG4gIHZhciBlbGVtZW50ID0gcHJvcHMuZWxlbWVudCxcclxuICAgIHRvb2x0aXBFdmVudFR5cGUgPSBwcm9wcy50b29sdGlwRXZlbnRUeXBlLFxyXG4gICAgaXNBY3RpdmUgPSBwcm9wcy5pc0FjdGl2ZSxcclxuICAgIGFjdGl2ZUNvb3JkaW5hdGUgPSBwcm9wcy5hY3RpdmVDb29yZGluYXRlLFxyXG4gICAgYWN0aXZlUGF5bG9hZCA9IHByb3BzLmFjdGl2ZVBheWxvYWQsXHJcbiAgICBvZmZzZXQgPSBwcm9wcy5vZmZzZXQsXHJcbiAgICBhY3RpdmVUb29sdGlwSW5kZXggPSBwcm9wcy5hY3RpdmVUb29sdGlwSW5kZXgsXHJcbiAgICB0b29sdGlwQXhpc0JhbmRTaXplID0gcHJvcHMudG9vbHRpcEF4aXNCYW5kU2l6ZSxcclxuICAgIGxheW91dCA9IHByb3BzLmxheW91dCxcclxuICAgIGNoYXJ0TmFtZSA9IHByb3BzLmNoYXJ0TmFtZTtcclxuICB2YXIgZWxlbWVudFByb3BzQ3Vyc29yID0gKF9lbGVtZW50JHByb3BzJGN1cnNvciA9IGVsZW1lbnQucHJvcHMuY3Vyc29yKSAhPT0gbnVsbCAmJiBfZWxlbWVudCRwcm9wcyRjdXJzb3IgIT09IHZvaWQgMCA/IF9lbGVtZW50JHByb3BzJGN1cnNvciA6IChfZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykgPT09IG51bGwgfHwgX2RlZmF1bHRQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RlZmF1bHRQcm9wcy5jdXJzb3I7XHJcbiAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50UHJvcHNDdXJzb3IgfHwgIWlzQWN0aXZlIHx8ICFhY3RpdmVDb29yZGluYXRlIHx8IGNoYXJ0TmFtZSAhPT0gJ1NjYXR0ZXJDaGFydCcgJiYgdG9vbHRpcEV2ZW50VHlwZSAhPT0gJ2F4aXMnKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgdmFyIHJlc3RQcm9wcztcclxuICB2YXIgY3Vyc29yQ29tcCA9IF9DdXJ2ZS5DdXJ2ZTtcclxuICBpZiAoY2hhcnROYW1lID09PSAnU2NhdHRlckNoYXJ0Jykge1xyXG4gICAgcmVzdFByb3BzID0gYWN0aXZlQ29vcmRpbmF0ZTtcclxuICAgIGN1cnNvckNvbXAgPSBfQ3Jvc3MuQ3Jvc3M7XHJcbiAgfSBlbHNlIGlmIChjaGFydE5hbWUgPT09ICdCYXJDaGFydCcpIHtcclxuICAgIHJlc3RQcm9wcyA9ICgwLCBfZ2V0Q3Vyc29yUmVjdGFuZ2xlLmdldEN1cnNvclJlY3RhbmdsZSkobGF5b3V0LCBhY3RpdmVDb29yZGluYXRlLCBvZmZzZXQsIHRvb2x0aXBBeGlzQmFuZFNpemUpO1xyXG4gICAgY3Vyc29yQ29tcCA9IF9SZWN0YW5nbGUuUmVjdGFuZ2xlO1xyXG4gIH0gZWxzZSBpZiAobGF5b3V0ID09PSAncmFkaWFsJykge1xyXG4gICAgdmFyIF9nZXRSYWRpYWxDdXJzb3JQb2ludCA9ICgwLCBfZ2V0UmFkaWFsQ3Vyc29yUG9pbnRzLmdldFJhZGlhbEN1cnNvclBvaW50cykoYWN0aXZlQ29vcmRpbmF0ZSksXHJcbiAgICAgIGN4ID0gX2dldFJhZGlhbEN1cnNvclBvaW50LmN4LFxyXG4gICAgICBjeSA9IF9nZXRSYWRpYWxDdXJzb3JQb2ludC5jeSxcclxuICAgICAgcmFkaXVzID0gX2dldFJhZGlhbEN1cnNvclBvaW50LnJhZGl1cyxcclxuICAgICAgc3RhcnRBbmdsZSA9IF9nZXRSYWRpYWxDdXJzb3JQb2ludC5zdGFydEFuZ2xlLFxyXG4gICAgICBlbmRBbmdsZSA9IF9nZXRSYWRpYWxDdXJzb3JQb2ludC5lbmRBbmdsZTtcclxuICAgIHJlc3RQcm9wcyA9IHtcclxuICAgICAgY3g6IGN4LFxyXG4gICAgICBjeTogY3ksXHJcbiAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXHJcbiAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZSxcclxuICAgICAgaW5uZXJSYWRpdXM6IHJhZGl1cyxcclxuICAgICAgb3V0ZXJSYWRpdXM6IHJhZGl1c1xyXG4gICAgfTtcclxuICAgIGN1cnNvckNvbXAgPSBfU2VjdG9yLlNlY3RvcjtcclxuICB9IGVsc2Uge1xyXG4gICAgcmVzdFByb3BzID0ge1xyXG4gICAgICBwb2ludHM6ICgwLCBfZ2V0Q3Vyc29yUG9pbnRzLmdldEN1cnNvclBvaW50cykobGF5b3V0LCBhY3RpdmVDb29yZGluYXRlLCBvZmZzZXQpXHJcbiAgICB9O1xyXG4gICAgY3Vyc29yQ29tcCA9IF9DdXJ2ZS5DdXJ2ZTtcclxuICB9XHJcbiAgdmFyIGN1cnNvclByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XHJcbiAgICBzdHJva2U6ICcjY2NjJyxcclxuICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xyXG4gIH0sIG9mZnNldCksIHJlc3RQcm9wcyksICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykoZWxlbWVudFByb3BzQ3Vyc29yLCBmYWxzZSkpLCB7fSwge1xyXG4gICAgcGF5bG9hZDogYWN0aXZlUGF5bG9hZCxcclxuICAgIHBheWxvYWRJbmRleDogYWN0aXZlVG9vbHRpcEluZGV4LFxyXG4gICAgY2xhc3NOYW1lOiAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtdG9vbHRpcC1jdXJzb3InLCBlbGVtZW50UHJvcHNDdXJzb3IuY2xhc3NOYW1lKVxyXG4gIH0pO1xyXG4gIHJldHVybiAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5pc1ZhbGlkRWxlbWVudCkoZWxlbWVudFByb3BzQ3Vyc29yKSA/IC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNsb25lRWxlbWVudCkoZWxlbWVudFByb3BzQ3Vyc29yLCBjdXJzb3JQcm9wcykgOiAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jcmVhdGVFbGVtZW50KShjdXJzb3JDb21wLCBjdXJzb3JQcm9wcyk7XHJcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDdXJzb3IiLCJfcmVhY3QiLCJyZXF1aXJlIiwiX2Nsc3giLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX0N1cnZlIiwiX0Nyb3NzIiwiX2dldEN1cnNvclJlY3RhbmdsZSIsIl9SZWN0YW5nbGUiLCJfZ2V0UmFkaWFsQ3Vyc29yUG9pbnRzIiwiX1NlY3RvciIsIl9nZXRDdXJzb3JQb2ludHMiLCJfUmVhY3RVdGlscyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwicHJvdG90eXBlIiwib3duS2V5cyIsImUiLCJyIiwidCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImtleSIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJpIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwicHJvcHMiLCJfZWxlbWVudCRwcm9wcyRjdXJzb3IiLCJfZGVmYXVsdFByb3BzIiwiZWxlbWVudCIsInRvb2x0aXBFdmVudFR5cGUiLCJpc0FjdGl2ZSIsImFjdGl2ZUNvb3JkaW5hdGUiLCJhY3RpdmVQYXlsb2FkIiwib2Zmc2V0IiwiYWN0aXZlVG9vbHRpcEluZGV4IiwidG9vbHRpcEF4aXNCYW5kU2l6ZSIsImxheW91dCIsImNoYXJ0TmFtZSIsImVsZW1lbnRQcm9wc0N1cnNvciIsImN1cnNvciIsInR5cGUiLCJkZWZhdWx0UHJvcHMiLCJyZXN0UHJvcHMiLCJjdXJzb3JDb21wIiwiQ3VydmUiLCJDcm9zcyIsImdldEN1cnNvclJlY3RhbmdsZSIsIlJlY3RhbmdsZSIsIl9nZXRSYWRpYWxDdXJzb3JQb2ludCIsImdldFJhZGlhbEN1cnNvclBvaW50cyIsImN4IiwiY3kiLCJyYWRpdXMiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIiwiU2VjdG9yIiwicG9pbnRzIiwiZ2V0Q3Vyc29yUG9pbnRzIiwiY3Vyc29yUHJvcHMiLCJzdHJva2UiLCJwb2ludGVyRXZlbnRzIiwiZmlsdGVyUHJvcHMiLCJwYXlsb2FkIiwicGF5bG9hZEluZGV4IiwiY2xhc3NOYW1lIiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJjcmVhdGVFbGVtZW50Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/component/Cursor.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/component/Customized.js":
/*!***********************************************************!*\
  !*** ./node_modules/recharts/lib/component/Customized.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Customized = Customized;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _LogUtils = __webpack_require__(/*! ../util/LogUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/LogUtils.js\");\nvar _excluded = [\n    \"component\"\n];\n/**\r\n * @fileOverview Customized\r\n */ function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\n/**\r\n * custom svg elements by rechart instance props and state.\r\n * @returns {Object}   svg elements\r\n */ function Customized(_ref) {\n    var component = _ref.component, props = _objectWithoutProperties(_ref, _excluded);\n    var child;\n    if (/*#__PURE__*/ (0, _react.isValidElement)(component)) {\n        child = /*#__PURE__*/ (0, _react.cloneElement)(component, props);\n    } else if ((0, _isFunction[\"default\"])(component)) {\n        child = /*#__PURE__*/ (0, _react.createElement)(component, props);\n    } else {\n        (0, _LogUtils.warn)(false, \"Customized's props `component` must be React.element or Function, but got %s.\", _typeof(component));\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n        className: \"recharts-customized-wrapper\"\n    }, child);\n}\nCustomized.displayName = 'Customized';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY29tcG9uZW50L0N1c3RvbWl6ZWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFrQixHQUFHRTtBQUNyQixJQUFJQyxTQUFTQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3BELElBQUlDLGNBQWNDLHVCQUF1QkYsbUJBQU9BLENBQUMsNENBQW1CO0FBQ3BFLElBQUlHLFNBQVNILG1CQUFPQSxDQUFDLDJGQUFvQjtBQUN6QyxJQUFJSSxZQUFZSixtQkFBT0EsQ0FBQyx1RkFBa0I7QUFDMUMsSUFBSUssWUFBWTtJQUFDO0NBQVk7QUFDN0I7O0NBRUMsR0FDRCxTQUFTSCx1QkFBdUJJLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UseUJBQXlCQyxDQUFDO0lBQUksSUFBSSxjQUFjLE9BQU9DLFNBQVMsT0FBTztJQUFNLElBQUlDLElBQUksSUFBSUQsV0FBV0UsSUFBSSxJQUFJRjtJQUFXLE9BQU8sQ0FBQ0YsMkJBQTJCLFNBQVNBLHlCQUF5QkMsQ0FBQztRQUFJLE9BQU9BLElBQUlHLElBQUlEO0lBQUcsR0FBR0Y7QUFBSTtBQUNuTyxTQUFTVix3QkFBd0JVLENBQUMsRUFBRUUsQ0FBQztJQUFJLElBQUksQ0FBQ0EsS0FBS0YsS0FBS0EsRUFBRUYsVUFBVSxFQUFFLE9BQU9FO0lBQUcsSUFBSSxTQUFTQSxLQUFLLFlBQVlJLFFBQVFKLE1BQU0sY0FBYyxPQUFPQSxHQUFHLE9BQU87UUFBRSxXQUFXQTtJQUFFO0lBQUcsSUFBSUcsSUFBSUoseUJBQXlCRztJQUFJLElBQUlDLEtBQUtBLEVBQUVFLEdBQUcsQ0FBQ0wsSUFBSSxPQUFPRyxFQUFFRyxHQUFHLENBQUNOO0lBQUksSUFBSU8sSUFBSTtRQUFFQyxX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Q0FBQyxVQUFVLENBQUNnRCxhQUFhLENBQUMzQyxPQUFPNkMsS0FBSyxFQUFFO1FBQ2hFQyxXQUFXO0lBQ2IsR0FBR047QUFDTDtBQUNBOUMsV0FBV3FELFdBQVcsR0FBRyIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcY29tcG9uZW50XFxDdXN0b21pemVkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuQ3VzdG9taXplZCA9IEN1c3RvbWl6ZWQ7XHJcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgX2lzRnVuY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XHJcbnZhciBfTGF5ZXIgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL0xheWVyXCIpO1xyXG52YXIgX0xvZ1V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvTG9nVXRpbHNcIik7XHJcbnZhciBfZXhjbHVkZWQgPSBbXCJjb21wb25lbnRcIl07XHJcbi8qKlxyXG4gKiBAZmlsZU92ZXJ2aWV3IEN1c3RvbWl6ZWRcclxuICovXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxuLyoqXHJcbiAqIGN1c3RvbSBzdmcgZWxlbWVudHMgYnkgcmVjaGFydCBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9ICAgc3ZnIGVsZW1lbnRzXHJcbiAqL1xyXG5mdW5jdGlvbiBDdXN0b21pemVkKF9yZWYpIHtcclxuICB2YXIgY29tcG9uZW50ID0gX3JlZi5jb21wb25lbnQsXHJcbiAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQpO1xyXG4gIHZhciBjaGlsZDtcclxuICBpZiAoIC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmlzVmFsaWRFbGVtZW50KShjb21wb25lbnQpKSB7XHJcbiAgICBjaGlsZCA9IC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNsb25lRWxlbWVudCkoY29tcG9uZW50LCBwcm9wcyk7XHJcbiAgfSBlbHNlIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShjb21wb25lbnQpKSB7XHJcbiAgICBjaGlsZCA9IC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNyZWF0ZUVsZW1lbnQpKGNvbXBvbmVudCwgcHJvcHMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAoMCwgX0xvZ1V0aWxzLndhcm4pKGZhbHNlLCBcIkN1c3RvbWl6ZWQncyBwcm9wcyBgY29tcG9uZW50YCBtdXN0IGJlIFJlYWN0LmVsZW1lbnQgb3IgRnVuY3Rpb24sIGJ1dCBnb3QgJXMuXCIsIF90eXBlb2YoY29tcG9uZW50KSk7XHJcbiAgfVxyXG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xyXG4gICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWN1c3RvbWl6ZWQtd3JhcHBlclwiXHJcbiAgfSwgY2hpbGQpO1xyXG59XHJcbkN1c3RvbWl6ZWQuZGlzcGxheU5hbWUgPSAnQ3VzdG9taXplZCc7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ3VzdG9taXplZCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9pc0Z1bmN0aW9uIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9MYXllciIsIl9Mb2dVdGlscyIsIl9leGNsdWRlZCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX3R5cGVvZiIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJzb3VyY2UiLCJleGNsdWRlZCIsInRhcmdldCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwia2V5IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsImxlbmd0aCIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9yZWYiLCJjb21wb25lbnQiLCJwcm9wcyIsImNoaWxkIiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwid2FybiIsIkxheWVyIiwiY2xhc3NOYW1lIiwiZGlzcGxheU5hbWUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/component/Customized.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/component/DefaultLegendContent.js":
/*!*********************************************************************!*\
  !*** ./node_modules/recharts/lib/component/DefaultLegendContent.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DefaultLegendContent = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _clsx2 = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _LogUtils = __webpack_require__(/*! ../util/LogUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/LogUtils.js\");\nvar _Surface = __webpack_require__(/*! ../container/Surface */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Surface.js\");\nvar _Symbols = __webpack_require__(/*! ../shape/Symbols */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Symbols.js\");\nvar _types = __webpack_require__(/*! ../util/types */ \"(pages-dir-node)/./node_modules/recharts/lib/util/types.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Default Legend Content\r\n */ \nvar SIZE = 32;\nvar DefaultLegendContent = exports.DefaultLegendContent = /*#__PURE__*/ function(_PureComponent) {\n    function DefaultLegendContent() {\n        _classCallCheck(this, DefaultLegendContent);\n        return _callSuper(this, DefaultLegendContent, arguments);\n    }\n    _inherits(DefaultLegendContent, _PureComponent);\n    return _createClass(DefaultLegendContent, [\n        {\n            key: \"renderIcon\",\n            value: /**\r\n     * Render the path of icon\r\n     * @param {Object} data Data of each legend item\r\n     * @return {String} Path element\r\n     */ function renderIcon(data) {\n                var inactiveColor = this.props.inactiveColor;\n                var halfSize = SIZE / 2;\n                var sixthSize = SIZE / 6;\n                var thirdSize = SIZE / 3;\n                var color = data.inactive ? inactiveColor : data.color;\n                if (data.type === 'plainline') {\n                    return /*#__PURE__*/ _react[\"default\"].createElement(\"line\", {\n                        strokeWidth: 4,\n                        fill: \"none\",\n                        stroke: color,\n                        strokeDasharray: data.payload.strokeDasharray,\n                        x1: 0,\n                        y1: halfSize,\n                        x2: SIZE,\n                        y2: halfSize,\n                        className: \"recharts-legend-icon\"\n                    });\n                }\n                if (data.type === 'line') {\n                    return /*#__PURE__*/ _react[\"default\"].createElement(\"path\", {\n                        strokeWidth: 4,\n                        fill: \"none\",\n                        stroke: color,\n                        d: \"M0,\".concat(halfSize, \"h\").concat(thirdSize, \"\\n            A\").concat(sixthSize, \",\").concat(sixthSize, \",0,1,1,\").concat(2 * thirdSize, \",\").concat(halfSize, \"\\n            H\").concat(SIZE, \"M\").concat(2 * thirdSize, \",\").concat(halfSize, \"\\n            A\").concat(sixthSize, \",\").concat(sixthSize, \",0,1,1,\").concat(thirdSize, \",\").concat(halfSize),\n                        className: \"recharts-legend-icon\"\n                    });\n                }\n                if (data.type === 'rect') {\n                    return /*#__PURE__*/ _react[\"default\"].createElement(\"path\", {\n                        stroke: \"none\",\n                        fill: color,\n                        d: \"M0,\".concat(SIZE / 8, \"h\").concat(SIZE, \"v\").concat(SIZE * 3 / 4, \"h\").concat(-SIZE, \"z\"),\n                        className: \"recharts-legend-icon\"\n                    });\n                }\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(data.legendIcon)) {\n                    var iconProps = _objectSpread({}, data);\n                    delete iconProps.legendIcon;\n                    return /*#__PURE__*/ _react[\"default\"].cloneElement(data.legendIcon, iconProps);\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Symbols.Symbols, {\n                    fill: color,\n                    cx: halfSize,\n                    cy: halfSize,\n                    size: SIZE,\n                    sizeType: \"diameter\",\n                    type: data.type\n                });\n            }\n        },\n        {\n            key: \"renderItems\",\n            value: function renderItems() {\n                var _this = this;\n                var _this$props = this.props, payload = _this$props.payload, iconSize = _this$props.iconSize, layout = _this$props.layout, formatter = _this$props.formatter, inactiveColor = _this$props.inactiveColor;\n                var viewBox = {\n                    x: 0,\n                    y: 0,\n                    width: SIZE,\n                    height: SIZE\n                };\n                var itemStyle = {\n                    display: layout === 'horizontal' ? 'inline-block' : 'block',\n                    marginRight: 10\n                };\n                var svgStyle = {\n                    display: 'inline-block',\n                    verticalAlign: 'middle',\n                    marginRight: 4\n                };\n                return payload.map(function(entry, i) {\n                    var finalFormatter = entry.formatter || formatter;\n                    var className = (0, _clsx2[\"default\"])(_defineProperty(_defineProperty({\n                        'recharts-legend-item': true\n                    }, \"legend-item-\".concat(i), true), \"inactive\", entry.inactive));\n                    if (entry.type === 'none') {\n                        return null;\n                    }\n                    // Do not render entry.value as functions. Always require static string properties.\n                    var entryValue = !(0, _isFunction[\"default\"])(entry.value) ? entry.value : null;\n                    (0, _LogUtils.warn)(!(0, _isFunction[\"default\"])(entry.value), \"The name property is also required when using a function for the dataKey of a chart's cartesian components. Ex: <Bar name=\\\"Name of my Data\\\"/>\" // eslint-disable-line max-len\n                    );\n                    var color = entry.inactive ? inactiveColor : entry.color;\n                    return /*#__PURE__*/ _react[\"default\"].createElement(\"li\", _extends({\n                        className: className,\n                        style: itemStyle,\n                        key: \"legend-item-\".concat(i)\n                    }, (0, _types.adaptEventsOfChild)(_this.props, entry, i)), /*#__PURE__*/ _react[\"default\"].createElement(_Surface.Surface, {\n                        width: iconSize,\n                        height: iconSize,\n                        viewBox: viewBox,\n                        style: svgStyle\n                    }, _this.renderIcon(entry)), /*#__PURE__*/ _react[\"default\"].createElement(\"span\", {\n                        className: \"recharts-legend-item-text\",\n                        style: {\n                            color: color\n                        }\n                    }, finalFormatter ? finalFormatter(entryValue, entry, i) : entryValue));\n                });\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props2 = this.props, payload = _this$props2.payload, layout = _this$props2.layout, align = _this$props2.align;\n                if (!payload || !payload.length) {\n                    return null;\n                }\n                var finalStyle = {\n                    padding: 0,\n                    margin: 0,\n                    textAlign: layout === 'horizontal' ? align : 'left'\n                };\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"ul\", {\n                    className: \"recharts-default-legend\",\n                    style: finalStyle\n                }, this.renderItems());\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(DefaultLegendContent, \"displayName\", 'Legend');\n_defineProperty(DefaultLegendContent, \"defaultProps\", {\n    iconSize: 14,\n    layout: 'horizontal',\n    align: 'center',\n    verticalAlign: 'middle',\n    inactiveColor: '#ccc'\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY29tcG9uZW50L0RlZmF1bHRMZWdlbmRDb250ZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCw0QkFBNEIsR0FBRyxLQUFLO0FBQ3BDLElBQUlHLFNBQVNDLHdCQUF3QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUMsY0FBY0MsdUJBQXVCRixtQkFBT0EsQ0FBQyw0Q0FBbUI7QUFDcEUsSUFBSUcsU0FBU0QsdUJBQXVCRixtQkFBT0EsQ0FBQyx1QkFBTTtBQUNsRCxJQUFJSSxZQUFZSixtQkFBT0EsQ0FBQyx1RkFBa0I7QUFDMUMsSUFBSUssV0FBV0wsbUJBQU9BLENBQUMsK0ZBQXNCO0FBQzdDLElBQUlNLFdBQVdOLG1CQUFPQSxDQUFDLHVGQUFrQjtBQUN6QyxJQUFJTyxTQUFTUCxtQkFBT0EsQ0FBQyxpRkFBZTtBQUNwQyxTQUFTRSx1QkFBdUJNLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UseUJBQXlCQyxDQUFDO0lBQUksSUFBSSxjQUFjLE9BQU9DLFNBQVMsT0FBTztJQUFNLElBQUlDLElBQUksSUFBSUQsV0FBV0UsSUFBSSxJQUFJRjtJQUFXLE9BQU8sQ0FBQ0YsMkJBQTJCLFNBQVNBLHlCQUF5QkMsQ0FBQztRQUFJLE9BQU9BLElBQUlHLElBQUlEO0lBQUcsR0FBR0Y7QUFBSTtBQUNuTyxTQUFTWix3QkFBd0JZLENBQUMsRUFBRUUsQ0FBQztJQUFJLElBQUksQ0FBQ0EsS0FBS0YsS0FBS0EsRUFBRUYsVUFBVSxFQUFFLE9BQU9FO0lBQUcsSUFBSSxTQUFTQSxLQUFLLFlBQVlJLFFBQVFKLE1BQU0sY0FBYyxPQUFPQSxHQUFHLE9BQU87UUFBRSxXQUFXQTtJQUFFO0lBQUcsSUFBSUcsSUFBSUos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QUFNLEVBQzVCc0IsUUFBUUQsYUFBYUMsS0FBSztnQkFDNUIsSUFBSSxDQUFDM0MsV0FBVyxDQUFDQSxRQUFRbkUsTUFBTSxFQUFFO29CQUMvQixPQUFPO2dCQUNUO2dCQUNBLElBQUkrRyxhQUFhO29CQUNmQyxTQUFTO29CQUNUQyxRQUFRO29CQUNSQyxXQUFXMUIsV0FBVyxlQUFlc0IsUUFBUTtnQkFDL0M7Z0JBQ0EsT0FBTyxXQUFXLEdBQUVwSixNQUFNLENBQUMsVUFBVSxDQUFDb0csYUFBYSxDQUFDLE1BQU07b0JBQ3hEVSxXQUFXO29CQUNYaUMsT0FBT007Z0JBQ1QsR0FBRyxJQUFJLENBQUMzQixXQUFXO1lBQ3JCO1FBQ0Y7S0FBRTtBQUNKLEVBQUUxSCxPQUFPeUosYUFBYTtBQUN0QnZHLGdCQUFnQm5ELHNCQUFzQixlQUFlO0FBQ3JEbUQsZ0JBQWdCbkQsc0JBQXNCLGdCQUFnQjtJQUNwRDhILFVBQVU7SUFDVkMsUUFBUTtJQUNSc0IsT0FBTztJQUNQWCxlQUFlO0lBQ2Y1QyxlQUFlO0FBQ2pCIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxjb21wb25lbnRcXERlZmF1bHRMZWdlbmRDb250ZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuRGVmYXVsdExlZ2VuZENvbnRlbnQgPSB2b2lkIDA7XHJcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgX2lzRnVuY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XHJcbnZhciBfY2xzeDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcclxudmFyIF9Mb2dVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0xvZ1V0aWxzXCIpO1xyXG52YXIgX1N1cmZhY2UgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL1N1cmZhY2VcIik7XHJcbnZhciBfU3ltYm9scyA9IHJlcXVpcmUoXCIuLi9zaGFwZS9TeW1ib2xzXCIpO1xyXG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4uL3V0aWwvdHlwZXNcIik7XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxyXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxyXG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxyXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cclxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XHJcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxyXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxyXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxyXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxyXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XHJcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxyXG4gKiBAZmlsZU92ZXJ2aWV3IERlZmF1bHQgTGVnZW5kIENvbnRlbnRcclxuICovXHJcbnZhciBTSVpFID0gMzI7XHJcbnZhciBEZWZhdWx0TGVnZW5kQ29udGVudCA9IGV4cG9ydHMuRGVmYXVsdExlZ2VuZENvbnRlbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QdXJlQ29tcG9uZW50KSB7XHJcbiAgZnVuY3Rpb24gRGVmYXVsdExlZ2VuZENvbnRlbnQoKSB7XHJcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVmYXVsdExlZ2VuZENvbnRlbnQpO1xyXG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgRGVmYXVsdExlZ2VuZENvbnRlbnQsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG4gIF9pbmhlcml0cyhEZWZhdWx0TGVnZW5kQ29udGVudCwgX1B1cmVDb21wb25lbnQpO1xyXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRGVmYXVsdExlZ2VuZENvbnRlbnQsIFt7XHJcbiAgICBrZXk6IFwicmVuZGVySWNvblwiLFxyXG4gICAgdmFsdWU6XHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlciB0aGUgcGF0aCBvZiBpY29uXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBEYXRhIG9mIGVhY2ggbGVnZW5kIGl0ZW1cclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUGF0aCBlbGVtZW50XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlbmRlckljb24oZGF0YSkge1xyXG4gICAgICB2YXIgaW5hY3RpdmVDb2xvciA9IHRoaXMucHJvcHMuaW5hY3RpdmVDb2xvcjtcclxuICAgICAgdmFyIGhhbGZTaXplID0gU0laRSAvIDI7XHJcbiAgICAgIHZhciBzaXh0aFNpemUgPSBTSVpFIC8gNjtcclxuICAgICAgdmFyIHRoaXJkU2l6ZSA9IFNJWkUgLyAzO1xyXG4gICAgICB2YXIgY29sb3IgPSBkYXRhLmluYWN0aXZlID8gaW5hY3RpdmVDb2xvciA6IGRhdGEuY29sb3I7XHJcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdwbGFpbmxpbmUnKSB7XHJcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIHtcclxuICAgICAgICAgIHN0cm9rZVdpZHRoOiA0LFxyXG4gICAgICAgICAgZmlsbDogXCJub25lXCIsXHJcbiAgICAgICAgICBzdHJva2U6IGNvbG9yLFxyXG4gICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiBkYXRhLnBheWxvYWQuc3Ryb2tlRGFzaGFycmF5LFxyXG4gICAgICAgICAgeDE6IDAsXHJcbiAgICAgICAgICB5MTogaGFsZlNpemUsXHJcbiAgICAgICAgICB4MjogU0laRSxcclxuICAgICAgICAgIHkyOiBoYWxmU2l6ZSxcclxuICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1sZWdlbmQtaWNvblwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2xpbmUnKSB7XHJcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcclxuICAgICAgICAgIHN0cm9rZVdpZHRoOiA0LFxyXG4gICAgICAgICAgZmlsbDogXCJub25lXCIsXHJcbiAgICAgICAgICBzdHJva2U6IGNvbG9yLFxyXG4gICAgICAgICAgZDogXCJNMCxcIi5jb25jYXQoaGFsZlNpemUsIFwiaFwiKS5jb25jYXQodGhpcmRTaXplLCBcIlxcbiAgICAgICAgICAgIEFcIikuY29uY2F0KHNpeHRoU2l6ZSwgXCIsXCIpLmNvbmNhdChzaXh0aFNpemUsIFwiLDAsMSwxLFwiKS5jb25jYXQoMiAqIHRoaXJkU2l6ZSwgXCIsXCIpLmNvbmNhdChoYWxmU2l6ZSwgXCJcXG4gICAgICAgICAgICBIXCIpLmNvbmNhdChTSVpFLCBcIk1cIikuY29uY2F0KDIgKiB0aGlyZFNpemUsIFwiLFwiKS5jb25jYXQoaGFsZlNpemUsIFwiXFxuICAgICAgICAgICAgQVwiKS5jb25jYXQoc2l4dGhTaXplLCBcIixcIikuY29uY2F0KHNpeHRoU2l6ZSwgXCIsMCwxLDEsXCIpLmNvbmNhdCh0aGlyZFNpemUsIFwiLFwiKS5jb25jYXQoaGFsZlNpemUpLFxyXG4gICAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWxlZ2VuZC1pY29uXCJcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZGF0YS50eXBlID09PSAncmVjdCcpIHtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xyXG4gICAgICAgICAgc3Ryb2tlOiBcIm5vbmVcIixcclxuICAgICAgICAgIGZpbGw6IGNvbG9yLFxyXG4gICAgICAgICAgZDogXCJNMCxcIi5jb25jYXQoU0laRSAvIDgsIFwiaFwiKS5jb25jYXQoU0laRSwgXCJ2XCIpLmNvbmNhdChTSVpFICogMyAvIDQsIFwiaFwiKS5jb25jYXQoLVNJWkUsIFwielwiKSxcclxuICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1sZWdlbmQtaWNvblwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5pc1ZhbGlkRWxlbWVudChkYXRhLmxlZ2VuZEljb24pKSB7XHJcbiAgICAgICAgdmFyIGljb25Qcm9wcyA9IF9vYmplY3RTcHJlYWQoe30sIGRhdGEpO1xyXG4gICAgICAgIGRlbGV0ZSBpY29uUHJvcHMubGVnZW5kSWNvbjtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGRhdGEubGVnZW5kSWNvbiwgaWNvblByb3BzKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfU3ltYm9scy5TeW1ib2xzLCB7XHJcbiAgICAgICAgZmlsbDogY29sb3IsXHJcbiAgICAgICAgY3g6IGhhbGZTaXplLFxyXG4gICAgICAgIGN5OiBoYWxmU2l6ZSxcclxuICAgICAgICBzaXplOiBTSVpFLFxyXG4gICAgICAgIHNpemVUeXBlOiBcImRpYW1ldGVyXCIsXHJcbiAgICAgICAgdHlwZTogZGF0YS50eXBlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBpdGVtcyBvZiBsZWdlbmRcclxuICAgICAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gSXRlbXNcclxuICAgICAqL1xyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJJdGVtc1wiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckl0ZW1zKCkge1xyXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIHBheWxvYWQgPSBfdGhpcyRwcm9wcy5wYXlsb2FkLFxyXG4gICAgICAgIGljb25TaXplID0gX3RoaXMkcHJvcHMuaWNvblNpemUsXHJcbiAgICAgICAgbGF5b3V0ID0gX3RoaXMkcHJvcHMubGF5b3V0LFxyXG4gICAgICAgIGZvcm1hdHRlciA9IF90aGlzJHByb3BzLmZvcm1hdHRlcixcclxuICAgICAgICBpbmFjdGl2ZUNvbG9yID0gX3RoaXMkcHJvcHMuaW5hY3RpdmVDb2xvcjtcclxuICAgICAgdmFyIHZpZXdCb3ggPSB7XHJcbiAgICAgICAgeDogMCxcclxuICAgICAgICB5OiAwLFxyXG4gICAgICAgIHdpZHRoOiBTSVpFLFxyXG4gICAgICAgIGhlaWdodDogU0laRVxyXG4gICAgICB9O1xyXG4gICAgICB2YXIgaXRlbVN0eWxlID0ge1xyXG4gICAgICAgIGRpc3BsYXk6IGxheW91dCA9PT0gJ2hvcml6b250YWwnID8gJ2lubGluZS1ibG9jaycgOiAnYmxvY2snLFxyXG4gICAgICAgIG1hcmdpblJpZ2h0OiAxMFxyXG4gICAgICB9O1xyXG4gICAgICB2YXIgc3ZnU3R5bGUgPSB7XHJcbiAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXHJcbiAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXHJcbiAgICAgICAgbWFyZ2luUmlnaHQ6IDRcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHBheWxvYWQubWFwKGZ1bmN0aW9uIChlbnRyeSwgaSkge1xyXG4gICAgICAgIHZhciBmaW5hbEZvcm1hdHRlciA9IGVudHJ5LmZvcm1hdHRlciB8fCBmb3JtYXR0ZXI7XHJcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICgwLCBfY2xzeDJbXCJkZWZhdWx0XCJdKShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KHtcclxuICAgICAgICAgICdyZWNoYXJ0cy1sZWdlbmQtaXRlbSc6IHRydWVcclxuICAgICAgICB9LCBcImxlZ2VuZC1pdGVtLVwiLmNvbmNhdChpKSwgdHJ1ZSksIFwiaW5hY3RpdmVcIiwgZW50cnkuaW5hY3RpdmUpKTtcclxuICAgICAgICBpZiAoZW50cnkudHlwZSA9PT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERvIG5vdCByZW5kZXIgZW50cnkudmFsdWUgYXMgZnVuY3Rpb25zLiBBbHdheXMgcmVxdWlyZSBzdGF0aWMgc3RyaW5nIHByb3BlcnRpZXMuXHJcbiAgICAgICAgdmFyIGVudHJ5VmFsdWUgPSAhKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkoZW50cnkudmFsdWUpID8gZW50cnkudmFsdWUgOiBudWxsO1xyXG4gICAgICAgICgwLCBfTG9nVXRpbHMud2FybikoISgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKGVudHJ5LnZhbHVlKSwgXCJUaGUgbmFtZSBwcm9wZXJ0eSBpcyBhbHNvIHJlcXVpcmVkIHdoZW4gdXNpbmcgYSBmdW5jdGlvbiBmb3IgdGhlIGRhdGFLZXkgb2YgYSBjaGFydCdzIGNhcnRlc2lhbiBjb21wb25lbnRzLiBFeDogPEJhciBuYW1lPVxcXCJOYW1lIG9mIG15IERhdGFcXFwiLz5cIiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cclxuICAgICAgICApO1xyXG4gICAgICAgIHZhciBjb2xvciA9IGVudHJ5LmluYWN0aXZlID8gaW5hY3RpdmVDb2xvciA6IGVudHJ5LmNvbG9yO1xyXG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwibGlcIiwgX2V4dGVuZHMoe1xyXG4gICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXHJcbiAgICAgICAgICBzdHlsZTogaXRlbVN0eWxlXHJcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XHJcbiAgICAgICAgICAsXHJcbiAgICAgICAgICBrZXk6IFwibGVnZW5kLWl0ZW0tXCIuY29uY2F0KGkpXHJcbiAgICAgICAgfSwgKDAsIF90eXBlcy5hZGFwdEV2ZW50c09mQ2hpbGQpKF90aGlzLnByb3BzLCBlbnRyeSwgaSkpLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9TdXJmYWNlLlN1cmZhY2UsIHtcclxuICAgICAgICAgIHdpZHRoOiBpY29uU2l6ZSxcclxuICAgICAgICAgIGhlaWdodDogaWNvblNpemUsXHJcbiAgICAgICAgICB2aWV3Qm94OiB2aWV3Qm94LFxyXG4gICAgICAgICAgc3R5bGU6IHN2Z1N0eWxlXHJcbiAgICAgICAgfSwgX3RoaXMucmVuZGVySWNvbihlbnRyeSkpLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XHJcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtbGVnZW5kLWl0ZW0tdGV4dFwiLFxyXG4gICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgY29sb3I6IGNvbG9yXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZmluYWxGb3JtYXR0ZXIgPyBmaW5hbEZvcm1hdHRlcihlbnRyeVZhbHVlLCBlbnRyeSwgaSkgOiBlbnRyeVZhbHVlKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIHBheWxvYWQgPSBfdGhpcyRwcm9wczIucGF5bG9hZCxcclxuICAgICAgICBsYXlvdXQgPSBfdGhpcyRwcm9wczIubGF5b3V0LFxyXG4gICAgICAgIGFsaWduID0gX3RoaXMkcHJvcHMyLmFsaWduO1xyXG4gICAgICBpZiAoIXBheWxvYWQgfHwgIXBheWxvYWQubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGZpbmFsU3R5bGUgPSB7XHJcbiAgICAgICAgcGFkZGluZzogMCxcclxuICAgICAgICBtYXJnaW46IDAsXHJcbiAgICAgICAgdGV4dEFsaWduOiBsYXlvdXQgPT09ICdob3Jpem9udGFsJyA/IGFsaWduIDogJ2xlZnQnXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwidWxcIiwge1xyXG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1kZWZhdWx0LWxlZ2VuZFwiLFxyXG4gICAgICAgIHN0eWxlOiBmaW5hbFN0eWxlXHJcbiAgICAgIH0sIHRoaXMucmVuZGVySXRlbXMoKSk7XHJcbiAgICB9XHJcbiAgfV0pO1xyXG59KF9yZWFjdC5QdXJlQ29tcG9uZW50KTtcclxuX2RlZmluZVByb3BlcnR5KERlZmF1bHRMZWdlbmRDb250ZW50LCBcImRpc3BsYXlOYW1lXCIsICdMZWdlbmQnKTtcclxuX2RlZmluZVByb3BlcnR5KERlZmF1bHRMZWdlbmRDb250ZW50LCBcImRlZmF1bHRQcm9wc1wiLCB7XHJcbiAgaWNvblNpemU6IDE0LFxyXG4gIGxheW91dDogJ2hvcml6b250YWwnLFxyXG4gIGFsaWduOiAnY2VudGVyJyxcclxuICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcclxuICBpbmFjdGl2ZUNvbG9yOiAnI2NjYydcclxufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRGVmYXVsdExlZ2VuZENvbnRlbnQiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfaXNGdW5jdGlvbiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfY2xzeDIiLCJfTG9nVXRpbHMiLCJfU3VyZmFjZSIsIl9TeW1ib2xzIiwiX3R5cGVzIiwib2JqIiwiX19lc01vZHVsZSIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJfdHlwZW9mIiwiaGFzIiwiZ2V0IiwibiIsIl9fcHJvdG9fXyIsImEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ1IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaSIsInNldCIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsImFwcGx5Iiwib3duS2V5cyIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJlbnVtZXJhYmxlIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1Byb3BlcnR5S2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NhbGxTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiQm9vbGVhbiIsInZhbHVlT2YiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwicCIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiU0laRSIsIl9QdXJlQ29tcG9uZW50IiwicmVuZGVySWNvbiIsImRhdGEiLCJpbmFjdGl2ZUNvbG9yIiwiaGFsZlNpemUiLCJzaXh0aFNpemUiLCJ0aGlyZFNpemUiLCJjb2xvciIsImluYWN0aXZlIiwidHlwZSIsImNyZWF0ZUVsZW1lbnQiLCJzdHJva2VXaWR0aCIsImZpbGwiLCJzdHJva2UiLCJzdHJva2VEYXNoYXJyYXkiLCJwYXlsb2FkIiwieDEiLCJ5MSIsIngyIiwieTIiLCJjbGFzc05hbWUiLCJkIiwiY29uY2F0IiwiaXNWYWxpZEVsZW1lbnQiLCJsZWdlbmRJY29uIiwiaWNvblByb3BzIiwiY2xvbmVFbGVtZW50IiwiU3ltYm9scyIsImN4IiwiY3kiLCJzaXplIiwic2l6ZVR5cGUiLCJyZW5kZXJJdGVtcyIsIl90aGlzIiwiX3RoaXMkcHJvcHMiLCJpY29uU2l6ZSIsImxheW91dCIsImZvcm1hdHRlciIsInZpZXdCb3giLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0IiwiaXRlbVN0eWxlIiwiZGlzcGxheSIsIm1hcmdpblJpZ2h0Iiwic3ZnU3R5bGUiLCJ2ZXJ0aWNhbEFsaWduIiwibWFwIiwiZW50cnkiLCJmaW5hbEZvcm1hdHRlciIsImVudHJ5VmFsdWUiLCJ3YXJuIiwic3R5bGUiLCJhZGFwdEV2ZW50c09mQ2hpbGQiLCJTdXJmYWNlIiwicmVuZGVyIiwiX3RoaXMkcHJvcHMyIiwiYWxpZ24iLCJmaW5hbFN0eWxlIiwicGFkZGluZyIsIm1hcmdpbiIsInRleHRBbGlnbiIsIlB1cmVDb21wb25lbnQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/component/DefaultLegendContent.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/component/DefaultTooltipContent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/recharts/lib/component/DefaultTooltipContent.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DefaultTooltipContent = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _sortBy = _interopRequireDefault(__webpack_require__(/*! lodash/sortBy */ \"lodash/sortBy\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Default Tooltip Content\r\n */ \nfunction defaultFormatter(value) {\n    return Array.isArray(value) && (0, _DataUtils.isNumOrStr)(value[0]) && (0, _DataUtils.isNumOrStr)(value[1]) ? value.join(' ~ ') : value;\n}\nvar DefaultTooltipContent = exports.DefaultTooltipContent = function DefaultTooltipContent(props) {\n    var _props$separator = props.separator, separator = _props$separator === void 0 ? ' : ' : _props$separator, _props$contentStyle = props.contentStyle, contentStyle = _props$contentStyle === void 0 ? {} : _props$contentStyle, _props$itemStyle = props.itemStyle, itemStyle = _props$itemStyle === void 0 ? {} : _props$itemStyle, _props$labelStyle = props.labelStyle, labelStyle = _props$labelStyle === void 0 ? {} : _props$labelStyle, payload = props.payload, formatter = props.formatter, itemSorter = props.itemSorter, wrapperClassName = props.wrapperClassName, labelClassName = props.labelClassName, label = props.label, labelFormatter = props.labelFormatter, _props$accessibilityL = props.accessibilityLayer, accessibilityLayer = _props$accessibilityL === void 0 ? false : _props$accessibilityL;\n    var renderContent = function renderContent() {\n        if (payload && payload.length) {\n            var listStyle = {\n                padding: 0,\n                margin: 0\n            };\n            var items = (itemSorter ? (0, _sortBy[\"default\"])(payload, itemSorter) : payload).map(function(entry, i) {\n                if (entry.type === 'none') {\n                    return null;\n                }\n                var finalItemStyle = _objectSpread({\n                    display: 'block',\n                    paddingTop: 4,\n                    paddingBottom: 4,\n                    color: entry.color || '#000'\n                }, itemStyle);\n                var finalFormatter = entry.formatter || formatter || defaultFormatter;\n                var value = entry.value, name = entry.name;\n                var finalValue = value;\n                var finalName = name;\n                if (finalFormatter && finalValue != null && finalName != null) {\n                    var formatted = finalFormatter(value, name, entry, i, payload);\n                    if (Array.isArray(formatted)) {\n                        var _formatted = _slicedToArray(formatted, 2);\n                        finalValue = _formatted[0];\n                        finalName = _formatted[1];\n                    } else {\n                        finalValue = formatted;\n                    }\n                }\n                return(/*#__PURE__*/ // eslint-disable-next-line react/no-array-index-key\n                _react[\"default\"].createElement(\"li\", {\n                    className: \"recharts-tooltip-item\",\n                    key: \"tooltip-item-\".concat(i),\n                    style: finalItemStyle\n                }, (0, _DataUtils.isNumOrStr)(finalName) ? /*#__PURE__*/ _react[\"default\"].createElement(\"span\", {\n                    className: \"recharts-tooltip-item-name\"\n                }, finalName) : null, (0, _DataUtils.isNumOrStr)(finalName) ? /*#__PURE__*/ _react[\"default\"].createElement(\"span\", {\n                    className: \"recharts-tooltip-item-separator\"\n                }, separator) : null, /*#__PURE__*/ _react[\"default\"].createElement(\"span\", {\n                    className: \"recharts-tooltip-item-value\"\n                }, finalValue), /*#__PURE__*/ _react[\"default\"].createElement(\"span\", {\n                    className: \"recharts-tooltip-item-unit\"\n                }, entry.unit || '')));\n            });\n            return /*#__PURE__*/ _react[\"default\"].createElement(\"ul\", {\n                className: \"recharts-tooltip-item-list\",\n                style: listStyle\n            }, items);\n        }\n        return null;\n    };\n    var finalStyle = _objectSpread({\n        margin: 0,\n        padding: 10,\n        backgroundColor: '#fff',\n        border: '1px solid #ccc',\n        whiteSpace: 'nowrap'\n    }, contentStyle);\n    var finalLabelStyle = _objectSpread({\n        margin: 0\n    }, labelStyle);\n    var hasLabel = !(0, _isNil[\"default\"])(label);\n    var finalLabel = hasLabel ? label : '';\n    var wrapperCN = (0, _clsx[\"default\"])('recharts-default-tooltip', wrapperClassName);\n    var labelCN = (0, _clsx[\"default\"])('recharts-tooltip-label', labelClassName);\n    if (hasLabel && labelFormatter && payload !== undefined && payload !== null) {\n        finalLabel = labelFormatter(label, payload);\n    }\n    var accessibilityAttributes = accessibilityLayer ? {\n        role: 'status',\n        'aria-live': 'assertive'\n    } : {};\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"div\", _extends({\n        className: wrapperCN,\n        style: finalStyle\n    }, accessibilityAttributes), /*#__PURE__*/ _react[\"default\"].createElement(\"p\", {\n        className: labelCN,\n        style: finalLabelStyle\n    }, /*#__PURE__*/ _react[\"default\"].isValidElement(finalLabel) ? finalLabel : \"\".concat(finalLabel)), renderContent());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY29tcG9uZW50L0RlZmF1bHRUb29sdGlwQ29udGVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsNkJBQTZCLEdBQUcsS0FBSztBQUNyQyxJQUFJRyxTQUFTQyx1QkFBdUJDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ25ELElBQUlDLFVBQVVGLHVCQUF1QkMsbUJBQU9BLENBQUMsb0NBQWU7QUFDNUQsSUFBSUUsU0FBU0gsdUJBQXVCQyxtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJRyxRQUFRSix1QkFBdUJDLG1CQUFPQSxDQUFDLHVCQUFNO0FBQ2pELElBQUlJLGFBQWFKLG1CQUFPQSxDQUFDLHlGQUFtQjtBQUM1QyxTQUFTRCx1QkFBdUJNLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUUsV0FBVyxLQUFLQyxVQUFVRCxNQUFNQyxPQUFPRSxTQUFTLEdBQUcsV0FBVyxPQUFPSDtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1QsU0FBU0k7SUFBYUEsV0FBV25CLE9BQU9vQixNQUFNLEdBQUdwQixPQUFPb0IsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVUMsTUFBTTtRQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFBRSxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFB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LE1BQU0sQ0FBQ1MsY0FBYzdCO0FBQ3RHIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxjb21wb25lbnRcXERlZmF1bHRUb29sdGlwQ29udGVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLkRlZmF1bHRUb29sdGlwQ29udGVudCA9IHZvaWQgMDtcclxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIF9zb3J0QnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvc29ydEJ5XCIpKTtcclxudmFyIF9pc05pbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc05pbFwiKSk7XHJcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xyXG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0RhdGFVdGlsc1wiKTtcclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XHJcbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cclxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XHJcbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XHJcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cclxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XHJcbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XHJcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxyXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cclxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cclxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxyXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfSAvKipcclxuICogQGZpbGVPdmVydmlldyBEZWZhdWx0IFRvb2x0aXAgQ29udGVudFxyXG4gKi9cclxuZnVuY3Rpb24gZGVmYXVsdEZvcm1hdHRlcih2YWx1ZSkge1xyXG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAoMCwgX0RhdGFVdGlscy5pc051bU9yU3RyKSh2YWx1ZVswXSkgJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1PclN0cikodmFsdWVbMV0pID8gdmFsdWUuam9pbignIH4gJykgOiB2YWx1ZTtcclxufVxyXG52YXIgRGVmYXVsdFRvb2x0aXBDb250ZW50ID0gZXhwb3J0cy5EZWZhdWx0VG9vbHRpcENvbnRlbnQgPSBmdW5jdGlvbiBEZWZhdWx0VG9vbHRpcENvbnRlbnQocHJvcHMpIHtcclxuICB2YXIgX3Byb3BzJHNlcGFyYXRvciA9IHByb3BzLnNlcGFyYXRvcixcclxuICAgIHNlcGFyYXRvciA9IF9wcm9wcyRzZXBhcmF0b3IgPT09IHZvaWQgMCA/ICcgOiAnIDogX3Byb3BzJHNlcGFyYXRvcixcclxuICAgIF9wcm9wcyRjb250ZW50U3R5bGUgPSBwcm9wcy5jb250ZW50U3R5bGUsXHJcbiAgICBjb250ZW50U3R5bGUgPSBfcHJvcHMkY29udGVudFN0eWxlID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyRjb250ZW50U3R5bGUsXHJcbiAgICBfcHJvcHMkaXRlbVN0eWxlID0gcHJvcHMuaXRlbVN0eWxlLFxyXG4gICAgaXRlbVN0eWxlID0gX3Byb3BzJGl0ZW1TdHlsZSA9PT0gdm9pZCAwID8ge30gOiBfcHJvcHMkaXRlbVN0eWxlLFxyXG4gICAgX3Byb3BzJGxhYmVsU3R5bGUgPSBwcm9wcy5sYWJlbFN0eWxlLFxyXG4gICAgbGFiZWxTdHlsZSA9IF9wcm9wcyRsYWJlbFN0eWxlID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyRsYWJlbFN0eWxlLFxyXG4gICAgcGF5bG9hZCA9IHByb3BzLnBheWxvYWQsXHJcbiAgICBmb3JtYXR0ZXIgPSBwcm9wcy5mb3JtYXR0ZXIsXHJcbiAgICBpdGVtU29ydGVyID0gcHJvcHMuaXRlbVNvcnRlcixcclxuICAgIHdyYXBwZXJDbGFzc05hbWUgPSBwcm9wcy53cmFwcGVyQ2xhc3NOYW1lLFxyXG4gICAgbGFiZWxDbGFzc05hbWUgPSBwcm9wcy5sYWJlbENsYXNzTmFtZSxcclxuICAgIGxhYmVsID0gcHJvcHMubGFiZWwsXHJcbiAgICBsYWJlbEZvcm1hdHRlciA9IHByb3BzLmxhYmVsRm9ybWF0dGVyLFxyXG4gICAgX3Byb3BzJGFjY2Vzc2liaWxpdHlMID0gcHJvcHMuYWNjZXNzaWJpbGl0eUxheWVyLFxyXG4gICAgYWNjZXNzaWJpbGl0eUxheWVyID0gX3Byb3BzJGFjY2Vzc2liaWxpdHlMID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRhY2Nlc3NpYmlsaXR5TDtcclxuICB2YXIgcmVuZGVyQ29udGVudCA9IGZ1bmN0aW9uIHJlbmRlckNvbnRlbnQoKSB7XHJcbiAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLmxlbmd0aCkge1xyXG4gICAgICB2YXIgbGlzdFN0eWxlID0ge1xyXG4gICAgICAgIHBhZGRpbmc6IDAsXHJcbiAgICAgICAgbWFyZ2luOiAwXHJcbiAgICAgIH07XHJcbiAgICAgIHZhciBpdGVtcyA9IChpdGVtU29ydGVyID8gKDAsIF9zb3J0QnlbXCJkZWZhdWx0XCJdKShwYXlsb2FkLCBpdGVtU29ydGVyKSA6IHBheWxvYWQpLm1hcChmdW5jdGlvbiAoZW50cnksIGkpIHtcclxuICAgICAgICBpZiAoZW50cnkudHlwZSA9PT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGZpbmFsSXRlbVN0eWxlID0gX29iamVjdFNwcmVhZCh7XHJcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxyXG4gICAgICAgICAgcGFkZGluZ1RvcDogNCxcclxuICAgICAgICAgIHBhZGRpbmdCb3R0b206IDQsXHJcbiAgICAgICAgICBjb2xvcjogZW50cnkuY29sb3IgfHwgJyMwMDAnXHJcbiAgICAgICAgfSwgaXRlbVN0eWxlKTtcclxuICAgICAgICB2YXIgZmluYWxGb3JtYXR0ZXIgPSBlbnRyeS5mb3JtYXR0ZXIgfHwgZm9ybWF0dGVyIHx8IGRlZmF1bHRGb3JtYXR0ZXI7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gZW50cnkudmFsdWUsXHJcbiAgICAgICAgICBuYW1lID0gZW50cnkubmFtZTtcclxuICAgICAgICB2YXIgZmluYWxWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHZhciBmaW5hbE5hbWUgPSBuYW1lO1xyXG4gICAgICAgIGlmIChmaW5hbEZvcm1hdHRlciAmJiBmaW5hbFZhbHVlICE9IG51bGwgJiYgZmluYWxOYW1lICE9IG51bGwpIHtcclxuICAgICAgICAgIHZhciBmb3JtYXR0ZWQgPSBmaW5hbEZvcm1hdHRlcih2YWx1ZSwgbmFtZSwgZW50cnksIGksIHBheWxvYWQpO1xyXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZm9ybWF0dGVkKSkge1xyXG4gICAgICAgICAgICB2YXIgX2Zvcm1hdHRlZCA9IF9zbGljZWRUb0FycmF5KGZvcm1hdHRlZCwgMik7XHJcbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBfZm9ybWF0dGVkWzBdO1xyXG4gICAgICAgICAgICBmaW5hbE5hbWUgPSBfZm9ybWF0dGVkWzFdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZmluYWxWYWx1ZSA9IGZvcm1hdHRlZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgIC8qI19fUFVSRV9fKi9cclxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1hcnJheS1pbmRleC1rZXlcclxuICAgICAgICAgIF9yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImxpXCIsIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXRvb2x0aXAtaXRlbVwiLFxyXG4gICAgICAgICAgICBrZXk6IFwidG9vbHRpcC1pdGVtLVwiLmNvbmNhdChpKSxcclxuICAgICAgICAgICAgc3R5bGU6IGZpbmFsSXRlbVN0eWxlXHJcbiAgICAgICAgICB9LCAoMCwgX0RhdGFVdGlscy5pc051bU9yU3RyKShmaW5hbE5hbWUpID8gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xyXG4gICAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtdG9vbHRpcC1pdGVtLW5hbWVcIlxyXG4gICAgICAgICAgfSwgZmluYWxOYW1lKSA6IG51bGwsICgwLCBfRGF0YVV0aWxzLmlzTnVtT3JTdHIpKGZpbmFsTmFtZSkgPyAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy10b29sdGlwLWl0ZW0tc2VwYXJhdG9yXCJcclxuICAgICAgICAgIH0sIHNlcGFyYXRvcikgOiBudWxsLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy10b29sdGlwLWl0ZW0tdmFsdWVcIlxyXG4gICAgICAgICAgfSwgZmluYWxWYWx1ZSksIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXRvb2x0aXAtaXRlbS11bml0XCJcclxuICAgICAgICAgIH0sIGVudHJ5LnVuaXQgfHwgJycpKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInVsXCIsIHtcclxuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtdG9vbHRpcC1pdGVtLWxpc3RcIixcclxuICAgICAgICBzdHlsZTogbGlzdFN0eWxlXHJcbiAgICAgIH0sIGl0ZW1zKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH07XHJcbiAgdmFyIGZpbmFsU3R5bGUgPSBfb2JqZWN0U3ByZWFkKHtcclxuICAgIG1hcmdpbjogMCxcclxuICAgIHBhZGRpbmc6IDEwLFxyXG4gICAgYmFja2dyb3VuZENvbG9yOiAnI2ZmZicsXHJcbiAgICBib3JkZXI6ICcxcHggc29saWQgI2NjYycsXHJcbiAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJ1xyXG4gIH0sIGNvbnRlbnRTdHlsZSk7XHJcbiAgdmFyIGZpbmFsTGFiZWxTdHlsZSA9IF9vYmplY3RTcHJlYWQoe1xyXG4gICAgbWFyZ2luOiAwXHJcbiAgfSwgbGFiZWxTdHlsZSk7XHJcbiAgdmFyIGhhc0xhYmVsID0gISgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShsYWJlbCk7XHJcbiAgdmFyIGZpbmFsTGFiZWwgPSBoYXNMYWJlbCA/IGxhYmVsIDogJyc7XHJcbiAgdmFyIHdyYXBwZXJDTiA9ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1kZWZhdWx0LXRvb2x0aXAnLCB3cmFwcGVyQ2xhc3NOYW1lKTtcclxuICB2YXIgbGFiZWxDTiA9ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy10b29sdGlwLWxhYmVsJywgbGFiZWxDbGFzc05hbWUpO1xyXG4gIGlmIChoYXNMYWJlbCAmJiBsYWJlbEZvcm1hdHRlciAmJiBwYXlsb2FkICE9PSB1bmRlZmluZWQgJiYgcGF5bG9hZCAhPT0gbnVsbCkge1xyXG4gICAgZmluYWxMYWJlbCA9IGxhYmVsRm9ybWF0dGVyKGxhYmVsLCBwYXlsb2FkKTtcclxuICB9XHJcbiAgdmFyIGFjY2Vzc2liaWxpdHlBdHRyaWJ1dGVzID0gYWNjZXNzaWJpbGl0eUxheWVyID8ge1xyXG4gICAgcm9sZTogJ3N0YXR1cycsXHJcbiAgICAnYXJpYS1saXZlJzogJ2Fzc2VydGl2ZSdcclxuICB9IDoge307XHJcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xyXG4gICAgY2xhc3NOYW1lOiB3cmFwcGVyQ04sXHJcbiAgICBzdHlsZTogZmluYWxTdHlsZVxyXG4gIH0sIGFjY2Vzc2liaWxpdHlBdHRyaWJ1dGVzKSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInBcIiwge1xyXG4gICAgY2xhc3NOYW1lOiBsYWJlbENOLFxyXG4gICAgc3R5bGU6IGZpbmFsTGFiZWxTdHlsZVxyXG4gIH0sIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KGZpbmFsTGFiZWwpID8gZmluYWxMYWJlbCA6IFwiXCIuY29uY2F0KGZpbmFsTGFiZWwpKSwgcmVuZGVyQ29udGVudCgpKTtcclxufTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJEZWZhdWx0VG9vbHRpcENvbnRlbnQiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9zb3J0QnkiLCJfaXNOaWwiLCJfY2xzeCIsIl9EYXRhVXRpbHMiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIlR5cGVFcnJvciIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwibiIsInRvU3RyaW5nIiwic2xpY2UiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsImxlbiIsImFycjIiLCJyIiwibCIsInQiLCJlIiwidSIsImEiLCJmIiwibmV4dCIsImRvbmUiLCJwdXNoIiwiaXNBcnJheSIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJkZWZhdWx0Rm9ybWF0dGVyIiwiaXNOdW1PclN0ciIsImpvaW4iLCJwcm9wcyIsIl9wcm9wcyRzZXBhcmF0b3IiLCJzZXBhcmF0b3IiLCJfcHJvcHMkY29udGVudFN0eWxlIiwiY29udGVudFN0eWxlIiwiX3Byb3BzJGl0ZW1TdHlsZSIsIml0ZW1TdHlsZSIsIl9wcm9wcyRsYWJlbFN0eWxlIiwibGFiZWxTdHlsZSIsInBheWxvYWQiLCJmb3JtYXR0ZXIiLCJpdGVtU29ydGVyIiwid3JhcHBlckNsYXNzTmFtZSIsImxhYmVsQ2xhc3NOYW1lIiwibGFiZWwiLCJsYWJlbEZvcm1hdHRlciIsIl9wcm9wcyRhY2Nlc3NpYmlsaXR5TCIsImFjY2Vzc2liaWxpdHlMYXllciIsInJlbmRlckNvbnRlbnQiLCJsaXN0U3R5bGUiLCJwYWRkaW5nIiwibWFyZ2luIiwiaXRlbXMiLCJtYXAiLCJlbnRyeSIsInR5cGUiLCJmaW5hbEl0ZW1TdHlsZSIsImRpc3BsYXkiLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsImNvbG9yIiwiZmluYWxGb3JtYXR0ZXIiLCJmaW5hbFZhbHVlIiwiZmluYWxOYW1lIiwiZm9ybWF0dGVkIiwiX2Zvcm1hdHRlZCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJjb25jYXQiLCJzdHlsZSIsInVuaXQiLCJmaW5hbFN0eWxlIiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyIiwid2hpdGVTcGFjZSIsImZpbmFsTGFiZWxTdHlsZSIsImhhc0xhYmVsIiwiZmluYWxMYWJlbCIsIndyYXBwZXJDTiIsImxhYmVsQ04iLCJ1bmRlZmluZWQiLCJhY2Nlc3NpYmlsaXR5QXR0cmlidXRlcyIsInJvbGUiLCJpc1ZhbGlkRWxlbWVudCJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/component/DefaultTooltipContent.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/component/Label.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/component/Label.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Label = Label;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _isObject = _interopRequireDefault(__webpack_require__(/*! lodash/isObject */ \"lodash/isObject\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _Text = __webpack_require__(/*! ./Text */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Text.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _excluded = [\n    \"offset\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nvar getLabel = function getLabel(props) {\n    var value = props.value, formatter = props.formatter;\n    var label = (0, _isNil[\"default\"])(props.children) ? value : props.children;\n    if ((0, _isFunction[\"default\"])(formatter)) {\n        return formatter(label);\n    }\n    return label;\n};\nvar getDeltaAngle = function getDeltaAngle(startAngle, endAngle) {\n    var sign = (0, _DataUtils.mathSign)(endAngle - startAngle);\n    var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);\n    return sign * deltaAngle;\n};\nvar renderRadialLabel = function renderRadialLabel(labelProps, label, attrs) {\n    var position = labelProps.position, viewBox = labelProps.viewBox, offset = labelProps.offset, className = labelProps.className;\n    var _ref = viewBox, cx = _ref.cx, cy = _ref.cy, innerRadius = _ref.innerRadius, outerRadius = _ref.outerRadius, startAngle = _ref.startAngle, endAngle = _ref.endAngle, clockWise = _ref.clockWise;\n    var radius = (innerRadius + outerRadius) / 2;\n    var deltaAngle = getDeltaAngle(startAngle, endAngle);\n    var sign = deltaAngle >= 0 ? 1 : -1;\n    var labelAngle, direction;\n    if (position === 'insideStart') {\n        labelAngle = startAngle + sign * offset;\n        direction = clockWise;\n    } else if (position === 'insideEnd') {\n        labelAngle = endAngle - sign * offset;\n        direction = !clockWise;\n    } else if (position === 'end') {\n        labelAngle = endAngle + sign * offset;\n        direction = clockWise;\n    }\n    direction = deltaAngle <= 0 ? direction : !direction;\n    var startPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, radius, labelAngle);\n    var endPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, radius, labelAngle + (direction ? 1 : -1) * 359);\n    var path = \"M\".concat(startPoint.x, \",\").concat(startPoint.y, \"\\n    A\").concat(radius, \",\").concat(radius, \",0,1,\").concat(direction ? 0 : 1, \",\\n    \").concat(endPoint.x, \",\").concat(endPoint.y);\n    var id = (0, _isNil[\"default\"])(labelProps.id) ? (0, _DataUtils.uniqueId)('recharts-radial-line-') : labelProps.id;\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"text\", _extends({}, attrs, {\n        dominantBaseline: \"central\",\n        className: (0, _clsx[\"default\"])('recharts-radial-bar-label', className)\n    }), /*#__PURE__*/ _react[\"default\"].createElement(\"defs\", null, /*#__PURE__*/ _react[\"default\"].createElement(\"path\", {\n        id: id,\n        d: path\n    })), /*#__PURE__*/ _react[\"default\"].createElement(\"textPath\", {\n        xlinkHref: \"#\".concat(id)\n    }, label));\n};\nvar getAttrsOfPolarLabel = function getAttrsOfPolarLabel(props) {\n    var viewBox = props.viewBox, offset = props.offset, position = props.position;\n    var _ref2 = viewBox, cx = _ref2.cx, cy = _ref2.cy, innerRadius = _ref2.innerRadius, outerRadius = _ref2.outerRadius, startAngle = _ref2.startAngle, endAngle = _ref2.endAngle;\n    var midAngle = (startAngle + endAngle) / 2;\n    if (position === 'outside') {\n        var _polarToCartesian = (0, _PolarUtils.polarToCartesian)(cx, cy, outerRadius + offset, midAngle), _x = _polarToCartesian.x, _y = _polarToCartesian.y;\n        return {\n            x: _x,\n            y: _y,\n            textAnchor: _x >= cx ? 'start' : 'end',\n            verticalAnchor: 'middle'\n        };\n    }\n    if (position === 'center') {\n        return {\n            x: cx,\n            y: cy,\n            textAnchor: 'middle',\n            verticalAnchor: 'middle'\n        };\n    }\n    if (position === 'centerTop') {\n        return {\n            x: cx,\n            y: cy,\n            textAnchor: 'middle',\n            verticalAnchor: 'start'\n        };\n    }\n    if (position === 'centerBottom') {\n        return {\n            x: cx,\n            y: cy,\n            textAnchor: 'middle',\n            verticalAnchor: 'end'\n        };\n    }\n    var r = (innerRadius + outerRadius) / 2;\n    var _polarToCartesian2 = (0, _PolarUtils.polarToCartesian)(cx, cy, r, midAngle), x = _polarToCartesian2.x, y = _polarToCartesian2.y;\n    return {\n        x: x,\n        y: y,\n        textAnchor: 'middle',\n        verticalAnchor: 'middle'\n    };\n};\nvar getAttrsOfCartesianLabel = function getAttrsOfCartesianLabel(props) {\n    var viewBox = props.viewBox, parentViewBox = props.parentViewBox, offset = props.offset, position = props.position;\n    var _ref3 = viewBox, x = _ref3.x, y = _ref3.y, width = _ref3.width, height = _ref3.height;\n    // Define vertical offsets and position inverts based on the value being positive or negative\n    var verticalSign = height >= 0 ? 1 : -1;\n    var verticalOffset = verticalSign * offset;\n    var verticalEnd = verticalSign > 0 ? 'end' : 'start';\n    var verticalStart = verticalSign > 0 ? 'start' : 'end';\n    // Define horizontal offsets and position inverts based on the value being positive or negative\n    var horizontalSign = width >= 0 ? 1 : -1;\n    var horizontalOffset = horizontalSign * offset;\n    var horizontalEnd = horizontalSign > 0 ? 'end' : 'start';\n    var horizontalStart = horizontalSign > 0 ? 'start' : 'end';\n    if (position === 'top') {\n        var attrs = {\n            x: x + width / 2,\n            y: y - verticalSign * offset,\n            textAnchor: 'middle',\n            verticalAnchor: verticalEnd\n        };\n        return _objectSpread(_objectSpread({}, attrs), parentViewBox ? {\n            height: Math.max(y - parentViewBox.y, 0),\n            width: width\n        } : {});\n    }\n    if (position === 'bottom') {\n        var _attrs = {\n            x: x + width / 2,\n            y: y + height + verticalOffset,\n            textAnchor: 'middle',\n            verticalAnchor: verticalStart\n        };\n        return _objectSpread(_objectSpread({}, _attrs), parentViewBox ? {\n            height: Math.max(parentViewBox.y + parentViewBox.height - (y + height), 0),\n            width: width\n        } : {});\n    }\n    if (position === 'left') {\n        var _attrs2 = {\n            x: x - horizontalOffset,\n            y: y + height / 2,\n            textAnchor: horizontalEnd,\n            verticalAnchor: 'middle'\n        };\n        return _objectSpread(_objectSpread({}, _attrs2), parentViewBox ? {\n            width: Math.max(_attrs2.x - parentViewBox.x, 0),\n            height: height\n        } : {});\n    }\n    if (position === 'right') {\n        var _attrs3 = {\n            x: x + width + horizontalOffset,\n            y: y + height / 2,\n            textAnchor: horizontalStart,\n            verticalAnchor: 'middle'\n        };\n        return _objectSpread(_objectSpread({}, _attrs3), parentViewBox ? {\n            width: Math.max(parentViewBox.x + parentViewBox.width - _attrs3.x, 0),\n            height: height\n        } : {});\n    }\n    var sizeAttrs = parentViewBox ? {\n        width: width,\n        height: height\n    } : {};\n    if (position === 'insideLeft') {\n        return _objectSpread({\n            x: x + horizontalOffset,\n            y: y + height / 2,\n            textAnchor: horizontalStart,\n            verticalAnchor: 'middle'\n        }, sizeAttrs);\n    }\n    if (position === 'insideRight') {\n        return _objectSpread({\n            x: x + width - horizontalOffset,\n            y: y + height / 2,\n            textAnchor: horizontalEnd,\n            verticalAnchor: 'middle'\n        }, sizeAttrs);\n    }\n    if (position === 'insideTop') {\n        return _objectSpread({\n            x: x + width / 2,\n            y: y + verticalOffset,\n            textAnchor: 'middle',\n            verticalAnchor: verticalStart\n        }, sizeAttrs);\n    }\n    if (position === 'insideBottom') {\n        return _objectSpread({\n            x: x + width / 2,\n            y: y + height - verticalOffset,\n            textAnchor: 'middle',\n            verticalAnchor: verticalEnd\n        }, sizeAttrs);\n    }\n    if (position === 'insideTopLeft') {\n        return _objectSpread({\n            x: x + horizontalOffset,\n            y: y + verticalOffset,\n            textAnchor: horizontalStart,\n            verticalAnchor: verticalStart\n        }, sizeAttrs);\n    }\n    if (position === 'insideTopRight') {\n        return _objectSpread({\n            x: x + width - horizontalOffset,\n            y: y + verticalOffset,\n            textAnchor: horizontalEnd,\n            verticalAnchor: verticalStart\n        }, sizeAttrs);\n    }\n    if (position === 'insideBottomLeft') {\n        return _objectSpread({\n            x: x + horizontalOffset,\n            y: y + height - verticalOffset,\n            textAnchor: horizontalStart,\n            verticalAnchor: verticalEnd\n        }, sizeAttrs);\n    }\n    if (position === 'insideBottomRight') {\n        return _objectSpread({\n            x: x + width - horizontalOffset,\n            y: y + height - verticalOffset,\n            textAnchor: horizontalEnd,\n            verticalAnchor: verticalEnd\n        }, sizeAttrs);\n    }\n    if ((0, _isObject[\"default\"])(position) && ((0, _DataUtils.isNumber)(position.x) || (0, _DataUtils.isPercent)(position.x)) && ((0, _DataUtils.isNumber)(position.y) || (0, _DataUtils.isPercent)(position.y))) {\n        return _objectSpread({\n            x: x + (0, _DataUtils.getPercentValue)(position.x, width),\n            y: y + (0, _DataUtils.getPercentValue)(position.y, height),\n            textAnchor: 'end',\n            verticalAnchor: 'end'\n        }, sizeAttrs);\n    }\n    return _objectSpread({\n        x: x + width / 2,\n        y: y + height / 2,\n        textAnchor: 'middle',\n        verticalAnchor: 'middle'\n    }, sizeAttrs);\n};\nvar isPolar = function isPolar(viewBox) {\n    return 'cx' in viewBox && (0, _DataUtils.isNumber)(viewBox.cx);\n};\nfunction Label(_ref4) {\n    var _ref4$offset = _ref4.offset, offset = _ref4$offset === void 0 ? 5 : _ref4$offset, restProps = _objectWithoutProperties(_ref4, _excluded);\n    var props = _objectSpread({\n        offset: offset\n    }, restProps);\n    var viewBox = props.viewBox, position = props.position, value = props.value, children = props.children, content = props.content, _props$className = props.className, className = _props$className === void 0 ? '' : _props$className, textBreakAll = props.textBreakAll;\n    if (!viewBox || (0, _isNil[\"default\"])(value) && (0, _isNil[\"default\"])(children) && !/*#__PURE__*/ (0, _react.isValidElement)(content) && !(0, _isFunction[\"default\"])(content)) {\n        return null;\n    }\n    if (/*#__PURE__*/ (0, _react.isValidElement)(content)) {\n        return /*#__PURE__*/ (0, _react.cloneElement)(content, props);\n    }\n    var label;\n    if ((0, _isFunction[\"default\"])(content)) {\n        label = /*#__PURE__*/ (0, _react.createElement)(content, props);\n        if (/*#__PURE__*/ (0, _react.isValidElement)(label)) {\n            return label;\n        }\n    } else {\n        label = getLabel(props);\n    }\n    var isPolarLabel = isPolar(viewBox);\n    var attrs = (0, _ReactUtils.filterProps)(props, true);\n    if (isPolarLabel && (position === 'insideStart' || position === 'insideEnd' || position === 'end')) {\n        return renderRadialLabel(props, label, attrs);\n    }\n    var positionAttrs = isPolarLabel ? getAttrsOfPolarLabel(props) : getAttrsOfCartesianLabel(props);\n    return /*#__PURE__*/ _react[\"default\"].createElement(_Text.Text, _extends({\n        className: (0, _clsx[\"default\"])('recharts-label', className)\n    }, attrs, positionAttrs, {\n        breakAll: textBreakAll\n    }), label);\n}\nLabel.displayName = 'Label';\nvar parseViewBox = function parseViewBox(props) {\n    var cx = props.cx, cy = props.cy, angle = props.angle, startAngle = props.startAngle, endAngle = props.endAngle, r = props.r, radius = props.radius, innerRadius = props.innerRadius, outerRadius = props.outerRadius, x = props.x, y = props.y, top = props.top, left = props.left, width = props.width, height = props.height, clockWise = props.clockWise, labelViewBox = props.labelViewBox;\n    if (labelViewBox) {\n        return labelViewBox;\n    }\n    if ((0, _DataUtils.isNumber)(width) && (0, _DataUtils.isNumber)(height)) {\n        if ((0, _DataUtils.isNumber)(x) && (0, _DataUtils.isNumber)(y)) {\n            return {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            };\n        }\n        if ((0, _DataUtils.isNumber)(top) && (0, _DataUtils.isNumber)(left)) {\n            return {\n                x: top,\n                y: left,\n                width: width,\n                height: height\n            };\n        }\n    }\n    if ((0, _DataUtils.isNumber)(x) && (0, _DataUtils.isNumber)(y)) {\n        return {\n            x: x,\n            y: y,\n            width: 0,\n            height: 0\n        };\n    }\n    if ((0, _DataUtils.isNumber)(cx) && (0, _DataUtils.isNumber)(cy)) {\n        return {\n            cx: cx,\n            cy: cy,\n            startAngle: startAngle || angle || 0,\n            endAngle: endAngle || angle || 0,\n            innerRadius: innerRadius || 0,\n            outerRadius: outerRadius || radius || r || 0,\n            clockWise: clockWise\n        };\n    }\n    if (props.viewBox) {\n        return props.viewBox;\n    }\n    return {};\n};\nvar parseLabel = function parseLabel(label, viewBox) {\n    if (!label) {\n        return null;\n    }\n    if (label === true) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(Label, {\n            key: \"label-implicit\",\n            viewBox: viewBox\n        });\n    }\n    if ((0, _DataUtils.isNumOrStr)(label)) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(Label, {\n            key: \"label-implicit\",\n            viewBox: viewBox,\n            value: label\n        });\n    }\n    if (/*#__PURE__*/ (0, _react.isValidElement)(label)) {\n        if (label.type === Label) {\n            return /*#__PURE__*/ (0, _react.cloneElement)(label, {\n                key: 'label-implicit',\n                viewBox: viewBox\n            });\n        }\n        return /*#__PURE__*/ _react[\"default\"].createElement(Label, {\n            key: \"label-implicit\",\n            content: label,\n            viewBox: viewBox\n        });\n    }\n    if ((0, _isFunction[\"default\"])(label)) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(Label, {\n            key: \"label-implicit\",\n            content: label,\n            viewBox: viewBox\n        });\n    }\n    if ((0, _isObject[\"default\"])(label)) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(Label, _extends({\n            viewBox: viewBox\n        }, label, {\n            key: \"label-implicit\"\n        }));\n    }\n    return null;\n};\nvar renderCallByParent = function renderCallByParent(parentProps, viewBox) {\n    var checkPropsLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (!parentProps || !parentProps.children && checkPropsLabel && !parentProps.label) {\n        return null;\n    }\n    var children = parentProps.children;\n    var parentViewBox = parseViewBox(parentProps);\n    var explicitChildren = (0, _ReactUtils.findAllByType)(children, Label).map(function(child, index) {\n        return /*#__PURE__*/ (0, _react.cloneElement)(child, {\n            viewBox: viewBox || parentViewBox,\n            // eslint-disable-next-line react/no-array-index-key\n            key: \"label-\".concat(index)\n        });\n    });\n    if (!checkPropsLabel) {\n        return explicitChildren;\n    }\n    var implicitLabel = parseLabel(parentProps.label, viewBox || parentViewBox);\n    return [\n        implicitLabel\n    ].concat(_toConsumableArray(explicitChildren));\n};\nLabel.parseViewBox = parseViewBox;\nLabel.renderCallByParent = renderCallByParent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY29tcG9uZW50L0xhYmVsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUUsV0FBVyxLQUFLQyxVQUFVRCxNQUFNQyxPQUFPRSxTQUFTLEdBQUcsV0FBVyxPQUFPSDtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1RJLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxhQUFhLEdBQUdFO0FBQ2hCLElBQUlDLFNBQVNDLHdCQUF3QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUMsU0FBU0MsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJRyxjQUFjRCx1QkFBdUJGLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJSSxZQUFZRix1QkFBdUJGLG1CQUFPQSxDQUFDLHdDQUFpQjtBQUNoRSxJQUFJSyxRQUFRSCx1QkFBdUJGLG1CQUFPQSxDQUFDLHVCQUFNO0FBQ2pELElBQUlNLFFBQVFOLG1CQUFPQSxDQUFDLDhFQUFRO0FBQzVCLElBQUlPLGNBQWNQLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM5QyxJQUFJUSxhQUFhUixtQkFBT0EsQ0FBQyx5RkFBbUI7QUFDNUMsSUFBSVMsY0FBY1QsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlVLFlBQVk7SUFBQztDQUFTO0FBQzFCLFNBQVNSLHVCQUF1QlMsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSx5QkFBeUJDLENBQUM7SUFBSSxJQUFJLGNBQWMsT0FBT0MsU0FBUyxPQUFPO0lBQU0sSUFBSUMsSUFBSSxJQUFJRCxXQUFXRSxJQUFJLElBQUlGO0lBQVcsT0FBTyxDQUFDRiwyQkFBMkIsU0FBU0EseUJBQXlCQyxDQUFDO1FBQUksT0FBT0EsSUFBSUcsSUFBSUQ7SUFBRyxHQUFHRjtBQUFJO0FBQ25PLFNBQVNmLHdCQUF3QmUsQ0FBQyxFQUFFRSxDQUFDO0lBQUksSUFBSSxDQUFDQSxLQUFLRixLQUFLQSxFQUFFRixVQUFVLEVBQUUsT0FBT0U7SUFBRyxJQUFJLFNBQVNBLEtBQUssWUFBWTFCLFFBQVEwQixNQUFNLGNBQWMsT0FBT0EsR0FBRyxPQUFPO1FBQUUsV0FBV0E7SUFBRTtJQUFHLElBQUlHLElBQUlKLHlCQUF5Qkc7SUFBSSxJQUFJQyxLQUFLQSxFQUFFQyxHQUFHLENBQUNKLElBQUksT0FBT0csRUFBRUUsR0FBRyxDQUFDTDtJQUFJLElBQUlNLElBQUk7UUFBRUMsV0FBVztJQUFLLEdBQUdDLElBQUk3QixPQUFPQyxjQUFjLElBQUlELE9BQU84Qix3QkFBd0I7SUFBRSxJQUFLLElBQUlDLEtBQUtWLEVBQUcsSUFBSSxjQUFjVSxLQUFLLEVBQUMsR0FBRUMsY0FBYyxDQUFDQyxJQUFJLENBQUNaLEdBQUdVLElBQUk7UUFBRSxJQUFJRyxJQUFJTCxJQUFJN0IsT0FBTzhCLHdCQUF3QixDQUFDVCxHQUFHVSxLQUFLO1FBQU1HLEtBQU1BLENBQUFBLEVBQUVSLEdBQUcsSUFBSVEsRUFBRUMsR0FBRyxJQUFJbkMsT0FBT0MsY0FBYyxDQUFDMEIsR0FBR0ksR0FBR0csS0FBS1AsQ0FBQyxDQUFDSSxFQUFFLEdBQUdWLENBQUMsQ0FBQ1UsRUFBRTtJQUFFO0lBQUUsT0FBT0osQ0FBQyxDQUFDLFVBQVUsR0FBR04sR0FBR0csS0FBS0EsRUFBRVcsR0FBRyxDQUFDZCxHQUFHTSxJQUFJQTtBQUFHO0FBQ3prQixTQUFTUyxtQkFBbUJDLEdBQUc7SUFBSSxPQUFPQyxtQkFBbUJELFFBQVFFLGlCQUFpQkYsUUFBUUcsNEJBQTRCSCxRQUFRSTtBQUFzQjtBQUN4SixTQUFTQTtJQUF1QixNQUFNLElBQUlDLFVBQVU7QUFBeUk7QUFDN0wsU0FBU0YsNEJBQTRCNUMsQ0FBQyxFQUFFK0MsTUFBTTtJQUFJLElBQUksQ0FBQy9DLEdBQUc7SUFBUSxJQUFJLE9BQU9BLE1BQU0sVUFBVSxPQUFPZ0Qsa0JBQWtCaEQsR0FBRytDO0lBQVMsSUFBSWhCLElBQUkzQixPQUFPRCxTQUFTLENBQUM4QyxRQUFRLENBQUNaLElBQUksQ0FBQ3JDLEdBQUdrRCxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQUksSUFBSW5CLE1BQU0sWUFBWS9CLEVBQUUsV0FBVyxFQUFFK0IsSUFBSS9CLEVBQUUsV0FBVyxDQUFDbUQsSUFBSTtJQUFFLElBQUlwQixNQUFNLFNBQVNBLE1BQU0sT0FBTyxPQUFPcUIsTUFBTUMsSUFBSSxDQUFDckQ7SUFBSSxJQUFJK0IsTUFBTSxlQUFlLDJDQUEyQ3VCLElBQUksQ0FBQ3ZCLElBQUksT0FBT2lCLGtCQUFrQmhELEdBQUcrQztBQUFTO0FBQy9aLFNBQVNKLGlCQUFpQlksSUFBSTtJQUFJLElBQUksT0FBT3RELFdBQVcsZUFBZXNELElBQUksQ0FBQ3RELE9BQU9DLFFBQVEsQ0FBQyxJQUFJLFFBQVFxRCxJQUFJLENBQUMsYUFBYSxJQUFJLE1BQU0sT0FBT0gsTUFBTUMsSUFBSSxDQUFDRTtBQUFPO0FBQzdKLFNBQVNiLG1CQUFtQkQsR0FBRztJQUFJLElBQUlXLE1BQU1JLE9BQU8sQ0FBQ2YsTUFBTSxPQUFPTyxrQkFBa0JQO0FBQU07QUFDMUYsU0FBU08sa0JBQWtCUCxHQUFHLEVBQUVnQixHQUFHO0lBQUksSUFBSUEsT0FBTyxRQUFRQSxNQUFNaEIsSUFBSWlCLE1BQU0sRUFBRUQsTUFBTWhCLElBQUlpQixNQUFNO0lBQUUsSUFBSyxJQUFJcEIsSUFBSSxHQUFHcUIsT0FBTyxJQUFJUCxNQUFNSyxNQUFNbkIsSUFBSW1CLEtBQUtuQixJQUFLcUIsSUFBSSxDQUFDckIsRUFBRSxHQUFHRyxHQUFHLENBQUNILEVBQUU7SUFBRSxPQUFPcUI7QUFBTTtBQUNsTCxTQUFTQyx5QkFBeUJDLE1BQU0sRUFBRUMsUUFBUTtJQUFJLElBQUlELFVBQVUsTUFBTSxPQUFPLENBQUM7SUFBRyxJQUFJRSxTQUFTQyw4QkFBOEJILFFBQVFDO0lBQVcsSUFBSUcsS0FBSzNCO0lBQUcsSUFBSWxDLE9BQU84RCxxQkFBcUIsRUFBRTtRQUFFLElBQUlDLG1CQUFtQi9ELE9BQU84RCxxQkFBcUIsQ0FBQ0w7UUFBUyxJQUFLdkIsSUFBSSxHQUFHQSxJQUFJNkIsaUJBQWlCVCxNQUFNLEVBQUVwQixJQUFLO1lBQUUyQixNQUFNRSxnQkFBZ0IsQ0FBQzdCLEVBQUU7WUFBRSxJQUFJd0IsU0FBU00sT0FBTyxDQUFDSCxRQUFRLEdBQUc7WUFBVSxJQUFJLENBQUM3RCxPQUFPRCxTQUFTLENBQUNrRSxvQkFBb0IsQ0FBQ2hDLElBQUksQ0FBQ3dCLFFBQVFJLE1BQU07WUFBVUYsTUFBTSxDQUFDRSxJQUFJLEdBQUdKLE1BQU0sQ0FBQ0ksSUFBSTtRQUFFO0lBQUU7SUFBRSxPQUFPRjtBQUFRO0FBQzNlLFNBQVNDLDhCQUE4QkgsTUFBTSxFQUFFQyxRQUFRO0lBQUksSUFBSUQsVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUFHLElBQUlFLFNBQVMsQ0FBQztJQUFHLElBQUssSUFBSUUsT0FBT0osT0FBUTtRQUFFLElBQUl6RCxPQUFPRCxTQUFTLENBQUNpQyxjQUFjLENBQUNDLElBQUksQ0FBQ3dCLFFBQVFJLE1BQU07WUFBRSxJQUFJSCxTQUFTTSxPQUFPLENBQUNILFFBQVEsR0FBRztZQUFVRixNQUFNLENBQUNFLElBQUksR0FBR0osTUFBTSxDQUFDSSxJQUFJO1FBQUU7SUFBRTtJQUFFLE9BQU9GO0FBQVE7QUFDdFIsU0FBU08sUUFBUTdDLENBQUMsRUFBRUUsQ0FBQztJQUFJLElBQUlDLElBQUl4QixPQUFPbUUsSUFBSSxDQUFDOUM7SUFBSSxJQUFJckIsT0FBTzhELHFCQUFxQixFQUFFO1FBQUUsSUFBSWxFLElBQUlJLE9BQU84RCxxQkFBcUIsQ0FBQ3pDO1FBQUlFLEtBQU0zQixDQUFBQSxJQUFJQSxFQUFFd0UsTUFBTSxDQUFDLFNBQVU3QyxDQUFDO1lBQUksT0FBT3ZCLE9BQU84Qix3QkFBd0IsQ0FBQ1QsR0FBR0UsR0FBRzhDLFVBQVU7UUFBRSxFQUFDLEdBQUk3QyxFQUFFOEMsSUFBSSxDQUFDQyxLQUFLLENBQUMvQyxHQUFHNUI7SUFBSTtJQUFFLE9BQU80QjtBQUFHO0FBQzlQLFNBQVNnRCxjQUFjbkQsQ0FBQztJQUFJLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJa0QsVUFBVW5CLE1BQU0sRUFBRS9CLElBQUs7UUFBRSxJQUFJQyxJQUFJLFFBQVFpRCxTQUFTLENBQUNsRCxFQUFFLEdBQUdrRCxTQUFTLENBQUNsRCxFQUFFLEdBQUcsQ0FBQztRQUFHQSxJQUFJLElBQUkyQyxRQUFRbEUsT0FBT3dCLElBQUksQ0FBQyxHQUFHa0QsT0FBTyxDQUFDLFNBQVVuRCxDQUFDO1lBQUlvRCxnQkFBZ0J0RCxHQUFHRSxHQUFHQyxDQUFDLENBQUNELEVBQUU7UUFBRyxLQUFLdkIsT0FBTzRFLHlCQUF5QixHQUFHNUUsT0FBTzZFLGdCQUFnQixDQUFDeEQsR0FBR3JCLE9BQU80RSx5QkFBeUIsQ0FBQ3BELE1BQU0wQyxRQUFRbEUsT0FBT3dCLElBQUlrRCxPQUFPLENBQUMsU0FBVW5ELENBQUM7WUFBSXZCLE9BQU9DLGNBQWMsQ0FBQ29CLEdBQUdFLEdBQUd2QixPQUFPOEIsd0JBQXdCLENBQUNOLEdBQUdEO1FBQUs7SUFBSTtJQUFFLE9BQU9GO0FBQUc7QUFDdGIsU0FBU3NELGdCQUFnQnpELEdBQUcsRUFBRTJDLEdBQUcsRUFBRTFELEtBQUs7SUFBSTBELE1BQU1pQixlQUFlakI7SUFBTSxJQUFJQSxPQUFPM0MsS0FBSztRQUFFbEIsT0FBT0MsY0FBYyxDQUFDaUIsS0FBSzJDLEtBQUs7WUFBRTFELE9BQU9BO1lBQU9rRSxZQUFZO1lBQU1VLGNBQWM7WUFBTUMsVUFBVTtRQUFLO0lBQUksT0FBTztRQUFFOUQsR0FBRyxDQUFDMkMsSUFBSSxHQUFHMUQ7SUFBTztJQUFFLE9BQU9lO0FBQUs7QUFDM08sU0FBUzRELGVBQWV0RCxDQUFDO0lBQUksSUFBSVUsSUFBSStDLGFBQWF6RCxHQUFHO0lBQVcsT0FBTyxZQUFZN0IsUUFBUXVDLEtBQUtBLElBQUlBLElBQUk7QUFBSTtBQUM1RyxTQUFTK0MsYUFBYXpELENBQUMsRUFBRUQsQ0FBQztJQUFJLElBQUksWUFBWTVCLFFBQVE2QixNQUFNLENBQUNBLEdBQUcsT0FBT0E7SUFBRyxJQUFJSCxJQUFJRyxDQUFDLENBQUMzQixPQUFPcUYsV0FBVyxDQUFDO0lBQUUsSUFBSSxLQUFLLE1BQU03RCxHQUFHO1FBQUUsSUFBSWEsSUFBSWIsRUFBRVksSUFBSSxDQUFDVCxHQUFHRCxLQUFLO1FBQVksSUFBSSxZQUFZNUIsUUFBUXVDLElBQUksT0FBT0E7UUFBRyxNQUFNLElBQUlRLFVBQVU7SUFBaUQ7SUFBRSxPQUFPLENBQUMsYUFBYW5CLElBQUk0RCxTQUFTQyxNQUFLLEVBQUc1RDtBQUFJO0FBQzNULFNBQVM2RDtJQUFhQSxXQUFXckYsT0FBT3NGLE1BQU0sR0FBR3RGLE9BQU9zRixNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVNUIsTUFBTTtRQUFJLElBQUssSUFBSXpCLElBQUksR0FBR0EsSUFBSXVDLFVBQVVuQixNQUFNLEVBQUVwQixJQUFLO1lBQUUsSUFBSXVCLFNBQVNnQixTQUFTLENBQUN2QyxFQUFFO1lBQUUsSUFBSyxJQUFJMkIsT0FBT0osT0FBUTtnQkFBRSxJQUFJekQsT0FBT0QsU0FBUyxDQUFDaUMsY0FBYyxDQUFDQyxJQUFJLENBQUN3QixRQUFRSSxNQUFNO29CQUFFRixNQUFNLENBQUNFLElBQUksR0FBR0osTUFBTSxDQUFDSSxJQUFJO2dCQUFFO1lBQUU7UUFBRTtRQUFFLE9BQU9GO0lBQVE7SUFBRyxPQUFPMEIsU0FBU2QsS0FBSyxDQUFDLElBQUksRUFBRUU7QUFBWTtBQUNsVixJQUFJZSxXQUFXLFNBQVNBLFNBQVNDLEtBQUs7SUFDcEMsSUFBSXRGLFFBQVFzRixNQUFNdEYsS0FBSyxFQUNyQnVGLFlBQVlELE1BQU1DLFNBQVM7SUFDN0IsSUFBSUMsUUFBUSxDQUFDLEdBQUduRixNQUFNLENBQUMsVUFBVSxFQUFFaUYsTUFBTUcsUUFBUSxJQUFJekYsUUFBUXNGLE1BQU1HLFFBQVE7SUFDM0UsSUFBSSxDQUFDLEdBQUdsRixXQUFXLENBQUMsVUFBVSxFQUFFZ0YsWUFBWTtRQUMxQyxPQUFPQSxVQUFVQztJQUNuQjtJQUNBLE9BQU9BO0FBQ1Q7QUFDQSxJQUFJRSxnQkFBZ0IsU0FBU0EsY0FBY0MsVUFBVSxFQUFFQyxRQUFRO0lBQzdELElBQUlDLE9BQU8sQ0FBQyxHQUFHakYsV0FBV2tGLFFBQVEsRUFBRUYsV0FBV0Q7SUFDL0MsSUFBSUksYUFBYUMsS0FBS0MsR0FBRyxDQUFDRCxLQUFLRSxHQUFHLENBQUNOLFdBQVdELGFBQWE7SUFDM0QsT0FBT0UsT0FBT0U7QUFDaEI7QUFDQSxJQUFJSSxvQkFBb0IsU0FBU0Esa0JBQWtCQyxVQUFVLEVBQUVaLEtBQUssRUFBRWEsS0FBSztJQUN6RSxJQUFJQyxXQUFXRixXQUFXRSxRQUFRLEVBQ2hDQyxVQUFVSCxXQUFXRyxPQUFPLEVBQzVCQyxTQUFTSixXQUFXSSxNQUFNLEVBQzFCQyxZQUFZTCxXQUFXSyxTQUFTO0lBQ2xDLElBQUlDLE9BQU9ILFNBQ1RJLEtBQUtELEtBQUtDLEVBQUUsRUFDWkMsS0FBS0YsS0FBS0UsRUFBRSxFQUNaQyxjQUFjSCxLQUFLRyxXQUFXLEVBQzlCQyxjQUFjSixLQUFLSSxXQUFXLEVBQzlCbkIsYUFBYWUsS0FBS2YsVUFBVSxFQUM1QkMsV0FBV2MsS0FBS2QsUUFBUSxFQUN4Qm1CLFlBQVlMLEtBQUtLLFNBQVM7SUFDNUIsSUFBSUMsU0FBUyxDQUFDSCxjQUFjQyxXQUFVLElBQUs7SUFDM0MsSUFBSWYsYUFBYUwsY0FBY0MsWUFBWUM7SUFDM0MsSUFBSUMsT0FBT0UsY0FBYyxJQUFJLElBQUksQ0FBQztJQUNsQyxJQUFJa0IsWUFBWUM7SUFDaEIsSUFBSVosYUFBYSxlQUFlO1FBQzlCVyxhQUFhdEIsYUFBYUUsT0FBT1c7UUFDakNVLFlBQVlIO0lBQ2QsT0FBTyxJQUFJVCxhQUFhLGFBQWE7UUFDbkNXLGFBQWFyQixXQUFXQyxPQUFPVztRQUMvQlUsWUFBWSxDQUFDSDtJQUNmLE9BQU8sSUFBSVQsYUFBYSxPQUFPO1FBQzdCVyxhQUFhckIsV0FBV0MsT0FBT1c7UUFDL0JVLFlBQVlIO0lBQ2Q7SUFDQUcsWUFBWW5CLGNBQWMsSUFBSW1CLFlBQVksQ0FBQ0E7SUFDM0MsSUFBSUMsYUFBYSxDQUFDLEdBQUd0RyxZQUFZdUcsZ0JBQWdCLEVBQUVULElBQUlDLElBQUlJLFFBQVFDO0lBQ25FLElBQUlJLFdBQVcsQ0FBQyxHQUFHeEcsWUFBWXVHLGdCQUFnQixFQUFFVCxJQUFJQyxJQUFJSSxRQUFRQyxhQUFhLENBQUNDLFlBQVksSUFBSSxDQUFDLEtBQUs7SUFDckcsSUFBSUksT0FBTyxJQUFJQyxNQUFNLENBQUNKLFdBQVdLLENBQUMsRUFBRSxLQUFLRCxNQUFNLENBQUNKLFdBQVdNLENBQUMsRUFBRSxXQUFXRixNQUFNLENBQUNQLFFBQVEsS0FBS08sTUFBTSxDQUFDUCxRQUFRLFNBQVNPLE1BQU0sQ0FBQ0wsWUFBWSxJQUFJLEdBQUcsV0FBV0ssTUFBTSxDQUFDRixTQUFTRyxDQUFDLEVBQUUsS0FBS0QsTUFBTSxDQUFDRixTQUFTSSxDQUFDO0lBQ25NLElBQUlDLEtBQUssQ0FBQyxHQUFHckgsTUFBTSxDQUFDLFVBQVUsRUFBRStGLFdBQVdzQixFQUFFLElBQUksQ0FBQyxHQUFHOUcsV0FBVytHLFFBQVEsRUFBRSwyQkFBMkJ2QixXQUFXc0IsRUFBRTtJQUNsSCxPQUFPLFdBQVcsR0FBRXhILE1BQU0sQ0FBQyxVQUFVLENBQUMwSCxhQUFhLENBQUMsUUFBUTFDLFNBQVMsQ0FBQyxHQUFHbUIsT0FBTztRQUM5RXdCLGtCQUFrQjtRQUNsQnBCLFdBQVcsQ0FBQyxHQUFHaEcsS0FBSyxDQUFDLFVBQVUsRUFBRSw2QkFBNkJnRztJQUNoRSxJQUFJLFdBQVcsR0FBRXZHLE1BQU0sQ0FBQyxVQUFVLENBQUMwSCxhQUFhLENBQUMsUUFBUSxNQUFNLFdBQVcsR0FBRTFILE1BQU0sQ0FBQyxVQUFVLENBQUMwSCxhQUFhLENBQUMsUUFBUTtRQUNsSEYsSUFBSUE7UUFDSkksR0FBR1I7SUFDTCxLQUFLLFdBQVcsR0FBRXBILE1BQU0sQ0FBQyxVQUFVLENBQUMwSCxhQUFhLENBQUMsWUFBWTtRQUM1REcsV0FBVyxJQUFJUixNQUFNLENBQUNHO0lBQ3hCLEdBQUdsQztBQUNMO0FBQ0EsSUFBSXdDLHVCQUF1QixTQUFTQSxxQkFBcUIxQyxLQUFLO0lBQzVELElBQUlpQixVQUFVakIsTUFBTWlCLE9BQU8sRUFDekJDLFNBQVNsQixNQUFNa0IsTUFBTSxFQUNyQkYsV0FBV2hCLE1BQU1nQixRQUFRO0lBQzNCLElBQUkyQixRQUFRMUIsU0FDVkksS0FBS3NCLE1BQU10QixFQUFFLEVBQ2JDLEtBQUtxQixNQUFNckIsRUFBRSxFQUNiQyxjQUFjb0IsTUFBTXBCLFdBQVcsRUFDL0JDLGNBQWNtQixNQUFNbkIsV0FBVyxFQUMvQm5CLGFBQWFzQyxNQUFNdEMsVUFBVSxFQUM3QkMsV0FBV3FDLE1BQU1yQyxRQUFRO0lBQzNCLElBQUlzQyxXQUFXLENBQUN2QyxhQUFhQyxRQUFPLElBQUs7SUFDekMsSUFBSVUsYUFBYSxXQUFXO1FBQzFCLElBQUk2QixvQkFBb0IsQ0FBQyxHQUFHdEgsWUFBWXVHLGdCQUFnQixFQUFFVCxJQUFJQyxJQUFJRSxjQUFjTixRQUFRMEIsV0FDdEZFLEtBQUtELGtCQUFrQlgsQ0FBQyxFQUN4QmEsS0FBS0Ysa0JBQWtCVixDQUFDO1FBQzFCLE9BQU87WUFDTEQsR0FBR1k7WUFDSFgsR0FBR1k7WUFDSEMsWUFBWUYsTUFBTXpCLEtBQUssVUFBVTtZQUNqQzRCLGdCQUFnQjtRQUNsQjtJQUNGO0lBQ0EsSUFBSWpDLGFBQWEsVUFBVTtRQUN6QixPQUFPO1lBQ0xrQixHQUFHYjtZQUNIYyxHQUFHYjtZQUNIMEIsWUFBWTtZQUNaQyxnQkFBZ0I7UUFDbEI7SUFDRjtJQUNBLElBQUlqQyxhQUFhLGFBQWE7UUFDNUIsT0FBTztZQUNMa0IsR0FBR2I7WUFDSGMsR0FBR2I7WUFDSDBCLFlBQVk7WUFDWkMsZ0JBQWdCO1FBQ2xCO0lBQ0Y7SUFDQSxJQUFJakMsYUFBYSxnQkFBZ0I7UUFDL0IsT0FBTztZQUNMa0IsR0FBR2I7WUFDSGMsR0FBR2I7WUFDSDBCLFlBQVk7WUFDWkMsZ0JBQWdCO1FBQ2xCO0lBQ0Y7SUFDQSxJQUFJbkgsSUFBSSxDQUFDeUYsY0FBY0MsV0FBVSxJQUFLO0lBQ3RDLElBQUkwQixxQkFBcUIsQ0FBQyxHQUFHM0gsWUFBWXVHLGdCQUFnQixFQUFFVCxJQUFJQyxJQUFJeEYsR0FBRzhHLFdBQ3BFVixJQUFJZ0IsbUJBQW1CaEIsQ0FBQyxFQUN4QkMsSUFBSWUsbUJBQW1CZixDQUFDO0lBQzFCLE9BQU87UUFDTEQsR0FBR0E7UUFDSEMsR0FBR0E7UUFDSGEsWUFBWTtRQUNaQyxnQkFBZ0I7SUFDbEI7QUFDRjtBQUNBLElBQUlFLDJCQUEyQixTQUFTQSx5QkFBeUJuRCxLQUFLO0lBQ3BFLElBQUlpQixVQUFVakIsTUFBTWlCLE9BQU8sRUFDekJtQyxnQkFBZ0JwRCxNQUFNb0QsYUFBYSxFQUNuQ2xDLFNBQVNsQixNQUFNa0IsTUFBTSxFQUNyQkYsV0FBV2hCLE1BQU1nQixRQUFRO0lBQzNCLElBQUlxQyxRQUFRcEMsU0FDVmlCLElBQUltQixNQUFNbkIsQ0FBQyxFQUNYQyxJQUFJa0IsTUFBTWxCLENBQUMsRUFDWG1CLFFBQVFELE1BQU1DLEtBQUssRUFDbkJDLFNBQVNGLE1BQU1FLE1BQU07SUFFdkIsNkZBQTZGO0lBQzdGLElBQUlDLGVBQWVELFVBQVUsSUFBSSxJQUFJLENBQUM7SUFDdEMsSUFBSUUsaUJBQWlCRCxlQUFldEM7SUFDcEMsSUFBSXdDLGNBQWNGLGVBQWUsSUFBSSxRQUFRO0lBQzdDLElBQUlHLGdCQUFnQkgsZUFBZSxJQUFJLFVBQVU7SUFFakQsK0ZBQStGO0lBQy9GLElBQUlJLGlCQUFpQk4sU0FBUyxJQUFJLElBQUksQ0FBQztJQUN2QyxJQUFJTyxtQkFBbUJELGlCQUFpQjFDO0lBQ3hDLElBQUk0QyxnQkFBZ0JGLGlCQUFpQixJQUFJLFFBQVE7SUFDakQsSUFBSUcsa0JBQWtCSCxpQkFBaUIsSUFBSSxVQUFVO0lBQ3JELElBQUk1QyxhQUFhLE9BQU87UUFDdEIsSUFBSUQsUUFBUTtZQUNWbUIsR0FBR0EsSUFBSW9CLFFBQVE7WUFDZm5CLEdBQUdBLElBQUlxQixlQUFldEM7WUFDdEI4QixZQUFZO1lBQ1pDLGdCQUFnQlM7UUFDbEI7UUFDQSxPQUFPM0UsY0FBY0EsY0FBYyxDQUFDLEdBQUdnQyxRQUFRcUMsZ0JBQWdCO1lBQzdERyxRQUFRN0MsS0FBS3NELEdBQUcsQ0FBQzdCLElBQUlpQixjQUFjakIsQ0FBQyxFQUFFO1lBQ3RDbUIsT0FBT0E7UUFDVCxJQUFJLENBQUM7SUFDUDtJQUNBLElBQUl0QyxhQUFhLFVBQVU7UUFDekIsSUFBSWlELFNBQVM7WUFDWC9CLEdBQUdBLElBQUlvQixRQUFRO1lBQ2ZuQixHQUFHQSxJQUFJb0IsU0FBU0U7WUFDaEJULFlBQVk7WUFDWkMsZ0JBQWdCVTtRQUNsQjtRQUNBLE9BQU81RSxjQUFjQSxjQUFjLENBQUMsR0FBR2tGLFNBQVNiLGdCQUFnQjtZQUM5REcsUUFBUTdDLEtBQUtzRCxHQUFHLENBQUNaLGNBQWNqQixDQUFDLEdBQUdpQixjQUFjRyxNQUFNLEdBQUlwQixDQUFBQSxJQUFJb0IsTUFBSyxHQUFJO1lBQ3hFRCxPQUFPQTtRQUNULElBQUksQ0FBQztJQUNQO0lBQ0EsSUFBSXRDLGFBQWEsUUFBUTtRQUN2QixJQUFJa0QsVUFBVTtZQUNaaEMsR0FBR0EsSUFBSTJCO1lBQ1AxQixHQUFHQSxJQUFJb0IsU0FBUztZQUNoQlAsWUFBWWM7WUFDWmIsZ0JBQWdCO1FBQ2xCO1FBQ0EsT0FBT2xFLGNBQWNBLGNBQWMsQ0FBQyxHQUFHbUYsVUFBVWQsZ0JBQWdCO1lBQy9ERSxPQUFPNUMsS0FBS3NELEdBQUcsQ0FBQ0UsUUFBUWhDLENBQUMsR0FBR2tCLGNBQWNsQixDQUFDLEVBQUU7WUFDN0NxQixRQUFRQTtRQUNWLElBQUksQ0FBQztJQUNQO0lBQ0EsSUFBSXZDLGFBQWEsU0FBUztRQUN4QixJQUFJbUQsVUFBVTtZQUNaakMsR0FBR0EsSUFBSW9CLFFBQVFPO1lBQ2YxQixHQUFHQSxJQUFJb0IsU0FBUztZQUNoQlAsWUFBWWU7WUFDWmQsZ0JBQWdCO1FBQ2xCO1FBQ0EsT0FBT2xFLGNBQWNBLGNBQWMsQ0FBQyxHQUFHb0YsVUFBVWYsZ0JBQWdCO1lBQy9ERSxPQUFPNUMsS0FBS3NELEdBQUcsQ0FBQ1osY0FBY2xCLENBQUMsR0FBR2tCLGNBQWNFLEtBQUssR0FBR2EsUUFBUWpDLENBQUMsRUFBRTtZQUNuRXFCLFFBQVFBO1FBQ1YsSUFBSSxDQUFDO0lBQ1A7SUFDQSxJQUFJYSxZQUFZaEIsZ0JBQWdCO1FBQzlCRSxPQUFPQTtRQUNQQyxRQUFRQTtJQUNWLElBQUksQ0FBQztJQUNMLElBQUl2QyxhQUFhLGNBQWM7UUFDN0IsT0FBT2pDLGNBQWM7WUFDbkJtRCxHQUFHQSxJQUFJMkI7WUFDUDFCLEdBQUdBLElBQUlvQixTQUFTO1lBQ2hCUCxZQUFZZTtZQUNaZCxnQkFBZ0I7UUFDbEIsR0FBR21CO0lBQ0w7SUFDQSxJQUFJcEQsYUFBYSxlQUFlO1FBQzlCLE9BQU9qQyxjQUFjO1lBQ25CbUQsR0FBR0EsSUFBSW9CLFFBQVFPO1lBQ2YxQixHQUFHQSxJQUFJb0IsU0FBUztZQUNoQlAsWUFBWWM7WUFDWmIsZ0JBQWdCO1FBQ2xCLEdBQUdtQjtJQUNMO0lBQ0EsSUFBSXBELGFBQWEsYUFBYTtRQUM1QixPQUFPakMsY0FBYztZQUNuQm1ELEdBQUdBLElBQUlvQixRQUFRO1lBQ2ZuQixHQUFHQSxJQUFJc0I7WUFDUFQsWUFBWTtZQUNaQyxnQkFBZ0JVO1FBQ2xCLEdBQUdTO0lBQ0w7SUFDQSxJQUFJcEQsYUFBYSxnQkFBZ0I7UUFDL0IsT0FBT2pDLGNBQWM7WUFDbkJtRCxHQUFHQSxJQUFJb0IsUUFBUTtZQUNmbkIsR0FBR0EsSUFBSW9CLFNBQVNFO1lBQ2hCVCxZQUFZO1lBQ1pDLGdCQUFnQlM7UUFDbEIsR0FBR1U7SUFDTDtJQUNBLElBQUlwRCxhQUFhLGlCQUFpQjtRQUNoQyxPQUFPakMsY0FBYztZQUNuQm1ELEdBQUdBLElBQUkyQjtZQUNQMUIsR0FBR0EsSUFBSXNCO1lBQ1BULFlBQVllO1lBQ1pkLGdCQUFnQlU7UUFDbEIsR0FBR1M7SUFDTDtJQUNBLElBQUlwRCxhQUFhLGtCQUFrQjtRQUNqQyxPQUFPakMsY0FBYztZQUNuQm1ELEdBQUdBLElBQUlvQixRQUFRTztZQUNmMUIsR0FBR0EsSUFBSXNCO1lBQ1BULFlBQVljO1lBQ1piLGdCQUFnQlU7UUFDbEIsR0FBR1M7SUFDTDtJQUNBLElBQUlwRCxhQUFhLG9CQUFvQjtRQUNuQyxPQUFPakMsY0FBYztZQUNuQm1ELEdBQUdBLElBQUkyQjtZQUNQMUIsR0FBR0EsSUFBSW9CLFNBQVNFO1lBQ2hCVCxZQUFZZTtZQUNaZCxnQkFBZ0JTO1FBQ2xCLEdBQUdVO0lBQ0w7SUFDQSxJQUFJcEQsYUFBYSxxQkFBcUI7UUFDcEMsT0FBT2pDLGNBQWM7WUFDbkJtRCxHQUFHQSxJQUFJb0IsUUFBUU87WUFDZjFCLEdBQUdBLElBQUlvQixTQUFTRTtZQUNoQlQsWUFBWWM7WUFDWmIsZ0JBQWdCUztRQUNsQixHQUFHVTtJQUNMO0lBQ0EsSUFBSSxDQUFDLEdBQUdsSixTQUFTLENBQUMsVUFBVSxFQUFFOEYsYUFBYyxFQUFDLEdBQUcxRixXQUFXK0ksUUFBUSxFQUFFckQsU0FBU2tCLENBQUMsS0FBSyxDQUFDLEdBQUc1RyxXQUFXZ0osU0FBUyxFQUFFdEQsU0FBU2tCLENBQUMsTUFBTyxFQUFDLEdBQUc1RyxXQUFXK0ksUUFBUSxFQUFFckQsU0FBU21CLENBQUMsS0FBSyxDQUFDLEdBQUc3RyxXQUFXZ0osU0FBUyxFQUFFdEQsU0FBU21CLENBQUMsSUFBSTtRQUM3TSxPQUFPcEQsY0FBYztZQUNuQm1ELEdBQUdBLElBQUksQ0FBQyxHQUFHNUcsV0FBV2lKLGVBQWUsRUFBRXZELFNBQVNrQixDQUFDLEVBQUVvQjtZQUNuRG5CLEdBQUdBLElBQUksQ0FBQyxHQUFHN0csV0FBV2lKLGVBQWUsRUFBRXZELFNBQVNtQixDQUFDLEVBQUVvQjtZQUNuRFAsWUFBWTtZQUNaQyxnQkFBZ0I7UUFDbEIsR0FBR21CO0lBQ0w7SUFDQSxPQUFPckYsY0FBYztRQUNuQm1ELEdBQUdBLElBQUlvQixRQUFRO1FBQ2ZuQixHQUFHQSxJQUFJb0IsU0FBUztRQUNoQlAsWUFBWTtRQUNaQyxnQkFBZ0I7SUFDbEIsR0FBR21CO0FBQ0w7QUFDQSxJQUFJSSxVQUFVLFNBQVNBLFFBQVF2RCxPQUFPO0lBQ3BDLE9BQU8sUUFBUUEsV0FBVyxDQUFDLEdBQUczRixXQUFXK0ksUUFBUSxFQUFFcEQsUUFBUUksRUFBRTtBQUMvRDtBQUNBLFNBQVMxRyxNQUFNOEosS0FBSztJQUNsQixJQUFJQyxlQUFlRCxNQUFNdkQsTUFBTSxFQUM3QkEsU0FBU3dELGlCQUFpQixLQUFLLElBQUksSUFBSUEsY0FDdkNDLFlBQVk1Ryx5QkFBeUIwRyxPQUFPako7SUFDOUMsSUFBSXdFLFFBQVFqQixjQUFjO1FBQ3hCbUMsUUFBUUE7SUFDVixHQUFHeUQ7SUFDSCxJQUFJMUQsVUFBVWpCLE1BQU1pQixPQUFPLEVBQ3pCRCxXQUFXaEIsTUFBTWdCLFFBQVEsRUFDekJ0RyxRQUFRc0YsTUFBTXRGLEtBQUssRUFDbkJ5RixXQUFXSCxNQUFNRyxRQUFRLEVBQ3pCeUUsVUFBVTVFLE1BQU00RSxPQUFPLEVBQ3ZCQyxtQkFBbUI3RSxNQUFNbUIsU0FBUyxFQUNsQ0EsWUFBWTBELHFCQUFxQixLQUFLLElBQUksS0FBS0Esa0JBQy9DQyxlQUFlOUUsTUFBTThFLFlBQVk7SUFDbkMsSUFBSSxDQUFDN0QsV0FBVyxDQUFDLEdBQUdsRyxNQUFNLENBQUMsVUFBVSxFQUFFTCxVQUFVLENBQUMsR0FBR0ssTUFBTSxDQUFDLFVBQVUsRUFBRW9GLGFBQWEsQ0FBZSxXQUFGLEdBQUcsSUFBR3ZGLE9BQU9tSyxjQUFjLEVBQUVILFlBQVksQ0FBQyxDQUFDLEdBQUczSixXQUFXLENBQUMsVUFBVSxFQUFFMkosVUFBVTtRQUNoTCxPQUFPO0lBQ1Q7SUFDQSxJQUFrQixXQUFGLEdBQUcsSUFBR2hLLE9BQU9tSyxjQUFjLEVBQUVILFVBQVU7UUFDckQsT0FBb0IsV0FBRixHQUFHLElBQUdoSyxPQUFPb0ssWUFBWSxFQUFFSixTQUFTNUU7SUFDeEQ7SUFDQSxJQUFJRTtJQUNKLElBQUksQ0FBQyxHQUFHakYsV0FBVyxDQUFDLFVBQVUsRUFBRTJKLFVBQVU7UUFDeEMxRSxRQUFxQixXQUFGLEdBQUcsSUFBR3RGLE9BQU8wSCxhQUFhLEVBQUVzQyxTQUFTNUU7UUFDeEQsSUFBa0IsV0FBRixHQUFHLElBQUdwRixPQUFPbUssY0FBYyxFQUFFN0UsUUFBUTtZQUNuRCxPQUFPQTtRQUNUO0lBQ0YsT0FBTztRQUNMQSxRQUFRSCxTQUFTQztJQUNuQjtJQUNBLElBQUlpRixlQUFlVCxRQUFRdkQ7SUFDM0IsSUFBSUYsUUFBUSxDQUFDLEdBQUcxRixZQUFZNkosV0FBVyxFQUFFbEYsT0FBTztJQUNoRCxJQUFJaUYsZ0JBQWlCakUsQ0FBQUEsYUFBYSxpQkFBaUJBLGFBQWEsZUFBZUEsYUFBYSxLQUFJLEdBQUk7UUFDbEcsT0FBT0gsa0JBQWtCYixPQUFPRSxPQUFPYTtJQUN6QztJQUNBLElBQUlvRSxnQkFBZ0JGLGVBQWV2QyxxQkFBcUIxQyxTQUFTbUQseUJBQXlCbkQ7SUFDMUYsT0FBTyxXQUFXLEdBQUVwRixNQUFNLENBQUMsVUFBVSxDQUFDMEgsYUFBYSxDQUFDbEgsTUFBTWdLLElBQUksRUFBRXhGLFNBQVM7UUFDdkV1QixXQUFXLENBQUMsR0FBR2hHLEtBQUssQ0FBQyxVQUFVLEVBQUUsa0JBQWtCZ0c7SUFDckQsR0FBR0osT0FBT29FLGVBQWU7UUFDdkJFLFVBQVVQO0lBQ1osSUFBSTVFO0FBQ047QUFDQXZGLE1BQU0ySyxXQUFXLEdBQUc7QUFDcEIsSUFBSUMsZUFBZSxTQUFTQSxhQUFhdkYsS0FBSztJQUM1QyxJQUFJcUIsS0FBS3JCLE1BQU1xQixFQUFFLEVBQ2ZDLEtBQUt0QixNQUFNc0IsRUFBRSxFQUNia0UsUUFBUXhGLE1BQU13RixLQUFLLEVBQ25CbkYsYUFBYUwsTUFBTUssVUFBVSxFQUM3QkMsV0FBV04sTUFBTU0sUUFBUSxFQUN6QnhFLElBQUlrRSxNQUFNbEUsQ0FBQyxFQUNYNEYsU0FBUzFCLE1BQU0wQixNQUFNLEVBQ3JCSCxjQUFjdkIsTUFBTXVCLFdBQVcsRUFDL0JDLGNBQWN4QixNQUFNd0IsV0FBVyxFQUMvQlUsSUFBSWxDLE1BQU1rQyxDQUFDLEVBQ1hDLElBQUluQyxNQUFNbUMsQ0FBQyxFQUNYc0QsTUFBTXpGLE1BQU15RixHQUFHLEVBQ2ZDLE9BQU8xRixNQUFNMEYsSUFBSSxFQUNqQnBDLFFBQVF0RCxNQUFNc0QsS0FBSyxFQUNuQkMsU0FBU3ZELE1BQU11RCxNQUFNLEVBQ3JCOUIsWUFBWXpCLE1BQU15QixTQUFTLEVBQzNCa0UsZUFBZTNGLE1BQU0yRixZQUFZO0lBQ25DLElBQUlBLGNBQWM7UUFDaEIsT0FBT0E7SUFDVDtJQUNBLElBQUksQ0FBQyxHQUFHckssV0FBVytJLFFBQVEsRUFBRWYsVUFBVSxDQUFDLEdBQUdoSSxXQUFXK0ksUUFBUSxFQUFFZCxTQUFTO1FBQ3ZFLElBQUksQ0FBQyxHQUFHakksV0FBVytJLFFBQVEsRUFBRW5DLE1BQU0sQ0FBQyxHQUFHNUcsV0FBVytJLFFBQVEsRUFBRWxDLElBQUk7WUFDOUQsT0FBTztnQkFDTEQsR0FBR0E7Z0JBQ0hDLEdBQUdBO2dCQUNIbUIsT0FBT0E7Z0JBQ1BDLFFBQVFBO1lBQ1Y7UUFDRjtRQUNBLElBQUksQ0FBQyxHQUFHakksV0FBVytJLFFBQVEsRUFBRW9CLFFBQVEsQ0FBQyxHQUFHbkssV0FBVytJLFFBQVEsRUFBRXFCLE9BQU87WUFDbkUsT0FBTztnQkFDTHhELEdBQUd1RDtnQkFDSHRELEdBQUd1RDtnQkFDSHBDLE9BQU9BO2dCQUNQQyxRQUFRQTtZQUNWO1FBQ0Y7SUFDRjtJQUNBLElBQUksQ0FBQyxHQUFHakksV0FBVytJLFFBQVEsRUFBRW5DLE1BQU0sQ0FBQyxHQUFHNUcsV0FBVytJLFFBQVEsRUFBRWxDLElBQUk7UUFDOUQsT0FBTztZQUNMRCxHQUFHQTtZQUNIQyxHQUFHQTtZQUNIbUIsT0FBTztZQUNQQyxRQUFRO1FBQ1Y7SUFDRjtJQUNBLElBQUksQ0FBQyxHQUFHakksV0FBVytJLFFBQVEsRUFBRWhELE9BQU8sQ0FBQyxHQUFHL0YsV0FBVytJLFFBQVEsRUFBRS9DLEtBQUs7UUFDaEUsT0FBTztZQUNMRCxJQUFJQTtZQUNKQyxJQUFJQTtZQUNKakIsWUFBWUEsY0FBY21GLFNBQVM7WUFDbkNsRixVQUFVQSxZQUFZa0YsU0FBUztZQUMvQmpFLGFBQWFBLGVBQWU7WUFDNUJDLGFBQWFBLGVBQWVFLFVBQVU1RixLQUFLO1lBQzNDMkYsV0FBV0E7UUFDYjtJQUNGO0lBQ0EsSUFBSXpCLE1BQU1pQixPQUFPLEVBQUU7UUFDakIsT0FBT2pCLE1BQU1pQixPQUFPO0lBQ3RCO0lBQ0EsT0FBTyxDQUFDO0FBQ1Y7QUFDQSxJQUFJMkUsYUFBYSxTQUFTQSxXQUFXMUYsS0FBSyxFQUFFZSxPQUFPO0lBQ2pELElBQUksQ0FBQ2YsT0FBTztRQUNWLE9BQU87SUFDVDtJQUNBLElBQUlBLFVBQVUsTUFBTTtRQUNsQixPQUFPLFdBQVcsR0FBRXRGLE1BQU0sQ0FBQyxVQUFVLENBQUMwSCxhQUFhLENBQUMzSCxPQUFPO1lBQ3pEeUQsS0FBSztZQUNMNkMsU0FBU0E7UUFDWDtJQUNGO0lBQ0EsSUFBSSxDQUFDLEdBQUczRixXQUFXdUssVUFBVSxFQUFFM0YsUUFBUTtRQUNyQyxPQUFPLFdBQVcsR0FBRXRGLE1BQU0sQ0FBQyxVQUFVLENBQUMwSCxhQUFhLENBQUMzSCxPQUFPO1lBQ3pEeUQsS0FBSztZQUNMNkMsU0FBU0E7WUFDVHZHLE9BQU93RjtRQUNUO0lBQ0Y7SUFDQSxJQUFrQixXQUFGLEdBQUcsSUFBR3RGLE9BQU9tSyxjQUFjLEVBQUU3RSxRQUFRO1FBQ25ELElBQUlBLE1BQU00RixJQUFJLEtBQUtuTCxPQUFPO1lBQ3hCLE9BQW9CLFdBQUYsR0FBRyxJQUFHQyxPQUFPb0ssWUFBWSxFQUFFOUUsT0FBTztnQkFDbEQ5QixLQUFLO2dCQUNMNkMsU0FBU0E7WUFDWDtRQUNGO1FBQ0EsT0FBTyxXQUFXLEdBQUVyRyxNQUFNLENBQUMsVUFBVSxDQUFDMEgsYUFBYSxDQUFDM0gsT0FBTztZQUN6RHlELEtBQUs7WUFDTHdHLFNBQVMxRTtZQUNUZSxTQUFTQTtRQUNYO0lBQ0Y7SUFDQSxJQUFJLENBQUMsR0FBR2hHLFdBQVcsQ0FBQyxVQUFVLEVBQUVpRixRQUFRO1FBQ3RDLE9BQU8sV0FBVyxHQUFFdEYsTUFBTSxDQUFDLFVBQVUsQ0FBQzBILGFBQWEsQ0FBQzNILE9BQU87WUFDekR5RCxLQUFLO1lBQ0x3RyxTQUFTMUU7WUFDVGUsU0FBU0E7UUFDWDtJQUNGO0lBQ0EsSUFBSSxDQUFDLEdBQUcvRixTQUFTLENBQUMsVUFBVSxFQUFFZ0YsUUFBUTtRQUNwQyxPQUFPLFdBQVcsR0FBRXRGLE1BQU0sQ0FBQyxVQUFVLENBQUMwSCxhQUFhLENBQUMzSCxPQUFPaUYsU0FBUztZQUNsRXFCLFNBQVNBO1FBQ1gsR0FBR2YsT0FBTztZQUNSOUIsS0FBSztRQUNQO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxJQUFJMkgscUJBQXFCLFNBQVNBLG1CQUFtQkMsV0FBVyxFQUFFL0UsT0FBTztJQUN2RSxJQUFJZ0Ysa0JBQWtCakgsVUFBVW5CLE1BQU0sR0FBRyxLQUFLbUIsU0FBUyxDQUFDLEVBQUUsS0FBS2tILFlBQVlsSCxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQzFGLElBQUksQ0FBQ2dILGVBQWUsQ0FBQ0EsWUFBWTdGLFFBQVEsSUFBSThGLG1CQUFtQixDQUFDRCxZQUFZOUYsS0FBSyxFQUFFO1FBQ2xGLE9BQU87SUFDVDtJQUNBLElBQUlDLFdBQVc2RixZQUFZN0YsUUFBUTtJQUNuQyxJQUFJaUQsZ0JBQWdCbUMsYUFBYVM7SUFDakMsSUFBSUcsbUJBQW1CLENBQUMsR0FBRzlLLFlBQVkrSyxhQUFhLEVBQUVqRyxVQUFVeEYsT0FBTzBMLEdBQUcsQ0FBQyxTQUFVQyxLQUFLLEVBQUVDLEtBQUs7UUFDL0YsT0FBb0IsV0FBRixHQUFHLElBQUczTCxPQUFPb0ssWUFBWSxFQUFFc0IsT0FBTztZQUNsRHJGLFNBQVNBLFdBQVdtQztZQUNwQixvREFBb0Q7WUFDcERoRixLQUFLLFNBQVM2RCxNQUFNLENBQUNzRTtRQUN2QjtJQUNGO0lBQ0EsSUFBSSxDQUFDTixpQkFBaUI7UUFDcEIsT0FBT0U7SUFDVDtJQUNBLElBQUlLLGdCQUFnQlosV0FBV0ksWUFBWTlGLEtBQUssRUFBRWUsV0FBV21DO0lBQzdELE9BQU87UUFBQ29EO0tBQWMsQ0FBQ3ZFLE1BQU0sQ0FBQ3RGLG1CQUFtQndKO0FBQ25EO0FBQ0F4TCxNQUFNNEssWUFBWSxHQUFHQTtBQUNyQjVLLE1BQU1vTCxrQkFBa0IsR0FBR0EiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXGNvbXBvbmVudFxcTGFiZWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLkxhYmVsID0gTGFiZWw7XHJcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgX2lzTmlsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzTmlsXCIpKTtcclxudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xyXG52YXIgX2lzT2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzT2JqZWN0XCIpKTtcclxudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XHJcbnZhciBfVGV4dCA9IHJlcXVpcmUoXCIuL1RleHRcIik7XHJcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XHJcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRGF0YVV0aWxzXCIpO1xyXG52YXIgX1BvbGFyVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9Qb2xhclV0aWxzXCIpO1xyXG52YXIgX2V4Y2x1ZGVkID0gW1wib2Zmc2V0XCJdO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cclxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XHJcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cclxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XHJcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxyXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XHJcbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cclxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxyXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxyXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cclxudmFyIGdldExhYmVsID0gZnVuY3Rpb24gZ2V0TGFiZWwocHJvcHMpIHtcclxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZSxcclxuICAgIGZvcm1hdHRlciA9IHByb3BzLmZvcm1hdHRlcjtcclxuICB2YXIgbGFiZWwgPSAoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkocHJvcHMuY2hpbGRyZW4pID8gdmFsdWUgOiBwcm9wcy5jaGlsZHJlbjtcclxuICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkoZm9ybWF0dGVyKSkge1xyXG4gICAgcmV0dXJuIGZvcm1hdHRlcihsYWJlbCk7XHJcbiAgfVxyXG4gIHJldHVybiBsYWJlbDtcclxufTtcclxudmFyIGdldERlbHRhQW5nbGUgPSBmdW5jdGlvbiBnZXREZWx0YUFuZ2xlKHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSB7XHJcbiAgdmFyIHNpZ24gPSAoMCwgX0RhdGFVdGlscy5tYXRoU2lnbikoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcclxuICB2YXIgZGVsdGFBbmdsZSA9IE1hdGgubWluKE1hdGguYWJzKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSksIDM2MCk7XHJcbiAgcmV0dXJuIHNpZ24gKiBkZWx0YUFuZ2xlO1xyXG59O1xyXG52YXIgcmVuZGVyUmFkaWFsTGFiZWwgPSBmdW5jdGlvbiByZW5kZXJSYWRpYWxMYWJlbChsYWJlbFByb3BzLCBsYWJlbCwgYXR0cnMpIHtcclxuICB2YXIgcG9zaXRpb24gPSBsYWJlbFByb3BzLnBvc2l0aW9uLFxyXG4gICAgdmlld0JveCA9IGxhYmVsUHJvcHMudmlld0JveCxcclxuICAgIG9mZnNldCA9IGxhYmVsUHJvcHMub2Zmc2V0LFxyXG4gICAgY2xhc3NOYW1lID0gbGFiZWxQcm9wcy5jbGFzc05hbWU7XHJcbiAgdmFyIF9yZWYgPSB2aWV3Qm94LFxyXG4gICAgY3ggPSBfcmVmLmN4LFxyXG4gICAgY3kgPSBfcmVmLmN5LFxyXG4gICAgaW5uZXJSYWRpdXMgPSBfcmVmLmlubmVyUmFkaXVzLFxyXG4gICAgb3V0ZXJSYWRpdXMgPSBfcmVmLm91dGVyUmFkaXVzLFxyXG4gICAgc3RhcnRBbmdsZSA9IF9yZWYuc3RhcnRBbmdsZSxcclxuICAgIGVuZEFuZ2xlID0gX3JlZi5lbmRBbmdsZSxcclxuICAgIGNsb2NrV2lzZSA9IF9yZWYuY2xvY2tXaXNlO1xyXG4gIHZhciByYWRpdXMgPSAoaW5uZXJSYWRpdXMgKyBvdXRlclJhZGl1cykgLyAyO1xyXG4gIHZhciBkZWx0YUFuZ2xlID0gZ2V0RGVsdGFBbmdsZShzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XHJcbiAgdmFyIHNpZ24gPSBkZWx0YUFuZ2xlID49IDAgPyAxIDogLTE7XHJcbiAgdmFyIGxhYmVsQW5nbGUsIGRpcmVjdGlvbjtcclxuICBpZiAocG9zaXRpb24gPT09ICdpbnNpZGVTdGFydCcpIHtcclxuICAgIGxhYmVsQW5nbGUgPSBzdGFydEFuZ2xlICsgc2lnbiAqIG9mZnNldDtcclxuICAgIGRpcmVjdGlvbiA9IGNsb2NrV2lzZTtcclxuICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnaW5zaWRlRW5kJykge1xyXG4gICAgbGFiZWxBbmdsZSA9IGVuZEFuZ2xlIC0gc2lnbiAqIG9mZnNldDtcclxuICAgIGRpcmVjdGlvbiA9ICFjbG9ja1dpc2U7XHJcbiAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2VuZCcpIHtcclxuICAgIGxhYmVsQW5nbGUgPSBlbmRBbmdsZSArIHNpZ24gKiBvZmZzZXQ7XHJcbiAgICBkaXJlY3Rpb24gPSBjbG9ja1dpc2U7XHJcbiAgfVxyXG4gIGRpcmVjdGlvbiA9IGRlbHRhQW5nbGUgPD0gMCA/IGRpcmVjdGlvbiA6ICFkaXJlY3Rpb247XHJcbiAgdmFyIHN0YXJ0UG9pbnQgPSAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikoY3gsIGN5LCByYWRpdXMsIGxhYmVsQW5nbGUpO1xyXG4gIHZhciBlbmRQb2ludCA9ICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjeCwgY3ksIHJhZGl1cywgbGFiZWxBbmdsZSArIChkaXJlY3Rpb24gPyAxIDogLTEpICogMzU5KTtcclxuICB2YXIgcGF0aCA9IFwiTVwiLmNvbmNhdChzdGFydFBvaW50LngsIFwiLFwiKS5jb25jYXQoc3RhcnRQb2ludC55LCBcIlxcbiAgICBBXCIpLmNvbmNhdChyYWRpdXMsIFwiLFwiKS5jb25jYXQocmFkaXVzLCBcIiwwLDEsXCIpLmNvbmNhdChkaXJlY3Rpb24gPyAwIDogMSwgXCIsXFxuICAgIFwiKS5jb25jYXQoZW5kUG9pbnQueCwgXCIsXCIpLmNvbmNhdChlbmRQb2ludC55KTtcclxuICB2YXIgaWQgPSAoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkobGFiZWxQcm9wcy5pZCkgPyAoMCwgX0RhdGFVdGlscy51bmlxdWVJZCkoJ3JlY2hhcnRzLXJhZGlhbC1saW5lLScpIDogbGFiZWxQcm9wcy5pZDtcclxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInRleHRcIiwgX2V4dGVuZHMoe30sIGF0dHJzLCB7XHJcbiAgICBkb21pbmFudEJhc2VsaW5lOiBcImNlbnRyYWxcIixcclxuICAgIGNsYXNzTmFtZTogKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXJhZGlhbC1iYXItbGFiZWwnLCBjbGFzc05hbWUpXHJcbiAgfSksIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIsIG51bGwsIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcclxuICAgIGlkOiBpZCxcclxuICAgIGQ6IHBhdGhcclxuICB9KSksIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0UGF0aFwiLCB7XHJcbiAgICB4bGlua0hyZWY6IFwiI1wiLmNvbmNhdChpZClcclxuICB9LCBsYWJlbCkpO1xyXG59O1xyXG52YXIgZ2V0QXR0cnNPZlBvbGFyTGFiZWwgPSBmdW5jdGlvbiBnZXRBdHRyc09mUG9sYXJMYWJlbChwcm9wcykge1xyXG4gIHZhciB2aWV3Qm94ID0gcHJvcHMudmlld0JveCxcclxuICAgIG9mZnNldCA9IHByb3BzLm9mZnNldCxcclxuICAgIHBvc2l0aW9uID0gcHJvcHMucG9zaXRpb247XHJcbiAgdmFyIF9yZWYyID0gdmlld0JveCxcclxuICAgIGN4ID0gX3JlZjIuY3gsXHJcbiAgICBjeSA9IF9yZWYyLmN5LFxyXG4gICAgaW5uZXJSYWRpdXMgPSBfcmVmMi5pbm5lclJhZGl1cyxcclxuICAgIG91dGVyUmFkaXVzID0gX3JlZjIub3V0ZXJSYWRpdXMsXHJcbiAgICBzdGFydEFuZ2xlID0gX3JlZjIuc3RhcnRBbmdsZSxcclxuICAgIGVuZEFuZ2xlID0gX3JlZjIuZW5kQW5nbGU7XHJcbiAgdmFyIG1pZEFuZ2xlID0gKHN0YXJ0QW5nbGUgKyBlbmRBbmdsZSkgLyAyO1xyXG4gIGlmIChwb3NpdGlvbiA9PT0gJ291dHNpZGUnKSB7XHJcbiAgICB2YXIgX3BvbGFyVG9DYXJ0ZXNpYW4gPSAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikoY3gsIGN5LCBvdXRlclJhZGl1cyArIG9mZnNldCwgbWlkQW5nbGUpLFxyXG4gICAgICBfeCA9IF9wb2xhclRvQ2FydGVzaWFuLngsXHJcbiAgICAgIF95ID0gX3BvbGFyVG9DYXJ0ZXNpYW4ueTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IF94LFxyXG4gICAgICB5OiBfeSxcclxuICAgICAgdGV4dEFuY2hvcjogX3ggPj0gY3ggPyAnc3RhcnQnIDogJ2VuZCcsXHJcbiAgICAgIHZlcnRpY2FsQW5jaG9yOiAnbWlkZGxlJ1xyXG4gICAgfTtcclxuICB9XHJcbiAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogY3gsXHJcbiAgICAgIHk6IGN5LFxyXG4gICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcclxuICAgICAgdmVydGljYWxBbmNob3I6ICdtaWRkbGUnXHJcbiAgICB9O1xyXG4gIH1cclxuICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXJUb3AnKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiBjeCxcclxuICAgICAgeTogY3ksXHJcbiAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxyXG4gICAgICB2ZXJ0aWNhbEFuY2hvcjogJ3N0YXJ0J1xyXG4gICAgfTtcclxuICB9XHJcbiAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyQm90dG9tJykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogY3gsXHJcbiAgICAgIHk6IGN5LFxyXG4gICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcclxuICAgICAgdmVydGljYWxBbmNob3I6ICdlbmQnXHJcbiAgICB9O1xyXG4gIH1cclxuICB2YXIgciA9IChpbm5lclJhZGl1cyArIG91dGVyUmFkaXVzKSAvIDI7XHJcbiAgdmFyIF9wb2xhclRvQ2FydGVzaWFuMiA9ICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjeCwgY3ksIHIsIG1pZEFuZ2xlKSxcclxuICAgIHggPSBfcG9sYXJUb0NhcnRlc2lhbjIueCxcclxuICAgIHkgPSBfcG9sYXJUb0NhcnRlc2lhbjIueTtcclxuICByZXR1cm4ge1xyXG4gICAgeDogeCxcclxuICAgIHk6IHksXHJcbiAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcclxuICAgIHZlcnRpY2FsQW5jaG9yOiAnbWlkZGxlJ1xyXG4gIH07XHJcbn07XHJcbnZhciBnZXRBdHRyc09mQ2FydGVzaWFuTGFiZWwgPSBmdW5jdGlvbiBnZXRBdHRyc09mQ2FydGVzaWFuTGFiZWwocHJvcHMpIHtcclxuICB2YXIgdmlld0JveCA9IHByb3BzLnZpZXdCb3gsXHJcbiAgICBwYXJlbnRWaWV3Qm94ID0gcHJvcHMucGFyZW50Vmlld0JveCxcclxuICAgIG9mZnNldCA9IHByb3BzLm9mZnNldCxcclxuICAgIHBvc2l0aW9uID0gcHJvcHMucG9zaXRpb247XHJcbiAgdmFyIF9yZWYzID0gdmlld0JveCxcclxuICAgIHggPSBfcmVmMy54LFxyXG4gICAgeSA9IF9yZWYzLnksXHJcbiAgICB3aWR0aCA9IF9yZWYzLndpZHRoLFxyXG4gICAgaGVpZ2h0ID0gX3JlZjMuaGVpZ2h0O1xyXG5cclxuICAvLyBEZWZpbmUgdmVydGljYWwgb2Zmc2V0cyBhbmQgcG9zaXRpb24gaW52ZXJ0cyBiYXNlZCBvbiB0aGUgdmFsdWUgYmVpbmcgcG9zaXRpdmUgb3IgbmVnYXRpdmVcclxuICB2YXIgdmVydGljYWxTaWduID0gaGVpZ2h0ID49IDAgPyAxIDogLTE7XHJcbiAgdmFyIHZlcnRpY2FsT2Zmc2V0ID0gdmVydGljYWxTaWduICogb2Zmc2V0O1xyXG4gIHZhciB2ZXJ0aWNhbEVuZCA9IHZlcnRpY2FsU2lnbiA+IDAgPyAnZW5kJyA6ICdzdGFydCc7XHJcbiAgdmFyIHZlcnRpY2FsU3RhcnQgPSB2ZXJ0aWNhbFNpZ24gPiAwID8gJ3N0YXJ0JyA6ICdlbmQnO1xyXG5cclxuICAvLyBEZWZpbmUgaG9yaXpvbnRhbCBvZmZzZXRzIGFuZCBwb3NpdGlvbiBpbnZlcnRzIGJhc2VkIG9uIHRoZSB2YWx1ZSBiZWluZyBwb3NpdGl2ZSBvciBuZWdhdGl2ZVxyXG4gIHZhciBob3Jpem9udGFsU2lnbiA9IHdpZHRoID49IDAgPyAxIDogLTE7XHJcbiAgdmFyIGhvcml6b250YWxPZmZzZXQgPSBob3Jpem9udGFsU2lnbiAqIG9mZnNldDtcclxuICB2YXIgaG9yaXpvbnRhbEVuZCA9IGhvcml6b250YWxTaWduID4gMCA/ICdlbmQnIDogJ3N0YXJ0JztcclxuICB2YXIgaG9yaXpvbnRhbFN0YXJ0ID0gaG9yaXpvbnRhbFNpZ24gPiAwID8gJ3N0YXJ0JyA6ICdlbmQnO1xyXG4gIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcclxuICAgIHZhciBhdHRycyA9IHtcclxuICAgICAgeDogeCArIHdpZHRoIC8gMixcclxuICAgICAgeTogeSAtIHZlcnRpY2FsU2lnbiAqIG9mZnNldCxcclxuICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXHJcbiAgICAgIHZlcnRpY2FsQW5jaG9yOiB2ZXJ0aWNhbEVuZFxyXG4gICAgfTtcclxuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGF0dHJzKSwgcGFyZW50Vmlld0JveCA/IHtcclxuICAgICAgaGVpZ2h0OiBNYXRoLm1heCh5IC0gcGFyZW50Vmlld0JveC55LCAwKSxcclxuICAgICAgd2lkdGg6IHdpZHRoXHJcbiAgICB9IDoge30pO1xyXG4gIH1cclxuICBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XHJcbiAgICB2YXIgX2F0dHJzID0ge1xyXG4gICAgICB4OiB4ICsgd2lkdGggLyAyLFxyXG4gICAgICB5OiB5ICsgaGVpZ2h0ICsgdmVydGljYWxPZmZzZXQsXHJcbiAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxyXG4gICAgICB2ZXJ0aWNhbEFuY2hvcjogdmVydGljYWxTdGFydFxyXG4gICAgfTtcclxuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF9hdHRycyksIHBhcmVudFZpZXdCb3ggPyB7XHJcbiAgICAgIGhlaWdodDogTWF0aC5tYXgocGFyZW50Vmlld0JveC55ICsgcGFyZW50Vmlld0JveC5oZWlnaHQgLSAoeSArIGhlaWdodCksIDApLFxyXG4gICAgICB3aWR0aDogd2lkdGhcclxuICAgIH0gOiB7fSk7XHJcbiAgfVxyXG4gIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XHJcbiAgICB2YXIgX2F0dHJzMiA9IHtcclxuICAgICAgeDogeCAtIGhvcml6b250YWxPZmZzZXQsXHJcbiAgICAgIHk6IHkgKyBoZWlnaHQgLyAyLFxyXG4gICAgICB0ZXh0QW5jaG9yOiBob3Jpem9udGFsRW5kLFxyXG4gICAgICB2ZXJ0aWNhbEFuY2hvcjogJ21pZGRsZSdcclxuICAgIH07XHJcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfYXR0cnMyKSwgcGFyZW50Vmlld0JveCA/IHtcclxuICAgICAgd2lkdGg6IE1hdGgubWF4KF9hdHRyczIueCAtIHBhcmVudFZpZXdCb3gueCwgMCksXHJcbiAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICB9IDoge30pO1xyXG4gIH1cclxuICBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcclxuICAgIHZhciBfYXR0cnMzID0ge1xyXG4gICAgICB4OiB4ICsgd2lkdGggKyBob3Jpem9udGFsT2Zmc2V0LFxyXG4gICAgICB5OiB5ICsgaGVpZ2h0IC8gMixcclxuICAgICAgdGV4dEFuY2hvcjogaG9yaXpvbnRhbFN0YXJ0LFxyXG4gICAgICB2ZXJ0aWNhbEFuY2hvcjogJ21pZGRsZSdcclxuICAgIH07XHJcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfYXR0cnMzKSwgcGFyZW50Vmlld0JveCA/IHtcclxuICAgICAgd2lkdGg6IE1hdGgubWF4KHBhcmVudFZpZXdCb3gueCArIHBhcmVudFZpZXdCb3gud2lkdGggLSBfYXR0cnMzLngsIDApLFxyXG4gICAgICBoZWlnaHQ6IGhlaWdodFxyXG4gICAgfSA6IHt9KTtcclxuICB9XHJcbiAgdmFyIHNpemVBdHRycyA9IHBhcmVudFZpZXdCb3ggPyB7XHJcbiAgICB3aWR0aDogd2lkdGgsXHJcbiAgICBoZWlnaHQ6IGhlaWdodFxyXG4gIH0gOiB7fTtcclxuICBpZiAocG9zaXRpb24gPT09ICdpbnNpZGVMZWZ0Jykge1xyXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xyXG4gICAgICB4OiB4ICsgaG9yaXpvbnRhbE9mZnNldCxcclxuICAgICAgeTogeSArIGhlaWdodCAvIDIsXHJcbiAgICAgIHRleHRBbmNob3I6IGhvcml6b250YWxTdGFydCxcclxuICAgICAgdmVydGljYWxBbmNob3I6ICdtaWRkbGUnXHJcbiAgICB9LCBzaXplQXR0cnMpO1xyXG4gIH1cclxuICBpZiAocG9zaXRpb24gPT09ICdpbnNpZGVSaWdodCcpIHtcclxuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHtcclxuICAgICAgeDogeCArIHdpZHRoIC0gaG9yaXpvbnRhbE9mZnNldCxcclxuICAgICAgeTogeSArIGhlaWdodCAvIDIsXHJcbiAgICAgIHRleHRBbmNob3I6IGhvcml6b250YWxFbmQsXHJcbiAgICAgIHZlcnRpY2FsQW5jaG9yOiAnbWlkZGxlJ1xyXG4gICAgfSwgc2l6ZUF0dHJzKTtcclxuICB9XHJcbiAgaWYgKHBvc2l0aW9uID09PSAnaW5zaWRlVG9wJykge1xyXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xyXG4gICAgICB4OiB4ICsgd2lkdGggLyAyLFxyXG4gICAgICB5OiB5ICsgdmVydGljYWxPZmZzZXQsXHJcbiAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxyXG4gICAgICB2ZXJ0aWNhbEFuY2hvcjogdmVydGljYWxTdGFydFxyXG4gICAgfSwgc2l6ZUF0dHJzKTtcclxuICB9XHJcbiAgaWYgKHBvc2l0aW9uID09PSAnaW5zaWRlQm90dG9tJykge1xyXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xyXG4gICAgICB4OiB4ICsgd2lkdGggLyAyLFxyXG4gICAgICB5OiB5ICsgaGVpZ2h0IC0gdmVydGljYWxPZmZzZXQsXHJcbiAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxyXG4gICAgICB2ZXJ0aWNhbEFuY2hvcjogdmVydGljYWxFbmRcclxuICAgIH0sIHNpemVBdHRycyk7XHJcbiAgfVxyXG4gIGlmIChwb3NpdGlvbiA9PT0gJ2luc2lkZVRvcExlZnQnKSB7XHJcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7XHJcbiAgICAgIHg6IHggKyBob3Jpem9udGFsT2Zmc2V0LFxyXG4gICAgICB5OiB5ICsgdmVydGljYWxPZmZzZXQsXHJcbiAgICAgIHRleHRBbmNob3I6IGhvcml6b250YWxTdGFydCxcclxuICAgICAgdmVydGljYWxBbmNob3I6IHZlcnRpY2FsU3RhcnRcclxuICAgIH0sIHNpemVBdHRycyk7XHJcbiAgfVxyXG4gIGlmIChwb3NpdGlvbiA9PT0gJ2luc2lkZVRvcFJpZ2h0Jykge1xyXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xyXG4gICAgICB4OiB4ICsgd2lkdGggLSBob3Jpem9udGFsT2Zmc2V0LFxyXG4gICAgICB5OiB5ICsgdmVydGljYWxPZmZzZXQsXHJcbiAgICAgIHRleHRBbmNob3I6IGhvcml6b250YWxFbmQsXHJcbiAgICAgIHZlcnRpY2FsQW5jaG9yOiB2ZXJ0aWNhbFN0YXJ0XHJcbiAgICB9LCBzaXplQXR0cnMpO1xyXG4gIH1cclxuICBpZiAocG9zaXRpb24gPT09ICdpbnNpZGVCb3R0b21MZWZ0Jykge1xyXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xyXG4gICAgICB4OiB4ICsgaG9yaXpvbnRhbE9mZnNldCxcclxuICAgICAgeTogeSArIGhlaWdodCAtIHZlcnRpY2FsT2Zmc2V0LFxyXG4gICAgICB0ZXh0QW5jaG9yOiBob3Jpem9udGFsU3RhcnQsXHJcbiAgICAgIHZlcnRpY2FsQW5jaG9yOiB2ZXJ0aWNhbEVuZFxyXG4gICAgfSwgc2l6ZUF0dHJzKTtcclxuICB9XHJcbiAgaWYgKHBvc2l0aW9uID09PSAnaW5zaWRlQm90dG9tUmlnaHQnKSB7XHJcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7XHJcbiAgICAgIHg6IHggKyB3aWR0aCAtIGhvcml6b250YWxPZmZzZXQsXHJcbiAgICAgIHk6IHkgKyBoZWlnaHQgLSB2ZXJ0aWNhbE9mZnNldCxcclxuICAgICAgdGV4dEFuY2hvcjogaG9yaXpvbnRhbEVuZCxcclxuICAgICAgdmVydGljYWxBbmNob3I6IHZlcnRpY2FsRW5kXHJcbiAgICB9LCBzaXplQXR0cnMpO1xyXG4gIH1cclxuICBpZiAoKDAsIF9pc09iamVjdFtcImRlZmF1bHRcIl0pKHBvc2l0aW9uKSAmJiAoKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHBvc2l0aW9uLngpIHx8ICgwLCBfRGF0YVV0aWxzLmlzUGVyY2VudCkocG9zaXRpb24ueCkpICYmICgoMCwgX0RhdGFVdGlscy5pc051bWJlcikocG9zaXRpb24ueSkgfHwgKDAsIF9EYXRhVXRpbHMuaXNQZXJjZW50KShwb3NpdGlvbi55KSkpIHtcclxuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHtcclxuICAgICAgeDogeCArICgwLCBfRGF0YVV0aWxzLmdldFBlcmNlbnRWYWx1ZSkocG9zaXRpb24ueCwgd2lkdGgpLFxyXG4gICAgICB5OiB5ICsgKDAsIF9EYXRhVXRpbHMuZ2V0UGVyY2VudFZhbHVlKShwb3NpdGlvbi55LCBoZWlnaHQpLFxyXG4gICAgICB0ZXh0QW5jaG9yOiAnZW5kJyxcclxuICAgICAgdmVydGljYWxBbmNob3I6ICdlbmQnXHJcbiAgICB9LCBzaXplQXR0cnMpO1xyXG4gIH1cclxuICByZXR1cm4gX29iamVjdFNwcmVhZCh7XHJcbiAgICB4OiB4ICsgd2lkdGggLyAyLFxyXG4gICAgeTogeSArIGhlaWdodCAvIDIsXHJcbiAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcclxuICAgIHZlcnRpY2FsQW5jaG9yOiAnbWlkZGxlJ1xyXG4gIH0sIHNpemVBdHRycyk7XHJcbn07XHJcbnZhciBpc1BvbGFyID0gZnVuY3Rpb24gaXNQb2xhcih2aWV3Qm94KSB7XHJcbiAgcmV0dXJuICdjeCcgaW4gdmlld0JveCAmJiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikodmlld0JveC5jeCk7XHJcbn07XHJcbmZ1bmN0aW9uIExhYmVsKF9yZWY0KSB7XHJcbiAgdmFyIF9yZWY0JG9mZnNldCA9IF9yZWY0Lm9mZnNldCxcclxuICAgIG9mZnNldCA9IF9yZWY0JG9mZnNldCA9PT0gdm9pZCAwID8gNSA6IF9yZWY0JG9mZnNldCxcclxuICAgIHJlc3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmNCwgX2V4Y2x1ZGVkKTtcclxuICB2YXIgcHJvcHMgPSBfb2JqZWN0U3ByZWFkKHtcclxuICAgIG9mZnNldDogb2Zmc2V0XHJcbiAgfSwgcmVzdFByb3BzKTtcclxuICB2YXIgdmlld0JveCA9IHByb3BzLnZpZXdCb3gsXHJcbiAgICBwb3NpdGlvbiA9IHByb3BzLnBvc2l0aW9uLFxyXG4gICAgdmFsdWUgPSBwcm9wcy52YWx1ZSxcclxuICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXHJcbiAgICBjb250ZW50ID0gcHJvcHMuY29udGVudCxcclxuICAgIF9wcm9wcyRjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXHJcbiAgICBjbGFzc05hbWUgPSBfcHJvcHMkY2xhc3NOYW1lID09PSB2b2lkIDAgPyAnJyA6IF9wcm9wcyRjbGFzc05hbWUsXHJcbiAgICB0ZXh0QnJlYWtBbGwgPSBwcm9wcy50ZXh0QnJlYWtBbGw7XHJcbiAgaWYgKCF2aWV3Qm94IHx8ICgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKSh2YWx1ZSkgJiYgKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGNoaWxkcmVuKSAmJiAhIC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmlzVmFsaWRFbGVtZW50KShjb250ZW50KSAmJiAhKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkoY29udGVudCkpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICBpZiAoIC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmlzVmFsaWRFbGVtZW50KShjb250ZW50KSkge1xyXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNsb25lRWxlbWVudCkoY29udGVudCwgcHJvcHMpO1xyXG4gIH1cclxuICB2YXIgbGFiZWw7XHJcbiAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKGNvbnRlbnQpKSB7XHJcbiAgICBsYWJlbCA9IC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNyZWF0ZUVsZW1lbnQpKGNvbnRlbnQsIHByb3BzKTtcclxuICAgIGlmICggLyojX19QVVJFX18qLygwLCBfcmVhY3QuaXNWYWxpZEVsZW1lbnQpKGxhYmVsKSkge1xyXG4gICAgICByZXR1cm4gbGFiZWw7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGxhYmVsID0gZ2V0TGFiZWwocHJvcHMpO1xyXG4gIH1cclxuICB2YXIgaXNQb2xhckxhYmVsID0gaXNQb2xhcih2aWV3Qm94KTtcclxuICB2YXIgYXR0cnMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHByb3BzLCB0cnVlKTtcclxuICBpZiAoaXNQb2xhckxhYmVsICYmIChwb3NpdGlvbiA9PT0gJ2luc2lkZVN0YXJ0JyB8fCBwb3NpdGlvbiA9PT0gJ2luc2lkZUVuZCcgfHwgcG9zaXRpb24gPT09ICdlbmQnKSkge1xyXG4gICAgcmV0dXJuIHJlbmRlclJhZGlhbExhYmVsKHByb3BzLCBsYWJlbCwgYXR0cnMpO1xyXG4gIH1cclxuICB2YXIgcG9zaXRpb25BdHRycyA9IGlzUG9sYXJMYWJlbCA/IGdldEF0dHJzT2ZQb2xhckxhYmVsKHByb3BzKSA6IGdldEF0dHJzT2ZDYXJ0ZXNpYW5MYWJlbChwcm9wcyk7XHJcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX1RleHQuVGV4dCwgX2V4dGVuZHMoe1xyXG4gICAgY2xhc3NOYW1lOiAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtbGFiZWwnLCBjbGFzc05hbWUpXHJcbiAgfSwgYXR0cnMsIHBvc2l0aW9uQXR0cnMsIHtcclxuICAgIGJyZWFrQWxsOiB0ZXh0QnJlYWtBbGxcclxuICB9KSwgbGFiZWwpO1xyXG59XHJcbkxhYmVsLmRpc3BsYXlOYW1lID0gJ0xhYmVsJztcclxudmFyIHBhcnNlVmlld0JveCA9IGZ1bmN0aW9uIHBhcnNlVmlld0JveChwcm9wcykge1xyXG4gIHZhciBjeCA9IHByb3BzLmN4LFxyXG4gICAgY3kgPSBwcm9wcy5jeSxcclxuICAgIGFuZ2xlID0gcHJvcHMuYW5nbGUsXHJcbiAgICBzdGFydEFuZ2xlID0gcHJvcHMuc3RhcnRBbmdsZSxcclxuICAgIGVuZEFuZ2xlID0gcHJvcHMuZW5kQW5nbGUsXHJcbiAgICByID0gcHJvcHMucixcclxuICAgIHJhZGl1cyA9IHByb3BzLnJhZGl1cyxcclxuICAgIGlubmVyUmFkaXVzID0gcHJvcHMuaW5uZXJSYWRpdXMsXHJcbiAgICBvdXRlclJhZGl1cyA9IHByb3BzLm91dGVyUmFkaXVzLFxyXG4gICAgeCA9IHByb3BzLngsXHJcbiAgICB5ID0gcHJvcHMueSxcclxuICAgIHRvcCA9IHByb3BzLnRvcCxcclxuICAgIGxlZnQgPSBwcm9wcy5sZWZ0LFxyXG4gICAgd2lkdGggPSBwcm9wcy53aWR0aCxcclxuICAgIGhlaWdodCA9IHByb3BzLmhlaWdodCxcclxuICAgIGNsb2NrV2lzZSA9IHByb3BzLmNsb2NrV2lzZSxcclxuICAgIGxhYmVsVmlld0JveCA9IHByb3BzLmxhYmVsVmlld0JveDtcclxuICBpZiAobGFiZWxWaWV3Qm94KSB7XHJcbiAgICByZXR1cm4gbGFiZWxWaWV3Qm94O1xyXG4gIH1cclxuICBpZiAoKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHdpZHRoKSAmJiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikoaGVpZ2h0KSkge1xyXG4gICAgaWYgKCgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKSh4KSAmJiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikoeSkpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB4OiB4LFxyXG4gICAgICAgIHk6IHksXHJcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAoKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHRvcCkgJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGxlZnQpKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogdG9wLFxyXG4gICAgICAgIHk6IGxlZnQsXHJcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICgoMCwgX0RhdGFVdGlscy5pc051bWJlcikoeCkgJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHkpKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiB4LFxyXG4gICAgICB5OiB5LFxyXG4gICAgICB3aWR0aDogMCxcclxuICAgICAgaGVpZ2h0OiAwXHJcbiAgICB9O1xyXG4gIH1cclxuICBpZiAoKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGN4KSAmJiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikoY3kpKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjeDogY3gsXHJcbiAgICAgIGN5OiBjeSxcclxuICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSB8fCBhbmdsZSB8fCAwLFxyXG4gICAgICBlbmRBbmdsZTogZW5kQW5nbGUgfHwgYW5nbGUgfHwgMCxcclxuICAgICAgaW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzIHx8IDAsXHJcbiAgICAgIG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyB8fCByYWRpdXMgfHwgciB8fCAwLFxyXG4gICAgICBjbG9ja1dpc2U6IGNsb2NrV2lzZVxyXG4gICAgfTtcclxuICB9XHJcbiAgaWYgKHByb3BzLnZpZXdCb3gpIHtcclxuICAgIHJldHVybiBwcm9wcy52aWV3Qm94O1xyXG4gIH1cclxuICByZXR1cm4ge307XHJcbn07XHJcbnZhciBwYXJzZUxhYmVsID0gZnVuY3Rpb24gcGFyc2VMYWJlbChsYWJlbCwgdmlld0JveCkge1xyXG4gIGlmICghbGFiZWwpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICBpZiAobGFiZWwgPT09IHRydWUpIHtcclxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KExhYmVsLCB7XHJcbiAgICAgIGtleTogXCJsYWJlbC1pbXBsaWNpdFwiLFxyXG4gICAgICB2aWV3Qm94OiB2aWV3Qm94XHJcbiAgICB9KTtcclxuICB9XHJcbiAgaWYgKCgwLCBfRGF0YVV0aWxzLmlzTnVtT3JTdHIpKGxhYmVsKSkge1xyXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoTGFiZWwsIHtcclxuICAgICAga2V5OiBcImxhYmVsLWltcGxpY2l0XCIsXHJcbiAgICAgIHZpZXdCb3g6IHZpZXdCb3gsXHJcbiAgICAgIHZhbHVlOiBsYWJlbFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGlmICggLyojX19QVVJFX18qLygwLCBfcmVhY3QuaXNWYWxpZEVsZW1lbnQpKGxhYmVsKSkge1xyXG4gICAgaWYgKGxhYmVsLnR5cGUgPT09IExhYmVsKSB7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jbG9uZUVsZW1lbnQpKGxhYmVsLCB7XHJcbiAgICAgICAga2V5OiAnbGFiZWwtaW1wbGljaXQnLFxyXG4gICAgICAgIHZpZXdCb3g6IHZpZXdCb3hcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChMYWJlbCwge1xyXG4gICAgICBrZXk6IFwibGFiZWwtaW1wbGljaXRcIixcclxuICAgICAgY29udGVudDogbGFiZWwsXHJcbiAgICAgIHZpZXdCb3g6IHZpZXdCb3hcclxuICAgIH0pO1xyXG4gIH1cclxuICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkobGFiZWwpKSB7XHJcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChMYWJlbCwge1xyXG4gICAgICBrZXk6IFwibGFiZWwtaW1wbGljaXRcIixcclxuICAgICAgY29udGVudDogbGFiZWwsXHJcbiAgICAgIHZpZXdCb3g6IHZpZXdCb3hcclxuICAgIH0pO1xyXG4gIH1cclxuICBpZiAoKDAsIF9pc09iamVjdFtcImRlZmF1bHRcIl0pKGxhYmVsKSkge1xyXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoTGFiZWwsIF9leHRlbmRzKHtcclxuICAgICAgdmlld0JveDogdmlld0JveFxyXG4gICAgfSwgbGFiZWwsIHtcclxuICAgICAga2V5OiBcImxhYmVsLWltcGxpY2l0XCJcclxuICAgIH0pKTtcclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn07XHJcbnZhciByZW5kZXJDYWxsQnlQYXJlbnQgPSBmdW5jdGlvbiByZW5kZXJDYWxsQnlQYXJlbnQocGFyZW50UHJvcHMsIHZpZXdCb3gpIHtcclxuICB2YXIgY2hlY2tQcm9wc0xhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xyXG4gIGlmICghcGFyZW50UHJvcHMgfHwgIXBhcmVudFByb3BzLmNoaWxkcmVuICYmIGNoZWNrUHJvcHNMYWJlbCAmJiAhcGFyZW50UHJvcHMubGFiZWwpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICB2YXIgY2hpbGRyZW4gPSBwYXJlbnRQcm9wcy5jaGlsZHJlbjtcclxuICB2YXIgcGFyZW50Vmlld0JveCA9IHBhcnNlVmlld0JveChwYXJlbnRQcm9wcyk7XHJcbiAgdmFyIGV4cGxpY2l0Q2hpbGRyZW4gPSAoMCwgX1JlYWN0VXRpbHMuZmluZEFsbEJ5VHlwZSkoY2hpbGRyZW4sIExhYmVsKS5tYXAoZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xyXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNsb25lRWxlbWVudCkoY2hpbGQsIHtcclxuICAgICAgdmlld0JveDogdmlld0JveCB8fCBwYXJlbnRWaWV3Qm94LFxyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XHJcbiAgICAgIGtleTogXCJsYWJlbC1cIi5jb25jYXQoaW5kZXgpXHJcbiAgICB9KTtcclxuICB9KTtcclxuICBpZiAoIWNoZWNrUHJvcHNMYWJlbCkge1xyXG4gICAgcmV0dXJuIGV4cGxpY2l0Q2hpbGRyZW47XHJcbiAgfVxyXG4gIHZhciBpbXBsaWNpdExhYmVsID0gcGFyc2VMYWJlbChwYXJlbnRQcm9wcy5sYWJlbCwgdmlld0JveCB8fCBwYXJlbnRWaWV3Qm94KTtcclxuICByZXR1cm4gW2ltcGxpY2l0TGFiZWxdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZXhwbGljaXRDaGlsZHJlbikpO1xyXG59O1xyXG5MYWJlbC5wYXJzZVZpZXdCb3ggPSBwYXJzZVZpZXdCb3g7XHJcbkxhYmVsLnJlbmRlckNhbGxCeVBhcmVudCA9IHJlbmRlckNhbGxCeVBhcmVudDsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTGFiZWwiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfaXNOaWwiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2lzRnVuY3Rpb24iLCJfaXNPYmplY3QiLCJfY2xzeCIsIl9UZXh0IiwiX1JlYWN0VXRpbHMiLCJfRGF0YVV0aWxzIiwiX1BvbGFyVXRpbHMiLCJfZXhjbHVkZWQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiVHlwZUVycm9yIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJ0b1N0cmluZyIsInNsaWNlIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJpdGVyIiwiaXNBcnJheSIsImxlbiIsImxlbmd0aCIsImFycjIiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJzb3VyY2UiLCJleGNsdWRlZCIsInRhcmdldCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwia2V5IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIm93bktleXMiLCJrZXlzIiwiZmlsdGVyIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJnZXRMYWJlbCIsInByb3BzIiwiZm9ybWF0dGVyIiwibGFiZWwiLCJjaGlsZHJlbiIsImdldERlbHRhQW5nbGUiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJzaWduIiwibWF0aFNpZ24iLCJkZWx0YUFuZ2xlIiwiTWF0aCIsIm1pbiIsImFicyIsInJlbmRlclJhZGlhbExhYmVsIiwibGFiZWxQcm9wcyIsImF0dHJzIiwicG9zaXRpb24iLCJ2aWV3Qm94Iiwib2Zmc2V0IiwiY2xhc3NOYW1lIiwiX3JlZiIsImN4IiwiY3kiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIiwiY2xvY2tXaXNlIiwicmFkaXVzIiwibGFiZWxBbmdsZSIsImRpcmVjdGlvbiIsInN0YXJ0UG9pbnQiLCJwb2xhclRvQ2FydGVzaWFuIiwiZW5kUG9pbnQiLCJwYXRoIiwiY29uY2F0IiwieCIsInkiLCJpZCIsInVuaXF1ZUlkIiwiY3JlYXRlRWxlbWVudCIsImRvbWluYW50QmFzZWxpbmUiLCJkIiwieGxpbmtIcmVmIiwiZ2V0QXR0cnNPZlBvbGFyTGFiZWwiLCJfcmVmMiIsIm1pZEFuZ2xlIiwiX3BvbGFyVG9DYXJ0ZXNpYW4iLCJfeCIsIl95IiwidGV4dEFuY2hvciIsInZlcnRpY2FsQW5jaG9yIiwiX3BvbGFyVG9DYXJ0ZXNpYW4yIiwiZ2V0QXR0cnNPZkNhcnRlc2lhbkxhYmVsIiwicGFyZW50Vmlld0JveCIsIl9yZWYzIiwid2lkdGgiLCJoZWlnaHQiLCJ2ZXJ0aWNhbFNpZ24iLCJ2ZXJ0aWNhbE9mZnNldCIsInZlcnRpY2FsRW5kIiwidmVydGljYWxTdGFydCIsImhvcml6b250YWxTaWduIiwiaG9yaXpvbnRhbE9mZnNldCIsImhvcml6b250YWxFbmQiLCJob3Jpem9udGFsU3RhcnQiLCJtYXgiLCJfYXR0cnMiLCJfYXR0cnMyIiwiX2F0dHJzMyIsInNpemVBdHRycyIsImlzTnVtYmVyIiwiaXNQZXJjZW50IiwiZ2V0UGVyY2VudFZhbHVlIiwiaXNQb2xhciIsIl9yZWY0IiwiX3JlZjQkb2Zmc2V0IiwicmVzdFByb3BzIiwiY29udGVudCIsIl9wcm9wcyRjbGFzc05hbWUiLCJ0ZXh0QnJlYWtBbGwiLCJpc1ZhbGlkRWxlbWVudCIsImNsb25lRWxlbWVudCIsImlzUG9sYXJMYWJlbCIsImZpbHRlclByb3BzIiwicG9zaXRpb25BdHRycyIsIlRleHQiLCJicmVha0FsbCIsImRpc3BsYXlOYW1lIiwicGFyc2VWaWV3Qm94IiwiYW5nbGUiLCJ0b3AiLCJsZWZ0IiwibGFiZWxWaWV3Qm94IiwicGFyc2VMYWJlbCIsImlzTnVtT3JTdHIiLCJ0eXBlIiwicmVuZGVyQ2FsbEJ5UGFyZW50IiwicGFyZW50UHJvcHMiLCJjaGVja1Byb3BzTGFiZWwiLCJ1bmRlZmluZWQiLCJleHBsaWNpdENoaWxkcmVuIiwiZmluZEFsbEJ5VHlwZSIsIm1hcCIsImNoaWxkIiwiaW5kZXgiLCJpbXBsaWNpdExhYmVsIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/component/Label.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/component/LabelList.js":
/*!**********************************************************!*\
  !*** ./node_modules/recharts/lib/component/LabelList.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LabelList = LabelList;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _isObject = _interopRequireDefault(__webpack_require__(/*! lodash/isObject */ \"lodash/isObject\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _last = _interopRequireDefault(__webpack_require__(/*! lodash/last */ \"lodash/last\"));\nvar _Label = __webpack_require__(/*! ./Label */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Label.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _excluded = [\n    \"valueAccessor\"\n], _excluded2 = [\n    \"data\",\n    \"dataKey\",\n    \"clockWise\",\n    \"id\",\n    \"textBreakAll\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nvar defaultAccessor = function defaultAccessor(entry) {\n    return Array.isArray(entry.value) ? (0, _last[\"default\"])(entry.value) : entry.value;\n};\nfunction LabelList(_ref) {\n    var _ref$valueAccessor = _ref.valueAccessor, valueAccessor = _ref$valueAccessor === void 0 ? defaultAccessor : _ref$valueAccessor, restProps = _objectWithoutProperties(_ref, _excluded);\n    var data = restProps.data, dataKey = restProps.dataKey, clockWise = restProps.clockWise, id = restProps.id, textBreakAll = restProps.textBreakAll, others = _objectWithoutProperties(restProps, _excluded2);\n    if (!data || !data.length) {\n        return null;\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n        className: \"recharts-label-list\"\n    }, data.map(function(entry, index) {\n        var value = (0, _isNil[\"default\"])(dataKey) ? valueAccessor(entry, index) : (0, _ChartUtils.getValueByDataKey)(entry && entry.payload, dataKey);\n        var idProps = (0, _isNil[\"default\"])(id) ? {} : {\n            id: \"\".concat(id, \"-\").concat(index)\n        };\n        return /*#__PURE__*/ _react[\"default\"].createElement(_Label.Label, _extends({}, (0, _ReactUtils.filterProps)(entry, true), others, idProps, {\n            parentViewBox: entry.parentViewBox,\n            value: value,\n            textBreakAll: textBreakAll,\n            viewBox: _Label.Label.parseViewBox((0, _isNil[\"default\"])(clockWise) ? entry : _objectSpread(_objectSpread({}, entry), {}, {\n                clockWise: clockWise\n            })),\n            key: \"label-\".concat(index) // eslint-disable-line react/no-array-index-key\n            ,\n            index: index\n        }));\n    }));\n}\nLabelList.displayName = 'LabelList';\nfunction parseLabelList(label, data) {\n    if (!label) {\n        return null;\n    }\n    if (label === true) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(LabelList, {\n            key: \"labelList-implicit\",\n            data: data\n        });\n    }\n    if (/*#__PURE__*/ _react[\"default\"].isValidElement(label) || (0, _isFunction[\"default\"])(label)) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(LabelList, {\n            key: \"labelList-implicit\",\n            data: data,\n            content: label\n        });\n    }\n    if ((0, _isObject[\"default\"])(label)) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(LabelList, _extends({\n            data: data\n        }, label, {\n            key: \"labelList-implicit\"\n        }));\n    }\n    return null;\n}\nfunction renderCallByParent(parentProps, data) {\n    var checkPropsLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (!parentProps || !parentProps.children && checkPropsLabel && !parentProps.label) {\n        return null;\n    }\n    var children = parentProps.children;\n    var explicitChildren = (0, _ReactUtils.findAllByType)(children, LabelList).map(function(child, index) {\n        return /*#__PURE__*/ (0, _react.cloneElement)(child, {\n            data: data,\n            // eslint-disable-next-line react/no-array-index-key\n            key: \"labelList-\".concat(index)\n        });\n    });\n    if (!checkPropsLabel) {\n        return explicitChildren;\n    }\n    var implicitLabelList = parseLabelList(parentProps.label, data);\n    return [\n        implicitLabelList\n    ].concat(_toConsumableArray(explicitChildren));\n}\nLabelList.renderCallByParent = renderCallByParent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY29tcG9uZW50L0xhYmVsTGlzdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFLFdBQVcsS0FBS0MsVUFBVUQsTUFBTUMsT0FBT0UsU0FBUyxHQUFHLFdBQVcsT0FBT0g7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdUSSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsaUJBQWlCLEdBQUdFO0FBQ3BCLElBQUlDLFNBQVNDLHdCQUF3QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUMsU0FBU0MsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJRyxZQUFZRCx1QkFBdUJGLG1CQUFPQSxDQUFDLHdDQUFpQjtBQUNoRSxJQUFJSSxjQUFjRix1QkFBdUJGLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJSyxRQUFRSCx1QkFBdUJGLG1CQUFPQSxDQUFDLGdDQUFhO0FBQ3hELElBQUlNLFNBQVNOLG1CQUFPQSxDQUFDLGdGQUFTO0FBQzlCLElBQUlPLFNBQVNQLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUN6QyxJQUFJUSxjQUFjUixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDOUMsSUFBSVMsY0FBY1QsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlVLFlBQVk7SUFBQztDQUFnQixFQUMvQkMsYUFBYTtJQUFDO0lBQVE7SUFBVztJQUFhO0lBQU07Q0FBZTtBQUNyRSxTQUFTVCx1QkFBdUJVLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxV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QUFDLFVBQVUsQ0FBQ2dHLGFBQWEsQ0FBQ2pHLFdBQVdxRCxTQUFTO1lBQ3RFc0MsTUFBTUE7UUFDUixHQUFHc0IsT0FBTztZQUNSdEQsS0FBSztRQUNQO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxTQUFTeUQsbUJBQW1CQyxXQUFXLEVBQUUxQixJQUFJO0lBQzNDLElBQUkyQixrQkFBa0I3RCxVQUFVTixNQUFNLEdBQUcsS0FBS00sU0FBUyxDQUFDLEVBQUUsS0FBSzhELFlBQVk5RCxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQzFGLElBQUksQ0FBQzRELGVBQWUsQ0FBQ0EsWUFBWUcsUUFBUSxJQUFJRixtQkFBbUIsQ0FBQ0QsWUFBWUosS0FBSyxFQUFFO1FBQ2xGLE9BQU87SUFDVDtJQUNBLElBQUlPLFdBQVdILFlBQVlHLFFBQVE7SUFDbkMsSUFBSUMsbUJBQW1CLENBQUMsR0FBRzlHLFlBQVkrRyxhQUFhLEVBQUVGLFVBQVV4SCxXQUFXb0csR0FBRyxDQUFDLFNBQVV1QixLQUFLLEVBQUV0QixLQUFLO1FBQ25HLE9BQW9CLFdBQUYsR0FBRyxJQUFHcEcsT0FBTzJILFlBQVksRUFBRUQsT0FBTztZQUNsRGhDLE1BQU1BO1lBQ04sb0RBQW9EO1lBQ3BEaEMsS0FBSyxhQUFhOEMsTUFBTSxDQUFDSjtRQUMzQjtJQUNGO0lBQ0EsSUFBSSxDQUFDaUIsaUJBQWlCO1FBQ3BCLE9BQU9HO0lBQ1Q7SUFDQSxJQUFJSSxvQkFBb0JiLGVBQWVLLFlBQVlKLEtBQUssRUFBRXRCO0lBQzFELE9BQU87UUFBQ2tDO0tBQWtCLENBQUNwQixNQUFNLENBQUN4RSxtQkFBbUJ3RjtBQUN2RDtBQUNBekgsVUFBVW9ILGtCQUFrQixHQUFHQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcY29tcG9uZW50XFxMYWJlbExpc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLkxhYmVsTGlzdCA9IExhYmVsTGlzdDtcclxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBfaXNOaWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNOaWxcIikpO1xyXG52YXIgX2lzT2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzT2JqZWN0XCIpKTtcclxudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xyXG52YXIgX2xhc3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvbGFzdFwiKSk7XHJcbnZhciBfTGFiZWwgPSByZXF1aXJlKFwiLi9MYWJlbFwiKTtcclxudmFyIF9MYXllciA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvTGF5ZXJcIik7XHJcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XHJcbnZhciBfQ2hhcnRVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NoYXJ0VXRpbHNcIik7XHJcbnZhciBfZXhjbHVkZWQgPSBbXCJ2YWx1ZUFjY2Vzc29yXCJdLFxyXG4gIF9leGNsdWRlZDIgPSBbXCJkYXRhXCIsIFwiZGF0YUtleVwiLCBcImNsb2NrV2lzZVwiLCBcImlkXCIsIFwidGV4dEJyZWFrQWxsXCJdO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cclxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XHJcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cclxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XHJcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxyXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XHJcbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XHJcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxyXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XHJcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxudmFyIGRlZmF1bHRBY2Nlc3NvciA9IGZ1bmN0aW9uIGRlZmF1bHRBY2Nlc3NvcihlbnRyeSkge1xyXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGVudHJ5LnZhbHVlKSA/ICgwLCBfbGFzdFtcImRlZmF1bHRcIl0pKGVudHJ5LnZhbHVlKSA6IGVudHJ5LnZhbHVlO1xyXG59O1xyXG5mdW5jdGlvbiBMYWJlbExpc3QoX3JlZikge1xyXG4gIHZhciBfcmVmJHZhbHVlQWNjZXNzb3IgPSBfcmVmLnZhbHVlQWNjZXNzb3IsXHJcbiAgICB2YWx1ZUFjY2Vzc29yID0gX3JlZiR2YWx1ZUFjY2Vzc29yID09PSB2b2lkIDAgPyBkZWZhdWx0QWNjZXNzb3IgOiBfcmVmJHZhbHVlQWNjZXNzb3IsXHJcbiAgICByZXN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkKTtcclxuICB2YXIgZGF0YSA9IHJlc3RQcm9wcy5kYXRhLFxyXG4gICAgZGF0YUtleSA9IHJlc3RQcm9wcy5kYXRhS2V5LFxyXG4gICAgY2xvY2tXaXNlID0gcmVzdFByb3BzLmNsb2NrV2lzZSxcclxuICAgIGlkID0gcmVzdFByb3BzLmlkLFxyXG4gICAgdGV4dEJyZWFrQWxsID0gcmVzdFByb3BzLnRleHRCcmVha0FsbCxcclxuICAgIG90aGVycyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhyZXN0UHJvcHMsIF9leGNsdWRlZDIpO1xyXG4gIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIHtcclxuICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1sYWJlbC1saXN0XCJcclxuICB9LCBkYXRhLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XHJcbiAgICB2YXIgdmFsdWUgPSAoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoZGF0YUtleSkgPyB2YWx1ZUFjY2Vzc29yKGVudHJ5LCBpbmRleCkgOiAoMCwgX0NoYXJ0VXRpbHMuZ2V0VmFsdWVCeURhdGFLZXkpKGVudHJ5ICYmIGVudHJ5LnBheWxvYWQsIGRhdGFLZXkpO1xyXG4gICAgdmFyIGlkUHJvcHMgPSAoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoaWQpID8ge30gOiB7XHJcbiAgICAgIGlkOiBcIlwiLmNvbmNhdChpZCwgXCItXCIpLmNvbmNhdChpbmRleClcclxuICAgIH07XHJcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGFiZWwuTGFiZWwsIF9leHRlbmRzKHt9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKGVudHJ5LCB0cnVlKSwgb3RoZXJzLCBpZFByb3BzLCB7XHJcbiAgICAgIHBhcmVudFZpZXdCb3g6IGVudHJ5LnBhcmVudFZpZXdCb3gsXHJcbiAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgdGV4dEJyZWFrQWxsOiB0ZXh0QnJlYWtBbGwsXHJcbiAgICAgIHZpZXdCb3g6IF9MYWJlbC5MYWJlbC5wYXJzZVZpZXdCb3goKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGNsb2NrV2lzZSkgPyBlbnRyeSA6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xyXG4gICAgICAgIGNsb2NrV2lzZTogY2xvY2tXaXNlXHJcbiAgICAgIH0pKSxcclxuICAgICAga2V5OiBcImxhYmVsLVwiLmNvbmNhdChpbmRleCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC9uby1hcnJheS1pbmRleC1rZXlcclxuICAgICAgLFxyXG4gICAgICBpbmRleDogaW5kZXhcclxuICAgIH0pKTtcclxuICB9KSk7XHJcbn1cclxuTGFiZWxMaXN0LmRpc3BsYXlOYW1lID0gJ0xhYmVsTGlzdCc7XHJcbmZ1bmN0aW9uIHBhcnNlTGFiZWxMaXN0KGxhYmVsLCBkYXRhKSB7XHJcbiAgaWYgKCFsYWJlbCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIGlmIChsYWJlbCA9PT0gdHJ1ZSkge1xyXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoTGFiZWxMaXN0LCB7XHJcbiAgICAgIGtleTogXCJsYWJlbExpc3QtaW1wbGljaXRcIixcclxuICAgICAgZGF0YTogZGF0YVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGlmICggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uaXNWYWxpZEVsZW1lbnQobGFiZWwpIHx8ICgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKGxhYmVsKSkge1xyXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoTGFiZWxMaXN0LCB7XHJcbiAgICAgIGtleTogXCJsYWJlbExpc3QtaW1wbGljaXRcIixcclxuICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgY29udGVudDogbGFiZWxcclxuICAgIH0pO1xyXG4gIH1cclxuICBpZiAoKDAsIF9pc09iamVjdFtcImRlZmF1bHRcIl0pKGxhYmVsKSkge1xyXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoTGFiZWxMaXN0LCBfZXh0ZW5kcyh7XHJcbiAgICAgIGRhdGE6IGRhdGFcclxuICAgIH0sIGxhYmVsLCB7XHJcbiAgICAgIGtleTogXCJsYWJlbExpc3QtaW1wbGljaXRcIlxyXG4gICAgfSkpO1xyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJDYWxsQnlQYXJlbnQocGFyZW50UHJvcHMsIGRhdGEpIHtcclxuICB2YXIgY2hlY2tQcm9wc0xhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xyXG4gIGlmICghcGFyZW50UHJvcHMgfHwgIXBhcmVudFByb3BzLmNoaWxkcmVuICYmIGNoZWNrUHJvcHNMYWJlbCAmJiAhcGFyZW50UHJvcHMubGFiZWwpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICB2YXIgY2hpbGRyZW4gPSBwYXJlbnRQcm9wcy5jaGlsZHJlbjtcclxuICB2YXIgZXhwbGljaXRDaGlsZHJlbiA9ICgwLCBfUmVhY3RVdGlscy5maW5kQWxsQnlUeXBlKShjaGlsZHJlbiwgTGFiZWxMaXN0KS5tYXAoZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xyXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNsb25lRWxlbWVudCkoY2hpbGQsIHtcclxuICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxyXG4gICAgICBrZXk6IFwibGFiZWxMaXN0LVwiLmNvbmNhdChpbmRleClcclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIGlmICghY2hlY2tQcm9wc0xhYmVsKSB7XHJcbiAgICByZXR1cm4gZXhwbGljaXRDaGlsZHJlbjtcclxuICB9XHJcbiAgdmFyIGltcGxpY2l0TGFiZWxMaXN0ID0gcGFyc2VMYWJlbExpc3QocGFyZW50UHJvcHMubGFiZWwsIGRhdGEpO1xyXG4gIHJldHVybiBbaW1wbGljaXRMYWJlbExpc3RdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZXhwbGljaXRDaGlsZHJlbikpO1xyXG59XHJcbkxhYmVsTGlzdC5yZW5kZXJDYWxsQnlQYXJlbnQgPSByZW5kZXJDYWxsQnlQYXJlbnQ7Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkxhYmVsTGlzdCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9pc05pbCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfaXNPYmplY3QiLCJfaXNGdW5jdGlvbiIsIl9sYXN0IiwiX0xhYmVsIiwiX0xheWVyIiwiX1JlYWN0VXRpbHMiLCJfQ2hhcnRVdGlscyIsIl9leGNsdWRlZCIsIl9leGNsdWRlZDIiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiVHlwZUVycm9yIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJ0b1N0cmluZyIsInNsaWNlIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJpdGVyIiwiaXNBcnJheSIsImxlbiIsImxlbmd0aCIsImFycjIiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJzb3VyY2UiLCJrZXkiLCJhcHBseSIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsInNvdXJjZVN5bWJvbEtleXMiLCJpbmRleE9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJkZWZhdWx0QWNjZXNzb3IiLCJlbnRyeSIsIl9yZWYiLCJfcmVmJHZhbHVlQWNjZXNzb3IiLCJ2YWx1ZUFjY2Vzc29yIiwicmVzdFByb3BzIiwiZGF0YSIsImRhdGFLZXkiLCJjbG9ja1dpc2UiLCJpZCIsInRleHRCcmVha0FsbCIsIm90aGVycyIsImNyZWF0ZUVsZW1lbnQiLCJMYXllciIsImNsYXNzTmFtZSIsIm1hcCIsImluZGV4IiwiZ2V0VmFsdWVCeURhdGFLZXkiLCJwYXlsb2FkIiwiaWRQcm9wcyIsImNvbmNhdCIsIkxhYmVsIiwiZmlsdGVyUHJvcHMiLCJwYXJlbnRWaWV3Qm94Iiwidmlld0JveCIsInBhcnNlVmlld0JveCIsImRpc3BsYXlOYW1lIiwicGFyc2VMYWJlbExpc3QiLCJsYWJlbCIsImlzVmFsaWRFbGVtZW50IiwiY29udGVudCIsInJlbmRlckNhbGxCeVBhcmVudCIsInBhcmVudFByb3BzIiwiY2hlY2tQcm9wc0xhYmVsIiwidW5kZWZpbmVkIiwiY2hpbGRyZW4iLCJleHBsaWNpdENoaWxkcmVuIiwiZmluZEFsbEJ5VHlwZSIsImNoaWxkIiwiY2xvbmVFbGVtZW50IiwiaW1wbGljaXRMYWJlbExpc3QiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/component/LabelList.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/component/Legend.js":
/*!*******************************************************!*\
  !*** ./node_modules/recharts/lib/component/Legend.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Legend = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _DefaultLegendContent = __webpack_require__(/*! ./DefaultLegendContent */ \"(pages-dir-node)/./node_modules/recharts/lib/component/DefaultLegendContent.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _getUniqPayload = __webpack_require__(/*! ../util/payload/getUniqPayload */ \"(pages-dir-node)/./node_modules/recharts/lib/util/payload/getUniqPayload.js\");\nvar _excluded = [\n    \"ref\"\n];\n/**\r\n * @fileOverview Legend\r\n */ function _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction defaultUniqBy(entry) {\n    return entry.value;\n}\nfunction renderContent(content, props) {\n    if (/*#__PURE__*/ _react[\"default\"].isValidElement(content)) {\n        return /*#__PURE__*/ _react[\"default\"].cloneElement(content, props);\n    }\n    if (typeof content === 'function') {\n        return /*#__PURE__*/ _react[\"default\"].createElement(content, props);\n    }\n    var ref = props.ref, otherProps = _objectWithoutProperties(props, _excluded);\n    return /*#__PURE__*/ _react[\"default\"].createElement(_DefaultLegendContent.DefaultLegendContent, otherProps);\n}\nvar EPS = 1;\nvar Legend = exports.Legend = /*#__PURE__*/ function(_PureComponent) {\n    function Legend() {\n        var _this;\n        _classCallCheck(this, Legend);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, Legend, [].concat(args));\n        _defineProperty(_this, \"lastBoundingBox\", {\n            width: -1,\n            height: -1\n        });\n        return _this;\n    }\n    _inherits(Legend, _PureComponent);\n    return _createClass(Legend, [\n        {\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n                this.updateBBox();\n            }\n        },\n        {\n            key: \"componentDidUpdate\",\n            value: function componentDidUpdate() {\n                this.updateBBox();\n            }\n        },\n        {\n            key: \"getBBox\",\n            value: function getBBox() {\n                if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {\n                    var box = this.wrapperNode.getBoundingClientRect();\n                    box.height = this.wrapperNode.offsetHeight;\n                    box.width = this.wrapperNode.offsetWidth;\n                    return box;\n                }\n                return null;\n            }\n        },\n        {\n            key: \"updateBBox\",\n            value: function updateBBox() {\n                var onBBoxUpdate = this.props.onBBoxUpdate;\n                var box = this.getBBox();\n                if (box) {\n                    if (Math.abs(box.width - this.lastBoundingBox.width) > EPS || Math.abs(box.height - this.lastBoundingBox.height) > EPS) {\n                        this.lastBoundingBox.width = box.width;\n                        this.lastBoundingBox.height = box.height;\n                        if (onBBoxUpdate) {\n                            onBBoxUpdate(box);\n                        }\n                    }\n                } else if (this.lastBoundingBox.width !== -1 || this.lastBoundingBox.height !== -1) {\n                    this.lastBoundingBox.width = -1;\n                    this.lastBoundingBox.height = -1;\n                    if (onBBoxUpdate) {\n                        onBBoxUpdate(null);\n                    }\n                }\n            }\n        },\n        {\n            key: \"getBBoxSnapshot\",\n            value: function getBBoxSnapshot() {\n                if (this.lastBoundingBox.width >= 0 && this.lastBoundingBox.height >= 0) {\n                    return _objectSpread({}, this.lastBoundingBox);\n                }\n                return {\n                    width: 0,\n                    height: 0\n                };\n            }\n        },\n        {\n            key: \"getDefaultPosition\",\n            value: function getDefaultPosition(style) {\n                var _this$props = this.props, layout = _this$props.layout, align = _this$props.align, verticalAlign = _this$props.verticalAlign, margin = _this$props.margin, chartWidth = _this$props.chartWidth, chartHeight = _this$props.chartHeight;\n                var hPos, vPos;\n                if (!style || (style.left === undefined || style.left === null) && (style.right === undefined || style.right === null)) {\n                    if (align === 'center' && layout === 'vertical') {\n                        var box = this.getBBoxSnapshot();\n                        hPos = {\n                            left: ((chartWidth || 0) - box.width) / 2\n                        };\n                    } else {\n                        hPos = align === 'right' ? {\n                            right: margin && margin.right || 0\n                        } : {\n                            left: margin && margin.left || 0\n                        };\n                    }\n                }\n                if (!style || (style.top === undefined || style.top === null) && (style.bottom === undefined || style.bottom === null)) {\n                    if (verticalAlign === 'middle') {\n                        var _box = this.getBBoxSnapshot();\n                        vPos = {\n                            top: ((chartHeight || 0) - _box.height) / 2\n                        };\n                    } else {\n                        vPos = verticalAlign === 'bottom' ? {\n                            bottom: margin && margin.bottom || 0\n                        } : {\n                            top: margin && margin.top || 0\n                        };\n                    }\n                }\n                return _objectSpread(_objectSpread({}, hPos), vPos);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this2 = this;\n                var _this$props2 = this.props, content = _this$props2.content, width = _this$props2.width, height = _this$props2.height, wrapperStyle = _this$props2.wrapperStyle, payloadUniqBy = _this$props2.payloadUniqBy, payload = _this$props2.payload;\n                var outerStyle = _objectSpread(_objectSpread({\n                    position: 'absolute',\n                    width: width || 'auto',\n                    height: height || 'auto'\n                }, this.getDefaultPosition(wrapperStyle)), wrapperStyle);\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n                    className: \"recharts-legend-wrapper\",\n                    style: outerStyle,\n                    ref: function ref(node) {\n                        _this2.wrapperNode = node;\n                    }\n                }, renderContent(content, _objectSpread(_objectSpread({}, this.props), {}, {\n                    payload: (0, _getUniqPayload.getUniqPayload)(payload, payloadUniqBy, defaultUniqBy)\n                })));\n            }\n        }\n    ], [\n        {\n            key: \"getWithHeight\",\n            value: function getWithHeight(item, chartWidth) {\n                var _this$defaultProps$it = _objectSpread(_objectSpread({}, this.defaultProps), item.props), layout = _this$defaultProps$it.layout;\n                if (layout === 'vertical' && (0, _DataUtils.isNumber)(item.props.height)) {\n                    return {\n                        height: item.props.height\n                    };\n                }\n                if (layout === 'horizontal') {\n                    return {\n                        width: item.props.width || chartWidth\n                    };\n                }\n                return null;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(Legend, \"displayName\", 'Legend');\n_defineProperty(Legend, \"defaultProps\", {\n    iconSize: 14,\n    layout: 'horizontal',\n    align: 'center',\n    verticalAlign: 'bottom'\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY29tcG9uZW50L0xlZ2VuZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFLFdBQVcsS0FBS0MsVUFBVUQsTUFBTUMsT0FBT0UsU0FBUyxHQUFHLFdBQVcsT0FBT0g7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdUSSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsSUFBSUcsU0FBU0Msd0JBQXdCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNwRCxJQUFJQyx3QkFBd0JELG1CQUFPQSxDQUFDLDhHQUF3QjtBQUM1RCxJQUFJRSxhQUFhRixtQkFBT0EsQ0FBQyx5RkFBbUI7QUFDNUMsSUFBSUcsa0JBQWtCSCxtQkFBT0EsQ0FBQyxtSEFBZ0M7QUFDOUQsSUFBSUksWUFBWTtJQUFDO0NBQU07QUFDdkI7O0NBRUMsR0FDRCxTQUFTQyx5QkFBeUJDLENBQUM7SUFBSSxJQUFJLGNBQWMsT0FBT0MsU0FBUyxPQUFPO0lBQU0sSUFBSUMsSUFBSSxJQUFJRCxXQUFXRSxJQUFJLElBQUlGO0lBQVcsT0FBTyxDQUFDRiwyQkFBMkIsU0FBU0EseUJBQXlCQyxDQUFDO1FBQUksT0FBT0EsSUFBSUcsSUFBSUQ7SUFBRyxHQUFHRjtBQUFJO0FBQ25PLFNBQVNQLHdCQUF3Qk8sQ0FBQyxFQUFFRSxDQUFDO0lBQUksSUFBSSxDQUFDQSxLQUFLRixLQUFLQSxFQUFFSSxVQUFVLEVBQUUsT0FBT0o7SUFBRyxJQUFJLFNBQVNBLEtBQUssWUFBWWxCLFFB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LFNBQVMyQixzQkFBc0IzQixNQUFNO2dCQUN2QyxJQUFJQSxXQUFXLGNBQWMsQ0FBQyxHQUFHdEgsV0FBV21KLFFBQVEsRUFBRUgsS0FBS3hHLEtBQUssQ0FBQzRELE1BQU0sR0FBRztvQkFDeEUsT0FBTzt3QkFDTEEsUUFBUTRDLEtBQUt4RyxLQUFLLENBQUM0RCxNQUFNO29CQUMzQjtnQkFDRjtnQkFDQSxJQUFJa0IsV0FBVyxjQUFjO29CQUMzQixPQUFPO3dCQUNMbkIsT0FBTzZDLEtBQUt4RyxLQUFLLENBQUMyRCxLQUFLLElBQUl1QjtvQkFDN0I7Z0JBQ0Y7Z0JBQ0EsT0FBTztZQUNUO1FBQ0Y7S0FBRTtBQUNKLEVBQUU5SCxPQUFPd0osYUFBYTtBQUN0QnJILGdCQUFnQnBDLFFBQVEsZUFBZTtBQUN2Q29DLGdCQUFnQnBDLFFBQVEsZ0JBQWdCO0lBQ3RDMEosVUFBVTtJQUNWL0IsUUFBUTtJQUNSQyxPQUFPO0lBQ1BDLGVBQWU7QUFDakIiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXGNvbXBvbmVudFxcTGVnZW5kLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5MZWdlbmQgPSB2b2lkIDA7XHJcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgX0RlZmF1bHRMZWdlbmRDb250ZW50ID0gcmVxdWlyZShcIi4vRGVmYXVsdExlZ2VuZENvbnRlbnRcIik7XHJcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRGF0YVV0aWxzXCIpO1xyXG52YXIgX2dldFVuaXFQYXlsb2FkID0gcmVxdWlyZShcIi4uL3V0aWwvcGF5bG9hZC9nZXRVbmlxUGF5bG9hZFwiKTtcclxudmFyIF9leGNsdWRlZCA9IFtcInJlZlwiXTtcclxuLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgTGVnZW5kXHJcbiAqL1xyXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxyXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxyXG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxyXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cclxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XHJcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxyXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxyXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxyXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxyXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XHJcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxuZnVuY3Rpb24gZGVmYXVsdFVuaXFCeShlbnRyeSkge1xyXG4gIHJldHVybiBlbnRyeS52YWx1ZTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJDb250ZW50KGNvbnRlbnQsIHByb3BzKSB7XHJcbiAgaWYgKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5pc1ZhbGlkRWxlbWVudChjb250ZW50KSkge1xyXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChjb250ZW50LCBwcm9wcyk7XHJcbiAgfVxyXG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoY29udGVudCwgcHJvcHMpO1xyXG4gIH1cclxuICB2YXIgcmVmID0gcHJvcHMucmVmLFxyXG4gICAgb3RoZXJQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkKTtcclxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfRGVmYXVsdExlZ2VuZENvbnRlbnQuRGVmYXVsdExlZ2VuZENvbnRlbnQsIG90aGVyUHJvcHMpO1xyXG59XHJcbnZhciBFUFMgPSAxO1xyXG52YXIgTGVnZW5kID0gZXhwb3J0cy5MZWdlbmQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QdXJlQ29tcG9uZW50KSB7XHJcbiAgZnVuY3Rpb24gTGVnZW5kKCkge1xyXG4gICAgdmFyIF90aGlzO1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExlZ2VuZCk7XHJcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcclxuICAgIH1cclxuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBMZWdlbmQsIFtdLmNvbmNhdChhcmdzKSk7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibGFzdEJvdW5kaW5nQm94XCIsIHtcclxuICAgICAgd2lkdGg6IC0xLFxyXG4gICAgICBoZWlnaHQ6IC0xXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcbiAgX2luaGVyaXRzKExlZ2VuZCwgX1B1cmVDb21wb25lbnQpO1xyXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoTGVnZW5kLCBbe1xyXG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgIHRoaXMudXBkYXRlQkJveCgpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJjb21wb25lbnREaWRVcGRhdGVcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XHJcbiAgICAgIHRoaXMudXBkYXRlQkJveCgpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJnZXRCQm94XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QkJveCgpIHtcclxuICAgICAgaWYgKHRoaXMud3JhcHBlck5vZGUgJiYgdGhpcy53cmFwcGVyTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcclxuICAgICAgICB2YXIgYm94ID0gdGhpcy53cmFwcGVyTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBib3guaGVpZ2h0ID0gdGhpcy53cmFwcGVyTm9kZS5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgYm94LndpZHRoID0gdGhpcy53cmFwcGVyTm9kZS5vZmZzZXRXaWR0aDtcclxuICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJ1cGRhdGVCQm94XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQkJveCgpIHtcclxuICAgICAgdmFyIG9uQkJveFVwZGF0ZSA9IHRoaXMucHJvcHMub25CQm94VXBkYXRlO1xyXG4gICAgICB2YXIgYm94ID0gdGhpcy5nZXRCQm94KCk7XHJcbiAgICAgIGlmIChib3gpIHtcclxuICAgICAgICBpZiAoTWF0aC5hYnMoYm94LndpZHRoIC0gdGhpcy5sYXN0Qm91bmRpbmdCb3gud2lkdGgpID4gRVBTIHx8IE1hdGguYWJzKGJveC5oZWlnaHQgLSB0aGlzLmxhc3RCb3VuZGluZ0JveC5oZWlnaHQpID4gRVBTKSB7XHJcbiAgICAgICAgICB0aGlzLmxhc3RCb3VuZGluZ0JveC53aWR0aCA9IGJveC53aWR0aDtcclxuICAgICAgICAgIHRoaXMubGFzdEJvdW5kaW5nQm94LmhlaWdodCA9IGJveC5oZWlnaHQ7XHJcbiAgICAgICAgICBpZiAob25CQm94VXBkYXRlKSB7XHJcbiAgICAgICAgICAgIG9uQkJveFVwZGF0ZShib3gpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0aGlzLmxhc3RCb3VuZGluZ0JveC53aWR0aCAhPT0gLTEgfHwgdGhpcy5sYXN0Qm91bmRpbmdCb3guaGVpZ2h0ICE9PSAtMSkge1xyXG4gICAgICAgIHRoaXMubGFzdEJvdW5kaW5nQm94LndpZHRoID0gLTE7XHJcbiAgICAgICAgdGhpcy5sYXN0Qm91bmRpbmdCb3guaGVpZ2h0ID0gLTE7XHJcbiAgICAgICAgaWYgKG9uQkJveFVwZGF0ZSkge1xyXG4gICAgICAgICAgb25CQm94VXBkYXRlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJnZXRCQm94U25hcHNob3RcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCQm94U25hcHNob3QoKSB7XHJcbiAgICAgIGlmICh0aGlzLmxhc3RCb3VuZGluZ0JveC53aWR0aCA+PSAwICYmIHRoaXMubGFzdEJvdW5kaW5nQm94LmhlaWdodCA+PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe30sIHRoaXMubGFzdEJvdW5kaW5nQm94KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgIGhlaWdodDogMFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJnZXREZWZhdWx0UG9zaXRpb25cIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZhdWx0UG9zaXRpb24oc3R5bGUpIHtcclxuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBsYXlvdXQgPSBfdGhpcyRwcm9wcy5sYXlvdXQsXHJcbiAgICAgICAgYWxpZ24gPSBfdGhpcyRwcm9wcy5hbGlnbixcclxuICAgICAgICB2ZXJ0aWNhbEFsaWduID0gX3RoaXMkcHJvcHMudmVydGljYWxBbGlnbixcclxuICAgICAgICBtYXJnaW4gPSBfdGhpcyRwcm9wcy5tYXJnaW4sXHJcbiAgICAgICAgY2hhcnRXaWR0aCA9IF90aGlzJHByb3BzLmNoYXJ0V2lkdGgsXHJcbiAgICAgICAgY2hhcnRIZWlnaHQgPSBfdGhpcyRwcm9wcy5jaGFydEhlaWdodDtcclxuICAgICAgdmFyIGhQb3MsIHZQb3M7XHJcbiAgICAgIGlmICghc3R5bGUgfHwgKHN0eWxlLmxlZnQgPT09IHVuZGVmaW5lZCB8fCBzdHlsZS5sZWZ0ID09PSBudWxsKSAmJiAoc3R5bGUucmlnaHQgPT09IHVuZGVmaW5lZCB8fCBzdHlsZS5yaWdodCA9PT0gbnVsbCkpIHtcclxuICAgICAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInICYmIGxheW91dCA9PT0gJ3ZlcnRpY2FsJykge1xyXG4gICAgICAgICAgdmFyIGJveCA9IHRoaXMuZ2V0QkJveFNuYXBzaG90KCk7XHJcbiAgICAgICAgICBoUG9zID0ge1xyXG4gICAgICAgICAgICBsZWZ0OiAoKGNoYXJ0V2lkdGggfHwgMCkgLSBib3gud2lkdGgpIC8gMlxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaFBvcyA9IGFsaWduID09PSAncmlnaHQnID8ge1xyXG4gICAgICAgICAgICByaWdodDogbWFyZ2luICYmIG1hcmdpbi5yaWdodCB8fCAwXHJcbiAgICAgICAgICB9IDoge1xyXG4gICAgICAgICAgICBsZWZ0OiBtYXJnaW4gJiYgbWFyZ2luLmxlZnQgfHwgMFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFzdHlsZSB8fCAoc3R5bGUudG9wID09PSB1bmRlZmluZWQgfHwgc3R5bGUudG9wID09PSBudWxsKSAmJiAoc3R5bGUuYm90dG9tID09PSB1bmRlZmluZWQgfHwgc3R5bGUuYm90dG9tID09PSBudWxsKSkge1xyXG4gICAgICAgIGlmICh2ZXJ0aWNhbEFsaWduID09PSAnbWlkZGxlJykge1xyXG4gICAgICAgICAgdmFyIF9ib3ggPSB0aGlzLmdldEJCb3hTbmFwc2hvdCgpO1xyXG4gICAgICAgICAgdlBvcyA9IHtcclxuICAgICAgICAgICAgdG9wOiAoKGNoYXJ0SGVpZ2h0IHx8IDApIC0gX2JveC5oZWlnaHQpIC8gMlxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdlBvcyA9IHZlcnRpY2FsQWxpZ24gPT09ICdib3R0b20nID8ge1xyXG4gICAgICAgICAgICBib3R0b206IG1hcmdpbiAmJiBtYXJnaW4uYm90dG9tIHx8IDBcclxuICAgICAgICAgIH0gOiB7XHJcbiAgICAgICAgICAgIHRvcDogbWFyZ2luICYmIG1hcmdpbi50b3AgfHwgMFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaFBvcyksIHZQb3MpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBjb250ZW50ID0gX3RoaXMkcHJvcHMyLmNvbnRlbnQsXHJcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczIud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHMyLmhlaWdodCxcclxuICAgICAgICB3cmFwcGVyU3R5bGUgPSBfdGhpcyRwcm9wczIud3JhcHBlclN0eWxlLFxyXG4gICAgICAgIHBheWxvYWRVbmlxQnkgPSBfdGhpcyRwcm9wczIucGF5bG9hZFVuaXFCeSxcclxuICAgICAgICBwYXlsb2FkID0gX3RoaXMkcHJvcHMyLnBheWxvYWQ7XHJcbiAgICAgIHZhciBvdXRlclN0eWxlID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcclxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICB3aWR0aDogd2lkdGggfHwgJ2F1dG8nLFxyXG4gICAgICAgIGhlaWdodDogaGVpZ2h0IHx8ICdhdXRvJ1xyXG4gICAgICB9LCB0aGlzLmdldERlZmF1bHRQb3NpdGlvbih3cmFwcGVyU3R5bGUpKSwgd3JhcHBlclN0eWxlKTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xyXG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1sZWdlbmQtd3JhcHBlclwiLFxyXG4gICAgICAgIHN0eWxlOiBvdXRlclN0eWxlLFxyXG4gICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKG5vZGUpIHtcclxuICAgICAgICAgIF90aGlzMi53cmFwcGVyTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCByZW5kZXJDb250ZW50KGNvbnRlbnQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5wcm9wcyksIHt9LCB7XHJcbiAgICAgICAgcGF5bG9hZDogKDAsIF9nZXRVbmlxUGF5bG9hZC5nZXRVbmlxUGF5bG9hZCkocGF5bG9hZCwgcGF5bG9hZFVuaXFCeSwgZGVmYXVsdFVuaXFCeSlcclxuICAgICAgfSkpKTtcclxuICAgIH1cclxuICB9XSwgW3tcclxuICAgIGtleTogXCJnZXRXaXRoSGVpZ2h0XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0V2l0aEhlaWdodChpdGVtLCBjaGFydFdpZHRoKSB7XHJcbiAgICAgIHZhciBfdGhpcyRkZWZhdWx0UHJvcHMkaXQgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMuZGVmYXVsdFByb3BzKSwgaXRlbS5wcm9wcyksXHJcbiAgICAgICAgbGF5b3V0ID0gX3RoaXMkZGVmYXVsdFByb3BzJGl0LmxheW91dDtcclxuICAgICAgaWYgKGxheW91dCA9PT0gJ3ZlcnRpY2FsJyAmJiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikoaXRlbS5wcm9wcy5oZWlnaHQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGhlaWdodDogaXRlbS5wcm9wcy5oZWlnaHRcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChsYXlvdXQgPT09ICdob3Jpem9udGFsJykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB3aWR0aDogaXRlbS5wcm9wcy53aWR0aCB8fCBjaGFydFdpZHRoXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XSk7XHJcbn0oX3JlYWN0LlB1cmVDb21wb25lbnQpO1xyXG5fZGVmaW5lUHJvcGVydHkoTGVnZW5kLCBcImRpc3BsYXlOYW1lXCIsICdMZWdlbmQnKTtcclxuX2RlZmluZVByb3BlcnR5KExlZ2VuZCwgXCJkZWZhdWx0UHJvcHNcIiwge1xyXG4gIGljb25TaXplOiAxNCxcclxuICBsYXlvdXQ6ICdob3Jpem9udGFsJyxcclxuICBhbGlnbjogJ2NlbnRlcicsXHJcbiAgdmVydGljYWxBbGlnbjogJ2JvdHRvbSdcclxufSk7Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkxlZ2VuZCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9EZWZhdWx0TGVnZW5kQ29udGVudCIsIl9EYXRhVXRpbHMiLCJfZ2V0VW5pcVBheWxvYWQiLCJfZXhjbHVkZWQiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX19lc01vZHVsZSIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9Qcm9wZXJ0eUtleSIsImtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsImJpbmQiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwib2JqIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJzb3VyY2UiLCJleGNsdWRlZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwic291cmNlU3ltYm9sS2V5cyIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImRlZmF1bHRVbmlxQnkiLCJlbnRyeSIsInJlbmRlckNvbnRlbnQiLCJjb250ZW50IiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwicmVmIiwib3RoZXJQcm9wcyIsIkRlZmF1bHRMZWdlbmRDb250ZW50IiwiRVBTIiwiX1B1cmVDb21wb25lbnQiLCJfdGhpcyIsIl9sZW4iLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiY29uY2F0Iiwid2lkdGgiLCJoZWlnaHQiLCJjb21wb25lbnREaWRNb3VudCIsInVwZGF0ZUJCb3giLCJjb21wb25lbnREaWRVcGRhdGUiLCJnZXRCQm94Iiwid3JhcHBlck5vZGUiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJib3giLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsIm9uQkJveFVwZGF0ZSIsIk1hdGgiLCJhYnMiLCJsYXN0Qm91bmRpbmdCb3giLCJnZXRCQm94U25hcHNob3QiLCJnZXREZWZhdWx0UG9zaXRpb24iLCJzdHlsZSIsIl90aGlzJHByb3BzIiwibGF5b3V0IiwiYWxpZ24iLCJ2ZXJ0aWNhbEFsaWduIiwibWFyZ2luIiwiY2hhcnRXaWR0aCIsImNoYXJ0SGVpZ2h0IiwiaFBvcyIsInZQb3MiLCJsZWZ0IiwidW5kZWZpbmVkIiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJfYm94IiwicmVuZGVyIiwiX3RoaXMyIiwiX3RoaXMkcHJvcHMyIiwid3JhcHBlclN0eWxlIiwicGF5bG9hZFVuaXFCeSIsInBheWxvYWQiLCJvdXRlclN0eWxlIiwicG9zaXRpb24iLCJjbGFzc05hbWUiLCJub2RlIiwiZ2V0VW5pcVBheWxvYWQiLCJnZXRXaXRoSGVpZ2h0IiwiaXRlbSIsIl90aGlzJGRlZmF1bHRQcm9wcyRpdCIsImRlZmF1bHRQcm9wcyIsImlzTnVtYmVyIiwiUHVyZUNvbXBvbmVudCIsImljb25TaXplIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/component/Legend.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/component/ResponsiveContainer.js":
/*!********************************************************************!*\
  !*** ./node_modules/recharts/lib/component/ResponsiveContainer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ResponsiveContainer = void 0;\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _throttle = _interopRequireDefault(__webpack_require__(/*! lodash/throttle */ \"lodash/throttle\"));\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _LogUtils = __webpack_require__(/*! ../util/LogUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/LogUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n} /**\r\n * @fileOverview Wrapper component to make charts adapt to the size of parent * DOM\r\n */ \nvar ResponsiveContainer = exports.ResponsiveContainer = /*#__PURE__*/ (0, _react.forwardRef)(function(_ref, ref) {\n    var aspect = _ref.aspect, _ref$initialDimension = _ref.initialDimension, initialDimension = _ref$initialDimension === void 0 ? {\n        width: -1,\n        height: -1\n    } : _ref$initialDimension, _ref$width = _ref.width, width = _ref$width === void 0 ? '100%' : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? '100%' : _ref$height, _ref$minWidth = _ref.minWidth, minWidth = _ref$minWidth === void 0 ? 0 : _ref$minWidth, minHeight = _ref.minHeight, maxHeight = _ref.maxHeight, children = _ref.children, _ref$debounce = _ref.debounce, debounce = _ref$debounce === void 0 ? 0 : _ref$debounce, id = _ref.id, className = _ref.className, onResize = _ref.onResize, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style;\n    var containerRef = (0, _react.useRef)(null);\n    var onResizeRef = (0, _react.useRef)();\n    onResizeRef.current = onResize;\n    (0, _react.useImperativeHandle)(ref, function() {\n        return Object.defineProperty(containerRef.current, 'current', {\n            get: function get() {\n                // eslint-disable-next-line no-console\n                console.warn('The usage of ref.current.current is deprecated and will no longer be supported.');\n                return containerRef.current;\n            },\n            configurable: true\n        });\n    });\n    var _useState = (0, _react.useState)({\n        containerWidth: initialDimension.width,\n        containerHeight: initialDimension.height\n    }), _useState2 = _slicedToArray(_useState, 2), sizes = _useState2[0], setSizes = _useState2[1];\n    var setContainerSize = (0, _react.useCallback)(function(newWidth, newHeight) {\n        setSizes(function(prevState) {\n            var roundedWidth = Math.round(newWidth);\n            var roundedHeight = Math.round(newHeight);\n            if (prevState.containerWidth === roundedWidth && prevState.containerHeight === roundedHeight) {\n                return prevState;\n            }\n            return {\n                containerWidth: roundedWidth,\n                containerHeight: roundedHeight\n            };\n        });\n    }, []);\n    (0, _react.useEffect)(function() {\n        var callback = function callback(entries) {\n            var _onResizeRef$current;\n            var _entries$0$contentRec = entries[0].contentRect, containerWidth = _entries$0$contentRec.width, containerHeight = _entries$0$contentRec.height;\n            setContainerSize(containerWidth, containerHeight);\n            (_onResizeRef$current = onResizeRef.current) === null || _onResizeRef$current === void 0 || _onResizeRef$current.call(onResizeRef, containerWidth, containerHeight);\n        };\n        if (debounce > 0) {\n            callback = (0, _throttle[\"default\"])(callback, debounce, {\n                trailing: true,\n                leading: false\n            });\n        }\n        var observer = new ResizeObserver(callback);\n        var _containerRef$current = containerRef.current.getBoundingClientRect(), containerWidth = _containerRef$current.width, containerHeight = _containerRef$current.height;\n        setContainerSize(containerWidth, containerHeight);\n        observer.observe(containerRef.current);\n        return function() {\n            observer.disconnect();\n        };\n    }, [\n        setContainerSize,\n        debounce\n    ]);\n    var chartContent = (0, _react.useMemo)(function() {\n        var containerWidth = sizes.containerWidth, containerHeight = sizes.containerHeight;\n        if (containerWidth < 0 || containerHeight < 0) {\n            return null;\n        }\n        (0, _LogUtils.warn)((0, _DataUtils.isPercent)(width) || (0, _DataUtils.isPercent)(height), \"The width(%s) and height(%s) are both fixed numbers,\\n       maybe you don't need to use a ResponsiveContainer.\", width, height);\n        (0, _LogUtils.warn)(!aspect || aspect > 0, 'The aspect(%s) must be greater than zero.', aspect);\n        var calculatedWidth = (0, _DataUtils.isPercent)(width) ? containerWidth : width;\n        var calculatedHeight = (0, _DataUtils.isPercent)(height) ? containerHeight : height;\n        if (aspect && aspect > 0) {\n            // Preserve the desired aspect ratio\n            if (calculatedWidth) {\n                // Will default to using width for aspect ratio\n                calculatedHeight = calculatedWidth / aspect;\n            } else if (calculatedHeight) {\n                // But we should also take height into consideration\n                calculatedWidth = calculatedHeight * aspect;\n            }\n            // if maxHeight is set, overwrite if calculatedHeight is greater than maxHeight\n            if (maxHeight && calculatedHeight > maxHeight) {\n                calculatedHeight = maxHeight;\n            }\n        }\n        (0, _LogUtils.warn)(calculatedWidth > 0 || calculatedHeight > 0, \"The width(%s) and height(%s) of chart should be greater than 0,\\n       please check the style of container, or the props width(%s) and height(%s),\\n       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the\\n       height and width.\", calculatedWidth, calculatedHeight, width, height, minWidth, minHeight, aspect);\n        var isCharts = !Array.isArray(children) && (0, _ReactUtils.getDisplayName)(children.type).endsWith('Chart');\n        return _react[\"default\"].Children.map(children, function(child) {\n            if (/*#__PURE__*/ _react[\"default\"].isValidElement(child)) {\n                return /*#__PURE__*/ (0, _react.cloneElement)(child, _objectSpread({\n                    width: calculatedWidth,\n                    height: calculatedHeight\n                }, isCharts ? {\n                    style: _objectSpread({\n                        height: '100%',\n                        width: '100%',\n                        maxHeight: calculatedHeight,\n                        maxWidth: calculatedWidth\n                    }, child.props.style)\n                } : {}));\n            }\n            return child;\n        });\n    }, [\n        aspect,\n        children,\n        height,\n        maxHeight,\n        minHeight,\n        minWidth,\n        sizes,\n        width\n    ]);\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n        id: id ? \"\".concat(id) : undefined,\n        className: (0, _clsx[\"default\"])('recharts-responsive-container', className),\n        style: _objectSpread(_objectSpread({}, style), {}, {\n            width: width,\n            height: height,\n            minWidth: minWidth,\n            minHeight: minHeight,\n            maxHeight: maxHeight\n        }),\n        ref: containerRef\n    }, chartContent);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY29tcG9uZW50L1Jlc3BvbnNpdmVDb250YWluZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRSxXQUFXLEtBQUtDLFVBQVVELE1BQU1DLE9BQU9FLFNBQVMsR0FBRyxXQUFXLE9BQU9IO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VEksOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELDJCQUEyQixHQUFHLEtBQUs7QUFDbkMsSUFBSUcsUUFBUUMsdUJBQXVCQyxtQkFBT0EsQ0FBQyx1QkFBTTtBQUNqRCxJQUFJQyxTQUFTQyx3QkFBd0JGLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3BELElBQUlHLFlBQVlKLHVCQUF1QkMsbUJBQU9BLENBQUMsd0NBQWlCO0FBQ2hFLElBQUlJLGFBQWFKLG1CQUFPQSxDQUFDLHlGQUFtQjtBQUM1QyxJQUFJSyxZQUFZTCxtQkFBT0EsQ0FBQyx1RkFBa0I7QUFDMUMsSUFBSU0sY0FBY04sbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLFNBQVNPLHlCQUF5QkMsQ0FBQztJQUFJLElBQUksY0FBYyxPQUFPQyxTQUFTLE9BQU87SUFBTSxJQUFJQyxJQUFJLElBQUlELFdBQVdFLElBQUksSUFBSUY7SUFBVyxPQUFPLENBQUNGLDJCQUEyQixTQUFTQSx5QkFBeUJDLENBQUM7UUFBSSxPQUFPQSxJQUFJRyxJQUFJRDtJQUFHLEdBQUdGO0FBQUk7QUFDbk8sU0FBU04sd0JBQXdCTSxDQUFDLEVBQUVFLENBQUM7SUFBSSxJQUFJLENBQUNBLEtB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LGNBQWM7d0JBQ25CNEMsUUFBUTt3QkFDUkQsT0FBTzt3QkFDUE8sV0FBV2tEO3dCQUNYVSxVQUFVWDtvQkFDWixHQUFHUSxNQUFNSSxLQUFLLENBQUNyRCxLQUFLO2dCQUN0QixJQUFJLENBQUM7WUFDUDtZQUNBLE9BQU9pRDtRQUNUO0lBQ0YsR0FBRztRQUFDbkU7UUFBUVc7UUFBVVA7UUFBUU07UUFBV0Q7UUFBV0Q7UUFBVXVCO1FBQU81QjtLQUFNO0lBQzNFLE9BQU8sV0FBVyxHQUFFMUUsTUFBTSxDQUFDLFVBQVUsQ0FBQytJLGFBQWEsQ0FBQyxPQUFPO1FBQ3pEMUQsSUFBSUEsS0FBSyxHQUFHMkQsTUFBTSxDQUFDM0QsTUFBTTREO1FBQ3pCM0QsV0FBVyxDQUFDLEdBQUd6RixLQUFLLENBQUMsVUFBVSxFQUFFLGlDQUFpQ3lGO1FBQ2xFRyxPQUFPMUQsY0FBY0EsY0FBYyxDQUFDLEdBQUcwRCxRQUFRLENBQUMsR0FBRztZQUNqRGYsT0FBT0E7WUFDUEMsUUFBUUE7WUFDUkksVUFBVUE7WUFDVkMsV0FBV0E7WUFDWEMsV0FBV0E7UUFDYjtRQUNBWCxLQUFLb0I7SUFDUCxHQUFHcUM7QUFDTCIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcY29tcG9uZW50XFxSZXNwb25zaXZlQ29udGFpbmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5SZXNwb25zaXZlQ29udGFpbmVyID0gdm9pZCAwO1xyXG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcclxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBfdGhyb3R0bGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvdGhyb3R0bGVcIikpO1xyXG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0RhdGFVdGlsc1wiKTtcclxudmFyIF9Mb2dVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0xvZ1V0aWxzXCIpO1xyXG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xyXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cclxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxyXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxyXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxyXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XHJcbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxyXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxyXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cclxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9IC8qKlxyXG4gKiBAZmlsZU92ZXJ2aWV3IFdyYXBwZXIgY29tcG9uZW50IHRvIG1ha2UgY2hhcnRzIGFkYXB0IHRvIHRoZSBzaXplIG9mIHBhcmVudCAqIERPTVxyXG4gKi9cclxudmFyIFJlc3BvbnNpdmVDb250YWluZXIgPSBleHBvcnRzLlJlc3BvbnNpdmVDb250YWluZXIgPSAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5mb3J3YXJkUmVmKShmdW5jdGlvbiAoX3JlZiwgcmVmKSB7XHJcbiAgdmFyIGFzcGVjdCA9IF9yZWYuYXNwZWN0LFxyXG4gICAgX3JlZiRpbml0aWFsRGltZW5zaW9uID0gX3JlZi5pbml0aWFsRGltZW5zaW9uLFxyXG4gICAgaW5pdGlhbERpbWVuc2lvbiA9IF9yZWYkaW5pdGlhbERpbWVuc2lvbiA9PT0gdm9pZCAwID8ge1xyXG4gICAgICB3aWR0aDogLTEsXHJcbiAgICAgIGhlaWdodDogLTFcclxuICAgIH0gOiBfcmVmJGluaXRpYWxEaW1lbnNpb24sXHJcbiAgICBfcmVmJHdpZHRoID0gX3JlZi53aWR0aCxcclxuICAgIHdpZHRoID0gX3JlZiR3aWR0aCA9PT0gdm9pZCAwID8gJzEwMCUnIDogX3JlZiR3aWR0aCxcclxuICAgIF9yZWYkaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXHJcbiAgICBoZWlnaHQgPSBfcmVmJGhlaWdodCA9PT0gdm9pZCAwID8gJzEwMCUnIDogX3JlZiRoZWlnaHQsXHJcbiAgICBfcmVmJG1pbldpZHRoID0gX3JlZi5taW5XaWR0aCxcclxuICAgIG1pbldpZHRoID0gX3JlZiRtaW5XaWR0aCA9PT0gdm9pZCAwID8gMCA6IF9yZWYkbWluV2lkdGgsXHJcbiAgICBtaW5IZWlnaHQgPSBfcmVmLm1pbkhlaWdodCxcclxuICAgIG1heEhlaWdodCA9IF9yZWYubWF4SGVpZ2h0LFxyXG4gICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxyXG4gICAgX3JlZiRkZWJvdW5jZSA9IF9yZWYuZGVib3VuY2UsXHJcbiAgICBkZWJvdW5jZSA9IF9yZWYkZGVib3VuY2UgPT09IHZvaWQgMCA/IDAgOiBfcmVmJGRlYm91bmNlLFxyXG4gICAgaWQgPSBfcmVmLmlkLFxyXG4gICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXHJcbiAgICBvblJlc2l6ZSA9IF9yZWYub25SZXNpemUsXHJcbiAgICBfcmVmJHN0eWxlID0gX3JlZi5zdHlsZSxcclxuICAgIHN0eWxlID0gX3JlZiRzdHlsZSA9PT0gdm9pZCAwID8ge30gOiBfcmVmJHN0eWxlO1xyXG4gIHZhciBjb250YWluZXJSZWYgPSAoMCwgX3JlYWN0LnVzZVJlZikobnVsbCk7XHJcbiAgdmFyIG9uUmVzaXplUmVmID0gKDAsIF9yZWFjdC51c2VSZWYpKCk7XHJcbiAgb25SZXNpemVSZWYuY3VycmVudCA9IG9uUmVzaXplO1xyXG4gICgwLCBfcmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZSkocmVmLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnRhaW5lclJlZi5jdXJyZW50LCAnY3VycmVudCcsIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSB1c2FnZSBvZiByZWYuY3VycmVudC5jdXJyZW50IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgbm8gbG9uZ2VyIGJlIHN1cHBvcnRlZC4nKTtcclxuICAgICAgICByZXR1cm4gY29udGFpbmVyUmVmLmN1cnJlbnQ7XHJcbiAgICAgIH0sXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbiAgdmFyIF91c2VTdGF0ZSA9ICgwLCBfcmVhY3QudXNlU3RhdGUpKHtcclxuICAgICAgY29udGFpbmVyV2lkdGg6IGluaXRpYWxEaW1lbnNpb24ud2lkdGgsXHJcbiAgICAgIGNvbnRhaW5lckhlaWdodDogaW5pdGlhbERpbWVuc2lvbi5oZWlnaHRcclxuICAgIH0pLFxyXG4gICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXHJcbiAgICBzaXplcyA9IF91c2VTdGF0ZTJbMF0sXHJcbiAgICBzZXRTaXplcyA9IF91c2VTdGF0ZTJbMV07XHJcbiAgdmFyIHNldENvbnRhaW5lclNpemUgPSAoMCwgX3JlYWN0LnVzZUNhbGxiYWNrKShmdW5jdGlvbiAobmV3V2lkdGgsIG5ld0hlaWdodCkge1xyXG4gICAgc2V0U2l6ZXMoZnVuY3Rpb24gKHByZXZTdGF0ZSkge1xyXG4gICAgICB2YXIgcm91bmRlZFdpZHRoID0gTWF0aC5yb3VuZChuZXdXaWR0aCk7XHJcbiAgICAgIHZhciByb3VuZGVkSGVpZ2h0ID0gTWF0aC5yb3VuZChuZXdIZWlnaHQpO1xyXG4gICAgICBpZiAocHJldlN0YXRlLmNvbnRhaW5lcldpZHRoID09PSByb3VuZGVkV2lkdGggJiYgcHJldlN0YXRlLmNvbnRhaW5lckhlaWdodCA9PT0gcm91bmRlZEhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiBwcmV2U3RhdGU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBjb250YWluZXJXaWR0aDogcm91bmRlZFdpZHRoLFxyXG4gICAgICAgIGNvbnRhaW5lckhlaWdodDogcm91bmRlZEhlaWdodFxyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgfSwgW10pO1xyXG4gICgwLCBfcmVhY3QudXNlRWZmZWN0KShmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjayhlbnRyaWVzKSB7XHJcbiAgICAgIHZhciBfb25SZXNpemVSZWYkY3VycmVudDtcclxuICAgICAgdmFyIF9lbnRyaWVzJDAkY29udGVudFJlYyA9IGVudHJpZXNbMF0uY29udGVudFJlY3QsXHJcbiAgICAgICAgY29udGFpbmVyV2lkdGggPSBfZW50cmllcyQwJGNvbnRlbnRSZWMud2lkdGgsXHJcbiAgICAgICAgY29udGFpbmVySGVpZ2h0ID0gX2VudHJpZXMkMCRjb250ZW50UmVjLmhlaWdodDtcclxuICAgICAgc2V0Q29udGFpbmVyU2l6ZShjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0KTtcclxuICAgICAgKF9vblJlc2l6ZVJlZiRjdXJyZW50ID0gb25SZXNpemVSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX29uUmVzaXplUmVmJGN1cnJlbnQgPT09IHZvaWQgMCB8fCBfb25SZXNpemVSZWYkY3VycmVudC5jYWxsKG9uUmVzaXplUmVmLCBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0KTtcclxuICAgIH07XHJcbiAgICBpZiAoZGVib3VuY2UgPiAwKSB7XHJcbiAgICAgIGNhbGxiYWNrID0gKDAsIF90aHJvdHRsZVtcImRlZmF1bHRcIl0pKGNhbGxiYWNrLCBkZWJvdW5jZSwge1xyXG4gICAgICAgIHRyYWlsaW5nOiB0cnVlLFxyXG4gICAgICAgIGxlYWRpbmc6IGZhbHNlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdmFyIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKTtcclxuICAgIHZhciBfY29udGFpbmVyUmVmJGN1cnJlbnQgPSBjb250YWluZXJSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcclxuICAgICAgY29udGFpbmVyV2lkdGggPSBfY29udGFpbmVyUmVmJGN1cnJlbnQud2lkdGgsXHJcbiAgICAgIGNvbnRhaW5lckhlaWdodCA9IF9jb250YWluZXJSZWYkY3VycmVudC5oZWlnaHQ7XHJcbiAgICBzZXRDb250YWluZXJTaXplKGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQpO1xyXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXJSZWYuY3VycmVudCk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgICB9O1xyXG4gIH0sIFtzZXRDb250YWluZXJTaXplLCBkZWJvdW5jZV0pO1xyXG4gIHZhciBjaGFydENvbnRlbnQgPSAoMCwgX3JlYWN0LnVzZU1lbW8pKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBjb250YWluZXJXaWR0aCA9IHNpemVzLmNvbnRhaW5lcldpZHRoLFxyXG4gICAgICBjb250YWluZXJIZWlnaHQgPSBzaXplcy5jb250YWluZXJIZWlnaHQ7XHJcbiAgICBpZiAoY29udGFpbmVyV2lkdGggPCAwIHx8IGNvbnRhaW5lckhlaWdodCA8IDApIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAoMCwgX0xvZ1V0aWxzLndhcm4pKCgwLCBfRGF0YVV0aWxzLmlzUGVyY2VudCkod2lkdGgpIHx8ICgwLCBfRGF0YVV0aWxzLmlzUGVyY2VudCkoaGVpZ2h0KSwgXCJUaGUgd2lkdGgoJXMpIGFuZCBoZWlnaHQoJXMpIGFyZSBib3RoIGZpeGVkIG51bWJlcnMsXFxuICAgICAgIG1heWJlIHlvdSBkb24ndCBuZWVkIHRvIHVzZSBhIFJlc3BvbnNpdmVDb250YWluZXIuXCIsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgKDAsIF9Mb2dVdGlscy53YXJuKSghYXNwZWN0IHx8IGFzcGVjdCA+IDAsICdUaGUgYXNwZWN0KCVzKSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLicsIGFzcGVjdCk7XHJcbiAgICB2YXIgY2FsY3VsYXRlZFdpZHRoID0gKDAsIF9EYXRhVXRpbHMuaXNQZXJjZW50KSh3aWR0aCkgPyBjb250YWluZXJXaWR0aCA6IHdpZHRoO1xyXG4gICAgdmFyIGNhbGN1bGF0ZWRIZWlnaHQgPSAoMCwgX0RhdGFVdGlscy5pc1BlcmNlbnQpKGhlaWdodCkgPyBjb250YWluZXJIZWlnaHQgOiBoZWlnaHQ7XHJcbiAgICBpZiAoYXNwZWN0ICYmIGFzcGVjdCA+IDApIHtcclxuICAgICAgLy8gUHJlc2VydmUgdGhlIGRlc2lyZWQgYXNwZWN0IHJhdGlvXHJcbiAgICAgIGlmIChjYWxjdWxhdGVkV2lkdGgpIHtcclxuICAgICAgICAvLyBXaWxsIGRlZmF1bHQgdG8gdXNpbmcgd2lkdGggZm9yIGFzcGVjdCByYXRpb1xyXG4gICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQgPSBjYWxjdWxhdGVkV2lkdGggLyBhc3BlY3Q7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2FsY3VsYXRlZEhlaWdodCkge1xyXG4gICAgICAgIC8vIEJ1dCB3ZSBzaG91bGQgYWxzbyB0YWtlIGhlaWdodCBpbnRvIGNvbnNpZGVyYXRpb25cclxuICAgICAgICBjYWxjdWxhdGVkV2lkdGggPSBjYWxjdWxhdGVkSGVpZ2h0ICogYXNwZWN0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBpZiBtYXhIZWlnaHQgaXMgc2V0LCBvdmVyd3JpdGUgaWYgY2FsY3VsYXRlZEhlaWdodCBpcyBncmVhdGVyIHRoYW4gbWF4SGVpZ2h0XHJcbiAgICAgIGlmIChtYXhIZWlnaHQgJiYgY2FsY3VsYXRlZEhlaWdodCA+IG1heEhlaWdodCkge1xyXG4gICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQgPSBtYXhIZWlnaHQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgICgwLCBfTG9nVXRpbHMud2FybikoY2FsY3VsYXRlZFdpZHRoID4gMCB8fCBjYWxjdWxhdGVkSGVpZ2h0ID4gMCwgXCJUaGUgd2lkdGgoJXMpIGFuZCBoZWlnaHQoJXMpIG9mIGNoYXJ0IHNob3VsZCBiZSBncmVhdGVyIHRoYW4gMCxcXG4gICAgICAgcGxlYXNlIGNoZWNrIHRoZSBzdHlsZSBvZiBjb250YWluZXIsIG9yIHRoZSBwcm9wcyB3aWR0aCglcykgYW5kIGhlaWdodCglcyksXFxuICAgICAgIG9yIGFkZCBhIG1pbldpZHRoKCVzKSBvciBtaW5IZWlnaHQoJXMpIG9yIHVzZSBhc3BlY3QoJXMpIHRvIGNvbnRyb2wgdGhlXFxuICAgICAgIGhlaWdodCBhbmQgd2lkdGguXCIsIGNhbGN1bGF0ZWRXaWR0aCwgY2FsY3VsYXRlZEhlaWdodCwgd2lkdGgsIGhlaWdodCwgbWluV2lkdGgsIG1pbkhlaWdodCwgYXNwZWN0KTtcclxuICAgIHZhciBpc0NoYXJ0cyA9ICFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiAoMCwgX1JlYWN0VXRpbHMuZ2V0RGlzcGxheU5hbWUpKGNoaWxkcmVuLnR5cGUpLmVuZHNXaXRoKCdDaGFydCcpO1xyXG4gICAgcmV0dXJuIF9yZWFjdFtcImRlZmF1bHRcIl0uQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgaWYgKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLygwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShjaGlsZCwgX29iamVjdFNwcmVhZCh7XHJcbiAgICAgICAgICB3aWR0aDogY2FsY3VsYXRlZFdpZHRoLFxyXG4gICAgICAgICAgaGVpZ2h0OiBjYWxjdWxhdGVkSGVpZ2h0XHJcbiAgICAgICAgfSwgaXNDaGFydHMgPyB7XHJcbiAgICAgICAgICBzdHlsZTogX29iamVjdFNwcmVhZCh7XHJcbiAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxyXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IGNhbGN1bGF0ZWRIZWlnaHQsXHJcbiAgICAgICAgICAgIG1heFdpZHRoOiBjYWxjdWxhdGVkV2lkdGhcclxuICAgICAgICAgIH0sIGNoaWxkLnByb3BzLnN0eWxlKVxyXG4gICAgICAgIH0gOiB7fSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH0pO1xyXG4gIH0sIFthc3BlY3QsIGNoaWxkcmVuLCBoZWlnaHQsIG1heEhlaWdodCwgbWluSGVpZ2h0LCBtaW5XaWR0aCwgc2l6ZXMsIHdpZHRoXSk7XHJcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xyXG4gICAgaWQ6IGlkID8gXCJcIi5jb25jYXQoaWQpIDogdW5kZWZpbmVkLFxyXG4gICAgY2xhc3NOYW1lOiAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtcmVzcG9uc2l2ZS1jb250YWluZXInLCBjbGFzc05hbWUpLFxyXG4gICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3R5bGUpLCB7fSwge1xyXG4gICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICBtaW5XaWR0aDogbWluV2lkdGgsXHJcbiAgICAgIG1pbkhlaWdodDogbWluSGVpZ2h0LFxyXG4gICAgICBtYXhIZWlnaHQ6IG1heEhlaWdodFxyXG4gICAgfSksXHJcbiAgICByZWY6IGNvbnRhaW5lclJlZlxyXG4gIH0sIGNoYXJ0Q29udGVudCk7XHJcbn0pOyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSZXNwb25zaXZlQ29udGFpbmVyIiwiX2Nsc3giLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwiX3Rocm90dGxlIiwiX0RhdGFVdGlscyIsIl9Mb2dVdGlscyIsIl9SZWFjdFV0aWxzIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl9fZXNNb2R1bGUiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0Iiwib2JqIiwib3duS2V5cyIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImtleSIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwibGVuIiwiYXJyMiIsImwiLCJmIiwibmV4dCIsImRvbmUiLCJpc0FycmF5IiwiZm9yd2FyZFJlZiIsIl9yZWYiLCJyZWYiLCJhc3BlY3QiLCJfcmVmJGluaXRpYWxEaW1lbnNpb24iLCJpbml0aWFsRGltZW5zaW9uIiwid2lkdGgiLCJoZWlnaHQiLCJfcmVmJHdpZHRoIiwiX3JlZiRoZWlnaHQiLCJfcmVmJG1pbldpZHRoIiwibWluV2lkdGgiLCJtaW5IZWlnaHQiLCJtYXhIZWlnaHQiLCJjaGlsZHJlbiIsIl9yZWYkZGVib3VuY2UiLCJkZWJvdW5jZSIsImlkIiwiY2xhc3NOYW1lIiwib25SZXNpemUiLCJfcmVmJHN0eWxlIiwic3R5bGUiLCJjb250YWluZXJSZWYiLCJ1c2VSZWYiLCJvblJlc2l6ZVJlZiIsImN1cnJlbnQiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwiY29uc29sZSIsIndhcm4iLCJfdXNlU3RhdGUiLCJ1c2VTdGF0ZSIsImNvbnRhaW5lcldpZHRoIiwiY29udGFpbmVySGVpZ2h0IiwiX3VzZVN0YXRlMiIsInNpemVzIiwic2V0U2l6ZXMiLCJzZXRDb250YWluZXJTaXplIiwidXNlQ2FsbGJhY2siLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsInByZXZTdGF0ZSIsInJvdW5kZWRXaWR0aCIsIk1hdGgiLCJyb3VuZCIsInJvdW5kZWRIZWlnaHQiLCJ1c2VFZmZlY3QiLCJjYWxsYmFjayIsImVudHJpZXMiLCJfb25SZXNpemVSZWYkY3VycmVudCIsIl9lbnRyaWVzJDAkY29udGVudFJlYyIsImNvbnRlbnRSZWN0IiwidHJhaWxpbmciLCJsZWFkaW5nIiwib2JzZXJ2ZXIiLCJSZXNpemVPYnNlcnZlciIsIl9jb250YWluZXJSZWYkY3VycmVudCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIm9ic2VydmUiLCJkaXNjb25uZWN0IiwiY2hhcnRDb250ZW50IiwidXNlTWVtbyIsImlzUGVyY2VudCIsImNhbGN1bGF0ZWRXaWR0aCIsImNhbGN1bGF0ZWRIZWlnaHQiLCJpc0NoYXJ0cyIsImdldERpc3BsYXlOYW1lIiwidHlwZSIsImVuZHNXaXRoIiwiQ2hpbGRyZW4iLCJtYXAiLCJjaGlsZCIsImlzVmFsaWRFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwibWF4V2lkdGgiLCJwcm9wcyIsImNyZWF0ZUVsZW1lbnQiLCJjb25jYXQiLCJ1bmRlZmluZWQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/component/ResponsiveContainer.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/component/Text.js":
/*!*****************************************************!*\
  !*** ./node_modules/recharts/lib/component/Text.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Text = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"(pages-dir-node)/./node_modules/recharts/lib/util/Global.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _DOMUtils = __webpack_require__(/*! ../util/DOMUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DOMUtils.js\");\nvar _ReduceCSSCalc = __webpack_require__(/*! ../util/ReduceCSSCalc */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReduceCSSCalc.js\");\nvar _excluded = [\n    \"x\",\n    \"y\",\n    \"lineHeight\",\n    \"capHeight\",\n    \"scaleToFit\",\n    \"textAnchor\",\n    \"verticalAnchor\",\n    \"fill\"\n], _excluded2 = [\n    \"dx\",\n    \"dy\",\n    \"angle\",\n    \"className\",\n    \"breakAll\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nvar BREAKING_SPACES = /[ \\f\\n\\r\\t\\v\\u2028\\u2029]+/;\nvar calculateWordWidths = function calculateWordWidths(_ref) {\n    var children = _ref.children, breakAll = _ref.breakAll, style = _ref.style;\n    try {\n        var words = [];\n        if (!(0, _isNil[\"default\"])(children)) {\n            if (breakAll) {\n                words = children.toString().split('');\n            } else {\n                words = children.toString().split(BREAKING_SPACES);\n            }\n        }\n        var wordsWithComputedWidth = words.map(function(word) {\n            return {\n                word: word,\n                width: (0, _DOMUtils.getStringSize)(word, style).width\n            };\n        });\n        var spaceWidth = breakAll ? 0 : (0, _DOMUtils.getStringSize)(\"\\xA0\", style).width;\n        return {\n            wordsWithComputedWidth: wordsWithComputedWidth,\n            spaceWidth: spaceWidth\n        };\n    } catch (e) {\n        return null;\n    }\n};\nvar calculateWordsByLines = function calculateWordsByLines(_ref2, initialWordsWithComputedWith, spaceWidth, lineWidth, scaleToFit) {\n    var maxLines = _ref2.maxLines, children = _ref2.children, style = _ref2.style, breakAll = _ref2.breakAll;\n    var shouldLimitLines = (0, _DataUtils.isNumber)(maxLines);\n    var text = children;\n    var calculate = function calculate() {\n        var words = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        return words.reduce(function(result, _ref3) {\n            var word = _ref3.word, width = _ref3.width;\n            var currentLine = result[result.length - 1];\n            if (currentLine && (lineWidth == null || scaleToFit || currentLine.width + width + spaceWidth < Number(lineWidth))) {\n                // Word can be added to an existing line\n                currentLine.words.push(word);\n                currentLine.width += width + spaceWidth;\n            } else {\n                // Add first word to line or word is too long to scaleToFit on existing line\n                var newLine = {\n                    words: [\n                        word\n                    ],\n                    width: width\n                };\n                result.push(newLine);\n            }\n            return result;\n        }, []);\n    };\n    var originalResult = calculate(initialWordsWithComputedWith);\n    var findLongestLine = function findLongestLine(words) {\n        return words.reduce(function(a, b) {\n            return a.width > b.width ? a : b;\n        });\n    };\n    if (!shouldLimitLines) {\n        return originalResult;\n    }\n    var suffix = '…';\n    var checkOverflow = function checkOverflow(index) {\n        var tempText = text.slice(0, index);\n        var words = calculateWordWidths({\n            breakAll: breakAll,\n            style: style,\n            children: tempText + suffix\n        }).wordsWithComputedWidth;\n        var result = calculate(words);\n        var doesOverflow = result.length > maxLines || findLongestLine(result).width > Number(lineWidth);\n        return [\n            doesOverflow,\n            result\n        ];\n    };\n    var start = 0;\n    var end = text.length - 1;\n    var iterations = 0;\n    var trimmedResult;\n    while(start <= end && iterations <= text.length - 1){\n        var middle = Math.floor((start + end) / 2);\n        var prev = middle - 1;\n        var _checkOverflow = checkOverflow(prev), _checkOverflow2 = _slicedToArray(_checkOverflow, 2), doesPrevOverflow = _checkOverflow2[0], result = _checkOverflow2[1];\n        var _checkOverflow3 = checkOverflow(middle), _checkOverflow4 = _slicedToArray(_checkOverflow3, 1), doesMiddleOverflow = _checkOverflow4[0];\n        if (!doesPrevOverflow && !doesMiddleOverflow) {\n            start = middle + 1;\n        }\n        if (doesPrevOverflow && doesMiddleOverflow) {\n            end = middle - 1;\n        }\n        if (!doesPrevOverflow && doesMiddleOverflow) {\n            trimmedResult = result;\n            break;\n        }\n        iterations++;\n    }\n    // Fallback to originalResult (result without trimming) if we cannot find the\n    // where to trim.  This should not happen :tm:\n    return trimmedResult || originalResult;\n};\nvar getWordsWithoutCalculate = function getWordsWithoutCalculate(children) {\n    var words = !(0, _isNil[\"default\"])(children) ? children.toString().split(BREAKING_SPACES) : [];\n    return [\n        {\n            words: words\n        }\n    ];\n};\nvar getWordsByLines = function getWordsByLines(_ref4) {\n    var width = _ref4.width, scaleToFit = _ref4.scaleToFit, children = _ref4.children, style = _ref4.style, breakAll = _ref4.breakAll, maxLines = _ref4.maxLines;\n    // Only perform calculations if using features that require them (multiline, scaleToFit)\n    if ((width || scaleToFit) && !_Global.Global.isSsr) {\n        var wordsWithComputedWidth, spaceWidth;\n        var wordWidths = calculateWordWidths({\n            breakAll: breakAll,\n            children: children,\n            style: style\n        });\n        if (wordWidths) {\n            var wcw = wordWidths.wordsWithComputedWidth, sw = wordWidths.spaceWidth;\n            wordsWithComputedWidth = wcw;\n            spaceWidth = sw;\n        } else {\n            return getWordsWithoutCalculate(children);\n        }\n        return calculateWordsByLines({\n            breakAll: breakAll,\n            children: children,\n            maxLines: maxLines,\n            style: style\n        }, wordsWithComputedWidth, spaceWidth, width, scaleToFit);\n    }\n    return getWordsWithoutCalculate(children);\n};\nvar DEFAULT_FILL = '#808080';\nvar Text = exports.Text = function Text(_ref5) {\n    var _ref5$x = _ref5.x, propsX = _ref5$x === void 0 ? 0 : _ref5$x, _ref5$y = _ref5.y, propsY = _ref5$y === void 0 ? 0 : _ref5$y, _ref5$lineHeight = _ref5.lineHeight, lineHeight = _ref5$lineHeight === void 0 ? '1em' : _ref5$lineHeight, _ref5$capHeight = _ref5.capHeight, capHeight = _ref5$capHeight === void 0 ? '0.71em' : _ref5$capHeight, _ref5$scaleToFit = _ref5.scaleToFit, scaleToFit = _ref5$scaleToFit === void 0 ? false : _ref5$scaleToFit, _ref5$textAnchor = _ref5.textAnchor, textAnchor = _ref5$textAnchor === void 0 ? 'start' : _ref5$textAnchor, _ref5$verticalAnchor = _ref5.verticalAnchor, verticalAnchor = _ref5$verticalAnchor === void 0 ? 'end' : _ref5$verticalAnchor, _ref5$fill = _ref5.fill, fill = _ref5$fill === void 0 ? DEFAULT_FILL : _ref5$fill, props = _objectWithoutProperties(_ref5, _excluded);\n    var wordsByLines = (0, _react.useMemo)(function() {\n        return getWordsByLines({\n            breakAll: props.breakAll,\n            children: props.children,\n            maxLines: props.maxLines,\n            scaleToFit: scaleToFit,\n            style: props.style,\n            width: props.width\n        });\n    }, [\n        props.breakAll,\n        props.children,\n        props.maxLines,\n        scaleToFit,\n        props.style,\n        props.width\n    ]);\n    var dx = props.dx, dy = props.dy, angle = props.angle, className = props.className, breakAll = props.breakAll, textProps = _objectWithoutProperties(props, _excluded2);\n    if (!(0, _DataUtils.isNumOrStr)(propsX) || !(0, _DataUtils.isNumOrStr)(propsY)) {\n        return null;\n    }\n    var x = propsX + ((0, _DataUtils.isNumber)(dx) ? dx : 0);\n    var y = propsY + ((0, _DataUtils.isNumber)(dy) ? dy : 0);\n    var startDy;\n    switch(verticalAnchor){\n        case 'start':\n            startDy = (0, _ReduceCSSCalc.reduceCSSCalc)(\"calc(\".concat(capHeight, \")\"));\n            break;\n        case 'middle':\n            startDy = (0, _ReduceCSSCalc.reduceCSSCalc)(\"calc(\".concat((wordsByLines.length - 1) / 2, \" * -\").concat(lineHeight, \" + (\").concat(capHeight, \" / 2))\"));\n            break;\n        default:\n            startDy = (0, _ReduceCSSCalc.reduceCSSCalc)(\"calc(\".concat(wordsByLines.length - 1, \" * -\").concat(lineHeight, \")\"));\n            break;\n    }\n    var transforms = [];\n    if (scaleToFit) {\n        var lineWidth = wordsByLines[0].width;\n        var width = props.width;\n        transforms.push(\"scale(\".concat(((0, _DataUtils.isNumber)(width) ? width / lineWidth : 1) / lineWidth, \")\"));\n    }\n    if (angle) {\n        transforms.push(\"rotate(\".concat(angle, \", \").concat(x, \", \").concat(y, \")\"));\n    }\n    if (transforms.length) {\n        textProps.transform = transforms.join(' ');\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"text\", _extends({}, (0, _ReactUtils.filterProps)(textProps, true), {\n        x: x,\n        y: y,\n        className: (0, _clsx[\"default\"])('recharts-text', className),\n        textAnchor: textAnchor,\n        fill: fill.includes('url') ? DEFAULT_FILL : fill\n    }), wordsByLines.map(function(line, index) {\n        var words = line.words.join(breakAll ? '' : ' ');\n        return(/*#__PURE__*/ // duplicate words will cause duplicate keys\n        // eslint-disable-next-line react/no-array-index-key\n        _react[\"default\"].createElement(\"tspan\", {\n            x: x,\n            dy: index === 0 ? startDy : lineHeight,\n            key: \"\".concat(words, \"-\").concat(index)\n        }, words));\n    }));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY29tcG9uZW50L1RleHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRSxXQUFXLEtBQUtDLFVBQVVELE1BQU1DLE9BQU9FLFNBQVMsR0FBRyxXQUFXLE9BQU9IO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VEksOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELFlBQVksR0FBRyxLQUFLO0FBQ3BCLElBQUlHLFNBQVNDLHdCQUF3QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUMsU0FBU0MsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJRyxRQUFRRCx1QkFBdUJGLG1CQUFPQSxDQUFDLHVCQUFNO0FBQ2pELElBQUlJLGFBQWFKLG1CQUFPQSxDQUFDLHlGQUFtQjtBQUM1QyxJQUFJSyxVQUFVTCxtQkFBT0EsQ0FBQyxtRkFBZ0I7QUFDdEMsSUFBSU0sY0FBY04sbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlPLFlBQVlQLG1CQUFPQSxDQUFDLHVGQUFrQjtBQUMxQyxJQUFJUSxpQkFBaUJSLG1CQUFPQSxDQUFDLGlHQUF1QjtBQUNwRCxJQUFJUyxZQUFZO0lBQUM7SUFBSztJQUFLO0lBQWM7SUFBYTtJQUFjO0lBQWM7SUFBa0I7Q0FBTyxFQUN6R0MsYUFBYTtJQUFDO0lBQU07SUFBTTtJQUFTO0lBQWE7Q0FBVztBQUM3RCxTQUFTUix1QkFBdUJTLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UseUJBQXlCQyxDQUFDO0lBQUksSUFBSSxjQUFjLE9BQU9DLFNBQVMsT0FBTztJQUFNLElBQUlDLElBQUksSUFBSUQsV0FBV0UsSUFBSSxJQUFJRjtJQUFXLE9BQU8sQ0FBQ0YsMkJBQTJCLFNBQVNBLHlCQUF5QkMsQ0FBQztRQUFJLE9BQU9BLElBQUlHLElBQUlEO0lBQUcsR0FBR0Y7QUFBSTtBQUNuTyxTQUFTZix3QkFBd0JlLENBQUMsRUFBRUUsQ0FBQztJQUFJLElBQUksQ0FBQ0EsS0FBS0YsS0FBS0EsRUFBRUYsVUFBVSxFQUFFLE9BQU9FO0lBQUcsSUFBSSxTQUFTQSxLQUFLLFlBQVkxQixRQUFRMEIsTUFBTSxjQUFjLE9BQU9BLEdBQUcsT0FBTztRQUFFLFdBQVdBO0lBQUU7SUFBRyxJQUFJRyxJQUFJSix5QkFBeUJHO0lBQUksSUFBSUMsS0FBS0EsRUFBRUMsR0FBRyxDQUFDSixJQUFJLE9BQU9HLEVBQUVFLEdBQUcsQ0FBQ0w7SUFBSSxJQUFJTSxJQUFJO1FBQUVDLFdBQVc7SUFBSyxHQUFHQyxJQUFJN0IsT0FBT0MsY0FBYyxJQUFJRCxPQUFPOEIsd0JBQXdCO0lBQUUsSUFBSyxJQUFJQyxLQUFLVixFQUFHLElBQUksY0FBY1UsS0FBSyxFQUFDLEdBQUVDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDWixHQUFHVSxJQUFJO1FBQUUsSUFBSUcsSUFBSUwsSUFBSTdCLE9BQU84Qix3QkFBd0IsQ0FBQ1QsR0FBR1UsS0FBSztRQUFNRyxLQUFNQSxDQUFBQSxFQUFFUixHQUFHLElBQUlRLEVBQUVDLEdBQUcsSUFBSW5DLE9BQU9DLGNBQWMsQ0FBQzBCLEdBQUdJLEdBQUdHLEtBQUtQLENBQUMsQ0FBQ0ksRUFBRSxHQUFHVixDQUFDLENBQUNVLEVBQUU7SUFBRTtJQUFFLE9BQU9KLENBQUMsQ0FBQyxVQUFVLEdBQUdOLEdBQUdHLEtBQUtBLEVBQUVXLEdBQUcsQ0FBQ2QsR0FBR00sSUFBSUE7QUFBRztBQUN6a0IsU0FBU1M7SUFBYUEsV0FBV3BDLE9BQU9xQyxNQUFNLEdBQUdyQyxPQUFPcUMsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVUMsTUFBTTtRQUFJLElBQUssSUFBSUwsSUFBSSxHQUFHQSxJQUFJTSxVQUFVQyxNQUFNLEVBQUVQLElBQUs7WUFBRSxJQUFJUSxTQUFTRixTQUFTLENBQUNOLEVBQUU7WUFBRSxJQUFLLElBQUlTLE9BQU9ELE9BQVE7Z0JBQUUsSUFBSTFDLE9BQU9ELFNBQVMsQ0FBQ2lDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUyxRQUFRQyxNQUFNO29CQUFFSixNQUFNLENBQUNJLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO2dCQUFFO1lBQUU7UUFBRTtRQUFFLE9BQU9KO0lBQVE7SUFBRyxPQUFPSCxTQUFTUSxLQUFLLENBQUMsSUFBSSxFQUFFSjtBQUFZO0FBQ2xWLFNBQVNLLHlCQUF5QkgsTUFBTSxFQUFFSSxRQUFRO0lBQUksSUFBSUosVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUFHLElBQUlILFNBQVNRLDhCQUE4QkwsUUFBUUk7SUFBVyxJQUFJSCxLQUFLVDtJQUFHLElBQUlsQyxPQUFPZ0QscUJBQXFCLEVBQUU7UUFBRSxJQUFJQyxtQkFBbUJqRCxPQUFPZ0QscUJBQXFCLENBQUNOO1FBQVMsSUFBS1IsSUFBSSxHQUFHQSxJQUFJZSxpQkFBaUJSLE1BQU0sRUFBRVAsSUFBSztZQUFFUyxNQUFNTSxnQkFBZ0IsQ0FBQ2YsRUFBRTtZQUFFLElBQUlZLFNBQVNJLE9BQU8sQ0FBQ1AsUUFBUSxHQUFHO1lBQVUsSUFBSSxDQUFDM0MsT0FBT0QsU0FBUyxDQUFDb0Qsb0JBQW9CLENBQUNsQixJQUFJLENBQUNTLFFBQVFDLE1BQU07WUFBVUosTUFBTSxDQUFDSSxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtRQUFFO0lBQUU7SUFBRSxPQUFPSjtBQUFRO0FBQzNlLFNBQVNRLDhCQUE4QkwsTUFBTSxFQUFFSSxRQUFRO0lBQUksSUFBSUosVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUFHLElBQUlILFNBQVMsQ0FBQztJQUFHLElBQUssSUFBSUksT0FBT0QsT0FBUTtRQUFFLElBQUkxQyxPQUFPRCxTQUFTLENBQUNpQyxjQUFjLENBQUNDLElBQUksQ0FBQ1MsUUFBUUMsTUFBTTtZQUFFLElBQUlHLFNBQVNJLE9BQU8sQ0FBQ1AsUUFBUSxHQUFHO1lBQVVKLE1BQU0sQ0FBQ0ksSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7UUFBRTtJQUFFO0lBQUUsT0FBT0o7QUFBUTtBQUN0UixTQUFTYSxlQUFlQyxHQUFHLEVBQUVuQixDQUFDO0lBQUksT0FBT29CLGdCQUFnQkQsUUFBUUUsc0JBQXNCRixLQUFLbkIsTUFBTXNCLDRCQUE0QkgsS0FBS25CLE1BQU11QjtBQUFvQjtBQUM3SixTQUFTQTtJQUFxQixNQUFNLElBQUlDLFVBQVU7QUFBOEk7QUFDaE0sU0FBU0YsNEJBQTRCNUQsQ0FBQyxFQUFFK0QsTUFBTTtJQUFJLElBQUksQ0FBQy9ELEdBQUc7SUFBUSxJQUFJLE9BQU9BLE1BQU0sVUFBVSxPQUFPZ0Usa0JBQWtCaEUsR0FBRytEO0lBQVMsSUFBSWhDLElBQUkzQixPQUFPRCxTQUFTLENBQUM4RCxRQUFRLENBQUM1QixJQUFJLENBQUNyQyxHQUFHa0UsS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUFJLElBQUluQyxNQUFNLFlBQVkvQixFQUFFLFdBQVcsRUFBRStCLElBQUkvQixFQUFFLFdBQVcsQ0FBQ21FLElBQUk7SUFBRSxJQUFJcEMsTUFBTSxTQUFTQSxNQUFNLE9BQU8sT0FBT3FDLE1BQU1DLElBQUksQ0FBQ3JFO0lBQUksSUFBSStCLE1BQU0sZUFBZSwyQ0FBMkN1QyxJQUFJLENBQUN2QyxJQUFJLE9BQU9pQyxrQkFBa0JoRSxHQUFHK0Q7QUFBUztBQUMvWixTQUFTQyxrQkFBa0JQLEdBQUcsRUFBRWMsR0FBRztJQUFJLElBQUlBLE9BQU8sUUFBUUEsTUFBTWQsSUFBSVosTUFBTSxFQUFFMEIsTUFBTWQsSUFBSVosTUFBTTtJQUFFLElBQUssSUFBSVAsSUFBSSxHQUFHa0MsT0FBTyxJQUFJSixNQUFNRyxNQUFNakMsSUFBSWlDLEtBQUtqQyxJQUFLa0MsSUFBSSxDQUFDbEMsRUFBRSxHQUFHbUIsR0FBRyxDQUFDbkIsRUFBRTtJQUFFLE9BQU9rQztBQUFNO0FBQ2xMLFNBQVNiLHNCQUFzQmhDLENBQUMsRUFBRThDLENBQUM7SUFBSSxJQUFJN0MsSUFBSSxRQUFRRCxJQUFJLE9BQU8sZUFBZSxPQUFPMUIsVUFBVTBCLENBQUMsQ0FBQzFCLE9BQU9DLFFBQVEsQ0FBQyxJQUFJeUIsQ0FBQyxDQUFDLGFBQWE7SUFBRSxJQUFJLFFBQVFDLEdBQUc7UUFBRSxJQUFJSCxHQUFHTSxHQUFHTyxHQUFHSCxHQUFHRixJQUFJLEVBQUUsRUFBRXlDLElBQUksQ0FBQyxHQUFHMUUsSUFBSSxDQUFDO1FBQUcsSUFBSTtZQUFFLElBQUlzQyxJQUFJLENBQUNWLElBQUlBLEVBQUVTLElBQUksQ0FBQ1YsRUFBQyxFQUFHZ0QsSUFBSSxFQUFFLE1BQU1GLEdBQUc7Z0JBQUUsSUFBSXJFLE9BQU93QixPQUFPQSxHQUFHO2dCQUFROEMsSUFBSSxDQUFDO1lBQUcsT0FBTyxNQUFPLENBQUVBLENBQUFBLElBQUksQ0FBQ2pELElBQUlhLEVBQUVELElBQUksQ0FBQ1QsRUFBQyxFQUFHZ0QsSUFBSSxLQUFNM0MsQ0FBQUEsRUFBRTRDLElBQUksQ0FBQ3BELEVBQUVsQixLQUFLLEdBQUcwQixFQUFFWSxNQUFNLEtBQUs0QixDQUFBQSxHQUFJQyxJQUFJLENBQUM7UUFBSSxFQUFFLE9BQU8vQyxHQUFHO1lBQUUzQixJQUFJLENBQUMsR0FBRytCLElBQUlKO1FBQUcsU0FBVTtZQUFFLElBQUk7Z0JBQUUsSUFBSSxDQUFDK0MsS0FBSyxRQUFROUMsQ0FBQyxDQUFDLFNBQVMsSUFBS08sQ0FBQUEsSUFBSVAsQ0FBQyxDQUFDLFNBQVMsSUFBSXhCLE9BQU8rQixPQUFPQSxDQUFBQSxHQUFJO1lBQVEsU0FBVTtnQkFBRSxJQUFJbkMsR0FBRyxNQUFNK0I7WUFBRztRQUFFO1FBQUUsT0FBT0U7SUFBRztBQUFFO0FBQ3poQixTQUFTeUIsZ0JBQWdCRCxHQUFHO0lBQUksSUFBSVcsTUFBTVUsT0FBTyxDQUFDckIsTUFBTSxPQUFPQTtBQUFLO0FBQ3BFLElBQUlzQixrQkFBa0I7QUFDdEIsSUFBSUMsc0JBQXNCLFNBQVNBLG9CQUFvQkMsSUFBSTtJQUN6RCxJQUFJQyxXQUFXRCxLQUFLQyxRQUFRLEVBQzFCQyxXQUFXRixLQUFLRSxRQUFRLEVBQ3hCQyxRQUFRSCxLQUFLRyxLQUFLO0lBQ3BCLElBQUk7UUFDRixJQUFJQyxRQUFRLEVBQUU7UUFDZCxJQUFJLENBQUMsQ0FBQyxHQUFHekUsTUFBTSxDQUFDLFVBQVUsRUFBRXNFLFdBQVc7WUFDckMsSUFBSUMsVUFBVTtnQkFDWkUsUUFBUUgsU0FBU2pCLFFBQVEsR0FBR3FCLEtBQUssQ0FBQztZQUNwQyxPQUFPO2dCQUNMRCxRQUFRSCxTQUFTakIsUUFBUSxHQUFHcUIsS0FBSyxDQUFDUDtZQUNwQztRQUNGO1FBQ0EsSUFBSVEseUJBQXlCRixNQUFNRyxHQUFHLENBQUMsU0FBVUMsSUFBSTtZQUNuRCxPQUFPO2dCQUNMQSxNQUFNQTtnQkFDTkMsT0FBTyxDQUFDLEdBQUd4RSxVQUFVeUUsYUFBYSxFQUFFRixNQUFNTCxPQUFPTSxLQUFLO1lBQ3hEO1FBQ0Y7UUFDQSxJQUFJRSxhQUFhVCxXQUFXLElBQUksQ0FBQyxHQUFHakUsVUFBVXlFLGFBQWEsRUFBRSxRQUFRUCxPQUFPTSxLQUFLO1FBQ2pGLE9BQU87WUFDTEgsd0JBQXdCQTtZQUN4QkssWUFBWUE7UUFDZDtJQUNGLEVBQUUsT0FBT25FLEdBQUc7UUFDVixPQUFPO0lBQ1Q7QUFDRjtBQUNBLElBQUlvRSx3QkFBd0IsU0FBU0Esc0JBQXNCQyxLQUFLLEVBQUVDLDRCQUE0QixFQUFFSCxVQUFVLEVBQUVJLFNBQVMsRUFBRUMsVUFBVTtJQUMvSCxJQUFJQyxXQUFXSixNQUFNSSxRQUFRLEVBQzNCaEIsV0FBV1ksTUFBTVosUUFBUSxFQUN6QkUsUUFBUVUsTUFBTVYsS0FBSyxFQUNuQkQsV0FBV1csTUFBTVgsUUFBUTtJQUMzQixJQUFJZ0IsbUJBQW1CLENBQUMsR0FBR3BGLFdBQVdxRixRQUFRLEVBQUVGO0lBQ2hELElBQUlHLE9BQU9uQjtJQUNYLElBQUlvQixZQUFZLFNBQVNBO1FBQ3ZCLElBQUlqQixRQUFRekMsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUsyRCxZQUFZM0QsU0FBUyxDQUFDLEVBQUUsR0FBRyxFQUFFO1FBQ2xGLE9BQU95QyxNQUFNbUIsTUFBTSxDQUFDLFNBQVVDLE1BQU0sRUFBRUMsS0FBSztZQUN6QyxJQUFJakIsT0FBT2lCLE1BQU1qQixJQUFJLEVBQ25CQyxRQUFRZ0IsTUFBTWhCLEtBQUs7WUFDckIsSUFBSWlCLGNBQWNGLE1BQU0sQ0FBQ0EsT0FBTzVELE1BQU0sR0FBRyxFQUFFO1lBQzNDLElBQUk4RCxlQUFnQlgsQ0FBQUEsYUFBYSxRQUFRQyxjQUFjVSxZQUFZakIsS0FBSyxHQUFHQSxRQUFRRSxhQUFhZ0IsT0FBT1osVUFBUyxHQUFJO2dCQUNsSCx3Q0FBd0M7Z0JBQ3hDVyxZQUFZdEIsS0FBSyxDQUFDUixJQUFJLENBQUNZO2dCQUN2QmtCLFlBQVlqQixLQUFLLElBQUlBLFFBQVFFO1lBQy9CLE9BQU87Z0JBQ0wsNEVBQTRFO2dCQUM1RSxJQUFJaUIsVUFBVTtvQkFDWnhCLE9BQU87d0JBQUNJO3FCQUFLO29CQUNiQyxPQUFPQTtnQkFDVDtnQkFDQWUsT0FBTzVCLElBQUksQ0FBQ2dDO1lBQ2Q7WUFDQSxPQUFPSjtRQUNULEdBQUcsRUFBRTtJQUNQO0lBQ0EsSUFBSUssaUJBQWlCUixVQUFVUDtJQUMvQixJQUFJZ0Isa0JBQWtCLFNBQVNBLGdCQUFnQjFCLEtBQUs7UUFDbEQsT0FBT0EsTUFBTW1CLE1BQU0sQ0FBQyxTQUFVdkUsQ0FBQyxFQUFFK0UsQ0FBQztZQUNoQyxPQUFPL0UsRUFBRXlELEtBQUssR0FBR3NCLEVBQUV0QixLQUFLLEdBQUd6RCxJQUFJK0U7UUFDakM7SUFDRjtJQUNBLElBQUksQ0FBQ2Isa0JBQWtCO1FBQ3JCLE9BQU9XO0lBQ1Q7SUFDQSxJQUFJRyxTQUFTO0lBQ2IsSUFBSUMsZ0JBQWdCLFNBQVNBLGNBQWNDLEtBQUs7UUFDOUMsSUFBSUMsV0FBV2YsS0FBS25DLEtBQUssQ0FBQyxHQUFHaUQ7UUFDN0IsSUFBSTlCLFFBQVFMLG9CQUFvQjtZQUM5QkcsVUFBVUE7WUFDVkMsT0FBT0E7WUFDUEYsVUFBVWtDLFdBQVdIO1FBQ3ZCLEdBQUcxQixzQkFBc0I7UUFDekIsSUFBSWtCLFNBQVNILFVBQVVqQjtRQUN2QixJQUFJZ0MsZUFBZVosT0FBTzVELE1BQU0sR0FBR3FELFlBQVlhLGdCQUFnQk4sUUFBUWYsS0FBSyxHQUFHa0IsT0FBT1o7UUFDdEYsT0FBTztZQUFDcUI7WUFBY1o7U0FBTztJQUMvQjtJQUNBLElBQUlhLFFBQVE7SUFDWixJQUFJQyxNQUFNbEIsS0FBS3hELE1BQU0sR0FBRztJQUN4QixJQUFJMkUsYUFBYTtJQUNqQixJQUFJQztJQUNKLE1BQU9ILFNBQVNDLE9BQU9DLGNBQWNuQixLQUFLeEQsTUFBTSxHQUFHLEVBQUc7UUFDcEQsSUFBSTZFLFNBQVNDLEtBQUtDLEtBQUssQ0FBQyxDQUFDTixRQUFRQyxHQUFFLElBQUs7UUFDeEMsSUFBSU0sT0FBT0gsU0FBUztRQUNwQixJQUFJSSxpQkFBaUJaLGNBQWNXLE9BQ2pDRSxrQkFBa0J2RSxlQUFlc0UsZ0JBQWdCLElBQ2pERSxtQkFBbUJELGVBQWUsQ0FBQyxFQUFFLEVBQ3JDdEIsU0FBU3NCLGVBQWUsQ0FBQyxFQUFFO1FBQzdCLElBQUlFLGtCQUFrQmYsY0FBY1EsU0FDbENRLGtCQUFrQjFFLGVBQWV5RSxpQkFBaUIsSUFDbERFLHFCQUFxQkQsZUFBZSxDQUFDLEVBQUU7UUFDekMsSUFBSSxDQUFDRixvQkFBb0IsQ0FBQ0csb0JBQW9CO1lBQzVDYixRQUFRSSxTQUFTO1FBQ25CO1FBQ0EsSUFBSU0sb0JBQW9CRyxvQkFBb0I7WUFDMUNaLE1BQU1HLFNBQVM7UUFDakI7UUFDQSxJQUFJLENBQUNNLG9CQUFvQkcsb0JBQW9CO1lBQzNDVixnQkFBZ0JoQjtZQUNoQjtRQUNGO1FBQ0FlO0lBQ0Y7SUFFQSw2RUFBNkU7SUFDN0UsOENBQThDO0lBQzlDLE9BQU9DLGlCQUFpQlg7QUFDMUI7QUFDQSxJQUFJc0IsMkJBQTJCLFNBQVNBLHlCQUF5QmxELFFBQVE7SUFDdkUsSUFBSUcsUUFBUSxDQUFDLENBQUMsR0FBR3pFLE1BQU0sQ0FBQyxVQUFVLEVBQUVzRSxZQUFZQSxTQUFTakIsUUFBUSxHQUFHcUIsS0FBSyxDQUFDUCxtQkFBbUIsRUFBRTtJQUMvRixPQUFPO1FBQUM7WUFDTk0sT0FBT0E7UUFDVDtLQUFFO0FBQ0o7QUFDQSxJQUFJZ0Qsa0JBQWtCLFNBQVNBLGdCQUFnQkMsS0FBSztJQUNsRCxJQUFJNUMsUUFBUTRDLE1BQU01QyxLQUFLLEVBQ3JCTyxhQUFhcUMsTUFBTXJDLFVBQVUsRUFDN0JmLFdBQVdvRCxNQUFNcEQsUUFBUSxFQUN6QkUsUUFBUWtELE1BQU1sRCxLQUFLLEVBQ25CRCxXQUFXbUQsTUFBTW5ELFFBQVEsRUFDekJlLFdBQVdvQyxNQUFNcEMsUUFBUTtJQUMzQix3RkFBd0Y7SUFDeEYsSUFBSSxDQUFDUixTQUFTTyxVQUFTLEtBQU0sQ0FBQ2pGLFFBQVF1SCxNQUFNLENBQUNDLEtBQUssRUFBRTtRQUNsRCxJQUFJakQsd0JBQXdCSztRQUM1QixJQUFJNkMsYUFBYXpELG9CQUFvQjtZQUNuQ0csVUFBVUE7WUFDVkQsVUFBVUE7WUFDVkUsT0FBT0E7UUFDVDtRQUNBLElBQUlxRCxZQUFZO1lBQ2QsSUFBSUMsTUFBTUQsV0FBV2xELHNCQUFzQixFQUN6Q29ELEtBQUtGLFdBQVc3QyxVQUFVO1lBQzVCTCx5QkFBeUJtRDtZQUN6QjlDLGFBQWErQztRQUNmLE9BQU87WUFDTCxPQUFPUCx5QkFBeUJsRDtRQUNsQztRQUNBLE9BQU9XLHNCQUFzQjtZQUMzQlYsVUFBVUE7WUFDVkQsVUFBVUE7WUFDVmdCLFVBQVVBO1lBQ1ZkLE9BQU9BO1FBQ1QsR0FBR0csd0JBQXdCSyxZQUFZRixPQUFPTztJQUNoRDtJQUNBLE9BQU9tQyx5QkFBeUJsRDtBQUNsQztBQUNBLElBQUkwRCxlQUFlO0FBQ25CLElBQUlwSSxPQUFPRixZQUFZLEdBQUcsU0FBU0UsS0FBS3FJLEtBQUs7SUFDM0MsSUFBSUMsVUFBVUQsTUFBTUUsQ0FBQyxFQUNuQkMsU0FBU0YsWUFBWSxLQUFLLElBQUksSUFBSUEsU0FDbENHLFVBQVVKLE1BQU1LLENBQUMsRUFDakJDLFNBQVNGLFlBQVksS0FBSyxJQUFJLElBQUlBLFNBQ2xDRyxtQkFBbUJQLE1BQU1RLFVBQVUsRUFDbkNBLGFBQWFELHFCQUFxQixLQUFLLElBQUksUUFBUUEsa0JBQ25ERSxrQkFBa0JULE1BQU1VLFNBQVMsRUFDakNBLFlBQVlELG9CQUFvQixLQUFLLElBQUksV0FBV0EsaUJBQ3BERSxtQkFBbUJYLE1BQU01QyxVQUFVLEVBQ25DQSxhQUFhdUQscUJBQXFCLEtBQUssSUFBSSxRQUFRQSxrQkFDbkRDLG1CQUFtQlosTUFBTWEsVUFBVSxFQUNuQ0EsYUFBYUQscUJBQXFCLEtBQUssSUFBSSxVQUFVQSxrQkFDckRFLHVCQUF1QmQsTUFBTWUsY0FBYyxFQUMzQ0EsaUJBQWlCRCx5QkFBeUIsS0FBSyxJQUFJLFFBQVFBLHNCQUMzREUsYUFBYWhCLE1BQU1pQixJQUFJLEVBQ3ZCQSxPQUFPRCxlQUFlLEtBQUssSUFBSWpCLGVBQWVpQixZQUM5Q0UsUUFBUTlHLHlCQUF5QjRGLE9BQU96SDtJQUMxQyxJQUFJNEksZUFBZSxDQUFDLEdBQUd2SixPQUFPd0osT0FBTyxFQUFFO1FBQ3JDLE9BQU81QixnQkFBZ0I7WUFDckJsRCxVQUFVNEUsTUFBTTVFLFFBQVE7WUFDeEJELFVBQVU2RSxNQUFNN0UsUUFBUTtZQUN4QmdCLFVBQVU2RCxNQUFNN0QsUUFBUTtZQUN4QkQsWUFBWUE7WUFDWmIsT0FBTzJFLE1BQU0zRSxLQUFLO1lBQ2xCTSxPQUFPcUUsTUFBTXJFLEtBQUs7UUFDcEI7SUFDRixHQUFHO1FBQUNxRSxNQUFNNUUsUUFBUTtRQUFFNEUsTUFBTTdFLFFBQVE7UUFBRTZFLE1BQU03RCxRQUFRO1FBQUVEO1FBQVk4RCxNQUFNM0UsS0FBSztRQUFFMkUsTUFBTXJFLEtBQUs7S0FBQztJQUN6RixJQUFJd0UsS0FBS0gsTUFBTUcsRUFBRSxFQUNmQyxLQUFLSixNQUFNSSxFQUFFLEVBQ2JDLFFBQVFMLE1BQU1LLEtBQUssRUFDbkJDLFlBQVlOLE1BQU1NLFNBQVMsRUFDM0JsRixXQUFXNEUsTUFBTTVFLFFBQVEsRUFDekJtRixZQUFZckgseUJBQXlCOEcsT0FBTzFJO0lBQzlDLElBQUksQ0FBQyxDQUFDLEdBQUdOLFdBQVd3SixVQUFVLEVBQUV2QixXQUFXLENBQUMsQ0FBQyxHQUFHakksV0FBV3dKLFVBQVUsRUFBRXBCLFNBQVM7UUFDOUUsT0FBTztJQUNUO0lBQ0EsSUFBSUosSUFBSUMsU0FBVSxFQUFDLEdBQUdqSSxXQUFXcUYsUUFBUSxFQUFFOEQsTUFBTUEsS0FBSztJQUN0RCxJQUFJaEIsSUFBSUMsU0FBVSxFQUFDLEdBQUdwSSxXQUFXcUYsUUFBUSxFQUFFK0QsTUFBTUEsS0FBSztJQUN0RCxJQUFJSztJQUNKLE9BQVFaO1FBQ04sS0FBSztZQUNIWSxVQUFVLENBQUMsR0FBR3JKLGVBQWVzSixhQUFhLEVBQUUsUUFBUUMsTUFBTSxDQUFDbkIsV0FBVztZQUN0RTtRQUNGLEtBQUs7WUFDSGlCLFVBQVUsQ0FBQyxHQUFHckosZUFBZXNKLGFBQWEsRUFBRSxRQUFRQyxNQUFNLENBQUMsQ0FBQ1YsYUFBYW5ILE1BQU0sR0FBRyxLQUFLLEdBQUcsUUFBUTZILE1BQU0sQ0FBQ3JCLFlBQVksUUFBUXFCLE1BQU0sQ0FBQ25CLFdBQVc7WUFDL0k7UUFDRjtZQUNFaUIsVUFBVSxDQUFDLEdBQUdySixlQUFlc0osYUFBYSxFQUFFLFFBQVFDLE1BQU0sQ0FBQ1YsYUFBYW5ILE1BQU0sR0FBRyxHQUFHLFFBQVE2SCxNQUFNLENBQUNyQixZQUFZO1lBQy9HO0lBQ0o7SUFDQSxJQUFJc0IsYUFBYSxFQUFFO0lBQ25CLElBQUkxRSxZQUFZO1FBQ2QsSUFBSUQsWUFBWWdFLFlBQVksQ0FBQyxFQUFFLENBQUN0RSxLQUFLO1FBQ3JDLElBQUlBLFFBQVFxRSxNQUFNckUsS0FBSztRQUN2QmlGLFdBQVc5RixJQUFJLENBQUMsU0FBUzZGLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRzNKLFdBQVdxRixRQUFRLEVBQUVWLFNBQVNBLFFBQVFNLFlBQVksS0FBS0EsV0FBVztJQUN6RztJQUNBLElBQUlvRSxPQUFPO1FBQ1RPLFdBQVc5RixJQUFJLENBQUMsVUFBVTZGLE1BQU0sQ0FBQ04sT0FBTyxNQUFNTSxNQUFNLENBQUMzQixHQUFHLE1BQU0yQixNQUFNLENBQUN4QixHQUFHO0lBQzFFO0lBQ0EsSUFBSXlCLFdBQVc5SCxNQUFNLEVBQUU7UUFDckJ5SCxVQUFVTSxTQUFTLEdBQUdELFdBQVdFLElBQUksQ0FBQztJQUN4QztJQUNBLE9BQU8sV0FBVyxHQUFFcEssTUFBTSxDQUFDLFVBQVUsQ0FBQ3FLLGFBQWEsQ0FBQyxRQUFRdEksU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHdkIsWUFBWThKLFdBQVcsRUFBRVQsV0FBVyxPQUFPO1FBQ3RIdkIsR0FBR0E7UUFDSEcsR0FBR0E7UUFDSG1CLFdBQVcsQ0FBQyxHQUFHdkosS0FBSyxDQUFDLFVBQVUsRUFBRSxpQkFBaUJ1SjtRQUNsRFgsWUFBWUE7UUFDWkksTUFBTUEsS0FBS2tCLFFBQVEsQ0FBQyxTQUFTcEMsZUFBZWtCO0lBQzlDLElBQUlFLGFBQWF4RSxHQUFHLENBQUMsU0FBVXlGLElBQUksRUFBRTlELEtBQUs7UUFDeEMsSUFBSTlCLFFBQVE0RixLQUFLNUYsS0FBSyxDQUFDd0YsSUFBSSxDQUFDMUYsV0FBVyxLQUFLO1FBQzVDLE9BQ0UsV0FBVyxHQUNYLDRDQUE0QztRQUM1QyxvREFBb0Q7UUFDcEQxRSxNQUFNLENBQUMsVUFBVSxDQUFDcUssYUFBYSxDQUFDLFNBQVM7WUFDdkMvQixHQUFHQTtZQUNIb0IsSUFBSWhELFVBQVUsSUFBSXFELFVBQVVuQjtZQUM1QnRHLEtBQUssR0FBRzJILE1BQU0sQ0FBQ3JGLE9BQU8sS0FBS3FGLE1BQU0sQ0FBQ3ZEO1FBQ3BDLEdBQUc5QjtJQUVQO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXGNvbXBvbmVudFxcVGV4dC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuVGV4dCA9IHZvaWQgMDtcclxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBfaXNOaWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNOaWxcIikpO1xyXG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcclxudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9EYXRhVXRpbHNcIik7XHJcbnZhciBfR2xvYmFsID0gcmVxdWlyZShcIi4uL3V0aWwvR2xvYmFsXCIpO1xyXG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xyXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRE9NVXRpbHNcIik7XHJcbnZhciBfUmVkdWNlQ1NTQ2FsYyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlZHVjZUNTU0NhbGNcIik7XHJcbnZhciBfZXhjbHVkZWQgPSBbXCJ4XCIsIFwieVwiLCBcImxpbmVIZWlnaHRcIiwgXCJjYXBIZWlnaHRcIiwgXCJzY2FsZVRvRml0XCIsIFwidGV4dEFuY2hvclwiLCBcInZlcnRpY2FsQW5jaG9yXCIsIFwiZmlsbFwiXSxcclxuICBfZXhjbHVkZWQyID0gW1wiZHhcIiwgXCJkeVwiLCBcImFuZ2xlXCIsIFwiY2xhc3NOYW1lXCIsIFwiYnJlYWtBbGxcIl07XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxyXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxyXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XHJcbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxyXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxyXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cclxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XHJcbnZhciBCUkVBS0lOR19TUEFDRVMgPSAvWyBcXGZcXG5cXHJcXHRcXHZcXHUyMDI4XFx1MjAyOV0rLztcclxudmFyIGNhbGN1bGF0ZVdvcmRXaWR0aHMgPSBmdW5jdGlvbiBjYWxjdWxhdGVXb3JkV2lkdGhzKF9yZWYpIHtcclxuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxyXG4gICAgYnJlYWtBbGwgPSBfcmVmLmJyZWFrQWxsLFxyXG4gICAgc3R5bGUgPSBfcmVmLnN0eWxlO1xyXG4gIHRyeSB7XHJcbiAgICB2YXIgd29yZHMgPSBbXTtcclxuICAgIGlmICghKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGNoaWxkcmVuKSkge1xyXG4gICAgICBpZiAoYnJlYWtBbGwpIHtcclxuICAgICAgICB3b3JkcyA9IGNoaWxkcmVuLnRvU3RyaW5nKCkuc3BsaXQoJycpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdvcmRzID0gY2hpbGRyZW4udG9TdHJpbmcoKS5zcGxpdChCUkVBS0lOR19TUEFDRVMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgd29yZHNXaXRoQ29tcHV0ZWRXaWR0aCA9IHdvcmRzLm1hcChmdW5jdGlvbiAod29yZCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHdvcmQ6IHdvcmQsXHJcbiAgICAgICAgd2lkdGg6ICgwLCBfRE9NVXRpbHMuZ2V0U3RyaW5nU2l6ZSkod29yZCwgc3R5bGUpLndpZHRoXHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIHZhciBzcGFjZVdpZHRoID0gYnJlYWtBbGwgPyAwIDogKDAsIF9ET01VdGlscy5nZXRTdHJpbmdTaXplKShcIlxceEEwXCIsIHN0eWxlKS53aWR0aDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHdvcmRzV2l0aENvbXB1dGVkV2lkdGg6IHdvcmRzV2l0aENvbXB1dGVkV2lkdGgsXHJcbiAgICAgIHNwYWNlV2lkdGg6IHNwYWNlV2lkdGhcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59O1xyXG52YXIgY2FsY3VsYXRlV29yZHNCeUxpbmVzID0gZnVuY3Rpb24gY2FsY3VsYXRlV29yZHNCeUxpbmVzKF9yZWYyLCBpbml0aWFsV29yZHNXaXRoQ29tcHV0ZWRXaXRoLCBzcGFjZVdpZHRoLCBsaW5lV2lkdGgsIHNjYWxlVG9GaXQpIHtcclxuICB2YXIgbWF4TGluZXMgPSBfcmVmMi5tYXhMaW5lcyxcclxuICAgIGNoaWxkcmVuID0gX3JlZjIuY2hpbGRyZW4sXHJcbiAgICBzdHlsZSA9IF9yZWYyLnN0eWxlLFxyXG4gICAgYnJlYWtBbGwgPSBfcmVmMi5icmVha0FsbDtcclxuICB2YXIgc2hvdWxkTGltaXRMaW5lcyA9ICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShtYXhMaW5lcyk7XHJcbiAgdmFyIHRleHQgPSBjaGlsZHJlbjtcclxuICB2YXIgY2FsY3VsYXRlID0gZnVuY3Rpb24gY2FsY3VsYXRlKCkge1xyXG4gICAgdmFyIHdvcmRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcclxuICAgIHJldHVybiB3b3Jkcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgX3JlZjMpIHtcclxuICAgICAgdmFyIHdvcmQgPSBfcmVmMy53b3JkLFxyXG4gICAgICAgIHdpZHRoID0gX3JlZjMud2lkdGg7XHJcbiAgICAgIHZhciBjdXJyZW50TGluZSA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XHJcbiAgICAgIGlmIChjdXJyZW50TGluZSAmJiAobGluZVdpZHRoID09IG51bGwgfHwgc2NhbGVUb0ZpdCB8fCBjdXJyZW50TGluZS53aWR0aCArIHdpZHRoICsgc3BhY2VXaWR0aCA8IE51bWJlcihsaW5lV2lkdGgpKSkge1xyXG4gICAgICAgIC8vIFdvcmQgY2FuIGJlIGFkZGVkIHRvIGFuIGV4aXN0aW5nIGxpbmVcclxuICAgICAgICBjdXJyZW50TGluZS53b3Jkcy5wdXNoKHdvcmQpO1xyXG4gICAgICAgIGN1cnJlbnRMaW5lLndpZHRoICs9IHdpZHRoICsgc3BhY2VXaWR0aDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBBZGQgZmlyc3Qgd29yZCB0byBsaW5lIG9yIHdvcmQgaXMgdG9vIGxvbmcgdG8gc2NhbGVUb0ZpdCBvbiBleGlzdGluZyBsaW5lXHJcbiAgICAgICAgdmFyIG5ld0xpbmUgPSB7XHJcbiAgICAgICAgICB3b3JkczogW3dvcmRdLFxyXG4gICAgICAgICAgd2lkdGg6IHdpZHRoXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXN1bHQucHVzaChuZXdMaW5lKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSwgW10pO1xyXG4gIH07XHJcbiAgdmFyIG9yaWdpbmFsUmVzdWx0ID0gY2FsY3VsYXRlKGluaXRpYWxXb3Jkc1dpdGhDb21wdXRlZFdpdGgpO1xyXG4gIHZhciBmaW5kTG9uZ2VzdExpbmUgPSBmdW5jdGlvbiBmaW5kTG9uZ2VzdExpbmUod29yZHMpIHtcclxuICAgIHJldHVybiB3b3Jkcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgcmV0dXJuIGEud2lkdGggPiBiLndpZHRoID8gYSA6IGI7XHJcbiAgICB9KTtcclxuICB9O1xyXG4gIGlmICghc2hvdWxkTGltaXRMaW5lcykge1xyXG4gICAgcmV0dXJuIG9yaWdpbmFsUmVzdWx0O1xyXG4gIH1cclxuICB2YXIgc3VmZml4ID0gJ+KApic7XHJcbiAgdmFyIGNoZWNrT3ZlcmZsb3cgPSBmdW5jdGlvbiBjaGVja092ZXJmbG93KGluZGV4KSB7XHJcbiAgICB2YXIgdGVtcFRleHQgPSB0ZXh0LnNsaWNlKDAsIGluZGV4KTtcclxuICAgIHZhciB3b3JkcyA9IGNhbGN1bGF0ZVdvcmRXaWR0aHMoe1xyXG4gICAgICBicmVha0FsbDogYnJlYWtBbGwsXHJcbiAgICAgIHN0eWxlOiBzdHlsZSxcclxuICAgICAgY2hpbGRyZW46IHRlbXBUZXh0ICsgc3VmZml4XHJcbiAgICB9KS53b3Jkc1dpdGhDb21wdXRlZFdpZHRoO1xyXG4gICAgdmFyIHJlc3VsdCA9IGNhbGN1bGF0ZSh3b3Jkcyk7XHJcbiAgICB2YXIgZG9lc092ZXJmbG93ID0gcmVzdWx0Lmxlbmd0aCA+IG1heExpbmVzIHx8IGZpbmRMb25nZXN0TGluZShyZXN1bHQpLndpZHRoID4gTnVtYmVyKGxpbmVXaWR0aCk7XHJcbiAgICByZXR1cm4gW2RvZXNPdmVyZmxvdywgcmVzdWx0XTtcclxuICB9O1xyXG4gIHZhciBzdGFydCA9IDA7XHJcbiAgdmFyIGVuZCA9IHRleHQubGVuZ3RoIC0gMTtcclxuICB2YXIgaXRlcmF0aW9ucyA9IDA7XHJcbiAgdmFyIHRyaW1tZWRSZXN1bHQ7XHJcbiAgd2hpbGUgKHN0YXJ0IDw9IGVuZCAmJiBpdGVyYXRpb25zIDw9IHRleHQubGVuZ3RoIC0gMSkge1xyXG4gICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xyXG4gICAgdmFyIHByZXYgPSBtaWRkbGUgLSAxO1xyXG4gICAgdmFyIF9jaGVja092ZXJmbG93ID0gY2hlY2tPdmVyZmxvdyhwcmV2KSxcclxuICAgICAgX2NoZWNrT3ZlcmZsb3cyID0gX3NsaWNlZFRvQXJyYXkoX2NoZWNrT3ZlcmZsb3csIDIpLFxyXG4gICAgICBkb2VzUHJldk92ZXJmbG93ID0gX2NoZWNrT3ZlcmZsb3cyWzBdLFxyXG4gICAgICByZXN1bHQgPSBfY2hlY2tPdmVyZmxvdzJbMV07XHJcbiAgICB2YXIgX2NoZWNrT3ZlcmZsb3czID0gY2hlY2tPdmVyZmxvdyhtaWRkbGUpLFxyXG4gICAgICBfY2hlY2tPdmVyZmxvdzQgPSBfc2xpY2VkVG9BcnJheShfY2hlY2tPdmVyZmxvdzMsIDEpLFxyXG4gICAgICBkb2VzTWlkZGxlT3ZlcmZsb3cgPSBfY2hlY2tPdmVyZmxvdzRbMF07XHJcbiAgICBpZiAoIWRvZXNQcmV2T3ZlcmZsb3cgJiYgIWRvZXNNaWRkbGVPdmVyZmxvdykge1xyXG4gICAgICBzdGFydCA9IG1pZGRsZSArIDE7XHJcbiAgICB9XHJcbiAgICBpZiAoZG9lc1ByZXZPdmVyZmxvdyAmJiBkb2VzTWlkZGxlT3ZlcmZsb3cpIHtcclxuICAgICAgZW5kID0gbWlkZGxlIC0gMTtcclxuICAgIH1cclxuICAgIGlmICghZG9lc1ByZXZPdmVyZmxvdyAmJiBkb2VzTWlkZGxlT3ZlcmZsb3cpIHtcclxuICAgICAgdHJpbW1lZFJlc3VsdCA9IHJlc3VsdDtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBpdGVyYXRpb25zKys7XHJcbiAgfVxyXG5cclxuICAvLyBGYWxsYmFjayB0byBvcmlnaW5hbFJlc3VsdCAocmVzdWx0IHdpdGhvdXQgdHJpbW1pbmcpIGlmIHdlIGNhbm5vdCBmaW5kIHRoZVxyXG4gIC8vIHdoZXJlIHRvIHRyaW0uICBUaGlzIHNob3VsZCBub3QgaGFwcGVuIDp0bTpcclxuICByZXR1cm4gdHJpbW1lZFJlc3VsdCB8fCBvcmlnaW5hbFJlc3VsdDtcclxufTtcclxudmFyIGdldFdvcmRzV2l0aG91dENhbGN1bGF0ZSA9IGZ1bmN0aW9uIGdldFdvcmRzV2l0aG91dENhbGN1bGF0ZShjaGlsZHJlbikge1xyXG4gIHZhciB3b3JkcyA9ICEoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoY2hpbGRyZW4pID8gY2hpbGRyZW4udG9TdHJpbmcoKS5zcGxpdChCUkVBS0lOR19TUEFDRVMpIDogW107XHJcbiAgcmV0dXJuIFt7XHJcbiAgICB3b3Jkczogd29yZHNcclxuICB9XTtcclxufTtcclxudmFyIGdldFdvcmRzQnlMaW5lcyA9IGZ1bmN0aW9uIGdldFdvcmRzQnlMaW5lcyhfcmVmNCkge1xyXG4gIHZhciB3aWR0aCA9IF9yZWY0LndpZHRoLFxyXG4gICAgc2NhbGVUb0ZpdCA9IF9yZWY0LnNjYWxlVG9GaXQsXHJcbiAgICBjaGlsZHJlbiA9IF9yZWY0LmNoaWxkcmVuLFxyXG4gICAgc3R5bGUgPSBfcmVmNC5zdHlsZSxcclxuICAgIGJyZWFrQWxsID0gX3JlZjQuYnJlYWtBbGwsXHJcbiAgICBtYXhMaW5lcyA9IF9yZWY0Lm1heExpbmVzO1xyXG4gIC8vIE9ubHkgcGVyZm9ybSBjYWxjdWxhdGlvbnMgaWYgdXNpbmcgZmVhdHVyZXMgdGhhdCByZXF1aXJlIHRoZW0gKG11bHRpbGluZSwgc2NhbGVUb0ZpdClcclxuICBpZiAoKHdpZHRoIHx8IHNjYWxlVG9GaXQpICYmICFfR2xvYmFsLkdsb2JhbC5pc1Nzcikge1xyXG4gICAgdmFyIHdvcmRzV2l0aENvbXB1dGVkV2lkdGgsIHNwYWNlV2lkdGg7XHJcbiAgICB2YXIgd29yZFdpZHRocyA9IGNhbGN1bGF0ZVdvcmRXaWR0aHMoe1xyXG4gICAgICBicmVha0FsbDogYnJlYWtBbGwsXHJcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcclxuICAgICAgc3R5bGU6IHN0eWxlXHJcbiAgICB9KTtcclxuICAgIGlmICh3b3JkV2lkdGhzKSB7XHJcbiAgICAgIHZhciB3Y3cgPSB3b3JkV2lkdGhzLndvcmRzV2l0aENvbXB1dGVkV2lkdGgsXHJcbiAgICAgICAgc3cgPSB3b3JkV2lkdGhzLnNwYWNlV2lkdGg7XHJcbiAgICAgIHdvcmRzV2l0aENvbXB1dGVkV2lkdGggPSB3Y3c7XHJcbiAgICAgIHNwYWNlV2lkdGggPSBzdztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBnZXRXb3Jkc1dpdGhvdXRDYWxjdWxhdGUoY2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNhbGN1bGF0ZVdvcmRzQnlMaW5lcyh7XHJcbiAgICAgIGJyZWFrQWxsOiBicmVha0FsbCxcclxuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxyXG4gICAgICBtYXhMaW5lczogbWF4TGluZXMsXHJcbiAgICAgIHN0eWxlOiBzdHlsZVxyXG4gICAgfSwgd29yZHNXaXRoQ29tcHV0ZWRXaWR0aCwgc3BhY2VXaWR0aCwgd2lkdGgsIHNjYWxlVG9GaXQpO1xyXG4gIH1cclxuICByZXR1cm4gZ2V0V29yZHNXaXRob3V0Q2FsY3VsYXRlKGNoaWxkcmVuKTtcclxufTtcclxudmFyIERFRkFVTFRfRklMTCA9ICcjODA4MDgwJztcclxudmFyIFRleHQgPSBleHBvcnRzLlRleHQgPSBmdW5jdGlvbiBUZXh0KF9yZWY1KSB7XHJcbiAgdmFyIF9yZWY1JHggPSBfcmVmNS54LFxyXG4gICAgcHJvcHNYID0gX3JlZjUkeCA9PT0gdm9pZCAwID8gMCA6IF9yZWY1JHgsXHJcbiAgICBfcmVmNSR5ID0gX3JlZjUueSxcclxuICAgIHByb3BzWSA9IF9yZWY1JHkgPT09IHZvaWQgMCA/IDAgOiBfcmVmNSR5LFxyXG4gICAgX3JlZjUkbGluZUhlaWdodCA9IF9yZWY1LmxpbmVIZWlnaHQsXHJcbiAgICBsaW5lSGVpZ2h0ID0gX3JlZjUkbGluZUhlaWdodCA9PT0gdm9pZCAwID8gJzFlbScgOiBfcmVmNSRsaW5lSGVpZ2h0LFxyXG4gICAgX3JlZjUkY2FwSGVpZ2h0ID0gX3JlZjUuY2FwSGVpZ2h0LFxyXG4gICAgY2FwSGVpZ2h0ID0gX3JlZjUkY2FwSGVpZ2h0ID09PSB2b2lkIDAgPyAnMC43MWVtJyA6IF9yZWY1JGNhcEhlaWdodCxcclxuICAgIF9yZWY1JHNjYWxlVG9GaXQgPSBfcmVmNS5zY2FsZVRvRml0LFxyXG4gICAgc2NhbGVUb0ZpdCA9IF9yZWY1JHNjYWxlVG9GaXQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjUkc2NhbGVUb0ZpdCxcclxuICAgIF9yZWY1JHRleHRBbmNob3IgPSBfcmVmNS50ZXh0QW5jaG9yLFxyXG4gICAgdGV4dEFuY2hvciA9IF9yZWY1JHRleHRBbmNob3IgPT09IHZvaWQgMCA/ICdzdGFydCcgOiBfcmVmNSR0ZXh0QW5jaG9yLFxyXG4gICAgX3JlZjUkdmVydGljYWxBbmNob3IgPSBfcmVmNS52ZXJ0aWNhbEFuY2hvcixcclxuICAgIHZlcnRpY2FsQW5jaG9yID0gX3JlZjUkdmVydGljYWxBbmNob3IgPT09IHZvaWQgMCA/ICdlbmQnIDogX3JlZjUkdmVydGljYWxBbmNob3IsXHJcbiAgICBfcmVmNSRmaWxsID0gX3JlZjUuZmlsbCxcclxuICAgIGZpbGwgPSBfcmVmNSRmaWxsID09PSB2b2lkIDAgPyBERUZBVUxUX0ZJTEwgOiBfcmVmNSRmaWxsLFxyXG4gICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjUsIF9leGNsdWRlZCk7XHJcbiAgdmFyIHdvcmRzQnlMaW5lcyA9ICgwLCBfcmVhY3QudXNlTWVtbykoZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGdldFdvcmRzQnlMaW5lcyh7XHJcbiAgICAgIGJyZWFrQWxsOiBwcm9wcy5icmVha0FsbCxcclxuICAgICAgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuLFxyXG4gICAgICBtYXhMaW5lczogcHJvcHMubWF4TGluZXMsXHJcbiAgICAgIHNjYWxlVG9GaXQ6IHNjYWxlVG9GaXQsXHJcbiAgICAgIHN0eWxlOiBwcm9wcy5zdHlsZSxcclxuICAgICAgd2lkdGg6IHByb3BzLndpZHRoXHJcbiAgICB9KTtcclxuICB9LCBbcHJvcHMuYnJlYWtBbGwsIHByb3BzLmNoaWxkcmVuLCBwcm9wcy5tYXhMaW5lcywgc2NhbGVUb0ZpdCwgcHJvcHMuc3R5bGUsIHByb3BzLndpZHRoXSk7XHJcbiAgdmFyIGR4ID0gcHJvcHMuZHgsXHJcbiAgICBkeSA9IHByb3BzLmR5LFxyXG4gICAgYW5nbGUgPSBwcm9wcy5hbmdsZSxcclxuICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcclxuICAgIGJyZWFrQWxsID0gcHJvcHMuYnJlYWtBbGwsXHJcbiAgICB0ZXh0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZDIpO1xyXG4gIGlmICghKDAsIF9EYXRhVXRpbHMuaXNOdW1PclN0cikocHJvcHNYKSB8fCAhKDAsIF9EYXRhVXRpbHMuaXNOdW1PclN0cikocHJvcHNZKSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHZhciB4ID0gcHJvcHNYICsgKCgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShkeCkgPyBkeCA6IDApO1xyXG4gIHZhciB5ID0gcHJvcHNZICsgKCgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShkeSkgPyBkeSA6IDApO1xyXG4gIHZhciBzdGFydER5O1xyXG4gIHN3aXRjaCAodmVydGljYWxBbmNob3IpIHtcclxuICAgIGNhc2UgJ3N0YXJ0JzpcclxuICAgICAgc3RhcnREeSA9ICgwLCBfUmVkdWNlQ1NTQ2FsYy5yZWR1Y2VDU1NDYWxjKShcImNhbGMoXCIuY29uY2F0KGNhcEhlaWdodCwgXCIpXCIpKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdtaWRkbGUnOlxyXG4gICAgICBzdGFydER5ID0gKDAsIF9SZWR1Y2VDU1NDYWxjLnJlZHVjZUNTU0NhbGMpKFwiY2FsYyhcIi5jb25jYXQoKHdvcmRzQnlMaW5lcy5sZW5ndGggLSAxKSAvIDIsIFwiICogLVwiKS5jb25jYXQobGluZUhlaWdodCwgXCIgKyAoXCIpLmNvbmNhdChjYXBIZWlnaHQsIFwiIC8gMikpXCIpKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBzdGFydER5ID0gKDAsIF9SZWR1Y2VDU1NDYWxjLnJlZHVjZUNTU0NhbGMpKFwiY2FsYyhcIi5jb25jYXQod29yZHNCeUxpbmVzLmxlbmd0aCAtIDEsIFwiICogLVwiKS5jb25jYXQobGluZUhlaWdodCwgXCIpXCIpKTtcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG4gIHZhciB0cmFuc2Zvcm1zID0gW107XHJcbiAgaWYgKHNjYWxlVG9GaXQpIHtcclxuICAgIHZhciBsaW5lV2lkdGggPSB3b3Jkc0J5TGluZXNbMF0ud2lkdGg7XHJcbiAgICB2YXIgd2lkdGggPSBwcm9wcy53aWR0aDtcclxuICAgIHRyYW5zZm9ybXMucHVzaChcInNjYWxlKFwiLmNvbmNhdCgoKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHdpZHRoKSA/IHdpZHRoIC8gbGluZVdpZHRoIDogMSkgLyBsaW5lV2lkdGgsIFwiKVwiKSk7XHJcbiAgfVxyXG4gIGlmIChhbmdsZSkge1xyXG4gICAgdHJhbnNmb3Jtcy5wdXNoKFwicm90YXRlKFwiLmNvbmNhdChhbmdsZSwgXCIsIFwiKS5jb25jYXQoeCwgXCIsIFwiKS5jb25jYXQoeSwgXCIpXCIpKTtcclxuICB9XHJcbiAgaWYgKHRyYW5zZm9ybXMubGVuZ3RoKSB7XHJcbiAgICB0ZXh0UHJvcHMudHJhbnNmb3JtID0gdHJhbnNmb3Jtcy5qb2luKCcgJyk7XHJcbiAgfVxyXG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwidGV4dFwiLCBfZXh0ZW5kcyh7fSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0ZXh0UHJvcHMsIHRydWUpLCB7XHJcbiAgICB4OiB4LFxyXG4gICAgeTogeSxcclxuICAgIGNsYXNzTmFtZTogKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXRleHQnLCBjbGFzc05hbWUpLFxyXG4gICAgdGV4dEFuY2hvcjogdGV4dEFuY2hvcixcclxuICAgIGZpbGw6IGZpbGwuaW5jbHVkZXMoJ3VybCcpID8gREVGQVVMVF9GSUxMIDogZmlsbFxyXG4gIH0pLCB3b3Jkc0J5TGluZXMubWFwKGZ1bmN0aW9uIChsaW5lLCBpbmRleCkge1xyXG4gICAgdmFyIHdvcmRzID0gbGluZS53b3Jkcy5qb2luKGJyZWFrQWxsID8gJycgOiAnICcpO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgLyojX19QVVJFX18qL1xyXG4gICAgICAvLyBkdXBsaWNhdGUgd29yZHMgd2lsbCBjYXVzZSBkdXBsaWNhdGUga2V5c1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XHJcbiAgICAgIF9yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInRzcGFuXCIsIHtcclxuICAgICAgICB4OiB4LFxyXG4gICAgICAgIGR5OiBpbmRleCA9PT0gMCA/IHN0YXJ0RHkgOiBsaW5lSGVpZ2h0LFxyXG4gICAgICAgIGtleTogXCJcIi5jb25jYXQod29yZHMsIFwiLVwiKS5jb25jYXQoaW5kZXgpXHJcbiAgICAgIH0sIHdvcmRzKVxyXG4gICAgKTtcclxuICB9KSk7XHJcbn07Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlRleHQiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfaXNOaWwiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2Nsc3giLCJfRGF0YVV0aWxzIiwiX0dsb2JhbCIsIl9SZWFjdFV0aWxzIiwiX0RPTVV0aWxzIiwiX1JlZHVjZUNTU0NhbGMiLCJfZXhjbHVkZWQiLCJfZXhjbHVkZWQyIiwib2JqIiwiX19lc01vZHVsZSIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwiYXBwbHkiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJleGNsdWRlZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIlR5cGVFcnJvciIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwibGVuIiwiYXJyMiIsImwiLCJmIiwibmV4dCIsImRvbmUiLCJwdXNoIiwiaXNBcnJheSIsIkJSRUFLSU5HX1NQQUNFUyIsImNhbGN1bGF0ZVdvcmRXaWR0aHMiLCJfcmVmIiwiY2hpbGRyZW4iLCJicmVha0FsbCIsInN0eWxlIiwid29yZHMiLCJzcGxpdCIsIndvcmRzV2l0aENvbXB1dGVkV2lkdGgiLCJtYXAiLCJ3b3JkIiwid2lkdGgiLCJnZXRTdHJpbmdTaXplIiwic3BhY2VXaWR0aCIsImNhbGN1bGF0ZVdvcmRzQnlMaW5lcyIsIl9yZWYyIiwiaW5pdGlhbFdvcmRzV2l0aENvbXB1dGVkV2l0aCIsImxpbmVXaWR0aCIsInNjYWxlVG9GaXQiLCJtYXhMaW5lcyIsInNob3VsZExpbWl0TGluZXMiLCJpc051bWJlciIsInRleHQiLCJjYWxjdWxhdGUiLCJ1bmRlZmluZWQiLCJyZWR1Y2UiLCJyZXN1bHQiLCJfcmVmMyIsImN1cnJlbnRMaW5lIiwiTnVtYmVyIiwibmV3TGluZSIsIm9yaWdpbmFsUmVzdWx0IiwiZmluZExvbmdlc3RMaW5lIiwiYiIsInN1ZmZpeCIsImNoZWNrT3ZlcmZsb3ciLCJpbmRleCIsInRlbXBUZXh0IiwiZG9lc092ZXJmbG93Iiwic3RhcnQiLCJlbmQiLCJpdGVyYXRpb25zIiwidHJpbW1lZFJlc3VsdCIsIm1pZGRsZSIsIk1hdGgiLCJmbG9vciIsInByZXYiLCJfY2hlY2tPdmVyZmxvdyIsIl9jaGVja092ZXJmbG93MiIsImRvZXNQcmV2T3ZlcmZsb3ciLCJfY2hlY2tPdmVyZmxvdzMiLCJfY2hlY2tPdmVyZmxvdzQiLCJkb2VzTWlkZGxlT3ZlcmZsb3ciLCJnZXRXb3Jkc1dpdGhvdXRDYWxjdWxhdGUiLCJnZXRXb3Jkc0J5TGluZXMiLCJfcmVmNCIsIkdsb2JhbCIsImlzU3NyIiwid29yZFdpZHRocyIsIndjdyIsInN3IiwiREVGQVVMVF9GSUxMIiwiX3JlZjUiLCJfcmVmNSR4IiwieCIsInByb3BzWCIsIl9yZWY1JHkiLCJ5IiwicHJvcHNZIiwiX3JlZjUkbGluZUhlaWdodCIsImxpbmVIZWlnaHQiLCJfcmVmNSRjYXBIZWlnaHQiLCJjYXBIZWlnaHQiLCJfcmVmNSRzY2FsZVRvRml0IiwiX3JlZjUkdGV4dEFuY2hvciIsInRleHRBbmNob3IiLCJfcmVmNSR2ZXJ0aWNhbEFuY2hvciIsInZlcnRpY2FsQW5jaG9yIiwiX3JlZjUkZmlsbCIsImZpbGwiLCJwcm9wcyIsIndvcmRzQnlMaW5lcyIsInVzZU1lbW8iLCJkeCIsImR5IiwiYW5nbGUiLCJjbGFzc05hbWUiLCJ0ZXh0UHJvcHMiLCJpc051bU9yU3RyIiwic3RhcnREeSIsInJlZHVjZUNTU0NhbGMiLCJjb25jYXQiLCJ0cmFuc2Zvcm1zIiwidHJhbnNmb3JtIiwiam9pbiIsImNyZWF0ZUVsZW1lbnQiLCJmaWx0ZXJQcm9wcyIsImluY2x1ZGVzIiwibGluZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/component/Text.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/component/Tooltip.js":
/*!********************************************************!*\
  !*** ./node_modules/recharts/lib/component/Tooltip.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Tooltip = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _DefaultTooltipContent = __webpack_require__(/*! ./DefaultTooltipContent */ \"(pages-dir-node)/./node_modules/recharts/lib/component/DefaultTooltipContent.js\");\nvar _TooltipBoundingBox = __webpack_require__(/*! ./TooltipBoundingBox */ \"(pages-dir-node)/./node_modules/recharts/lib/component/TooltipBoundingBox.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"(pages-dir-node)/./node_modules/recharts/lib/util/Global.js\");\nvar _getUniqPayload = __webpack_require__(/*! ../util/payload/getUniqPayload */ \"(pages-dir-node)/./node_modules/recharts/lib/util/payload/getUniqPayload.js\");\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Tooltip\r\n */ \nfunction defaultUniqBy(entry) {\n    return entry.dataKey;\n}\nfunction renderContent(content, props) {\n    if (/*#__PURE__*/ _react[\"default\"].isValidElement(content)) {\n        return /*#__PURE__*/ _react[\"default\"].cloneElement(content, props);\n    }\n    if (typeof content === 'function') {\n        return /*#__PURE__*/ _react[\"default\"].createElement(content, props);\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(_DefaultTooltipContent.DefaultTooltipContent, props);\n}\nvar Tooltip = exports.Tooltip = /*#__PURE__*/ function(_PureComponent) {\n    function Tooltip() {\n        _classCallCheck(this, Tooltip);\n        return _callSuper(this, Tooltip, arguments);\n    }\n    _inherits(Tooltip, _PureComponent);\n    return _createClass(Tooltip, [\n        {\n            key: \"render\",\n            value: function render() {\n                var _this = this;\n                var _this$props = this.props, active = _this$props.active, allowEscapeViewBox = _this$props.allowEscapeViewBox, animationDuration = _this$props.animationDuration, animationEasing = _this$props.animationEasing, content = _this$props.content, coordinate = _this$props.coordinate, filterNull = _this$props.filterNull, isAnimationActive = _this$props.isAnimationActive, offset = _this$props.offset, payload = _this$props.payload, payloadUniqBy = _this$props.payloadUniqBy, position = _this$props.position, reverseDirection = _this$props.reverseDirection, useTranslate3d = _this$props.useTranslate3d, viewBox = _this$props.viewBox, wrapperStyle = _this$props.wrapperStyle;\n                var finalPayload = payload !== null && payload !== void 0 ? payload : [];\n                if (filterNull && finalPayload.length) {\n                    finalPayload = (0, _getUniqPayload.getUniqPayload)(payload.filter(function(entry) {\n                        return entry.value != null && (entry.hide !== true || _this.props.includeHidden);\n                    }), payloadUniqBy, defaultUniqBy);\n                }\n                var hasPayload = finalPayload.length > 0;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_TooltipBoundingBox.TooltipBoundingBox, {\n                    allowEscapeViewBox: allowEscapeViewBox,\n                    animationDuration: animationDuration,\n                    animationEasing: animationEasing,\n                    isAnimationActive: isAnimationActive,\n                    active: active,\n                    coordinate: coordinate,\n                    hasPayload: hasPayload,\n                    offset: offset,\n                    position: position,\n                    reverseDirection: reverseDirection,\n                    useTranslate3d: useTranslate3d,\n                    viewBox: viewBox,\n                    wrapperStyle: wrapperStyle\n                }, renderContent(content, _objectSpread(_objectSpread({}, this.props), {}, {\n                    payload: finalPayload\n                })));\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(Tooltip, \"displayName\", 'Tooltip');\n_defineProperty(Tooltip, \"defaultProps\", {\n    accessibilityLayer: false,\n    allowEscapeViewBox: {\n        x: false,\n        y: false\n    },\n    animationDuration: 400,\n    animationEasing: 'ease',\n    contentStyle: {},\n    coordinate: {\n        x: 0,\n        y: 0\n    },\n    cursor: true,\n    cursorStyle: {},\n    filterNull: true,\n    isAnimationActive: !_Global.Global.isSsr,\n    itemStyle: {},\n    labelStyle: {},\n    offset: 10,\n    reverseDirection: {\n        x: false,\n        y: false\n    },\n    separator: ' : ',\n    trigger: 'hover',\n    useTranslate3d: false,\n    viewBox: {\n        x: 0,\n        y: 0,\n        height: 0,\n        width: 0\n    },\n    wrapperStyle: {}\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY29tcG9uZW50L1Rvb2x0aXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGVBQWUsR0FBRyxLQUFLO0FBQ3ZCLElBQUlHLFNBQVNDLHdCQUF3QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUMseUJBQXlCRCxtQkFBT0EsQ0FBQyxnSEFBeUI7QUFDOUQsSUFBSUUsc0JBQXNCRixtQkFBT0EsQ0FBQywwR0FBc0I7QUFDeEQsSUFBSUcsVUFBVUgsbUJBQU9BLENBQUMsbUZBQWdCO0FBQ3RDLElBQUlJLGtCQUFrQkosbUJBQU9BLENBQUMsbUhBQWdDO0FBQzlELFNBQVNLLHlCQUF5QkMsQ0FBQztJQUFJLElBQUksY0FBYyxPQUFPQyxTQUFTLE9BQU87SUFBTSxJQUFJQyxJQUFJLElBQUlELFdBQVdFLElBQUksSUFBSUY7SUFBVyxPQUFPLENBQUNGLDJCQUEyQixTQUFTQSx5QkFBeUJDLENBQUM7UUFBSSxPQUFPQSxJQUFJRyxJQUFJRDtJQUFHLEdBQUdGO0FBQUk7QUFDbk8sU0FBU1Asd0JBQXdCTyxDQUFDLEVBQUVFLENBQUM7SUFBSSxJQUFJLENBQUNBLEtBQUtGLEtBQUtBLEVBQUVJLFVBQVUsRUFBRSxPQUFPSjtJQUFHLElBQUksU0FBU0EsS0FBSyxZQUFZSyxRQUFRTCxNQUFNLGNBQWMsT0FBT0EsR0FBRyxPQUFPO1FBQUUsV0FBV0E7SUFBRTtJQUFHLElBQUlHLElBQUlKLHlCQUF5Qkc7SUFBSSxJQUFJQyxLQUFLQSxFQUFFRyxHQUFHLENBQUNOLElBQUksT0FBT0csRUFBRUksR0FBRyxDQUFDUDtJQUFJLElBQUlRLElBQUk7UUFBRUMsV0FBVztJQUFLLEdBQUdDLElBQUl2QixPQUFPQyxjQUFjLElBQUlELE9BQU93Qix3QkFBd0I7SUFBRSxJQUFLLElBQUlDLEtBQUtaLEVBQUcsSUFBSSxjQUFj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QyxPQUFPO0lBQ1Q7SUFDQXJCLGNBQWMsQ0FBQztBQUNqQiIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcY29tcG9uZW50XFxUb29sdGlwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuVG9vbHRpcCA9IHZvaWQgMDtcclxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBfRGVmYXVsdFRvb2x0aXBDb250ZW50ID0gcmVxdWlyZShcIi4vRGVmYXVsdFRvb2x0aXBDb250ZW50XCIpO1xyXG52YXIgX1Rvb2x0aXBCb3VuZGluZ0JveCA9IHJlcXVpcmUoXCIuL1Rvb2x0aXBCb3VuZGluZ0JveFwiKTtcclxudmFyIF9HbG9iYWwgPSByZXF1aXJlKFwiLi4vdXRpbC9HbG9iYWxcIik7XHJcbnZhciBfZ2V0VW5pcVBheWxvYWQgPSByZXF1aXJlKFwiLi4vdXRpbC9wYXlsb2FkL2dldFVuaXFQYXlsb2FkXCIpO1xyXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XHJcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XHJcbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XHJcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxyXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cclxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XHJcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XHJcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cclxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH0gLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgVG9vbHRpcFxyXG4gKi9cclxuZnVuY3Rpb24gZGVmYXVsdFVuaXFCeShlbnRyeSkge1xyXG4gIHJldHVybiBlbnRyeS5kYXRhS2V5O1xyXG59XHJcbmZ1bmN0aW9uIHJlbmRlckNvbnRlbnQoY29udGVudCwgcHJvcHMpIHtcclxuICBpZiAoIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KGNvbnRlbnQpKSB7XHJcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGNvbnRlbnQsIHByb3BzKTtcclxuICB9XHJcbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChjb250ZW50LCBwcm9wcyk7XHJcbiAgfVxyXG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9EZWZhdWx0VG9vbHRpcENvbnRlbnQuRGVmYXVsdFRvb2x0aXBDb250ZW50LCBwcm9wcyk7XHJcbn1cclxudmFyIFRvb2x0aXAgPSBleHBvcnRzLlRvb2x0aXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QdXJlQ29tcG9uZW50KSB7XHJcbiAgZnVuY3Rpb24gVG9vbHRpcCgpIHtcclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb29sdGlwKTtcclxuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIFRvb2x0aXAsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG4gIF9pbmhlcml0cyhUb29sdGlwLCBfUHVyZUNvbXBvbmVudCk7XHJcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhUb29sdGlwLCBbe1xyXG4gICAga2V5OiBcInJlbmRlclwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcclxuICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBhY3RpdmUgPSBfdGhpcyRwcm9wcy5hY3RpdmUsXHJcbiAgICAgICAgYWxsb3dFc2NhcGVWaWV3Qm94ID0gX3RoaXMkcHJvcHMuYWxsb3dFc2NhcGVWaWV3Qm94LFxyXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uID0gX3RoaXMkcHJvcHMuYW5pbWF0aW9uRHVyYXRpb24sXHJcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nID0gX3RoaXMkcHJvcHMuYW5pbWF0aW9uRWFzaW5nLFxyXG4gICAgICAgIGNvbnRlbnQgPSBfdGhpcyRwcm9wcy5jb250ZW50LFxyXG4gICAgICAgIGNvb3JkaW5hdGUgPSBfdGhpcyRwcm9wcy5jb29yZGluYXRlLFxyXG4gICAgICAgIGZpbHRlck51bGwgPSBfdGhpcyRwcm9wcy5maWx0ZXJOdWxsLFxyXG4gICAgICAgIGlzQW5pbWF0aW9uQWN0aXZlID0gX3RoaXMkcHJvcHMuaXNBbmltYXRpb25BY3RpdmUsXHJcbiAgICAgICAgb2Zmc2V0ID0gX3RoaXMkcHJvcHMub2Zmc2V0LFxyXG4gICAgICAgIHBheWxvYWQgPSBfdGhpcyRwcm9wcy5wYXlsb2FkLFxyXG4gICAgICAgIHBheWxvYWRVbmlxQnkgPSBfdGhpcyRwcm9wcy5wYXlsb2FkVW5pcUJ5LFxyXG4gICAgICAgIHBvc2l0aW9uID0gX3RoaXMkcHJvcHMucG9zaXRpb24sXHJcbiAgICAgICAgcmV2ZXJzZURpcmVjdGlvbiA9IF90aGlzJHByb3BzLnJldmVyc2VEaXJlY3Rpb24sXHJcbiAgICAgICAgdXNlVHJhbnNsYXRlM2QgPSBfdGhpcyRwcm9wcy51c2VUcmFuc2xhdGUzZCxcclxuICAgICAgICB2aWV3Qm94ID0gX3RoaXMkcHJvcHMudmlld0JveCxcclxuICAgICAgICB3cmFwcGVyU3R5bGUgPSBfdGhpcyRwcm9wcy53cmFwcGVyU3R5bGU7XHJcbiAgICAgIHZhciBmaW5hbFBheWxvYWQgPSBwYXlsb2FkICE9PSBudWxsICYmIHBheWxvYWQgIT09IHZvaWQgMCA/IHBheWxvYWQgOiBbXTtcclxuICAgICAgaWYgKGZpbHRlck51bGwgJiYgZmluYWxQYXlsb2FkLmxlbmd0aCkge1xyXG4gICAgICAgIGZpbmFsUGF5bG9hZCA9ICgwLCBfZ2V0VW5pcVBheWxvYWQuZ2V0VW5pcVBheWxvYWQpKHBheWxvYWQuZmlsdGVyKGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlICE9IG51bGwgJiYgKGVudHJ5LmhpZGUgIT09IHRydWUgfHwgX3RoaXMucHJvcHMuaW5jbHVkZUhpZGRlbik7XHJcbiAgICAgICAgfSksIHBheWxvYWRVbmlxQnksIGRlZmF1bHRVbmlxQnkpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBoYXNQYXlsb2FkID0gZmluYWxQYXlsb2FkLmxlbmd0aCA+IDA7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9Ub29sdGlwQm91bmRpbmdCb3guVG9vbHRpcEJvdW5kaW5nQm94LCB7XHJcbiAgICAgICAgYWxsb3dFc2NhcGVWaWV3Qm94OiBhbGxvd0VzY2FwZVZpZXdCb3gsXHJcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246IGFuaW1hdGlvbkR1cmF0aW9uLFxyXG4gICAgICAgIGFuaW1hdGlvbkVhc2luZzogYW5pbWF0aW9uRWFzaW5nLFxyXG4gICAgICAgIGlzQW5pbWF0aW9uQWN0aXZlOiBpc0FuaW1hdGlvbkFjdGl2ZSxcclxuICAgICAgICBhY3RpdmU6IGFjdGl2ZSxcclxuICAgICAgICBjb29yZGluYXRlOiBjb29yZGluYXRlLFxyXG4gICAgICAgIGhhc1BheWxvYWQ6IGhhc1BheWxvYWQsXHJcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXHJcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxyXG4gICAgICAgIHJldmVyc2VEaXJlY3Rpb246IHJldmVyc2VEaXJlY3Rpb24sXHJcbiAgICAgICAgdXNlVHJhbnNsYXRlM2Q6IHVzZVRyYW5zbGF0ZTNkLFxyXG4gICAgICAgIHZpZXdCb3g6IHZpZXdCb3gsXHJcbiAgICAgICAgd3JhcHBlclN0eWxlOiB3cmFwcGVyU3R5bGVcclxuICAgICAgfSwgcmVuZGVyQ29udGVudChjb250ZW50LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMucHJvcHMpLCB7fSwge1xyXG4gICAgICAgIHBheWxvYWQ6IGZpbmFsUGF5bG9hZFxyXG4gICAgICB9KSkpO1xyXG4gICAgfVxyXG4gIH1dKTtcclxufShfcmVhY3QuUHVyZUNvbXBvbmVudCk7XHJcbl9kZWZpbmVQcm9wZXJ0eShUb29sdGlwLCBcImRpc3BsYXlOYW1lXCIsICdUb29sdGlwJyk7XHJcbl9kZWZpbmVQcm9wZXJ0eShUb29sdGlwLCBcImRlZmF1bHRQcm9wc1wiLCB7XHJcbiAgYWNjZXNzaWJpbGl0eUxheWVyOiBmYWxzZSxcclxuICBhbGxvd0VzY2FwZVZpZXdCb3g6IHtcclxuICAgIHg6IGZhbHNlLFxyXG4gICAgeTogZmFsc2VcclxuICB9LFxyXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA0MDAsXHJcbiAgYW5pbWF0aW9uRWFzaW5nOiAnZWFzZScsXHJcbiAgY29udGVudFN0eWxlOiB7fSxcclxuICBjb29yZGluYXRlOiB7XHJcbiAgICB4OiAwLFxyXG4gICAgeTogMFxyXG4gIH0sXHJcbiAgY3Vyc29yOiB0cnVlLFxyXG4gIGN1cnNvclN0eWxlOiB7fSxcclxuICBmaWx0ZXJOdWxsOiB0cnVlLFxyXG4gIGlzQW5pbWF0aW9uQWN0aXZlOiAhX0dsb2JhbC5HbG9iYWwuaXNTc3IsXHJcbiAgaXRlbVN0eWxlOiB7fSxcclxuICBsYWJlbFN0eWxlOiB7fSxcclxuICBvZmZzZXQ6IDEwLFxyXG4gIHJldmVyc2VEaXJlY3Rpb246IHtcclxuICAgIHg6IGZhbHNlLFxyXG4gICAgeTogZmFsc2VcclxuICB9LFxyXG4gIHNlcGFyYXRvcjogJyA6ICcsXHJcbiAgdHJpZ2dlcjogJ2hvdmVyJyxcclxuICB1c2VUcmFuc2xhdGUzZDogZmFsc2UsXHJcbiAgdmlld0JveDoge1xyXG4gICAgeDogMCxcclxuICAgIHk6IDAsXHJcbiAgICBoZWlnaHQ6IDAsXHJcbiAgICB3aWR0aDogMFxyXG4gIH0sXHJcbiAgd3JhcHBlclN0eWxlOiB7fVxyXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJUb29sdGlwIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX0RlZmF1bHRUb29sdGlwQ29udGVudCIsIl9Ub29sdGlwQm91bmRpbmdCb3giLCJfR2xvYmFsIiwiX2dldFVuaXFQYXlsb2FkIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl9fZXNNb2R1bGUiLCJfdHlwZW9mIiwiaGFzIiwiZ2V0IiwibiIsIl9fcHJvdG9fXyIsImEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ1IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaSIsInNldCIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1Byb3BlcnR5S2V5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NhbGxTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiQm9vbGVhbiIsInZhbHVlT2YiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiYmluZCIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsInAiLCJvYmoiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsImRlZmF1bHRVbmlxQnkiLCJlbnRyeSIsImRhdGFLZXkiLCJyZW5kZXJDb250ZW50IiwiY29udGVudCIsImlzVmFsaWRFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsIkRlZmF1bHRUb29sdGlwQ29udGVudCIsIl9QdXJlQ29tcG9uZW50IiwicmVuZGVyIiwiX3RoaXMiLCJfdGhpcyRwcm9wcyIsImFjdGl2ZSIsImFsbG93RXNjYXBlVmlld0JveCIsImFuaW1hdGlvbkR1cmF0aW9uIiwiYW5pbWF0aW9uRWFzaW5nIiwiY29vcmRpbmF0ZSIsImZpbHRlck51bGwiLCJpc0FuaW1hdGlvbkFjdGl2ZSIsIm9mZnNldCIsInBheWxvYWQiLCJwYXlsb2FkVW5pcUJ5IiwicG9zaXRpb24iLCJyZXZlcnNlRGlyZWN0aW9uIiwidXNlVHJhbnNsYXRlM2QiLCJ2aWV3Qm94Iiwid3JhcHBlclN0eWxlIiwiZmluYWxQYXlsb2FkIiwiZ2V0VW5pcVBheWxvYWQiLCJoaWRlIiwiaW5jbHVkZUhpZGRlbiIsImhhc1BheWxvYWQiLCJUb29sdGlwQm91bmRpbmdCb3giLCJQdXJlQ29tcG9uZW50IiwiYWNjZXNzaWJpbGl0eUxheWVyIiwieCIsInkiLCJjb250ZW50U3R5bGUiLCJjdXJzb3IiLCJjdXJzb3JTdHlsZSIsIkdsb2JhbCIsImlzU3NyIiwiaXRlbVN0eWxlIiwibGFiZWxTdHlsZSIsInNlcGFyYXRvciIsInRyaWdnZXIiLCJoZWlnaHQiLCJ3aWR0aCJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/component/Tooltip.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/component/TooltipBoundingBox.js":
/*!*******************************************************************!*\
  !*** ./node_modules/recharts/lib/component/TooltipBoundingBox.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.TooltipBoundingBox = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _translate = __webpack_require__(/*! ../util/tooltip/translate */ \"(pages-dir-node)/./node_modules/recharts/lib/util/tooltip/translate.js\");\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar EPSILON = 1;\nvar TooltipBoundingBox = exports.TooltipBoundingBox = /*#__PURE__*/ function(_PureComponent) {\n    function TooltipBoundingBox() {\n        var _this;\n        _classCallCheck(this, TooltipBoundingBox);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, TooltipBoundingBox, [].concat(args));\n        _defineProperty(_this, \"state\", {\n            dismissed: false,\n            dismissedAtCoordinate: {\n                x: 0,\n                y: 0\n            },\n            lastBoundingBox: {\n                width: -1,\n                height: -1\n            }\n        });\n        _defineProperty(_this, \"handleKeyDown\", function(event) {\n            if (event.key === 'Escape') {\n                var _this$props$coordinat, _this$props$coordinat2, _this$props$coordinat3, _this$props$coordinat4;\n                _this.setState({\n                    dismissed: true,\n                    dismissedAtCoordinate: {\n                        x: (_this$props$coordinat = (_this$props$coordinat2 = _this.props.coordinate) === null || _this$props$coordinat2 === void 0 ? void 0 : _this$props$coordinat2.x) !== null && _this$props$coordinat !== void 0 ? _this$props$coordinat : 0,\n                        y: (_this$props$coordinat3 = (_this$props$coordinat4 = _this.props.coordinate) === null || _this$props$coordinat4 === void 0 ? void 0 : _this$props$coordinat4.y) !== null && _this$props$coordinat3 !== void 0 ? _this$props$coordinat3 : 0\n                    }\n                });\n            }\n        });\n        return _this;\n    }\n    _inherits(TooltipBoundingBox, _PureComponent);\n    return _createClass(TooltipBoundingBox, [\n        {\n            key: \"updateBBox\",\n            value: function updateBBox() {\n                if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {\n                    var box = this.wrapperNode.getBoundingClientRect();\n                    if (Math.abs(box.width - this.state.lastBoundingBox.width) > EPSILON || Math.abs(box.height - this.state.lastBoundingBox.height) > EPSILON) {\n                        this.setState({\n                            lastBoundingBox: {\n                                width: box.width,\n                                height: box.height\n                            }\n                        });\n                    }\n                } else if (this.state.lastBoundingBox.width !== -1 || this.state.lastBoundingBox.height !== -1) {\n                    this.setState({\n                        lastBoundingBox: {\n                            width: -1,\n                            height: -1\n                        }\n                    });\n                }\n            }\n        },\n        {\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n                document.addEventListener('keydown', this.handleKeyDown);\n                this.updateBBox();\n            }\n        },\n        {\n            key: \"componentWillUnmount\",\n            value: function componentWillUnmount() {\n                document.removeEventListener('keydown', this.handleKeyDown);\n            }\n        },\n        {\n            key: \"componentDidUpdate\",\n            value: function componentDidUpdate() {\n                var _this$props$coordinat5, _this$props$coordinat6;\n                if (this.props.active) {\n                    this.updateBBox();\n                }\n                if (!this.state.dismissed) {\n                    return;\n                }\n                if (((_this$props$coordinat5 = this.props.coordinate) === null || _this$props$coordinat5 === void 0 ? void 0 : _this$props$coordinat5.x) !== this.state.dismissedAtCoordinate.x || ((_this$props$coordinat6 = this.props.coordinate) === null || _this$props$coordinat6 === void 0 ? void 0 : _this$props$coordinat6.y) !== this.state.dismissedAtCoordinate.y) {\n                    this.state.dismissed = false;\n                }\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this2 = this;\n                var _this$props = this.props, active = _this$props.active, allowEscapeViewBox = _this$props.allowEscapeViewBox, animationDuration = _this$props.animationDuration, animationEasing = _this$props.animationEasing, children = _this$props.children, coordinate = _this$props.coordinate, hasPayload = _this$props.hasPayload, isAnimationActive = _this$props.isAnimationActive, offset = _this$props.offset, position = _this$props.position, reverseDirection = _this$props.reverseDirection, useTranslate3d = _this$props.useTranslate3d, viewBox = _this$props.viewBox, wrapperStyle = _this$props.wrapperStyle;\n                var _getTooltipTranslate = (0, _translate.getTooltipTranslate)({\n                    allowEscapeViewBox: allowEscapeViewBox,\n                    coordinate: coordinate,\n                    offsetTopLeft: offset,\n                    position: position,\n                    reverseDirection: reverseDirection,\n                    tooltipBox: this.state.lastBoundingBox,\n                    useTranslate3d: useTranslate3d,\n                    viewBox: viewBox\n                }), cssClasses = _getTooltipTranslate.cssClasses, cssProperties = _getTooltipTranslate.cssProperties;\n                var outerStyle = _objectSpread(_objectSpread({\n                    transition: isAnimationActive && active ? \"transform \".concat(animationDuration, \"ms \").concat(animationEasing) : undefined\n                }, cssProperties), {}, {\n                    pointerEvents: 'none',\n                    visibility: !this.state.dismissed && active && hasPayload ? 'visible' : 'hidden',\n                    position: 'absolute',\n                    top: 0,\n                    left: 0\n                }, wrapperStyle);\n                return(/*#__PURE__*/ // This element allow listening to the `Escape` key.\n                // See https://github.com/recharts/recharts/pull/2925\n                _react[\"default\"].createElement(\"div\", {\n                    tabIndex: -1,\n                    className: cssClasses,\n                    style: outerStyle,\n                    ref: function ref(node) {\n                        _this2.wrapperNode = node;\n                    }\n                }, children));\n            }\n        }\n    ]);\n}(_react.PureComponent);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY29tcG9uZW50L1Rvb2x0aXBCb3VuZGluZ0JveC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsMEJBQTBCLEdBQUcsS0FBSztBQUNsQyxJQUFJRyxTQUFTQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3BELElBQUlDLGFBQWFELG1CQUFPQSxDQUFDLHlHQUEyQjtBQUNwRCxTQUFTRSx5QkFBeUJDLENBQUM7SUFBSSxJQUFJLGNBQWMsT0FBT0MsU0FBUyxPQUFPO0lBQU0sSUFBSUMsSUFBSSxJQUFJRCxXQUFXRSxJQUFJLElBQUlGO0lBQVcsT0FBTyxDQUFDRiwyQkFBMkIsU0FBU0EseUJBQXlCQyxDQUFDO1FBQUksT0FBT0EsSUFBSUcsSUFBSUQ7SUFBRyxHQUFHRjtBQUFJO0FBQ25PLFNBQVNKLHdCQUF3QkksQ0FBQyxFQUFFRSxDQUFDO0lBQUksSUFBSSxDQUFDQSxLQUFLRixLQUFLQSxFQUFFSSxVQUFVLEVBQUUsT0FBT0o7SUFBRyxJQUFJLFNBQVNBLEtBQUssWUFBWUssUUFBUUwsTUFBTSxjQUFjLE9BQU9BLEdBQUcsT0FBTztRQUFFLFdBQVdBO0lBQUU7SUFBRyxJQUFJRyxJQUFJSix5QkFBeUJHO0lBQUksSUFBSUMsS0FBS0EsRUFBRUcsR0FBRyxDQUFDTixJQUFJLE9BQU9HLEVBQUVJLEdBQUcsQ0FBQ1A7SUFBSSxJQUFJUSxJQUFJO1FBQUVDLFdBQVc7SUFBSyxHQUFHQyxJQUFJcEIsT0FBT0MsY0FBYyxJQUFJRCxPQUFPcUIsd0JBQXdCO0lBQUUsSUFBSyxJQUFJQyxLQUFLWixFQUFHLElBQUksY0FBY1ksS0FBSyxFQUFDLEdBQUVDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDZCxHQUFHWSxJQUFJO1FBQUUsSUFBSUcsSUFBSUwsSUFBSXBCLE9BQU9xQix3QkFBd0IsQ0FBQ1gsR0FBR1ksS0FB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LE1BQU0sQ0FBQ3FDLG1CQUFtQmtCO2dCQUNwSCxHQUFHSCxnQkFBZ0IsQ0FBQyxHQUFHO29CQUNyQkksZUFBZTtvQkFDZkMsWUFBWSxDQUFDLElBQUksQ0FBQ3BDLEtBQUssQ0FBQ3BCLFNBQVMsSUFBSThCLFVBQVVRLGFBQWEsWUFBWTtvQkFDeEVHLFVBQVU7b0JBQ1ZnQixLQUFLO29CQUNMQyxNQUFNO2dCQUNSLEdBQUdiO2dCQUNILE9BQ0UsV0FBVyxHQUNYLG9EQUFvRDtnQkFDcEQscURBQXFEO2dCQUNyRHJJLE1BQU0sQ0FBQyxVQUFVLENBQUNtSixhQUFhLENBQUMsT0FBTztvQkFDckNDLFVBQVUsQ0FBQztvQkFDWEMsV0FBV1g7b0JBQ1hZLE9BQU9WO29CQUNQVyxLQUFLLFNBQVNBLElBQUlDLElBQUk7d0JBQ3BCaEMsT0FBT2pCLFdBQVcsR0FBR2lEO29CQUN2QjtnQkFDRixHQUFHM0I7WUFFUDtRQUNGO0tBQUU7QUFDSixFQUFFN0gsT0FBT3lKLGFBQWEiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXGNvbXBvbmVudFxcVG9vbHRpcEJvdW5kaW5nQm94LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuVG9vbHRpcEJvdW5kaW5nQm94ID0gdm9pZCAwO1xyXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIF90cmFuc2xhdGUgPSByZXF1aXJlKFwiLi4vdXRpbC90b29sdGlwL3RyYW5zbGF0ZVwiKTtcclxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxyXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxyXG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxyXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cclxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XHJcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxyXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxyXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxyXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxyXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XHJcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XHJcbnZhciBFUFNJTE9OID0gMTtcclxudmFyIFRvb2x0aXBCb3VuZGluZ0JveCA9IGV4cG9ydHMuVG9vbHRpcEJvdW5kaW5nQm94ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xyXG4gIGZ1bmN0aW9uIFRvb2x0aXBCb3VuZGluZ0JveCgpIHtcclxuICAgIHZhciBfdGhpcztcclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb29sdGlwQm91bmRpbmdCb3gpO1xyXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgICB9XHJcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgVG9vbHRpcEJvdW5kaW5nQm94LCBbXS5jb25jYXQoYXJncykpO1xyXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInN0YXRlXCIsIHtcclxuICAgICAgZGlzbWlzc2VkOiBmYWxzZSxcclxuICAgICAgZGlzbWlzc2VkQXRDb29yZGluYXRlOiB7XHJcbiAgICAgICAgeDogMCxcclxuICAgICAgICB5OiAwXHJcbiAgICAgIH0sXHJcbiAgICAgIGxhc3RCb3VuZGluZ0JveDoge1xyXG4gICAgICAgIHdpZHRoOiAtMSxcclxuICAgICAgICBoZWlnaHQ6IC0xXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZUtleURvd25cIiwgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgIGlmIChldmVudC5rZXkgPT09ICdFc2NhcGUnKSB7XHJcbiAgICAgICAgdmFyIF90aGlzJHByb3BzJGNvb3JkaW5hdCwgX3RoaXMkcHJvcHMkY29vcmRpbmF0MiwgX3RoaXMkcHJvcHMkY29vcmRpbmF0MywgX3RoaXMkcHJvcHMkY29vcmRpbmF0NDtcclxuICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICBkaXNtaXNzZWQ6IHRydWUsXHJcbiAgICAgICAgICBkaXNtaXNzZWRBdENvb3JkaW5hdGU6IHtcclxuICAgICAgICAgICAgeDogKF90aGlzJHByb3BzJGNvb3JkaW5hdCA9IChfdGhpcyRwcm9wcyRjb29yZGluYXQyID0gX3RoaXMucHJvcHMuY29vcmRpbmF0ZSkgPT09IG51bGwgfHwgX3RoaXMkcHJvcHMkY29vcmRpbmF0MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcHJvcHMkY29vcmRpbmF0Mi54KSAhPT0gbnVsbCAmJiBfdGhpcyRwcm9wcyRjb29yZGluYXQgIT09IHZvaWQgMCA/IF90aGlzJHByb3BzJGNvb3JkaW5hdCA6IDAsXHJcbiAgICAgICAgICAgIHk6IChfdGhpcyRwcm9wcyRjb29yZGluYXQzID0gKF90aGlzJHByb3BzJGNvb3JkaW5hdDQgPSBfdGhpcy5wcm9wcy5jb29yZGluYXRlKSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wcyRjb29yZGluYXQ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRwcm9wcyRjb29yZGluYXQ0LnkpICE9PSBudWxsICYmIF90aGlzJHByb3BzJGNvb3JkaW5hdDMgIT09IHZvaWQgMCA/IF90aGlzJHByb3BzJGNvb3JkaW5hdDMgOiAwXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuICBfaW5oZXJpdHMoVG9vbHRpcEJvdW5kaW5nQm94LCBfUHVyZUNvbXBvbmVudCk7XHJcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhUb29sdGlwQm91bmRpbmdCb3gsIFt7XHJcbiAgICBrZXk6IFwidXBkYXRlQkJveFwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJCb3goKSB7XHJcbiAgICAgIGlmICh0aGlzLndyYXBwZXJOb2RlICYmIHRoaXMud3JhcHBlck5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XHJcbiAgICAgICAgdmFyIGJveCA9IHRoaXMud3JhcHBlck5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKGJveC53aWR0aCAtIHRoaXMuc3RhdGUubGFzdEJvdW5kaW5nQm94LndpZHRoKSA+IEVQU0lMT04gfHwgTWF0aC5hYnMoYm94LmhlaWdodCAtIHRoaXMuc3RhdGUubGFzdEJvdW5kaW5nQm94LmhlaWdodCkgPiBFUFNJTE9OKSB7XHJcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgbGFzdEJvdW5kaW5nQm94OiB7XHJcbiAgICAgICAgICAgICAgd2lkdGg6IGJveC53aWR0aCxcclxuICAgICAgICAgICAgICBoZWlnaHQ6IGJveC5oZWlnaHRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUubGFzdEJvdW5kaW5nQm94LndpZHRoICE9PSAtMSB8fCB0aGlzLnN0YXRlLmxhc3RCb3VuZGluZ0JveC5oZWlnaHQgIT09IC0xKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICBsYXN0Qm91bmRpbmdCb3g6IHtcclxuICAgICAgICAgICAgd2lkdGg6IC0xLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IC0xXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bik7XHJcbiAgICAgIHRoaXMudXBkYXRlQkJveCgpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duKTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHMkY29vcmRpbmF0NSwgX3RoaXMkcHJvcHMkY29vcmRpbmF0NjtcclxuICAgICAgaWYgKHRoaXMucHJvcHMuYWN0aXZlKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVCQm94KCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0aGlzLnN0YXRlLmRpc21pc3NlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoKChfdGhpcyRwcm9wcyRjb29yZGluYXQ1ID0gdGhpcy5wcm9wcy5jb29yZGluYXRlKSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wcyRjb29yZGluYXQ1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRwcm9wcyRjb29yZGluYXQ1LngpICE9PSB0aGlzLnN0YXRlLmRpc21pc3NlZEF0Q29vcmRpbmF0ZS54IHx8ICgoX3RoaXMkcHJvcHMkY29vcmRpbmF0NiA9IHRoaXMucHJvcHMuY29vcmRpbmF0ZSkgPT09IG51bGwgfHwgX3RoaXMkcHJvcHMkY29vcmRpbmF0NiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcHJvcHMkY29vcmRpbmF0Ni55KSAhPT0gdGhpcy5zdGF0ZS5kaXNtaXNzZWRBdENvb3JkaW5hdGUueSkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUuZGlzbWlzc2VkID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBhY3RpdmUgPSBfdGhpcyRwcm9wcy5hY3RpdmUsXHJcbiAgICAgICAgYWxsb3dFc2NhcGVWaWV3Qm94ID0gX3RoaXMkcHJvcHMuYWxsb3dFc2NhcGVWaWV3Qm94LFxyXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uID0gX3RoaXMkcHJvcHMuYW5pbWF0aW9uRHVyYXRpb24sXHJcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nID0gX3RoaXMkcHJvcHMuYW5pbWF0aW9uRWFzaW5nLFxyXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW4sXHJcbiAgICAgICAgY29vcmRpbmF0ZSA9IF90aGlzJHByb3BzLmNvb3JkaW5hdGUsXHJcbiAgICAgICAgaGFzUGF5bG9hZCA9IF90aGlzJHByb3BzLmhhc1BheWxvYWQsXHJcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wcy5pc0FuaW1hdGlvbkFjdGl2ZSxcclxuICAgICAgICBvZmZzZXQgPSBfdGhpcyRwcm9wcy5vZmZzZXQsXHJcbiAgICAgICAgcG9zaXRpb24gPSBfdGhpcyRwcm9wcy5wb3NpdGlvbixcclxuICAgICAgICByZXZlcnNlRGlyZWN0aW9uID0gX3RoaXMkcHJvcHMucmV2ZXJzZURpcmVjdGlvbixcclxuICAgICAgICB1c2VUcmFuc2xhdGUzZCA9IF90aGlzJHByb3BzLnVzZVRyYW5zbGF0ZTNkLFxyXG4gICAgICAgIHZpZXdCb3ggPSBfdGhpcyRwcm9wcy52aWV3Qm94LFxyXG4gICAgICAgIHdyYXBwZXJTdHlsZSA9IF90aGlzJHByb3BzLndyYXBwZXJTdHlsZTtcclxuICAgICAgdmFyIF9nZXRUb29sdGlwVHJhbnNsYXRlID0gKDAsIF90cmFuc2xhdGUuZ2V0VG9vbHRpcFRyYW5zbGF0ZSkoe1xyXG4gICAgICAgICAgYWxsb3dFc2NhcGVWaWV3Qm94OiBhbGxvd0VzY2FwZVZpZXdCb3gsXHJcbiAgICAgICAgICBjb29yZGluYXRlOiBjb29yZGluYXRlLFxyXG4gICAgICAgICAgb2Zmc2V0VG9wTGVmdDogb2Zmc2V0LFxyXG4gICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxyXG4gICAgICAgICAgcmV2ZXJzZURpcmVjdGlvbjogcmV2ZXJzZURpcmVjdGlvbixcclxuICAgICAgICAgIHRvb2x0aXBCb3g6IHRoaXMuc3RhdGUubGFzdEJvdW5kaW5nQm94LFxyXG4gICAgICAgICAgdXNlVHJhbnNsYXRlM2Q6IHVzZVRyYW5zbGF0ZTNkLFxyXG4gICAgICAgICAgdmlld0JveDogdmlld0JveFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGNzc0NsYXNzZXMgPSBfZ2V0VG9vbHRpcFRyYW5zbGF0ZS5jc3NDbGFzc2VzLFxyXG4gICAgICAgIGNzc1Byb3BlcnRpZXMgPSBfZ2V0VG9vbHRpcFRyYW5zbGF0ZS5jc3NQcm9wZXJ0aWVzO1xyXG4gICAgICB2YXIgb3V0ZXJTdHlsZSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XHJcbiAgICAgICAgdHJhbnNpdGlvbjogaXNBbmltYXRpb25BY3RpdmUgJiYgYWN0aXZlID8gXCJ0cmFuc2Zvcm0gXCIuY29uY2F0KGFuaW1hdGlvbkR1cmF0aW9uLCBcIm1zIFwiKS5jb25jYXQoYW5pbWF0aW9uRWFzaW5nKSA6IHVuZGVmaW5lZFxyXG4gICAgICB9LCBjc3NQcm9wZXJ0aWVzKSwge30sIHtcclxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXHJcbiAgICAgICAgdmlzaWJpbGl0eTogIXRoaXMuc3RhdGUuZGlzbWlzc2VkICYmIGFjdGl2ZSAmJiBoYXNQYXlsb2FkID8gJ3Zpc2libGUnIDogJ2hpZGRlbicsXHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIGxlZnQ6IDBcclxuICAgICAgfSwgd3JhcHBlclN0eWxlKTtcclxuICAgICAgcmV0dXJuIChcclxuICAgICAgICAvKiNfX1BVUkVfXyovXHJcbiAgICAgICAgLy8gVGhpcyBlbGVtZW50IGFsbG93IGxpc3RlbmluZyB0byB0aGUgYEVzY2FwZWAga2V5LlxyXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVjaGFydHMvcmVjaGFydHMvcHVsbC8yOTI1XHJcbiAgICAgICAgX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcclxuICAgICAgICAgIHRhYkluZGV4OiAtMSxcclxuICAgICAgICAgIGNsYXNzTmFtZTogY3NzQ2xhc3NlcyxcclxuICAgICAgICAgIHN0eWxlOiBvdXRlclN0eWxlLFxyXG4gICAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYobm9kZSkge1xyXG4gICAgICAgICAgICBfdGhpczIud3JhcHBlck5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIGNoaWxkcmVuKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1dKTtcclxufShfcmVhY3QuUHVyZUNvbXBvbmVudCk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVG9vbHRpcEJvdW5kaW5nQm94IiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX3RyYW5zbGF0ZSIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJfX2VzTW9kdWxlIiwiX3R5cGVvZiIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9Qcm9wZXJ0eUtleSIsImtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsImJpbmQiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwib2JqIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJFUFNJTE9OIiwiX1B1cmVDb21wb25lbnQiLCJfdGhpcyIsIl9sZW4iLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiY29uY2F0IiwiZGlzbWlzc2VkIiwiZGlzbWlzc2VkQXRDb29yZGluYXRlIiwieCIsInkiLCJsYXN0Qm91bmRpbmdCb3giLCJ3aWR0aCIsImhlaWdodCIsImV2ZW50IiwiX3RoaXMkcHJvcHMkY29vcmRpbmF0IiwiX3RoaXMkcHJvcHMkY29vcmRpbmF0MiIsIl90aGlzJHByb3BzJGNvb3JkaW5hdDMiLCJfdGhpcyRwcm9wcyRjb29yZGluYXQ0Iiwic2V0U3RhdGUiLCJjb29yZGluYXRlIiwidXBkYXRlQkJveCIsIndyYXBwZXJOb2RlIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYm94IiwiTWF0aCIsImFicyIsInN0YXRlIiwiY29tcG9uZW50RGlkTW91bnQiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJoYW5kbGVLZXlEb3duIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiX3RoaXMkcHJvcHMkY29vcmRpbmF0NSIsIl90aGlzJHByb3BzJGNvb3JkaW5hdDYiLCJhY3RpdmUiLCJyZW5kZXIiLCJfdGhpczIiLCJfdGhpcyRwcm9wcyIsImFsbG93RXNjYXBlVmlld0JveCIsImFuaW1hdGlvbkR1cmF0aW9uIiwiYW5pbWF0aW9uRWFzaW5nIiwiY2hpbGRyZW4iLCJoYXNQYXlsb2FkIiwiaXNBbmltYXRpb25BY3RpdmUiLCJvZmZzZXQiLCJwb3NpdGlvbiIsInJldmVyc2VEaXJlY3Rpb24iLCJ1c2VUcmFuc2xhdGUzZCIsInZpZXdCb3giLCJ3cmFwcGVyU3R5bGUiLCJfZ2V0VG9vbHRpcFRyYW5zbGF0ZSIsImdldFRvb2x0aXBUcmFuc2xhdGUiLCJvZmZzZXRUb3BMZWZ0IiwidG9vbHRpcEJveCIsImNzc0NsYXNzZXMiLCJjc3NQcm9wZXJ0aWVzIiwib3V0ZXJTdHlsZSIsInRyYW5zaXRpb24iLCJ1bmRlZmluZWQiLCJwb2ludGVyRXZlbnRzIiwidmlzaWJpbGl0eSIsInRvcCIsImxlZnQiLCJjcmVhdGVFbGVtZW50IiwidGFiSW5kZXgiLCJjbGFzc05hbWUiLCJzdHlsZSIsInJlZiIsIm5vZGUiLCJQdXJlQ29tcG9uZW50Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/component/TooltipBoundingBox.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/container/Layer.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Layer = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"children\",\n    \"className\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nvar Layer = exports.Layer = /*#__PURE__*/ _react[\"default\"].forwardRef(function(props, ref) {\n    var children = props.children, className = props.className, others = _objectWithoutProperties(props, _excluded);\n    var layerClass = (0, _clsx[\"default\"])('recharts-layer', className);\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", _extends({\n        className: layerClass\n    }, (0, _ReactUtils.filterProps)(others, true), {\n        ref: ref\n    }), children);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY29udGFpbmVyL0xheWVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxhQUFhLEdBQUcsS0FBSztBQUNyQixJQUFJRyxTQUFTQyx1QkFBdUJDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ25ELElBQUlDLFFBQVFGLHVCQUF1QkMsbUJBQU9BLENBQUMsdUJBQU07QUFDakQsSUFBSUUsY0FBY0YsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlHLFlBQVk7SUFBQztJQUFZO0NBQVk7QUFDekMsU0FBU0osdUJBQXVCSyxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFO0lBQWFBLFdBQVdiLE9BQU9jLE1BQU0sR0FBR2QsT0FBT2MsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVUMsTUFBTTtRQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFBRSxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFBRSxJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQUUsSUFBSXBCLE9BQU9zQixTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRQyxNQUFNO29CQUFFTCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO2dCQUFFO1lBQUU7UUFBRTtRQUFFLE9BQU9MO0lBQVE7SUFBRyxPQUFPSCxTQUFTWSxLQUFLLENBQUMsSUFBSSxFQUFFUDtBQUFZO0FBQ2xWLFNBQVNRLHlCQUF5Qk4sTUFBTSxFQUFFTyxRQUFRO0lBQUksSUFBSVAsVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUFHLElBQUlKLFNBQVNZLDhCQUE4QlIsUUFBUU87SUFBVyxJQUFJTixLQUFLSjtJQUFHLElBQUlqQixPQUFPNkIscUJBQXFCLEVBQUU7UUFBRSxJQUFJQyxtQkFBbUI5QixPQUFPNkIscUJBQXFCLENBQUNUO1FBQVMsSUFBS0gsSUFBSSxHQUFHQSxJQUFJYSxpQkFBaUJYLE1BQU0sRUFBRUYsSUFBSztZQUFFSSxNQUFNUyxnQkFBZ0IsQ0FBQ2IsRUFBRTtZQUFFLElBQUlVLFNBQVNJLE9BQU8sQ0FBQ1YsUUFBUSxHQUFHO1lBQVUsSUFBSSxDQUFDckIsT0FBT3NCLFNBQVMsQ0FBQ1Usb0JBQW9CLENBQUNSLElBQUksQ0FBQ0osUUFBUUMsTUFBTTtZQUFVTCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO1FBQUU7SUFBRTtJQUFFLE9BQU9MO0FBQVE7QUFDM2UsU0FBU1ksOEJBQThCUixNQUFNLEVBQUVPLFFBQVE7SUFBSSxJQUFJUCxVQUFVLE1BQU0sT0FBTyxDQUFDO0lBQUcsSUFBSUosU0FBUyxDQUFDO0lBQUcsSUFBSyxJQUFJSyxPQUFPRCxPQUFRO1FBQUUsSUFBSXBCLE9BQU9zQixTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRQyxNQUFNO1lBQUUsSUFBSU0sU0FBU0ksT0FBTyxDQUFDVixRQUFRLEdBQUc7WUFBVUwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtRQUFFO0lBQUU7SUFBRSxPQUFPTDtBQUFRO0FBQ3RSLElBQUlaLFFBQVFGLGFBQWEsR0FBRyxXQUFXLEdBQUVHLE1BQU0sQ0FBQyxVQUFVLENBQUM0QixVQUFVLENBQUMsU0FBVUMsS0FBSyxFQUFFQyxHQUFHO0lBQ3hGLElBQUlDLFdBQVdGLE1BQU1FLFFBQVEsRUFDM0JDLFlBQVlILE1BQU1HLFNBQVMsRUFDM0JDLFNBQVNaLHlCQUF5QlEsT0FBT3hCO0lBQzNDLElBQUk2QixhQUFhLENBQUMsR0FBRy9CLEtBQUssQ0FBQyxVQUFVLEVBQUUsa0JBQWtCNkI7SUFDekQsT0FBTyxXQUFXLEdBQUVoQyxNQUFNLENBQUMsVUFBVSxDQUFDbUMsYUFBYSxDQUFDLEtBQUszQixTQUFTO1FBQ2hFd0IsV0FBV0U7SUFDYixHQUFHLENBQUMsR0FBRzlCLFlBQVlnQyxXQUFXLEVBQUVILFFBQVEsT0FBTztRQUM3Q0gsS0FBS0E7SUFDUCxJQUFJQztBQUNOIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxjb250YWluZXJcXExheWVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuTGF5ZXIgPSB2b2lkIDA7XHJcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xyXG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xyXG52YXIgX2V4Y2x1ZGVkID0gW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIl07XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxyXG52YXIgTGF5ZXIgPSBleHBvcnRzLkxheWVyID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xyXG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxyXG4gICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxyXG4gICAgb3RoZXJzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQpO1xyXG4gIHZhciBsYXllckNsYXNzID0gKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLWxheWVyJywgY2xhc3NOYW1lKTtcclxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImdcIiwgX2V4dGVuZHMoe1xyXG4gICAgY2xhc3NOYW1lOiBsYXllckNsYXNzXHJcbiAgfSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShvdGhlcnMsIHRydWUpLCB7XHJcbiAgICByZWY6IHJlZlxyXG4gIH0pLCBjaGlsZHJlbik7XHJcbn0pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkxheWVyIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfY2xzeCIsIl9SZWFjdFV0aWxzIiwiX2V4Y2x1ZGVkIiwib2JqIiwiX19lc01vZHVsZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsImV4Y2x1ZGVkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzb3VyY2VTeW1ib2xLZXlzIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiZm9yd2FyZFJlZiIsInByb3BzIiwicmVmIiwiY2hpbGRyZW4iLCJjbGFzc05hbWUiLCJvdGhlcnMiLCJsYXllckNsYXNzIiwiY3JlYXRlRWxlbWVudCIsImZpbHRlclByb3BzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/container/Surface.js":
/*!********************************************************!*\
  !*** ./node_modules/recharts/lib/container/Surface.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Surface = Surface;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"children\",\n    \"width\",\n    \"height\",\n    \"viewBox\",\n    \"className\",\n    \"style\",\n    \"title\",\n    \"desc\"\n];\n/**\r\n * @fileOverview Surface\r\n */ function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction Surface(props) {\n    var children = props.children, width = props.width, height = props.height, viewBox = props.viewBox, className = props.className, style = props.style, title = props.title, desc = props.desc, others = _objectWithoutProperties(props, _excluded);\n    var svgView = viewBox || {\n        width: width,\n        height: height,\n        x: 0,\n        y: 0\n    };\n    var layerClass = (0, _clsx[\"default\"])('recharts-surface', className);\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"svg\", _extends({}, (0, _ReactUtils.filterProps)(others, true, 'svg'), {\n        className: layerClass,\n        width: width,\n        height: height,\n        style: style,\n        viewBox: \"\".concat(svgView.x, \" \").concat(svgView.y, \" \").concat(svgView.width, \" \").concat(svgView.height)\n    }), /*#__PURE__*/ _react[\"default\"].createElement(\"title\", null, title), /*#__PURE__*/ _react[\"default\"].createElement(\"desc\", null, desc), children);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY29udGFpbmVyL1N1cmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGVBQWUsR0FBR0U7QUFDbEIsSUFBSUMsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNuRCxJQUFJQyxRQUFRRix1QkFBdUJDLG1CQUFPQSxDQUFDLHVCQUFNO0FBQ2pELElBQUlFLGNBQWNGLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM5QyxJQUFJRyxZQUFZO0lBQUM7SUFBWTtJQUFTO0lBQVU7SUFBVztJQUFhO0lBQVM7SUFBUztDQUFPO0FBQ2pHOztDQUVDLEdBQ0QsU0FBU0osdUJBQXVCSyxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFO0lBQWFBLFdBQVdiLE9BQU9jLE1BQU0sR0FBR2QsT0FBT2MsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVUMsTUFBTTtRQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFBRSxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFBRSxJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQUUsSUFBSXBCLE9BQU9zQixTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRQyxNQUFNO29CQUFFTCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO2dCQUFFO1lBQUU7UUFBRTtRQUFFLE9BQU9MO0lBQVE7SUFBRyxPQUFPSCxTQUFTWSxLQUFLLENBQUMsSUFBSSxFQUFFUDtBQUFZO0FBQ2xWLFNBQVNRLHlCQUF5Qk4sTUFBTSxFQUFFTyxRQUFRO0lBQUksSUFBSVAsVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUFHLElBQUlKLFNBQVNZLDhCQUE4QlIsUUFBUU87SUFBVyxJQUFJTixLQUFLSjtJQUFHLElBQUlqQixPQUFPNkIscUJBQXFCLEVBQUU7UUFBRSxJQUFJQyxtQkFBbUI5QixPQUFPNkIscUJBQXFCLENBQUNUO1FBQVMsSUFBS0gsSUFBSSxHQUFHQSxJQUFJYSxpQkFBaUJYLE1BQU0sRUFBRUYsSUFBSztZQUFFSSxNQUFNUyxnQkFBZ0IsQ0FBQ2IsRUFBRTtZQUFFLElBQUlVLFNBQVNJLE9BQU8sQ0FBQ1YsUUFBUSxHQUFHO1lBQVUsSUFBSSxDQUFDckIsT0FBT3NCLFNBQVMsQ0FBQ1Usb0JBQW9CLENBQUNSLElBQUksQ0FBQ0osUUFBUUMsTUFBTTtZQUFVTCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO1FBQUU7SUFBRTtJQUFFLE9BQU9MO0FBQVE7QUFDM2UsU0FBU1ksOEJBQThCUixNQUFNLEVBQUVPLFFBQVE7SUFBSSxJQUFJUCxVQUFVLE1BQU0sT0FBTyxDQUFDO0lBQUcsSUFBSUosU0FBUyxDQUFDO0lBQUcsSUFBSyxJQUFJSyxPQUFPRCxPQUFRO1FBQUUsSUFBSXBCLE9BQU9zQixTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRQyxNQUFNO1lBQUUsSUFBSU0sU0FBU0ksT0FBTyxDQUFDVixRQUFRLEdBQUc7WUFBVUwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtRQUFFO0lBQUU7SUFBRSxPQUFPTDtBQUFRO0FBQ3RSLFNBQVNaLFFBQVE2QixLQUFLO0lBQ3BCLElBQUlDLFdBQVdELE1BQU1DLFFBQVEsRUFDM0JDLFFBQVFGLE1BQU1FLEtBQUssRUFDbkJDLFNBQVNILE1BQU1HLE1BQU0sRUFDckJDLFVBQVVKLE1BQU1JLE9BQU8sRUFDdkJDLFlBQVlMLE1BQU1LLFNBQVMsRUFDM0JDLFFBQVFOLE1BQU1NLEtBQUssRUFDbkJDLFFBQVFQLE1BQU1PLEtBQUssRUFDbkJDLE9BQU9SLE1BQU1RLElBQUksRUFDakJDLFNBQVNoQix5QkFBeUJPLE9BQU92QjtJQUMzQyxJQUFJaUMsVUFBVU4sV0FBVztRQUN2QkYsT0FBT0E7UUFDUEMsUUFBUUE7UUFDUlEsR0FBRztRQUNIQyxHQUFHO0lBQ0w7SUFDQSxJQUFJQyxhQUFhLENBQUMsR0FBR3RDLEtBQUssQ0FBQyxVQUFVLEVBQUUsb0JBQW9COEI7SUFDM0QsT0FBTyxXQUFXLEdBQUVqQyxNQUFNLENBQUMsVUFBVSxDQUFDMEMsYUFBYSxDQUFDLE9BQU9sQyxTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUdKLFlBQVl1QyxXQUFXLEVBQUVOLFFBQVEsTUFBTSxRQUFRO1FBQ3pISixXQUFXUTtRQUNYWCxPQUFPQTtRQUNQQyxRQUFRQTtRQUNSRyxPQUFPQTtRQUNQRixTQUFTLEdBQUdZLE1BQU0sQ0FBQ04sUUFBUUMsQ0FBQyxFQUFFLEtBQUtLLE1BQU0sQ0FBQ04sUUFBUUUsQ0FBQyxFQUFFLEtBQUtJLE1BQU0sQ0FBQ04sUUFBUVIsS0FBSyxFQUFFLEtBQUtjLE1BQU0sQ0FBQ04sUUFBUVAsTUFBTTtJQUM1RyxJQUFJLFdBQVcsR0FBRS9CLE1BQU0sQ0FBQyxVQUFVLENBQUMwQyxhQUFhLENBQUMsU0FBUyxNQUFNUCxRQUFRLFdBQVcsR0FBRW5DLE1BQU0sQ0FBQyxVQUFVLENBQUMwQyxhQUFhLENBQUMsUUFBUSxNQUFNTixPQUFPUDtBQUM1SSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcY29udGFpbmVyXFxTdXJmYWNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuU3VyZmFjZSA9IFN1cmZhY2U7XHJcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xyXG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xyXG52YXIgX2V4Y2x1ZGVkID0gW1wiY2hpbGRyZW5cIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcInZpZXdCb3hcIiwgXCJjbGFzc05hbWVcIiwgXCJzdHlsZVwiLCBcInRpdGxlXCIsIFwiZGVzY1wiXTtcclxuLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgU3VyZmFjZVxyXG4gKi9cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XHJcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XHJcbmZ1bmN0aW9uIFN1cmZhY2UocHJvcHMpIHtcclxuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcclxuICAgIHdpZHRoID0gcHJvcHMud2lkdGgsXHJcbiAgICBoZWlnaHQgPSBwcm9wcy5oZWlnaHQsXHJcbiAgICB2aWV3Qm94ID0gcHJvcHMudmlld0JveCxcclxuICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcclxuICAgIHN0eWxlID0gcHJvcHMuc3R5bGUsXHJcbiAgICB0aXRsZSA9IHByb3BzLnRpdGxlLFxyXG4gICAgZGVzYyA9IHByb3BzLmRlc2MsXHJcbiAgICBvdGhlcnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZCk7XHJcbiAgdmFyIHN2Z1ZpZXcgPSB2aWV3Qm94IHx8IHtcclxuICAgIHdpZHRoOiB3aWR0aCxcclxuICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgeDogMCxcclxuICAgIHk6IDBcclxuICB9O1xyXG4gIHZhciBsYXllckNsYXNzID0gKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXN1cmZhY2UnLCBjbGFzc05hbWUpO1xyXG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIF9leHRlbmRzKHt9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKG90aGVycywgdHJ1ZSwgJ3N2ZycpLCB7XHJcbiAgICBjbGFzc05hbWU6IGxheWVyQ2xhc3MsXHJcbiAgICB3aWR0aDogd2lkdGgsXHJcbiAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgIHN0eWxlOiBzdHlsZSxcclxuICAgIHZpZXdCb3g6IFwiXCIuY29uY2F0KHN2Z1ZpZXcueCwgXCIgXCIpLmNvbmNhdChzdmdWaWV3LnksIFwiIFwiKS5jb25jYXQoc3ZnVmlldy53aWR0aCwgXCIgXCIpLmNvbmNhdChzdmdWaWV3LmhlaWdodClcclxuICB9KSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInRpdGxlXCIsIG51bGwsIHRpdGxlKSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRlc2NcIiwgbnVsbCwgZGVzYyksIGNoaWxkcmVuKTtcclxufSJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlN1cmZhY2UiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9jbHN4IiwiX1JlYWN0VXRpbHMiLCJfZXhjbHVkZWQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNvdXJjZVN5bWJvbEtleXMiLCJpbmRleE9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJwcm9wcyIsImNoaWxkcmVuIiwid2lkdGgiLCJoZWlnaHQiLCJ2aWV3Qm94IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJ0aXRsZSIsImRlc2MiLCJvdGhlcnMiLCJzdmdWaWV3IiwieCIsInkiLCJsYXllckNsYXNzIiwiY3JlYXRlRWxlbWVudCIsImZpbHRlclByb3BzIiwiY29uY2F0Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/container/Surface.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/context/chartLayoutContext.js":
/*!*****************************************************************!*\
  !*** ./node_modules/recharts/lib/context/chartLayoutContext.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useYAxisWithFiniteDomainOrRandom = exports.useYAxisOrThrow = exports.useXAxisOrThrow = exports.useViewBox = exports.useOffset = exports.useClipPathId = exports.useChartWidth = exports.useChartHeight = exports.useArbitraryYAxis = exports.useArbitraryXAxis = exports.YAxisContext = exports.XAxisContext = exports.ViewBoxContext = exports.OffsetContext = exports.ClipPathIdContext = exports.ChartWidthContext = exports.ChartLayoutContextProvider = exports.ChartHeightContext = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _tinyInvariant = _interopRequireDefault(__webpack_require__(/*! tiny-invariant */ \"tiny-invariant\"));\nvar _find = _interopRequireDefault(__webpack_require__(/*! lodash/find */ \"lodash/find\"));\nvar _every = _interopRequireDefault(__webpack_require__(/*! lodash/every */ \"lodash/every\"));\nvar _calculateViewBox = __webpack_require__(/*! ../util/calculateViewBox */ \"(pages-dir-node)/./node_modules/recharts/lib/util/calculateViewBox.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nvar XAxisContext = exports.XAxisContext = /*#__PURE__*/ (0, _react.createContext)(undefined);\nvar YAxisContext = exports.YAxisContext = /*#__PURE__*/ (0, _react.createContext)(undefined);\nvar ViewBoxContext = exports.ViewBoxContext = /*#__PURE__*/ (0, _react.createContext)(undefined);\nvar OffsetContext = exports.OffsetContext = /*#__PURE__*/ (0, _react.createContext)({});\nvar ClipPathIdContext = exports.ClipPathIdContext = /*#__PURE__*/ (0, _react.createContext)(undefined);\nvar ChartHeightContext = exports.ChartHeightContext = /*#__PURE__*/ (0, _react.createContext)(0);\nvar ChartWidthContext = exports.ChartWidthContext = /*#__PURE__*/ (0, _react.createContext)(0);\n/**\r\n * Will add all the properties required to render all individual Recharts components into a React Context.\r\n *\r\n * If you want to read these properties, see the collection of hooks exported from this file.\r\n *\r\n * @param {object} props CategoricalChartState, plus children\r\n * @returns {ReactElement} React Context Provider\r\n */ var ChartLayoutContextProvider = exports.ChartLayoutContextProvider = function ChartLayoutContextProvider(props) {\n    var _props$state = props.state, xAxisMap = _props$state.xAxisMap, yAxisMap = _props$state.yAxisMap, offset = _props$state.offset, clipPathId = props.clipPathId, children = props.children, width = props.width, height = props.height;\n    /**\r\n   * Perhaps we should compute this property when reading? Let's see what is more often used\r\n   */ var viewBox = (0, _calculateViewBox.calculateViewBox)(offset);\n    /*\r\n   * This pretends to be a single context but actually is split into multiple smaller ones.\r\n   * Why?\r\n   * Because one React Context only allows to set one value.\r\n   * But we need to set multiple values.\r\n   * If we do that with one context, then we force re-render on components that might not even be interested\r\n   * in the part of the state that has changed.\r\n   *\r\n   * By splitting into smaller contexts, we allow each components to be optimized and only re-render when its dependencies change.\r\n   *\r\n   * To actually achieve the optimal re-render, it is necessary to use React.memo().\r\n   * See the test file for details.\r\n   */ return /*#__PURE__*/ _react[\"default\"].createElement(XAxisContext.Provider, {\n        value: xAxisMap\n    }, /*#__PURE__*/ _react[\"default\"].createElement(YAxisContext.Provider, {\n        value: yAxisMap\n    }, /*#__PURE__*/ _react[\"default\"].createElement(OffsetContext.Provider, {\n        value: offset\n    }, /*#__PURE__*/ _react[\"default\"].createElement(ViewBoxContext.Provider, {\n        value: viewBox\n    }, /*#__PURE__*/ _react[\"default\"].createElement(ClipPathIdContext.Provider, {\n        value: clipPathId\n    }, /*#__PURE__*/ _react[\"default\"].createElement(ChartHeightContext.Provider, {\n        value: height\n    }, /*#__PURE__*/ _react[\"default\"].createElement(ChartWidthContext.Provider, {\n        value: width\n    }, children)))))));\n};\nvar useClipPathId = exports.useClipPathId = function useClipPathId() {\n    return (0, _react.useContext)(ClipPathIdContext);\n};\nfunction getKeysForDebug(object) {\n    var keys = Object.keys(object);\n    if (keys.length === 0) {\n        return 'There are no available ids.';\n    }\n    return \"Available ids are: \".concat(keys, \".\");\n}\n/**\r\n * This either finds and returns Axis by the specified ID, or throws an exception if an axis with this ID does not exist.\r\n *\r\n * @param xAxisId identifier of the axis - it's either autogenerated ('0'), or passed via `id` prop as <XAxis id='foo' />\r\n * @returns axis configuration object\r\n * @throws Error if no axis with this ID exists\r\n */ var useXAxisOrThrow = exports.useXAxisOrThrow = function useXAxisOrThrow(xAxisId) {\n    var xAxisMap = (0, _react.useContext)(XAxisContext);\n    !(xAxisMap != null) ?  true ? (0, _tinyInvariant[\"default\"])(false, 'Could not find Recharts context; are you sure this is rendered inside a Recharts wrapper component?') : 0 : void 0;\n    var xAxis = xAxisMap[xAxisId];\n    !(xAxis != null) ?  true ? (0, _tinyInvariant[\"default\"])(false, \"Could not find xAxis by id \\\"\".concat(xAxisId, \"\\\" [\").concat(_typeof(xAxisId), \"]. \").concat(getKeysForDebug(xAxisMap))) : 0 : void 0;\n    return xAxis;\n};\n/**\r\n * This will find an arbitrary first XAxis. If there's exactly one it always returns that one\r\n * - but if there are multiple then it can return any of those.\r\n *\r\n * If you want specific XAxis out of multiple then prefer using useXAxisOrThrow\r\n *\r\n * @returns X axisOptions, or undefined - if there are no X axes\r\n */ var useArbitraryXAxis = exports.useArbitraryXAxis = function useArbitraryXAxis() {\n    var xAxisMap = (0, _react.useContext)(XAxisContext);\n    return (0, _DataUtils.getAnyElementOfObject)(xAxisMap);\n};\n/**\r\n * This will find an arbitrary first YAxis. If there's exactly one it always returns that one\r\n * - but if there are multiple then it can return any of those.\r\n *\r\n * If you want specific YAxis out of multiple then prefer using useXAxisOrThrow\r\n *\r\n * @returns Y axisOptions, or undefined - if there are no Y axes\r\n */ var useArbitraryYAxis = exports.useArbitraryYAxis = function useArbitraryYAxis() {\n    var yAxisMap = (0, _react.useContext)(YAxisContext);\n    return (0, _DataUtils.getAnyElementOfObject)(yAxisMap);\n};\n/**\r\n * This hooks will:\r\n * 1st attempt to find an YAxis that has all elements in its domain finite\r\n * If no such axis exists, it will return an arbitrary YAxis\r\n * if there are no Y axes then it returns undefined\r\n *\r\n * @returns Either Y axisOptions, or undefined if there are no Y axes\r\n */ var useYAxisWithFiniteDomainOrRandom = exports.useYAxisWithFiniteDomainOrRandom = function useYAxisWithFiniteDomainOrRandom() {\n    var yAxisMap = (0, _react.useContext)(YAxisContext);\n    var yAxisWithFiniteDomain = (0, _find[\"default\"])(yAxisMap, function(axis) {\n        return (0, _every[\"default\"])(axis.domain, Number.isFinite);\n    });\n    return yAxisWithFiniteDomain || (0, _DataUtils.getAnyElementOfObject)(yAxisMap);\n};\n/**\r\n * This either finds and returns Axis by the specified ID, or throws an exception if an axis with this ID does not exist.\r\n *\r\n * @param yAxisId identifier of the axis - it's either autogenerated ('0'), or passed via `id` prop as <YAxis id='foo' />\r\n * @returns axis configuration object\r\n * @throws Error if no axis with this ID exists\r\n */ var useYAxisOrThrow = exports.useYAxisOrThrow = function useYAxisOrThrow(yAxisId) {\n    var yAxisMap = (0, _react.useContext)(YAxisContext);\n    !(yAxisMap != null) ?  true ? (0, _tinyInvariant[\"default\"])(false, 'Could not find Recharts context; are you sure this is rendered inside a Recharts wrapper component?') : 0 : void 0;\n    var yAxis = yAxisMap[yAxisId];\n    !(yAxis != null) ?  true ? (0, _tinyInvariant[\"default\"])(false, \"Could not find yAxis by id \\\"\".concat(yAxisId, \"\\\" [\").concat(_typeof(yAxisId), \"]. \").concat(getKeysForDebug(yAxisMap))) : 0 : void 0;\n    return yAxis;\n};\nvar useViewBox = exports.useViewBox = function useViewBox() {\n    var viewBox = (0, _react.useContext)(ViewBoxContext);\n    return viewBox;\n};\nvar useOffset = exports.useOffset = function useOffset() {\n    return (0, _react.useContext)(OffsetContext);\n};\nvar useChartWidth = exports.useChartWidth = function useChartWidth() {\n    return (0, _react.useContext)(ChartWidthContext);\n};\nvar useChartHeight = exports.useChartHeight = function useChartHeight() {\n    return (0, _react.useContext)(ChartHeightContext);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY29udGV4dC9jaGFydExheW91dENvbnRleHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELHdDQUF3QyxHQUFHQSx1QkFBdUIsR0FBR0EsdUJBQXVCLEdBQUdBLGtCQUFrQixHQUFHQSxpQkFBaUIsR0FBR0EscUJBQXFCLEdBQUdBLHFCQUFxQixHQUFHQSxzQkFBc0IsR0FBR0EseUJBQXlCLEdBQUdBLHlCQUF5QixHQUFHQSxvQkFBb0IsR0FBR0Esb0JBQW9CLEdBQUdBLHNCQUFzQixHQUFHQSxxQkFBcUIsR0FBR0EseUJBQXlCLEdBQUdBLHlCQUF5QixHQUFHQSxrQ0FBa0MsR0FBR0EsMEJBQTBCLEdBQUcsS0FBSztBQUN2ZSxJQUFJb0IsU0FBU0Msd0JBQXdCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNwRCxJQUFJQyxpQkFBaUJDLHVCQUF1QkYsbUJBQU9BLENBQUMsc0NBQWdCO0FBQ3BFLElBQUlHLFFBQVFELHVCQUF1QkYsbUJBQU9BLENBQUMsZ0NBQWE7QUFDeEQsSUFBSUksU0FBU0YsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJSyxvQkFBb0JMLG1CQUFPQSxDQUFDLHVHQUEwQjtBQUMxRCxJQUFJTSxhQUFhTixtQkFBT0EsQ0FBQyx5RkFBbUI7QUFDNUMsU0FBU0UsdUJBQXVCSyxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFLHlCQUF5QkMsQ0FBQztJQUFJLElBQUksY0FBYyxPQUFPQyxTQUFTLE9BQU87SUFBTSxJQUFJQyxJQUFJLElBQUlELFdBQVdFLElBQUksSUFBSUY7SUFBVyxPQUFPLENBQUNGLDJCQUEyQixTQUFTQSx5QkFBeUJDLENBQUM7UUFBSSxPQUFPQSxJQUFJRyxJQUFJRDtJ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QU8sQ0FBQyxHQUFHVyxPQUFPZ0QsVUFBVSxFQUFFakQ7QUFDaEMiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXGNvbnRleHRcXGNoYXJ0TGF5b3V0Q29udGV4dC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLnVzZVlBeGlzV2l0aEZpbml0ZURvbWFpbk9yUmFuZG9tID0gZXhwb3J0cy51c2VZQXhpc09yVGhyb3cgPSBleHBvcnRzLnVzZVhBeGlzT3JUaHJvdyA9IGV4cG9ydHMudXNlVmlld0JveCA9IGV4cG9ydHMudXNlT2Zmc2V0ID0gZXhwb3J0cy51c2VDbGlwUGF0aElkID0gZXhwb3J0cy51c2VDaGFydFdpZHRoID0gZXhwb3J0cy51c2VDaGFydEhlaWdodCA9IGV4cG9ydHMudXNlQXJiaXRyYXJ5WUF4aXMgPSBleHBvcnRzLnVzZUFyYml0cmFyeVhBeGlzID0gZXhwb3J0cy5ZQXhpc0NvbnRleHQgPSBleHBvcnRzLlhBeGlzQ29udGV4dCA9IGV4cG9ydHMuVmlld0JveENvbnRleHQgPSBleHBvcnRzLk9mZnNldENvbnRleHQgPSBleHBvcnRzLkNsaXBQYXRoSWRDb250ZXh0ID0gZXhwb3J0cy5DaGFydFdpZHRoQ29udGV4dCA9IGV4cG9ydHMuQ2hhcnRMYXlvdXRDb250ZXh0UHJvdmlkZXIgPSBleHBvcnRzLkNoYXJ0SGVpZ2h0Q29udGV4dCA9IHZvaWQgMDtcclxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBfdGlueUludmFyaWFudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInRpbnktaW52YXJpYW50XCIpKTtcclxudmFyIF9maW5kID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2ZpbmRcIikpO1xyXG52YXIgX2V2ZXJ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2V2ZXJ5XCIpKTtcclxudmFyIF9jYWxjdWxhdGVWaWV3Qm94ID0gcmVxdWlyZShcIi4uL3V0aWwvY2FsY3VsYXRlVmlld0JveFwiKTtcclxudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9EYXRhVXRpbHNcIik7XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbnZhciBYQXhpc0NvbnRleHQgPSBleHBvcnRzLlhBeGlzQ29udGV4dCA9IC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNyZWF0ZUNvbnRleHQpKHVuZGVmaW5lZCk7XHJcbnZhciBZQXhpc0NvbnRleHQgPSBleHBvcnRzLllBeGlzQ29udGV4dCA9IC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNyZWF0ZUNvbnRleHQpKHVuZGVmaW5lZCk7XHJcbnZhciBWaWV3Qm94Q29udGV4dCA9IGV4cG9ydHMuVmlld0JveENvbnRleHQgPSAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jcmVhdGVDb250ZXh0KSh1bmRlZmluZWQpO1xyXG52YXIgT2Zmc2V0Q29udGV4dCA9IGV4cG9ydHMuT2Zmc2V0Q29udGV4dCA9IC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNyZWF0ZUNvbnRleHQpKHt9KTtcclxudmFyIENsaXBQYXRoSWRDb250ZXh0ID0gZXhwb3J0cy5DbGlwUGF0aElkQ29udGV4dCA9IC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNyZWF0ZUNvbnRleHQpKHVuZGVmaW5lZCk7XHJcbnZhciBDaGFydEhlaWdodENvbnRleHQgPSBleHBvcnRzLkNoYXJ0SGVpZ2h0Q29udGV4dCA9IC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNyZWF0ZUNvbnRleHQpKDApO1xyXG52YXIgQ2hhcnRXaWR0aENvbnRleHQgPSBleHBvcnRzLkNoYXJ0V2lkdGhDb250ZXh0ID0gLyojX19QVVJFX18qLygwLCBfcmVhY3QuY3JlYXRlQ29udGV4dCkoMCk7XHJcblxyXG4vKipcclxuICogV2lsbCBhZGQgYWxsIHRoZSBwcm9wZXJ0aWVzIHJlcXVpcmVkIHRvIHJlbmRlciBhbGwgaW5kaXZpZHVhbCBSZWNoYXJ0cyBjb21wb25lbnRzIGludG8gYSBSZWFjdCBDb250ZXh0LlxyXG4gKlxyXG4gKiBJZiB5b3Ugd2FudCB0byByZWFkIHRoZXNlIHByb3BlcnRpZXMsIHNlZSB0aGUgY29sbGVjdGlvbiBvZiBob29rcyBleHBvcnRlZCBmcm9tIHRoaXMgZmlsZS5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIENhdGVnb3JpY2FsQ2hhcnRTdGF0ZSwgcGx1cyBjaGlsZHJlblxyXG4gKiBAcmV0dXJucyB7UmVhY3RFbGVtZW50fSBSZWFjdCBDb250ZXh0IFByb3ZpZGVyXHJcbiAqL1xyXG52YXIgQ2hhcnRMYXlvdXRDb250ZXh0UHJvdmlkZXIgPSBleHBvcnRzLkNoYXJ0TGF5b3V0Q29udGV4dFByb3ZpZGVyID0gZnVuY3Rpb24gQ2hhcnRMYXlvdXRDb250ZXh0UHJvdmlkZXIocHJvcHMpIHtcclxuICB2YXIgX3Byb3BzJHN0YXRlID0gcHJvcHMuc3RhdGUsXHJcbiAgICB4QXhpc01hcCA9IF9wcm9wcyRzdGF0ZS54QXhpc01hcCxcclxuICAgIHlBeGlzTWFwID0gX3Byb3BzJHN0YXRlLnlBeGlzTWFwLFxyXG4gICAgb2Zmc2V0ID0gX3Byb3BzJHN0YXRlLm9mZnNldCxcclxuICAgIGNsaXBQYXRoSWQgPSBwcm9wcy5jbGlwUGF0aElkLFxyXG4gICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcclxuICAgIHdpZHRoID0gcHJvcHMud2lkdGgsXHJcbiAgICBoZWlnaHQgPSBwcm9wcy5oZWlnaHQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIFBlcmhhcHMgd2Ugc2hvdWxkIGNvbXB1dGUgdGhpcyBwcm9wZXJ0eSB3aGVuIHJlYWRpbmc/IExldCdzIHNlZSB3aGF0IGlzIG1vcmUgb2Z0ZW4gdXNlZFxyXG4gICAqL1xyXG4gIHZhciB2aWV3Qm94ID0gKDAsIF9jYWxjdWxhdGVWaWV3Qm94LmNhbGN1bGF0ZVZpZXdCb3gpKG9mZnNldCk7XHJcblxyXG4gIC8qXHJcbiAgICogVGhpcyBwcmV0ZW5kcyB0byBiZSBhIHNpbmdsZSBjb250ZXh0IGJ1dCBhY3R1YWxseSBpcyBzcGxpdCBpbnRvIG11bHRpcGxlIHNtYWxsZXIgb25lcy5cclxuICAgKiBXaHk/XHJcbiAgICogQmVjYXVzZSBvbmUgUmVhY3QgQ29udGV4dCBvbmx5IGFsbG93cyB0byBzZXQgb25lIHZhbHVlLlxyXG4gICAqIEJ1dCB3ZSBuZWVkIHRvIHNldCBtdWx0aXBsZSB2YWx1ZXMuXHJcbiAgICogSWYgd2UgZG8gdGhhdCB3aXRoIG9uZSBjb250ZXh0LCB0aGVuIHdlIGZvcmNlIHJlLXJlbmRlciBvbiBjb21wb25lbnRzIHRoYXQgbWlnaHQgbm90IGV2ZW4gYmUgaW50ZXJlc3RlZFxyXG4gICAqIGluIHRoZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0aGF0IGhhcyBjaGFuZ2VkLlxyXG4gICAqXHJcbiAgICogQnkgc3BsaXR0aW5nIGludG8gc21hbGxlciBjb250ZXh0cywgd2UgYWxsb3cgZWFjaCBjb21wb25lbnRzIHRvIGJlIG9wdGltaXplZCBhbmQgb25seSByZS1yZW5kZXIgd2hlbiBpdHMgZGVwZW5kZW5jaWVzIGNoYW5nZS5cclxuICAgKlxyXG4gICAqIFRvIGFjdHVhbGx5IGFjaGlldmUgdGhlIG9wdGltYWwgcmUtcmVuZGVyLCBpdCBpcyBuZWNlc3NhcnkgdG8gdXNlIFJlYWN0Lm1lbW8oKS5cclxuICAgKiBTZWUgdGhlIHRlc3QgZmlsZSBmb3IgZGV0YWlscy5cclxuICAgKi9cclxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChYQXhpc0NvbnRleHQuUHJvdmlkZXIsIHtcclxuICAgIHZhbHVlOiB4QXhpc01hcFxyXG4gIH0sIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoWUF4aXNDb250ZXh0LlByb3ZpZGVyLCB7XHJcbiAgICB2YWx1ZTogeUF4aXNNYXBcclxuICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KE9mZnNldENvbnRleHQuUHJvdmlkZXIsIHtcclxuICAgIHZhbHVlOiBvZmZzZXRcclxuICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFZpZXdCb3hDb250ZXh0LlByb3ZpZGVyLCB7XHJcbiAgICB2YWx1ZTogdmlld0JveFxyXG4gIH0sIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoQ2xpcFBhdGhJZENvbnRleHQuUHJvdmlkZXIsIHtcclxuICAgIHZhbHVlOiBjbGlwUGF0aElkXHJcbiAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChDaGFydEhlaWdodENvbnRleHQuUHJvdmlkZXIsIHtcclxuICAgIHZhbHVlOiBoZWlnaHRcclxuICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KENoYXJ0V2lkdGhDb250ZXh0LlByb3ZpZGVyLCB7XHJcbiAgICB2YWx1ZTogd2lkdGhcclxuICB9LCBjaGlsZHJlbikpKSkpKSk7XHJcbn07XHJcbnZhciB1c2VDbGlwUGF0aElkID0gZXhwb3J0cy51c2VDbGlwUGF0aElkID0gZnVuY3Rpb24gdXNlQ2xpcFBhdGhJZCgpIHtcclxuICByZXR1cm4gKDAsIF9yZWFjdC51c2VDb250ZXh0KShDbGlwUGF0aElkQ29udGV4dCk7XHJcbn07XHJcbmZ1bmN0aW9uIGdldEtleXNGb3JEZWJ1ZyhvYmplY3QpIHtcclxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XHJcbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gJ1RoZXJlIGFyZSBubyBhdmFpbGFibGUgaWRzLic7XHJcbiAgfVxyXG4gIHJldHVybiBcIkF2YWlsYWJsZSBpZHMgYXJlOiBcIi5jb25jYXQoa2V5cywgXCIuXCIpO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBlaXRoZXIgZmluZHMgYW5kIHJldHVybnMgQXhpcyBieSB0aGUgc3BlY2lmaWVkIElELCBvciB0aHJvd3MgYW4gZXhjZXB0aW9uIGlmIGFuIGF4aXMgd2l0aCB0aGlzIElEIGRvZXMgbm90IGV4aXN0LlxyXG4gKlxyXG4gKiBAcGFyYW0geEF4aXNJZCBpZGVudGlmaWVyIG9mIHRoZSBheGlzIC0gaXQncyBlaXRoZXIgYXV0b2dlbmVyYXRlZCAoJzAnKSwgb3IgcGFzc2VkIHZpYSBgaWRgIHByb3AgYXMgPFhBeGlzIGlkPSdmb28nIC8+XHJcbiAqIEByZXR1cm5zIGF4aXMgY29uZmlndXJhdGlvbiBvYmplY3RcclxuICogQHRocm93cyBFcnJvciBpZiBubyBheGlzIHdpdGggdGhpcyBJRCBleGlzdHNcclxuICovXHJcbnZhciB1c2VYQXhpc09yVGhyb3cgPSBleHBvcnRzLnVzZVhBeGlzT3JUaHJvdyA9IGZ1bmN0aW9uIHVzZVhBeGlzT3JUaHJvdyh4QXhpc0lkKSB7XHJcbiAgdmFyIHhBeGlzTWFwID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShYQXhpc0NvbnRleHQpO1xyXG4gICEoeEF4aXNNYXAgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyAoMCwgX3RpbnlJbnZhcmlhbnRbXCJkZWZhdWx0XCJdKShmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIFJlY2hhcnRzIGNvbnRleHQ7IGFyZSB5b3Ugc3VyZSB0aGlzIGlzIHJlbmRlcmVkIGluc2lkZSBhIFJlY2hhcnRzIHdyYXBwZXIgY29tcG9uZW50PycpIDogKDAsIF90aW55SW52YXJpYW50W1wiZGVmYXVsdFwiXSkoZmFsc2UpIDogdm9pZCAwO1xyXG4gIHZhciB4QXhpcyA9IHhBeGlzTWFwW3hBeGlzSWRdO1xyXG4gICEoeEF4aXMgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyAoMCwgX3RpbnlJbnZhcmlhbnRbXCJkZWZhdWx0XCJdKShmYWxzZSwgXCJDb3VsZCBub3QgZmluZCB4QXhpcyBieSBpZCBcXFwiXCIuY29uY2F0KHhBeGlzSWQsIFwiXFxcIiBbXCIpLmNvbmNhdChfdHlwZW9mKHhBeGlzSWQpLCBcIl0uIFwiKS5jb25jYXQoZ2V0S2V5c0ZvckRlYnVnKHhBeGlzTWFwKSkpIDogKDAsIF90aW55SW52YXJpYW50W1wiZGVmYXVsdFwiXSkoZmFsc2UpIDogdm9pZCAwO1xyXG4gIHJldHVybiB4QXhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIHdpbGwgZmluZCBhbiBhcmJpdHJhcnkgZmlyc3QgWEF4aXMuIElmIHRoZXJlJ3MgZXhhY3RseSBvbmUgaXQgYWx3YXlzIHJldHVybnMgdGhhdCBvbmVcclxuICogLSBidXQgaWYgdGhlcmUgYXJlIG11bHRpcGxlIHRoZW4gaXQgY2FuIHJldHVybiBhbnkgb2YgdGhvc2UuXHJcbiAqXHJcbiAqIElmIHlvdSB3YW50IHNwZWNpZmljIFhBeGlzIG91dCBvZiBtdWx0aXBsZSB0aGVuIHByZWZlciB1c2luZyB1c2VYQXhpc09yVGhyb3dcclxuICpcclxuICogQHJldHVybnMgWCBheGlzT3B0aW9ucywgb3IgdW5kZWZpbmVkIC0gaWYgdGhlcmUgYXJlIG5vIFggYXhlc1xyXG4gKi9cclxudmFyIHVzZUFyYml0cmFyeVhBeGlzID0gZXhwb3J0cy51c2VBcmJpdHJhcnlYQXhpcyA9IGZ1bmN0aW9uIHVzZUFyYml0cmFyeVhBeGlzKCkge1xyXG4gIHZhciB4QXhpc01hcCA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoWEF4aXNDb250ZXh0KTtcclxuICByZXR1cm4gKDAsIF9EYXRhVXRpbHMuZ2V0QW55RWxlbWVudE9mT2JqZWN0KSh4QXhpc01hcCk7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyB3aWxsIGZpbmQgYW4gYXJiaXRyYXJ5IGZpcnN0IFlBeGlzLiBJZiB0aGVyZSdzIGV4YWN0bHkgb25lIGl0IGFsd2F5cyByZXR1cm5zIHRoYXQgb25lXHJcbiAqIC0gYnV0IGlmIHRoZXJlIGFyZSBtdWx0aXBsZSB0aGVuIGl0IGNhbiByZXR1cm4gYW55IG9mIHRob3NlLlxyXG4gKlxyXG4gKiBJZiB5b3Ugd2FudCBzcGVjaWZpYyBZQXhpcyBvdXQgb2YgbXVsdGlwbGUgdGhlbiBwcmVmZXIgdXNpbmcgdXNlWEF4aXNPclRocm93XHJcbiAqXHJcbiAqIEByZXR1cm5zIFkgYXhpc09wdGlvbnMsIG9yIHVuZGVmaW5lZCAtIGlmIHRoZXJlIGFyZSBubyBZIGF4ZXNcclxuICovXHJcbnZhciB1c2VBcmJpdHJhcnlZQXhpcyA9IGV4cG9ydHMudXNlQXJiaXRyYXJ5WUF4aXMgPSBmdW5jdGlvbiB1c2VBcmJpdHJhcnlZQXhpcygpIHtcclxuICB2YXIgeUF4aXNNYXAgPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKFlBeGlzQ29udGV4dCk7XHJcbiAgcmV0dXJuICgwLCBfRGF0YVV0aWxzLmdldEFueUVsZW1lbnRPZk9iamVjdCkoeUF4aXNNYXApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaG9va3Mgd2lsbDpcclxuICogMXN0IGF0dGVtcHQgdG8gZmluZCBhbiBZQXhpcyB0aGF0IGhhcyBhbGwgZWxlbWVudHMgaW4gaXRzIGRvbWFpbiBmaW5pdGVcclxuICogSWYgbm8gc3VjaCBheGlzIGV4aXN0cywgaXQgd2lsbCByZXR1cm4gYW4gYXJiaXRyYXJ5IFlBeGlzXHJcbiAqIGlmIHRoZXJlIGFyZSBubyBZIGF4ZXMgdGhlbiBpdCByZXR1cm5zIHVuZGVmaW5lZFxyXG4gKlxyXG4gKiBAcmV0dXJucyBFaXRoZXIgWSBheGlzT3B0aW9ucywgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGFyZSBubyBZIGF4ZXNcclxuICovXHJcbnZhciB1c2VZQXhpc1dpdGhGaW5pdGVEb21haW5PclJhbmRvbSA9IGV4cG9ydHMudXNlWUF4aXNXaXRoRmluaXRlRG9tYWluT3JSYW5kb20gPSBmdW5jdGlvbiB1c2VZQXhpc1dpdGhGaW5pdGVEb21haW5PclJhbmRvbSgpIHtcclxuICB2YXIgeUF4aXNNYXAgPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKFlBeGlzQ29udGV4dCk7XHJcbiAgdmFyIHlBeGlzV2l0aEZpbml0ZURvbWFpbiA9ICgwLCBfZmluZFtcImRlZmF1bHRcIl0pKHlBeGlzTWFwLCBmdW5jdGlvbiAoYXhpcykge1xyXG4gICAgcmV0dXJuICgwLCBfZXZlcnlbXCJkZWZhdWx0XCJdKShheGlzLmRvbWFpbiwgTnVtYmVyLmlzRmluaXRlKTtcclxuICB9KTtcclxuICByZXR1cm4geUF4aXNXaXRoRmluaXRlRG9tYWluIHx8ICgwLCBfRGF0YVV0aWxzLmdldEFueUVsZW1lbnRPZk9iamVjdCkoeUF4aXNNYXApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgZWl0aGVyIGZpbmRzIGFuZCByZXR1cm5zIEF4aXMgYnkgdGhlIHNwZWNpZmllZCBJRCwgb3IgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBhbiBheGlzIHdpdGggdGhpcyBJRCBkb2VzIG5vdCBleGlzdC5cclxuICpcclxuICogQHBhcmFtIHlBeGlzSWQgaWRlbnRpZmllciBvZiB0aGUgYXhpcyAtIGl0J3MgZWl0aGVyIGF1dG9nZW5lcmF0ZWQgKCcwJyksIG9yIHBhc3NlZCB2aWEgYGlkYCBwcm9wIGFzIDxZQXhpcyBpZD0nZm9vJyAvPlxyXG4gKiBAcmV0dXJucyBheGlzIGNvbmZpZ3VyYXRpb24gb2JqZWN0XHJcbiAqIEB0aHJvd3MgRXJyb3IgaWYgbm8gYXhpcyB3aXRoIHRoaXMgSUQgZXhpc3RzXHJcbiAqL1xyXG52YXIgdXNlWUF4aXNPclRocm93ID0gZXhwb3J0cy51c2VZQXhpc09yVGhyb3cgPSBmdW5jdGlvbiB1c2VZQXhpc09yVGhyb3coeUF4aXNJZCkge1xyXG4gIHZhciB5QXhpc01hcCA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoWUF4aXNDb250ZXh0KTtcclxuICAhKHlBeGlzTWFwICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gKDAsIF90aW55SW52YXJpYW50W1wiZGVmYXVsdFwiXSkoZmFsc2UsICdDb3VsZCBub3QgZmluZCBSZWNoYXJ0cyBjb250ZXh0OyBhcmUgeW91IHN1cmUgdGhpcyBpcyByZW5kZXJlZCBpbnNpZGUgYSBSZWNoYXJ0cyB3cmFwcGVyIGNvbXBvbmVudD8nKSA6ICgwLCBfdGlueUludmFyaWFudFtcImRlZmF1bHRcIl0pKGZhbHNlKSA6IHZvaWQgMDtcclxuICB2YXIgeUF4aXMgPSB5QXhpc01hcFt5QXhpc0lkXTtcclxuICAhKHlBeGlzICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gKDAsIF90aW55SW52YXJpYW50W1wiZGVmYXVsdFwiXSkoZmFsc2UsIFwiQ291bGQgbm90IGZpbmQgeUF4aXMgYnkgaWQgXFxcIlwiLmNvbmNhdCh5QXhpc0lkLCBcIlxcXCIgW1wiKS5jb25jYXQoX3R5cGVvZih5QXhpc0lkKSwgXCJdLiBcIikuY29uY2F0KGdldEtleXNGb3JEZWJ1Zyh5QXhpc01hcCkpKSA6ICgwLCBfdGlueUludmFyaWFudFtcImRlZmF1bHRcIl0pKGZhbHNlKSA6IHZvaWQgMDtcclxuICByZXR1cm4geUF4aXM7XHJcbn07XHJcbnZhciB1c2VWaWV3Qm94ID0gZXhwb3J0cy51c2VWaWV3Qm94ID0gZnVuY3Rpb24gdXNlVmlld0JveCgpIHtcclxuICB2YXIgdmlld0JveCA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoVmlld0JveENvbnRleHQpO1xyXG4gIHJldHVybiB2aWV3Qm94O1xyXG59O1xyXG52YXIgdXNlT2Zmc2V0ID0gZXhwb3J0cy51c2VPZmZzZXQgPSBmdW5jdGlvbiB1c2VPZmZzZXQoKSB7XHJcbiAgcmV0dXJuICgwLCBfcmVhY3QudXNlQ29udGV4dCkoT2Zmc2V0Q29udGV4dCk7XHJcbn07XHJcbnZhciB1c2VDaGFydFdpZHRoID0gZXhwb3J0cy51c2VDaGFydFdpZHRoID0gZnVuY3Rpb24gdXNlQ2hhcnRXaWR0aCgpIHtcclxuICByZXR1cm4gKDAsIF9yZWFjdC51c2VDb250ZXh0KShDaGFydFdpZHRoQ29udGV4dCk7XHJcbn07XHJcbnZhciB1c2VDaGFydEhlaWdodCA9IGV4cG9ydHMudXNlQ2hhcnRIZWlnaHQgPSBmdW5jdGlvbiB1c2VDaGFydEhlaWdodCgpIHtcclxuICByZXR1cm4gKDAsIF9yZWFjdC51c2VDb250ZXh0KShDaGFydEhlaWdodENvbnRleHQpO1xyXG59OyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInVzZVlBeGlzV2l0aEZpbml0ZURvbWFpbk9yUmFuZG9tIiwidXNlWUF4aXNPclRocm93IiwidXNlWEF4aXNPclRocm93IiwidXNlVmlld0JveCIsInVzZU9mZnNldCIsInVzZUNsaXBQYXRoSWQiLCJ1c2VDaGFydFdpZHRoIiwidXNlQ2hhcnRIZWlnaHQiLCJ1c2VBcmJpdHJhcnlZQXhpcyIsInVzZUFyYml0cmFyeVhBeGlzIiwiWUF4aXNDb250ZXh0IiwiWEF4aXNDb250ZXh0IiwiVmlld0JveENvbnRleHQiLCJPZmZzZXRDb250ZXh0IiwiQ2xpcFBhdGhJZENvbnRleHQiLCJDaGFydFdpZHRoQ29udGV4dCIsIkNoYXJ0TGF5b3V0Q29udGV4dFByb3ZpZGVyIiwiQ2hhcnRIZWlnaHRDb250ZXh0IiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX3RpbnlJbnZhcmlhbnQiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2ZpbmQiLCJfZXZlcnkiLCJfY2FsY3VsYXRlVmlld0JveCIsIl9EYXRhVXRpbHMiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwicHJvdG90eXBlIiwiY3JlYXRlQ29udGV4dCIsInVuZGVmaW5lZCIsInByb3BzIiwiX3Byb3BzJHN0YXRlIiwic3RhdGUiLCJ4QXhpc01hcCIsInlBeGlzTWFwIiwib2Zmc2V0IiwiY2xpcFBhdGhJZCIsImNoaWxkcmVuIiwid2lkdGgiLCJoZWlnaHQiLCJ2aWV3Qm94IiwiY2FsY3VsYXRlVmlld0JveCIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInVzZUNvbnRleHQiLCJnZXRLZXlzRm9yRGVidWciLCJvYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiY29uY2F0IiwieEF4aXNJZCIsInByb2Nlc3MiLCJ4QXhpcyIsImdldEFueUVsZW1lbnRPZk9iamVjdCIsInlBeGlzV2l0aEZpbml0ZURvbWFpbiIsImF4aXMiLCJkb21haW4iLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInlBeGlzSWQiLCJ5QXhpcyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/context/chartLayoutContext.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/recharts/lib/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Area\", ({\n    enumerable: true,\n    get: function get() {\n        return _Area.Area;\n    }\n}));\nObject.defineProperty(exports, \"AreaChart\", ({\n    enumerable: true,\n    get: function get() {\n        return _AreaChart.AreaChart;\n    }\n}));\nObject.defineProperty(exports, \"Bar\", ({\n    enumerable: true,\n    get: function get() {\n        return _Bar.Bar;\n    }\n}));\nObject.defineProperty(exports, \"BarChart\", ({\n    enumerable: true,\n    get: function get() {\n        return _BarChart.BarChart;\n    }\n}));\nObject.defineProperty(exports, \"Brush\", ({\n    enumerable: true,\n    get: function get() {\n        return _Brush.Brush;\n    }\n}));\nObject.defineProperty(exports, \"CartesianAxis\", ({\n    enumerable: true,\n    get: function get() {\n        return _CartesianAxis.CartesianAxis;\n    }\n}));\nObject.defineProperty(exports, \"CartesianGrid\", ({\n    enumerable: true,\n    get: function get() {\n        return _CartesianGrid.CartesianGrid;\n    }\n}));\nObject.defineProperty(exports, \"Cell\", ({\n    enumerable: true,\n    get: function get() {\n        return _Cell.Cell;\n    }\n}));\nObject.defineProperty(exports, \"ComposedChart\", ({\n    enumerable: true,\n    get: function get() {\n        return _ComposedChart.ComposedChart;\n    }\n}));\nObject.defineProperty(exports, \"Cross\", ({\n    enumerable: true,\n    get: function get() {\n        return _Cross.Cross;\n    }\n}));\nObject.defineProperty(exports, \"Curve\", ({\n    enumerable: true,\n    get: function get() {\n        return _Curve.Curve;\n    }\n}));\nObject.defineProperty(exports, \"Customized\", ({\n    enumerable: true,\n    get: function get() {\n        return _Customized.Customized;\n    }\n}));\nObject.defineProperty(exports, \"DefaultLegendContent\", ({\n    enumerable: true,\n    get: function get() {\n        return _DefaultLegendContent.DefaultLegendContent;\n    }\n}));\nObject.defineProperty(exports, \"DefaultTooltipContent\", ({\n    enumerable: true,\n    get: function get() {\n        return _DefaultTooltipContent.DefaultTooltipContent;\n    }\n}));\nObject.defineProperty(exports, \"Dot\", ({\n    enumerable: true,\n    get: function get() {\n        return _Dot.Dot;\n    }\n}));\nObject.defineProperty(exports, \"ErrorBar\", ({\n    enumerable: true,\n    get: function get() {\n        return _ErrorBar.ErrorBar;\n    }\n}));\nObject.defineProperty(exports, \"Funnel\", ({\n    enumerable: true,\n    get: function get() {\n        return _Funnel.Funnel;\n    }\n}));\nObject.defineProperty(exports, \"FunnelChart\", ({\n    enumerable: true,\n    get: function get() {\n        return _FunnelChart.FunnelChart;\n    }\n}));\nObject.defineProperty(exports, \"Global\", ({\n    enumerable: true,\n    get: function get() {\n        return _Global.Global;\n    }\n}));\nObject.defineProperty(exports, \"Label\", ({\n    enumerable: true,\n    get: function get() {\n        return _Label.Label;\n    }\n}));\nObject.defineProperty(exports, \"LabelList\", ({\n    enumerable: true,\n    get: function get() {\n        return _LabelList.LabelList;\n    }\n}));\nObject.defineProperty(exports, \"Layer\", ({\n    enumerable: true,\n    get: function get() {\n        return _Layer.Layer;\n    }\n}));\nObject.defineProperty(exports, \"Legend\", ({\n    enumerable: true,\n    get: function get() {\n        return _Legend.Legend;\n    }\n}));\nObject.defineProperty(exports, \"Line\", ({\n    enumerable: true,\n    get: function get() {\n        return _Line.Line;\n    }\n}));\nObject.defineProperty(exports, \"LineChart\", ({\n    enumerable: true,\n    get: function get() {\n        return _LineChart.LineChart;\n    }\n}));\nObject.defineProperty(exports, \"Pie\", ({\n    enumerable: true,\n    get: function get() {\n        return _Pie.Pie;\n    }\n}));\nObject.defineProperty(exports, \"PieChart\", ({\n    enumerable: true,\n    get: function get() {\n        return _PieChart.PieChart;\n    }\n}));\nObject.defineProperty(exports, \"PolarAngleAxis\", ({\n    enumerable: true,\n    get: function get() {\n        return _PolarAngleAxis.PolarAngleAxis;\n    }\n}));\nObject.defineProperty(exports, \"PolarGrid\", ({\n    enumerable: true,\n    get: function get() {\n        return _PolarGrid.PolarGrid;\n    }\n}));\nObject.defineProperty(exports, \"PolarRadiusAxis\", ({\n    enumerable: true,\n    get: function get() {\n        return _PolarRadiusAxis.PolarRadiusAxis;\n    }\n}));\nObject.defineProperty(exports, \"Polygon\", ({\n    enumerable: true,\n    get: function get() {\n        return _Polygon.Polygon;\n    }\n}));\nObject.defineProperty(exports, \"Radar\", ({\n    enumerable: true,\n    get: function get() {\n        return _Radar.Radar;\n    }\n}));\nObject.defineProperty(exports, \"RadarChart\", ({\n    enumerable: true,\n    get: function get() {\n        return _RadarChart.RadarChart;\n    }\n}));\nObject.defineProperty(exports, \"RadialBar\", ({\n    enumerable: true,\n    get: function get() {\n        return _RadialBar.RadialBar;\n    }\n}));\nObject.defineProperty(exports, \"RadialBarChart\", ({\n    enumerable: true,\n    get: function get() {\n        return _RadialBarChart.RadialBarChart;\n    }\n}));\nObject.defineProperty(exports, \"Rectangle\", ({\n    enumerable: true,\n    get: function get() {\n        return _Rectangle.Rectangle;\n    }\n}));\nObject.defineProperty(exports, \"ReferenceArea\", ({\n    enumerable: true,\n    get: function get() {\n        return _ReferenceArea.ReferenceArea;\n    }\n}));\nObject.defineProperty(exports, \"ReferenceDot\", ({\n    enumerable: true,\n    get: function get() {\n        return _ReferenceDot.ReferenceDot;\n    }\n}));\nObject.defineProperty(exports, \"ReferenceLine\", ({\n    enumerable: true,\n    get: function get() {\n        return _ReferenceLine.ReferenceLine;\n    }\n}));\nObject.defineProperty(exports, \"ResponsiveContainer\", ({\n    enumerable: true,\n    get: function get() {\n        return _ResponsiveContainer.ResponsiveContainer;\n    }\n}));\nObject.defineProperty(exports, \"Sankey\", ({\n    enumerable: true,\n    get: function get() {\n        return _Sankey.Sankey;\n    }\n}));\nObject.defineProperty(exports, \"Scatter\", ({\n    enumerable: true,\n    get: function get() {\n        return _Scatter.Scatter;\n    }\n}));\nObject.defineProperty(exports, \"ScatterChart\", ({\n    enumerable: true,\n    get: function get() {\n        return _ScatterChart.ScatterChart;\n    }\n}));\nObject.defineProperty(exports, \"Sector\", ({\n    enumerable: true,\n    get: function get() {\n        return _Sector.Sector;\n    }\n}));\nObject.defineProperty(exports, \"SunburstChart\", ({\n    enumerable: true,\n    get: function get() {\n        return _SunburstChart.SunburstChart;\n    }\n}));\nObject.defineProperty(exports, \"Surface\", ({\n    enumerable: true,\n    get: function get() {\n        return _Surface.Surface;\n    }\n}));\nObject.defineProperty(exports, \"Symbols\", ({\n    enumerable: true,\n    get: function get() {\n        return _Symbols.Symbols;\n    }\n}));\nObject.defineProperty(exports, \"Text\", ({\n    enumerable: true,\n    get: function get() {\n        return _Text.Text;\n    }\n}));\nObject.defineProperty(exports, \"Tooltip\", ({\n    enumerable: true,\n    get: function get() {\n        return _Tooltip.Tooltip;\n    }\n}));\nObject.defineProperty(exports, \"Trapezoid\", ({\n    enumerable: true,\n    get: function get() {\n        return _Trapezoid.Trapezoid;\n    }\n}));\nObject.defineProperty(exports, \"Treemap\", ({\n    enumerable: true,\n    get: function get() {\n        return _Treemap.Treemap;\n    }\n}));\nObject.defineProperty(exports, \"XAxis\", ({\n    enumerable: true,\n    get: function get() {\n        return _XAxis.XAxis;\n    }\n}));\nObject.defineProperty(exports, \"YAxis\", ({\n    enumerable: true,\n    get: function get() {\n        return _YAxis.YAxis;\n    }\n}));\nObject.defineProperty(exports, \"ZAxis\", ({\n    enumerable: true,\n    get: function get() {\n        return _ZAxis.ZAxis;\n    }\n}));\nvar _Surface = __webpack_require__(/*! ./container/Surface */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Surface.js\");\nvar _Layer = __webpack_require__(/*! ./container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _Legend = __webpack_require__(/*! ./component/Legend */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Legend.js\");\nvar _DefaultLegendContent = __webpack_require__(/*! ./component/DefaultLegendContent */ \"(pages-dir-node)/./node_modules/recharts/lib/component/DefaultLegendContent.js\");\nvar _Tooltip = __webpack_require__(/*! ./component/Tooltip */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Tooltip.js\");\nvar _DefaultTooltipContent = __webpack_require__(/*! ./component/DefaultTooltipContent */ \"(pages-dir-node)/./node_modules/recharts/lib/component/DefaultTooltipContent.js\");\nvar _ResponsiveContainer = __webpack_require__(/*! ./component/ResponsiveContainer */ \"(pages-dir-node)/./node_modules/recharts/lib/component/ResponsiveContainer.js\");\nvar _Cell = __webpack_require__(/*! ./component/Cell */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Cell.js\");\nvar _Text = __webpack_require__(/*! ./component/Text */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Text.js\");\nvar _Label = __webpack_require__(/*! ./component/Label */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Label.js\");\nvar _LabelList = __webpack_require__(/*! ./component/LabelList */ \"(pages-dir-node)/./node_modules/recharts/lib/component/LabelList.js\");\nvar _Customized = __webpack_require__(/*! ./component/Customized */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Customized.js\");\nvar _Sector = __webpack_require__(/*! ./shape/Sector */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Sector.js\");\nvar _Curve = __webpack_require__(/*! ./shape/Curve */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Curve.js\");\nvar _Rectangle = __webpack_require__(/*! ./shape/Rectangle */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Rectangle.js\");\nvar _Polygon = __webpack_require__(/*! ./shape/Polygon */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Polygon.js\");\nvar _Dot = __webpack_require__(/*! ./shape/Dot */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Dot.js\");\nvar _Cross = __webpack_require__(/*! ./shape/Cross */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Cross.js\");\nvar _Symbols = __webpack_require__(/*! ./shape/Symbols */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Symbols.js\");\nvar _PolarGrid = __webpack_require__(/*! ./polar/PolarGrid */ \"(pages-dir-node)/./node_modules/recharts/lib/polar/PolarGrid.js\");\nvar _PolarRadiusAxis = __webpack_require__(/*! ./polar/PolarRadiusAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/polar/PolarRadiusAxis.js\");\nvar _PolarAngleAxis = __webpack_require__(/*! ./polar/PolarAngleAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/polar/PolarAngleAxis.js\");\nvar _Pie = __webpack_require__(/*! ./polar/Pie */ \"(pages-dir-node)/./node_modules/recharts/lib/polar/Pie.js\");\nvar _Radar = __webpack_require__(/*! ./polar/Radar */ \"(pages-dir-node)/./node_modules/recharts/lib/polar/Radar.js\");\nvar _RadialBar = __webpack_require__(/*! ./polar/RadialBar */ \"(pages-dir-node)/./node_modules/recharts/lib/polar/RadialBar.js\");\nvar _Brush = __webpack_require__(/*! ./cartesian/Brush */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/Brush.js\");\nvar _ReferenceLine = __webpack_require__(/*! ./cartesian/ReferenceLine */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/ReferenceLine.js\");\nvar _ReferenceDot = __webpack_require__(/*! ./cartesian/ReferenceDot */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/ReferenceDot.js\");\nvar _ReferenceArea = __webpack_require__(/*! ./cartesian/ReferenceArea */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/ReferenceArea.js\");\nvar _CartesianAxis = __webpack_require__(/*! ./cartesian/CartesianAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/CartesianAxis.js\");\nvar _CartesianGrid = __webpack_require__(/*! ./cartesian/CartesianGrid */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/CartesianGrid.js\");\nvar _Line = __webpack_require__(/*! ./cartesian/Line */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/Line.js\");\nvar _Area = __webpack_require__(/*! ./cartesian/Area */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/Area.js\");\nvar _Bar = __webpack_require__(/*! ./cartesian/Bar */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/Bar.js\");\nvar _Scatter = __webpack_require__(/*! ./cartesian/Scatter */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/Scatter.js\");\nvar _XAxis = __webpack_require__(/*! ./cartesian/XAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/XAxis.js\");\nvar _YAxis = __webpack_require__(/*! ./cartesian/YAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/YAxis.js\");\nvar _ZAxis = __webpack_require__(/*! ./cartesian/ZAxis */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/ZAxis.js\");\nvar _ErrorBar = __webpack_require__(/*! ./cartesian/ErrorBar */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/ErrorBar.js\");\nvar _LineChart = __webpack_require__(/*! ./chart/LineChart */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/LineChart.js\");\nvar _BarChart = __webpack_require__(/*! ./chart/BarChart */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/BarChart.js\");\nvar _PieChart = __webpack_require__(/*! ./chart/PieChart */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/PieChart.js\");\nvar _Treemap = __webpack_require__(/*! ./chart/Treemap */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/Treemap.js\");\nvar _Sankey = __webpack_require__(/*! ./chart/Sankey */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/Sankey.js\");\nvar _RadarChart = __webpack_require__(/*! ./chart/RadarChart */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/RadarChart.js\");\nvar _ScatterChart = __webpack_require__(/*! ./chart/ScatterChart */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/ScatterChart.js\");\nvar _AreaChart = __webpack_require__(/*! ./chart/AreaChart */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/AreaChart.js\");\nvar _RadialBarChart = __webpack_require__(/*! ./chart/RadialBarChart */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/RadialBarChart.js\");\nvar _ComposedChart = __webpack_require__(/*! ./chart/ComposedChart */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/ComposedChart.js\");\nvar _SunburstChart = __webpack_require__(/*! ./chart/SunburstChart */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/SunburstChart.js\");\nvar _Funnel = __webpack_require__(/*! ./numberAxis/Funnel */ \"(pages-dir-node)/./node_modules/recharts/lib/numberAxis/Funnel.js\");\nvar _FunnelChart = __webpack_require__(/*! ./chart/FunnelChart */ \"(pages-dir-node)/./node_modules/recharts/lib/chart/FunnelChart.js\");\nvar _Trapezoid = __webpack_require__(/*! ./shape/Trapezoid */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Trapezoid.js\");\nvar _Global = __webpack_require__(/*! ./util/Global */ \"(pages-dir-node)/./node_modules/recharts/lib/util/Global.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZILHdDQUF1QztJQUNyQ0ksWUFBWTtJQUNaQyxLQUFLLFNBQVNBO1FBQ1osT0FBT0MsTUFBTUMsSUFBSTtJQUNuQjtBQUNGLENBQUMsRUFBQztBQUNGUCw2Q0FBNEM7SUFDMUNJLFlBQVk7SUFDWkMsS0FBSyxTQUFTQTtRQUNaLE9BQU9HLFdBQVdDLFNBQVM7SUFDN0I7QUFDRixDQUFDLEVBQUM7QUFDRlQsdUNBQXNDO0lBQ3BDSSxZQUFZO0lBQ1pDLEtBQUssU0FBU0E7UUFDWixPQUFPSyxLQUFLQyxHQUFHO0lBQ2pCO0FBQ0YsQ0FBQyxFQUFDO0FBQ0ZYLDRDQUEyQztJQUN6Q0ksWUFBWTtJQUNaQyxLQUFLLFNBQVNBO1FBQ1osT0FBT08sVUFBVUMsUUFBUTtJQUMzQjtBQUNGLENBQUMsRUFBQztBQUNGYix5Q0FBd0M7SUFDdENJLFlBQVk7SUFDWkMsS0FBSyxTQUFTQTtRQUNaLE9BQU9TLE9BQU9DLEtBQUs7SUFDckI7QUFDRixDQUFDLEVBQUM7QUFDRmYsaURBQWdEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUssU0FBU0E7UUFDWixPQUFPVyxlQUFlQyxhQUFhO0lBQ3JDO0FBQ0YsQ0FBQyxFQUFDO0FBQ0ZqQixpREFBZ0Q7SUFDOUNJLFlBQVk7SUFDWkMsS0FBSyxTQUFTQTtRQUNaLE9BQU9hLGVBQWVDLGFBQWE7SUFDckM7QUFDRixDQUFDLEVBQUM7QUFDRm5CLHdDQUF1QztJQUNyQ0ksWUFBWTtJQUNaQyxLQUFLLFNBQVNBO1FBQ1osT0FBT2UsTUFBTUMsSUFBSTtJQUNuQjtBQUNGLENBQUMsRUFBQztBQUNGckIsaURBQWdEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUssU0FBU0E7UUFDWixPQUFPaUIsZUFBZUMsYUFBYTtJQUNyQztBQUNGLENBQUMsRUFB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RSxtQkFBT0EsQ0FBQywwRkFBbUI7QUFDeEMsSUFBSTlFLFlBQVk4RSxtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDOUMsSUFBSTVELGFBQWE0RCxtQkFBT0EsQ0FBQywwRkFBbUI7QUFDNUMsSUFBSXRHLFlBQVlzRyxtQkFBT0EsQ0FBQyx3RkFBa0I7QUFDMUMsSUFBSXhELFlBQVl3RCxtQkFBT0EsQ0FBQyx3RkFBa0I7QUFDMUMsSUFBSVIsV0FBV1EsbUJBQU9BLENBQUMsc0ZBQWlCO0FBQ3hDLElBQUk1QixVQUFVNEIsbUJBQU9BLENBQUMsb0ZBQWdCO0FBQ3RDLElBQUk1QyxjQUFjNEMsbUJBQU9BLENBQUMsNEZBQW9CO0FBQzlDLElBQUl4QixnQkFBZ0J3QixtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDbEQsSUFBSTFHLGFBQWEwRyxtQkFBT0EsQ0FBQywwRkFBbUI7QUFDNUMsSUFBSXhDLGtCQUFrQndDLG1CQUFPQSxDQUFDLG9HQUF3QjtBQUN0RCxJQUFJNUYsaUJBQWlCNEYsbUJBQU9BLENBQUMsa0dBQXVCO0FBQ3BELElBQUlwQixpQkFBaUJvQixtQkFBT0EsQ0FBQyxrR0FBdUI7QUFDcEQsSUFBSTVFLFVBQVU0RSxtQkFBT0EsQ0FBQyw4RkFBcUI7QUFDM0MsSUFBSTFFLGVBQWUwRSxtQkFBT0EsQ0FBQyw4RkFBcUI7QUFDaEQsSUFBSVYsYUFBYVUsbUJBQU9BLENBQUMsMEZBQW1CO0FBQzVDLElBQUl4RSxVQUFVd0UsbUJBQU9BLENBQUMsa0ZBQWUiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFyZWFcIiwge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX0FyZWEuQXJlYTtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBcmVhQ2hhcnRcIiwge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX0FyZWFDaGFydC5BcmVhQ2hhcnQ7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFyXCIsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgcmV0dXJuIF9CYXIuQmFyO1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhckNoYXJ0XCIsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgcmV0dXJuIF9CYXJDaGFydC5CYXJDaGFydDtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCcnVzaFwiLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfQnJ1c2guQnJ1c2g7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FydGVzaWFuQXhpc1wiLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfQ2FydGVzaWFuQXhpcy5DYXJ0ZXNpYW5BeGlzO1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhcnRlc2lhbkdyaWRcIiwge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX0NhcnRlc2lhbkdyaWQuQ2FydGVzaWFuR3JpZDtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDZWxsXCIsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgcmV0dXJuIF9DZWxsLkNlbGw7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29tcG9zZWRDaGFydFwiLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfQ29tcG9zZWRDaGFydC5Db21wb3NlZENoYXJ0O1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNyb3NzXCIsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgcmV0dXJuIF9Dcm9zcy5Dcm9zcztcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDdXJ2ZVwiLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfQ3VydmUuQ3VydmU7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ3VzdG9taXplZFwiLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfQ3VzdG9taXplZC5DdXN0b21pemVkO1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRlZmF1bHRMZWdlbmRDb250ZW50XCIsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgcmV0dXJuIF9EZWZhdWx0TGVnZW5kQ29udGVudC5EZWZhdWx0TGVnZW5kQ29udGVudDtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWZhdWx0VG9vbHRpcENvbnRlbnRcIiwge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX0RlZmF1bHRUb29sdGlwQ29udGVudC5EZWZhdWx0VG9vbHRpcENvbnRlbnQ7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRG90XCIsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgcmV0dXJuIF9Eb3QuRG90O1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVycm9yQmFyXCIsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgcmV0dXJuIF9FcnJvckJhci5FcnJvckJhcjtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGdW5uZWxcIiwge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX0Z1bm5lbC5GdW5uZWw7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRnVubmVsQ2hhcnRcIiwge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX0Z1bm5lbENoYXJ0LkZ1bm5lbENoYXJ0O1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkdsb2JhbFwiLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfR2xvYmFsLkdsb2JhbDtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMYWJlbFwiLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfTGFiZWwuTGFiZWw7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGFiZWxMaXN0XCIsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgcmV0dXJuIF9MYWJlbExpc3QuTGFiZWxMaXN0O1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxheWVyXCIsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgcmV0dXJuIF9MYXllci5MYXllcjtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMZWdlbmRcIiwge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX0xlZ2VuZC5MZWdlbmQ7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGluZVwiLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfTGluZS5MaW5lO1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpbmVDaGFydFwiLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfTGluZUNoYXJ0LkxpbmVDaGFydDtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQaWVcIiwge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX1BpZS5QaWU7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGllQ2hhcnRcIiwge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX1BpZUNoYXJ0LlBpZUNoYXJ0O1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBvbGFyQW5nbGVBeGlzXCIsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgcmV0dXJuIF9Qb2xhckFuZ2xlQXhpcy5Qb2xhckFuZ2xlQXhpcztcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQb2xhckdyaWRcIiwge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX1BvbGFyR3JpZC5Qb2xhckdyaWQ7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUG9sYXJSYWRpdXNBeGlzXCIsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgcmV0dXJuIF9Qb2xhclJhZGl1c0F4aXMuUG9sYXJSYWRpdXNBeGlzO1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBvbHlnb25cIiwge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX1BvbHlnb24uUG9seWdvbjtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSYWRhclwiLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfUmFkYXIuUmFkYXI7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmFkYXJDaGFydFwiLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfUmFkYXJDaGFydC5SYWRhckNoYXJ0O1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJhZGlhbEJhclwiLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfUmFkaWFsQmFyLlJhZGlhbEJhcjtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSYWRpYWxCYXJDaGFydFwiLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfUmFkaWFsQmFyQ2hhcnQuUmFkaWFsQmFyQ2hhcnQ7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVjdGFuZ2xlXCIsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgcmV0dXJuIF9SZWN0YW5nbGUuUmVjdGFuZ2xlO1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlZmVyZW5jZUFyZWFcIiwge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX1JlZmVyZW5jZUFyZWEuUmVmZXJlbmNlQXJlYTtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZWZlcmVuY2VEb3RcIiwge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX1JlZmVyZW5jZURvdC5SZWZlcmVuY2VEb3Q7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVmZXJlbmNlTGluZVwiLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfUmVmZXJlbmNlTGluZS5SZWZlcmVuY2VMaW5lO1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlc3BvbnNpdmVDb250YWluZXJcIiwge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX1Jlc3BvbnNpdmVDb250YWluZXIuUmVzcG9uc2l2ZUNvbnRhaW5lcjtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTYW5rZXlcIiwge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX1NhbmtleS5TYW5rZXk7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2NhdHRlclwiLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfU2NhdHRlci5TY2F0dGVyO1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNjYXR0ZXJDaGFydFwiLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfU2NhdHRlckNoYXJ0LlNjYXR0ZXJDaGFydDtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZWN0b3JcIiwge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX1NlY3Rvci5TZWN0b3I7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3VuYnVyc3RDaGFydFwiLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfU3VuYnVyc3RDaGFydC5TdW5idXJzdENoYXJ0O1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN1cmZhY2VcIiwge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX1N1cmZhY2UuU3VyZmFjZTtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTeW1ib2xzXCIsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgcmV0dXJuIF9TeW1ib2xzLlN5bWJvbHM7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGV4dFwiLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfVGV4dC5UZXh0O1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRvb2x0aXBcIiwge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX1Rvb2x0aXAuVG9vbHRpcDtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFwZXpvaWRcIiwge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX1RyYXBlem9pZC5UcmFwZXpvaWQ7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJlZW1hcFwiLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfVHJlZW1hcC5UcmVlbWFwO1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlhBeGlzXCIsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgcmV0dXJuIF9YQXhpcy5YQXhpcztcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJZQXhpc1wiLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfWUF4aXMuWUF4aXM7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiWkF4aXNcIiwge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX1pBeGlzLlpBeGlzO1xyXG4gIH1cclxufSk7XHJcbnZhciBfU3VyZmFjZSA9IHJlcXVpcmUoXCIuL2NvbnRhaW5lci9TdXJmYWNlXCIpO1xyXG52YXIgX0xheWVyID0gcmVxdWlyZShcIi4vY29udGFpbmVyL0xheWVyXCIpO1xyXG52YXIgX0xlZ2VuZCA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudC9MZWdlbmRcIik7XHJcbnZhciBfRGVmYXVsdExlZ2VuZENvbnRlbnQgPSByZXF1aXJlKFwiLi9jb21wb25lbnQvRGVmYXVsdExlZ2VuZENvbnRlbnRcIik7XHJcbnZhciBfVG9vbHRpcCA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudC9Ub29sdGlwXCIpO1xyXG52YXIgX0RlZmF1bHRUb29sdGlwQ29udGVudCA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudC9EZWZhdWx0VG9vbHRpcENvbnRlbnRcIik7XHJcbnZhciBfUmVzcG9uc2l2ZUNvbnRhaW5lciA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudC9SZXNwb25zaXZlQ29udGFpbmVyXCIpO1xyXG52YXIgX0NlbGwgPSByZXF1aXJlKFwiLi9jb21wb25lbnQvQ2VsbFwiKTtcclxudmFyIF9UZXh0ID0gcmVxdWlyZShcIi4vY29tcG9uZW50L1RleHRcIik7XHJcbnZhciBfTGFiZWwgPSByZXF1aXJlKFwiLi9jb21wb25lbnQvTGFiZWxcIik7XHJcbnZhciBfTGFiZWxMaXN0ID0gcmVxdWlyZShcIi4vY29tcG9uZW50L0xhYmVsTGlzdFwiKTtcclxudmFyIF9DdXN0b21pemVkID0gcmVxdWlyZShcIi4vY29tcG9uZW50L0N1c3RvbWl6ZWRcIik7XHJcbnZhciBfU2VjdG9yID0gcmVxdWlyZShcIi4vc2hhcGUvU2VjdG9yXCIpO1xyXG52YXIgX0N1cnZlID0gcmVxdWlyZShcIi4vc2hhcGUvQ3VydmVcIik7XHJcbnZhciBfUmVjdGFuZ2xlID0gcmVxdWlyZShcIi4vc2hhcGUvUmVjdGFuZ2xlXCIpO1xyXG52YXIgX1BvbHlnb24gPSByZXF1aXJlKFwiLi9zaGFwZS9Qb2x5Z29uXCIpO1xyXG52YXIgX0RvdCA9IHJlcXVpcmUoXCIuL3NoYXBlL0RvdFwiKTtcclxudmFyIF9Dcm9zcyA9IHJlcXVpcmUoXCIuL3NoYXBlL0Nyb3NzXCIpO1xyXG52YXIgX1N5bWJvbHMgPSByZXF1aXJlKFwiLi9zaGFwZS9TeW1ib2xzXCIpO1xyXG52YXIgX1BvbGFyR3JpZCA9IHJlcXVpcmUoXCIuL3BvbGFyL1BvbGFyR3JpZFwiKTtcclxudmFyIF9Qb2xhclJhZGl1c0F4aXMgPSByZXF1aXJlKFwiLi9wb2xhci9Qb2xhclJhZGl1c0F4aXNcIik7XHJcbnZhciBfUG9sYXJBbmdsZUF4aXMgPSByZXF1aXJlKFwiLi9wb2xhci9Qb2xhckFuZ2xlQXhpc1wiKTtcclxudmFyIF9QaWUgPSByZXF1aXJlKFwiLi9wb2xhci9QaWVcIik7XHJcbnZhciBfUmFkYXIgPSByZXF1aXJlKFwiLi9wb2xhci9SYWRhclwiKTtcclxudmFyIF9SYWRpYWxCYXIgPSByZXF1aXJlKFwiLi9wb2xhci9SYWRpYWxCYXJcIik7XHJcbnZhciBfQnJ1c2ggPSByZXF1aXJlKFwiLi9jYXJ0ZXNpYW4vQnJ1c2hcIik7XHJcbnZhciBfUmVmZXJlbmNlTGluZSA9IHJlcXVpcmUoXCIuL2NhcnRlc2lhbi9SZWZlcmVuY2VMaW5lXCIpO1xyXG52YXIgX1JlZmVyZW5jZURvdCA9IHJlcXVpcmUoXCIuL2NhcnRlc2lhbi9SZWZlcmVuY2VEb3RcIik7XHJcbnZhciBfUmVmZXJlbmNlQXJlYSA9IHJlcXVpcmUoXCIuL2NhcnRlc2lhbi9SZWZlcmVuY2VBcmVhXCIpO1xyXG52YXIgX0NhcnRlc2lhbkF4aXMgPSByZXF1aXJlKFwiLi9jYXJ0ZXNpYW4vQ2FydGVzaWFuQXhpc1wiKTtcclxudmFyIF9DYXJ0ZXNpYW5HcmlkID0gcmVxdWlyZShcIi4vY2FydGVzaWFuL0NhcnRlc2lhbkdyaWRcIik7XHJcbnZhciBfTGluZSA9IHJlcXVpcmUoXCIuL2NhcnRlc2lhbi9MaW5lXCIpO1xyXG52YXIgX0FyZWEgPSByZXF1aXJlKFwiLi9jYXJ0ZXNpYW4vQXJlYVwiKTtcclxudmFyIF9CYXIgPSByZXF1aXJlKFwiLi9jYXJ0ZXNpYW4vQmFyXCIpO1xyXG52YXIgX1NjYXR0ZXIgPSByZXF1aXJlKFwiLi9jYXJ0ZXNpYW4vU2NhdHRlclwiKTtcclxudmFyIF9YQXhpcyA9IHJlcXVpcmUoXCIuL2NhcnRlc2lhbi9YQXhpc1wiKTtcclxudmFyIF9ZQXhpcyA9IHJlcXVpcmUoXCIuL2NhcnRlc2lhbi9ZQXhpc1wiKTtcclxudmFyIF9aQXhpcyA9IHJlcXVpcmUoXCIuL2NhcnRlc2lhbi9aQXhpc1wiKTtcclxudmFyIF9FcnJvckJhciA9IHJlcXVpcmUoXCIuL2NhcnRlc2lhbi9FcnJvckJhclwiKTtcclxudmFyIF9MaW5lQ2hhcnQgPSByZXF1aXJlKFwiLi9jaGFydC9MaW5lQ2hhcnRcIik7XHJcbnZhciBfQmFyQ2hhcnQgPSByZXF1aXJlKFwiLi9jaGFydC9CYXJDaGFydFwiKTtcclxudmFyIF9QaWVDaGFydCA9IHJlcXVpcmUoXCIuL2NoYXJ0L1BpZUNoYXJ0XCIpO1xyXG52YXIgX1RyZWVtYXAgPSByZXF1aXJlKFwiLi9jaGFydC9UcmVlbWFwXCIpO1xyXG52YXIgX1NhbmtleSA9IHJlcXVpcmUoXCIuL2NoYXJ0L1NhbmtleVwiKTtcclxudmFyIF9SYWRhckNoYXJ0ID0gcmVxdWlyZShcIi4vY2hhcnQvUmFkYXJDaGFydFwiKTtcclxudmFyIF9TY2F0dGVyQ2hhcnQgPSByZXF1aXJlKFwiLi9jaGFydC9TY2F0dGVyQ2hhcnRcIik7XHJcbnZhciBfQXJlYUNoYXJ0ID0gcmVxdWlyZShcIi4vY2hhcnQvQXJlYUNoYXJ0XCIpO1xyXG52YXIgX1JhZGlhbEJhckNoYXJ0ID0gcmVxdWlyZShcIi4vY2hhcnQvUmFkaWFsQmFyQ2hhcnRcIik7XHJcbnZhciBfQ29tcG9zZWRDaGFydCA9IHJlcXVpcmUoXCIuL2NoYXJ0L0NvbXBvc2VkQ2hhcnRcIik7XHJcbnZhciBfU3VuYnVyc3RDaGFydCA9IHJlcXVpcmUoXCIuL2NoYXJ0L1N1bmJ1cnN0Q2hhcnRcIik7XHJcbnZhciBfRnVubmVsID0gcmVxdWlyZShcIi4vbnVtYmVyQXhpcy9GdW5uZWxcIik7XHJcbnZhciBfRnVubmVsQ2hhcnQgPSByZXF1aXJlKFwiLi9jaGFydC9GdW5uZWxDaGFydFwiKTtcclxudmFyIF9UcmFwZXpvaWQgPSByZXF1aXJlKFwiLi9zaGFwZS9UcmFwZXpvaWRcIik7XHJcbnZhciBfR2xvYmFsID0gcmVxdWlyZShcIi4vdXRpbC9HbG9iYWxcIik7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIl9BcmVhIiwiQXJlYSIsIl9BcmVhQ2hhcnQiLCJBcmVhQ2hhcnQiLCJfQmFyIiwiQmFyIiwiX0JhckNoYXJ0IiwiQmFyQ2hhcnQiLCJfQnJ1c2giLCJCcnVzaCIsIl9DYXJ0ZXNpYW5BeGlzIiwiQ2FydGVzaWFuQXhpcyIsIl9DYXJ0ZXNpYW5HcmlkIiwiQ2FydGVzaWFuR3JpZCIsIl9DZWxsIiwiQ2VsbCIsIl9Db21wb3NlZENoYXJ0IiwiQ29tcG9zZWRDaGFydCIsIl9Dcm9zcyIsIkNyb3NzIiwiX0N1cnZlIiwiQ3VydmUiLCJfQ3VzdG9taXplZCIsIkN1c3RvbWl6ZWQiLCJfRGVmYXVsdExlZ2VuZENvbnRlbnQiLCJEZWZhdWx0TGVnZW5kQ29udGVudCIsIl9EZWZhdWx0VG9vbHRpcENvbnRlbnQiLCJEZWZhdWx0VG9vbHRpcENvbnRlbnQiLCJfRG90IiwiRG90IiwiX0Vycm9yQmFyIiwiRXJyb3JCYXIiLCJfRnVubmVsIiwiRnVubmVsIiwiX0Z1bm5lbENoYXJ0IiwiRnVubmVsQ2hhcnQiLCJfR2xvYmFsIiwiR2xvYmFsIiwiX0xhYmVsIiwiTGFiZWwiLCJfTGFiZWxMaXN0IiwiTGFiZWxMaXN0IiwiX0xheWVyIiwiTGF5ZXIiLCJfTGVnZW5kIiwiTGVnZW5kIiwiX0xpbmUiLCJMaW5lIiwiX0xpbmVDaGFydCIsIkxpbmVDaGFydCIsIl9QaWUiLCJQaWUiLCJfUGllQ2hhcnQiLCJQaWVDaGFydCIsIl9Qb2xhckFuZ2xlQXhpcyIsIlBvbGFyQW5nbGVBeGlzIiwiX1BvbGFyR3JpZCIsIlBvbGFyR3JpZCIsIl9Qb2xhclJhZGl1c0F4aXMiLCJQb2xhclJhZGl1c0F4aXMiLCJfUG9seWdvbiIsIlBvbHlnb24iLCJfUmFkYXIiLCJSYWRhciIsIl9SYWRhckNoYXJ0IiwiUmFkYXJDaGFydCIsIl9SYWRpYWxCYXIiLCJSYWRpYWxCYXIiLCJfUmFkaWFsQmFyQ2hhcnQiLCJSYWRpYWxCYXJDaGFydCIsIl9SZWN0YW5nbGUiLCJSZWN0YW5nbGUiLCJfUmVmZXJlbmNlQXJlYSIsIlJlZmVyZW5jZUFyZWEiLCJfUmVmZXJlbmNlRG90IiwiUmVmZXJlbmNlRG90IiwiX1JlZmVyZW5jZUxpbmUiLCJSZWZlcmVuY2VMaW5lIiwiX1Jlc3BvbnNpdmVDb250YWluZXIiLCJSZXNwb25zaXZlQ29udGFpbmVyIiwiX1NhbmtleSIsIlNhbmtleSIsIl9TY2F0dGVyIiwiU2NhdHRlciIsIl9TY2F0dGVyQ2hhcnQiLCJTY2F0dGVyQ2hhcnQiLCJfU2VjdG9yIiwiU2VjdG9yIiwiX1N1bmJ1cnN0Q2hhcnQiLCJTdW5idXJzdENoYXJ0IiwiX1N1cmZhY2UiLCJTdXJmYWNlIiwiX1N5bWJvbHMiLCJTeW1ib2xzIiwiX1RleHQiLCJUZXh0IiwiX1Rvb2x0aXAiLCJUb29sdGlwIiwiX1RyYXBlem9pZCIsIlRyYXBlem9pZCIsIl9UcmVlbWFwIiwiVHJlZW1hcCIsIl9YQXhpcyIsIlhBeGlzIiwiX1lBeGlzIiwiWUF4aXMiLCJfWkF4aXMiLCJaQXhpcyIsInJlcXVpcmUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/index.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/numberAxis/Funnel.js":
/*!********************************************************!*\
  !*** ./node_modules/recharts/lib/numberAxis/Funnel.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Funnel = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _isNumber = _interopRequireDefault(__webpack_require__(/*! lodash/isNumber */ \"lodash/isNumber\"));\nvar _isString = _interopRequireDefault(__webpack_require__(/*! lodash/isString */ \"lodash/isString\"));\nvar _omit = _interopRequireDefault(__webpack_require__(/*! lodash/omit */ \"lodash/omit\"));\nvar _isEqual = _interopRequireDefault(__webpack_require__(/*! lodash/isEqual */ \"lodash/isEqual\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _LabelList = __webpack_require__(/*! ../component/LabelList */ \"(pages-dir-node)/./node_modules/recharts/lib/component/LabelList.js\");\nvar _Cell = __webpack_require__(/*! ../component/Cell */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Cell.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"(pages-dir-node)/./node_modules/recharts/lib/util/Global.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _types = __webpack_require__(/*! ../util/types */ \"(pages-dir-node)/./node_modules/recharts/lib/util/types.js\");\nvar _FunnelUtils = __webpack_require__(/*! ../util/FunnelUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/FunnelUtils.js\");\nvar _Funnel;\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Render sectors of a funnel\r\n */ \nvar Funnel = exports.Funnel = /*#__PURE__*/ function(_PureComponent) {\n    function Funnel() {\n        var _this;\n        _classCallCheck(this, Funnel);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, Funnel, [].concat(args));\n        _defineProperty(_this, \"state\", {\n            isAnimationFinished: false\n        });\n        _defineProperty(_this, \"handleAnimationEnd\", function() {\n            var onAnimationEnd = _this.props.onAnimationEnd;\n            _this.setState({\n                isAnimationFinished: true\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationEnd)) {\n                onAnimationEnd();\n            }\n        });\n        _defineProperty(_this, \"handleAnimationStart\", function() {\n            var onAnimationStart = _this.props.onAnimationStart;\n            _this.setState({\n                isAnimationFinished: false\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationStart)) {\n                onAnimationStart();\n            }\n        });\n        return _this;\n    }\n    _inherits(Funnel, _PureComponent);\n    return _createClass(Funnel, [\n        {\n            key: \"isActiveIndex\",\n            value: function isActiveIndex(i) {\n                var activeIndex = this.props.activeIndex;\n                if (Array.isArray(activeIndex)) {\n                    return activeIndex.indexOf(i) !== -1;\n                }\n                return i === activeIndex;\n            }\n        },\n        {\n            key: \"renderTrapezoidsStatically\",\n            value: function renderTrapezoidsStatically(trapezoids) {\n                var _this2 = this;\n                var _this$props = this.props, shape = _this$props.shape, activeShape = _this$props.activeShape;\n                return trapezoids.map(function(entry, i) {\n                    var trapezoidOptions = _this2.isActiveIndex(i) ? activeShape : shape;\n                    var trapezoidProps = _objectSpread(_objectSpread({}, entry), {}, {\n                        isActive: _this2.isActiveIndex(i),\n                        stroke: entry.stroke\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                        className: \"recharts-funnel-trapezoid\"\n                    }, (0, _types.adaptEventsOfChild)(_this2.props, entry, i), {\n                        key: \"trapezoid-\".concat(entry === null || entry === void 0 ? void 0 : entry.x, \"-\").concat(entry === null || entry === void 0 ? void 0 : entry.y, \"-\").concat(entry === null || entry === void 0 ? void 0 : entry.name, \"-\").concat(entry === null || entry === void 0 ? void 0 : entry.value),\n                        role: \"img\"\n                    }), /*#__PURE__*/ _react[\"default\"].createElement(_FunnelUtils.FunnelTrapezoid, _extends({\n                        option: trapezoidOptions\n                    }, trapezoidProps)));\n                });\n            }\n        },\n        {\n            key: \"renderTrapezoidsWithAnimation\",\n            value: function renderTrapezoidsWithAnimation() {\n                var _this3 = this;\n                var _this$props2 = this.props, trapezoids = _this$props2.trapezoids, isAnimationActive = _this$props2.isAnimationActive, animationBegin = _this$props2.animationBegin, animationDuration = _this$props2.animationDuration, animationEasing = _this$props2.animationEasing, animationId = _this$props2.animationId;\n                var prevTrapezoids = this.state.prevTrapezoids;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n                    begin: animationBegin,\n                    duration: animationDuration,\n                    isActive: isAnimationActive,\n                    easing: animationEasing,\n                    from: {\n                        t: 0\n                    },\n                    to: {\n                        t: 1\n                    },\n                    key: \"funnel-\".concat(animationId),\n                    onAnimationStart: this.handleAnimationStart,\n                    onAnimationEnd: this.handleAnimationEnd\n                }, function(_ref) {\n                    var t = _ref.t;\n                    var stepData = trapezoids.map(function(entry, index) {\n                        var prev = prevTrapezoids && prevTrapezoids[index];\n                        if (prev) {\n                            var _interpolatorX = (0, _DataUtils.interpolateNumber)(prev.x, entry.x);\n                            var _interpolatorY = (0, _DataUtils.interpolateNumber)(prev.y, entry.y);\n                            var _interpolatorUpperWidth = (0, _DataUtils.interpolateNumber)(prev.upperWidth, entry.upperWidth);\n                            var _interpolatorLowerWidth = (0, _DataUtils.interpolateNumber)(prev.lowerWidth, entry.lowerWidth);\n                            var _interpolatorHeight = (0, _DataUtils.interpolateNumber)(prev.height, entry.height);\n                            return _objectSpread(_objectSpread({}, entry), {}, {\n                                x: _interpolatorX(t),\n                                y: _interpolatorY(t),\n                                upperWidth: _interpolatorUpperWidth(t),\n                                lowerWidth: _interpolatorLowerWidth(t),\n                                height: _interpolatorHeight(t)\n                            });\n                        }\n                        var interpolatorX = (0, _DataUtils.interpolateNumber)(entry.x + entry.upperWidth / 2, entry.x);\n                        var interpolatorY = (0, _DataUtils.interpolateNumber)(entry.y + entry.height / 2, entry.y);\n                        var interpolatorUpperWidth = (0, _DataUtils.interpolateNumber)(0, entry.upperWidth);\n                        var interpolatorLowerWidth = (0, _DataUtils.interpolateNumber)(0, entry.lowerWidth);\n                        var interpolatorHeight = (0, _DataUtils.interpolateNumber)(0, entry.height);\n                        return _objectSpread(_objectSpread({}, entry), {}, {\n                            x: interpolatorX(t),\n                            y: interpolatorY(t),\n                            upperWidth: interpolatorUpperWidth(t),\n                            lowerWidth: interpolatorLowerWidth(t),\n                            height: interpolatorHeight(t)\n                        });\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, null, _this3.renderTrapezoidsStatically(stepData));\n                });\n            }\n        },\n        {\n            key: \"renderTrapezoids\",\n            value: function renderTrapezoids() {\n                var _this$props3 = this.props, trapezoids = _this$props3.trapezoids, isAnimationActive = _this$props3.isAnimationActive;\n                var prevTrapezoids = this.state.prevTrapezoids;\n                if (isAnimationActive && trapezoids && trapezoids.length && (!prevTrapezoids || !(0, _isEqual[\"default\"])(prevTrapezoids, trapezoids))) {\n                    return this.renderTrapezoidsWithAnimation();\n                }\n                return this.renderTrapezoidsStatically(trapezoids);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props4 = this.props, hide = _this$props4.hide, trapezoids = _this$props4.trapezoids, className = _this$props4.className, isAnimationActive = _this$props4.isAnimationActive;\n                var isAnimationFinished = this.state.isAnimationFinished;\n                if (hide || !trapezoids || !trapezoids.length) {\n                    return null;\n                }\n                var layerClass = (0, _clsx[\"default\"])('recharts-trapezoids', className);\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: layerClass\n                }, this.renderTrapezoids(), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, trapezoids));\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                if (nextProps.animationId !== prevState.prevAnimationId) {\n                    return {\n                        prevAnimationId: nextProps.animationId,\n                        curTrapezoids: nextProps.trapezoids,\n                        prevTrapezoids: prevState.curTrapezoids\n                    };\n                }\n                if (nextProps.trapezoids !== prevState.curTrapezoids) {\n                    return {\n                        curTrapezoids: nextProps.trapezoids\n                    };\n                }\n                return null;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_Funnel = Funnel;\n_defineProperty(Funnel, \"displayName\", 'Funnel');\n_defineProperty(Funnel, \"defaultProps\", {\n    stroke: '#fff',\n    fill: '#808080',\n    legendType: 'rect',\n    labelLine: true,\n    hide: false,\n    isAnimationActive: !_Global.Global.isSsr,\n    animationBegin: 400,\n    animationDuration: 1500,\n    animationEasing: 'ease',\n    nameKey: 'name',\n    lastShapeType: 'triangle'\n});\n_defineProperty(Funnel, \"getRealFunnelData\", function(item) {\n    var _item$props = item.props, data = _item$props.data, children = _item$props.children;\n    var presentationProps = (0, _ReactUtils.filterProps)(item.props, false);\n    var cells = (0, _ReactUtils.findAllByType)(children, _Cell.Cell);\n    if (data && data.length) {\n        return data.map(function(entry, index) {\n            return _objectSpread(_objectSpread(_objectSpread({\n                payload: entry\n            }, presentationProps), entry), cells && cells[index] && cells[index].props);\n        });\n    }\n    if (cells && cells.length) {\n        return cells.map(function(cell) {\n            return _objectSpread(_objectSpread({}, presentationProps), cell.props);\n        });\n    }\n    return [];\n});\n_defineProperty(Funnel, \"getRealWidthHeight\", function(item, offset) {\n    var customWidth = item.props.width;\n    var width = offset.width, height = offset.height, left = offset.left, right = offset.right, top = offset.top, bottom = offset.bottom;\n    var realHeight = height;\n    var realWidth = width;\n    if ((0, _isNumber[\"default\"])(customWidth)) {\n        realWidth = customWidth;\n    } else if ((0, _isString[\"default\"])(customWidth)) {\n        realWidth = realWidth * parseFloat(customWidth) / 100;\n    }\n    return {\n        realWidth: realWidth - left - right - 50,\n        realHeight: realHeight - bottom - top,\n        offsetX: (width - realWidth) / 2,\n        offsetY: (height - realHeight) / 2\n    };\n});\n_defineProperty(Funnel, \"getComposedData\", function(_ref2) {\n    var item = _ref2.item, offset = _ref2.offset;\n    var funnelData = _Funnel.getRealFunnelData(item);\n    var _item$props2 = item.props, dataKey = _item$props2.dataKey, nameKey = _item$props2.nameKey, tooltipType = _item$props2.tooltipType, lastShapeType = _item$props2.lastShapeType, reversed = _item$props2.reversed;\n    var left = offset.left, top = offset.top;\n    var _Funnel$getRealWidthH = _Funnel.getRealWidthHeight(item, offset), realHeight = _Funnel$getRealWidthH.realHeight, realWidth = _Funnel$getRealWidthH.realWidth, offsetX = _Funnel$getRealWidthH.offsetX, offsetY = _Funnel$getRealWidthH.offsetY;\n    var maxValue = Math.max.apply(null, funnelData.map(function(entry) {\n        return (0, _ChartUtils.getValueByDataKey)(entry, dataKey, 0);\n    }));\n    var len = funnelData.length;\n    var rowHeight = realHeight / len;\n    var parentViewBox = {\n        x: offset.left,\n        y: offset.top,\n        width: offset.width,\n        height: offset.height\n    };\n    var trapezoids = funnelData.map(function(entry, i) {\n        var rawVal = (0, _ChartUtils.getValueByDataKey)(entry, dataKey, 0);\n        var name = (0, _ChartUtils.getValueByDataKey)(entry, nameKey, i);\n        var val = rawVal;\n        var nextVal;\n        if (i !== len - 1) {\n            nextVal = (0, _ChartUtils.getValueByDataKey)(funnelData[i + 1], dataKey, 0);\n            if (nextVal instanceof Array) {\n                var _nextVal = nextVal;\n                var _nextVal2 = _slicedToArray(_nextVal, 1);\n                nextVal = _nextVal2[0];\n            }\n        } else if (rawVal instanceof Array && rawVal.length === 2) {\n            var _rawVal = _slicedToArray(rawVal, 2);\n            val = _rawVal[0];\n            nextVal = _rawVal[1];\n        } else if (lastShapeType === 'rectangle') {\n            nextVal = val;\n        } else {\n            nextVal = 0;\n        }\n        var x = (maxValue - val) * realWidth / (2 * maxValue) + top + 25 + offsetX;\n        var y = rowHeight * i + left + offsetY;\n        var upperWidth = val / maxValue * realWidth;\n        var lowerWidth = nextVal / maxValue * realWidth;\n        var tooltipPayload = [\n            {\n                name: name,\n                value: val,\n                payload: entry,\n                dataKey: dataKey,\n                type: tooltipType\n            }\n        ];\n        var tooltipPosition = {\n            x: x + upperWidth / 2,\n            y: y + rowHeight / 2\n        };\n        return _objectSpread(_objectSpread({\n            x: x,\n            y: y,\n            width: Math.max(upperWidth, lowerWidth),\n            upperWidth: upperWidth,\n            lowerWidth: lowerWidth,\n            height: rowHeight,\n            name: name,\n            val: val,\n            tooltipPayload: tooltipPayload,\n            tooltipPosition: tooltipPosition\n        }, (0, _omit[\"default\"])(entry, 'width')), {}, {\n            payload: entry,\n            parentViewBox: parentViewBox,\n            labelViewBox: {\n                x: x + (upperWidth - lowerWidth) / 4,\n                y: y,\n                width: Math.abs(upperWidth - lowerWidth) / 2 + Math.min(upperWidth, lowerWidth),\n                height: rowHeight\n            }\n        });\n    });\n    if (reversed) {\n        trapezoids = trapezoids.map(function(entry, index) {\n            var newY = entry.y - index * rowHeight + (len - 1 - index) * rowHeight;\n            return _objectSpread(_objectSpread({}, entry), {}, {\n                upperWidth: entry.lowerWidth,\n                lowerWidth: entry.upperWidth,\n                x: entry.x - (entry.lowerWidth - entry.upperWidth) / 2,\n                y: entry.y - index * rowHeight + (len - 1 - index) * rowHeight,\n                tooltipPosition: _objectSpread(_objectSpread({}, entry.tooltipPosition), {}, {\n                    y: newY + rowHeight / 2\n                }),\n                labelViewBox: _objectSpread(_objectSpread({}, entry.labelViewBox), {}, {\n                    y: newY\n                })\n            });\n        });\n    }\n    return {\n        trapezoids: trapezoids,\n        data: funnelData\n    };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvbnVtYmVyQXhpcy9GdW5uZWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGNBQWMsR0FBRyxLQUFLO0FBQ3RCLElBQUlHLFNBQVNDLHdCQUF3QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUMsZUFBZUMsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUNoRSxJQUFJRyxjQUFjRCx1QkFBdUJGLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJSSxZQUFZRix1QkFBdUJGLG1CQUFPQSxDQUFDLHdDQUFpQjtBQUNoRSxJQUFJSyxZQUFZSCx1QkFBdUJGLG1CQUFPQSxDQUFDLHdDQUFpQjtBQUNoRSxJQUFJTSxRQUFRSix1QkFBdUJGLG1CQUFPQSxDQUFDLGdDQUFhO0FBQ3hELElBQUlPLFdBQVdMLHVCQUF1QkYsbUJBQU9BLENBQUMsc0NBQWdCO0FBQzlELElBQUlRLFFBQVFOLHVCQUF1QkYsbUJBQU9BLENBQUMsdUJBQU07QUFDakQsSUFBSVMsU0FBU1QsbUJBQU9BLENBQUMsMkZBQW9CO0FBQ3pDLElBQUlVLGFBQWFWLG1CQUFPQSxDQUFDLG1HQUF3QjtBQUNqRCxJQUFJVyxRQUFRWCxtQkFBT0EsQ0FBQyx5RkFBbUI7QUFDdkMsSUFBSVksY0FBY1osbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlhLFVBQVViLG1CQUFPQSxDQUFDLG1GQUFnQjtBQUN0QyxJQUFJYyxhQUFhZCxtQkFBT0EsQ0FBQyx5RkFBbUI7QUFDNUMsSUFBSWUsY0FBY2YsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlnQixTQUFTaEIsbUJBQU9BLENBQUMsaUZBQWU7QUFDcEMsSUFBSWlCLGVBQWVqQixtQkFBT0EsQ0FBQyw2RkFBcUI7QUFDaEQsSUFBSWtCO0FBQ0osU0FBU2hCLHVCQUF1QmlCLEdBQUc7SUFB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QUdWLE1BQU1VLENBQUMsR0FBR3NCLFFBQVF5RSxZQUFZLENBQUM3TCxNQUFNLElBQUlvSCxLQUFJLElBQUt5RTtnQkFDckRVLGlCQUFpQi9LLGNBQWNBLGNBQWMsQ0FBQyxHQUFHNEQsTUFBTW1ILGVBQWUsR0FBRyxDQUFDLEdBQUc7b0JBQzNFekcsR0FBRzZHLE9BQU9kLFlBQVk7Z0JBQ3hCO2dCQUNBVyxjQUFjaEwsY0FBY0EsY0FBYyxDQUFDLEdBQUc0RCxNQUFNb0gsWUFBWSxHQUFHLENBQUMsR0FBRztvQkFDckUxRyxHQUFHNkc7Z0JBQ0w7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxPQUFPO1FBQ0w3SCxZQUFZQTtRQUNaNkUsTUFBTXNCO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcbnVtYmVyQXhpc1xcRnVubmVsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuRnVubmVsID0gdm9pZCAwO1xyXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIF9yZWFjdFNtb290aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0LXNtb290aFwiKSk7XHJcbnZhciBfaXNGdW5jdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpKTtcclxudmFyIF9pc051bWJlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc051bWJlclwiKSk7XHJcbnZhciBfaXNTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNTdHJpbmdcIikpO1xyXG52YXIgX29taXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvb21pdFwiKSk7XHJcbnZhciBfaXNFcXVhbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0VxdWFsXCIpKTtcclxudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XHJcbnZhciBfTGF5ZXIgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL0xheWVyXCIpO1xyXG52YXIgX0xhYmVsTGlzdCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQvTGFiZWxMaXN0XCIpO1xyXG52YXIgX0NlbGwgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50L0NlbGxcIik7XHJcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XHJcbnZhciBfR2xvYmFsID0gcmVxdWlyZShcIi4uL3V0aWwvR2xvYmFsXCIpO1xyXG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0RhdGFVdGlsc1wiKTtcclxudmFyIF9DaGFydFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvQ2hhcnRVdGlsc1wiKTtcclxudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuLi91dGlsL3R5cGVzXCIpO1xyXG52YXIgX0Z1bm5lbFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRnVubmVsVXRpbHNcIik7XHJcbnZhciBfRnVubmVsO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cclxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cclxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxyXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cclxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cclxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XHJcbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxyXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxyXG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxyXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cclxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XHJcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxyXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxyXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxyXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxyXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XHJcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxyXG4gKiBAZmlsZU92ZXJ2aWV3IFJlbmRlciBzZWN0b3JzIG9mIGEgZnVubmVsXHJcbiAqL1xyXG52YXIgRnVubmVsID0gZXhwb3J0cy5GdW5uZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QdXJlQ29tcG9uZW50KSB7XHJcbiAgZnVuY3Rpb24gRnVubmVsKCkge1xyXG4gICAgdmFyIF90aGlzO1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZ1bm5lbCk7XHJcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcclxuICAgIH1cclxuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBGdW5uZWwsIFtdLmNvbmNhdChhcmdzKSk7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwic3RhdGVcIiwge1xyXG4gICAgICBpc0FuaW1hdGlvbkZpbmlzaGVkOiBmYWxzZVxyXG4gICAgfSk7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlQW5pbWF0aW9uRW5kXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG9uQW5pbWF0aW9uRW5kID0gX3RoaXMucHJvcHMub25BbmltYXRpb25FbmQ7XHJcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcclxuICAgICAgICBpc0FuaW1hdGlvbkZpbmlzaGVkOiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob25BbmltYXRpb25FbmQpKSB7XHJcbiAgICAgICAgb25BbmltYXRpb25FbmQoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlQW5pbWF0aW9uU3RhcnRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgb25BbmltYXRpb25TdGFydCA9IF90aGlzLnByb3BzLm9uQW5pbWF0aW9uU3RhcnQ7XHJcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcclxuICAgICAgICBpc0FuaW1hdGlvbkZpbmlzaGVkOiBmYWxzZVxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9uQW5pbWF0aW9uU3RhcnQpKSB7XHJcbiAgICAgICAgb25BbmltYXRpb25TdGFydCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcbiAgX2luaGVyaXRzKEZ1bm5lbCwgX1B1cmVDb21wb25lbnQpO1xyXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRnVubmVsLCBbe1xyXG4gICAga2V5OiBcImlzQWN0aXZlSW5kZXhcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0FjdGl2ZUluZGV4KGkpIHtcclxuICAgICAgdmFyIGFjdGl2ZUluZGV4ID0gdGhpcy5wcm9wcy5hY3RpdmVJbmRleDtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYWN0aXZlSW5kZXgpKSB7XHJcbiAgICAgICAgcmV0dXJuIGFjdGl2ZUluZGV4LmluZGV4T2YoaSkgIT09IC0xO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpID09PSBhY3RpdmVJbmRleDtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyVHJhcGV6b2lkc1N0YXRpY2FsbHlcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJUcmFwZXpvaWRzU3RhdGljYWxseSh0cmFwZXpvaWRzKSB7XHJcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIHNoYXBlID0gX3RoaXMkcHJvcHMuc2hhcGUsXHJcbiAgICAgICAgYWN0aXZlU2hhcGUgPSBfdGhpcyRwcm9wcy5hY3RpdmVTaGFwZTtcclxuICAgICAgcmV0dXJuIHRyYXBlem9pZHMubWFwKGZ1bmN0aW9uIChlbnRyeSwgaSkge1xyXG4gICAgICAgIHZhciB0cmFwZXpvaWRPcHRpb25zID0gX3RoaXMyLmlzQWN0aXZlSW5kZXgoaSkgPyBhY3RpdmVTaGFwZSA6IHNoYXBlO1xyXG4gICAgICAgIHZhciB0cmFwZXpvaWRQcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xyXG4gICAgICAgICAgaXNBY3RpdmU6IF90aGlzMi5pc0FjdGl2ZUluZGV4KGkpLFxyXG4gICAgICAgICAgc3Ryb2tlOiBlbnRyeS5zdHJva2VcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIF9leHRlbmRzKHtcclxuICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1mdW5uZWwtdHJhcGV6b2lkXCJcclxuICAgICAgICB9LCAoMCwgX3R5cGVzLmFkYXB0RXZlbnRzT2ZDaGlsZCkoX3RoaXMyLnByb3BzLCBlbnRyeSwgaSksIHtcclxuICAgICAgICAgIGtleTogXCJ0cmFwZXpvaWQtXCIuY29uY2F0KGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS54LCBcIi1cIikuY29uY2F0KGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS55LCBcIi1cIikuY29uY2F0KGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS5uYW1lLCBcIi1cIikuY29uY2F0KGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS52YWx1ZSksXHJcbiAgICAgICAgICByb2xlOiBcImltZ1wiXHJcbiAgICAgICAgfSksIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0Z1bm5lbFV0aWxzLkZ1bm5lbFRyYXBlem9pZCwgX2V4dGVuZHMoe1xyXG4gICAgICAgICAgb3B0aW9uOiB0cmFwZXpvaWRPcHRpb25zXHJcbiAgICAgICAgfSwgdHJhcGV6b2lkUHJvcHMpKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJUcmFwZXpvaWRzV2l0aEFuaW1hdGlvblwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclRyYXBlem9pZHNXaXRoQW5pbWF0aW9uKCkge1xyXG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcclxuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgdHJhcGV6b2lkcyA9IF90aGlzJHByb3BzMi50cmFwZXpvaWRzLFxyXG4gICAgICAgIGlzQW5pbWF0aW9uQWN0aXZlID0gX3RoaXMkcHJvcHMyLmlzQW5pbWF0aW9uQWN0aXZlLFxyXG4gICAgICAgIGFuaW1hdGlvbkJlZ2luID0gX3RoaXMkcHJvcHMyLmFuaW1hdGlvbkJlZ2luLFxyXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uID0gX3RoaXMkcHJvcHMyLmFuaW1hdGlvbkR1cmF0aW9uLFxyXG4gICAgICAgIGFuaW1hdGlvbkVhc2luZyA9IF90aGlzJHByb3BzMi5hbmltYXRpb25FYXNpbmcsXHJcbiAgICAgICAgYW5pbWF0aW9uSWQgPSBfdGhpcyRwcm9wczIuYW5pbWF0aW9uSWQ7XHJcbiAgICAgIHZhciBwcmV2VHJhcGV6b2lkcyA9IHRoaXMuc3RhdGUucHJldlRyYXBlem9pZHM7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9yZWFjdFNtb290aFtcImRlZmF1bHRcIl0sIHtcclxuICAgICAgICBiZWdpbjogYW5pbWF0aW9uQmVnaW4sXHJcbiAgICAgICAgZHVyYXRpb246IGFuaW1hdGlvbkR1cmF0aW9uLFxyXG4gICAgICAgIGlzQWN0aXZlOiBpc0FuaW1hdGlvbkFjdGl2ZSxcclxuICAgICAgICBlYXNpbmc6IGFuaW1hdGlvbkVhc2luZyxcclxuICAgICAgICBmcm9tOiB7XHJcbiAgICAgICAgICB0OiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0bzoge1xyXG4gICAgICAgICAgdDogMVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAga2V5OiBcImZ1bm5lbC1cIi5jb25jYXQoYW5pbWF0aW9uSWQpLFxyXG4gICAgICAgIG9uQW5pbWF0aW9uU3RhcnQ6IHRoaXMuaGFuZGxlQW5pbWF0aW9uU3RhcnQsXHJcbiAgICAgICAgb25BbmltYXRpb25FbmQ6IHRoaXMuaGFuZGxlQW5pbWF0aW9uRW5kXHJcbiAgICAgIH0sIGZ1bmN0aW9uIChfcmVmKSB7XHJcbiAgICAgICAgdmFyIHQgPSBfcmVmLnQ7XHJcbiAgICAgICAgdmFyIHN0ZXBEYXRhID0gdHJhcGV6b2lkcy5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xyXG4gICAgICAgICAgdmFyIHByZXYgPSBwcmV2VHJhcGV6b2lkcyAmJiBwcmV2VHJhcGV6b2lkc1tpbmRleF07XHJcbiAgICAgICAgICBpZiAocHJldikge1xyXG4gICAgICAgICAgICB2YXIgX2ludGVycG9sYXRvclggPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikocHJldi54LCBlbnRyeS54KTtcclxuICAgICAgICAgICAgdmFyIF9pbnRlcnBvbGF0b3JZID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKHByZXYueSwgZW50cnkueSk7XHJcbiAgICAgICAgICAgIHZhciBfaW50ZXJwb2xhdG9yVXBwZXJXaWR0aCA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShwcmV2LnVwcGVyV2lkdGgsIGVudHJ5LnVwcGVyV2lkdGgpO1xyXG4gICAgICAgICAgICB2YXIgX2ludGVycG9sYXRvckxvd2VyV2lkdGggPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikocHJldi5sb3dlcldpZHRoLCBlbnRyeS5sb3dlcldpZHRoKTtcclxuICAgICAgICAgICAgdmFyIF9pbnRlcnBvbGF0b3JIZWlnaHQgPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikocHJldi5oZWlnaHQsIGVudHJ5LmhlaWdodCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcclxuICAgICAgICAgICAgICB4OiBfaW50ZXJwb2xhdG9yWCh0KSxcclxuICAgICAgICAgICAgICB5OiBfaW50ZXJwb2xhdG9yWSh0KSxcclxuICAgICAgICAgICAgICB1cHBlcldpZHRoOiBfaW50ZXJwb2xhdG9yVXBwZXJXaWR0aCh0KSxcclxuICAgICAgICAgICAgICBsb3dlcldpZHRoOiBfaW50ZXJwb2xhdG9yTG93ZXJXaWR0aCh0KSxcclxuICAgICAgICAgICAgICBoZWlnaHQ6IF9pbnRlcnBvbGF0b3JIZWlnaHQodClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgaW50ZXJwb2xhdG9yWCA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShlbnRyeS54ICsgZW50cnkudXBwZXJXaWR0aCAvIDIsIGVudHJ5LngpO1xyXG4gICAgICAgICAgdmFyIGludGVycG9sYXRvclkgPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikoZW50cnkueSArIGVudHJ5LmhlaWdodCAvIDIsIGVudHJ5LnkpO1xyXG4gICAgICAgICAgdmFyIGludGVycG9sYXRvclVwcGVyV2lkdGggPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikoMCwgZW50cnkudXBwZXJXaWR0aCk7XHJcbiAgICAgICAgICB2YXIgaW50ZXJwb2xhdG9yTG93ZXJXaWR0aCA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKSgwLCBlbnRyeS5sb3dlcldpZHRoKTtcclxuICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3JIZWlnaHQgPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikoMCwgZW50cnkuaGVpZ2h0KTtcclxuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcclxuICAgICAgICAgICAgeDogaW50ZXJwb2xhdG9yWCh0KSxcclxuICAgICAgICAgICAgeTogaW50ZXJwb2xhdG9yWSh0KSxcclxuICAgICAgICAgICAgdXBwZXJXaWR0aDogaW50ZXJwb2xhdG9yVXBwZXJXaWR0aCh0KSxcclxuICAgICAgICAgICAgbG93ZXJXaWR0aDogaW50ZXJwb2xhdG9yTG93ZXJXaWR0aCh0KSxcclxuICAgICAgICAgICAgaGVpZ2h0OiBpbnRlcnBvbGF0b3JIZWlnaHQodClcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwgbnVsbCwgX3RoaXMzLnJlbmRlclRyYXBlem9pZHNTdGF0aWNhbGx5KHN0ZXBEYXRhKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJUcmFwZXpvaWRzXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVHJhcGV6b2lkcygpIHtcclxuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgdHJhcGV6b2lkcyA9IF90aGlzJHByb3BzMy50cmFwZXpvaWRzLFxyXG4gICAgICAgIGlzQW5pbWF0aW9uQWN0aXZlID0gX3RoaXMkcHJvcHMzLmlzQW5pbWF0aW9uQWN0aXZlO1xyXG4gICAgICB2YXIgcHJldlRyYXBlem9pZHMgPSB0aGlzLnN0YXRlLnByZXZUcmFwZXpvaWRzO1xyXG4gICAgICBpZiAoaXNBbmltYXRpb25BY3RpdmUgJiYgdHJhcGV6b2lkcyAmJiB0cmFwZXpvaWRzLmxlbmd0aCAmJiAoIXByZXZUcmFwZXpvaWRzIHx8ICEoMCwgX2lzRXF1YWxbXCJkZWZhdWx0XCJdKShwcmV2VHJhcGV6b2lkcywgdHJhcGV6b2lkcykpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyVHJhcGV6b2lkc1dpdGhBbmltYXRpb24oKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJUcmFwZXpvaWRzU3RhdGljYWxseSh0cmFwZXpvaWRzKTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBoaWRlID0gX3RoaXMkcHJvcHM0LmhpZGUsXHJcbiAgICAgICAgdHJhcGV6b2lkcyA9IF90aGlzJHByb3BzNC50cmFwZXpvaWRzLFxyXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzNC5jbGFzc05hbWUsXHJcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wczQuaXNBbmltYXRpb25BY3RpdmU7XHJcbiAgICAgIHZhciBpc0FuaW1hdGlvbkZpbmlzaGVkID0gdGhpcy5zdGF0ZS5pc0FuaW1hdGlvbkZpbmlzaGVkO1xyXG4gICAgICBpZiAoaGlkZSB8fCAhdHJhcGV6b2lkcyB8fCAhdHJhcGV6b2lkcy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgbGF5ZXJDbGFzcyA9ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy10cmFwZXpvaWRzJywgY2xhc3NOYW1lKTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBsYXllckNsYXNzXHJcbiAgICAgIH0sIHRoaXMucmVuZGVyVHJhcGV6b2lkcygpLCAoIWlzQW5pbWF0aW9uQWN0aXZlIHx8IGlzQW5pbWF0aW9uRmluaXNoZWQpICYmIF9MYWJlbExpc3QuTGFiZWxMaXN0LnJlbmRlckNhbGxCeVBhcmVudCh0aGlzLnByb3BzLCB0cmFwZXpvaWRzKSk7XHJcbiAgICB9XHJcbiAgfV0sIFt7XHJcbiAgICBrZXk6IFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKSB7XHJcbiAgICAgIGlmIChuZXh0UHJvcHMuYW5pbWF0aW9uSWQgIT09IHByZXZTdGF0ZS5wcmV2QW5pbWF0aW9uSWQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgcHJldkFuaW1hdGlvbklkOiBuZXh0UHJvcHMuYW5pbWF0aW9uSWQsXHJcbiAgICAgICAgICBjdXJUcmFwZXpvaWRzOiBuZXh0UHJvcHMudHJhcGV6b2lkcyxcclxuICAgICAgICAgIHByZXZUcmFwZXpvaWRzOiBwcmV2U3RhdGUuY3VyVHJhcGV6b2lkc1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5leHRQcm9wcy50cmFwZXpvaWRzICE9PSBwcmV2U3RhdGUuY3VyVHJhcGV6b2lkcykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBjdXJUcmFwZXpvaWRzOiBuZXh0UHJvcHMudHJhcGV6b2lkc1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfV0pO1xyXG59KF9yZWFjdC5QdXJlQ29tcG9uZW50KTtcclxuX0Z1bm5lbCA9IEZ1bm5lbDtcclxuX2RlZmluZVByb3BlcnR5KEZ1bm5lbCwgXCJkaXNwbGF5TmFtZVwiLCAnRnVubmVsJyk7XHJcbl9kZWZpbmVQcm9wZXJ0eShGdW5uZWwsIFwiZGVmYXVsdFByb3BzXCIsIHtcclxuICBzdHJva2U6ICcjZmZmJyxcclxuICBmaWxsOiAnIzgwODA4MCcsXHJcbiAgbGVnZW5kVHlwZTogJ3JlY3QnLFxyXG4gIGxhYmVsTGluZTogdHJ1ZSxcclxuICBoaWRlOiBmYWxzZSxcclxuICBpc0FuaW1hdGlvbkFjdGl2ZTogIV9HbG9iYWwuR2xvYmFsLmlzU3NyLFxyXG4gIGFuaW1hdGlvbkJlZ2luOiA0MDAsXHJcbiAgYW5pbWF0aW9uRHVyYXRpb246IDE1MDAsXHJcbiAgYW5pbWF0aW9uRWFzaW5nOiAnZWFzZScsXHJcbiAgbmFtZUtleTogJ25hbWUnLFxyXG4gIGxhc3RTaGFwZVR5cGU6ICd0cmlhbmdsZSdcclxufSk7XHJcbl9kZWZpbmVQcm9wZXJ0eShGdW5uZWwsIFwiZ2V0UmVhbEZ1bm5lbERhdGFcIiwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICB2YXIgX2l0ZW0kcHJvcHMgPSBpdGVtLnByb3BzLFxyXG4gICAgZGF0YSA9IF9pdGVtJHByb3BzLmRhdGEsXHJcbiAgICBjaGlsZHJlbiA9IF9pdGVtJHByb3BzLmNoaWxkcmVuO1xyXG4gIHZhciBwcmVzZW50YXRpb25Qcm9wcyA9ICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykoaXRlbS5wcm9wcywgZmFsc2UpO1xyXG4gIHZhciBjZWxscyA9ICgwLCBfUmVhY3RVdGlscy5maW5kQWxsQnlUeXBlKShjaGlsZHJlbiwgX0NlbGwuQ2VsbCk7XHJcbiAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGgpIHtcclxuICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XHJcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XHJcbiAgICAgICAgcGF5bG9hZDogZW50cnlcclxuICAgICAgfSwgcHJlc2VudGF0aW9uUHJvcHMpLCBlbnRyeSksIGNlbGxzICYmIGNlbGxzW2luZGV4XSAmJiBjZWxsc1tpbmRleF0ucHJvcHMpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGlmIChjZWxscyAmJiBjZWxscy5sZW5ndGgpIHtcclxuICAgIHJldHVybiBjZWxscy5tYXAoZnVuY3Rpb24gKGNlbGwpIHtcclxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJlc2VudGF0aW9uUHJvcHMpLCBjZWxsLnByb3BzKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gW107XHJcbn0pO1xyXG5fZGVmaW5lUHJvcGVydHkoRnVubmVsLCBcImdldFJlYWxXaWR0aEhlaWdodFwiLCBmdW5jdGlvbiAoaXRlbSwgb2Zmc2V0KSB7XHJcbiAgdmFyIGN1c3RvbVdpZHRoID0gaXRlbS5wcm9wcy53aWR0aDtcclxuICB2YXIgd2lkdGggPSBvZmZzZXQud2lkdGgsXHJcbiAgICBoZWlnaHQgPSBvZmZzZXQuaGVpZ2h0LFxyXG4gICAgbGVmdCA9IG9mZnNldC5sZWZ0LFxyXG4gICAgcmlnaHQgPSBvZmZzZXQucmlnaHQsXHJcbiAgICB0b3AgPSBvZmZzZXQudG9wLFxyXG4gICAgYm90dG9tID0gb2Zmc2V0LmJvdHRvbTtcclxuICB2YXIgcmVhbEhlaWdodCA9IGhlaWdodDtcclxuICB2YXIgcmVhbFdpZHRoID0gd2lkdGg7XHJcbiAgaWYgKCgwLCBfaXNOdW1iZXJbXCJkZWZhdWx0XCJdKShjdXN0b21XaWR0aCkpIHtcclxuICAgIHJlYWxXaWR0aCA9IGN1c3RvbVdpZHRoO1xyXG4gIH0gZWxzZSBpZiAoKDAsIF9pc1N0cmluZ1tcImRlZmF1bHRcIl0pKGN1c3RvbVdpZHRoKSkge1xyXG4gICAgcmVhbFdpZHRoID0gcmVhbFdpZHRoICogcGFyc2VGbG9hdChjdXN0b21XaWR0aCkgLyAxMDA7XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICByZWFsV2lkdGg6IHJlYWxXaWR0aCAtIGxlZnQgLSByaWdodCAtIDUwLFxyXG4gICAgcmVhbEhlaWdodDogcmVhbEhlaWdodCAtIGJvdHRvbSAtIHRvcCxcclxuICAgIG9mZnNldFg6ICh3aWR0aCAtIHJlYWxXaWR0aCkgLyAyLFxyXG4gICAgb2Zmc2V0WTogKGhlaWdodCAtIHJlYWxIZWlnaHQpIC8gMlxyXG4gIH07XHJcbn0pO1xyXG5fZGVmaW5lUHJvcGVydHkoRnVubmVsLCBcImdldENvbXBvc2VkRGF0YVwiLCBmdW5jdGlvbiAoX3JlZjIpIHtcclxuICB2YXIgaXRlbSA9IF9yZWYyLml0ZW0sXHJcbiAgICBvZmZzZXQgPSBfcmVmMi5vZmZzZXQ7XHJcbiAgdmFyIGZ1bm5lbERhdGEgPSBfRnVubmVsLmdldFJlYWxGdW5uZWxEYXRhKGl0ZW0pO1xyXG4gIHZhciBfaXRlbSRwcm9wczIgPSBpdGVtLnByb3BzLFxyXG4gICAgZGF0YUtleSA9IF9pdGVtJHByb3BzMi5kYXRhS2V5LFxyXG4gICAgbmFtZUtleSA9IF9pdGVtJHByb3BzMi5uYW1lS2V5LFxyXG4gICAgdG9vbHRpcFR5cGUgPSBfaXRlbSRwcm9wczIudG9vbHRpcFR5cGUsXHJcbiAgICBsYXN0U2hhcGVUeXBlID0gX2l0ZW0kcHJvcHMyLmxhc3RTaGFwZVR5cGUsXHJcbiAgICByZXZlcnNlZCA9IF9pdGVtJHByb3BzMi5yZXZlcnNlZDtcclxuICB2YXIgbGVmdCA9IG9mZnNldC5sZWZ0LFxyXG4gICAgdG9wID0gb2Zmc2V0LnRvcDtcclxuICB2YXIgX0Z1bm5lbCRnZXRSZWFsV2lkdGhIID0gX0Z1bm5lbC5nZXRSZWFsV2lkdGhIZWlnaHQoaXRlbSwgb2Zmc2V0KSxcclxuICAgIHJlYWxIZWlnaHQgPSBfRnVubmVsJGdldFJlYWxXaWR0aEgucmVhbEhlaWdodCxcclxuICAgIHJlYWxXaWR0aCA9IF9GdW5uZWwkZ2V0UmVhbFdpZHRoSC5yZWFsV2lkdGgsXHJcbiAgICBvZmZzZXRYID0gX0Z1bm5lbCRnZXRSZWFsV2lkdGhILm9mZnNldFgsXHJcbiAgICBvZmZzZXRZID0gX0Z1bm5lbCRnZXRSZWFsV2lkdGhILm9mZnNldFk7XHJcbiAgdmFyIG1heFZhbHVlID0gTWF0aC5tYXguYXBwbHkobnVsbCwgZnVubmVsRGF0YS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICByZXR1cm4gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShlbnRyeSwgZGF0YUtleSwgMCk7XHJcbiAgfSkpO1xyXG4gIHZhciBsZW4gPSBmdW5uZWxEYXRhLmxlbmd0aDtcclxuICB2YXIgcm93SGVpZ2h0ID0gcmVhbEhlaWdodCAvIGxlbjtcclxuICB2YXIgcGFyZW50Vmlld0JveCA9IHtcclxuICAgIHg6IG9mZnNldC5sZWZ0LFxyXG4gICAgeTogb2Zmc2V0LnRvcCxcclxuICAgIHdpZHRoOiBvZmZzZXQud2lkdGgsXHJcbiAgICBoZWlnaHQ6IG9mZnNldC5oZWlnaHRcclxuICB9O1xyXG4gIHZhciB0cmFwZXpvaWRzID0gZnVubmVsRGF0YS5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpKSB7XHJcbiAgICB2YXIgcmF3VmFsID0gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShlbnRyeSwgZGF0YUtleSwgMCk7XHJcbiAgICB2YXIgbmFtZSA9ICgwLCBfQ2hhcnRVdGlscy5nZXRWYWx1ZUJ5RGF0YUtleSkoZW50cnksIG5hbWVLZXksIGkpO1xyXG4gICAgdmFyIHZhbCA9IHJhd1ZhbDtcclxuICAgIHZhciBuZXh0VmFsO1xyXG4gICAgaWYgKGkgIT09IGxlbiAtIDEpIHtcclxuICAgICAgbmV4dFZhbCA9ICgwLCBfQ2hhcnRVdGlscy5nZXRWYWx1ZUJ5RGF0YUtleSkoZnVubmVsRGF0YVtpICsgMV0sIGRhdGFLZXksIDApO1xyXG4gICAgICBpZiAobmV4dFZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgdmFyIF9uZXh0VmFsID0gbmV4dFZhbDtcclxuICAgICAgICB2YXIgX25leHRWYWwyID0gX3NsaWNlZFRvQXJyYXkoX25leHRWYWwsIDEpO1xyXG4gICAgICAgIG5leHRWYWwgPSBfbmV4dFZhbDJbMF07XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAocmF3VmFsIGluc3RhbmNlb2YgQXJyYXkgJiYgcmF3VmFsLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICB2YXIgX3Jhd1ZhbCA9IF9zbGljZWRUb0FycmF5KHJhd1ZhbCwgMik7XHJcbiAgICAgIHZhbCA9IF9yYXdWYWxbMF07XHJcbiAgICAgIG5leHRWYWwgPSBfcmF3VmFsWzFdO1xyXG4gICAgfSBlbHNlIGlmIChsYXN0U2hhcGVUeXBlID09PSAncmVjdGFuZ2xlJykge1xyXG4gICAgICBuZXh0VmFsID0gdmFsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbmV4dFZhbCA9IDA7XHJcbiAgICB9XHJcbiAgICB2YXIgeCA9IChtYXhWYWx1ZSAtIHZhbCkgKiByZWFsV2lkdGggLyAoMiAqIG1heFZhbHVlKSArIHRvcCArIDI1ICsgb2Zmc2V0WDtcclxuICAgIHZhciB5ID0gcm93SGVpZ2h0ICogaSArIGxlZnQgKyBvZmZzZXRZO1xyXG4gICAgdmFyIHVwcGVyV2lkdGggPSB2YWwgLyBtYXhWYWx1ZSAqIHJlYWxXaWR0aDtcclxuICAgIHZhciBsb3dlcldpZHRoID0gbmV4dFZhbCAvIG1heFZhbHVlICogcmVhbFdpZHRoO1xyXG4gICAgdmFyIHRvb2x0aXBQYXlsb2FkID0gW3tcclxuICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgdmFsdWU6IHZhbCxcclxuICAgICAgcGF5bG9hZDogZW50cnksXHJcbiAgICAgIGRhdGFLZXk6IGRhdGFLZXksXHJcbiAgICAgIHR5cGU6IHRvb2x0aXBUeXBlXHJcbiAgICB9XTtcclxuICAgIHZhciB0b29sdGlwUG9zaXRpb24gPSB7XHJcbiAgICAgIHg6IHggKyB1cHBlcldpZHRoIC8gMixcclxuICAgICAgeTogeSArIHJvd0hlaWdodCAvIDJcclxuICAgIH07XHJcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcclxuICAgICAgeDogeCxcclxuICAgICAgeTogeSxcclxuICAgICAgd2lkdGg6IE1hdGgubWF4KHVwcGVyV2lkdGgsIGxvd2VyV2lkdGgpLFxyXG4gICAgICB1cHBlcldpZHRoOiB1cHBlcldpZHRoLFxyXG4gICAgICBsb3dlcldpZHRoOiBsb3dlcldpZHRoLFxyXG4gICAgICBoZWlnaHQ6IHJvd0hlaWdodCxcclxuICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgdmFsOiB2YWwsXHJcbiAgICAgIHRvb2x0aXBQYXlsb2FkOiB0b29sdGlwUGF5bG9hZCxcclxuICAgICAgdG9vbHRpcFBvc2l0aW9uOiB0b29sdGlwUG9zaXRpb25cclxuICAgIH0sICgwLCBfb21pdFtcImRlZmF1bHRcIl0pKGVudHJ5LCAnd2lkdGgnKSksIHt9LCB7XHJcbiAgICAgIHBheWxvYWQ6IGVudHJ5LFxyXG4gICAgICBwYXJlbnRWaWV3Qm94OiBwYXJlbnRWaWV3Qm94LFxyXG4gICAgICBsYWJlbFZpZXdCb3g6IHtcclxuICAgICAgICB4OiB4ICsgKHVwcGVyV2lkdGggLSBsb3dlcldpZHRoKSAvIDQsXHJcbiAgICAgICAgeTogeSxcclxuICAgICAgICB3aWR0aDogTWF0aC5hYnModXBwZXJXaWR0aCAtIGxvd2VyV2lkdGgpIC8gMiArIE1hdGgubWluKHVwcGVyV2lkdGgsIGxvd2VyV2lkdGgpLFxyXG4gICAgICAgIGhlaWdodDogcm93SGVpZ2h0XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIGlmIChyZXZlcnNlZCkge1xyXG4gICAgdHJhcGV6b2lkcyA9IHRyYXBlem9pZHMubWFwKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHtcclxuICAgICAgdmFyIG5ld1kgPSBlbnRyeS55IC0gaW5kZXggKiByb3dIZWlnaHQgKyAobGVuIC0gMSAtIGluZGV4KSAqIHJvd0hlaWdodDtcclxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xyXG4gICAgICAgIHVwcGVyV2lkdGg6IGVudHJ5Lmxvd2VyV2lkdGgsXHJcbiAgICAgICAgbG93ZXJXaWR0aDogZW50cnkudXBwZXJXaWR0aCxcclxuICAgICAgICB4OiBlbnRyeS54IC0gKGVudHJ5Lmxvd2VyV2lkdGggLSBlbnRyeS51cHBlcldpZHRoKSAvIDIsXHJcbiAgICAgICAgeTogZW50cnkueSAtIGluZGV4ICogcm93SGVpZ2h0ICsgKGxlbiAtIDEgLSBpbmRleCkgKiByb3dIZWlnaHQsXHJcbiAgICAgICAgdG9vbHRpcFBvc2l0aW9uOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5LnRvb2x0aXBQb3NpdGlvbiksIHt9LCB7XHJcbiAgICAgICAgICB5OiBuZXdZICsgcm93SGVpZ2h0IC8gMlxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGxhYmVsVmlld0JveDogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeS5sYWJlbFZpZXdCb3gpLCB7fSwge1xyXG4gICAgICAgICAgeTogbmV3WVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICB0cmFwZXpvaWRzOiB0cmFwZXpvaWRzLFxyXG4gICAgZGF0YTogZnVubmVsRGF0YVxyXG4gIH07XHJcbn0pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkZ1bm5lbCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9yZWFjdFNtb290aCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfaXNGdW5jdGlvbiIsIl9pc051bWJlciIsIl9pc1N0cmluZyIsIl9vbWl0IiwiX2lzRXF1YWwiLCJfY2xzeCIsIl9MYXllciIsIl9MYWJlbExpc3QiLCJfQ2VsbCIsIl9SZWFjdFV0aWxzIiwiX0dsb2JhbCIsIl9EYXRhVXRpbHMiLCJfQ2hhcnRVdGlscyIsIl90eXBlcyIsIl9GdW5uZWxVdGlscyIsIl9GdW5uZWwiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiVHlwZUVycm9yIiwibyIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwibGVuIiwibGVuZ3RoIiwiYXJyMiIsImwiLCJTeW1ib2wiLCJpdGVyYXRvciIsImYiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJpc0FycmF5IiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiYXJndW1lbnRzIiwic291cmNlIiwia2V5IiwiYXBwbHkiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImVudW1lcmFibGUiLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9Qcm9wZXJ0eUtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsInAiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsIl9QdXJlQ29tcG9uZW50IiwiX3RoaXMiLCJfbGVuIiwiYXJncyIsIl9rZXkiLCJjb25jYXQiLCJpc0FuaW1hdGlvbkZpbmlzaGVkIiwib25BbmltYXRpb25FbmQiLCJzZXRTdGF0ZSIsIm9uQW5pbWF0aW9uU3RhcnQiLCJpc0FjdGl2ZUluZGV4IiwiYWN0aXZlSW5kZXgiLCJpbmRleE9mIiwicmVuZGVyVHJhcGV6b2lkc1N0YXRpY2FsbHkiLCJ0cmFwZXpvaWRzIiwiX3RoaXMyIiwiX3RoaXMkcHJvcHMiLCJzaGFwZSIsImFjdGl2ZVNoYXBlIiwibWFwIiwiZW50cnkiLCJ0cmFwZXpvaWRPcHRpb25zIiwidHJhcGV6b2lkUHJvcHMiLCJpc0FjdGl2ZSIsInN0cm9rZSIsImNyZWF0ZUVsZW1lbnQiLCJMYXllciIsImNsYXNzTmFtZSIsImFkYXB0RXZlbnRzT2ZDaGlsZCIsIngiLCJ5Iiwicm9sZSIsIkZ1bm5lbFRyYXBlem9pZCIsIm9wdGlvbiIsInJlbmRlclRyYXBlem9pZHNXaXRoQW5pbWF0aW9uIiwiX3RoaXMzIiwiX3RoaXMkcHJvcHMyIiwiaXNBbmltYXRpb25BY3RpdmUiLCJhbmltYXRpb25CZWdpbiIsImFuaW1hdGlvbkR1cmF0aW9uIiwiYW5pbWF0aW9uRWFzaW5nIiwiYW5pbWF0aW9uSWQiLCJwcmV2VHJhcGV6b2lkcyIsInN0YXRlIiwiYmVnaW4iLCJkdXJhdGlvbiIsImVhc2luZyIsInRvIiwiaGFuZGxlQW5pbWF0aW9uU3RhcnQiLCJoYW5kbGVBbmltYXRpb25FbmQiLCJfcmVmIiwic3RlcERhdGEiLCJpbmRleCIsInByZXYiLCJfaW50ZXJwb2xhdG9yWCIsImludGVycG9sYXRlTnVtYmVyIiwiX2ludGVycG9sYXRvclkiLCJfaW50ZXJwb2xhdG9yVXBwZXJXaWR0aCIsInVwcGVyV2lkdGgiLCJfaW50ZXJwb2xhdG9yTG93ZXJXaWR0aCIsImxvd2VyV2lkdGgiLCJfaW50ZXJwb2xhdG9ySGVpZ2h0IiwiaGVpZ2h0IiwiaW50ZXJwb2xhdG9yWCIsImludGVycG9sYXRvclkiLCJpbnRlcnBvbGF0b3JVcHBlcldpZHRoIiwiaW50ZXJwb2xhdG9yTG93ZXJXaWR0aCIsImludGVycG9sYXRvckhlaWdodCIsInJlbmRlclRyYXBlem9pZHMiLCJfdGhpcyRwcm9wczMiLCJyZW5kZXIiLCJfdGhpcyRwcm9wczQiLCJoaWRlIiwibGF5ZXJDbGFzcyIsIkxhYmVsTGlzdCIsInJlbmRlckNhbGxCeVBhcmVudCIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIm5leHRQcm9wcyIsInByZXZTdGF0ZSIsInByZXZBbmltYXRpb25JZCIsImN1clRyYXBlem9pZHMiLCJQdXJlQ29tcG9uZW50IiwiZmlsbCIsImxlZ2VuZFR5cGUiLCJsYWJlbExpbmUiLCJHbG9iYWwiLCJpc1NzciIsIm5hbWVLZXkiLCJsYXN0U2hhcGVUeXBlIiwiaXRlbSIsIl9pdGVtJHByb3BzIiwiZGF0YSIsImNoaWxkcmVuIiwicHJlc2VudGF0aW9uUHJvcHMiLCJmaWx0ZXJQcm9wcyIsImNlbGxzIiwiZmluZEFsbEJ5VHlwZSIsIkNlbGwiLCJwYXlsb2FkIiwiY2VsbCIsIm9mZnNldCIsImN1c3RvbVdpZHRoIiwid2lkdGgiLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJyZWFsSGVpZ2h0IiwicmVhbFdpZHRoIiwicGFyc2VGbG9hdCIsIm9mZnNldFgiLCJvZmZzZXRZIiwiX3JlZjIiLCJmdW5uZWxEYXRhIiwiZ2V0UmVhbEZ1bm5lbERhdGEiLCJfaXRlbSRwcm9wczIiLCJkYXRhS2V5IiwidG9vbHRpcFR5cGUiLCJyZXZlcnNlZCIsIl9GdW5uZWwkZ2V0UmVhbFdpZHRoSCIsImdldFJlYWxXaWR0aEhlaWdodCIsIm1heFZhbHVlIiwiTWF0aCIsIm1heCIsImdldFZhbHVlQnlEYXRhS2V5Iiwicm93SGVpZ2h0IiwicGFyZW50Vmlld0JveCIsInJhd1ZhbCIsInZhbCIsIm5leHRWYWwiLCJfbmV4dFZhbCIsIl9uZXh0VmFsMiIsIl9yYXdWYWwiLCJ0b29sdGlwUGF5bG9hZCIsInR5cGUiLCJ0b29sdGlwUG9zaXRpb24iLCJsYWJlbFZpZXdCb3giLCJhYnMiLCJtaW4iLCJuZXdZIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/numberAxis/Funnel.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/polar/Pie.js":
/*!************************************************!*\
  !*** ./node_modules/recharts/lib/polar/Pie.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Pie = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _get = _interopRequireDefault(__webpack_require__(/*! lodash/get */ \"lodash/get\"));\nvar _isEqual = _interopRequireDefault(__webpack_require__(/*! lodash/isEqual */ \"lodash/isEqual\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _Curve = __webpack_require__(/*! ../shape/Curve */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Curve.js\");\nvar _Text = __webpack_require__(/*! ../component/Text */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Text.js\");\nvar _Label = __webpack_require__(/*! ../component/Label */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Label.js\");\nvar _LabelList = __webpack_require__(/*! ../component/LabelList */ \"(pages-dir-node)/./node_modules/recharts/lib/component/LabelList.js\");\nvar _Cell = __webpack_require__(/*! ../component/Cell */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Cell.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"(pages-dir-node)/./node_modules/recharts/lib/util/Global.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _LogUtils = __webpack_require__(/*! ../util/LogUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/LogUtils.js\");\nvar _types = __webpack_require__(/*! ../util/types */ \"(pages-dir-node)/./node_modules/recharts/lib/util/types.js\");\nvar _ActiveShapeUtils = __webpack_require__(/*! ../util/ActiveShapeUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ActiveShapeUtils.js\");\nvar _Pie;\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Render sectors of a pie\r\n */ \nvar Pie = exports.Pie = /*#__PURE__*/ function(_PureComponent) {\n    function Pie(props) {\n        var _this;\n        _classCallCheck(this, Pie);\n        _this = _callSuper(this, Pie, [\n            props\n        ]);\n        _defineProperty(_this, \"pieRef\", null);\n        _defineProperty(_this, \"sectorRefs\", []);\n        _defineProperty(_this, \"id\", (0, _DataUtils.uniqueId)('recharts-pie-'));\n        _defineProperty(_this, \"handleAnimationEnd\", function() {\n            var onAnimationEnd = _this.props.onAnimationEnd;\n            _this.setState({\n                isAnimationFinished: true\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationEnd)) {\n                onAnimationEnd();\n            }\n        });\n        _defineProperty(_this, \"handleAnimationStart\", function() {\n            var onAnimationStart = _this.props.onAnimationStart;\n            _this.setState({\n                isAnimationFinished: false\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationStart)) {\n                onAnimationStart();\n            }\n        });\n        _this.state = {\n            isAnimationFinished: !props.isAnimationActive,\n            prevIsAnimationActive: props.isAnimationActive,\n            prevAnimationId: props.animationId,\n            sectorToFocus: 0\n        };\n        return _this;\n    }\n    _inherits(Pie, _PureComponent);\n    return _createClass(Pie, [\n        {\n            key: \"isActiveIndex\",\n            value: function isActiveIndex(i) {\n                var activeIndex = this.props.activeIndex;\n                if (Array.isArray(activeIndex)) {\n                    return activeIndex.indexOf(i) !== -1;\n                }\n                return i === activeIndex;\n            }\n        },\n        {\n            key: \"hasActiveIndex\",\n            value: function hasActiveIndex() {\n                var activeIndex = this.props.activeIndex;\n                return Array.isArray(activeIndex) ? activeIndex.length !== 0 : activeIndex || activeIndex === 0;\n            }\n        },\n        {\n            key: \"renderLabels\",\n            value: function renderLabels(sectors) {\n                var isAnimationActive = this.props.isAnimationActive;\n                if (isAnimationActive && !this.state.isAnimationFinished) {\n                    return null;\n                }\n                var _this$props = this.props, label = _this$props.label, labelLine = _this$props.labelLine, dataKey = _this$props.dataKey, valueKey = _this$props.valueKey;\n                var pieProps = (0, _ReactUtils.filterProps)(this.props, false);\n                var customLabelProps = (0, _ReactUtils.filterProps)(label, false);\n                var customLabelLineProps = (0, _ReactUtils.filterProps)(labelLine, false);\n                var offsetRadius = label && label.offsetRadius || 20;\n                var labels = sectors.map(function(entry, i) {\n                    var midAngle = (entry.startAngle + entry.endAngle) / 2;\n                    var endPoint = (0, _PolarUtils.polarToCartesian)(entry.cx, entry.cy, entry.outerRadius + offsetRadius, midAngle);\n                    var labelProps = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, pieProps), entry), {}, {\n                        stroke: 'none'\n                    }, customLabelProps), {}, {\n                        index: i,\n                        textAnchor: Pie.getTextAnchor(endPoint.x, entry.cx)\n                    }, endPoint);\n                    var lineProps = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, pieProps), entry), {}, {\n                        fill: 'none',\n                        stroke: entry.fill\n                    }, customLabelLineProps), {}, {\n                        index: i,\n                        points: [\n                            (0, _PolarUtils.polarToCartesian)(entry.cx, entry.cy, entry.outerRadius, midAngle),\n                            endPoint\n                        ]\n                    });\n                    var realDataKey = dataKey;\n                    // TODO: compatible to lower versions\n                    if ((0, _isNil[\"default\"])(dataKey) && (0, _isNil[\"default\"])(valueKey)) {\n                        realDataKey = 'value';\n                    } else if ((0, _isNil[\"default\"])(dataKey)) {\n                        realDataKey = valueKey;\n                    }\n                    return(/*#__PURE__*/ // eslint-disable-next-line react/no-array-index-key\n                    _react[\"default\"].createElement(_Layer.Layer, {\n                        key: \"label-\".concat(entry.startAngle, \"-\").concat(entry.endAngle, \"-\").concat(entry.midAngle, \"-\").concat(i)\n                    }, labelLine && Pie.renderLabelLineItem(labelLine, lineProps, 'line'), Pie.renderLabelItem(label, labelProps, (0, _ChartUtils.getValueByDataKey)(entry, realDataKey))));\n                });\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-pie-labels\"\n                }, labels);\n            }\n        },\n        {\n            key: \"renderSectorsStatically\",\n            value: function renderSectorsStatically(sectors) {\n                var _this2 = this;\n                var _this$props2 = this.props, activeShape = _this$props2.activeShape, blendStroke = _this$props2.blendStroke, inactiveShapeProp = _this$props2.inactiveShape;\n                return sectors.map(function(entry, i) {\n                    if ((entry === null || entry === void 0 ? void 0 : entry.startAngle) === 0 && (entry === null || entry === void 0 ? void 0 : entry.endAngle) === 0 && sectors.length !== 1) return null;\n                    var isActive = _this2.isActiveIndex(i);\n                    var inactiveShape = inactiveShapeProp && _this2.hasActiveIndex() ? inactiveShapeProp : null;\n                    var sectorOptions = isActive ? activeShape : inactiveShape;\n                    var sectorProps = _objectSpread(_objectSpread({}, entry), {}, {\n                        stroke: blendStroke ? entry.fill : entry.stroke,\n                        tabIndex: -1\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                        ref: function ref(_ref) {\n                            if (_ref && !_this2.sectorRefs.includes(_ref)) {\n                                _this2.sectorRefs.push(_ref);\n                            }\n                        },\n                        tabIndex: -1,\n                        className: \"recharts-pie-sector\"\n                    }, (0, _types.adaptEventsOfChild)(_this2.props, entry, i), {\n                        // eslint-disable-next-line react/no-array-index-key\n                        key: \"sector-\".concat(entry === null || entry === void 0 ? void 0 : entry.startAngle, \"-\").concat(entry === null || entry === void 0 ? void 0 : entry.endAngle, \"-\").concat(entry.midAngle, \"-\").concat(i)\n                    }), /*#__PURE__*/ _react[\"default\"].createElement(_ActiveShapeUtils.Shape, _extends({\n                        option: sectorOptions,\n                        isActive: isActive,\n                        shapeType: \"sector\"\n                    }, sectorProps)));\n                });\n            }\n        },\n        {\n            key: \"renderSectorsWithAnimation\",\n            value: function renderSectorsWithAnimation() {\n                var _this3 = this;\n                var _this$props3 = this.props, sectors = _this$props3.sectors, isAnimationActive = _this$props3.isAnimationActive, animationBegin = _this$props3.animationBegin, animationDuration = _this$props3.animationDuration, animationEasing = _this$props3.animationEasing, animationId = _this$props3.animationId;\n                var _this$state = this.state, prevSectors = _this$state.prevSectors, prevIsAnimationActive = _this$state.prevIsAnimationActive;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n                    begin: animationBegin,\n                    duration: animationDuration,\n                    isActive: isAnimationActive,\n                    easing: animationEasing,\n                    from: {\n                        t: 0\n                    },\n                    to: {\n                        t: 1\n                    },\n                    key: \"pie-\".concat(animationId, \"-\").concat(prevIsAnimationActive),\n                    onAnimationStart: this.handleAnimationStart,\n                    onAnimationEnd: this.handleAnimationEnd\n                }, function(_ref2) {\n                    var t = _ref2.t;\n                    var stepData = [];\n                    var first = sectors && sectors[0];\n                    var curAngle = first.startAngle;\n                    sectors.forEach(function(entry, index) {\n                        var prev = prevSectors && prevSectors[index];\n                        var paddingAngle = index > 0 ? (0, _get[\"default\"])(entry, 'paddingAngle', 0) : 0;\n                        if (prev) {\n                            var angleIp = (0, _DataUtils.interpolateNumber)(prev.endAngle - prev.startAngle, entry.endAngle - entry.startAngle);\n                            var latest = _objectSpread(_objectSpread({}, entry), {}, {\n                                startAngle: curAngle + paddingAngle,\n                                endAngle: curAngle + angleIp(t) + paddingAngle\n                            });\n                            stepData.push(latest);\n                            curAngle = latest.endAngle;\n                        } else {\n                            var endAngle = entry.endAngle, startAngle = entry.startAngle;\n                            var interpolatorAngle = (0, _DataUtils.interpolateNumber)(0, endAngle - startAngle);\n                            var deltaAngle = interpolatorAngle(t);\n                            var _latest = _objectSpread(_objectSpread({}, entry), {}, {\n                                startAngle: curAngle + paddingAngle,\n                                endAngle: curAngle + deltaAngle + paddingAngle\n                            });\n                            stepData.push(_latest);\n                            curAngle = _latest.endAngle;\n                        }\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, null, _this3.renderSectorsStatically(stepData));\n                });\n            }\n        },\n        {\n            key: \"attachKeyboardHandlers\",\n            value: function attachKeyboardHandlers(pieRef) {\n                var _this4 = this;\n                // eslint-disable-next-line no-param-reassign\n                pieRef.onkeydown = function(e) {\n                    if (!e.altKey) {\n                        switch(e.key){\n                            case 'ArrowLeft':\n                                {\n                                    var next = ++_this4.state.sectorToFocus % _this4.sectorRefs.length;\n                                    _this4.sectorRefs[next].focus();\n                                    _this4.setState({\n                                        sectorToFocus: next\n                                    });\n                                    break;\n                                }\n                            case 'ArrowRight':\n                                {\n                                    var _next = --_this4.state.sectorToFocus < 0 ? _this4.sectorRefs.length - 1 : _this4.state.sectorToFocus % _this4.sectorRefs.length;\n                                    _this4.sectorRefs[_next].focus();\n                                    _this4.setState({\n                                        sectorToFocus: _next\n                                    });\n                                    break;\n                                }\n                            case 'Escape':\n                                {\n                                    _this4.sectorRefs[_this4.state.sectorToFocus].blur();\n                                    _this4.setState({\n                                        sectorToFocus: 0\n                                    });\n                                    break;\n                                }\n                            default:\n                                {\n                                // There is nothing to do here\n                                }\n                        }\n                    }\n                };\n            }\n        },\n        {\n            key: \"renderSectors\",\n            value: function renderSectors() {\n                var _this$props4 = this.props, sectors = _this$props4.sectors, isAnimationActive = _this$props4.isAnimationActive;\n                var prevSectors = this.state.prevSectors;\n                if (isAnimationActive && sectors && sectors.length && (!prevSectors || !(0, _isEqual[\"default\"])(prevSectors, sectors))) {\n                    return this.renderSectorsWithAnimation();\n                }\n                return this.renderSectorsStatically(sectors);\n            }\n        },\n        {\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n                if (this.pieRef) {\n                    this.attachKeyboardHandlers(this.pieRef);\n                }\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this5 = this;\n                var _this$props5 = this.props, hide = _this$props5.hide, sectors = _this$props5.sectors, className = _this$props5.className, label = _this$props5.label, cx = _this$props5.cx, cy = _this$props5.cy, innerRadius = _this$props5.innerRadius, outerRadius = _this$props5.outerRadius, isAnimationActive = _this$props5.isAnimationActive;\n                var isAnimationFinished = this.state.isAnimationFinished;\n                if (hide || !sectors || !sectors.length || !(0, _DataUtils.isNumber)(cx) || !(0, _DataUtils.isNumber)(cy) || !(0, _DataUtils.isNumber)(innerRadius) || !(0, _DataUtils.isNumber)(outerRadius)) {\n                    return null;\n                }\n                var layerClass = (0, _clsx[\"default\"])('recharts-pie', className);\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    tabIndex: this.props.rootTabIndex,\n                    className: layerClass,\n                    ref: function ref(_ref3) {\n                        _this5.pieRef = _ref3;\n                    }\n                }, this.renderSectors(), label && this.renderLabels(sectors), _Label.Label.renderCallByParent(this.props, null, false), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, sectors, false));\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                if (prevState.prevIsAnimationActive !== nextProps.isAnimationActive) {\n                    return {\n                        prevIsAnimationActive: nextProps.isAnimationActive,\n                        prevAnimationId: nextProps.animationId,\n                        curSectors: nextProps.sectors,\n                        prevSectors: [],\n                        isAnimationFinished: true\n                    };\n                }\n                if (nextProps.isAnimationActive && nextProps.animationId !== prevState.prevAnimationId) {\n                    return {\n                        prevAnimationId: nextProps.animationId,\n                        curSectors: nextProps.sectors,\n                        prevSectors: prevState.curSectors,\n                        isAnimationFinished: true\n                    };\n                }\n                if (nextProps.sectors !== prevState.curSectors) {\n                    return {\n                        curSectors: nextProps.sectors,\n                        isAnimationFinished: true\n                    };\n                }\n                return null;\n            }\n        },\n        {\n            key: \"getTextAnchor\",\n            value: function getTextAnchor(x, cx) {\n                if (x > cx) {\n                    return 'start';\n                }\n                if (x < cx) {\n                    return 'end';\n                }\n                return 'middle';\n            }\n        },\n        {\n            key: \"renderLabelLineItem\",\n            value: function renderLabelLineItem(option, props, key) {\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n                    return /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n                }\n                if ((0, _isFunction[\"default\"])(option)) {\n                    return option(props);\n                }\n                var className = (0, _clsx[\"default\"])('recharts-pie-label-line', typeof option !== 'boolean' ? option.className : '');\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Curve.Curve, _extends({}, props, {\n                    key: key,\n                    type: \"linear\",\n                    className: className\n                }));\n            }\n        },\n        {\n            key: \"renderLabelItem\",\n            value: function renderLabelItem(option, props, value) {\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n                    return /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n                }\n                var label = value;\n                if ((0, _isFunction[\"default\"])(option)) {\n                    label = option(props);\n                    if (/*#__PURE__*/ _react[\"default\"].isValidElement(label)) {\n                        return label;\n                    }\n                }\n                var className = (0, _clsx[\"default\"])('recharts-pie-label-text', typeof option !== 'boolean' && !(0, _isFunction[\"default\"])(option) ? option.className : '');\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Text.Text, _extends({}, props, {\n                    alignmentBaseline: \"middle\",\n                    className: className\n                }), label);\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_Pie = Pie;\n_defineProperty(Pie, \"displayName\", 'Pie');\n_defineProperty(Pie, \"defaultProps\", {\n    stroke: '#fff',\n    fill: '#808080',\n    legendType: 'rect',\n    cx: '50%',\n    cy: '50%',\n    startAngle: 0,\n    endAngle: 360,\n    innerRadius: 0,\n    outerRadius: '80%',\n    paddingAngle: 0,\n    labelLine: true,\n    hide: false,\n    minAngle: 0,\n    isAnimationActive: !_Global.Global.isSsr,\n    animationBegin: 400,\n    animationDuration: 1500,\n    animationEasing: 'ease',\n    nameKey: 'name',\n    blendStroke: false,\n    rootTabIndex: 0\n});\n_defineProperty(Pie, \"parseDeltaAngle\", function(startAngle, endAngle) {\n    var sign = (0, _DataUtils.mathSign)(endAngle - startAngle);\n    var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);\n    return sign * deltaAngle;\n});\n_defineProperty(Pie, \"getRealPieData\", function(itemProps) {\n    var data = itemProps.data, children = itemProps.children;\n    var presentationProps = (0, _ReactUtils.filterProps)(itemProps, false);\n    var cells = (0, _ReactUtils.findAllByType)(children, _Cell.Cell);\n    if (data && data.length) {\n        return data.map(function(entry, index) {\n            return _objectSpread(_objectSpread(_objectSpread({\n                payload: entry\n            }, presentationProps), entry), cells && cells[index] && cells[index].props);\n        });\n    }\n    if (cells && cells.length) {\n        return cells.map(function(cell) {\n            return _objectSpread(_objectSpread({}, presentationProps), cell.props);\n        });\n    }\n    return [];\n});\n_defineProperty(Pie, \"parseCoordinateOfPie\", function(itemProps, offset) {\n    var top = offset.top, left = offset.left, width = offset.width, height = offset.height;\n    var maxPieRadius = (0, _PolarUtils.getMaxRadius)(width, height);\n    var cx = left + (0, _DataUtils.getPercentValue)(itemProps.cx, width, width / 2);\n    var cy = top + (0, _DataUtils.getPercentValue)(itemProps.cy, height, height / 2);\n    var innerRadius = (0, _DataUtils.getPercentValue)(itemProps.innerRadius, maxPieRadius, 0);\n    var outerRadius = (0, _DataUtils.getPercentValue)(itemProps.outerRadius, maxPieRadius, maxPieRadius * 0.8);\n    var maxRadius = itemProps.maxRadius || Math.sqrt(width * width + height * height) / 2;\n    return {\n        cx: cx,\n        cy: cy,\n        innerRadius: innerRadius,\n        outerRadius: outerRadius,\n        maxRadius: maxRadius\n    };\n});\n_defineProperty(Pie, \"getComposedData\", function(_ref4) {\n    var item = _ref4.item, offset = _ref4.offset;\n    var itemProps = item.type.defaultProps !== undefined ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;\n    var pieData = _Pie.getRealPieData(itemProps);\n    if (!pieData || !pieData.length) {\n        return null;\n    }\n    var cornerRadius = itemProps.cornerRadius, startAngle = itemProps.startAngle, endAngle = itemProps.endAngle, paddingAngle = itemProps.paddingAngle, dataKey = itemProps.dataKey, nameKey = itemProps.nameKey, valueKey = itemProps.valueKey, tooltipType = itemProps.tooltipType;\n    var minAngle = Math.abs(itemProps.minAngle);\n    var coordinate = _Pie.parseCoordinateOfPie(itemProps, offset);\n    var deltaAngle = _Pie.parseDeltaAngle(startAngle, endAngle);\n    var absDeltaAngle = Math.abs(deltaAngle);\n    var realDataKey = dataKey;\n    if ((0, _isNil[\"default\"])(dataKey) && (0, _isNil[\"default\"])(valueKey)) {\n        (0, _LogUtils.warn)(false, \"Use \\\"dataKey\\\" to specify the value of pie,\\n      the props \\\"valueKey\\\" will be deprecated in 1.1.0\");\n        realDataKey = 'value';\n    } else if ((0, _isNil[\"default\"])(dataKey)) {\n        (0, _LogUtils.warn)(false, \"Use \\\"dataKey\\\" to specify the value of pie,\\n      the props \\\"valueKey\\\" will be deprecated in 1.1.0\");\n        realDataKey = valueKey;\n    }\n    var notZeroItemCount = pieData.filter(function(entry) {\n        return (0, _ChartUtils.getValueByDataKey)(entry, realDataKey, 0) !== 0;\n    }).length;\n    var totalPadingAngle = (absDeltaAngle >= 360 ? notZeroItemCount : notZeroItemCount - 1) * paddingAngle;\n    var realTotalAngle = absDeltaAngle - notZeroItemCount * minAngle - totalPadingAngle;\n    var sum = pieData.reduce(function(result, entry) {\n        var val = (0, _ChartUtils.getValueByDataKey)(entry, realDataKey, 0);\n        return result + ((0, _DataUtils.isNumber)(val) ? val : 0);\n    }, 0);\n    var sectors;\n    if (sum > 0) {\n        var prev;\n        sectors = pieData.map(function(entry, i) {\n            var val = (0, _ChartUtils.getValueByDataKey)(entry, realDataKey, 0);\n            var name = (0, _ChartUtils.getValueByDataKey)(entry, nameKey, i);\n            var percent = ((0, _DataUtils.isNumber)(val) ? val : 0) / sum;\n            var tempStartAngle;\n            if (i) {\n                tempStartAngle = prev.endAngle + (0, _DataUtils.mathSign)(deltaAngle) * paddingAngle * (val !== 0 ? 1 : 0);\n            } else {\n                tempStartAngle = startAngle;\n            }\n            var tempEndAngle = tempStartAngle + (0, _DataUtils.mathSign)(deltaAngle) * ((val !== 0 ? minAngle : 0) + percent * realTotalAngle);\n            var midAngle = (tempStartAngle + tempEndAngle) / 2;\n            var middleRadius = (coordinate.innerRadius + coordinate.outerRadius) / 2;\n            var tooltipPayload = [\n                {\n                    name: name,\n                    value: val,\n                    payload: entry,\n                    dataKey: realDataKey,\n                    type: tooltipType\n                }\n            ];\n            var tooltipPosition = (0, _PolarUtils.polarToCartesian)(coordinate.cx, coordinate.cy, middleRadius, midAngle);\n            prev = _objectSpread(_objectSpread(_objectSpread({\n                percent: percent,\n                cornerRadius: cornerRadius,\n                name: name,\n                tooltipPayload: tooltipPayload,\n                midAngle: midAngle,\n                middleRadius: middleRadius,\n                tooltipPosition: tooltipPosition\n            }, entry), coordinate), {}, {\n                value: (0, _ChartUtils.getValueByDataKey)(entry, realDataKey),\n                startAngle: tempStartAngle,\n                endAngle: tempEndAngle,\n                payload: entry,\n                paddingAngle: (0, _DataUtils.mathSign)(deltaAngle) * paddingAngle\n            });\n            return prev;\n        });\n    }\n    return _objectSpread(_objectSpread({}, coordinate), {}, {\n        sectors: sectors,\n        data: pieData\n    });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvcG9sYXIvUGllLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxXQUFXLEdBQUcsS0FBSztBQUNuQixJQUFJRyxTQUFTQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3BELElBQUlDLGVBQWVDLHVCQUF1QkYsbUJBQU9BLENBQUMsa0NBQWM7QUFDaEUsSUFBSUcsT0FBT0QsdUJBQXVCRixtQkFBT0EsQ0FBQyw4QkFBWTtBQUN0RCxJQUFJSSxXQUFXRix1QkFBdUJGLG1CQUFPQSxDQUFDLHNDQUFnQjtBQUM5RCxJQUFJSyxTQUFTSCx1QkFBdUJGLG1CQUFPQSxDQUFDLGtDQUFjO0FBQzFELElBQUlNLGNBQWNKLHVCQUF1QkYsbUJBQU9BLENBQUMsNENBQW1CO0FBQ3BFLElBQUlPLFFBQVFMLHVCQUF1QkYsbUJBQU9BLENBQUMsdUJBQU07QUFDakQsSUFBSVEsU0FBU1IsbUJBQU9BLENBQUMsMkZBQW9CO0FBQ3pDLElBQUlTLFNBQVNULG1CQUFPQSxDQUFDLG1GQUFnQjtBQUNyQyxJQUFJVSxRQUFRVixtQkFBT0EsQ0FBQyx5RkFBbUI7QUFDdkMsSUFBSVcsU0FBU1gsbUJBQU9BLENBQUMsMkZBQW9CO0FBQ3pDLElBQUlZLGFBQWFaLG1CQUFPQSxDQUFDLG1HQUF3QjtBQUNqRCxJQUFJYSxRQUFRYixtQkFBT0EsQ0FBQyx5RkFBbUI7QUFDdkMsSUFBSWMsY0FBY2QsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUllLFVBQVVmLG1CQUFPQSxDQUFDLG1GQUFnQjtBQUN0QyxJQUFJZ0IsY0FBY2hCLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM5QyxJQUFJaUIsYUFBYWpCLG1CQUFPQSxDQUFDLHlGQUFtQjtBQUM1QyxJQUFJa0IsY0FBY2xCLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM5QyxJQUFJbUIsWUFBWW5C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ZSxDQUFDaEIsV0FBV3hELFdBQVcsR0FBR3dELFdBQVd4SSxXQUFXLElBQUk7WUFDdkUsSUFBSXlKLGlCQUFpQjtnQkFBQztvQkFDcEJMLE1BQU1BO29CQUNOdlMsT0FBT3NTO29CQUNQL0IsU0FBUzVIO29CQUNUVCxTQUFTMkI7b0JBQ1RxRixNQUFNd0M7Z0JBQ1I7YUFBRTtZQUNGLElBQUltQixrQkFBa0IsQ0FBQyxHQUFHelIsWUFBWTRILGdCQUFnQixFQUFFMkksV0FBVzFJLEVBQUUsRUFBRTBJLFdBQVd6SSxFQUFFLEVBQUV5SixjQUFjL0o7WUFDcEcrRCxPQUFPMUksY0FBY0EsY0FBY0EsY0FBYztnQkFDL0N1TyxTQUFTQTtnQkFDVGYsY0FBY0E7Z0JBQ2RjLE1BQU1BO2dCQUNOSyxnQkFBZ0JBO2dCQUNoQmhLLFVBQVVBO2dCQUNWK0osY0FBY0E7Z0JBQ2RFLGlCQUFpQkE7WUFDbkIsR0FBR2xLLFFBQVFnSixhQUFhLENBQUMsR0FBRztnQkFDMUIzUixPQUFPLENBQUMsR0FBR3NCLFlBQVk2SSxpQkFBaUIsRUFBRXhCLE9BQU9rQjtnQkFDakRoQixZQUFZNEo7Z0JBQ1ozSixVQUFVNEo7Z0JBQ1ZuQyxTQUFTNUg7Z0JBQ1RpRSxjQUFjLENBQUMsR0FBR3ZMLFdBQVd1TyxRQUFRLEVBQUUzQyxjQUFjTDtZQUN2RDtZQUNBLE9BQU9EO1FBQ1Q7SUFDRjtJQUNBLE9BQU8xSSxjQUFjQSxjQUFjLENBQUMsR0FBRzBOLGFBQWEsQ0FBQyxHQUFHO1FBQ3REN0osU0FBU0E7UUFDVG1JLE1BQU1zQjtJQUNSO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXHBvbGFyXFxQaWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5QaWUgPSB2b2lkIDA7XHJcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgX3JlYWN0U21vb3RoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3Qtc21vb3RoXCIpKTtcclxudmFyIF9nZXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZ2V0XCIpKTtcclxudmFyIF9pc0VxdWFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRXF1YWxcIikpO1xyXG52YXIgX2lzTmlsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzTmlsXCIpKTtcclxudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xyXG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcclxudmFyIF9MYXllciA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvTGF5ZXJcIik7XHJcbnZhciBfQ3VydmUgPSByZXF1aXJlKFwiLi4vc2hhcGUvQ3VydmVcIik7XHJcbnZhciBfVGV4dCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQvVGV4dFwiKTtcclxudmFyIF9MYWJlbCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQvTGFiZWxcIik7XHJcbnZhciBfTGFiZWxMaXN0ID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9MYWJlbExpc3RcIik7XHJcbnZhciBfQ2VsbCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQvQ2VsbFwiKTtcclxudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmVhY3RVdGlsc1wiKTtcclxudmFyIF9HbG9iYWwgPSByZXF1aXJlKFwiLi4vdXRpbC9HbG9iYWxcIik7XHJcbnZhciBfUG9sYXJVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1BvbGFyVXRpbHNcIik7XHJcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRGF0YVV0aWxzXCIpO1xyXG52YXIgX0NoYXJ0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9DaGFydFV0aWxzXCIpO1xyXG52YXIgX0xvZ1V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvTG9nVXRpbHNcIik7XHJcbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi4vdXRpbC90eXBlc1wiKTtcclxudmFyIF9BY3RpdmVTaGFwZVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvQWN0aXZlU2hhcGVVdGlsc1wiKTtcclxudmFyIF9QaWU7XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxyXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxyXG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxyXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cclxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XHJcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxyXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxyXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxyXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxyXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XHJcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxyXG4gKiBAZmlsZU92ZXJ2aWV3IFJlbmRlciBzZWN0b3JzIG9mIGEgcGllXHJcbiAqL1xyXG52YXIgUGllID0gZXhwb3J0cy5QaWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QdXJlQ29tcG9uZW50KSB7XHJcbiAgZnVuY3Rpb24gUGllKHByb3BzKSB7XHJcbiAgICB2YXIgX3RoaXM7XHJcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGllKTtcclxuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBQaWUsIFtwcm9wc10pO1xyXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInBpZVJlZlwiLCBudWxsKTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJzZWN0b3JSZWZzXCIsIFtdKTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJpZFwiLCAoMCwgX0RhdGFVdGlscy51bmlxdWVJZCkoJ3JlY2hhcnRzLXBpZS0nKSk7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlQW5pbWF0aW9uRW5kXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG9uQW5pbWF0aW9uRW5kID0gX3RoaXMucHJvcHMub25BbmltYXRpb25FbmQ7XHJcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcclxuICAgICAgICBpc0FuaW1hdGlvbkZpbmlzaGVkOiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob25BbmltYXRpb25FbmQpKSB7XHJcbiAgICAgICAgb25BbmltYXRpb25FbmQoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlQW5pbWF0aW9uU3RhcnRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgb25BbmltYXRpb25TdGFydCA9IF90aGlzLnByb3BzLm9uQW5pbWF0aW9uU3RhcnQ7XHJcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcclxuICAgICAgICBpc0FuaW1hdGlvbkZpbmlzaGVkOiBmYWxzZVxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9uQW5pbWF0aW9uU3RhcnQpKSB7XHJcbiAgICAgICAgb25BbmltYXRpb25TdGFydCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIF90aGlzLnN0YXRlID0ge1xyXG4gICAgICBpc0FuaW1hdGlvbkZpbmlzaGVkOiAhcHJvcHMuaXNBbmltYXRpb25BY3RpdmUsXHJcbiAgICAgIHByZXZJc0FuaW1hdGlvbkFjdGl2ZTogcHJvcHMuaXNBbmltYXRpb25BY3RpdmUsXHJcbiAgICAgIHByZXZBbmltYXRpb25JZDogcHJvcHMuYW5pbWF0aW9uSWQsXHJcbiAgICAgIHNlY3RvclRvRm9jdXM6IDBcclxuICAgIH07XHJcbiAgICByZXR1cm4gX3RoaXM7XHJcbiAgfVxyXG4gIF9pbmhlcml0cyhQaWUsIF9QdXJlQ29tcG9uZW50KTtcclxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFBpZSwgW3tcclxuICAgIGtleTogXCJpc0FjdGl2ZUluZGV4XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNBY3RpdmVJbmRleChpKSB7XHJcbiAgICAgIHZhciBhY3RpdmVJbmRleCA9IHRoaXMucHJvcHMuYWN0aXZlSW5kZXg7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFjdGl2ZUluZGV4KSkge1xyXG4gICAgICAgIHJldHVybiBhY3RpdmVJbmRleC5pbmRleE9mKGkpICE9PSAtMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaSA9PT0gYWN0aXZlSW5kZXg7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImhhc0FjdGl2ZUluZGV4XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzQWN0aXZlSW5kZXgoKSB7XHJcbiAgICAgIHZhciBhY3RpdmVJbmRleCA9IHRoaXMucHJvcHMuYWN0aXZlSW5kZXg7XHJcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFjdGl2ZUluZGV4KSA/IGFjdGl2ZUluZGV4Lmxlbmd0aCAhPT0gMCA6IGFjdGl2ZUluZGV4IHx8IGFjdGl2ZUluZGV4ID09PSAwO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJMYWJlbHNcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJMYWJlbHMoc2VjdG9ycykge1xyXG4gICAgICB2YXIgaXNBbmltYXRpb25BY3RpdmUgPSB0aGlzLnByb3BzLmlzQW5pbWF0aW9uQWN0aXZlO1xyXG4gICAgICBpZiAoaXNBbmltYXRpb25BY3RpdmUgJiYgIXRoaXMuc3RhdGUuaXNBbmltYXRpb25GaW5pc2hlZCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgbGFiZWwgPSBfdGhpcyRwcm9wcy5sYWJlbCxcclxuICAgICAgICBsYWJlbExpbmUgPSBfdGhpcyRwcm9wcy5sYWJlbExpbmUsXHJcbiAgICAgICAgZGF0YUtleSA9IF90aGlzJHByb3BzLmRhdGFLZXksXHJcbiAgICAgICAgdmFsdWVLZXkgPSBfdGhpcyRwcm9wcy52YWx1ZUtleTtcclxuICAgICAgdmFyIHBpZVByb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0aGlzLnByb3BzLCBmYWxzZSk7XHJcbiAgICAgIHZhciBjdXN0b21MYWJlbFByb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShsYWJlbCwgZmFsc2UpO1xyXG4gICAgICB2YXIgY3VzdG9tTGFiZWxMaW5lUHJvcHMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKGxhYmVsTGluZSwgZmFsc2UpO1xyXG4gICAgICB2YXIgb2Zmc2V0UmFkaXVzID0gbGFiZWwgJiYgbGFiZWwub2Zmc2V0UmFkaXVzIHx8IDIwO1xyXG4gICAgICB2YXIgbGFiZWxzID0gc2VjdG9ycy5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpKSB7XHJcbiAgICAgICAgdmFyIG1pZEFuZ2xlID0gKGVudHJ5LnN0YXJ0QW5nbGUgKyBlbnRyeS5lbmRBbmdsZSkgLyAyO1xyXG4gICAgICAgIHZhciBlbmRQb2ludCA9ICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShlbnRyeS5jeCwgZW50cnkuY3ksIGVudHJ5Lm91dGVyUmFkaXVzICsgb2Zmc2V0UmFkaXVzLCBtaWRBbmdsZSk7XHJcbiAgICAgICAgdmFyIGxhYmVsUHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwaWVQcm9wcyksIGVudHJ5KSwge30sIHtcclxuICAgICAgICAgIHN0cm9rZTogJ25vbmUnXHJcbiAgICAgICAgfSwgY3VzdG9tTGFiZWxQcm9wcyksIHt9LCB7XHJcbiAgICAgICAgICBpbmRleDogaSxcclxuICAgICAgICAgIHRleHRBbmNob3I6IFBpZS5nZXRUZXh0QW5jaG9yKGVuZFBvaW50LngsIGVudHJ5LmN4KVxyXG4gICAgICAgIH0sIGVuZFBvaW50KTtcclxuICAgICAgICB2YXIgbGluZVByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGllUHJvcHMpLCBlbnRyeSksIHt9LCB7XHJcbiAgICAgICAgICBmaWxsOiAnbm9uZScsXHJcbiAgICAgICAgICBzdHJva2U6IGVudHJ5LmZpbGxcclxuICAgICAgICB9LCBjdXN0b21MYWJlbExpbmVQcm9wcyksIHt9LCB7XHJcbiAgICAgICAgICBpbmRleDogaSxcclxuICAgICAgICAgIHBvaW50czogWygwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShlbnRyeS5jeCwgZW50cnkuY3ksIGVudHJ5Lm91dGVyUmFkaXVzLCBtaWRBbmdsZSksIGVuZFBvaW50XVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciByZWFsRGF0YUtleSA9IGRhdGFLZXk7XHJcbiAgICAgICAgLy8gVE9ETzogY29tcGF0aWJsZSB0byBsb3dlciB2ZXJzaW9uc1xyXG4gICAgICAgIGlmICgoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoZGF0YUtleSkgJiYgKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKHZhbHVlS2V5KSkge1xyXG4gICAgICAgICAgcmVhbERhdGFLZXkgPSAndmFsdWUnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGRhdGFLZXkpKSB7XHJcbiAgICAgICAgICByZWFsRGF0YUtleSA9IHZhbHVlS2V5O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgLyojX19QVVJFX18qL1xyXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxyXG4gICAgICAgICAgX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xyXG4gICAgICAgICAgICBrZXk6IFwibGFiZWwtXCIuY29uY2F0KGVudHJ5LnN0YXJ0QW5nbGUsIFwiLVwiKS5jb25jYXQoZW50cnkuZW5kQW5nbGUsIFwiLVwiKS5jb25jYXQoZW50cnkubWlkQW5nbGUsIFwiLVwiKS5jb25jYXQoaSlcclxuICAgICAgICAgIH0sIGxhYmVsTGluZSAmJiBQaWUucmVuZGVyTGFiZWxMaW5lSXRlbShsYWJlbExpbmUsIGxpbmVQcm9wcywgJ2xpbmUnKSwgUGllLnJlbmRlckxhYmVsSXRlbShsYWJlbCwgbGFiZWxQcm9wcywgKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShlbnRyeSwgcmVhbERhdGFLZXkpKSlcclxuICAgICAgICApO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXBpZS1sYWJlbHNcIlxyXG4gICAgICB9LCBsYWJlbHMpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJTZWN0b3JzU3RhdGljYWxseVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclNlY3RvcnNTdGF0aWNhbGx5KHNlY3RvcnMpIHtcclxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIGFjdGl2ZVNoYXBlID0gX3RoaXMkcHJvcHMyLmFjdGl2ZVNoYXBlLFxyXG4gICAgICAgIGJsZW5kU3Ryb2tlID0gX3RoaXMkcHJvcHMyLmJsZW5kU3Ryb2tlLFxyXG4gICAgICAgIGluYWN0aXZlU2hhcGVQcm9wID0gX3RoaXMkcHJvcHMyLmluYWN0aXZlU2hhcGU7XHJcbiAgICAgIHJldHVybiBzZWN0b3JzLm1hcChmdW5jdGlvbiAoZW50cnksIGkpIHtcclxuICAgICAgICBpZiAoKGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS5zdGFydEFuZ2xlKSA9PT0gMCAmJiAoZW50cnkgPT09IG51bGwgfHwgZW50cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVudHJ5LmVuZEFuZ2xlKSA9PT0gMCAmJiBzZWN0b3JzLmxlbmd0aCAhPT0gMSkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgdmFyIGlzQWN0aXZlID0gX3RoaXMyLmlzQWN0aXZlSW5kZXgoaSk7XHJcbiAgICAgICAgdmFyIGluYWN0aXZlU2hhcGUgPSBpbmFjdGl2ZVNoYXBlUHJvcCAmJiBfdGhpczIuaGFzQWN0aXZlSW5kZXgoKSA/IGluYWN0aXZlU2hhcGVQcm9wIDogbnVsbDtcclxuICAgICAgICB2YXIgc2VjdG9yT3B0aW9ucyA9IGlzQWN0aXZlID8gYWN0aXZlU2hhcGUgOiBpbmFjdGl2ZVNoYXBlO1xyXG4gICAgICAgIHZhciBzZWN0b3JQcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xyXG4gICAgICAgICAgc3Ryb2tlOiBibGVuZFN0cm9rZSA/IGVudHJ5LmZpbGwgOiBlbnRyeS5zdHJva2UsXHJcbiAgICAgICAgICB0YWJJbmRleDogLTFcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIF9leHRlbmRzKHtcclxuICAgICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKF9yZWYpIHtcclxuICAgICAgICAgICAgaWYgKF9yZWYgJiYgIV90aGlzMi5zZWN0b3JSZWZzLmluY2x1ZGVzKF9yZWYpKSB7XHJcbiAgICAgICAgICAgICAgX3RoaXMyLnNlY3RvclJlZnMucHVzaChfcmVmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHRhYkluZGV4OiAtMSxcclxuICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1waWUtc2VjdG9yXCJcclxuICAgICAgICB9LCAoMCwgX3R5cGVzLmFkYXB0RXZlbnRzT2ZDaGlsZCkoX3RoaXMyLnByb3BzLCBlbnRyeSwgaSksIHtcclxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1hcnJheS1pbmRleC1rZXlcclxuICAgICAgICAgIGtleTogXCJzZWN0b3ItXCIuY29uY2F0KGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS5zdGFydEFuZ2xlLCBcIi1cIikuY29uY2F0KGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS5lbmRBbmdsZSwgXCItXCIpLmNvbmNhdChlbnRyeS5taWRBbmdsZSwgXCItXCIpLmNvbmNhdChpKVxyXG4gICAgICAgIH0pLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9BY3RpdmVTaGFwZVV0aWxzLlNoYXBlLCBfZXh0ZW5kcyh7XHJcbiAgICAgICAgICBvcHRpb246IHNlY3Rvck9wdGlvbnMsXHJcbiAgICAgICAgICBpc0FjdGl2ZTogaXNBY3RpdmUsXHJcbiAgICAgICAgICBzaGFwZVR5cGU6IFwic2VjdG9yXCJcclxuICAgICAgICB9LCBzZWN0b3JQcm9wcykpKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJlbmRlclNlY3RvcnNXaXRoQW5pbWF0aW9uXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyU2VjdG9yc1dpdGhBbmltYXRpb24oKSB7XHJcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBzZWN0b3JzID0gX3RoaXMkcHJvcHMzLnNlY3RvcnMsXHJcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wczMuaXNBbmltYXRpb25BY3RpdmUsXHJcbiAgICAgICAgYW5pbWF0aW9uQmVnaW4gPSBfdGhpcyRwcm9wczMuYW5pbWF0aW9uQmVnaW4sXHJcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb24gPSBfdGhpcyRwcm9wczMuYW5pbWF0aW9uRHVyYXRpb24sXHJcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nID0gX3RoaXMkcHJvcHMzLmFuaW1hdGlvbkVhc2luZyxcclxuICAgICAgICBhbmltYXRpb25JZCA9IF90aGlzJHByb3BzMy5hbmltYXRpb25JZDtcclxuICAgICAgdmFyIF90aGlzJHN0YXRlID0gdGhpcy5zdGF0ZSxcclxuICAgICAgICBwcmV2U2VjdG9ycyA9IF90aGlzJHN0YXRlLnByZXZTZWN0b3JzLFxyXG4gICAgICAgIHByZXZJc0FuaW1hdGlvbkFjdGl2ZSA9IF90aGlzJHN0YXRlLnByZXZJc0FuaW1hdGlvbkFjdGl2ZTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX3JlYWN0U21vb3RoW1wiZGVmYXVsdFwiXSwge1xyXG4gICAgICAgIGJlZ2luOiBhbmltYXRpb25CZWdpbixcclxuICAgICAgICBkdXJhdGlvbjogYW5pbWF0aW9uRHVyYXRpb24sXHJcbiAgICAgICAgaXNBY3RpdmU6IGlzQW5pbWF0aW9uQWN0aXZlLFxyXG4gICAgICAgIGVhc2luZzogYW5pbWF0aW9uRWFzaW5nLFxyXG4gICAgICAgIGZyb206IHtcclxuICAgICAgICAgIHQ6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvOiB7XHJcbiAgICAgICAgICB0OiAxXHJcbiAgICAgICAgfSxcclxuICAgICAgICBrZXk6IFwicGllLVwiLmNvbmNhdChhbmltYXRpb25JZCwgXCItXCIpLmNvbmNhdChwcmV2SXNBbmltYXRpb25BY3RpdmUpLFxyXG4gICAgICAgIG9uQW5pbWF0aW9uU3RhcnQ6IHRoaXMuaGFuZGxlQW5pbWF0aW9uU3RhcnQsXHJcbiAgICAgICAgb25BbmltYXRpb25FbmQ6IHRoaXMuaGFuZGxlQW5pbWF0aW9uRW5kXHJcbiAgICAgIH0sIGZ1bmN0aW9uIChfcmVmMikge1xyXG4gICAgICAgIHZhciB0ID0gX3JlZjIudDtcclxuICAgICAgICB2YXIgc3RlcERhdGEgPSBbXTtcclxuICAgICAgICB2YXIgZmlyc3QgPSBzZWN0b3JzICYmIHNlY3RvcnNbMF07XHJcbiAgICAgICAgdmFyIGN1ckFuZ2xlID0gZmlyc3Quc3RhcnRBbmdsZTtcclxuICAgICAgICBzZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xyXG4gICAgICAgICAgdmFyIHByZXYgPSBwcmV2U2VjdG9ycyAmJiBwcmV2U2VjdG9yc1tpbmRleF07XHJcbiAgICAgICAgICB2YXIgcGFkZGluZ0FuZ2xlID0gaW5kZXggPiAwID8gKDAsIF9nZXRbXCJkZWZhdWx0XCJdKShlbnRyeSwgJ3BhZGRpbmdBbmdsZScsIDApIDogMDtcclxuICAgICAgICAgIGlmIChwcmV2KSB7XHJcbiAgICAgICAgICAgIHZhciBhbmdsZUlwID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKHByZXYuZW5kQW5nbGUgLSBwcmV2LnN0YXJ0QW5nbGUsIGVudHJ5LmVuZEFuZ2xlIC0gZW50cnkuc3RhcnRBbmdsZSk7XHJcbiAgICAgICAgICAgIHZhciBsYXRlc3QgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcclxuICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBjdXJBbmdsZSArIHBhZGRpbmdBbmdsZSxcclxuICAgICAgICAgICAgICBlbmRBbmdsZTogY3VyQW5nbGUgKyBhbmdsZUlwKHQpICsgcGFkZGluZ0FuZ2xlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzdGVwRGF0YS5wdXNoKGxhdGVzdCk7XHJcbiAgICAgICAgICAgIGN1ckFuZ2xlID0gbGF0ZXN0LmVuZEFuZ2xlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gZW50cnkuZW5kQW5nbGUsXHJcbiAgICAgICAgICAgICAgc3RhcnRBbmdsZSA9IGVudHJ5LnN0YXJ0QW5nbGU7XHJcbiAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3JBbmdsZSA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKSgwLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xyXG4gICAgICAgICAgICB2YXIgZGVsdGFBbmdsZSA9IGludGVycG9sYXRvckFuZ2xlKHQpO1xyXG4gICAgICAgICAgICB2YXIgX2xhdGVzdCA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xyXG4gICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IGN1ckFuZ2xlICsgcGFkZGluZ0FuZ2xlLFxyXG4gICAgICAgICAgICAgIGVuZEFuZ2xlOiBjdXJBbmdsZSArIGRlbHRhQW5nbGUgKyBwYWRkaW5nQW5nbGVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHN0ZXBEYXRhLnB1c2goX2xhdGVzdCk7XHJcbiAgICAgICAgICAgIGN1ckFuZ2xlID0gX2xhdGVzdC5lbmRBbmdsZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIG51bGwsIF90aGlzMy5yZW5kZXJTZWN0b3JzU3RhdGljYWxseShzdGVwRGF0YSkpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiYXR0YWNoS2V5Ym9hcmRIYW5kbGVyc1wiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaEtleWJvYXJkSGFuZGxlcnMocGllUmVmKSB7XHJcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgcGllUmVmLm9ua2V5ZG93biA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgaWYgKCFlLmFsdEtleSkge1xyXG4gICAgICAgICAgc3dpdGNoIChlLmtleSkge1xyXG4gICAgICAgICAgICBjYXNlICdBcnJvd0xlZnQnOlxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gKytfdGhpczQuc3RhdGUuc2VjdG9yVG9Gb2N1cyAlIF90aGlzNC5zZWN0b3JSZWZzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIF90aGlzNC5zZWN0b3JSZWZzW25leHRdLmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpczQuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgICBzZWN0b3JUb0ZvY3VzOiBuZXh0XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9uZXh0ID0gLS1fdGhpczQuc3RhdGUuc2VjdG9yVG9Gb2N1cyA8IDAgPyBfdGhpczQuc2VjdG9yUmVmcy5sZW5ndGggLSAxIDogX3RoaXM0LnN0YXRlLnNlY3RvclRvRm9jdXMgJSBfdGhpczQuc2VjdG9yUmVmcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBfdGhpczQuc2VjdG9yUmVmc1tfbmV4dF0uZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgIF90aGlzNC5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgIHNlY3RvclRvRm9jdXM6IF9uZXh0XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAnRXNjYXBlJzpcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfdGhpczQuc2VjdG9yUmVmc1tfdGhpczQuc3RhdGUuc2VjdG9yVG9Gb2N1c10uYmx1cigpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXM0LnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgc2VjdG9yVG9Gb2N1czogMFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm90aGluZyB0byBkbyBoZXJlXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyU2VjdG9yc1wiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclNlY3RvcnMoKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIHNlY3RvcnMgPSBfdGhpcyRwcm9wczQuc2VjdG9ycyxcclxuICAgICAgICBpc0FuaW1hdGlvbkFjdGl2ZSA9IF90aGlzJHByb3BzNC5pc0FuaW1hdGlvbkFjdGl2ZTtcclxuICAgICAgdmFyIHByZXZTZWN0b3JzID0gdGhpcy5zdGF0ZS5wcmV2U2VjdG9ycztcclxuICAgICAgaWYgKGlzQW5pbWF0aW9uQWN0aXZlICYmIHNlY3RvcnMgJiYgc2VjdG9ycy5sZW5ndGggJiYgKCFwcmV2U2VjdG9ycyB8fCAhKDAsIF9pc0VxdWFsW1wiZGVmYXVsdFwiXSkocHJldlNlY3RvcnMsIHNlY3RvcnMpKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlclNlY3RvcnNXaXRoQW5pbWF0aW9uKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyU2VjdG9yc1N0YXRpY2FsbHkoc2VjdG9ycyk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgIGlmICh0aGlzLnBpZVJlZikge1xyXG4gICAgICAgIHRoaXMuYXR0YWNoS2V5Ym9hcmRIYW5kbGVycyh0aGlzLnBpZVJlZik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcclxuICAgICAgdmFyIF90aGlzJHByb3BzNSA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgaGlkZSA9IF90aGlzJHByb3BzNS5oaWRlLFxyXG4gICAgICAgIHNlY3RvcnMgPSBfdGhpcyRwcm9wczUuc2VjdG9ycyxcclxuICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczUuY2xhc3NOYW1lLFxyXG4gICAgICAgIGxhYmVsID0gX3RoaXMkcHJvcHM1LmxhYmVsLFxyXG4gICAgICAgIGN4ID0gX3RoaXMkcHJvcHM1LmN4LFxyXG4gICAgICAgIGN5ID0gX3RoaXMkcHJvcHM1LmN5LFxyXG4gICAgICAgIGlubmVyUmFkaXVzID0gX3RoaXMkcHJvcHM1LmlubmVyUmFkaXVzLFxyXG4gICAgICAgIG91dGVyUmFkaXVzID0gX3RoaXMkcHJvcHM1Lm91dGVyUmFkaXVzLFxyXG4gICAgICAgIGlzQW5pbWF0aW9uQWN0aXZlID0gX3RoaXMkcHJvcHM1LmlzQW5pbWF0aW9uQWN0aXZlO1xyXG4gICAgICB2YXIgaXNBbmltYXRpb25GaW5pc2hlZCA9IHRoaXMuc3RhdGUuaXNBbmltYXRpb25GaW5pc2hlZDtcclxuICAgICAgaWYgKGhpZGUgfHwgIXNlY3RvcnMgfHwgIXNlY3RvcnMubGVuZ3RoIHx8ICEoMCwgX0RhdGFVdGlscy5pc051bWJlcikoY3gpIHx8ICEoMCwgX0RhdGFVdGlscy5pc051bWJlcikoY3kpIHx8ICEoMCwgX0RhdGFVdGlscy5pc051bWJlcikoaW5uZXJSYWRpdXMpIHx8ICEoMCwgX0RhdGFVdGlscy5pc051bWJlcikob3V0ZXJSYWRpdXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGxheWVyQ2xhc3MgPSAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtcGllJywgY2xhc3NOYW1lKTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XHJcbiAgICAgICAgdGFiSW5kZXg6IHRoaXMucHJvcHMucm9vdFRhYkluZGV4LFxyXG4gICAgICAgIGNsYXNzTmFtZTogbGF5ZXJDbGFzcyxcclxuICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihfcmVmMykge1xyXG4gICAgICAgICAgX3RoaXM1LnBpZVJlZiA9IF9yZWYzO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgdGhpcy5yZW5kZXJTZWN0b3JzKCksIGxhYmVsICYmIHRoaXMucmVuZGVyTGFiZWxzKHNlY3RvcnMpLCBfTGFiZWwuTGFiZWwucmVuZGVyQ2FsbEJ5UGFyZW50KHRoaXMucHJvcHMsIG51bGwsIGZhbHNlKSwgKCFpc0FuaW1hdGlvbkFjdGl2ZSB8fCBpc0FuaW1hdGlvbkZpbmlzaGVkKSAmJiBfTGFiZWxMaXN0LkxhYmVsTGlzdC5yZW5kZXJDYWxsQnlQYXJlbnQodGhpcy5wcm9wcywgc2VjdG9ycywgZmFsc2UpKTtcclxuICAgIH1cclxuICB9XSwgW3tcclxuICAgIGtleTogXCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpIHtcclxuICAgICAgaWYgKHByZXZTdGF0ZS5wcmV2SXNBbmltYXRpb25BY3RpdmUgIT09IG5leHRQcm9wcy5pc0FuaW1hdGlvbkFjdGl2ZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBwcmV2SXNBbmltYXRpb25BY3RpdmU6IG5leHRQcm9wcy5pc0FuaW1hdGlvbkFjdGl2ZSxcclxuICAgICAgICAgIHByZXZBbmltYXRpb25JZDogbmV4dFByb3BzLmFuaW1hdGlvbklkLFxyXG4gICAgICAgICAgY3VyU2VjdG9yczogbmV4dFByb3BzLnNlY3RvcnMsXHJcbiAgICAgICAgICBwcmV2U2VjdG9yczogW10sXHJcbiAgICAgICAgICBpc0FuaW1hdGlvbkZpbmlzaGVkOiB0cnVlXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobmV4dFByb3BzLmlzQW5pbWF0aW9uQWN0aXZlICYmIG5leHRQcm9wcy5hbmltYXRpb25JZCAhPT0gcHJldlN0YXRlLnByZXZBbmltYXRpb25JZCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBwcmV2QW5pbWF0aW9uSWQ6IG5leHRQcm9wcy5hbmltYXRpb25JZCxcclxuICAgICAgICAgIGN1clNlY3RvcnM6IG5leHRQcm9wcy5zZWN0b3JzLFxyXG4gICAgICAgICAgcHJldlNlY3RvcnM6IHByZXZTdGF0ZS5jdXJTZWN0b3JzLFxyXG4gICAgICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogdHJ1ZVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5leHRQcm9wcy5zZWN0b3JzICE9PSBwcmV2U3RhdGUuY3VyU2VjdG9ycykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBjdXJTZWN0b3JzOiBuZXh0UHJvcHMuc2VjdG9ycyxcclxuICAgICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6IHRydWVcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJnZXRUZXh0QW5jaG9yXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dEFuY2hvcih4LCBjeCkge1xyXG4gICAgICBpZiAoeCA+IGN4KSB7XHJcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHggPCBjeCkge1xyXG4gICAgICAgIHJldHVybiAnZW5kJztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gJ21pZGRsZSc7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJlbmRlckxhYmVsTGluZUl0ZW1cIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJMYWJlbExpbmVJdGVtKG9wdGlvbiwgcHJvcHMsIGtleSkge1xyXG4gICAgICBpZiAoIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KG9wdGlvbikpIHtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KG9wdGlvbiwgcHJvcHMpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvcHRpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbihwcm9wcyk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGNsYXNzTmFtZSA9ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1waWUtbGFiZWwtbGluZScsIHR5cGVvZiBvcHRpb24gIT09ICdib29sZWFuJyA/IG9wdGlvbi5jbGFzc05hbWUgOiAnJyk7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9DdXJ2ZS5DdXJ2ZSwgX2V4dGVuZHMoe30sIHByb3BzLCB7XHJcbiAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgdHlwZTogXCJsaW5lYXJcIixcclxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxyXG4gICAgICB9KSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJlbmRlckxhYmVsSXRlbVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckxhYmVsSXRlbShvcHRpb24sIHByb3BzLCB2YWx1ZSkge1xyXG4gICAgICBpZiAoIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KG9wdGlvbikpIHtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KG9wdGlvbiwgcHJvcHMpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBsYWJlbCA9IHZhbHVlO1xyXG4gICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob3B0aW9uKSkge1xyXG4gICAgICAgIGxhYmVsID0gb3B0aW9uKHByb3BzKTtcclxuICAgICAgICBpZiAoIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KGxhYmVsKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGxhYmVsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB2YXIgY2xhc3NOYW1lID0gKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXBpZS1sYWJlbC10ZXh0JywgdHlwZW9mIG9wdGlvbiAhPT0gJ2Jvb2xlYW4nICYmICEoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvcHRpb24pID8gb3B0aW9uLmNsYXNzTmFtZSA6ICcnKTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX1RleHQuVGV4dCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XHJcbiAgICAgICAgYWxpZ25tZW50QmFzZWxpbmU6IFwibWlkZGxlXCIsXHJcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcclxuICAgICAgfSksIGxhYmVsKTtcclxuICAgIH1cclxuICB9XSk7XHJcbn0oX3JlYWN0LlB1cmVDb21wb25lbnQpO1xyXG5fUGllID0gUGllO1xyXG5fZGVmaW5lUHJvcGVydHkoUGllLCBcImRpc3BsYXlOYW1lXCIsICdQaWUnKTtcclxuX2RlZmluZVByb3BlcnR5KFBpZSwgXCJkZWZhdWx0UHJvcHNcIiwge1xyXG4gIHN0cm9rZTogJyNmZmYnLFxyXG4gIGZpbGw6ICcjODA4MDgwJyxcclxuICBsZWdlbmRUeXBlOiAncmVjdCcsXHJcbiAgY3g6ICc1MCUnLFxyXG4gIGN5OiAnNTAlJyxcclxuICBzdGFydEFuZ2xlOiAwLFxyXG4gIGVuZEFuZ2xlOiAzNjAsXHJcbiAgaW5uZXJSYWRpdXM6IDAsXHJcbiAgb3V0ZXJSYWRpdXM6ICc4MCUnLFxyXG4gIHBhZGRpbmdBbmdsZTogMCxcclxuICBsYWJlbExpbmU6IHRydWUsXHJcbiAgaGlkZTogZmFsc2UsXHJcbiAgbWluQW5nbGU6IDAsXHJcbiAgaXNBbmltYXRpb25BY3RpdmU6ICFfR2xvYmFsLkdsb2JhbC5pc1NzcixcclxuICBhbmltYXRpb25CZWdpbjogNDAwLFxyXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiAxNTAwLFxyXG4gIGFuaW1hdGlvbkVhc2luZzogJ2Vhc2UnLFxyXG4gIG5hbWVLZXk6ICduYW1lJyxcclxuICBibGVuZFN0cm9rZTogZmFsc2UsXHJcbiAgcm9vdFRhYkluZGV4OiAwXHJcbn0pO1xyXG5fZGVmaW5lUHJvcGVydHkoUGllLCBcInBhcnNlRGVsdGFBbmdsZVwiLCBmdW5jdGlvbiAoc3RhcnRBbmdsZSwgZW5kQW5nbGUpIHtcclxuICB2YXIgc2lnbiA9ICgwLCBfRGF0YVV0aWxzLm1hdGhTaWduKShlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xyXG4gIHZhciBkZWx0YUFuZ2xlID0gTWF0aC5taW4oTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSwgMzYwKTtcclxuICByZXR1cm4gc2lnbiAqIGRlbHRhQW5nbGU7XHJcbn0pO1xyXG5fZGVmaW5lUHJvcGVydHkoUGllLCBcImdldFJlYWxQaWVEYXRhXCIsIGZ1bmN0aW9uIChpdGVtUHJvcHMpIHtcclxuICB2YXIgZGF0YSA9IGl0ZW1Qcm9wcy5kYXRhLFxyXG4gICAgY2hpbGRyZW4gPSBpdGVtUHJvcHMuY2hpbGRyZW47XHJcbiAgdmFyIHByZXNlbnRhdGlvblByb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShpdGVtUHJvcHMsIGZhbHNlKTtcclxuICB2YXIgY2VsbHMgPSAoMCwgX1JlYWN0VXRpbHMuZmluZEFsbEJ5VHlwZSkoY2hpbGRyZW4sIF9DZWxsLkNlbGwpO1xyXG4gIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xyXG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xyXG4gICAgICAgIHBheWxvYWQ6IGVudHJ5XHJcbiAgICAgIH0sIHByZXNlbnRhdGlvblByb3BzKSwgZW50cnkpLCBjZWxscyAmJiBjZWxsc1tpbmRleF0gJiYgY2VsbHNbaW5kZXhdLnByb3BzKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBpZiAoY2VsbHMgJiYgY2VsbHMubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gY2VsbHMubWFwKGZ1bmN0aW9uIChjZWxsKSB7XHJcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByZXNlbnRhdGlvblByb3BzKSwgY2VsbC5wcm9wcyk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIFtdO1xyXG59KTtcclxuX2RlZmluZVByb3BlcnR5KFBpZSwgXCJwYXJzZUNvb3JkaW5hdGVPZlBpZVwiLCBmdW5jdGlvbiAoaXRlbVByb3BzLCBvZmZzZXQpIHtcclxuICB2YXIgdG9wID0gb2Zmc2V0LnRvcCxcclxuICAgIGxlZnQgPSBvZmZzZXQubGVmdCxcclxuICAgIHdpZHRoID0gb2Zmc2V0LndpZHRoLFxyXG4gICAgaGVpZ2h0ID0gb2Zmc2V0LmhlaWdodDtcclxuICB2YXIgbWF4UGllUmFkaXVzID0gKDAsIF9Qb2xhclV0aWxzLmdldE1heFJhZGl1cykod2lkdGgsIGhlaWdodCk7XHJcbiAgdmFyIGN4ID0gbGVmdCArICgwLCBfRGF0YVV0aWxzLmdldFBlcmNlbnRWYWx1ZSkoaXRlbVByb3BzLmN4LCB3aWR0aCwgd2lkdGggLyAyKTtcclxuICB2YXIgY3kgPSB0b3AgKyAoMCwgX0RhdGFVdGlscy5nZXRQZXJjZW50VmFsdWUpKGl0ZW1Qcm9wcy5jeSwgaGVpZ2h0LCBoZWlnaHQgLyAyKTtcclxuICB2YXIgaW5uZXJSYWRpdXMgPSAoMCwgX0RhdGFVdGlscy5nZXRQZXJjZW50VmFsdWUpKGl0ZW1Qcm9wcy5pbm5lclJhZGl1cywgbWF4UGllUmFkaXVzLCAwKTtcclxuICB2YXIgb3V0ZXJSYWRpdXMgPSAoMCwgX0RhdGFVdGlscy5nZXRQZXJjZW50VmFsdWUpKGl0ZW1Qcm9wcy5vdXRlclJhZGl1cywgbWF4UGllUmFkaXVzLCBtYXhQaWVSYWRpdXMgKiAwLjgpO1xyXG4gIHZhciBtYXhSYWRpdXMgPSBpdGVtUHJvcHMubWF4UmFkaXVzIHx8IE1hdGguc3FydCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0KSAvIDI7XHJcbiAgcmV0dXJuIHtcclxuICAgIGN4OiBjeCxcclxuICAgIGN5OiBjeSxcclxuICAgIGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcclxuICAgIG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcclxuICAgIG1heFJhZGl1czogbWF4UmFkaXVzXHJcbiAgfTtcclxufSk7XHJcbl9kZWZpbmVQcm9wZXJ0eShQaWUsIFwiZ2V0Q29tcG9zZWREYXRhXCIsIGZ1bmN0aW9uIChfcmVmNCkge1xyXG4gIHZhciBpdGVtID0gX3JlZjQuaXRlbSxcclxuICAgIG9mZnNldCA9IF9yZWY0Lm9mZnNldDtcclxuICB2YXIgaXRlbVByb3BzID0gaXRlbS50eXBlLmRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBpdGVtLnR5cGUuZGVmYXVsdFByb3BzKSwgaXRlbS5wcm9wcykgOiBpdGVtLnByb3BzO1xyXG4gIHZhciBwaWVEYXRhID0gX1BpZS5nZXRSZWFsUGllRGF0YShpdGVtUHJvcHMpO1xyXG4gIGlmICghcGllRGF0YSB8fCAhcGllRGF0YS5sZW5ndGgpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICB2YXIgY29ybmVyUmFkaXVzID0gaXRlbVByb3BzLmNvcm5lclJhZGl1cyxcclxuICAgIHN0YXJ0QW5nbGUgPSBpdGVtUHJvcHMuc3RhcnRBbmdsZSxcclxuICAgIGVuZEFuZ2xlID0gaXRlbVByb3BzLmVuZEFuZ2xlLFxyXG4gICAgcGFkZGluZ0FuZ2xlID0gaXRlbVByb3BzLnBhZGRpbmdBbmdsZSxcclxuICAgIGRhdGFLZXkgPSBpdGVtUHJvcHMuZGF0YUtleSxcclxuICAgIG5hbWVLZXkgPSBpdGVtUHJvcHMubmFtZUtleSxcclxuICAgIHZhbHVlS2V5ID0gaXRlbVByb3BzLnZhbHVlS2V5LFxyXG4gICAgdG9vbHRpcFR5cGUgPSBpdGVtUHJvcHMudG9vbHRpcFR5cGU7XHJcbiAgdmFyIG1pbkFuZ2xlID0gTWF0aC5hYnMoaXRlbVByb3BzLm1pbkFuZ2xlKTtcclxuICB2YXIgY29vcmRpbmF0ZSA9IF9QaWUucGFyc2VDb29yZGluYXRlT2ZQaWUoaXRlbVByb3BzLCBvZmZzZXQpO1xyXG4gIHZhciBkZWx0YUFuZ2xlID0gX1BpZS5wYXJzZURlbHRhQW5nbGUoc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xyXG4gIHZhciBhYnNEZWx0YUFuZ2xlID0gTWF0aC5hYnMoZGVsdGFBbmdsZSk7XHJcbiAgdmFyIHJlYWxEYXRhS2V5ID0gZGF0YUtleTtcclxuICBpZiAoKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGRhdGFLZXkpICYmICgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKSh2YWx1ZUtleSkpIHtcclxuICAgICgwLCBfTG9nVXRpbHMud2FybikoZmFsc2UsIFwiVXNlIFxcXCJkYXRhS2V5XFxcIiB0byBzcGVjaWZ5IHRoZSB2YWx1ZSBvZiBwaWUsXFxuICAgICAgdGhlIHByb3BzIFxcXCJ2YWx1ZUtleVxcXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIDEuMS4wXCIpO1xyXG4gICAgcmVhbERhdGFLZXkgPSAndmFsdWUnO1xyXG4gIH0gZWxzZSBpZiAoKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGRhdGFLZXkpKSB7XHJcbiAgICAoMCwgX0xvZ1V0aWxzLndhcm4pKGZhbHNlLCBcIlVzZSBcXFwiZGF0YUtleVxcXCIgdG8gc3BlY2lmeSB0aGUgdmFsdWUgb2YgcGllLFxcbiAgICAgIHRoZSBwcm9wcyBcXFwidmFsdWVLZXlcXFwiIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiAxLjEuMFwiKTtcclxuICAgIHJlYWxEYXRhS2V5ID0gdmFsdWVLZXk7XHJcbiAgfVxyXG4gIHZhciBub3RaZXJvSXRlbUNvdW50ID0gcGllRGF0YS5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICByZXR1cm4gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShlbnRyeSwgcmVhbERhdGFLZXksIDApICE9PSAwO1xyXG4gIH0pLmxlbmd0aDtcclxuICB2YXIgdG90YWxQYWRpbmdBbmdsZSA9IChhYnNEZWx0YUFuZ2xlID49IDM2MCA/IG5vdFplcm9JdGVtQ291bnQgOiBub3RaZXJvSXRlbUNvdW50IC0gMSkgKiBwYWRkaW5nQW5nbGU7XHJcbiAgdmFyIHJlYWxUb3RhbEFuZ2xlID0gYWJzRGVsdGFBbmdsZSAtIG5vdFplcm9JdGVtQ291bnQgKiBtaW5BbmdsZSAtIHRvdGFsUGFkaW5nQW5nbGU7XHJcbiAgdmFyIHN1bSA9IHBpZURhdGEucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGVudHJ5KSB7XHJcbiAgICB2YXIgdmFsID0gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShlbnRyeSwgcmVhbERhdGFLZXksIDApO1xyXG4gICAgcmV0dXJuIHJlc3VsdCArICgoMCwgX0RhdGFVdGlscy5pc051bWJlcikodmFsKSA/IHZhbCA6IDApO1xyXG4gIH0sIDApO1xyXG4gIHZhciBzZWN0b3JzO1xyXG4gIGlmIChzdW0gPiAwKSB7XHJcbiAgICB2YXIgcHJldjtcclxuICAgIHNlY3RvcnMgPSBwaWVEYXRhLm1hcChmdW5jdGlvbiAoZW50cnksIGkpIHtcclxuICAgICAgdmFyIHZhbCA9ICgwLCBfQ2hhcnRVdGlscy5nZXRWYWx1ZUJ5RGF0YUtleSkoZW50cnksIHJlYWxEYXRhS2V5LCAwKTtcclxuICAgICAgdmFyIG5hbWUgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0VmFsdWVCeURhdGFLZXkpKGVudHJ5LCBuYW1lS2V5LCBpKTtcclxuICAgICAgdmFyIHBlcmNlbnQgPSAoKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHZhbCkgPyB2YWwgOiAwKSAvIHN1bTtcclxuICAgICAgdmFyIHRlbXBTdGFydEFuZ2xlO1xyXG4gICAgICBpZiAoaSkge1xyXG4gICAgICAgIHRlbXBTdGFydEFuZ2xlID0gcHJldi5lbmRBbmdsZSArICgwLCBfRGF0YVV0aWxzLm1hdGhTaWduKShkZWx0YUFuZ2xlKSAqIHBhZGRpbmdBbmdsZSAqICh2YWwgIT09IDAgPyAxIDogMCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGVtcFN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB0ZW1wRW5kQW5nbGUgPSB0ZW1wU3RhcnRBbmdsZSArICgwLCBfRGF0YVV0aWxzLm1hdGhTaWduKShkZWx0YUFuZ2xlKSAqICgodmFsICE9PSAwID8gbWluQW5nbGUgOiAwKSArIHBlcmNlbnQgKiByZWFsVG90YWxBbmdsZSk7XHJcbiAgICAgIHZhciBtaWRBbmdsZSA9ICh0ZW1wU3RhcnRBbmdsZSArIHRlbXBFbmRBbmdsZSkgLyAyO1xyXG4gICAgICB2YXIgbWlkZGxlUmFkaXVzID0gKGNvb3JkaW5hdGUuaW5uZXJSYWRpdXMgKyBjb29yZGluYXRlLm91dGVyUmFkaXVzKSAvIDI7XHJcbiAgICAgIHZhciB0b29sdGlwUGF5bG9hZCA9IFt7XHJcbiAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICB2YWx1ZTogdmFsLFxyXG4gICAgICAgIHBheWxvYWQ6IGVudHJ5LFxyXG4gICAgICAgIGRhdGFLZXk6IHJlYWxEYXRhS2V5LFxyXG4gICAgICAgIHR5cGU6IHRvb2x0aXBUeXBlXHJcbiAgICAgIH1dO1xyXG4gICAgICB2YXIgdG9vbHRpcFBvc2l0aW9uID0gKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKGNvb3JkaW5hdGUuY3gsIGNvb3JkaW5hdGUuY3ksIG1pZGRsZVJhZGl1cywgbWlkQW5nbGUpO1xyXG4gICAgICBwcmV2ID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xyXG4gICAgICAgIHBlcmNlbnQ6IHBlcmNlbnQsXHJcbiAgICAgICAgY29ybmVyUmFkaXVzOiBjb3JuZXJSYWRpdXMsXHJcbiAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICB0b29sdGlwUGF5bG9hZDogdG9vbHRpcFBheWxvYWQsXHJcbiAgICAgICAgbWlkQW5nbGU6IG1pZEFuZ2xlLFxyXG4gICAgICAgIG1pZGRsZVJhZGl1czogbWlkZGxlUmFkaXVzLFxyXG4gICAgICAgIHRvb2x0aXBQb3NpdGlvbjogdG9vbHRpcFBvc2l0aW9uXHJcbiAgICAgIH0sIGVudHJ5KSwgY29vcmRpbmF0ZSksIHt9LCB7XHJcbiAgICAgICAgdmFsdWU6ICgwLCBfQ2hhcnRVdGlscy5nZXRWYWx1ZUJ5RGF0YUtleSkoZW50cnksIHJlYWxEYXRhS2V5KSxcclxuICAgICAgICBzdGFydEFuZ2xlOiB0ZW1wU3RhcnRBbmdsZSxcclxuICAgICAgICBlbmRBbmdsZTogdGVtcEVuZEFuZ2xlLFxyXG4gICAgICAgIHBheWxvYWQ6IGVudHJ5LFxyXG4gICAgICAgIHBhZGRpbmdBbmdsZTogKDAsIF9EYXRhVXRpbHMubWF0aFNpZ24pKGRlbHRhQW5nbGUpICogcGFkZGluZ0FuZ2xlXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gcHJldjtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjb29yZGluYXRlKSwge30sIHtcclxuICAgIHNlY3RvcnM6IHNlY3RvcnMsXHJcbiAgICBkYXRhOiBwaWVEYXRhXHJcbiAgfSk7XHJcbn0pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlBpZSIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9yZWFjdFNtb290aCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfZ2V0IiwiX2lzRXF1YWwiLCJfaXNOaWwiLCJfaXNGdW5jdGlvbiIsIl9jbHN4IiwiX0xheWVyIiwiX0N1cnZlIiwiX1RleHQiLCJfTGFiZWwiLCJfTGFiZWxMaXN0IiwiX0NlbGwiLCJfUmVhY3RVdGlscyIsIl9HbG9iYWwiLCJfUG9sYXJVdGlscyIsIl9EYXRhVXRpbHMiLCJfQ2hhcnRVdGlscyIsIl9Mb2dVdGlscyIsIl90eXBlcyIsIl9BY3RpdmVTaGFwZVV0aWxzIiwiX1BpZSIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX3R5cGVvZiIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJhcHBseSIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9Qcm9wZXJ0eUtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsInAiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsIl9QdXJlQ29tcG9uZW50IiwiX3RoaXMiLCJ1bmlxdWVJZCIsIm9uQW5pbWF0aW9uRW5kIiwic2V0U3RhdGUiLCJpc0FuaW1hdGlvbkZpbmlzaGVkIiwib25BbmltYXRpb25TdGFydCIsInN0YXRlIiwiaXNBbmltYXRpb25BY3RpdmUiLCJwcmV2SXNBbmltYXRpb25BY3RpdmUiLCJwcmV2QW5pbWF0aW9uSWQiLCJhbmltYXRpb25JZCIsInNlY3RvclRvRm9jdXMiLCJpc0FjdGl2ZUluZGV4IiwiYWN0aXZlSW5kZXgiLCJBcnJheSIsImlzQXJyYXkiLCJpbmRleE9mIiwiaGFzQWN0aXZlSW5kZXgiLCJyZW5kZXJMYWJlbHMiLCJzZWN0b3JzIiwiX3RoaXMkcHJvcHMiLCJsYWJlbCIsImxhYmVsTGluZSIsImRhdGFLZXkiLCJ2YWx1ZUtleSIsInBpZVByb3BzIiwiZmlsdGVyUHJvcHMiLCJjdXN0b21MYWJlbFByb3BzIiwiY3VzdG9tTGFiZWxMaW5lUHJvcHMiLCJvZmZzZXRSYWRpdXMiLCJsYWJlbHMiLCJtYXAiLCJlbnRyeSIsIm1pZEFuZ2xlIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiZW5kUG9pbnQiLCJwb2xhclRvQ2FydGVzaWFuIiwiY3giLCJjeSIsIm91dGVyUmFkaXVzIiwibGFiZWxQcm9wcyIsInN0cm9rZSIsImluZGV4IiwidGV4dEFuY2hvciIsImdldFRleHRBbmNob3IiLCJ4IiwibGluZVByb3BzIiwiZmlsbCIsInBvaW50cyIsInJlYWxEYXRhS2V5IiwiY3JlYXRlRWxlbWVudCIsIkxheWVyIiwiY29uY2F0IiwicmVuZGVyTGFiZWxMaW5lSXRlbSIsInJlbmRlckxhYmVsSXRlbSIsImdldFZhbHVlQnlEYXRhS2V5IiwiY2xhc3NOYW1lIiwicmVuZGVyU2VjdG9yc1N0YXRpY2FsbHkiLCJfdGhpczIiLCJfdGhpcyRwcm9wczIiLCJhY3RpdmVTaGFwZSIsImJsZW5kU3Ryb2tlIiwiaW5hY3RpdmVTaGFwZVByb3AiLCJpbmFjdGl2ZVNoYXBlIiwiaXNBY3RpdmUiLCJzZWN0b3JPcHRpb25zIiwic2VjdG9yUHJvcHMiLCJ0YWJJbmRleCIsInJlZiIsIl9yZWYiLCJzZWN0b3JSZWZzIiwiaW5jbHVkZXMiLCJhZGFwdEV2ZW50c09mQ2hpbGQiLCJTaGFwZSIsIm9wdGlvbiIsInNoYXBlVHlwZSIsInJlbmRlclNlY3RvcnNXaXRoQW5pbWF0aW9uIiwiX3RoaXMzIiwiX3RoaXMkcHJvcHMzIiwiYW5pbWF0aW9uQmVnaW4iLCJhbmltYXRpb25EdXJhdGlvbiIsImFuaW1hdGlvbkVhc2luZyIsIl90aGlzJHN0YXRlIiwicHJldlNlY3RvcnMiLCJiZWdpbiIsImR1cmF0aW9uIiwiZWFzaW5nIiwiZnJvbSIsInRvIiwiaGFuZGxlQW5pbWF0aW9uU3RhcnQiLCJoYW5kbGVBbmltYXRpb25FbmQiLCJfcmVmMiIsInN0ZXBEYXRhIiwiZmlyc3QiLCJjdXJBbmdsZSIsInByZXYiLCJwYWRkaW5nQW5nbGUiLCJhbmdsZUlwIiwiaW50ZXJwb2xhdGVOdW1iZXIiLCJsYXRlc3QiLCJpbnRlcnBvbGF0b3JBbmdsZSIsImRlbHRhQW5nbGUiLCJfbGF0ZXN0IiwiYXR0YWNoS2V5Ym9hcmRIYW5kbGVycyIsInBpZVJlZiIsIl90aGlzNCIsIm9ua2V5ZG93biIsImFsdEtleSIsIm5leHQiLCJmb2N1cyIsIl9uZXh0IiwiYmx1ciIsInJlbmRlclNlY3RvcnMiLCJfdGhpcyRwcm9wczQiLCJjb21wb25lbnREaWRNb3VudCIsInJlbmRlciIsIl90aGlzNSIsIl90aGlzJHByb3BzNSIsImhpZGUiLCJpbm5lclJhZGl1cyIsImlzTnVtYmVyIiwibGF5ZXJDbGFzcyIsInJvb3RUYWJJbmRleCIsIl9yZWYzIiwiTGFiZWwiLCJyZW5kZXJDYWxsQnlQYXJlbnQiLCJMYWJlbExpc3QiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJuZXh0UHJvcHMiLCJwcmV2U3RhdGUiLCJjdXJTZWN0b3JzIiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJDdXJ2ZSIsInR5cGUiLCJUZXh0IiwiYWxpZ25tZW50QmFzZWxpbmUiLCJQdXJlQ29tcG9uZW50IiwibGVnZW5kVHlwZSIsIm1pbkFuZ2xlIiwiR2xvYmFsIiwiaXNTc3IiLCJuYW1lS2V5Iiwic2lnbiIsIm1hdGhTaWduIiwiTWF0aCIsIm1pbiIsImFicyIsIml0ZW1Qcm9wcyIsImRhdGEiLCJjaGlsZHJlbiIsInByZXNlbnRhdGlvblByb3BzIiwiY2VsbHMiLCJmaW5kQWxsQnlUeXBlIiwiQ2VsbCIsInBheWxvYWQiLCJjZWxsIiwib2Zmc2V0IiwidG9wIiwibGVmdCIsIndpZHRoIiwiaGVpZ2h0IiwibWF4UGllUmFkaXVzIiwiZ2V0TWF4UmFkaXVzIiwiZ2V0UGVyY2VudFZhbHVlIiwibWF4UmFkaXVzIiwic3FydCIsIl9yZWY0IiwiaXRlbSIsImRlZmF1bHRQcm9wcyIsInVuZGVmaW5lZCIsInBpZURhdGEiLCJnZXRSZWFsUGllRGF0YSIsImNvcm5lclJhZGl1cyIsInRvb2x0aXBUeXBlIiwiY29vcmRpbmF0ZSIsInBhcnNlQ29vcmRpbmF0ZU9mUGllIiwicGFyc2VEZWx0YUFuZ2xlIiwiYWJzRGVsdGFBbmdsZSIsIndhcm4iLCJub3RaZXJvSXRlbUNvdW50IiwidG90YWxQYWRpbmdBbmdsZSIsInJlYWxUb3RhbEFuZ2xlIiwic3VtIiwicmVkdWNlIiwicmVzdWx0IiwidmFsIiwibmFtZSIsInBlcmNlbnQiLCJ0ZW1wU3RhcnRBbmdsZSIsInRlbXBFbmRBbmdsZSIsIm1pZGRsZVJhZGl1cyIsInRvb2x0aXBQYXlsb2FkIiwidG9vbHRpcFBvc2l0aW9uIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/polar/Pie.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/polar/PolarAngleAxis.js":
/*!***********************************************************!*\
  !*** ./node_modules/recharts/lib/polar/PolarAngleAxis.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PolarAngleAxis = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _Dot = __webpack_require__(/*! ../shape/Dot */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Dot.js\");\nvar _Polygon = __webpack_require__(/*! ../shape/Polygon */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Polygon.js\");\nvar _Text = __webpack_require__(/*! ../component/Text */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Text.js\");\nvar _types = __webpack_require__(/*! ../util/types */ \"(pages-dir-node)/./node_modules/recharts/lib/util/types.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/PolarUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Axis of radial direction\r\n */ \nvar RADIAN = Math.PI / 180;\nvar eps = 1e-5;\nvar PolarAngleAxis = exports.PolarAngleAxis = /*#__PURE__*/ function(_PureComponent) {\n    function PolarAngleAxis() {\n        _classCallCheck(this, PolarAngleAxis);\n        return _callSuper(this, PolarAngleAxis, arguments);\n    }\n    _inherits(PolarAngleAxis, _PureComponent);\n    return _createClass(PolarAngleAxis, [\n        {\n            key: \"getTickLineCoord\",\n            value: /**\r\n     * Calculate the coordinate of line endpoint\r\n     * @param  {Object} data The Data if ticks\r\n     * @return {Object} (x0, y0): The start point of text,\r\n     *                  (x1, y1): The end point close to text,\r\n     *                  (x2, y2): The end point close to axis\r\n     */ function getTickLineCoord(data) {\n                var _this$props = this.props, cx = _this$props.cx, cy = _this$props.cy, radius = _this$props.radius, orientation = _this$props.orientation, tickSize = _this$props.tickSize;\n                var tickLineSize = tickSize || 8;\n                var p1 = (0, _PolarUtils.polarToCartesian)(cx, cy, radius, data.coordinate);\n                var p2 = (0, _PolarUtils.polarToCartesian)(cx, cy, radius + (orientation === 'inner' ? -1 : 1) * tickLineSize, data.coordinate);\n                return {\n                    x1: p1.x,\n                    y1: p1.y,\n                    x2: p2.x,\n                    y2: p2.y\n                };\n            }\n        },\n        {\n            key: \"getTickTextAnchor\",\n            value: function getTickTextAnchor(data) {\n                var orientation = this.props.orientation;\n                var cos = Math.cos(-data.coordinate * RADIAN);\n                var textAnchor;\n                if (cos > eps) {\n                    textAnchor = orientation === 'outer' ? 'start' : 'end';\n                } else if (cos < -eps) {\n                    textAnchor = orientation === 'outer' ? 'end' : 'start';\n                } else {\n                    textAnchor = 'middle';\n                }\n                return textAnchor;\n            }\n        },\n        {\n            key: \"renderAxisLine\",\n            value: function renderAxisLine() {\n                var _this$props2 = this.props, cx = _this$props2.cx, cy = _this$props2.cy, radius = _this$props2.radius, axisLine = _this$props2.axisLine, axisLineType = _this$props2.axisLineType;\n                var props = _objectSpread(_objectSpread({}, (0, _ReactUtils.filterProps)(this.props, false)), {}, {\n                    fill: 'none'\n                }, (0, _ReactUtils.filterProps)(axisLine, false));\n                if (axisLineType === 'circle') {\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Dot.Dot, _extends({\n                        className: \"recharts-polar-angle-axis-line\"\n                    }, props, {\n                        cx: cx,\n                        cy: cy,\n                        r: radius\n                    }));\n                }\n                var ticks = this.props.ticks;\n                var points = ticks.map(function(entry) {\n                    return (0, _PolarUtils.polarToCartesian)(cx, cy, radius, entry.coordinate);\n                });\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Polygon.Polygon, _extends({\n                    className: \"recharts-polar-angle-axis-line\"\n                }, props, {\n                    points: points\n                }));\n            }\n        },\n        {\n            key: \"renderTicks\",\n            value: function renderTicks() {\n                var _this = this;\n                var _this$props3 = this.props, ticks = _this$props3.ticks, tick = _this$props3.tick, tickLine = _this$props3.tickLine, tickFormatter = _this$props3.tickFormatter, stroke = _this$props3.stroke;\n                var axisProps = (0, _ReactUtils.filterProps)(this.props, false);\n                var customTickProps = (0, _ReactUtils.filterProps)(tick, false);\n                var tickLineProps = _objectSpread(_objectSpread({}, axisProps), {}, {\n                    fill: 'none'\n                }, (0, _ReactUtils.filterProps)(tickLine, false));\n                var items = ticks.map(function(entry, i) {\n                    var lineCoord = _this.getTickLineCoord(entry);\n                    var textAnchor = _this.getTickTextAnchor(entry);\n                    var tickProps = _objectSpread(_objectSpread(_objectSpread({\n                        textAnchor: textAnchor\n                    }, axisProps), {}, {\n                        stroke: 'none',\n                        fill: stroke\n                    }, customTickProps), {}, {\n                        index: i,\n                        payload: entry,\n                        x: lineCoord.x2,\n                        y: lineCoord.y2\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                        className: (0, _clsx[\"default\"])('recharts-polar-angle-axis-tick', (0, _PolarUtils.getTickClassName)(tick)),\n                        key: \"tick-\".concat(entry.coordinate)\n                    }, (0, _types.adaptEventsOfChild)(_this.props, entry, i)), tickLine && /*#__PURE__*/ _react[\"default\"].createElement(\"line\", _extends({\n                        className: \"recharts-polar-angle-axis-tick-line\"\n                    }, tickLineProps, lineCoord)), tick && PolarAngleAxis.renderTickItem(tick, tickProps, tickFormatter ? tickFormatter(entry.value, i) : entry.value));\n                });\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-polar-angle-axis-ticks\"\n                }, items);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props4 = this.props, ticks = _this$props4.ticks, radius = _this$props4.radius, axisLine = _this$props4.axisLine;\n                if (radius <= 0 || !ticks || !ticks.length) {\n                    return null;\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: (0, _clsx[\"default\"])('recharts-polar-angle-axis', this.props.className)\n                }, axisLine && this.renderAxisLine(), this.renderTicks());\n            }\n        }\n    ], [\n        {\n            key: \"renderTickItem\",\n            value: function renderTickItem(option, props, value) {\n                var tickItem;\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n                    tickItem = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n                } else if ((0, _isFunction[\"default\"])(option)) {\n                    tickItem = option(props);\n                } else {\n                    tickItem = /*#__PURE__*/ _react[\"default\"].createElement(_Text.Text, _extends({}, props, {\n                        className: \"recharts-polar-angle-axis-tick-value\"\n                    }), value);\n                }\n                return tickItem;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(PolarAngleAxis, \"displayName\", 'PolarAngleAxis');\n_defineProperty(PolarAngleAxis, \"axisType\", 'angleAxis');\n_defineProperty(PolarAngleAxis, \"defaultProps\", {\n    type: 'category',\n    angleAxisId: 0,\n    scale: 'auto',\n    cx: 0,\n    cy: 0,\n    orientation: 'outer',\n    axisLine: true,\n    tickLine: true,\n    tickSize: 8,\n    tick: true,\n    hide: false,\n    allowDuplicatedCategory: true\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvcG9sYXIvUG9sYXJBbmdsZUF4aXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELHNCQUFzQixHQUFHLEtBQUs7QUFDOUIsSUFBSUcsU0FBU0Msd0JBQXdCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNwRCxJQUFJQyxjQUFjQyx1QkFBdUJGLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJRyxRQUFRRCx1QkFBdUJGLG1CQUFPQSxDQUFDLHVCQUFNO0FBQ2pELElBQUlJLFNBQVNKLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUN6QyxJQUFJSyxPQUFPTCxtQkFBT0EsQ0FBQywrRUFBYztBQUNqQyxJQUFJTSxXQUFXTixtQkFBT0EsQ0FBQyx1RkFBa0I7QUFDekMsSUFBSU8sUUFBUVAsbUJBQU9BLENBQUMseUZBQW1CO0FBQ3ZDLElBQUlRLFNBQVNSLG1CQUFPQSxDQUFDLGlGQUFlO0FBQ3BDLElBQUlTLGNBQWNULG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM5QyxJQUFJVSxjQUFjVixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDOUMsU0FBU0UsdUJBQXVCUyxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFLHlCQUF5QkMsQ0FBQztJQUFJLElBQUksY0FBYyxPQUFPQyxTQUFTLE9BQU87SUFBTSxJQUFJQyxJQUFJLElBQUlELFdBQVdFLElBQUksSUFBSUY7SUFBVyxPQUFPLENBQUNGLDJCQUEyQixTQUFTQSx5QkFBeUJDLENBQUM7UUFBSSxPQUFPQSxJQUFJRyxJQUFJRDtJQUFHLEdBQUdGO0FBQUk7QUFDbk8sU0FBU2Ysd0JBQXdCZSxDQUFDLEVBQUVFLENBQUM7SUFBSSxJQUFJLENBQUNBLEtBQUtGLEtBQUtBLEVBQUVGLFVBQVUsRUFB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RTNILFNBQVMsQ0FBQyxHQUFHeUIsT0FBTzt3QkFDdEZrRSxXQUFXO29CQUNiLElBQUlqSTtnQkFDTjtnQkFDQSxPQUFPOEo7WUFDVDtRQUNGO0tBQUU7QUFDSixFQUFFNUosT0FBT2dLLGFBQWE7QUFDdEIzRyxnQkFBZ0J0RCxnQkFBZ0IsZUFBZTtBQUMvQ3NELGdCQUFnQnRELGdCQUFnQixZQUFZO0FBQzVDc0QsZ0JBQWdCdEQsZ0JBQWdCLGdCQUFnQjtJQUM5Q2tLLE1BQU07SUFDTkMsYUFBYTtJQUNiQyxPQUFPO0lBQ1AvRCxJQUFJO0lBQ0pDLElBQUk7SUFDSkUsYUFBYTtJQUNia0IsVUFBVTtJQUNWZ0IsVUFBVTtJQUNWakMsVUFBVTtJQUNWZ0MsTUFBTTtJQUNONEIsTUFBTTtJQUNOQyx5QkFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXHBvbGFyXFxQb2xhckFuZ2xlQXhpcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLlBvbGFyQW5nbGVBeGlzID0gdm9pZCAwO1xyXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xyXG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcclxudmFyIF9MYXllciA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvTGF5ZXJcIik7XHJcbnZhciBfRG90ID0gcmVxdWlyZShcIi4uL3NoYXBlL0RvdFwiKTtcclxudmFyIF9Qb2x5Z29uID0gcmVxdWlyZShcIi4uL3NoYXBlL1BvbHlnb25cIik7XHJcbnZhciBfVGV4dCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQvVGV4dFwiKTtcclxudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuLi91dGlsL3R5cGVzXCIpO1xyXG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xyXG52YXIgX1BvbGFyVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9Qb2xhclV0aWxzXCIpO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cclxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cclxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cclxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cclxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XHJcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxyXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cclxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cclxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cclxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cclxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxyXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfSAvKipcclxuICogQGZpbGVPdmVydmlldyBBeGlzIG9mIHJhZGlhbCBkaXJlY3Rpb25cclxuICovXHJcbnZhciBSQURJQU4gPSBNYXRoLlBJIC8gMTgwO1xyXG52YXIgZXBzID0gMWUtNTtcclxudmFyIFBvbGFyQW5nbGVBeGlzID0gZXhwb3J0cy5Qb2xhckFuZ2xlQXhpcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1B1cmVDb21wb25lbnQpIHtcclxuICBmdW5jdGlvbiBQb2xhckFuZ2xlQXhpcygpIHtcclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb2xhckFuZ2xlQXhpcyk7XHJcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBQb2xhckFuZ2xlQXhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcbiAgX2luaGVyaXRzKFBvbGFyQW5nbGVBeGlzLCBfUHVyZUNvbXBvbmVudCk7XHJcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhQb2xhckFuZ2xlQXhpcywgW3tcclxuICAgIGtleTogXCJnZXRUaWNrTGluZUNvb3JkXCIsXHJcbiAgICB2YWx1ZTpcclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb29yZGluYXRlIG9mIGxpbmUgZW5kcG9pbnRcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZGF0YSBUaGUgRGF0YSBpZiB0aWNrc1xyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAoeDAsIHkwKTogVGhlIHN0YXJ0IHBvaW50IG9mIHRleHQsXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICh4MSwgeTEpOiBUaGUgZW5kIHBvaW50IGNsb3NlIHRvIHRleHQsXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICh4MiwgeTIpOiBUaGUgZW5kIHBvaW50IGNsb3NlIHRvIGF4aXNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0VGlja0xpbmVDb29yZChkYXRhKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgY3ggPSBfdGhpcyRwcm9wcy5jeCxcclxuICAgICAgICBjeSA9IF90aGlzJHByb3BzLmN5LFxyXG4gICAgICAgIHJhZGl1cyA9IF90aGlzJHByb3BzLnJhZGl1cyxcclxuICAgICAgICBvcmllbnRhdGlvbiA9IF90aGlzJHByb3BzLm9yaWVudGF0aW9uLFxyXG4gICAgICAgIHRpY2tTaXplID0gX3RoaXMkcHJvcHMudGlja1NpemU7XHJcbiAgICAgIHZhciB0aWNrTGluZVNpemUgPSB0aWNrU2l6ZSB8fCA4O1xyXG4gICAgICB2YXIgcDEgPSAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikoY3gsIGN5LCByYWRpdXMsIGRhdGEuY29vcmRpbmF0ZSk7XHJcbiAgICAgIHZhciBwMiA9ICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjeCwgY3ksIHJhZGl1cyArIChvcmllbnRhdGlvbiA9PT0gJ2lubmVyJyA/IC0xIDogMSkgKiB0aWNrTGluZVNpemUsIGRhdGEuY29vcmRpbmF0ZSk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgeDE6IHAxLngsXHJcbiAgICAgICAgeTE6IHAxLnksXHJcbiAgICAgICAgeDI6IHAyLngsXHJcbiAgICAgICAgeTI6IHAyLnlcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgdGV4dC1hbmNob3Igb2YgZWFjaCB0aWNrXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGEgRGF0YSBvZiB0aWNrc1xyXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0ZXh0LWFuY2hvclxyXG4gICAgICovXHJcbiAgfSwge1xyXG4gICAga2V5OiBcImdldFRpY2tUZXh0QW5jaG9yXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGlja1RleHRBbmNob3IoZGF0YSkge1xyXG4gICAgICB2YXIgb3JpZW50YXRpb24gPSB0aGlzLnByb3BzLm9yaWVudGF0aW9uO1xyXG4gICAgICB2YXIgY29zID0gTWF0aC5jb3MoLWRhdGEuY29vcmRpbmF0ZSAqIFJBRElBTik7XHJcbiAgICAgIHZhciB0ZXh0QW5jaG9yO1xyXG4gICAgICBpZiAoY29zID4gZXBzKSB7XHJcbiAgICAgICAgdGV4dEFuY2hvciA9IG9yaWVudGF0aW9uID09PSAnb3V0ZXInID8gJ3N0YXJ0JyA6ICdlbmQnO1xyXG4gICAgICB9IGVsc2UgaWYgKGNvcyA8IC1lcHMpIHtcclxuICAgICAgICB0ZXh0QW5jaG9yID0gb3JpZW50YXRpb24gPT09ICdvdXRlcicgPyAnZW5kJyA6ICdzdGFydCc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGV4dEFuY2hvciA9ICdtaWRkbGUnO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0ZXh0QW5jaG9yO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJBeGlzTGluZVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckF4aXNMaW5lKCkge1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBjeCA9IF90aGlzJHByb3BzMi5jeCxcclxuICAgICAgICBjeSA9IF90aGlzJHByb3BzMi5jeSxcclxuICAgICAgICByYWRpdXMgPSBfdGhpcyRwcm9wczIucmFkaXVzLFxyXG4gICAgICAgIGF4aXNMaW5lID0gX3RoaXMkcHJvcHMyLmF4aXNMaW5lLFxyXG4gICAgICAgIGF4aXNMaW5lVHlwZSA9IF90aGlzJHByb3BzMi5heGlzTGluZVR5cGU7XHJcbiAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0aGlzLnByb3BzLCBmYWxzZSkpLCB7fSwge1xyXG4gICAgICAgIGZpbGw6ICdub25lJ1xyXG4gICAgICB9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKGF4aXNMaW5lLCBmYWxzZSkpO1xyXG4gICAgICBpZiAoYXhpc0xpbmVUeXBlID09PSAnY2lyY2xlJykge1xyXG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9Eb3QuRG90LCBfZXh0ZW5kcyh7XHJcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtcG9sYXItYW5nbGUtYXhpcy1saW5lXCJcclxuICAgICAgICB9LCBwcm9wcywge1xyXG4gICAgICAgICAgY3g6IGN4LFxyXG4gICAgICAgICAgY3k6IGN5LFxyXG4gICAgICAgICAgcjogcmFkaXVzXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB0aWNrcyA9IHRoaXMucHJvcHMudGlja3M7XHJcbiAgICAgIHZhciBwb2ludHMgPSB0aWNrcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgcmV0dXJuICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjeCwgY3ksIHJhZGl1cywgZW50cnkuY29vcmRpbmF0ZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfUG9seWdvbi5Qb2x5Z29uLCBfZXh0ZW5kcyh7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXBvbGFyLWFuZ2xlLWF4aXMtbGluZVwiXHJcbiAgICAgIH0sIHByb3BzLCB7XHJcbiAgICAgICAgcG9pbnRzOiBwb2ludHNcclxuICAgICAgfSkpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJUaWNrc1wiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclRpY2tzKCkge1xyXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcyxcclxuICAgICAgICB0aWNrcyA9IF90aGlzJHByb3BzMy50aWNrcyxcclxuICAgICAgICB0aWNrID0gX3RoaXMkcHJvcHMzLnRpY2ssXHJcbiAgICAgICAgdGlja0xpbmUgPSBfdGhpcyRwcm9wczMudGlja0xpbmUsXHJcbiAgICAgICAgdGlja0Zvcm1hdHRlciA9IF90aGlzJHByb3BzMy50aWNrRm9ybWF0dGVyLFxyXG4gICAgICAgIHN0cm9rZSA9IF90aGlzJHByb3BzMy5zdHJva2U7XHJcbiAgICAgIHZhciBheGlzUHJvcHMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRoaXMucHJvcHMsIGZhbHNlKTtcclxuICAgICAgdmFyIGN1c3RvbVRpY2tQcm9wcyA9ICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykodGljaywgZmFsc2UpO1xyXG4gICAgICB2YXIgdGlja0xpbmVQcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgYXhpc1Byb3BzKSwge30sIHtcclxuICAgICAgICBmaWxsOiAnbm9uZSdcclxuICAgICAgfSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0aWNrTGluZSwgZmFsc2UpKTtcclxuICAgICAgdmFyIGl0ZW1zID0gdGlja3MubWFwKGZ1bmN0aW9uIChlbnRyeSwgaSkge1xyXG4gICAgICAgIHZhciBsaW5lQ29vcmQgPSBfdGhpcy5nZXRUaWNrTGluZUNvb3JkKGVudHJ5KTtcclxuICAgICAgICB2YXIgdGV4dEFuY2hvciA9IF90aGlzLmdldFRpY2tUZXh0QW5jaG9yKGVudHJ5KTtcclxuICAgICAgICB2YXIgdGlja1Byb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xyXG4gICAgICAgICAgdGV4dEFuY2hvcjogdGV4dEFuY2hvclxyXG4gICAgICAgIH0sIGF4aXNQcm9wcyksIHt9LCB7XHJcbiAgICAgICAgICBzdHJva2U6ICdub25lJyxcclxuICAgICAgICAgIGZpbGw6IHN0cm9rZVxyXG4gICAgICAgIH0sIGN1c3RvbVRpY2tQcm9wcyksIHt9LCB7XHJcbiAgICAgICAgICBpbmRleDogaSxcclxuICAgICAgICAgIHBheWxvYWQ6IGVudHJ5LFxyXG4gICAgICAgICAgeDogbGluZUNvb3JkLngyLFxyXG4gICAgICAgICAgeTogbGluZUNvb3JkLnkyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCBfZXh0ZW5kcyh7XHJcbiAgICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1wb2xhci1hbmdsZS1heGlzLXRpY2snLCAoMCwgX1BvbGFyVXRpbHMuZ2V0VGlja0NsYXNzTmFtZSkodGljaykpLFxyXG4gICAgICAgICAga2V5OiBcInRpY2stXCIuY29uY2F0KGVudHJ5LmNvb3JkaW5hdGUpXHJcbiAgICAgICAgfSwgKDAsIF90eXBlcy5hZGFwdEV2ZW50c09mQ2hpbGQpKF90aGlzLnByb3BzLCBlbnRyeSwgaSkpLCB0aWNrTGluZSAmJiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwibGluZVwiLCBfZXh0ZW5kcyh7XHJcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtcG9sYXItYW5nbGUtYXhpcy10aWNrLWxpbmVcIlxyXG4gICAgICAgIH0sIHRpY2tMaW5lUHJvcHMsIGxpbmVDb29yZCkpLCB0aWNrICYmIFBvbGFyQW5nbGVBeGlzLnJlbmRlclRpY2tJdGVtKHRpY2ssIHRpY2tQcm9wcywgdGlja0Zvcm1hdHRlciA/IHRpY2tGb3JtYXR0ZXIoZW50cnkudmFsdWUsIGkpIDogZW50cnkudmFsdWUpKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xyXG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1wb2xhci1hbmdsZS1heGlzLXRpY2tzXCJcclxuICAgICAgfSwgaXRlbXMpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIHRpY2tzID0gX3RoaXMkcHJvcHM0LnRpY2tzLFxyXG4gICAgICAgIHJhZGl1cyA9IF90aGlzJHByb3BzNC5yYWRpdXMsXHJcbiAgICAgICAgYXhpc0xpbmUgPSBfdGhpcyRwcm9wczQuYXhpc0xpbmU7XHJcbiAgICAgIGlmIChyYWRpdXMgPD0gMCB8fCAhdGlja3MgfHwgIXRpY2tzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xyXG4gICAgICAgIGNsYXNzTmFtZTogKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXBvbGFyLWFuZ2xlLWF4aXMnLCB0aGlzLnByb3BzLmNsYXNzTmFtZSlcclxuICAgICAgfSwgYXhpc0xpbmUgJiYgdGhpcy5yZW5kZXJBeGlzTGluZSgpLCB0aGlzLnJlbmRlclRpY2tzKCkpO1xyXG4gICAgfVxyXG4gIH1dLCBbe1xyXG4gICAga2V5OiBcInJlbmRlclRpY2tJdGVtXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVGlja0l0ZW0ob3B0aW9uLCBwcm9wcywgdmFsdWUpIHtcclxuICAgICAgdmFyIHRpY2tJdGVtO1xyXG4gICAgICBpZiAoIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KG9wdGlvbikpIHtcclxuICAgICAgICB0aWNrSXRlbSA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChvcHRpb24sIHByb3BzKTtcclxuICAgICAgfSBlbHNlIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvcHRpb24pKSB7XHJcbiAgICAgICAgdGlja0l0ZW0gPSBvcHRpb24ocHJvcHMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRpY2tJdGVtID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfVGV4dC5UZXh0LCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcclxuICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1wb2xhci1hbmdsZS1heGlzLXRpY2stdmFsdWVcIlxyXG4gICAgICAgIH0pLCB2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRpY2tJdGVtO1xyXG4gICAgfVxyXG4gIH1dKTtcclxufShfcmVhY3QuUHVyZUNvbXBvbmVudCk7XHJcbl9kZWZpbmVQcm9wZXJ0eShQb2xhckFuZ2xlQXhpcywgXCJkaXNwbGF5TmFtZVwiLCAnUG9sYXJBbmdsZUF4aXMnKTtcclxuX2RlZmluZVByb3BlcnR5KFBvbGFyQW5nbGVBeGlzLCBcImF4aXNUeXBlXCIsICdhbmdsZUF4aXMnKTtcclxuX2RlZmluZVByb3BlcnR5KFBvbGFyQW5nbGVBeGlzLCBcImRlZmF1bHRQcm9wc1wiLCB7XHJcbiAgdHlwZTogJ2NhdGVnb3J5JyxcclxuICBhbmdsZUF4aXNJZDogMCxcclxuICBzY2FsZTogJ2F1dG8nLFxyXG4gIGN4OiAwLFxyXG4gIGN5OiAwLFxyXG4gIG9yaWVudGF0aW9uOiAnb3V0ZXInLFxyXG4gIGF4aXNMaW5lOiB0cnVlLFxyXG4gIHRpY2tMaW5lOiB0cnVlLFxyXG4gIHRpY2tTaXplOiA4LFxyXG4gIHRpY2s6IHRydWUsXHJcbiAgaGlkZTogZmFsc2UsXHJcbiAgYWxsb3dEdXBsaWNhdGVkQ2F0ZWdvcnk6IHRydWVcclxufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUG9sYXJBbmdsZUF4aXMiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfaXNGdW5jdGlvbiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfY2xzeCIsIl9MYXllciIsIl9Eb3QiLCJfUG9seWdvbiIsIl9UZXh0IiwiX3R5cGVzIiwiX1JlYWN0VXRpbHMiLCJfUG9sYXJVdGlscyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX3R5cGVvZiIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJhcHBseSIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9Qcm9wZXJ0eUtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsInAiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsIlJBRElBTiIsIk1hdGgiLCJQSSIsImVwcyIsIl9QdXJlQ29tcG9uZW50IiwiZ2V0VGlja0xpbmVDb29yZCIsImRhdGEiLCJfdGhpcyRwcm9wcyIsImN4IiwiY3kiLCJyYWRpdXMiLCJvcmllbnRhdGlvbiIsInRpY2tTaXplIiwidGlja0xpbmVTaXplIiwicDEiLCJwb2xhclRvQ2FydGVzaWFuIiwiY29vcmRpbmF0ZSIsInAyIiwieDEiLCJ4IiwieTEiLCJ5IiwieDIiLCJ5MiIsImdldFRpY2tUZXh0QW5jaG9yIiwiY29zIiwidGV4dEFuY2hvciIsInJlbmRlckF4aXNMaW5lIiwiX3RoaXMkcHJvcHMyIiwiYXhpc0xpbmUiLCJheGlzTGluZVR5cGUiLCJmaWx0ZXJQcm9wcyIsImZpbGwiLCJjcmVhdGVFbGVtZW50IiwiRG90IiwiY2xhc3NOYW1lIiwidGlja3MiLCJwb2ludHMiLCJtYXAiLCJlbnRyeSIsIlBvbHlnb24iLCJyZW5kZXJUaWNrcyIsIl90aGlzIiwiX3RoaXMkcHJvcHMzIiwidGljayIsInRpY2tMaW5lIiwidGlja0Zvcm1hdHRlciIsInN0cm9rZSIsImF4aXNQcm9wcyIsImN1c3RvbVRpY2tQcm9wcyIsInRpY2tMaW5lUHJvcHMiLCJpdGVtcyIsImxpbmVDb29yZCIsInRpY2tQcm9wcyIsImluZGV4IiwicGF5bG9hZCIsIkxheWVyIiwiZ2V0VGlja0NsYXNzTmFtZSIsImNvbmNhdCIsImFkYXB0RXZlbnRzT2ZDaGlsZCIsInJlbmRlclRpY2tJdGVtIiwicmVuZGVyIiwiX3RoaXMkcHJvcHM0Iiwib3B0aW9uIiwidGlja0l0ZW0iLCJpc1ZhbGlkRWxlbWVudCIsImNsb25lRWxlbWVudCIsIlRleHQiLCJQdXJlQ29tcG9uZW50IiwidHlwZSIsImFuZ2xlQXhpc0lkIiwic2NhbGUiLCJoaWRlIiwiYWxsb3dEdXBsaWNhdGVkQ2F0ZWdvcnkiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/polar/PolarAngleAxis.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/polar/PolarGrid.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/polar/PolarGrid.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PolarGrid = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"cx\",\n    \"cy\",\n    \"innerRadius\",\n    \"outerRadius\",\n    \"gridType\",\n    \"radialLines\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Polar Grid\r\n */ \nvar getPolygonPath = function getPolygonPath(radius, cx, cy, polarAngles) {\n    var path = '';\n    polarAngles.forEach(function(angle, i) {\n        var point = (0, _PolarUtils.polarToCartesian)(cx, cy, radius, angle);\n        if (i) {\n            path += \"L \".concat(point.x, \",\").concat(point.y);\n        } else {\n            path += \"M \".concat(point.x, \",\").concat(point.y);\n        }\n    });\n    path += 'Z';\n    return path;\n};\n// Draw axis of radial line\nvar PolarAngles = function PolarAngles(props) {\n    var cx = props.cx, cy = props.cy, innerRadius = props.innerRadius, outerRadius = props.outerRadius, polarAngles = props.polarAngles, radialLines = props.radialLines;\n    if (!polarAngles || !polarAngles.length || !radialLines) {\n        return null;\n    }\n    var polarAnglesProps = _objectSpread({\n        stroke: '#ccc'\n    }, (0, _ReactUtils.filterProps)(props, false));\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", {\n        className: \"recharts-polar-grid-angle\"\n    }, polarAngles.map(function(entry) {\n        var start = (0, _PolarUtils.polarToCartesian)(cx, cy, innerRadius, entry);\n        var end = (0, _PolarUtils.polarToCartesian)(cx, cy, outerRadius, entry);\n        return /*#__PURE__*/ _react[\"default\"].createElement(\"line\", _extends({}, polarAnglesProps, {\n            key: \"line-\".concat(entry),\n            x1: start.x,\n            y1: start.y,\n            x2: end.x,\n            y2: end.y\n        }));\n    }));\n};\n// Draw concentric circles\nvar ConcentricCircle = function ConcentricCircle(props) {\n    var cx = props.cx, cy = props.cy, radius = props.radius, index = props.index;\n    var concentricCircleProps = _objectSpread(_objectSpread({\n        stroke: '#ccc'\n    }, (0, _ReactUtils.filterProps)(props, false)), {}, {\n        fill: 'none'\n    });\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"circle\", _extends({}, concentricCircleProps, {\n        className: (0, _clsx[\"default\"])('recharts-polar-grid-concentric-circle', props.className),\n        key: \"circle-\".concat(index),\n        cx: cx,\n        cy: cy,\n        r: radius\n    }));\n};\n// Draw concentric polygons\nvar ConcentricPolygon = function ConcentricPolygon(props) {\n    var radius = props.radius, index = props.index;\n    var concentricPolygonProps = _objectSpread(_objectSpread({\n        stroke: '#ccc'\n    }, (0, _ReactUtils.filterProps)(props, false)), {}, {\n        fill: 'none'\n    });\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, concentricPolygonProps, {\n        className: (0, _clsx[\"default\"])('recharts-polar-grid-concentric-polygon', props.className),\n        key: \"path-\".concat(index),\n        d: getPolygonPath(radius, props.cx, props.cy, props.polarAngles)\n    }));\n};\n// Draw concentric axis\n// TODO Optimize the name\nvar ConcentricPath = function ConcentricPath(props) {\n    var polarRadius = props.polarRadius, gridType = props.gridType;\n    if (!polarRadius || !polarRadius.length) {\n        return null;\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", {\n        className: \"recharts-polar-grid-concentric\"\n    }, polarRadius.map(function(entry, i) {\n        var key = i;\n        if (gridType === 'circle') return /*#__PURE__*/ _react[\"default\"].createElement(ConcentricCircle, _extends({\n            key: key\n        }, props, {\n            radius: entry,\n            index: i\n        }));\n        return /*#__PURE__*/ _react[\"default\"].createElement(ConcentricPolygon, _extends({\n            key: key\n        }, props, {\n            radius: entry,\n            index: i\n        }));\n    }));\n};\nvar PolarGrid = exports.PolarGrid = function PolarGrid(_ref) {\n    var _ref$cx = _ref.cx, cx = _ref$cx === void 0 ? 0 : _ref$cx, _ref$cy = _ref.cy, cy = _ref$cy === void 0 ? 0 : _ref$cy, _ref$innerRadius = _ref.innerRadius, innerRadius = _ref$innerRadius === void 0 ? 0 : _ref$innerRadius, _ref$outerRadius = _ref.outerRadius, outerRadius = _ref$outerRadius === void 0 ? 0 : _ref$outerRadius, _ref$gridType = _ref.gridType, gridType = _ref$gridType === void 0 ? 'polygon' : _ref$gridType, _ref$radialLines = _ref.radialLines, radialLines = _ref$radialLines === void 0 ? true : _ref$radialLines, props = _objectWithoutProperties(_ref, _excluded);\n    if (outerRadius <= 0) {\n        return null;\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", {\n        className: \"recharts-polar-grid\"\n    }, /*#__PURE__*/ _react[\"default\"].createElement(PolarAngles, _extends({\n        cx: cx,\n        cy: cy,\n        innerRadius: innerRadius,\n        outerRadius: outerRadius,\n        gridType: gridType,\n        radialLines: radialLines\n    }, props)), /*#__PURE__*/ _react[\"default\"].createElement(ConcentricPath, _extends({\n        cx: cx,\n        cy: cy,\n        innerRadius: innerRadius,\n        outerRadius: outerRadius,\n        gridType: gridType,\n        radialLines: radialLines\n    }, props)));\n};\nPolarGrid.displayName = 'PolarGrid';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvcG9sYXIvUG9sYXJHcmlkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLElBQUlHLFNBQVNDLHVCQUF1QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDbkQsSUFBSUMsUUFBUUYsdUJBQXVCQyxtQkFBT0EsQ0FBQyx1QkFBTTtBQUNqRCxJQUFJRSxjQUFjRixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDOUMsSUFBSUcsY0FBY0gsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlJLFlBQVk7SUFBQztJQUFNO0lBQU07SUFBZTtJQUFlO0lBQVk7Q0FBYztBQUNyRixTQUFTTCx1QkFBdUJNLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUUsV0FBVyxLQUFLQyxVQUFVRCxNQUFNQyxPQUFPRSxTQUFTLEdBQUcsV0FBVyxPQUFPSDtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1QsU0FBU0kseUJBQXlCQyxNQUFNLEVBQUVDLFFBQVE7SUFBSSxJQUFJRCxVQUFVLE1BQU0sT0FBTyxDQUFDO0lBQUcsSUFBSUUsU0FBU0MsOEJBQThCSCxRQUFRQztJQUFXLElBQUlHLEtBQUtDO0lBQUcsSUFBSXpCLE9BQU8wQixxQkFBcUIsRUFBRTtRQUFFLElBQUlDLG1CQUFtQjNCLE9BQU8wQixxQkFBcUIsQ0FBQ047UUFB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QzlCQyxtQkFBbUJILEtBQUsxQixXQUFXLEVBQ25DQSxjQUFjNkIscUJBQXFCLEtBQUssSUFBSSxJQUFJQSxrQkFDaERDLG1CQUFtQkosS0FBS3pCLFdBQVcsRUFDbkNBLGNBQWM2QixxQkFBcUIsS0FBSyxJQUFJLElBQUlBLGtCQUNoREMsZ0JBQWdCTCxLQUFLRCxRQUFRLEVBQzdCQSxXQUFXTSxrQkFBa0IsS0FBSyxJQUFJLFlBQVlBLGVBQ2xEQyxtQkFBbUJOLEtBQUt4QixXQUFXLEVBQ25DQSxjQUFjOEIscUJBQXFCLEtBQUssSUFBSSxPQUFPQSxrQkFDbkRqQyxRQUFRdEQseUJBQXlCaUYsTUFBTXpGO0lBQ3pDLElBQUlnRSxlQUFlLEdBQUc7UUFDcEIsT0FBTztJQUNUO0lBQ0EsT0FBTyxXQUFXLEdBQUV0RSxNQUFNLENBQUMsVUFBVSxDQUFDMkUsYUFBYSxDQUFDLEtBQUs7UUFDdkRDLFdBQVc7SUFDYixHQUFHLFdBQVcsR0FBRTVFLE1BQU0sQ0FBQyxVQUFVLENBQUMyRSxhQUFhLENBQUNSLGFBQWF2QyxTQUFTO1FBQ3BFNkIsSUFBSUE7UUFDSkMsSUFBSUE7UUFDSlcsYUFBYUE7UUFDYkMsYUFBYUE7UUFDYndCLFVBQVVBO1FBQ1Z2QixhQUFhQTtJQUNmLEdBQUdILFNBQVMsV0FBVyxHQUFFcEUsTUFBTSxDQUFDLFVBQVUsQ0FBQzJFLGFBQWEsQ0FBQ2lCLGdCQUFnQmhFLFNBQVM7UUFDaEY2QixJQUFJQTtRQUNKQyxJQUFJQTtRQUNKVyxhQUFhQTtRQUNiQyxhQUFhQTtRQUNid0IsVUFBVUE7UUFDVnZCLGFBQWFBO0lBQ2YsR0FBR0g7QUFDTDtBQUNBckUsVUFBVXVHLFdBQVcsR0FBRyIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxccG9sYXJcXFBvbGFyR3JpZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLlBvbGFyR3JpZCA9IHZvaWQgMDtcclxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XHJcbnZhciBfUG9sYXJVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1BvbGFyVXRpbHNcIik7XHJcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XHJcbnZhciBfZXhjbHVkZWQgPSBbXCJjeFwiLCBcImN5XCIsIFwiaW5uZXJSYWRpdXNcIiwgXCJvdXRlclJhZGl1c1wiLCBcImdyaWRUeXBlXCIsIFwicmFkaWFsTGluZXNcIl07XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XHJcbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cclxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH0gLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgUG9sYXIgR3JpZFxyXG4gKi9cclxudmFyIGdldFBvbHlnb25QYXRoID0gZnVuY3Rpb24gZ2V0UG9seWdvblBhdGgocmFkaXVzLCBjeCwgY3ksIHBvbGFyQW5nbGVzKSB7XHJcbiAgdmFyIHBhdGggPSAnJztcclxuICBwb2xhckFuZ2xlcy5mb3JFYWNoKGZ1bmN0aW9uIChhbmdsZSwgaSkge1xyXG4gICAgdmFyIHBvaW50ID0gKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKGN4LCBjeSwgcmFkaXVzLCBhbmdsZSk7XHJcbiAgICBpZiAoaSkge1xyXG4gICAgICBwYXRoICs9IFwiTCBcIi5jb25jYXQocG9pbnQueCwgXCIsXCIpLmNvbmNhdChwb2ludC55KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBhdGggKz0gXCJNIFwiLmNvbmNhdChwb2ludC54LCBcIixcIikuY29uY2F0KHBvaW50LnkpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHBhdGggKz0gJ1onO1xyXG4gIHJldHVybiBwYXRoO1xyXG59O1xyXG5cclxuLy8gRHJhdyBheGlzIG9mIHJhZGlhbCBsaW5lXHJcbnZhciBQb2xhckFuZ2xlcyA9IGZ1bmN0aW9uIFBvbGFyQW5nbGVzKHByb3BzKSB7XHJcbiAgdmFyIGN4ID0gcHJvcHMuY3gsXHJcbiAgICBjeSA9IHByb3BzLmN5LFxyXG4gICAgaW5uZXJSYWRpdXMgPSBwcm9wcy5pbm5lclJhZGl1cyxcclxuICAgIG91dGVyUmFkaXVzID0gcHJvcHMub3V0ZXJSYWRpdXMsXHJcbiAgICBwb2xhckFuZ2xlcyA9IHByb3BzLnBvbGFyQW5nbGVzLFxyXG4gICAgcmFkaWFsTGluZXMgPSBwcm9wcy5yYWRpYWxMaW5lcztcclxuICBpZiAoIXBvbGFyQW5nbGVzIHx8ICFwb2xhckFuZ2xlcy5sZW5ndGggfHwgIXJhZGlhbExpbmVzKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgdmFyIHBvbGFyQW5nbGVzUHJvcHMgPSBfb2JqZWN0U3ByZWFkKHtcclxuICAgIHN0cm9rZTogJyNjY2MnXHJcbiAgfSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShwcm9wcywgZmFsc2UpKTtcclxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImdcIiwge1xyXG4gICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXBvbGFyLWdyaWQtYW5nbGVcIlxyXG4gIH0sIHBvbGFyQW5nbGVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgIHZhciBzdGFydCA9ICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjeCwgY3ksIGlubmVyUmFkaXVzLCBlbnRyeSk7XHJcbiAgICB2YXIgZW5kID0gKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKGN4LCBjeSwgb3V0ZXJSYWRpdXMsIGVudHJ5KTtcclxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwibGluZVwiLCBfZXh0ZW5kcyh7fSwgcG9sYXJBbmdsZXNQcm9wcywge1xyXG4gICAgICBrZXk6IFwibGluZS1cIi5jb25jYXQoZW50cnkpLFxyXG4gICAgICB4MTogc3RhcnQueCxcclxuICAgICAgeTE6IHN0YXJ0LnksXHJcbiAgICAgIHgyOiBlbmQueCxcclxuICAgICAgeTI6IGVuZC55XHJcbiAgICB9KSk7XHJcbiAgfSkpO1xyXG59O1xyXG5cclxuLy8gRHJhdyBjb25jZW50cmljIGNpcmNsZXNcclxudmFyIENvbmNlbnRyaWNDaXJjbGUgPSBmdW5jdGlvbiBDb25jZW50cmljQ2lyY2xlKHByb3BzKSB7XHJcbiAgdmFyIGN4ID0gcHJvcHMuY3gsXHJcbiAgICBjeSA9IHByb3BzLmN5LFxyXG4gICAgcmFkaXVzID0gcHJvcHMucmFkaXVzLFxyXG4gICAgaW5kZXggPSBwcm9wcy5pbmRleDtcclxuICB2YXIgY29uY2VudHJpY0NpcmNsZVByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcclxuICAgIHN0cm9rZTogJyNjY2MnXHJcbiAgfSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShwcm9wcywgZmFsc2UpKSwge30sIHtcclxuICAgIGZpbGw6ICdub25lJ1xyXG4gIH0pO1xyXG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIF9leHRlbmRzKHt9LCBjb25jZW50cmljQ2lyY2xlUHJvcHMsIHtcclxuICAgIGNsYXNzTmFtZTogKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXBvbGFyLWdyaWQtY29uY2VudHJpYy1jaXJjbGUnLCBwcm9wcy5jbGFzc05hbWUpLFxyXG4gICAga2V5OiBcImNpcmNsZS1cIi5jb25jYXQoaW5kZXgpLFxyXG4gICAgY3g6IGN4LFxyXG4gICAgY3k6IGN5LFxyXG4gICAgcjogcmFkaXVzXHJcbiAgfSkpO1xyXG59O1xyXG5cclxuLy8gRHJhdyBjb25jZW50cmljIHBvbHlnb25zXHJcbnZhciBDb25jZW50cmljUG9seWdvbiA9IGZ1bmN0aW9uIENvbmNlbnRyaWNQb2x5Z29uKHByb3BzKSB7XHJcbiAgdmFyIHJhZGl1cyA9IHByb3BzLnJhZGl1cyxcclxuICAgIGluZGV4ID0gcHJvcHMuaW5kZXg7XHJcbiAgdmFyIGNvbmNlbnRyaWNQb2x5Z29uUHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xyXG4gICAgc3Ryb2tlOiAnI2NjYydcclxuICB9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHByb3BzLCBmYWxzZSkpLCB7fSwge1xyXG4gICAgZmlsbDogJ25vbmUnXHJcbiAgfSk7XHJcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIF9leHRlbmRzKHt9LCBjb25jZW50cmljUG9seWdvblByb3BzLCB7XHJcbiAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1wb2xhci1ncmlkLWNvbmNlbnRyaWMtcG9seWdvbicsIHByb3BzLmNsYXNzTmFtZSksXHJcbiAgICBrZXk6IFwicGF0aC1cIi5jb25jYXQoaW5kZXgpLFxyXG4gICAgZDogZ2V0UG9seWdvblBhdGgocmFkaXVzLCBwcm9wcy5jeCwgcHJvcHMuY3ksIHByb3BzLnBvbGFyQW5nbGVzKVxyXG4gIH0pKTtcclxufTtcclxuXHJcbi8vIERyYXcgY29uY2VudHJpYyBheGlzXHJcbi8vIFRPRE8gT3B0aW1pemUgdGhlIG5hbWVcclxudmFyIENvbmNlbnRyaWNQYXRoID0gZnVuY3Rpb24gQ29uY2VudHJpY1BhdGgocHJvcHMpIHtcclxuICB2YXIgcG9sYXJSYWRpdXMgPSBwcm9wcy5wb2xhclJhZGl1cyxcclxuICAgIGdyaWRUeXBlID0gcHJvcHMuZ3JpZFR5cGU7XHJcbiAgaWYgKCFwb2xhclJhZGl1cyB8fCAhcG9sYXJSYWRpdXMubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcclxuICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1wb2xhci1ncmlkLWNvbmNlbnRyaWNcIlxyXG4gIH0sIHBvbGFyUmFkaXVzLm1hcChmdW5jdGlvbiAoZW50cnksIGkpIHtcclxuICAgIHZhciBrZXkgPSBpO1xyXG4gICAgaWYgKGdyaWRUeXBlID09PSAnY2lyY2xlJykgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoQ29uY2VudHJpY0NpcmNsZSwgX2V4dGVuZHMoe1xyXG4gICAgICBrZXk6IGtleVxyXG4gICAgfSwgcHJvcHMsIHtcclxuICAgICAgcmFkaXVzOiBlbnRyeSxcclxuICAgICAgaW5kZXg6IGlcclxuICAgIH0pKTtcclxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KENvbmNlbnRyaWNQb2x5Z29uLCBfZXh0ZW5kcyh7XHJcbiAgICAgIGtleToga2V5XHJcbiAgICB9LCBwcm9wcywge1xyXG4gICAgICByYWRpdXM6IGVudHJ5LFxyXG4gICAgICBpbmRleDogaVxyXG4gICAgfSkpO1xyXG4gIH0pKTtcclxufTtcclxudmFyIFBvbGFyR3JpZCA9IGV4cG9ydHMuUG9sYXJHcmlkID0gZnVuY3Rpb24gUG9sYXJHcmlkKF9yZWYpIHtcclxuICB2YXIgX3JlZiRjeCA9IF9yZWYuY3gsXHJcbiAgICBjeCA9IF9yZWYkY3ggPT09IHZvaWQgMCA/IDAgOiBfcmVmJGN4LFxyXG4gICAgX3JlZiRjeSA9IF9yZWYuY3ksXHJcbiAgICBjeSA9IF9yZWYkY3kgPT09IHZvaWQgMCA/IDAgOiBfcmVmJGN5LFxyXG4gICAgX3JlZiRpbm5lclJhZGl1cyA9IF9yZWYuaW5uZXJSYWRpdXMsXHJcbiAgICBpbm5lclJhZGl1cyA9IF9yZWYkaW5uZXJSYWRpdXMgPT09IHZvaWQgMCA/IDAgOiBfcmVmJGlubmVyUmFkaXVzLFxyXG4gICAgX3JlZiRvdXRlclJhZGl1cyA9IF9yZWYub3V0ZXJSYWRpdXMsXHJcbiAgICBvdXRlclJhZGl1cyA9IF9yZWYkb3V0ZXJSYWRpdXMgPT09IHZvaWQgMCA/IDAgOiBfcmVmJG91dGVyUmFkaXVzLFxyXG4gICAgX3JlZiRncmlkVHlwZSA9IF9yZWYuZ3JpZFR5cGUsXHJcbiAgICBncmlkVHlwZSA9IF9yZWYkZ3JpZFR5cGUgPT09IHZvaWQgMCA/ICdwb2x5Z29uJyA6IF9yZWYkZ3JpZFR5cGUsXHJcbiAgICBfcmVmJHJhZGlhbExpbmVzID0gX3JlZi5yYWRpYWxMaW5lcyxcclxuICAgIHJhZGlhbExpbmVzID0gX3JlZiRyYWRpYWxMaW5lcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkcmFkaWFsTGluZXMsXHJcbiAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQpO1xyXG4gIGlmIChvdXRlclJhZGl1cyA8PSAwKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcclxuICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1wb2xhci1ncmlkXCJcclxuICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFBvbGFyQW5nbGVzLCBfZXh0ZW5kcyh7XHJcbiAgICBjeDogY3gsXHJcbiAgICBjeTogY3ksXHJcbiAgICBpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXHJcbiAgICBvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXHJcbiAgICBncmlkVHlwZTogZ3JpZFR5cGUsXHJcbiAgICByYWRpYWxMaW5lczogcmFkaWFsTGluZXNcclxuICB9LCBwcm9wcykpLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KENvbmNlbnRyaWNQYXRoLCBfZXh0ZW5kcyh7XHJcbiAgICBjeDogY3gsXHJcbiAgICBjeTogY3ksXHJcbiAgICBpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXHJcbiAgICBvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXHJcbiAgICBncmlkVHlwZTogZ3JpZFR5cGUsXHJcbiAgICByYWRpYWxMaW5lczogcmFkaWFsTGluZXNcclxuICB9LCBwcm9wcykpKTtcclxufTtcclxuUG9sYXJHcmlkLmRpc3BsYXlOYW1lID0gJ1BvbGFyR3JpZCc7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUG9sYXJHcmlkIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfY2xzeCIsIl9Qb2xhclV0aWxzIiwiX1JlYWN0VXRpbHMiLCJfZXhjbHVkZWQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsInNvdXJjZSIsImV4Y2x1ZGVkIiwidGFyZ2V0IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJrZXkiLCJpIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsImxlbmd0aCIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImNhbGwiLCJoYXNPd25Qcm9wZXJ0eSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsImFyZ3VtZW50cyIsImFwcGx5Iiwib3duS2V5cyIsImUiLCJyIiwidCIsImtleXMiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJnZXRQb2x5Z29uUGF0aCIsInJhZGl1cyIsImN4IiwiY3kiLCJwb2xhckFuZ2xlcyIsInBhdGgiLCJhbmdsZSIsInBvaW50IiwicG9sYXJUb0NhcnRlc2lhbiIsImNvbmNhdCIsIngiLCJ5IiwiUG9sYXJBbmdsZXMiLCJwcm9wcyIsImlubmVyUmFkaXVzIiwib3V0ZXJSYWRpdXMiLCJyYWRpYWxMaW5lcyIsInBvbGFyQW5nbGVzUHJvcHMiLCJzdHJva2UiLCJmaWx0ZXJQcm9wcyIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJtYXAiLCJlbnRyeSIsInN0YXJ0IiwiZW5kIiwieDEiLCJ5MSIsIngyIiwieTIiLCJDb25jZW50cmljQ2lyY2xlIiwiaW5kZXgiLCJjb25jZW50cmljQ2lyY2xlUHJvcHMiLCJmaWxsIiwiQ29uY2VudHJpY1BvbHlnb24iLCJjb25jZW50cmljUG9seWdvblByb3BzIiwiZCIsIkNvbmNlbnRyaWNQYXRoIiwicG9sYXJSYWRpdXMiLCJncmlkVHlwZSIsIl9yZWYiLCJfcmVmJGN4IiwiX3JlZiRjeSIsIl9yZWYkaW5uZXJSYWRpdXMiLCJfcmVmJG91dGVyUmFkaXVzIiwiX3JlZiRncmlkVHlwZSIsIl9yZWYkcmFkaWFsTGluZXMiLCJkaXNwbGF5TmFtZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/polar/PolarGrid.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/polar/PolarRadiusAxis.js":
/*!************************************************************!*\
  !*** ./node_modules/recharts/lib/polar/PolarRadiusAxis.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PolarRadiusAxis = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _maxBy = _interopRequireDefault(__webpack_require__(/*! lodash/maxBy */ \"lodash/maxBy\"));\nvar _minBy = _interopRequireDefault(__webpack_require__(/*! lodash/minBy */ \"lodash/minBy\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _Text = __webpack_require__(/*! ../component/Text */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Text.js\");\nvar _Label = __webpack_require__(/*! ../component/Label */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Label.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _types = __webpack_require__(/*! ../util/types */ \"(pages-dir-node)/./node_modules/recharts/lib/util/types.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"cx\",\n    \"cy\",\n    \"angle\",\n    \"ticks\",\n    \"axisLine\"\n], _excluded2 = [\n    \"ticks\",\n    \"tick\",\n    \"angle\",\n    \"tickFormatter\",\n    \"stroke\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview The axis of polar coordinate system\r\n */ \nvar PolarRadiusAxis = exports.PolarRadiusAxis = /*#__PURE__*/ function(_PureComponent) {\n    function PolarRadiusAxis() {\n        _classCallCheck(this, PolarRadiusAxis);\n        return _callSuper(this, PolarRadiusAxis, arguments);\n    }\n    _inherits(PolarRadiusAxis, _PureComponent);\n    return _createClass(PolarRadiusAxis, [\n        {\n            key: \"getTickValueCoord\",\n            value: /**\r\n     * Calculate the coordinate of tick\r\n     * @param  {Number} coordinate The radius of tick\r\n     * @return {Object} (x, y)\r\n     */ function getTickValueCoord(_ref) {\n                var coordinate = _ref.coordinate;\n                var _this$props = this.props, angle = _this$props.angle, cx = _this$props.cx, cy = _this$props.cy;\n                return (0, _PolarUtils.polarToCartesian)(cx, cy, coordinate, angle);\n            }\n        },\n        {\n            key: \"getTickTextAnchor\",\n            value: function getTickTextAnchor() {\n                var orientation = this.props.orientation;\n                var textAnchor;\n                switch(orientation){\n                    case 'left':\n                        textAnchor = 'end';\n                        break;\n                    case 'right':\n                        textAnchor = 'start';\n                        break;\n                    default:\n                        textAnchor = 'middle';\n                        break;\n                }\n                return textAnchor;\n            }\n        },\n        {\n            key: \"getViewBox\",\n            value: function getViewBox() {\n                var _this$props2 = this.props, cx = _this$props2.cx, cy = _this$props2.cy, angle = _this$props2.angle, ticks = _this$props2.ticks;\n                var maxRadiusTick = (0, _maxBy[\"default\"])(ticks, function(entry) {\n                    return entry.coordinate || 0;\n                });\n                var minRadiusTick = (0, _minBy[\"default\"])(ticks, function(entry) {\n                    return entry.coordinate || 0;\n                });\n                return {\n                    cx: cx,\n                    cy: cy,\n                    startAngle: angle,\n                    endAngle: angle,\n                    innerRadius: minRadiusTick.coordinate || 0,\n                    outerRadius: maxRadiusTick.coordinate || 0\n                };\n            }\n        },\n        {\n            key: \"renderAxisLine\",\n            value: function renderAxisLine() {\n                var _this$props3 = this.props, cx = _this$props3.cx, cy = _this$props3.cy, angle = _this$props3.angle, ticks = _this$props3.ticks, axisLine = _this$props3.axisLine, others = _objectWithoutProperties(_this$props3, _excluded);\n                var extent = ticks.reduce(function(result, entry) {\n                    return [\n                        Math.min(result[0], entry.coordinate),\n                        Math.max(result[1], entry.coordinate)\n                    ];\n                }, [\n                    Infinity,\n                    -Infinity\n                ]);\n                var point0 = (0, _PolarUtils.polarToCartesian)(cx, cy, extent[0], angle);\n                var point1 = (0, _PolarUtils.polarToCartesian)(cx, cy, extent[1], angle);\n                var props = _objectSpread(_objectSpread(_objectSpread({}, (0, _ReactUtils.filterProps)(others, false)), {}, {\n                    fill: 'none'\n                }, (0, _ReactUtils.filterProps)(axisLine, false)), {}, {\n                    x1: point0.x,\n                    y1: point0.y,\n                    x2: point1.x,\n                    y2: point1.y\n                });\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"line\", _extends({\n                    className: \"recharts-polar-radius-axis-line\"\n                }, props));\n            }\n        },\n        {\n            key: \"renderTicks\",\n            value: function renderTicks() {\n                var _this = this;\n                var _this$props4 = this.props, ticks = _this$props4.ticks, tick = _this$props4.tick, angle = _this$props4.angle, tickFormatter = _this$props4.tickFormatter, stroke = _this$props4.stroke, others = _objectWithoutProperties(_this$props4, _excluded2);\n                var textAnchor = this.getTickTextAnchor();\n                var axisProps = (0, _ReactUtils.filterProps)(others, false);\n                var customTickProps = (0, _ReactUtils.filterProps)(tick, false);\n                var items = ticks.map(function(entry, i) {\n                    var coord = _this.getTickValueCoord(entry);\n                    var tickProps = _objectSpread(_objectSpread(_objectSpread(_objectSpread({\n                        textAnchor: textAnchor,\n                        transform: \"rotate(\".concat(90 - angle, \", \").concat(coord.x, \", \").concat(coord.y, \")\")\n                    }, axisProps), {}, {\n                        stroke: 'none',\n                        fill: stroke\n                    }, customTickProps), {}, {\n                        index: i\n                    }, coord), {}, {\n                        payload: entry\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                        className: (0, _clsx[\"default\"])('recharts-polar-radius-axis-tick', (0, _PolarUtils.getTickClassName)(tick)),\n                        key: \"tick-\".concat(entry.coordinate)\n                    }, (0, _types.adaptEventsOfChild)(_this.props, entry, i)), PolarRadiusAxis.renderTickItem(tick, tickProps, tickFormatter ? tickFormatter(entry.value, i) : entry.value));\n                });\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-polar-radius-axis-ticks\"\n                }, items);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props5 = this.props, ticks = _this$props5.ticks, axisLine = _this$props5.axisLine, tick = _this$props5.tick;\n                if (!ticks || !ticks.length) {\n                    return null;\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: (0, _clsx[\"default\"])('recharts-polar-radius-axis', this.props.className)\n                }, axisLine && this.renderAxisLine(), tick && this.renderTicks(), _Label.Label.renderCallByParent(this.props, this.getViewBox()));\n            }\n        }\n    ], [\n        {\n            key: \"renderTickItem\",\n            value: function renderTickItem(option, props, value) {\n                var tickItem;\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n                    tickItem = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n                } else if ((0, _isFunction[\"default\"])(option)) {\n                    tickItem = option(props);\n                } else {\n                    tickItem = /*#__PURE__*/ _react[\"default\"].createElement(_Text.Text, _extends({}, props, {\n                        className: \"recharts-polar-radius-axis-tick-value\"\n                    }), value);\n                }\n                return tickItem;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(PolarRadiusAxis, \"displayName\", 'PolarRadiusAxis');\n_defineProperty(PolarRadiusAxis, \"axisType\", 'radiusAxis');\n_defineProperty(PolarRadiusAxis, \"defaultProps\", {\n    type: 'number',\n    radiusAxisId: 0,\n    cx: 0,\n    cy: 0,\n    angle: 0,\n    orientation: 'right',\n    stroke: '#ccc',\n    axisLine: true,\n    tick: true,\n    tickCount: 5,\n    allowDataOverflow: false,\n    scale: 'auto',\n    allowDuplicatedCategory: true\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvcG9sYXIvUG9sYXJSYWRpdXNBeGlzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCx1QkFBdUIsR0FBRyxLQUFLO0FBQy9CLElBQUlHLFNBQVNDLHdCQUF3QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUMsU0FBU0MsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJRyxTQUFTRCx1QkFBdUJGLG1CQUFPQSxDQUFDLGtDQUFjO0FBQzFELElBQUlJLGNBQWNGLHVCQUF1QkYsbUJBQU9BLENBQUMsNENBQW1CO0FBQ3BFLElBQUlLLFFBQVFILHVCQUF1QkYsbUJBQU9BLENBQUMsdUJBQU07QUFDakQsSUFBSU0sUUFBUU4sbUJBQU9BLENBQUMseUZBQW1CO0FBQ3ZDLElBQUlPLFNBQVNQLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUN6QyxJQUFJUSxTQUFTUixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDekMsSUFBSVMsY0FBY1QsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlVLFNBQVNWLG1CQUFPQSxDQUFDLGlGQUFlO0FBQ3BDLElBQUlXLGNBQWNYLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM5QyxJQUFJWSxZQUFZO0lBQUM7SUFBTTtJQUFNO0lBQVM7SUFBUztDQUFXLEVBQ3hEQyxhQUFhO0lBQUM7SUFBUztJQUFRO0lBQVM7SUFBaUI7Q0FBUztBQUNwRSxTQUFTWCx1QkFBdUJZLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UseUJBQXlCQyxDQUFDO0lBQUksSUFBSSxjQUFjLE9BQU9DLFNBQVMsT0FBTztJQUFNLElBQUlDLElBQUksSUFBSUQsV0FBV0UsSUFBSSxJQUFJRjtJQUFXLE9BQU8sQ0FBQ0Ys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QUFDLFVBQVUsRUFBRW9LLFNBQVM7b0JBQzlDQyxXQUFXRCxPQUFPcEc7Z0JBQ3BCLE9BQU87b0JBQ0xxRyxXQUFXLFdBQVcsR0FBRTNLLE1BQU0sQ0FBQyxVQUFVLENBQUNnSixhQUFhLENBQUN4SSxNQUFNc0ssSUFBSSxFQUFFdkksU0FBUyxDQUFDLEdBQUcrQixPQUFPO3dCQUN0RjJFLFdBQVc7b0JBQ2IsSUFBSW5KO2dCQUNOO2dCQUNBLE9BQU82SztZQUNUO1FBQ0Y7S0FBRTtBQUNKLEVBQUUzSyxPQUFPK0ssYUFBYTtBQUN0QnZILGdCQUFnQnpELGlCQUFpQixlQUFlO0FBQ2hEeUQsZ0JBQWdCekQsaUJBQWlCLFlBQVk7QUFDN0N5RCxnQkFBZ0J6RCxpQkFBaUIsZ0JBQWdCO0lBQy9DaUwsTUFBTTtJQUNOQyxjQUFjO0lBQ2R0RSxJQUFJO0lBQ0pDLElBQUk7SUFDSkYsT0FBTztJQUNQSyxhQUFhO0lBQ2J3QyxRQUFRO0lBQ1IxQixVQUFVO0lBQ1Z3QixNQUFNO0lBQ042QixXQUFXO0lBQ1hDLG1CQUFtQjtJQUNuQkMsT0FBTztJQUNQQyx5QkFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXHBvbGFyXFxQb2xhclJhZGl1c0F4aXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5Qb2xhclJhZGl1c0F4aXMgPSB2b2lkIDA7XHJcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgX21heEJ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL21heEJ5XCIpKTtcclxudmFyIF9taW5CeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9taW5CeVwiKSk7XHJcbnZhciBfaXNGdW5jdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpKTtcclxudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XHJcbnZhciBfVGV4dCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQvVGV4dFwiKTtcclxudmFyIF9MYWJlbCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQvTGFiZWxcIik7XHJcbnZhciBfTGF5ZXIgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL0xheWVyXCIpO1xyXG52YXIgX1BvbGFyVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9Qb2xhclV0aWxzXCIpO1xyXG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4uL3V0aWwvdHlwZXNcIik7XHJcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XHJcbnZhciBfZXhjbHVkZWQgPSBbXCJjeFwiLCBcImN5XCIsIFwiYW5nbGVcIiwgXCJ0aWNrc1wiLCBcImF4aXNMaW5lXCJdLFxyXG4gIF9leGNsdWRlZDIgPSBbXCJ0aWNrc1wiLCBcInRpY2tcIiwgXCJhbmdsZVwiLCBcInRpY2tGb3JtYXR0ZXJcIiwgXCJzdHJva2VcIl07XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XHJcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XHJcbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XHJcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxyXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cclxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XHJcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XHJcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cclxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH0gLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgVGhlIGF4aXMgb2YgcG9sYXIgY29vcmRpbmF0ZSBzeXN0ZW1cclxuICovXHJcbnZhciBQb2xhclJhZGl1c0F4aXMgPSBleHBvcnRzLlBvbGFyUmFkaXVzQXhpcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1B1cmVDb21wb25lbnQpIHtcclxuICBmdW5jdGlvbiBQb2xhclJhZGl1c0F4aXMoKSB7XHJcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9sYXJSYWRpdXNBeGlzKTtcclxuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIFBvbGFyUmFkaXVzQXhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcbiAgX2luaGVyaXRzKFBvbGFyUmFkaXVzQXhpcywgX1B1cmVDb21wb25lbnQpO1xyXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUG9sYXJSYWRpdXNBeGlzLCBbe1xyXG4gICAga2V5OiBcImdldFRpY2tWYWx1ZUNvb3JkXCIsXHJcbiAgICB2YWx1ZTpcclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb29yZGluYXRlIG9mIHRpY2tcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY29vcmRpbmF0ZSBUaGUgcmFkaXVzIG9mIHRpY2tcclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gKHgsIHkpXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFRpY2tWYWx1ZUNvb3JkKF9yZWYpIHtcclxuICAgICAgdmFyIGNvb3JkaW5hdGUgPSBfcmVmLmNvb3JkaW5hdGU7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgYW5nbGUgPSBfdGhpcyRwcm9wcy5hbmdsZSxcclxuICAgICAgICBjeCA9IF90aGlzJHByb3BzLmN4LFxyXG4gICAgICAgIGN5ID0gX3RoaXMkcHJvcHMuY3k7XHJcbiAgICAgIHJldHVybiAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikoY3gsIGN5LCBjb29yZGluYXRlLCBhbmdsZSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImdldFRpY2tUZXh0QW5jaG9yXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGlja1RleHRBbmNob3IoKSB7XHJcbiAgICAgIHZhciBvcmllbnRhdGlvbiA9IHRoaXMucHJvcHMub3JpZW50YXRpb247XHJcbiAgICAgIHZhciB0ZXh0QW5jaG9yO1xyXG4gICAgICBzd2l0Y2ggKG9yaWVudGF0aW9uKSB7XHJcbiAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICB0ZXh0QW5jaG9yID0gJ2VuZCc7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdyaWdodCc6XHJcbiAgICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB0ZXh0QW5jaG9yID0gJ21pZGRsZSc7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGV4dEFuY2hvcjtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiZ2V0Vmlld0JveFwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpZXdCb3goKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIGN4ID0gX3RoaXMkcHJvcHMyLmN4LFxyXG4gICAgICAgIGN5ID0gX3RoaXMkcHJvcHMyLmN5LFxyXG4gICAgICAgIGFuZ2xlID0gX3RoaXMkcHJvcHMyLmFuZ2xlLFxyXG4gICAgICAgIHRpY2tzID0gX3RoaXMkcHJvcHMyLnRpY2tzO1xyXG4gICAgICB2YXIgbWF4UmFkaXVzVGljayA9ICgwLCBfbWF4QnlbXCJkZWZhdWx0XCJdKSh0aWNrcywgZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIGVudHJ5LmNvb3JkaW5hdGUgfHwgMDtcclxuICAgICAgfSk7XHJcbiAgICAgIHZhciBtaW5SYWRpdXNUaWNrID0gKDAsIF9taW5CeVtcImRlZmF1bHRcIl0pKHRpY2tzLCBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICByZXR1cm4gZW50cnkuY29vcmRpbmF0ZSB8fCAwO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBjeDogY3gsXHJcbiAgICAgICAgY3k6IGN5LFxyXG4gICAgICAgIHN0YXJ0QW5nbGU6IGFuZ2xlLFxyXG4gICAgICAgIGVuZEFuZ2xlOiBhbmdsZSxcclxuICAgICAgICBpbm5lclJhZGl1czogbWluUmFkaXVzVGljay5jb29yZGluYXRlIHx8IDAsXHJcbiAgICAgICAgb3V0ZXJSYWRpdXM6IG1heFJhZGl1c1RpY2suY29vcmRpbmF0ZSB8fCAwXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJlbmRlckF4aXNMaW5lXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQXhpc0xpbmUoKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIGN4ID0gX3RoaXMkcHJvcHMzLmN4LFxyXG4gICAgICAgIGN5ID0gX3RoaXMkcHJvcHMzLmN5LFxyXG4gICAgICAgIGFuZ2xlID0gX3RoaXMkcHJvcHMzLmFuZ2xlLFxyXG4gICAgICAgIHRpY2tzID0gX3RoaXMkcHJvcHMzLnRpY2tzLFxyXG4gICAgICAgIGF4aXNMaW5lID0gX3RoaXMkcHJvcHMzLmF4aXNMaW5lLFxyXG4gICAgICAgIG90aGVycyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdGhpcyRwcm9wczMsIF9leGNsdWRlZCk7XHJcbiAgICAgIHZhciBleHRlbnQgPSB0aWNrcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgZW50cnkpIHtcclxuICAgICAgICByZXR1cm4gW01hdGgubWluKHJlc3VsdFswXSwgZW50cnkuY29vcmRpbmF0ZSksIE1hdGgubWF4KHJlc3VsdFsxXSwgZW50cnkuY29vcmRpbmF0ZSldO1xyXG4gICAgICB9LCBbSW5maW5pdHksIC1JbmZpbml0eV0pO1xyXG4gICAgICB2YXIgcG9pbnQwID0gKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKGN4LCBjeSwgZXh0ZW50WzBdLCBhbmdsZSk7XHJcbiAgICAgIHZhciBwb2ludDEgPSAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikoY3gsIGN5LCBleHRlbnRbMV0sIGFuZ2xlKTtcclxuICAgICAgdmFyIHByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykob3RoZXJzLCBmYWxzZSkpLCB7fSwge1xyXG4gICAgICAgIGZpbGw6ICdub25lJ1xyXG4gICAgICB9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKGF4aXNMaW5lLCBmYWxzZSkpLCB7fSwge1xyXG4gICAgICAgIHgxOiBwb2ludDAueCxcclxuICAgICAgICB5MTogcG9pbnQwLnksXHJcbiAgICAgICAgeDI6IHBvaW50MS54LFxyXG4gICAgICAgIHkyOiBwb2ludDEueVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIF9leHRlbmRzKHtcclxuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtcG9sYXItcmFkaXVzLWF4aXMtbGluZVwiXHJcbiAgICAgIH0sIHByb3BzKSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJlbmRlclRpY2tzXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVGlja3MoKSB7XHJcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIHRpY2tzID0gX3RoaXMkcHJvcHM0LnRpY2tzLFxyXG4gICAgICAgIHRpY2sgPSBfdGhpcyRwcm9wczQudGljayxcclxuICAgICAgICBhbmdsZSA9IF90aGlzJHByb3BzNC5hbmdsZSxcclxuICAgICAgICB0aWNrRm9ybWF0dGVyID0gX3RoaXMkcHJvcHM0LnRpY2tGb3JtYXR0ZXIsXHJcbiAgICAgICAgc3Ryb2tlID0gX3RoaXMkcHJvcHM0LnN0cm9rZSxcclxuICAgICAgICBvdGhlcnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkcHJvcHM0LCBfZXhjbHVkZWQyKTtcclxuICAgICAgdmFyIHRleHRBbmNob3IgPSB0aGlzLmdldFRpY2tUZXh0QW5jaG9yKCk7XHJcbiAgICAgIHZhciBheGlzUHJvcHMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKG90aGVycywgZmFsc2UpO1xyXG4gICAgICB2YXIgY3VzdG9tVGlja1Byb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0aWNrLCBmYWxzZSk7XHJcbiAgICAgIHZhciBpdGVtcyA9IHRpY2tzLm1hcChmdW5jdGlvbiAoZW50cnksIGkpIHtcclxuICAgICAgICB2YXIgY29vcmQgPSBfdGhpcy5nZXRUaWNrVmFsdWVDb29yZChlbnRyeSk7XHJcbiAgICAgICAgdmFyIHRpY2tQcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xyXG4gICAgICAgICAgdGV4dEFuY2hvcjogdGV4dEFuY2hvcixcclxuICAgICAgICAgIHRyYW5zZm9ybTogXCJyb3RhdGUoXCIuY29uY2F0KDkwIC0gYW5nbGUsIFwiLCBcIikuY29uY2F0KGNvb3JkLngsIFwiLCBcIikuY29uY2F0KGNvb3JkLnksIFwiKVwiKVxyXG4gICAgICAgIH0sIGF4aXNQcm9wcyksIHt9LCB7XHJcbiAgICAgICAgICBzdHJva2U6ICdub25lJyxcclxuICAgICAgICAgIGZpbGw6IHN0cm9rZVxyXG4gICAgICAgIH0sIGN1c3RvbVRpY2tQcm9wcyksIHt9LCB7XHJcbiAgICAgICAgICBpbmRleDogaVxyXG4gICAgICAgIH0sIGNvb3JkKSwge30sIHtcclxuICAgICAgICAgIHBheWxvYWQ6IGVudHJ5XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCBfZXh0ZW5kcyh7XHJcbiAgICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1wb2xhci1yYWRpdXMtYXhpcy10aWNrJywgKDAsIF9Qb2xhclV0aWxzLmdldFRpY2tDbGFzc05hbWUpKHRpY2spKSxcclxuICAgICAgICAgIGtleTogXCJ0aWNrLVwiLmNvbmNhdChlbnRyeS5jb29yZGluYXRlKVxyXG4gICAgICAgIH0sICgwLCBfdHlwZXMuYWRhcHRFdmVudHNPZkNoaWxkKShfdGhpcy5wcm9wcywgZW50cnksIGkpKSwgUG9sYXJSYWRpdXNBeGlzLnJlbmRlclRpY2tJdGVtKHRpY2ssIHRpY2tQcm9wcywgdGlja0Zvcm1hdHRlciA/IHRpY2tGb3JtYXR0ZXIoZW50cnkudmFsdWUsIGkpIDogZW50cnkudmFsdWUpKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xyXG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1wb2xhci1yYWRpdXMtYXhpcy10aWNrc1wiXHJcbiAgICAgIH0sIGl0ZW1zKTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHM1ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICB0aWNrcyA9IF90aGlzJHByb3BzNS50aWNrcyxcclxuICAgICAgICBheGlzTGluZSA9IF90aGlzJHByb3BzNS5heGlzTGluZSxcclxuICAgICAgICB0aWNrID0gX3RoaXMkcHJvcHM1LnRpY2s7XHJcbiAgICAgIGlmICghdGlja3MgfHwgIXRpY2tzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xyXG4gICAgICAgIGNsYXNzTmFtZTogKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXBvbGFyLXJhZGl1cy1heGlzJywgdGhpcy5wcm9wcy5jbGFzc05hbWUpXHJcbiAgICAgIH0sIGF4aXNMaW5lICYmIHRoaXMucmVuZGVyQXhpc0xpbmUoKSwgdGljayAmJiB0aGlzLnJlbmRlclRpY2tzKCksIF9MYWJlbC5MYWJlbC5yZW5kZXJDYWxsQnlQYXJlbnQodGhpcy5wcm9wcywgdGhpcy5nZXRWaWV3Qm94KCkpKTtcclxuICAgIH1cclxuICB9XSwgW3tcclxuICAgIGtleTogXCJyZW5kZXJUaWNrSXRlbVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclRpY2tJdGVtKG9wdGlvbiwgcHJvcHMsIHZhbHVlKSB7XHJcbiAgICAgIHZhciB0aWNrSXRlbTtcclxuICAgICAgaWYgKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5pc1ZhbGlkRWxlbWVudChvcHRpb24pKSB7XHJcbiAgICAgICAgdGlja0l0ZW0gPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQob3B0aW9uLCBwcm9wcyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob3B0aW9uKSkge1xyXG4gICAgICAgIHRpY2tJdGVtID0gb3B0aW9uKHByb3BzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aWNrSXRlbSA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX1RleHQuVGV4dCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XHJcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtcG9sYXItcmFkaXVzLWF4aXMtdGljay12YWx1ZVwiXHJcbiAgICAgICAgfSksIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGlja0l0ZW07XHJcbiAgICB9XHJcbiAgfV0pO1xyXG59KF9yZWFjdC5QdXJlQ29tcG9uZW50KTtcclxuX2RlZmluZVByb3BlcnR5KFBvbGFyUmFkaXVzQXhpcywgXCJkaXNwbGF5TmFtZVwiLCAnUG9sYXJSYWRpdXNBeGlzJyk7XHJcbl9kZWZpbmVQcm9wZXJ0eShQb2xhclJhZGl1c0F4aXMsIFwiYXhpc1R5cGVcIiwgJ3JhZGl1c0F4aXMnKTtcclxuX2RlZmluZVByb3BlcnR5KFBvbGFyUmFkaXVzQXhpcywgXCJkZWZhdWx0UHJvcHNcIiwge1xyXG4gIHR5cGU6ICdudW1iZXInLFxyXG4gIHJhZGl1c0F4aXNJZDogMCxcclxuICBjeDogMCxcclxuICBjeTogMCxcclxuICBhbmdsZTogMCxcclxuICBvcmllbnRhdGlvbjogJ3JpZ2h0JyxcclxuICBzdHJva2U6ICcjY2NjJyxcclxuICBheGlzTGluZTogdHJ1ZSxcclxuICB0aWNrOiB0cnVlLFxyXG4gIHRpY2tDb3VudDogNSxcclxuICBhbGxvd0RhdGFPdmVyZmxvdzogZmFsc2UsXHJcbiAgc2NhbGU6ICdhdXRvJyxcclxuICBhbGxvd0R1cGxpY2F0ZWRDYXRlZ29yeTogdHJ1ZVxyXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJQb2xhclJhZGl1c0F4aXMiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfbWF4QnkiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX21pbkJ5IiwiX2lzRnVuY3Rpb24iLCJfY2xzeCIsIl9UZXh0IiwiX0xhYmVsIiwiX0xheWVyIiwiX1BvbGFyVXRpbHMiLCJfdHlwZXMiLCJfUmVhY3RVdGlscyIsIl9leGNsdWRlZCIsIl9leGNsdWRlZDIiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwicHJvdG90eXBlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwiYXBwbHkiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImVudW1lcmFibGUiLCJwdXNoIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsImV4Y2x1ZGVkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJzb3VyY2VTeW1ib2xLZXlzIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9Qcm9wZXJ0eUtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsInAiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsIl9QdXJlQ29tcG9uZW50IiwiZ2V0VGlja1ZhbHVlQ29vcmQiLCJfcmVmIiwiY29vcmRpbmF0ZSIsIl90aGlzJHByb3BzIiwiYW5nbGUiLCJjeCIsImN5IiwicG9sYXJUb0NhcnRlc2lhbiIsImdldFRpY2tUZXh0QW5jaG9yIiwib3JpZW50YXRpb24iLCJ0ZXh0QW5jaG9yIiwiZ2V0Vmlld0JveCIsIl90aGlzJHByb3BzMiIsInRpY2tzIiwibWF4UmFkaXVzVGljayIsImVudHJ5IiwibWluUmFkaXVzVGljayIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsImlubmVyUmFkaXVzIiwib3V0ZXJSYWRpdXMiLCJyZW5kZXJBeGlzTGluZSIsIl90aGlzJHByb3BzMyIsImF4aXNMaW5lIiwib3RoZXJzIiwiZXh0ZW50IiwicmVkdWNlIiwicmVzdWx0IiwiTWF0aCIsIm1pbiIsIm1heCIsIkluZmluaXR5IiwicG9pbnQwIiwicG9pbnQxIiwiZmlsdGVyUHJvcHMiLCJmaWxsIiwieDEiLCJ4IiwieTEiLCJ5IiwieDIiLCJ5MiIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJyZW5kZXJUaWNrcyIsIl90aGlzIiwiX3RoaXMkcHJvcHM0IiwidGljayIsInRpY2tGb3JtYXR0ZXIiLCJzdHJva2UiLCJheGlzUHJvcHMiLCJjdXN0b21UaWNrUHJvcHMiLCJpdGVtcyIsIm1hcCIsImNvb3JkIiwidGlja1Byb3BzIiwidHJhbnNmb3JtIiwiY29uY2F0IiwiaW5kZXgiLCJwYXlsb2FkIiwiTGF5ZXIiLCJnZXRUaWNrQ2xhc3NOYW1lIiwiYWRhcHRFdmVudHNPZkNoaWxkIiwicmVuZGVyVGlja0l0ZW0iLCJyZW5kZXIiLCJfdGhpcyRwcm9wczUiLCJMYWJlbCIsInJlbmRlckNhbGxCeVBhcmVudCIsIm9wdGlvbiIsInRpY2tJdGVtIiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJUZXh0IiwiUHVyZUNvbXBvbmVudCIsInR5cGUiLCJyYWRpdXNBeGlzSWQiLCJ0aWNrQ291bnQiLCJhbGxvd0RhdGFPdmVyZmxvdyIsInNjYWxlIiwiYWxsb3dEdXBsaWNhdGVkQ2F0ZWdvcnkiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/polar/PolarRadiusAxis.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/polar/Radar.js":
/*!**************************************************!*\
  !*** ./node_modules/recharts/lib/polar/Radar.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Radar = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _last = _interopRequireDefault(__webpack_require__(/*! lodash/last */ \"lodash/last\"));\nvar _first = _interopRequireDefault(__webpack_require__(/*! lodash/first */ \"lodash/first\"));\nvar _isEqual = _interopRequireDefault(__webpack_require__(/*! lodash/isEqual */ \"lodash/isEqual\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"(pages-dir-node)/./node_modules/recharts/lib/util/Global.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _Polygon = __webpack_require__(/*! ../shape/Polygon */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Polygon.js\");\nvar _Dot = __webpack_require__(/*! ../shape/Dot */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Dot.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _LabelList = __webpack_require__(/*! ../component/LabelList */ \"(pages-dir-node)/./node_modules/recharts/lib/component/LabelList.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"key\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Radar\r\n */ \nvar Radar = exports.Radar = /*#__PURE__*/ function(_PureComponent) {\n    function Radar() {\n        var _this;\n        _classCallCheck(this, Radar);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, Radar, [].concat(args));\n        _defineProperty(_this, \"state\", {\n            isAnimationFinished: false\n        });\n        _defineProperty(_this, \"handleAnimationEnd\", function() {\n            var onAnimationEnd = _this.props.onAnimationEnd;\n            _this.setState({\n                isAnimationFinished: true\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationEnd)) {\n                onAnimationEnd();\n            }\n        });\n        _defineProperty(_this, \"handleAnimationStart\", function() {\n            var onAnimationStart = _this.props.onAnimationStart;\n            _this.setState({\n                isAnimationFinished: false\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationStart)) {\n                onAnimationStart();\n            }\n        });\n        _defineProperty(_this, \"handleMouseEnter\", function(e) {\n            var onMouseEnter = _this.props.onMouseEnter;\n            if (onMouseEnter) {\n                onMouseEnter(_this.props, e);\n            }\n        });\n        _defineProperty(_this, \"handleMouseLeave\", function(e) {\n            var onMouseLeave = _this.props.onMouseLeave;\n            if (onMouseLeave) {\n                onMouseLeave(_this.props, e);\n            }\n        });\n        return _this;\n    }\n    _inherits(Radar, _PureComponent);\n    return _createClass(Radar, [\n        {\n            key: \"renderDots\",\n            value: function renderDots(points) {\n                var _this$props = this.props, dot = _this$props.dot, dataKey = _this$props.dataKey;\n                var baseProps = (0, _ReactUtils.filterProps)(this.props, false);\n                var customDotProps = (0, _ReactUtils.filterProps)(dot, true);\n                var dots = points.map(function(entry, i) {\n                    var dotProps = _objectSpread(_objectSpread(_objectSpread({\n                        key: \"dot-\".concat(i),\n                        r: 3\n                    }, baseProps), customDotProps), {}, {\n                        dataKey: dataKey,\n                        cx: entry.x,\n                        cy: entry.y,\n                        index: i,\n                        payload: entry\n                    });\n                    return Radar.renderDotItem(dot, dotProps);\n                });\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-radar-dots\"\n                }, dots);\n            }\n        },\n        {\n            key: \"renderPolygonStatically\",\n            value: function renderPolygonStatically(points) {\n                var _this$props2 = this.props, shape = _this$props2.shape, dot = _this$props2.dot, isRange = _this$props2.isRange, baseLinePoints = _this$props2.baseLinePoints, connectNulls = _this$props2.connectNulls;\n                var radar;\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(shape)) {\n                    radar = /*#__PURE__*/ _react[\"default\"].cloneElement(shape, _objectSpread(_objectSpread({}, this.props), {}, {\n                        points: points\n                    }));\n                } else if ((0, _isFunction[\"default\"])(shape)) {\n                    radar = shape(_objectSpread(_objectSpread({}, this.props), {}, {\n                        points: points\n                    }));\n                } else {\n                    radar = /*#__PURE__*/ _react[\"default\"].createElement(_Polygon.Polygon, _extends({}, (0, _ReactUtils.filterProps)(this.props, true), {\n                        onMouseEnter: this.handleMouseEnter,\n                        onMouseLeave: this.handleMouseLeave,\n                        points: points,\n                        baseLinePoints: isRange ? baseLinePoints : null,\n                        connectNulls: connectNulls\n                    }));\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-radar-polygon\"\n                }, radar, dot ? this.renderDots(points) : null);\n            }\n        },\n        {\n            key: \"renderPolygonWithAnimation\",\n            value: function renderPolygonWithAnimation() {\n                var _this2 = this;\n                var _this$props3 = this.props, points = _this$props3.points, isAnimationActive = _this$props3.isAnimationActive, animationBegin = _this$props3.animationBegin, animationDuration = _this$props3.animationDuration, animationEasing = _this$props3.animationEasing, animationId = _this$props3.animationId;\n                var prevPoints = this.state.prevPoints;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n                    begin: animationBegin,\n                    duration: animationDuration,\n                    isActive: isAnimationActive,\n                    easing: animationEasing,\n                    from: {\n                        t: 0\n                    },\n                    to: {\n                        t: 1\n                    },\n                    key: \"radar-\".concat(animationId),\n                    onAnimationEnd: this.handleAnimationEnd,\n                    onAnimationStart: this.handleAnimationStart\n                }, function(_ref) {\n                    var t = _ref.t;\n                    var prevPointsDiffFactor = prevPoints && prevPoints.length / points.length;\n                    var stepData = points.map(function(entry, index) {\n                        var prev = prevPoints && prevPoints[Math.floor(index * prevPointsDiffFactor)];\n                        if (prev) {\n                            var _interpolatorX = (0, _DataUtils.interpolateNumber)(prev.x, entry.x);\n                            var _interpolatorY = (0, _DataUtils.interpolateNumber)(prev.y, entry.y);\n                            return _objectSpread(_objectSpread({}, entry), {}, {\n                                x: _interpolatorX(t),\n                                y: _interpolatorY(t)\n                            });\n                        }\n                        var interpolatorX = (0, _DataUtils.interpolateNumber)(entry.cx, entry.x);\n                        var interpolatorY = (0, _DataUtils.interpolateNumber)(entry.cy, entry.y);\n                        return _objectSpread(_objectSpread({}, entry), {}, {\n                            x: interpolatorX(t),\n                            y: interpolatorY(t)\n                        });\n                    });\n                    return _this2.renderPolygonStatically(stepData);\n                });\n            }\n        },\n        {\n            key: \"renderPolygon\",\n            value: function renderPolygon() {\n                var _this$props4 = this.props, points = _this$props4.points, isAnimationActive = _this$props4.isAnimationActive, isRange = _this$props4.isRange;\n                var prevPoints = this.state.prevPoints;\n                if (isAnimationActive && points && points.length && !isRange && (!prevPoints || !(0, _isEqual[\"default\"])(prevPoints, points))) {\n                    return this.renderPolygonWithAnimation();\n                }\n                return this.renderPolygonStatically(points);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props5 = this.props, hide = _this$props5.hide, className = _this$props5.className, points = _this$props5.points, isAnimationActive = _this$props5.isAnimationActive;\n                if (hide || !points || !points.length) {\n                    return null;\n                }\n                var isAnimationFinished = this.state.isAnimationFinished;\n                var layerClass = (0, _clsx[\"default\"])('recharts-radar', className);\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: layerClass\n                }, this.renderPolygon(), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, points));\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                if (nextProps.animationId !== prevState.prevAnimationId) {\n                    return {\n                        prevAnimationId: nextProps.animationId,\n                        curPoints: nextProps.points,\n                        prevPoints: prevState.curPoints\n                    };\n                }\n                if (nextProps.points !== prevState.curPoints) {\n                    return {\n                        curPoints: nextProps.points\n                    };\n                }\n                return null;\n            }\n        },\n        {\n            key: \"renderDotItem\",\n            value: function renderDotItem(option, props) {\n                var dotItem;\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n                    dotItem = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n                } else if ((0, _isFunction[\"default\"])(option)) {\n                    dotItem = option(props);\n                } else {\n                    var key = props.key, dotProps = _objectWithoutProperties(props, _excluded);\n                    dotItem = /*#__PURE__*/ _react[\"default\"].createElement(_Dot.Dot, _extends({}, dotProps, {\n                        key: key,\n                        className: (0, _clsx[\"default\"])('recharts-radar-dot', typeof option !== 'boolean' ? option.className : '')\n                    }));\n                }\n                return dotItem;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(Radar, \"displayName\", 'Radar');\n_defineProperty(Radar, \"defaultProps\", {\n    angleAxisId: 0,\n    radiusAxisId: 0,\n    hide: false,\n    activeDot: true,\n    dot: false,\n    legendType: 'rect',\n    isAnimationActive: !_Global.Global.isSsr,\n    animationBegin: 0,\n    animationDuration: 1500,\n    animationEasing: 'ease'\n});\n_defineProperty(Radar, \"getComposedData\", function(_ref2) {\n    var radiusAxis = _ref2.radiusAxis, angleAxis = _ref2.angleAxis, displayedData = _ref2.displayedData, dataKey = _ref2.dataKey, bandSize = _ref2.bandSize;\n    var cx = angleAxis.cx, cy = angleAxis.cy;\n    var isRange = false;\n    var points = [];\n    var angleBandSize = angleAxis.type !== 'number' ? bandSize !== null && bandSize !== void 0 ? bandSize : 0 : 0;\n    displayedData.forEach(function(entry, i) {\n        var name = (0, _ChartUtils.getValueByDataKey)(entry, angleAxis.dataKey, i);\n        var value = (0, _ChartUtils.getValueByDataKey)(entry, dataKey);\n        var angle = angleAxis.scale(name) + angleBandSize;\n        var pointValue = Array.isArray(value) ? (0, _last[\"default\"])(value) : value;\n        var radius = (0, _isNil[\"default\"])(pointValue) ? undefined : radiusAxis.scale(pointValue);\n        if (Array.isArray(value) && value.length >= 2) {\n            isRange = true;\n        }\n        points.push(_objectSpread(_objectSpread({}, (0, _PolarUtils.polarToCartesian)(cx, cy, radius, angle)), {}, {\n            name: name,\n            value: value,\n            cx: cx,\n            cy: cy,\n            radius: radius,\n            angle: angle,\n            payload: entry\n        }));\n    });\n    var baseLinePoints = [];\n    if (isRange) {\n        points.forEach(function(point) {\n            if (Array.isArray(point.value)) {\n                var baseValue = (0, _first[\"default\"])(point.value);\n                var radius = (0, _isNil[\"default\"])(baseValue) ? undefined : radiusAxis.scale(baseValue);\n                baseLinePoints.push(_objectSpread(_objectSpread({}, point), {}, {\n                    radius: radius\n                }, (0, _PolarUtils.polarToCartesian)(cx, cy, radius, point.angle)));\n            } else {\n                baseLinePoints.push(point);\n            }\n        });\n    }\n    return {\n        points: points,\n        isRange: isRange,\n        baseLinePoints: baseLinePoints\n    };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvcG9sYXIvUmFkYXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGFBQWEsR0FBRyxLQUFLO0FBQ3JCLElBQUlHLFNBQVNDLHdCQUF3QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUMsZUFBZUMsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUNoRSxJQUFJRyxTQUFTRCx1QkFBdUJGLG1CQUFPQSxDQUFDLGtDQUFjO0FBQzFELElBQUlJLFFBQVFGLHVCQUF1QkYsbUJBQU9BLENBQUMsZ0NBQWE7QUFDeEQsSUFBSUssU0FBU0gsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJTSxXQUFXSix1QkFBdUJGLG1CQUFPQSxDQUFDLHNDQUFnQjtBQUM5RCxJQUFJTyxjQUFjTCx1QkFBdUJGLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJUSxRQUFRTix1QkFBdUJGLG1CQUFPQSxDQUFDLHVCQUFNO0FBQ2pELElBQUlTLGFBQWFULG1CQUFPQSxDQUFDLHlGQUFtQjtBQUM1QyxJQUFJVSxVQUFVVixtQkFBT0EsQ0FBQyxtRkFBZ0I7QUFDdEMsSUFBSVcsY0FBY1gsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlZLGNBQWNaLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM5QyxJQUFJYSxXQUFXYixtQkFBT0EsQ0FBQyx1RkFBa0I7QUFDekMsSUFBSWMsT0FBT2QsbUJBQU9BLENBQUMsK0VBQWM7QUFDakMsSUFBSWUsU0FBU2YsbUJBQU9BLENBQUMsMkZBQW9CO0FBQ3pDLElBQUlnQixhQUFhaEIsbUJBQU9BLENBQUMsbUdBQXdCO0FBQ2pELElBQUlpQixjQUFjakIsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlrQixZQUFZO0lBQUM7Q0FBTTtBQUN2QixTQUFTaEIsdUJBQXVCaUIs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Q0MsY0FBY0EsY0FBYyxDQUFDLEdBQUc0SixRQUFRLENBQUMsR0FBRztvQkFDOURILFFBQVFBO2dCQUNWLEdBQUcsQ0FBQyxHQUFHN00sWUFBWStNLGdCQUFnQixFQUFFekYsSUFBSUUsSUFBSXFGLFFBQVFHLE1BQU1QLEtBQUs7WUFDbEUsT0FBTztnQkFDTHJFLGVBQWVqRixJQUFJLENBQUM2SjtZQUN0QjtRQUNGO0lBQ0Y7SUFDQSxPQUFPO1FBQ0xyRyxRQUFRQTtRQUNSd0IsU0FBU0E7UUFDVEMsZ0JBQWdCQTtJQUNsQjtBQUNGIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxwb2xhclxcUmFkYXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5SYWRhciA9IHZvaWQgMDtcclxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBfcmVhY3RTbW9vdGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1zbW9vdGhcIikpO1xyXG52YXIgX2lzTmlsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzTmlsXCIpKTtcclxudmFyIF9sYXN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2xhc3RcIikpO1xyXG52YXIgX2ZpcnN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2ZpcnN0XCIpKTtcclxudmFyIF9pc0VxdWFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRXF1YWxcIikpO1xyXG52YXIgX2lzRnVuY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XHJcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xyXG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0RhdGFVdGlsc1wiKTtcclxudmFyIF9HbG9iYWwgPSByZXF1aXJlKFwiLi4vdXRpbC9HbG9iYWxcIik7XHJcbnZhciBfUG9sYXJVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1BvbGFyVXRpbHNcIik7XHJcbnZhciBfQ2hhcnRVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NoYXJ0VXRpbHNcIik7XHJcbnZhciBfUG9seWdvbiA9IHJlcXVpcmUoXCIuLi9zaGFwZS9Qb2x5Z29uXCIpO1xyXG52YXIgX0RvdCA9IHJlcXVpcmUoXCIuLi9zaGFwZS9Eb3RcIik7XHJcbnZhciBfTGF5ZXIgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL0xheWVyXCIpO1xyXG52YXIgX0xhYmVsTGlzdCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQvTGFiZWxMaXN0XCIpO1xyXG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xyXG52YXIgX2V4Y2x1ZGVkID0gW1wia2V5XCJdO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XHJcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxyXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxyXG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxyXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cclxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XHJcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxyXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxyXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxyXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxyXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XHJcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxyXG4gKiBAZmlsZU92ZXJ2aWV3IFJhZGFyXHJcbiAqL1xyXG52YXIgUmFkYXIgPSBleHBvcnRzLlJhZGFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xyXG4gIGZ1bmN0aW9uIFJhZGFyKCkge1xyXG4gICAgdmFyIF90aGlzO1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhZGFyKTtcclxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xyXG4gICAgfVxyXG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIFJhZGFyLCBbXS5jb25jYXQoYXJncykpO1xyXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInN0YXRlXCIsIHtcclxuICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogZmFsc2VcclxuICAgIH0pO1xyXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZUFuaW1hdGlvbkVuZFwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBvbkFuaW1hdGlvbkVuZCA9IF90aGlzLnByb3BzLm9uQW5pbWF0aW9uRW5kO1xyXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9uQW5pbWF0aW9uRW5kKSkge1xyXG4gICAgICAgIG9uQW5pbWF0aW9uRW5kKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZUFuaW1hdGlvblN0YXJ0XCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG9uQW5pbWF0aW9uU3RhcnQgPSBfdGhpcy5wcm9wcy5vbkFuaW1hdGlvblN0YXJ0O1xyXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogZmFsc2VcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvbkFuaW1hdGlvblN0YXJ0KSkge1xyXG4gICAgICAgIG9uQW5pbWF0aW9uU3RhcnQoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlTW91c2VFbnRlclwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICB2YXIgb25Nb3VzZUVudGVyID0gX3RoaXMucHJvcHMub25Nb3VzZUVudGVyO1xyXG4gICAgICBpZiAob25Nb3VzZUVudGVyKSB7XHJcbiAgICAgICAgb25Nb3VzZUVudGVyKF90aGlzLnByb3BzLCBlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlTW91c2VMZWF2ZVwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICB2YXIgb25Nb3VzZUxlYXZlID0gX3RoaXMucHJvcHMub25Nb3VzZUxlYXZlO1xyXG4gICAgICBpZiAob25Nb3VzZUxlYXZlKSB7XHJcbiAgICAgICAgb25Nb3VzZUxlYXZlKF90aGlzLnByb3BzLCBlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gX3RoaXM7XHJcbiAgfVxyXG4gIF9pbmhlcml0cyhSYWRhciwgX1B1cmVDb21wb25lbnQpO1xyXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUmFkYXIsIFt7XHJcbiAgICBrZXk6IFwicmVuZGVyRG90c1wiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckRvdHMocG9pbnRzKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgZG90ID0gX3RoaXMkcHJvcHMuZG90LFxyXG4gICAgICAgIGRhdGFLZXkgPSBfdGhpcyRwcm9wcy5kYXRhS2V5O1xyXG4gICAgICB2YXIgYmFzZVByb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0aGlzLnByb3BzLCBmYWxzZSk7XHJcbiAgICAgIHZhciBjdXN0b21Eb3RQcm9wcyA9ICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykoZG90LCB0cnVlKTtcclxuICAgICAgdmFyIGRvdHMgPSBwb2ludHMubWFwKGZ1bmN0aW9uIChlbnRyeSwgaSkge1xyXG4gICAgICAgIHZhciBkb3RQcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcclxuICAgICAgICAgIGtleTogXCJkb3QtXCIuY29uY2F0KGkpLFxyXG4gICAgICAgICAgcjogM1xyXG4gICAgICAgIH0sIGJhc2VQcm9wcyksIGN1c3RvbURvdFByb3BzKSwge30sIHtcclxuICAgICAgICAgIGRhdGFLZXk6IGRhdGFLZXksXHJcbiAgICAgICAgICBjeDogZW50cnkueCxcclxuICAgICAgICAgIGN5OiBlbnRyeS55LFxyXG4gICAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgICBwYXlsb2FkOiBlbnRyeVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBSYWRhci5yZW5kZXJEb3RJdGVtKGRvdCwgZG90UHJvcHMpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXJhZGFyLWRvdHNcIlxyXG4gICAgICB9LCBkb3RzKTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyUG9seWdvblN0YXRpY2FsbHlcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJQb2x5Z29uU3RhdGljYWxseShwb2ludHMpIHtcclxuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgc2hhcGUgPSBfdGhpcyRwcm9wczIuc2hhcGUsXHJcbiAgICAgICAgZG90ID0gX3RoaXMkcHJvcHMyLmRvdCxcclxuICAgICAgICBpc1JhbmdlID0gX3RoaXMkcHJvcHMyLmlzUmFuZ2UsXHJcbiAgICAgICAgYmFzZUxpbmVQb2ludHMgPSBfdGhpcyRwcm9wczIuYmFzZUxpbmVQb2ludHMsXHJcbiAgICAgICAgY29ubmVjdE51bGxzID0gX3RoaXMkcHJvcHMyLmNvbm5lY3ROdWxscztcclxuICAgICAgdmFyIHJhZGFyO1xyXG4gICAgICBpZiAoIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KHNoYXBlKSkge1xyXG4gICAgICAgIHJhZGFyID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KHNoYXBlLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMucHJvcHMpLCB7fSwge1xyXG4gICAgICAgICAgcG9pbnRzOiBwb2ludHNcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkoc2hhcGUpKSB7XHJcbiAgICAgICAgcmFkYXIgPSBzaGFwZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMucHJvcHMpLCB7fSwge1xyXG4gICAgICAgICAgcG9pbnRzOiBwb2ludHNcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmFkYXIgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9Qb2x5Z29uLlBvbHlnb24sIF9leHRlbmRzKHt9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRoaXMucHJvcHMsIHRydWUpLCB7XHJcbiAgICAgICAgICBvbk1vdXNlRW50ZXI6IHRoaXMuaGFuZGxlTW91c2VFbnRlcixcclxuICAgICAgICAgIG9uTW91c2VMZWF2ZTogdGhpcy5oYW5kbGVNb3VzZUxlYXZlLFxyXG4gICAgICAgICAgcG9pbnRzOiBwb2ludHMsXHJcbiAgICAgICAgICBiYXNlTGluZVBvaW50czogaXNSYW5nZSA/IGJhc2VMaW5lUG9pbnRzIDogbnVsbCxcclxuICAgICAgICAgIGNvbm5lY3ROdWxsczogY29ubmVjdE51bGxzXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xyXG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1yYWRhci1wb2x5Z29uXCJcclxuICAgICAgfSwgcmFkYXIsIGRvdCA/IHRoaXMucmVuZGVyRG90cyhwb2ludHMpIDogbnVsbCk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJlbmRlclBvbHlnb25XaXRoQW5pbWF0aW9uXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyUG9seWdvbldpdGhBbmltYXRpb24oKSB7XHJcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBwb2ludHMgPSBfdGhpcyRwcm9wczMucG9pbnRzLFxyXG4gICAgICAgIGlzQW5pbWF0aW9uQWN0aXZlID0gX3RoaXMkcHJvcHMzLmlzQW5pbWF0aW9uQWN0aXZlLFxyXG4gICAgICAgIGFuaW1hdGlvbkJlZ2luID0gX3RoaXMkcHJvcHMzLmFuaW1hdGlvbkJlZ2luLFxyXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uID0gX3RoaXMkcHJvcHMzLmFuaW1hdGlvbkR1cmF0aW9uLFxyXG4gICAgICAgIGFuaW1hdGlvbkVhc2luZyA9IF90aGlzJHByb3BzMy5hbmltYXRpb25FYXNpbmcsXHJcbiAgICAgICAgYW5pbWF0aW9uSWQgPSBfdGhpcyRwcm9wczMuYW5pbWF0aW9uSWQ7XHJcbiAgICAgIHZhciBwcmV2UG9pbnRzID0gdGhpcy5zdGF0ZS5wcmV2UG9pbnRzO1xyXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfcmVhY3RTbW9vdGhbXCJkZWZhdWx0XCJdLCB7XHJcbiAgICAgICAgYmVnaW46IGFuaW1hdGlvbkJlZ2luLFxyXG4gICAgICAgIGR1cmF0aW9uOiBhbmltYXRpb25EdXJhdGlvbixcclxuICAgICAgICBpc0FjdGl2ZTogaXNBbmltYXRpb25BY3RpdmUsXHJcbiAgICAgICAgZWFzaW5nOiBhbmltYXRpb25FYXNpbmcsXHJcbiAgICAgICAgZnJvbToge1xyXG4gICAgICAgICAgdDogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG86IHtcclxuICAgICAgICAgIHQ6IDFcclxuICAgICAgICB9LFxyXG4gICAgICAgIGtleTogXCJyYWRhci1cIi5jb25jYXQoYW5pbWF0aW9uSWQpLFxyXG4gICAgICAgIG9uQW5pbWF0aW9uRW5kOiB0aGlzLmhhbmRsZUFuaW1hdGlvbkVuZCxcclxuICAgICAgICBvbkFuaW1hdGlvblN0YXJ0OiB0aGlzLmhhbmRsZUFuaW1hdGlvblN0YXJ0XHJcbiAgICAgIH0sIGZ1bmN0aW9uIChfcmVmKSB7XHJcbiAgICAgICAgdmFyIHQgPSBfcmVmLnQ7XHJcbiAgICAgICAgdmFyIHByZXZQb2ludHNEaWZmRmFjdG9yID0gcHJldlBvaW50cyAmJiBwcmV2UG9pbnRzLmxlbmd0aCAvIHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHN0ZXBEYXRhID0gcG9pbnRzLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XHJcbiAgICAgICAgICB2YXIgcHJldiA9IHByZXZQb2ludHMgJiYgcHJldlBvaW50c1tNYXRoLmZsb29yKGluZGV4ICogcHJldlBvaW50c0RpZmZGYWN0b3IpXTtcclxuICAgICAgICAgIGlmIChwcmV2KSB7XHJcbiAgICAgICAgICAgIHZhciBfaW50ZXJwb2xhdG9yWCA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShwcmV2LngsIGVudHJ5LngpO1xyXG4gICAgICAgICAgICB2YXIgX2ludGVycG9sYXRvclkgPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikocHJldi55LCBlbnRyeS55KTtcclxuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xyXG4gICAgICAgICAgICAgIHg6IF9pbnRlcnBvbGF0b3JYKHQpLFxyXG4gICAgICAgICAgICAgIHk6IF9pbnRlcnBvbGF0b3JZKHQpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFyIGludGVycG9sYXRvclggPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikoZW50cnkuY3gsIGVudHJ5LngpO1xyXG4gICAgICAgICAgdmFyIGludGVycG9sYXRvclkgPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikoZW50cnkuY3ksIGVudHJ5LnkpO1xyXG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xyXG4gICAgICAgICAgICB4OiBpbnRlcnBvbGF0b3JYKHQpLFxyXG4gICAgICAgICAgICB5OiBpbnRlcnBvbGF0b3JZKHQpXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gX3RoaXMyLnJlbmRlclBvbHlnb25TdGF0aWNhbGx5KHN0ZXBEYXRhKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJlbmRlclBvbHlnb25cIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJQb2x5Z29uKCkge1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBwb2ludHMgPSBfdGhpcyRwcm9wczQucG9pbnRzLFxyXG4gICAgICAgIGlzQW5pbWF0aW9uQWN0aXZlID0gX3RoaXMkcHJvcHM0LmlzQW5pbWF0aW9uQWN0aXZlLFxyXG4gICAgICAgIGlzUmFuZ2UgPSBfdGhpcyRwcm9wczQuaXNSYW5nZTtcclxuICAgICAgdmFyIHByZXZQb2ludHMgPSB0aGlzLnN0YXRlLnByZXZQb2ludHM7XHJcbiAgICAgIGlmIChpc0FuaW1hdGlvbkFjdGl2ZSAmJiBwb2ludHMgJiYgcG9pbnRzLmxlbmd0aCAmJiAhaXNSYW5nZSAmJiAoIXByZXZQb2ludHMgfHwgISgwLCBfaXNFcXVhbFtcImRlZmF1bHRcIl0pKHByZXZQb2ludHMsIHBvaW50cykpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyUG9seWdvbldpdGhBbmltYXRpb24oKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJQb2x5Z29uU3RhdGljYWxseShwb2ludHMpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wczUgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIGhpZGUgPSBfdGhpcyRwcm9wczUuaGlkZSxcclxuICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczUuY2xhc3NOYW1lLFxyXG4gICAgICAgIHBvaW50cyA9IF90aGlzJHByb3BzNS5wb2ludHMsXHJcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wczUuaXNBbmltYXRpb25BY3RpdmU7XHJcbiAgICAgIGlmIChoaWRlIHx8ICFwb2ludHMgfHwgIXBvaW50cy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgaXNBbmltYXRpb25GaW5pc2hlZCA9IHRoaXMuc3RhdGUuaXNBbmltYXRpb25GaW5pc2hlZDtcclxuICAgICAgdmFyIGxheWVyQ2xhc3MgPSAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtcmFkYXInLCBjbGFzc05hbWUpO1xyXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIHtcclxuICAgICAgICBjbGFzc05hbWU6IGxheWVyQ2xhc3NcclxuICAgICAgfSwgdGhpcy5yZW5kZXJQb2x5Z29uKCksICghaXNBbmltYXRpb25BY3RpdmUgfHwgaXNBbmltYXRpb25GaW5pc2hlZCkgJiYgX0xhYmVsTGlzdC5MYWJlbExpc3QucmVuZGVyQ2FsbEJ5UGFyZW50KHRoaXMucHJvcHMsIHBvaW50cykpO1xyXG4gICAgfVxyXG4gIH1dLCBbe1xyXG4gICAga2V5OiBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1wiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSkge1xyXG4gICAgICBpZiAobmV4dFByb3BzLmFuaW1hdGlvbklkICE9PSBwcmV2U3RhdGUucHJldkFuaW1hdGlvbklkKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHByZXZBbmltYXRpb25JZDogbmV4dFByb3BzLmFuaW1hdGlvbklkLFxyXG4gICAgICAgICAgY3VyUG9pbnRzOiBuZXh0UHJvcHMucG9pbnRzLFxyXG4gICAgICAgICAgcHJldlBvaW50czogcHJldlN0YXRlLmN1clBvaW50c1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5leHRQcm9wcy5wb2ludHMgIT09IHByZXZTdGF0ZS5jdXJQb2ludHMpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgY3VyUG9pbnRzOiBuZXh0UHJvcHMucG9pbnRzXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyRG90SXRlbVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckRvdEl0ZW0ob3B0aW9uLCBwcm9wcykge1xyXG4gICAgICB2YXIgZG90SXRlbTtcclxuICAgICAgaWYgKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5pc1ZhbGlkRWxlbWVudChvcHRpb24pKSB7XHJcbiAgICAgICAgZG90SXRlbSA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChvcHRpb24sIHByb3BzKTtcclxuICAgICAgfSBlbHNlIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvcHRpb24pKSB7XHJcbiAgICAgICAgZG90SXRlbSA9IG9wdGlvbihwcm9wcyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGtleSA9IHByb3BzLmtleSxcclxuICAgICAgICAgIGRvdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQpO1xyXG4gICAgICAgIGRvdEl0ZW0gPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9Eb3QuRG90LCBfZXh0ZW5kcyh7fSwgZG90UHJvcHMsIHtcclxuICAgICAgICAgIGtleToga2V5LFxyXG4gICAgICAgICAgY2xhc3NOYW1lOiAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtcmFkYXItZG90JywgdHlwZW9mIG9wdGlvbiAhPT0gJ2Jvb2xlYW4nID8gb3B0aW9uLmNsYXNzTmFtZSA6ICcnKVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZG90SXRlbTtcclxuICAgIH1cclxuICB9XSk7XHJcbn0oX3JlYWN0LlB1cmVDb21wb25lbnQpO1xyXG5fZGVmaW5lUHJvcGVydHkoUmFkYXIsIFwiZGlzcGxheU5hbWVcIiwgJ1JhZGFyJyk7XHJcbl9kZWZpbmVQcm9wZXJ0eShSYWRhciwgXCJkZWZhdWx0UHJvcHNcIiwge1xyXG4gIGFuZ2xlQXhpc0lkOiAwLFxyXG4gIHJhZGl1c0F4aXNJZDogMCxcclxuICBoaWRlOiBmYWxzZSxcclxuICBhY3RpdmVEb3Q6IHRydWUsXHJcbiAgZG90OiBmYWxzZSxcclxuICBsZWdlbmRUeXBlOiAncmVjdCcsXHJcbiAgaXNBbmltYXRpb25BY3RpdmU6ICFfR2xvYmFsLkdsb2JhbC5pc1NzcixcclxuICBhbmltYXRpb25CZWdpbjogMCxcclxuICBhbmltYXRpb25EdXJhdGlvbjogMTUwMCxcclxuICBhbmltYXRpb25FYXNpbmc6ICdlYXNlJ1xyXG59KTtcclxuX2RlZmluZVByb3BlcnR5KFJhZGFyLCBcImdldENvbXBvc2VkRGF0YVwiLCBmdW5jdGlvbiAoX3JlZjIpIHtcclxuICB2YXIgcmFkaXVzQXhpcyA9IF9yZWYyLnJhZGl1c0F4aXMsXHJcbiAgICBhbmdsZUF4aXMgPSBfcmVmMi5hbmdsZUF4aXMsXHJcbiAgICBkaXNwbGF5ZWREYXRhID0gX3JlZjIuZGlzcGxheWVkRGF0YSxcclxuICAgIGRhdGFLZXkgPSBfcmVmMi5kYXRhS2V5LFxyXG4gICAgYmFuZFNpemUgPSBfcmVmMi5iYW5kU2l6ZTtcclxuICB2YXIgY3ggPSBhbmdsZUF4aXMuY3gsXHJcbiAgICBjeSA9IGFuZ2xlQXhpcy5jeTtcclxuICB2YXIgaXNSYW5nZSA9IGZhbHNlO1xyXG4gIHZhciBwb2ludHMgPSBbXTtcclxuICB2YXIgYW5nbGVCYW5kU2l6ZSA9IGFuZ2xlQXhpcy50eXBlICE9PSAnbnVtYmVyJyA/IGJhbmRTaXplICE9PSBudWxsICYmIGJhbmRTaXplICE9PSB2b2lkIDAgPyBiYW5kU2l6ZSA6IDAgOiAwO1xyXG4gIGRpc3BsYXllZERhdGEuZm9yRWFjaChmdW5jdGlvbiAoZW50cnksIGkpIHtcclxuICAgIHZhciBuYW1lID0gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShlbnRyeSwgYW5nbGVBeGlzLmRhdGFLZXksIGkpO1xyXG4gICAgdmFyIHZhbHVlID0gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShlbnRyeSwgZGF0YUtleSk7XHJcbiAgICB2YXIgYW5nbGUgPSBhbmdsZUF4aXMuc2NhbGUobmFtZSkgKyBhbmdsZUJhbmRTaXplO1xyXG4gICAgdmFyIHBvaW50VmFsdWUgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/ICgwLCBfbGFzdFtcImRlZmF1bHRcIl0pKHZhbHVlKSA6IHZhbHVlO1xyXG4gICAgdmFyIHJhZGl1cyA9ICgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShwb2ludFZhbHVlKSA/IHVuZGVmaW5lZCA6IHJhZGl1c0F4aXMuc2NhbGUocG9pbnRWYWx1ZSk7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID49IDIpIHtcclxuICAgICAgaXNSYW5nZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBwb2ludHMucHVzaChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjeCwgY3ksIHJhZGl1cywgYW5nbGUpKSwge30sIHtcclxuICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICBjeDogY3gsXHJcbiAgICAgIGN5OiBjeSxcclxuICAgICAgcmFkaXVzOiByYWRpdXMsXHJcbiAgICAgIGFuZ2xlOiBhbmdsZSxcclxuICAgICAgcGF5bG9hZDogZW50cnlcclxuICAgIH0pKTtcclxuICB9KTtcclxuICB2YXIgYmFzZUxpbmVQb2ludHMgPSBbXTtcclxuICBpZiAoaXNSYW5nZSkge1xyXG4gICAgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBvaW50LnZhbHVlKSkge1xyXG4gICAgICAgIHZhciBiYXNlVmFsdWUgPSAoMCwgX2ZpcnN0W1wiZGVmYXVsdFwiXSkocG9pbnQudmFsdWUpO1xyXG4gICAgICAgIHZhciByYWRpdXMgPSAoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoYmFzZVZhbHVlKSA/IHVuZGVmaW5lZCA6IHJhZGl1c0F4aXMuc2NhbGUoYmFzZVZhbHVlKTtcclxuICAgICAgICBiYXNlTGluZVBvaW50cy5wdXNoKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcG9pbnQpLCB7fSwge1xyXG4gICAgICAgICAgcmFkaXVzOiByYWRpdXNcclxuICAgICAgICB9LCAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikoY3gsIGN5LCByYWRpdXMsIHBvaW50LmFuZ2xlKSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJhc2VMaW5lUG9pbnRzLnB1c2gocG9pbnQpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHBvaW50czogcG9pbnRzLFxyXG4gICAgaXNSYW5nZTogaXNSYW5nZSxcclxuICAgIGJhc2VMaW5lUG9pbnRzOiBiYXNlTGluZVBvaW50c1xyXG4gIH07XHJcbn0pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlJhZGFyIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX3JlYWN0U21vb3RoIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9pc05pbCIsIl9sYXN0IiwiX2ZpcnN0IiwiX2lzRXF1YWwiLCJfaXNGdW5jdGlvbiIsIl9jbHN4IiwiX0RhdGFVdGlscyIsIl9HbG9iYWwiLCJfUG9sYXJVdGlscyIsIl9DaGFydFV0aWxzIiwiX1BvbHlnb24iLCJfRG90IiwiX0xheWVyIiwiX0xhYmVsTGlzdCIsIl9SZWFjdFV0aWxzIiwiX2V4Y2x1ZGVkIiwib2JqIiwiX19lc01vZHVsZSIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJfdHlwZW9mIiwiaGFzIiwiZ2V0IiwibiIsIl9fcHJvdG9fXyIsImEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ1IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaSIsInNldCIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsInNvdXJjZSIsImV4Y2x1ZGVkIiwidGFyZ2V0IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJrZXkiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzb3VyY2VTeW1ib2xLZXlzIiwibGVuZ3RoIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJvd25LZXlzIiwia2V5cyIsImZpbHRlciIsImVudW1lcmFibGUiLCJwdXNoIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2FsbFN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJCb29sZWFuIiwidmFsdWVPZiIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJfUHVyZUNvbXBvbmVudCIsIl90aGlzIiwiX2xlbiIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJjb25jYXQiLCJpc0FuaW1hdGlvbkZpbmlzaGVkIiwib25BbmltYXRpb25FbmQiLCJzZXRTdGF0ZSIsIm9uQW5pbWF0aW9uU3RhcnQiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJyZW5kZXJEb3RzIiwicG9pbnRzIiwiX3RoaXMkcHJvcHMiLCJkb3QiLCJkYXRhS2V5IiwiYmFzZVByb3BzIiwiZmlsdGVyUHJvcHMiLCJjdXN0b21Eb3RQcm9wcyIsImRvdHMiLCJtYXAiLCJlbnRyeSIsImRvdFByb3BzIiwiY3giLCJ4IiwiY3kiLCJ5IiwiaW5kZXgiLCJwYXlsb2FkIiwicmVuZGVyRG90SXRlbSIsImNyZWF0ZUVsZW1lbnQiLCJMYXllciIsImNsYXNzTmFtZSIsInJlbmRlclBvbHlnb25TdGF0aWNhbGx5IiwiX3RoaXMkcHJvcHMyIiwic2hhcGUiLCJpc1JhbmdlIiwiYmFzZUxpbmVQb2ludHMiLCJjb25uZWN0TnVsbHMiLCJyYWRhciIsImlzVmFsaWRFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwiUG9seWdvbiIsImhhbmRsZU1vdXNlRW50ZXIiLCJoYW5kbGVNb3VzZUxlYXZlIiwicmVuZGVyUG9seWdvbldpdGhBbmltYXRpb24iLCJfdGhpczIiLCJfdGhpcyRwcm9wczMiLCJpc0FuaW1hdGlvbkFjdGl2ZSIsImFuaW1hdGlvbkJlZ2luIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJhbmltYXRpb25FYXNpbmciLCJhbmltYXRpb25JZCIsInByZXZQb2ludHMiLCJzdGF0ZSIsImJlZ2luIiwiZHVyYXRpb24iLCJpc0FjdGl2ZSIsImVhc2luZyIsImZyb20iLCJ0byIsImhhbmRsZUFuaW1hdGlvbkVuZCIsImhhbmRsZUFuaW1hdGlvblN0YXJ0IiwiX3JlZiIsInByZXZQb2ludHNEaWZmRmFjdG9yIiwic3RlcERhdGEiLCJwcmV2IiwiTWF0aCIsImZsb29yIiwiX2ludGVycG9sYXRvclgiLCJpbnRlcnBvbGF0ZU51bWJlciIsIl9pbnRlcnBvbGF0b3JZIiwiaW50ZXJwb2xhdG9yWCIsImludGVycG9sYXRvclkiLCJyZW5kZXJQb2x5Z29uIiwiX3RoaXMkcHJvcHM0IiwicmVuZGVyIiwiX3RoaXMkcHJvcHM1IiwiaGlkZSIsImxheWVyQ2xhc3MiLCJMYWJlbExpc3QiLCJyZW5kZXJDYWxsQnlQYXJlbnQiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJuZXh0UHJvcHMiLCJwcmV2U3RhdGUiLCJwcmV2QW5pbWF0aW9uSWQiLCJjdXJQb2ludHMiLCJvcHRpb24iLCJkb3RJdGVtIiwiRG90IiwiUHVyZUNvbXBvbmVudCIsImFuZ2xlQXhpc0lkIiwicmFkaXVzQXhpc0lkIiwiYWN0aXZlRG90IiwibGVnZW5kVHlwZSIsIkdsb2JhbCIsImlzU3NyIiwiX3JlZjIiLCJyYWRpdXNBeGlzIiwiYW5nbGVBeGlzIiwiZGlzcGxheWVkRGF0YSIsImJhbmRTaXplIiwiYW5nbGVCYW5kU2l6ZSIsInR5cGUiLCJuYW1lIiwiZ2V0VmFsdWVCeURhdGFLZXkiLCJhbmdsZSIsInNjYWxlIiwicG9pbnRWYWx1ZSIsImlzQXJyYXkiLCJyYWRpdXMiLCJ1bmRlZmluZWQiLCJwb2xhclRvQ2FydGVzaWFuIiwicG9pbnQiLCJiYXNlVmFsdWUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/polar/Radar.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/polar/RadialBar.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/polar/RadialBar.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RadialBar = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _isEqual = _interopRequireDefault(__webpack_require__(/*! lodash/isEqual */ \"lodash/isEqual\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _RadialBarUtils = __webpack_require__(/*! ../util/RadialBarUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/RadialBarUtils.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"(pages-dir-node)/./node_modules/recharts/lib/util/Global.js\");\nvar _LabelList = __webpack_require__(/*! ../component/LabelList */ \"(pages-dir-node)/./node_modules/recharts/lib/component/LabelList.js\");\nvar _Cell = __webpack_require__(/*! ../component/Cell */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Cell.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _types = __webpack_require__(/*! ../util/types */ \"(pages-dir-node)/./node_modules/recharts/lib/util/types.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _excluded = [\n    \"shape\",\n    \"activeShape\",\n    \"activeIndex\",\n    \"cornerRadius\"\n], _excluded2 = [\n    \"value\",\n    \"background\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Render a group of radial bar\r\n */ \n// TODO: Cause of circular dependency. Needs refactoring of functions that need them.\n// import { AngleAxisProps, RadiusAxisProps } from './types';\nvar RadialBar = exports.RadialBar = /*#__PURE__*/ function(_PureComponent) {\n    function RadialBar() {\n        var _this;\n        _classCallCheck(this, RadialBar);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, RadialBar, [].concat(args));\n        _defineProperty(_this, \"state\", {\n            isAnimationFinished: false\n        });\n        _defineProperty(_this, \"handleAnimationEnd\", function() {\n            var onAnimationEnd = _this.props.onAnimationEnd;\n            _this.setState({\n                isAnimationFinished: true\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationEnd)) {\n                onAnimationEnd();\n            }\n        });\n        _defineProperty(_this, \"handleAnimationStart\", function() {\n            var onAnimationStart = _this.props.onAnimationStart;\n            _this.setState({\n                isAnimationFinished: false\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationStart)) {\n                onAnimationStart();\n            }\n        });\n        return _this;\n    }\n    _inherits(RadialBar, _PureComponent);\n    return _createClass(RadialBar, [\n        {\n            key: \"getDeltaAngle\",\n            value: function getDeltaAngle() {\n                var _this$props = this.props, startAngle = _this$props.startAngle, endAngle = _this$props.endAngle;\n                var sign = (0, _DataUtils.mathSign)(endAngle - startAngle);\n                var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);\n                return sign * deltaAngle;\n            }\n        },\n        {\n            key: \"renderSectorsStatically\",\n            value: function renderSectorsStatically(sectors) {\n                var _this2 = this;\n                var _this$props2 = this.props, shape = _this$props2.shape, activeShape = _this$props2.activeShape, activeIndex = _this$props2.activeIndex, cornerRadius = _this$props2.cornerRadius, others = _objectWithoutProperties(_this$props2, _excluded);\n                var baseProps = (0, _ReactUtils.filterProps)(others, false);\n                return sectors.map(function(entry, i) {\n                    var isActive = i === activeIndex;\n                    var props = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, baseProps), {}, {\n                        cornerRadius: (0, _RadialBarUtils.parseCornerRadius)(cornerRadius)\n                    }, entry), (0, _types.adaptEventsOfChild)(_this2.props, entry, i)), {}, {\n                        className: \"recharts-radial-bar-sector \".concat(entry.className),\n                        forceCornerRadius: others.forceCornerRadius,\n                        cornerIsExternal: others.cornerIsExternal,\n                        isActive: isActive,\n                        option: isActive ? activeShape : shape\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_RadialBarUtils.RadialBarSector, _extends({}, props, {\n                        key: \"sector-\".concat(i)\n                    }));\n                });\n            }\n        },\n        {\n            key: \"renderSectorsWithAnimation\",\n            value: function renderSectorsWithAnimation() {\n                var _this3 = this;\n                var _this$props3 = this.props, data = _this$props3.data, isAnimationActive = _this$props3.isAnimationActive, animationBegin = _this$props3.animationBegin, animationDuration = _this$props3.animationDuration, animationEasing = _this$props3.animationEasing, animationId = _this$props3.animationId;\n                var prevData = this.state.prevData;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n                    begin: animationBegin,\n                    duration: animationDuration,\n                    isActive: isAnimationActive,\n                    easing: animationEasing,\n                    from: {\n                        t: 0\n                    },\n                    to: {\n                        t: 1\n                    },\n                    key: \"radialBar-\".concat(animationId),\n                    onAnimationStart: this.handleAnimationStart,\n                    onAnimationEnd: this.handleAnimationEnd\n                }, function(_ref) {\n                    var t = _ref.t;\n                    var stepData = data.map(function(entry, index) {\n                        var prev = prevData && prevData[index];\n                        if (prev) {\n                            var interpolatorStartAngle = (0, _DataUtils.interpolateNumber)(prev.startAngle, entry.startAngle);\n                            var interpolatorEndAngle = (0, _DataUtils.interpolateNumber)(prev.endAngle, entry.endAngle);\n                            return _objectSpread(_objectSpread({}, entry), {}, {\n                                startAngle: interpolatorStartAngle(t),\n                                endAngle: interpolatorEndAngle(t)\n                            });\n                        }\n                        var endAngle = entry.endAngle, startAngle = entry.startAngle;\n                        var interpolator = (0, _DataUtils.interpolateNumber)(startAngle, endAngle);\n                        return _objectSpread(_objectSpread({}, entry), {}, {\n                            endAngle: interpolator(t)\n                        });\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, null, _this3.renderSectorsStatically(stepData));\n                });\n            }\n        },\n        {\n            key: \"renderSectors\",\n            value: function renderSectors() {\n                var _this$props4 = this.props, data = _this$props4.data, isAnimationActive = _this$props4.isAnimationActive;\n                var prevData = this.state.prevData;\n                if (isAnimationActive && data && data.length && (!prevData || !(0, _isEqual[\"default\"])(prevData, data))) {\n                    return this.renderSectorsWithAnimation();\n                }\n                return this.renderSectorsStatically(data);\n            }\n        },\n        {\n            key: \"renderBackground\",\n            value: function renderBackground(sectors) {\n                var _this4 = this;\n                var cornerRadius = this.props.cornerRadius;\n                var backgroundProps = (0, _ReactUtils.filterProps)(this.props.background, false);\n                return sectors.map(function(entry, i) {\n                    var value = entry.value, background = entry.background, rest = _objectWithoutProperties(entry, _excluded2);\n                    if (!background) {\n                        return null;\n                    }\n                    var props = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({\n                        cornerRadius: (0, _RadialBarUtils.parseCornerRadius)(cornerRadius)\n                    }, rest), {}, {\n                        fill: '#eee'\n                    }, background), backgroundProps), (0, _types.adaptEventsOfChild)(_this4.props, entry, i)), {}, {\n                        index: i,\n                        className: (0, _clsx[\"default\"])('recharts-radial-bar-background-sector', backgroundProps === null || backgroundProps === void 0 ? void 0 : backgroundProps.className),\n                        option: background,\n                        isActive: false\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_RadialBarUtils.RadialBarSector, _extends({}, props, {\n                        key: \"sector-\".concat(i)\n                    }));\n                });\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props5 = this.props, hide = _this$props5.hide, data = _this$props5.data, className = _this$props5.className, background = _this$props5.background, isAnimationActive = _this$props5.isAnimationActive;\n                if (hide || !data || !data.length) {\n                    return null;\n                }\n                var isAnimationFinished = this.state.isAnimationFinished;\n                var layerClass = (0, _clsx[\"default\"])('recharts-area', className);\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: layerClass\n                }, background && /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-radial-bar-background\"\n                }, this.renderBackground(data)), /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-radial-bar-sectors\"\n                }, this.renderSectors()), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(_objectSpread({}, this.props), data));\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                if (nextProps.animationId !== prevState.prevAnimationId) {\n                    return {\n                        prevAnimationId: nextProps.animationId,\n                        curData: nextProps.data,\n                        prevData: prevState.curData\n                    };\n                }\n                if (nextProps.data !== prevState.curData) {\n                    return {\n                        curData: nextProps.data\n                    };\n                }\n                return null;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(RadialBar, \"displayName\", 'RadialBar');\n_defineProperty(RadialBar, \"defaultProps\", {\n    angleAxisId: 0,\n    radiusAxisId: 0,\n    minPointSize: 0,\n    hide: false,\n    legendType: 'rect',\n    data: [],\n    isAnimationActive: !_Global.Global.isSsr,\n    animationBegin: 0,\n    animationDuration: 1500,\n    animationEasing: 'ease',\n    forceCornerRadius: false,\n    cornerIsExternal: false\n});\n_defineProperty(RadialBar, \"getComposedData\", function(_ref2) {\n    var item = _ref2.item, props = _ref2.props, radiusAxis = _ref2.radiusAxis, radiusAxisTicks = _ref2.radiusAxisTicks, angleAxis = _ref2.angleAxis, angleAxisTicks = _ref2.angleAxisTicks, displayedData = _ref2.displayedData, dataKey = _ref2.dataKey, stackedData = _ref2.stackedData, barPosition = _ref2.barPosition, bandSize = _ref2.bandSize, dataStartIndex = _ref2.dataStartIndex;\n    var pos = (0, _ChartUtils.findPositionOfBar)(barPosition, item);\n    if (!pos) {\n        return null;\n    }\n    var cx = angleAxis.cx, cy = angleAxis.cy;\n    var layout = props.layout;\n    var _item$props = item.props, children = _item$props.children, minPointSize = _item$props.minPointSize;\n    var numericAxis = layout === 'radial' ? angleAxis : radiusAxis;\n    var stackedDomain = stackedData ? numericAxis.scale.domain() : null;\n    var baseValue = (0, _ChartUtils.getBaseValueOfBar)({\n        numericAxis: numericAxis\n    });\n    var cells = (0, _ReactUtils.findAllByType)(children, _Cell.Cell);\n    var sectors = displayedData.map(function(entry, index) {\n        var value, innerRadius, outerRadius, startAngle, endAngle, backgroundSector;\n        if (stackedData) {\n            value = (0, _ChartUtils.truncateByDomain)(stackedData[dataStartIndex + index], stackedDomain);\n        } else {\n            value = (0, _ChartUtils.getValueByDataKey)(entry, dataKey);\n            if (!Array.isArray(value)) {\n                value = [\n                    baseValue,\n                    value\n                ];\n            }\n        }\n        if (layout === 'radial') {\n            innerRadius = (0, _ChartUtils.getCateCoordinateOfBar)({\n                axis: radiusAxis,\n                ticks: radiusAxisTicks,\n                bandSize: bandSize,\n                offset: pos.offset,\n                entry: entry,\n                index: index\n            });\n            endAngle = angleAxis.scale(value[1]);\n            startAngle = angleAxis.scale(value[0]);\n            outerRadius = innerRadius + pos.size;\n            var deltaAngle = endAngle - startAngle;\n            if (Math.abs(minPointSize) > 0 && Math.abs(deltaAngle) < Math.abs(minPointSize)) {\n                var delta = (0, _DataUtils.mathSign)(deltaAngle || minPointSize) * (Math.abs(minPointSize) - Math.abs(deltaAngle));\n                endAngle += delta;\n            }\n            backgroundSector = {\n                background: {\n                    cx: cx,\n                    cy: cy,\n                    innerRadius: innerRadius,\n                    outerRadius: outerRadius,\n                    startAngle: props.startAngle,\n                    endAngle: props.endAngle\n                }\n            };\n        } else {\n            innerRadius = radiusAxis.scale(value[0]);\n            outerRadius = radiusAxis.scale(value[1]);\n            startAngle = (0, _ChartUtils.getCateCoordinateOfBar)({\n                axis: angleAxis,\n                ticks: angleAxisTicks,\n                bandSize: bandSize,\n                offset: pos.offset,\n                entry: entry,\n                index: index\n            });\n            endAngle = startAngle + pos.size;\n            var deltaRadius = outerRadius - innerRadius;\n            if (Math.abs(minPointSize) > 0 && Math.abs(deltaRadius) < Math.abs(minPointSize)) {\n                var _delta = (0, _DataUtils.mathSign)(deltaRadius || minPointSize) * (Math.abs(minPointSize) - Math.abs(deltaRadius));\n                outerRadius += _delta;\n            }\n        }\n        return _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, entry), backgroundSector), {}, {\n            payload: entry,\n            value: stackedData ? value : value[1],\n            cx: cx,\n            cy: cy,\n            innerRadius: innerRadius,\n            outerRadius: outerRadius,\n            startAngle: startAngle,\n            endAngle: endAngle\n        }, cells && cells[index] && cells[index].props), {}, {\n            tooltipPayload: [\n                (0, _ChartUtils.getTooltipItem)(item, entry)\n            ],\n            tooltipPosition: (0, _PolarUtils.polarToCartesian)(cx, cy, (innerRadius + outerRadius) / 2, (startAngle + endAngle) / 2)\n        });\n    });\n    return {\n        data: sectors,\n        layout: layout\n    };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvcG9sYXIvUmFkaWFsQmFyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLElBQUlHLFNBQVNDLHdCQUF3QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUMsUUFBUUMsdUJBQXVCRixtQkFBT0EsQ0FBQyx1QkFBTTtBQUNqRCxJQUFJRyxlQUFlRCx1QkFBdUJGLG1CQUFPQSxDQUFDLGtDQUFjO0FBQ2hFLElBQUlJLFdBQVdGLHVCQUF1QkYsbUJBQU9BLENBQUMsc0NBQWdCO0FBQzlELElBQUlLLGNBQWNILHVCQUF1QkYsbUJBQU9BLENBQUMsNENBQW1CO0FBQ3BFLElBQUlNLGtCQUFrQk4sbUJBQU9BLENBQUMsbUdBQXdCO0FBQ3RELElBQUlPLFNBQVNQLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUN6QyxJQUFJUSxjQUFjUixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDOUMsSUFBSVMsVUFBVVQsbUJBQU9BLENBQUMsbUZBQWdCO0FBQ3RDLElBQUlVLGFBQWFWLG1CQUFPQSxDQUFDLG1HQUF3QjtBQUNqRCxJQUFJVyxRQUFRWCxtQkFBT0EsQ0FBQyx5RkFBbUI7QUFDdkMsSUFBSVksYUFBYVosbUJBQU9BLENBQUMseUZBQW1CO0FBQzVDLElBQUlhLGNBQWNiLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM5QyxJQUFJYyxTQUFTZCxtQkFBT0EsQ0FBQyxpRkFBZTtBQUNwQyxJQUFJZSxjQUFjZixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDOUMsSUFBSWdCLFlBQVk7SUFBQztJQUFTO0lBQWU7SUFBZTtDQUFlLEVBQ3JFQyxhQUFhO0lBQUM7SUFBUztDQUFhO0FBQ3RDLFNBQVNmLHVCQUF1QmdCLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxX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ckN5TixJQUFJQTtZQUNKQyxJQUFJQTtZQUNKYSxhQUFhQTtZQUNiQyxhQUFhQTtZQUNiaEgsWUFBWUE7WUFDWkMsVUFBVUE7UUFDWixHQUFHMkcsU0FBU0EsS0FBSyxDQUFDMUQsTUFBTSxJQUFJMEQsS0FBSyxDQUFDMUQsTUFBTSxDQUFDOUYsS0FBSyxHQUFHLENBQUMsR0FBRztZQUNuRDBLLGdCQUFnQjtnQkFBRSxJQUFHck8sWUFBWXNPLGNBQWMsRUFBRTNDLE1BQU1oRTthQUFPO1lBQzlENEcsaUJBQWlCLENBQUMsR0FBR3JPLFlBQVlzTyxnQkFBZ0IsRUFBRWhDLElBQUlDLElBQUksQ0FBQ2EsY0FBY0MsV0FBVSxJQUFLLEdBQUcsQ0FBQ2hILGFBQWFDLFFBQU8sSUFBSztRQUN4SDtJQUNGO0lBQ0EsT0FBTztRQUNMZ0MsTUFBTXhCO1FBQ04wRixRQUFRQTtJQUNWO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXHBvbGFyXFxSYWRpYWxCYXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5SYWRpYWxCYXIgPSB2b2lkIDA7XHJcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcclxudmFyIF9yZWFjdFNtb290aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0LXNtb290aFwiKSk7XHJcbnZhciBfaXNFcXVhbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0VxdWFsXCIpKTtcclxudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xyXG52YXIgX1JhZGlhbEJhclV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmFkaWFsQmFyVXRpbHNcIik7XHJcbnZhciBfTGF5ZXIgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL0xheWVyXCIpO1xyXG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xyXG52YXIgX0dsb2JhbCA9IHJlcXVpcmUoXCIuLi91dGlsL0dsb2JhbFwiKTtcclxudmFyIF9MYWJlbExpc3QgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50L0xhYmVsTGlzdFwiKTtcclxudmFyIF9DZWxsID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9DZWxsXCIpO1xyXG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0RhdGFVdGlsc1wiKTtcclxudmFyIF9DaGFydFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvQ2hhcnRVdGlsc1wiKTtcclxudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuLi91dGlsL3R5cGVzXCIpO1xyXG52YXIgX1BvbGFyVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9Qb2xhclV0aWxzXCIpO1xyXG52YXIgX2V4Y2x1ZGVkID0gW1wic2hhcGVcIiwgXCJhY3RpdmVTaGFwZVwiLCBcImFjdGl2ZUluZGV4XCIsIFwiY29ybmVyUmFkaXVzXCJdLFxyXG4gIF9leGNsdWRlZDIgPSBbXCJ2YWx1ZVwiLCBcImJhY2tncm91bmRcIl07XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XHJcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XHJcbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XHJcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxyXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cclxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XHJcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XHJcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cclxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH0gLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgUmVuZGVyIGEgZ3JvdXAgb2YgcmFkaWFsIGJhclxyXG4gKi9cclxuLy8gVE9ETzogQ2F1c2Ugb2YgY2lyY3VsYXIgZGVwZW5kZW5jeS4gTmVlZHMgcmVmYWN0b3Jpbmcgb2YgZnVuY3Rpb25zIHRoYXQgbmVlZCB0aGVtLlxyXG4vLyBpbXBvcnQgeyBBbmdsZUF4aXNQcm9wcywgUmFkaXVzQXhpc1Byb3BzIH0gZnJvbSAnLi90eXBlcyc7XHJcbnZhciBSYWRpYWxCYXIgPSBleHBvcnRzLlJhZGlhbEJhciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1B1cmVDb21wb25lbnQpIHtcclxuICBmdW5jdGlvbiBSYWRpYWxCYXIoKSB7XHJcbiAgICB2YXIgX3RoaXM7XHJcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmFkaWFsQmFyKTtcclxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xyXG4gICAgfVxyXG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIFJhZGlhbEJhciwgW10uY29uY2F0KGFyZ3MpKTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJzdGF0ZVwiLCB7XHJcbiAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6IGZhbHNlXHJcbiAgICB9KTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVBbmltYXRpb25FbmRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgb25BbmltYXRpb25FbmQgPSBfdGhpcy5wcm9wcy5vbkFuaW1hdGlvbkVuZDtcclxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvbkFuaW1hdGlvbkVuZCkpIHtcclxuICAgICAgICBvbkFuaW1hdGlvbkVuZCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVBbmltYXRpb25TdGFydFwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBvbkFuaW1hdGlvblN0YXJ0ID0gX3RoaXMucHJvcHMub25BbmltYXRpb25TdGFydDtcclxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6IGZhbHNlXHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob25BbmltYXRpb25TdGFydCkpIHtcclxuICAgICAgICBvbkFuaW1hdGlvblN0YXJ0KCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuICBfaW5oZXJpdHMoUmFkaWFsQmFyLCBfUHVyZUNvbXBvbmVudCk7XHJcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhSYWRpYWxCYXIsIFt7XHJcbiAgICBrZXk6IFwiZ2V0RGVsdGFBbmdsZVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlbHRhQW5nbGUoKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgc3RhcnRBbmdsZSA9IF90aGlzJHByb3BzLnN0YXJ0QW5nbGUsXHJcbiAgICAgICAgZW5kQW5nbGUgPSBfdGhpcyRwcm9wcy5lbmRBbmdsZTtcclxuICAgICAgdmFyIHNpZ24gPSAoMCwgX0RhdGFVdGlscy5tYXRoU2lnbikoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcclxuICAgICAgdmFyIGRlbHRhQW5nbGUgPSBNYXRoLm1pbihNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpLCAzNjApO1xyXG4gICAgICByZXR1cm4gc2lnbiAqIGRlbHRhQW5nbGU7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJlbmRlclNlY3RvcnNTdGF0aWNhbGx5XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyU2VjdG9yc1N0YXRpY2FsbHkoc2VjdG9ycykge1xyXG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgc2hhcGUgPSBfdGhpcyRwcm9wczIuc2hhcGUsXHJcbiAgICAgICAgYWN0aXZlU2hhcGUgPSBfdGhpcyRwcm9wczIuYWN0aXZlU2hhcGUsXHJcbiAgICAgICAgYWN0aXZlSW5kZXggPSBfdGhpcyRwcm9wczIuYWN0aXZlSW5kZXgsXHJcbiAgICAgICAgY29ybmVyUmFkaXVzID0gX3RoaXMkcHJvcHMyLmNvcm5lclJhZGl1cyxcclxuICAgICAgICBvdGhlcnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkcHJvcHMyLCBfZXhjbHVkZWQpO1xyXG4gICAgICB2YXIgYmFzZVByb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShvdGhlcnMsIGZhbHNlKTtcclxuICAgICAgcmV0dXJuIHNlY3RvcnMubWFwKGZ1bmN0aW9uIChlbnRyeSwgaSkge1xyXG4gICAgICAgIHZhciBpc0FjdGl2ZSA9IGkgPT09IGFjdGl2ZUluZGV4O1xyXG4gICAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGJhc2VQcm9wcyksIHt9LCB7XHJcbiAgICAgICAgICBjb3JuZXJSYWRpdXM6ICgwLCBfUmFkaWFsQmFyVXRpbHMucGFyc2VDb3JuZXJSYWRpdXMpKGNvcm5lclJhZGl1cylcclxuICAgICAgICB9LCBlbnRyeSksICgwLCBfdHlwZXMuYWRhcHRFdmVudHNPZkNoaWxkKShfdGhpczIucHJvcHMsIGVudHJ5LCBpKSksIHt9LCB7XHJcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtcmFkaWFsLWJhci1zZWN0b3IgXCIuY29uY2F0KGVudHJ5LmNsYXNzTmFtZSksXHJcbiAgICAgICAgICBmb3JjZUNvcm5lclJhZGl1czogb3RoZXJzLmZvcmNlQ29ybmVyUmFkaXVzLFxyXG4gICAgICAgICAgY29ybmVySXNFeHRlcm5hbDogb3RoZXJzLmNvcm5lcklzRXh0ZXJuYWwsXHJcbiAgICAgICAgICBpc0FjdGl2ZTogaXNBY3RpdmUsXHJcbiAgICAgICAgICBvcHRpb246IGlzQWN0aXZlID8gYWN0aXZlU2hhcGUgOiBzaGFwZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9SYWRpYWxCYXJVdGlscy5SYWRpYWxCYXJTZWN0b3IsIF9leHRlbmRzKHt9LCBwcm9wcywge1xyXG4gICAgICAgICAga2V5OiBcInNlY3Rvci1cIi5jb25jYXQoaSlcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJTZWN0b3JzV2l0aEFuaW1hdGlvblwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclNlY3RvcnNXaXRoQW5pbWF0aW9uKCkge1xyXG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcclxuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgZGF0YSA9IF90aGlzJHByb3BzMy5kYXRhLFxyXG4gICAgICAgIGlzQW5pbWF0aW9uQWN0aXZlID0gX3RoaXMkcHJvcHMzLmlzQW5pbWF0aW9uQWN0aXZlLFxyXG4gICAgICAgIGFuaW1hdGlvbkJlZ2luID0gX3RoaXMkcHJvcHMzLmFuaW1hdGlvbkJlZ2luLFxyXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uID0gX3RoaXMkcHJvcHMzLmFuaW1hdGlvbkR1cmF0aW9uLFxyXG4gICAgICAgIGFuaW1hdGlvbkVhc2luZyA9IF90aGlzJHByb3BzMy5hbmltYXRpb25FYXNpbmcsXHJcbiAgICAgICAgYW5pbWF0aW9uSWQgPSBfdGhpcyRwcm9wczMuYW5pbWF0aW9uSWQ7XHJcbiAgICAgIHZhciBwcmV2RGF0YSA9IHRoaXMuc3RhdGUucHJldkRhdGE7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9yZWFjdFNtb290aFtcImRlZmF1bHRcIl0sIHtcclxuICAgICAgICBiZWdpbjogYW5pbWF0aW9uQmVnaW4sXHJcbiAgICAgICAgZHVyYXRpb246IGFuaW1hdGlvbkR1cmF0aW9uLFxyXG4gICAgICAgIGlzQWN0aXZlOiBpc0FuaW1hdGlvbkFjdGl2ZSxcclxuICAgICAgICBlYXNpbmc6IGFuaW1hdGlvbkVhc2luZyxcclxuICAgICAgICBmcm9tOiB7XHJcbiAgICAgICAgICB0OiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0bzoge1xyXG4gICAgICAgICAgdDogMVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAga2V5OiBcInJhZGlhbEJhci1cIi5jb25jYXQoYW5pbWF0aW9uSWQpLFxyXG4gICAgICAgIG9uQW5pbWF0aW9uU3RhcnQ6IHRoaXMuaGFuZGxlQW5pbWF0aW9uU3RhcnQsXHJcbiAgICAgICAgb25BbmltYXRpb25FbmQ6IHRoaXMuaGFuZGxlQW5pbWF0aW9uRW5kXHJcbiAgICAgIH0sIGZ1bmN0aW9uIChfcmVmKSB7XHJcbiAgICAgICAgdmFyIHQgPSBfcmVmLnQ7XHJcbiAgICAgICAgdmFyIHN0ZXBEYXRhID0gZGF0YS5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xyXG4gICAgICAgICAgdmFyIHByZXYgPSBwcmV2RGF0YSAmJiBwcmV2RGF0YVtpbmRleF07XHJcbiAgICAgICAgICBpZiAocHJldikge1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJwb2xhdG9yU3RhcnRBbmdsZSA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShwcmV2LnN0YXJ0QW5nbGUsIGVudHJ5LnN0YXJ0QW5nbGUpO1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJwb2xhdG9yRW5kQW5nbGUgPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikocHJldi5lbmRBbmdsZSwgZW50cnkuZW5kQW5nbGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeSksIHt9LCB7XHJcbiAgICAgICAgICAgICAgc3RhcnRBbmdsZTogaW50ZXJwb2xhdG9yU3RhcnRBbmdsZSh0KSxcclxuICAgICAgICAgICAgICBlbmRBbmdsZTogaW50ZXJwb2xhdG9yRW5kQW5nbGUodClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBlbnRyeS5lbmRBbmdsZSxcclxuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IGVudHJ5LnN0YXJ0QW5nbGU7XHJcbiAgICAgICAgICB2YXIgaW50ZXJwb2xhdG9yID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcclxuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcclxuICAgICAgICAgICAgZW5kQW5nbGU6IGludGVycG9sYXRvcih0KVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCBudWxsLCBfdGhpczMucmVuZGVyU2VjdG9yc1N0YXRpY2FsbHkoc3RlcERhdGEpKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJlbmRlclNlY3RvcnNcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJTZWN0b3JzKCkge1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBkYXRhID0gX3RoaXMkcHJvcHM0LmRhdGEsXHJcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wczQuaXNBbmltYXRpb25BY3RpdmU7XHJcbiAgICAgIHZhciBwcmV2RGF0YSA9IHRoaXMuc3RhdGUucHJldkRhdGE7XHJcbiAgICAgIGlmIChpc0FuaW1hdGlvbkFjdGl2ZSAmJiBkYXRhICYmIGRhdGEubGVuZ3RoICYmICghcHJldkRhdGEgfHwgISgwLCBfaXNFcXVhbFtcImRlZmF1bHRcIl0pKHByZXZEYXRhLCBkYXRhKSkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJTZWN0b3JzV2l0aEFuaW1hdGlvbigpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlclNlY3RvcnNTdGF0aWNhbGx5KGRhdGEpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZW5kZXJCYWNrZ3JvdW5kXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQmFja2dyb3VuZChzZWN0b3JzKSB7XHJcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xyXG4gICAgICB2YXIgY29ybmVyUmFkaXVzID0gdGhpcy5wcm9wcy5jb3JuZXJSYWRpdXM7XHJcbiAgICAgIHZhciBiYWNrZ3JvdW5kUHJvcHMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRoaXMucHJvcHMuYmFja2dyb3VuZCwgZmFsc2UpO1xyXG4gICAgICByZXR1cm4gc2VjdG9ycy5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gZW50cnkudmFsdWUsXHJcbiAgICAgICAgICBiYWNrZ3JvdW5kID0gZW50cnkuYmFja2dyb3VuZCxcclxuICAgICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZW50cnksIF9leGNsdWRlZDIpO1xyXG4gICAgICAgIGlmICghYmFja2dyb3VuZCkge1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XHJcbiAgICAgICAgICBjb3JuZXJSYWRpdXM6ICgwLCBfUmFkaWFsQmFyVXRpbHMucGFyc2VDb3JuZXJSYWRpdXMpKGNvcm5lclJhZGl1cylcclxuICAgICAgICB9LCByZXN0KSwge30sIHtcclxuICAgICAgICAgIGZpbGw6ICcjZWVlJ1xyXG4gICAgICAgIH0sIGJhY2tncm91bmQpLCBiYWNrZ3JvdW5kUHJvcHMpLCAoMCwgX3R5cGVzLmFkYXB0RXZlbnRzT2ZDaGlsZCkoX3RoaXM0LnByb3BzLCBlbnRyeSwgaSkpLCB7fSwge1xyXG4gICAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1yYWRpYWwtYmFyLWJhY2tncm91bmQtc2VjdG9yJywgYmFja2dyb3VuZFByb3BzID09PSBudWxsIHx8IGJhY2tncm91bmRQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmFja2dyb3VuZFByb3BzLmNsYXNzTmFtZSksXHJcbiAgICAgICAgICBvcHRpb246IGJhY2tncm91bmQsXHJcbiAgICAgICAgICBpc0FjdGl2ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfUmFkaWFsQmFyVXRpbHMuUmFkaWFsQmFyU2VjdG9yLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcclxuICAgICAgICAgIGtleTogXCJzZWN0b3ItXCIuY29uY2F0KGkpXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVuZGVyXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgICB2YXIgX3RoaXMkcHJvcHM1ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBoaWRlID0gX3RoaXMkcHJvcHM1LmhpZGUsXHJcbiAgICAgICAgZGF0YSA9IF90aGlzJHByb3BzNS5kYXRhLFxyXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzNS5jbGFzc05hbWUsXHJcbiAgICAgICAgYmFja2dyb3VuZCA9IF90aGlzJHByb3BzNS5iYWNrZ3JvdW5kLFxyXG4gICAgICAgIGlzQW5pbWF0aW9uQWN0aXZlID0gX3RoaXMkcHJvcHM1LmlzQW5pbWF0aW9uQWN0aXZlO1xyXG4gICAgICBpZiAoaGlkZSB8fCAhZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgaXNBbmltYXRpb25GaW5pc2hlZCA9IHRoaXMuc3RhdGUuaXNBbmltYXRpb25GaW5pc2hlZDtcclxuICAgICAgdmFyIGxheWVyQ2xhc3MgPSAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtYXJlYScsIGNsYXNzTmFtZSk7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xyXG4gICAgICAgIGNsYXNzTmFtZTogbGF5ZXJDbGFzc1xyXG4gICAgICB9LCBiYWNrZ3JvdW5kICYmIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXJhZGlhbC1iYXItYmFja2dyb3VuZFwiXHJcbiAgICAgIH0sIHRoaXMucmVuZGVyQmFja2dyb3VuZChkYXRhKSksIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXJhZGlhbC1iYXItc2VjdG9yc1wiXHJcbiAgICAgIH0sIHRoaXMucmVuZGVyU2VjdG9ycygpKSwgKCFpc0FuaW1hdGlvbkFjdGl2ZSB8fCBpc0FuaW1hdGlvbkZpbmlzaGVkKSAmJiBfTGFiZWxMaXN0LkxhYmVsTGlzdC5yZW5kZXJDYWxsQnlQYXJlbnQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5wcm9wcyksIGRhdGEpKTtcclxuICAgIH1cclxuICB9XSwgW3tcclxuICAgIGtleTogXCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpIHtcclxuICAgICAgaWYgKG5leHRQcm9wcy5hbmltYXRpb25JZCAhPT0gcHJldlN0YXRlLnByZXZBbmltYXRpb25JZCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBwcmV2QW5pbWF0aW9uSWQ6IG5leHRQcm9wcy5hbmltYXRpb25JZCxcclxuICAgICAgICAgIGN1ckRhdGE6IG5leHRQcm9wcy5kYXRhLFxyXG4gICAgICAgICAgcHJldkRhdGE6IHByZXZTdGF0ZS5jdXJEYXRhXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobmV4dFByb3BzLmRhdGEgIT09IHByZXZTdGF0ZS5jdXJEYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGN1ckRhdGE6IG5leHRQcm9wcy5kYXRhXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XSk7XHJcbn0oX3JlYWN0LlB1cmVDb21wb25lbnQpO1xyXG5fZGVmaW5lUHJvcGVydHkoUmFkaWFsQmFyLCBcImRpc3BsYXlOYW1lXCIsICdSYWRpYWxCYXInKTtcclxuX2RlZmluZVByb3BlcnR5KFJhZGlhbEJhciwgXCJkZWZhdWx0UHJvcHNcIiwge1xyXG4gIGFuZ2xlQXhpc0lkOiAwLFxyXG4gIHJhZGl1c0F4aXNJZDogMCxcclxuICBtaW5Qb2ludFNpemU6IDAsXHJcbiAgaGlkZTogZmFsc2UsXHJcbiAgbGVnZW5kVHlwZTogJ3JlY3QnLFxyXG4gIGRhdGE6IFtdLFxyXG4gIGlzQW5pbWF0aW9uQWN0aXZlOiAhX0dsb2JhbC5HbG9iYWwuaXNTc3IsXHJcbiAgYW5pbWF0aW9uQmVnaW46IDAsXHJcbiAgYW5pbWF0aW9uRHVyYXRpb246IDE1MDAsXHJcbiAgYW5pbWF0aW9uRWFzaW5nOiAnZWFzZScsXHJcbiAgZm9yY2VDb3JuZXJSYWRpdXM6IGZhbHNlLFxyXG4gIGNvcm5lcklzRXh0ZXJuYWw6IGZhbHNlXHJcbn0pO1xyXG5fZGVmaW5lUHJvcGVydHkoUmFkaWFsQmFyLCBcImdldENvbXBvc2VkRGF0YVwiLCBmdW5jdGlvbiAoX3JlZjIpIHtcclxuICB2YXIgaXRlbSA9IF9yZWYyLml0ZW0sXHJcbiAgICBwcm9wcyA9IF9yZWYyLnByb3BzLFxyXG4gICAgcmFkaXVzQXhpcyA9IF9yZWYyLnJhZGl1c0F4aXMsXHJcbiAgICByYWRpdXNBeGlzVGlja3MgPSBfcmVmMi5yYWRpdXNBeGlzVGlja3MsXHJcbiAgICBhbmdsZUF4aXMgPSBfcmVmMi5hbmdsZUF4aXMsXHJcbiAgICBhbmdsZUF4aXNUaWNrcyA9IF9yZWYyLmFuZ2xlQXhpc1RpY2tzLFxyXG4gICAgZGlzcGxheWVkRGF0YSA9IF9yZWYyLmRpc3BsYXllZERhdGEsXHJcbiAgICBkYXRhS2V5ID0gX3JlZjIuZGF0YUtleSxcclxuICAgIHN0YWNrZWREYXRhID0gX3JlZjIuc3RhY2tlZERhdGEsXHJcbiAgICBiYXJQb3NpdGlvbiA9IF9yZWYyLmJhclBvc2l0aW9uLFxyXG4gICAgYmFuZFNpemUgPSBfcmVmMi5iYW5kU2l6ZSxcclxuICAgIGRhdGFTdGFydEluZGV4ID0gX3JlZjIuZGF0YVN0YXJ0SW5kZXg7XHJcbiAgdmFyIHBvcyA9ICgwLCBfQ2hhcnRVdGlscy5maW5kUG9zaXRpb25PZkJhcikoYmFyUG9zaXRpb24sIGl0ZW0pO1xyXG4gIGlmICghcG9zKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgdmFyIGN4ID0gYW5nbGVBeGlzLmN4LFxyXG4gICAgY3kgPSBhbmdsZUF4aXMuY3k7XHJcbiAgdmFyIGxheW91dCA9IHByb3BzLmxheW91dDtcclxuICB2YXIgX2l0ZW0kcHJvcHMgPSBpdGVtLnByb3BzLFxyXG4gICAgY2hpbGRyZW4gPSBfaXRlbSRwcm9wcy5jaGlsZHJlbixcclxuICAgIG1pblBvaW50U2l6ZSA9IF9pdGVtJHByb3BzLm1pblBvaW50U2l6ZTtcclxuICB2YXIgbnVtZXJpY0F4aXMgPSBsYXlvdXQgPT09ICdyYWRpYWwnID8gYW5nbGVBeGlzIDogcmFkaXVzQXhpcztcclxuICB2YXIgc3RhY2tlZERvbWFpbiA9IHN0YWNrZWREYXRhID8gbnVtZXJpY0F4aXMuc2NhbGUuZG9tYWluKCkgOiBudWxsO1xyXG4gIHZhciBiYXNlVmFsdWUgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0QmFzZVZhbHVlT2ZCYXIpKHtcclxuICAgIG51bWVyaWNBeGlzOiBudW1lcmljQXhpc1xyXG4gIH0pO1xyXG4gIHZhciBjZWxscyA9ICgwLCBfUmVhY3RVdGlscy5maW5kQWxsQnlUeXBlKShjaGlsZHJlbiwgX0NlbGwuQ2VsbCk7XHJcbiAgdmFyIHNlY3RvcnMgPSBkaXNwbGF5ZWREYXRhLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XHJcbiAgICB2YXIgdmFsdWUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGJhY2tncm91bmRTZWN0b3I7XHJcbiAgICBpZiAoc3RhY2tlZERhdGEpIHtcclxuICAgICAgdmFsdWUgPSAoMCwgX0NoYXJ0VXRpbHMudHJ1bmNhdGVCeURvbWFpbikoc3RhY2tlZERhdGFbZGF0YVN0YXJ0SW5kZXggKyBpbmRleF0sIHN0YWNrZWREb21haW4pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFsdWUgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0VmFsdWVCeURhdGFLZXkpKGVudHJ5LCBkYXRhS2V5KTtcclxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlID0gW2Jhc2VWYWx1ZSwgdmFsdWVdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobGF5b3V0ID09PSAncmFkaWFsJykge1xyXG4gICAgICBpbm5lclJhZGl1cyA9ICgwLCBfQ2hhcnRVdGlscy5nZXRDYXRlQ29vcmRpbmF0ZU9mQmFyKSh7XHJcbiAgICAgICAgYXhpczogcmFkaXVzQXhpcyxcclxuICAgICAgICB0aWNrczogcmFkaXVzQXhpc1RpY2tzLFxyXG4gICAgICAgIGJhbmRTaXplOiBiYW5kU2l6ZSxcclxuICAgICAgICBvZmZzZXQ6IHBvcy5vZmZzZXQsXHJcbiAgICAgICAgZW50cnk6IGVudHJ5LFxyXG4gICAgICAgIGluZGV4OiBpbmRleFxyXG4gICAgICB9KTtcclxuICAgICAgZW5kQW5nbGUgPSBhbmdsZUF4aXMuc2NhbGUodmFsdWVbMV0pO1xyXG4gICAgICBzdGFydEFuZ2xlID0gYW5nbGVBeGlzLnNjYWxlKHZhbHVlWzBdKTtcclxuICAgICAgb3V0ZXJSYWRpdXMgPSBpbm5lclJhZGl1cyArIHBvcy5zaXplO1xyXG4gICAgICB2YXIgZGVsdGFBbmdsZSA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcclxuICAgICAgaWYgKE1hdGguYWJzKG1pblBvaW50U2l6ZSkgPiAwICYmIE1hdGguYWJzKGRlbHRhQW5nbGUpIDwgTWF0aC5hYnMobWluUG9pbnRTaXplKSkge1xyXG4gICAgICAgIHZhciBkZWx0YSA9ICgwLCBfRGF0YVV0aWxzLm1hdGhTaWduKShkZWx0YUFuZ2xlIHx8IG1pblBvaW50U2l6ZSkgKiAoTWF0aC5hYnMobWluUG9pbnRTaXplKSAtIE1hdGguYWJzKGRlbHRhQW5nbGUpKTtcclxuICAgICAgICBlbmRBbmdsZSArPSBkZWx0YTtcclxuICAgICAgfVxyXG4gICAgICBiYWNrZ3JvdW5kU2VjdG9yID0ge1xyXG4gICAgICAgIGJhY2tncm91bmQ6IHtcclxuICAgICAgICAgIGN4OiBjeCxcclxuICAgICAgICAgIGN5OiBjeSxcclxuICAgICAgICAgIGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcclxuICAgICAgICAgIG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcclxuICAgICAgICAgIHN0YXJ0QW5nbGU6IHByb3BzLnN0YXJ0QW5nbGUsXHJcbiAgICAgICAgICBlbmRBbmdsZTogcHJvcHMuZW5kQW5nbGVcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpbm5lclJhZGl1cyA9IHJhZGl1c0F4aXMuc2NhbGUodmFsdWVbMF0pO1xyXG4gICAgICBvdXRlclJhZGl1cyA9IHJhZGl1c0F4aXMuc2NhbGUodmFsdWVbMV0pO1xyXG4gICAgICBzdGFydEFuZ2xlID0gKDAsIF9DaGFydFV0aWxzLmdldENhdGVDb29yZGluYXRlT2ZCYXIpKHtcclxuICAgICAgICBheGlzOiBhbmdsZUF4aXMsXHJcbiAgICAgICAgdGlja3M6IGFuZ2xlQXhpc1RpY2tzLFxyXG4gICAgICAgIGJhbmRTaXplOiBiYW5kU2l6ZSxcclxuICAgICAgICBvZmZzZXQ6IHBvcy5vZmZzZXQsXHJcbiAgICAgICAgZW50cnk6IGVudHJ5LFxyXG4gICAgICAgIGluZGV4OiBpbmRleFxyXG4gICAgICB9KTtcclxuICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgcG9zLnNpemU7XHJcbiAgICAgIHZhciBkZWx0YVJhZGl1cyA9IG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXM7XHJcbiAgICAgIGlmIChNYXRoLmFicyhtaW5Qb2ludFNpemUpID4gMCAmJiBNYXRoLmFicyhkZWx0YVJhZGl1cykgPCBNYXRoLmFicyhtaW5Qb2ludFNpemUpKSB7XHJcbiAgICAgICAgdmFyIF9kZWx0YSA9ICgwLCBfRGF0YVV0aWxzLm1hdGhTaWduKShkZWx0YVJhZGl1cyB8fCBtaW5Qb2ludFNpemUpICogKE1hdGguYWJzKG1pblBvaW50U2l6ZSkgLSBNYXRoLmFicyhkZWx0YVJhZGl1cykpO1xyXG4gICAgICAgIG91dGVyUmFkaXVzICs9IF9kZWx0YTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwgYmFja2dyb3VuZFNlY3RvciksIHt9LCB7XHJcbiAgICAgIHBheWxvYWQ6IGVudHJ5LFxyXG4gICAgICB2YWx1ZTogc3RhY2tlZERhdGEgPyB2YWx1ZSA6IHZhbHVlWzFdLFxyXG4gICAgICBjeDogY3gsXHJcbiAgICAgIGN5OiBjeSxcclxuICAgICAgaW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxyXG4gICAgICBvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXHJcbiAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXHJcbiAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZVxyXG4gICAgfSwgY2VsbHMgJiYgY2VsbHNbaW5kZXhdICYmIGNlbGxzW2luZGV4XS5wcm9wcyksIHt9LCB7XHJcbiAgICAgIHRvb2x0aXBQYXlsb2FkOiBbKDAsIF9DaGFydFV0aWxzLmdldFRvb2x0aXBJdGVtKShpdGVtLCBlbnRyeSldLFxyXG4gICAgICB0b29sdGlwUG9zaXRpb246ICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjeCwgY3ksIChpbm5lclJhZGl1cyArIG91dGVyUmFkaXVzKSAvIDIsIChzdGFydEFuZ2xlICsgZW5kQW5nbGUpIC8gMilcclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIHJldHVybiB7XHJcbiAgICBkYXRhOiBzZWN0b3JzLFxyXG4gICAgbGF5b3V0OiBsYXlvdXRcclxuICB9O1xyXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSYWRpYWxCYXIiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfY2xzeCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfcmVhY3RTbW9vdGgiLCJfaXNFcXVhbCIsIl9pc0Z1bmN0aW9uIiwiX1JhZGlhbEJhclV0aWxzIiwiX0xheWVyIiwiX1JlYWN0VXRpbHMiLCJfR2xvYmFsIiwiX0xhYmVsTGlzdCIsIl9DZWxsIiwiX0RhdGFVdGlscyIsIl9DaGFydFV0aWxzIiwiX3R5cGVzIiwiX1BvbGFyVXRpbHMiLCJfZXhjbHVkZWQiLCJfZXhjbHVkZWQyIiwib2JqIiwiX19lc01vZHVsZSIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJfdHlwZW9mIiwiaGFzIiwiZ2V0IiwibiIsIl9fcHJvdG9fXyIsImEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ1IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaSIsInNldCIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsImFwcGx5Iiwib3duS2V5cyIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJlbnVtZXJhYmxlIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJleGNsdWRlZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwic291cmNlU3ltYm9sS2V5cyIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2FsbFN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJCb29sZWFuIiwidmFsdWVPZiIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJfUHVyZUNvbXBvbmVudCIsIl90aGlzIiwiX2xlbiIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJjb25jYXQiLCJpc0FuaW1hdGlvbkZpbmlzaGVkIiwib25BbmltYXRpb25FbmQiLCJzZXRTdGF0ZSIsIm9uQW5pbWF0aW9uU3RhcnQiLCJnZXREZWx0YUFuZ2xlIiwiX3RoaXMkcHJvcHMiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJzaWduIiwibWF0aFNpZ24iLCJkZWx0YUFuZ2xlIiwiTWF0aCIsIm1pbiIsImFicyIsInJlbmRlclNlY3RvcnNTdGF0aWNhbGx5Iiwic2VjdG9ycyIsIl90aGlzMiIsIl90aGlzJHByb3BzMiIsInNoYXBlIiwiYWN0aXZlU2hhcGUiLCJhY3RpdmVJbmRleCIsImNvcm5lclJhZGl1cyIsIm90aGVycyIsImJhc2VQcm9wcyIsImZpbHRlclByb3BzIiwibWFwIiwiZW50cnkiLCJpc0FjdGl2ZSIsInBhcnNlQ29ybmVyUmFkaXVzIiwiYWRhcHRFdmVudHNPZkNoaWxkIiwiY2xhc3NOYW1lIiwiZm9yY2VDb3JuZXJSYWRpdXMiLCJjb3JuZXJJc0V4dGVybmFsIiwib3B0aW9uIiwiY3JlYXRlRWxlbWVudCIsIlJhZGlhbEJhclNlY3RvciIsInJlbmRlclNlY3RvcnNXaXRoQW5pbWF0aW9uIiwiX3RoaXMzIiwiX3RoaXMkcHJvcHMzIiwiZGF0YSIsImlzQW5pbWF0aW9uQWN0aXZlIiwiYW5pbWF0aW9uQmVnaW4iLCJhbmltYXRpb25EdXJhdGlvbiIsImFuaW1hdGlvbkVhc2luZyIsImFuaW1hdGlvbklkIiwicHJldkRhdGEiLCJzdGF0ZSIsImJlZ2luIiwiZHVyYXRpb24iLCJlYXNpbmciLCJmcm9tIiwidG8iLCJoYW5kbGVBbmltYXRpb25TdGFydCIsImhhbmRsZUFuaW1hdGlvbkVuZCIsIl9yZWYiLCJzdGVwRGF0YSIsImluZGV4IiwicHJldiIsImludGVycG9sYXRvclN0YXJ0QW5nbGUiLCJpbnRlcnBvbGF0ZU51bWJlciIsImludGVycG9sYXRvckVuZEFuZ2xlIiwiaW50ZXJwb2xhdG9yIiwiTGF5ZXIiLCJyZW5kZXJTZWN0b3JzIiwiX3RoaXMkcHJvcHM0IiwicmVuZGVyQmFja2dyb3VuZCIsIl90aGlzNCIsImJhY2tncm91bmRQcm9wcyIsImJhY2tncm91bmQiLCJyZXN0IiwiZmlsbCIsInJlbmRlciIsIl90aGlzJHByb3BzNSIsImhpZGUiLCJsYXllckNsYXNzIiwiTGFiZWxMaXN0IiwicmVuZGVyQ2FsbEJ5UGFyZW50IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwibmV4dFByb3BzIiwicHJldlN0YXRlIiwicHJldkFuaW1hdGlvbklkIiwiY3VyRGF0YSIsIlB1cmVDb21wb25lbnQiLCJhbmdsZUF4aXNJZCIsInJhZGl1c0F4aXNJZCIsIm1pblBvaW50U2l6ZSIsImxlZ2VuZFR5cGUiLCJHbG9iYWwiLCJpc1NzciIsIl9yZWYyIiwiaXRlbSIsInJhZGl1c0F4aXMiLCJyYWRpdXNBeGlzVGlja3MiLCJhbmdsZUF4aXMiLCJhbmdsZUF4aXNUaWNrcyIsImRpc3BsYXllZERhdGEiLCJkYXRhS2V5Iiwic3RhY2tlZERhdGEiLCJiYXJQb3NpdGlvbiIsImJhbmRTaXplIiwiZGF0YVN0YXJ0SW5kZXgiLCJwb3MiLCJmaW5kUG9zaXRpb25PZkJhciIsImN4IiwiY3kiLCJsYXlvdXQiLCJfaXRlbSRwcm9wcyIsImNoaWxkcmVuIiwibnVtZXJpY0F4aXMiLCJzdGFja2VkRG9tYWluIiwic2NhbGUiLCJkb21haW4iLCJiYXNlVmFsdWUiLCJnZXRCYXNlVmFsdWVPZkJhciIsImNlbGxzIiwiZmluZEFsbEJ5VHlwZSIsIkNlbGwiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIiwiYmFja2dyb3VuZFNlY3RvciIsInRydW5jYXRlQnlEb21haW4iLCJnZXRWYWx1ZUJ5RGF0YUtleSIsImlzQXJyYXkiLCJnZXRDYXRlQ29vcmRpbmF0ZU9mQmFyIiwiYXhpcyIsInRpY2tzIiwib2Zmc2V0Iiwic2l6ZSIsImRlbHRhIiwiZGVsdGFSYWRpdXMiLCJfZGVsdGEiLCJwYXlsb2FkIiwidG9vbHRpcFBheWxvYWQiLCJnZXRUb29sdGlwSXRlbSIsInRvb2x0aXBQb3NpdGlvbiIsInBvbGFyVG9DYXJ0ZXNpYW4iXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/polar/RadialBar.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/shape/Cross.js":
/*!**************************************************!*\
  !*** ./node_modules/recharts/lib/shape/Cross.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Cross = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"x\",\n    \"y\",\n    \"top\",\n    \"left\",\n    \"width\",\n    \"height\",\n    \"className\"\n];\n/**\r\n * @fileOverview Cross\r\n */ function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nvar getPath = function getPath(x, y, width, height, top, left) {\n    return \"M\".concat(x, \",\").concat(top, \"v\").concat(height, \"M\").concat(left, \",\").concat(y, \"h\").concat(width);\n};\nvar Cross = exports.Cross = function Cross(_ref) {\n    var _ref$x = _ref.x, x = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y = _ref$y === void 0 ? 0 : _ref$y, _ref$top = _ref.top, top = _ref$top === void 0 ? 0 : _ref$top, _ref$left = _ref.left, left = _ref$left === void 0 ? 0 : _ref$left, _ref$width = _ref.width, width = _ref$width === void 0 ? 0 : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? 0 : _ref$height, className = _ref.className, rest = _objectWithoutProperties(_ref, _excluded);\n    var props = _objectSpread({\n        x: x,\n        y: y,\n        top: top,\n        left: left,\n        width: width,\n        height: height\n    }, rest);\n    if (!(0, _DataUtils.isNumber)(x) || !(0, _DataUtils.isNumber)(y) || !(0, _DataUtils.isNumber)(width) || !(0, _DataUtils.isNumber)(height) || !(0, _DataUtils.isNumber)(top) || !(0, _DataUtils.isNumber)(left)) {\n        return null;\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(props, true), {\n        className: (0, _clsx[\"default\"])('recharts-cross', className),\n        d: getPath(x, y, width, height, top, left)\n    }));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvc2hhcGUvQ3Jvc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRSxXQUFXLEtBQUtDLFVBQVVELE1BQU1DLE9BQU9FLFNBQVMsR0FBRyxXQUFXLE9BQU9IO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VEksOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGFBQWEsR0FBRyxLQUFLO0FBQ3JCLElBQUlHLFNBQVNDLHVCQUF1QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDbkQsSUFBSUMsUUFBUUYsdUJBQXVCQyxtQkFBT0EsQ0FBQyx1QkFBTTtBQUNqRCxJQUFJRSxhQUFhRixtQkFBT0EsQ0FBQyx5RkFBbUI7QUFDNUMsSUFBSUcsY0FBY0gsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlJLFlBQVk7SUFBQztJQUFLO0lBQUs7SUFBTztJQUFRO0lBQVM7SUFBVTtDQUFZO0FBQ3pFOztDQUVDLEdBQ0QsU0FBU0wsdUJBQXVCTSxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFO0lBQWFBLFdBQVdkLE9BQU9lLE1BQU0sR0FBR2YsT0FBT2UsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVUMsTUFBTTtRQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFBRSxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFBRSxJQUFLLElB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QUssQ0FBQyxVQUFVLEVBQUUsa0JBQWtCOEQ7UUFDbkRNLEdBQUdyQixRQUFRQyxHQUFHQyxHQUFHQyxPQUFPQyxRQUFRQyxLQUFLQztJQUN2QztBQUNGIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxzaGFwZVxcQ3Jvc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLkNyb3NzID0gdm9pZCAwO1xyXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcclxudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9EYXRhVXRpbHNcIik7XHJcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XHJcbnZhciBfZXhjbHVkZWQgPSBbXCJ4XCIsIFwieVwiLCBcInRvcFwiLCBcImxlZnRcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcImNsYXNzTmFtZVwiXTtcclxuLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgQ3Jvc3NcclxuICovXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cclxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cclxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxyXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XHJcbnZhciBnZXRQYXRoID0gZnVuY3Rpb24gZ2V0UGF0aCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0b3AsIGxlZnQpIHtcclxuICByZXR1cm4gXCJNXCIuY29uY2F0KHgsIFwiLFwiKS5jb25jYXQodG9wLCBcInZcIikuY29uY2F0KGhlaWdodCwgXCJNXCIpLmNvbmNhdChsZWZ0LCBcIixcIikuY29uY2F0KHksIFwiaFwiKS5jb25jYXQod2lkdGgpO1xyXG59O1xyXG52YXIgQ3Jvc3MgPSBleHBvcnRzLkNyb3NzID0gZnVuY3Rpb24gQ3Jvc3MoX3JlZikge1xyXG4gIHZhciBfcmVmJHggPSBfcmVmLngsXHJcbiAgICB4ID0gX3JlZiR4ID09PSB2b2lkIDAgPyAwIDogX3JlZiR4LFxyXG4gICAgX3JlZiR5ID0gX3JlZi55LFxyXG4gICAgeSA9IF9yZWYkeSA9PT0gdm9pZCAwID8gMCA6IF9yZWYkeSxcclxuICAgIF9yZWYkdG9wID0gX3JlZi50b3AsXHJcbiAgICB0b3AgPSBfcmVmJHRvcCA9PT0gdm9pZCAwID8gMCA6IF9yZWYkdG9wLFxyXG4gICAgX3JlZiRsZWZ0ID0gX3JlZi5sZWZ0LFxyXG4gICAgbGVmdCA9IF9yZWYkbGVmdCA9PT0gdm9pZCAwID8gMCA6IF9yZWYkbGVmdCxcclxuICAgIF9yZWYkd2lkdGggPSBfcmVmLndpZHRoLFxyXG4gICAgd2lkdGggPSBfcmVmJHdpZHRoID09PSB2b2lkIDAgPyAwIDogX3JlZiR3aWR0aCxcclxuICAgIF9yZWYkaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXHJcbiAgICBoZWlnaHQgPSBfcmVmJGhlaWdodCA9PT0gdm9pZCAwID8gMCA6IF9yZWYkaGVpZ2h0LFxyXG4gICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXHJcbiAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XHJcbiAgdmFyIHByb3BzID0gX29iamVjdFNwcmVhZCh7XHJcbiAgICB4OiB4LFxyXG4gICAgeTogeSxcclxuICAgIHRvcDogdG9wLFxyXG4gICAgbGVmdDogbGVmdCxcclxuICAgIHdpZHRoOiB3aWR0aCxcclxuICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgfSwgcmVzdCk7XHJcbiAgaWYgKCEoMCwgX0RhdGFVdGlscy5pc051bWJlcikoeCkgfHwgISgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKSh5KSB8fCAhKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHdpZHRoKSB8fCAhKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGhlaWdodCkgfHwgISgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKSh0b3ApIHx8ICEoMCwgX0RhdGFVdGlscy5pc051bWJlcikobGVmdCkpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInBhdGhcIiwgX2V4dGVuZHMoe30sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykocHJvcHMsIHRydWUpLCB7XHJcbiAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1jcm9zcycsIGNsYXNzTmFtZSksXHJcbiAgICBkOiBnZXRQYXRoKHgsIHksIHdpZHRoLCBoZWlnaHQsIHRvcCwgbGVmdClcclxuICB9KSk7XHJcbn07Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNyb3NzIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfY2xzeCIsIl9EYXRhVXRpbHMiLCJfUmVhY3RVdGlscyIsIl9leGNsdWRlZCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJvd25LZXlzIiwiZSIsInIiLCJ0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsImV4Y2x1ZGVkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJzb3VyY2VTeW1ib2xLZXlzIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiZ2V0UGF0aCIsIngiLCJ5Iiwid2lkdGgiLCJoZWlnaHQiLCJ0b3AiLCJsZWZ0IiwiY29uY2F0IiwiX3JlZiIsIl9yZWYkeCIsIl9yZWYkeSIsIl9yZWYkdG9wIiwiX3JlZiRsZWZ0IiwiX3JlZiR3aWR0aCIsIl9yZWYkaGVpZ2h0IiwiY2xhc3NOYW1lIiwicmVzdCIsInByb3BzIiwiaXNOdW1iZXIiLCJjcmVhdGVFbGVtZW50IiwiZmlsdGVyUHJvcHMiLCJkIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/shape/Cross.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/shape/Curve.js":
/*!**************************************************!*\
  !*** ./node_modules/recharts/lib/shape/Curve.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getPath = exports.Curve = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _d3Shape = __webpack_require__(/*! victory-vendor/d3-shape */ \"victory-vendor/d3-shape\");\nvar _upperFirst = _interopRequireDefault(__webpack_require__(/*! lodash/upperFirst */ \"lodash/upperFirst\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _types = __webpack_require__(/*! ../util/types */ \"(pages-dir-node)/./node_modules/recharts/lib/util/types.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Curve\r\n */ \nvar CURVE_FACTORIES = {\n    curveBasisClosed: _d3Shape.curveBasisClosed,\n    curveBasisOpen: _d3Shape.curveBasisOpen,\n    curveBasis: _d3Shape.curveBasis,\n    curveBumpX: _d3Shape.curveBumpX,\n    curveBumpY: _d3Shape.curveBumpY,\n    curveLinearClosed: _d3Shape.curveLinearClosed,\n    curveLinear: _d3Shape.curveLinear,\n    curveMonotoneX: _d3Shape.curveMonotoneX,\n    curveMonotoneY: _d3Shape.curveMonotoneY,\n    curveNatural: _d3Shape.curveNatural,\n    curveStep: _d3Shape.curveStep,\n    curveStepAfter: _d3Shape.curveStepAfter,\n    curveStepBefore: _d3Shape.curveStepBefore\n};\nvar defined = function defined(p) {\n    return p.x === +p.x && p.y === +p.y;\n};\nvar getX = function getX(p) {\n    return p.x;\n};\nvar getY = function getY(p) {\n    return p.y;\n};\nvar getCurveFactory = function getCurveFactory(type, layout) {\n    if ((0, _isFunction[\"default\"])(type)) {\n        return type;\n    }\n    var name = \"curve\".concat((0, _upperFirst[\"default\"])(type));\n    if ((name === 'curveMonotone' || name === 'curveBump') && layout) {\n        return CURVE_FACTORIES[\"\".concat(name).concat(layout === 'vertical' ? 'Y' : 'X')];\n    }\n    return CURVE_FACTORIES[name] || _d3Shape.curveLinear;\n};\n/**\r\n * Calculate the path of curve. Returns null if points is an empty array.\r\n * @return path or null\r\n */ var getPath = exports.getPath = function getPath(_ref) {\n    var _ref$type = _ref.type, type = _ref$type === void 0 ? 'linear' : _ref$type, _ref$points = _ref.points, points = _ref$points === void 0 ? [] : _ref$points, baseLine = _ref.baseLine, layout = _ref.layout, _ref$connectNulls = _ref.connectNulls, connectNulls = _ref$connectNulls === void 0 ? false : _ref$connectNulls;\n    var curveFactory = getCurveFactory(type, layout);\n    var formatPoints = connectNulls ? points.filter(function(entry) {\n        return defined(entry);\n    }) : points;\n    var lineFunction;\n    if (Array.isArray(baseLine)) {\n        var formatBaseLine = connectNulls ? baseLine.filter(function(base) {\n            return defined(base);\n        }) : baseLine;\n        var areaPoints = formatPoints.map(function(entry, index) {\n            return _objectSpread(_objectSpread({}, entry), {}, {\n                base: formatBaseLine[index]\n            });\n        });\n        if (layout === 'vertical') {\n            lineFunction = (0, _d3Shape.area)().y(getY).x1(getX).x0(function(d) {\n                return d.base.x;\n            });\n        } else {\n            lineFunction = (0, _d3Shape.area)().x(getX).y1(getY).y0(function(d) {\n                return d.base.y;\n            });\n        }\n        lineFunction.defined(defined).curve(curveFactory);\n        return lineFunction(areaPoints);\n    }\n    if (layout === 'vertical' && (0, _DataUtils.isNumber)(baseLine)) {\n        lineFunction = (0, _d3Shape.area)().y(getY).x1(getX).x0(baseLine);\n    } else if ((0, _DataUtils.isNumber)(baseLine)) {\n        lineFunction = (0, _d3Shape.area)().x(getX).y1(getY).y0(baseLine);\n    } else {\n        lineFunction = (0, _d3Shape.line)().x(getX).y(getY);\n    }\n    lineFunction.defined(defined).curve(curveFactory);\n    return lineFunction(formatPoints);\n};\nvar Curve = exports.Curve = function Curve(props) {\n    var className = props.className, points = props.points, path = props.path, pathRef = props.pathRef;\n    if ((!points || !points.length) && !path) {\n        return null;\n    }\n    var realPath = points && points.length ? getPath(props) : path;\n    return /*#__PURE__*/ React.createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(props, false), (0, _types.adaptEventHandlers)(props), {\n        className: (0, _clsx[\"default\"])('recharts-curve', className),\n        d: realPath,\n        ref: pathRef\n    }));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvc2hhcGUvQ3VydmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGVBQWUsR0FBR0EsYUFBYSxHQUFHLEtBQUs7QUFDdkMsSUFBSUksUUFBUUMsd0JBQXdCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNuRCxJQUFJQyxXQUFXRCxtQkFBT0EsQ0FBQyx3REFBeUI7QUFDaEQsSUFBSUUsY0FBY0MsdUJBQXVCSCxtQkFBT0EsQ0FBQyw0Q0FBbUI7QUFDcEUsSUFBSUksY0FBY0QsdUJBQXVCSCxtQkFBT0EsQ0FBQyw0Q0FBbUI7QUFDcEUsSUFBSUssUUFBUUYsdUJBQXVCSCxtQkFBT0EsQ0FBQyx1QkFBTTtBQUNqRCxJQUFJTSxTQUFTTixtQkFBT0EsQ0FBQyxpRkFBZTtBQUNwQyxJQUFJTyxjQUFjUCxtQkFBT0EsQ0FBQywyRkFBb0I7QUFDOUMsSUFBSVEsYUFBYVIsbUJBQU9BLENBQUMseUZBQW1CO0FBQzVDLFNBQVNHLHVCQUF1Qk0sR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSx5QkFBeUJDLENBQUM7SUFBSSxJQUFJLGNBQWMsT0FBT0MsU0FBUyxPQUFPO0lBQU0sSUFBSUMsSUFBSSxJQUFJRCxXQUFXRSxJQUFJLElBQUlGO0lBQVcsT0FBTyxDQUFDRiwyQkFBMkIsU0FBU0EseUJBQXlCQyxDQUFDO1FBQUksT0FBT0EsSUFBSUcsSUFBSUQ7SUFBRyxHQUFHRjtBQUFJO0FBQ25PLFNBQVNiLHdCQUF3QmEsQ0FBQyxFQUFFRSxDQUFDO0lBQUksSUFBSSxDQUFDQSxLQUFLRixLQUFLQSxFQUFFRixVQUFVLEVBQUUsT0FBT0U7SUFBRyxJQUFJLFNBQVNBLEtBQUssWUFBWUksUUFBUUosTUFBTSxjQUFjLE9BQU9BLEdBQUcsT0FB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LElBQUlFLFdBQVc1QixVQUFVQSxPQUFPbkQsTUFBTSxHQUFHekMsUUFBUW9ILFNBQVNFO0lBQzFELE9BQU8sV0FBVyxHQUFFcEgsTUFBTXVILGFBQWEsQ0FBQyxRQUFRckYsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHekIsWUFBWStHLFdBQVcsRUFBRU4sT0FBTyxRQUFRLENBQUMsR0FBRzFHLE9BQU9pSCxrQkFBa0IsRUFBRVAsUUFBUTtRQUM5SUMsV0FBVyxDQUFDLEdBQUc1RyxLQUFLLENBQUMsVUFBVSxFQUFFLGtCQUFrQjRHO1FBQ25EUCxHQUFHVTtRQUNISSxLQUFLTDtJQUNQO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXHNoYXBlXFxDdXJ2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmdldFBhdGggPSBleHBvcnRzLkN1cnZlID0gdm9pZCAwO1xyXG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgX2QzU2hhcGUgPSByZXF1aXJlKFwidmljdG9yeS12ZW5kb3IvZDMtc2hhcGVcIik7XHJcbnZhciBfdXBwZXJGaXJzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC91cHBlckZpcnN0XCIpKTtcclxudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xyXG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcclxudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuLi91dGlsL3R5cGVzXCIpO1xyXG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xyXG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0RhdGFVdGlsc1wiKTtcclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XHJcbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBudWxsOyB2YXIgciA9IG5ldyBXZWFrTWFwKCksIHQgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IHJldHVybiBlID8gdCA6IHI7IH0pKGUpOyB9XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHUpKSB7IHZhciBpID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdSkgOiBudWxsOyBpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgdSwgaSkgOiBuW3VdID0gZVt1XTsgfSByZXR1cm4gbltcImRlZmF1bHRcIl0gPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XHJcbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cclxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XHJcbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cclxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH0gLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgQ3VydmVcclxuICovXHJcbnZhciBDVVJWRV9GQUNUT1JJRVMgPSB7XHJcbiAgY3VydmVCYXNpc0Nsb3NlZDogX2QzU2hhcGUuY3VydmVCYXNpc0Nsb3NlZCxcclxuICBjdXJ2ZUJhc2lzT3BlbjogX2QzU2hhcGUuY3VydmVCYXNpc09wZW4sXHJcbiAgY3VydmVCYXNpczogX2QzU2hhcGUuY3VydmVCYXNpcyxcclxuICBjdXJ2ZUJ1bXBYOiBfZDNTaGFwZS5jdXJ2ZUJ1bXBYLFxyXG4gIGN1cnZlQnVtcFk6IF9kM1NoYXBlLmN1cnZlQnVtcFksXHJcbiAgY3VydmVMaW5lYXJDbG9zZWQ6IF9kM1NoYXBlLmN1cnZlTGluZWFyQ2xvc2VkLFxyXG4gIGN1cnZlTGluZWFyOiBfZDNTaGFwZS5jdXJ2ZUxpbmVhcixcclxuICBjdXJ2ZU1vbm90b25lWDogX2QzU2hhcGUuY3VydmVNb25vdG9uZVgsXHJcbiAgY3VydmVNb25vdG9uZVk6IF9kM1NoYXBlLmN1cnZlTW9ub3RvbmVZLFxyXG4gIGN1cnZlTmF0dXJhbDogX2QzU2hhcGUuY3VydmVOYXR1cmFsLFxyXG4gIGN1cnZlU3RlcDogX2QzU2hhcGUuY3VydmVTdGVwLFxyXG4gIGN1cnZlU3RlcEFmdGVyOiBfZDNTaGFwZS5jdXJ2ZVN0ZXBBZnRlcixcclxuICBjdXJ2ZVN0ZXBCZWZvcmU6IF9kM1NoYXBlLmN1cnZlU3RlcEJlZm9yZVxyXG59O1xyXG52YXIgZGVmaW5lZCA9IGZ1bmN0aW9uIGRlZmluZWQocCkge1xyXG4gIHJldHVybiBwLnggPT09ICtwLnggJiYgcC55ID09PSArcC55O1xyXG59O1xyXG52YXIgZ2V0WCA9IGZ1bmN0aW9uIGdldFgocCkge1xyXG4gIHJldHVybiBwLng7XHJcbn07XHJcbnZhciBnZXRZID0gZnVuY3Rpb24gZ2V0WShwKSB7XHJcbiAgcmV0dXJuIHAueTtcclxufTtcclxudmFyIGdldEN1cnZlRmFjdG9yeSA9IGZ1bmN0aW9uIGdldEN1cnZlRmFjdG9yeSh0eXBlLCBsYXlvdXQpIHtcclxuICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkodHlwZSkpIHtcclxuICAgIHJldHVybiB0eXBlO1xyXG4gIH1cclxuICB2YXIgbmFtZSA9IFwiY3VydmVcIi5jb25jYXQoKDAsIF91cHBlckZpcnN0W1wiZGVmYXVsdFwiXSkodHlwZSkpO1xyXG4gIGlmICgobmFtZSA9PT0gJ2N1cnZlTW9ub3RvbmUnIHx8IG5hbWUgPT09ICdjdXJ2ZUJ1bXAnKSAmJiBsYXlvdXQpIHtcclxuICAgIHJldHVybiBDVVJWRV9GQUNUT1JJRVNbXCJcIi5jb25jYXQobmFtZSkuY29uY2F0KGxheW91dCA9PT0gJ3ZlcnRpY2FsJyA/ICdZJyA6ICdYJyldO1xyXG4gIH1cclxuICByZXR1cm4gQ1VSVkVfRkFDVE9SSUVTW25hbWVdIHx8IF9kM1NoYXBlLmN1cnZlTGluZWFyO1xyXG59O1xyXG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBwYXRoIG9mIGN1cnZlLiBSZXR1cm5zIG51bGwgaWYgcG9pbnRzIGlzIGFuIGVtcHR5IGFycmF5LlxyXG4gKiBAcmV0dXJuIHBhdGggb3IgbnVsbFxyXG4gKi9cclxudmFyIGdldFBhdGggPSBleHBvcnRzLmdldFBhdGggPSBmdW5jdGlvbiBnZXRQYXRoKF9yZWYpIHtcclxuICB2YXIgX3JlZiR0eXBlID0gX3JlZi50eXBlLFxyXG4gICAgdHlwZSA9IF9yZWYkdHlwZSA9PT0gdm9pZCAwID8gJ2xpbmVhcicgOiBfcmVmJHR5cGUsXHJcbiAgICBfcmVmJHBvaW50cyA9IF9yZWYucG9pbnRzLFxyXG4gICAgcG9pbnRzID0gX3JlZiRwb2ludHMgPT09IHZvaWQgMCA/IFtdIDogX3JlZiRwb2ludHMsXHJcbiAgICBiYXNlTGluZSA9IF9yZWYuYmFzZUxpbmUsXHJcbiAgICBsYXlvdXQgPSBfcmVmLmxheW91dCxcclxuICAgIF9yZWYkY29ubmVjdE51bGxzID0gX3JlZi5jb25uZWN0TnVsbHMsXHJcbiAgICBjb25uZWN0TnVsbHMgPSBfcmVmJGNvbm5lY3ROdWxscyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGNvbm5lY3ROdWxscztcclxuICB2YXIgY3VydmVGYWN0b3J5ID0gZ2V0Q3VydmVGYWN0b3J5KHR5cGUsIGxheW91dCk7XHJcbiAgdmFyIGZvcm1hdFBvaW50cyA9IGNvbm5lY3ROdWxscyA/IHBvaW50cy5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICByZXR1cm4gZGVmaW5lZChlbnRyeSk7XHJcbiAgfSkgOiBwb2ludHM7XHJcbiAgdmFyIGxpbmVGdW5jdGlvbjtcclxuICBpZiAoQXJyYXkuaXNBcnJheShiYXNlTGluZSkpIHtcclxuICAgIHZhciBmb3JtYXRCYXNlTGluZSA9IGNvbm5lY3ROdWxscyA/IGJhc2VMaW5lLmZpbHRlcihmdW5jdGlvbiAoYmFzZSkge1xyXG4gICAgICByZXR1cm4gZGVmaW5lZChiYXNlKTtcclxuICAgIH0pIDogYmFzZUxpbmU7XHJcbiAgICB2YXIgYXJlYVBvaW50cyA9IGZvcm1hdFBvaW50cy5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xyXG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeSksIHt9LCB7XHJcbiAgICAgICAgYmFzZTogZm9ybWF0QmFzZUxpbmVbaW5kZXhdXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICBpZiAobGF5b3V0ID09PSAndmVydGljYWwnKSB7XHJcbiAgICAgIGxpbmVGdW5jdGlvbiA9ICgwLCBfZDNTaGFwZS5hcmVhKSgpLnkoZ2V0WSkueDEoZ2V0WCkueDAoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gZC5iYXNlLng7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGluZUZ1bmN0aW9uID0gKDAsIF9kM1NoYXBlLmFyZWEpKCkueChnZXRYKS55MShnZXRZKS55MChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBkLmJhc2UueTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBsaW5lRnVuY3Rpb24uZGVmaW5lZChkZWZpbmVkKS5jdXJ2ZShjdXJ2ZUZhY3RvcnkpO1xyXG4gICAgcmV0dXJuIGxpbmVGdW5jdGlvbihhcmVhUG9pbnRzKTtcclxuICB9XHJcbiAgaWYgKGxheW91dCA9PT0gJ3ZlcnRpY2FsJyAmJiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikoYmFzZUxpbmUpKSB7XHJcbiAgICBsaW5lRnVuY3Rpb24gPSAoMCwgX2QzU2hhcGUuYXJlYSkoKS55KGdldFkpLngxKGdldFgpLngwKGJhc2VMaW5lKTtcclxuICB9IGVsc2UgaWYgKCgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShiYXNlTGluZSkpIHtcclxuICAgIGxpbmVGdW5jdGlvbiA9ICgwLCBfZDNTaGFwZS5hcmVhKSgpLngoZ2V0WCkueTEoZ2V0WSkueTAoYmFzZUxpbmUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBsaW5lRnVuY3Rpb24gPSAoMCwgX2QzU2hhcGUubGluZSkoKS54KGdldFgpLnkoZ2V0WSk7XHJcbiAgfVxyXG4gIGxpbmVGdW5jdGlvbi5kZWZpbmVkKGRlZmluZWQpLmN1cnZlKGN1cnZlRmFjdG9yeSk7XHJcbiAgcmV0dXJuIGxpbmVGdW5jdGlvbihmb3JtYXRQb2ludHMpO1xyXG59O1xyXG52YXIgQ3VydmUgPSBleHBvcnRzLkN1cnZlID0gZnVuY3Rpb24gQ3VydmUocHJvcHMpIHtcclxuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxyXG4gICAgcG9pbnRzID0gcHJvcHMucG9pbnRzLFxyXG4gICAgcGF0aCA9IHByb3BzLnBhdGgsXHJcbiAgICBwYXRoUmVmID0gcHJvcHMucGF0aFJlZjtcclxuICBpZiAoKCFwb2ludHMgfHwgIXBvaW50cy5sZW5ndGgpICYmICFwYXRoKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgdmFyIHJlYWxQYXRoID0gcG9pbnRzICYmIHBvaW50cy5sZW5ndGggPyBnZXRQYXRoKHByb3BzKSA6IHBhdGg7XHJcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCBfZXh0ZW5kcyh7fSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShwcm9wcywgZmFsc2UpLCAoMCwgX3R5cGVzLmFkYXB0RXZlbnRIYW5kbGVycykocHJvcHMpLCB7XHJcbiAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1jdXJ2ZScsIGNsYXNzTmFtZSksXHJcbiAgICBkOiByZWFsUGF0aCxcclxuICAgIHJlZjogcGF0aFJlZlxyXG4gIH0pKTtcclxufTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRQYXRoIiwiQ3VydmUiLCJSZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9kM1NoYXBlIiwiX3VwcGVyRmlyc3QiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2lzRnVuY3Rpb24iLCJfY2xzeCIsIl90eXBlcyIsIl9SZWFjdFV0aWxzIiwiX0RhdGFVdGlscyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX3R5cGVvZiIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJhcHBseSIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiQ1VSVkVfRkFDVE9SSUVTIiwiY3VydmVCYXNpc0Nsb3NlZCIsImN1cnZlQmFzaXNPcGVuIiwiY3VydmVCYXNpcyIsImN1cnZlQnVtcFgiLCJjdXJ2ZUJ1bXBZIiwiY3VydmVMaW5lYXJDbG9zZWQiLCJjdXJ2ZUxpbmVhciIsImN1cnZlTW9ub3RvbmVYIiwiY3VydmVNb25vdG9uZVkiLCJjdXJ2ZU5hdHVyYWwiLCJjdXJ2ZVN0ZXAiLCJjdXJ2ZVN0ZXBBZnRlciIsImN1cnZlU3RlcEJlZm9yZSIsImRlZmluZWQiLCJwIiwieCIsInkiLCJnZXRYIiwiZ2V0WSIsImdldEN1cnZlRmFjdG9yeSIsInR5cGUiLCJsYXlvdXQiLCJuYW1lIiwiY29uY2F0IiwiX3JlZiIsIl9yZWYkdHlwZSIsIl9yZWYkcG9pbnRzIiwicG9pbnRzIiwiYmFzZUxpbmUiLCJfcmVmJGNvbm5lY3ROdWxscyIsImNvbm5lY3ROdWxscyIsImN1cnZlRmFjdG9yeSIsImZvcm1hdFBvaW50cyIsImVudHJ5IiwibGluZUZ1bmN0aW9uIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9ybWF0QmFzZUxpbmUiLCJiYXNlIiwiYXJlYVBvaW50cyIsIm1hcCIsImluZGV4IiwiYXJlYSIsIngxIiwieDAiLCJkIiwieTEiLCJ5MCIsImN1cnZlIiwiaXNOdW1iZXIiLCJsaW5lIiwicHJvcHMiLCJjbGFzc05hbWUiLCJwYXRoIiwicGF0aFJlZiIsInJlYWxQYXRoIiwiY3JlYXRlRWxlbWVudCIsImZpbHRlclByb3BzIiwiYWRhcHRFdmVudEhhbmRsZXJzIiwicmVmIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/shape/Curve.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/shape/Dot.js":
/*!************************************************!*\
  !*** ./node_modules/recharts/lib/shape/Dot.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Dot = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _types = __webpack_require__(/*! ../util/types */ \"(pages-dir-node)/./node_modules/recharts/lib/util/types.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n} /**\r\n * @fileOverview Dot\r\n */ \nvar Dot = exports.Dot = function Dot(props) {\n    var cx = props.cx, cy = props.cy, r = props.r, className = props.className;\n    var layerClass = (0, _clsx[\"default\"])('recharts-dot', className);\n    if (cx === +cx && cy === +cy && r === +r) {\n        return /*#__PURE__*/ React.createElement(\"circle\", _extends({}, (0, _ReactUtils.filterProps)(props, false), (0, _types.adaptEventHandlers)(props), {\n            className: layerClass,\n            cx: cx,\n            cy: cy,\n            r: r\n        }));\n    }\n    return null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvc2hhcGUvRG90LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUUsV0FBVyxLQUFLQyxVQUFVRCxNQUFNQyxPQUFPRSxTQUFTLEdBQUcsV0FBVyxPQUFPSDtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1RJLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxXQUFXLEdBQUcsS0FBSztBQUNuQixJQUFJRyxRQUFRQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ25ELElBQUlDLFFBQVFDLHVCQUF1QkYsbUJBQU9BLENBQUMsdUJBQU07QUFDakQsSUFBSUcsU0FBU0gsbUJBQU9BLENBQUMsaUZBQWU7QUFDcEMsSUFBSUksY0FBY0osbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLFNBQVNFLHVCQUF1QkcsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSx5QkFBeUJDLENBQUM7SUFBSSxJQUFJLGNBQWMsT0FBT0MsU0FBUyxPQUFPO0lBQU0sSUFBSUMsSUFBSSxJQUFJRCxXQUFXRSxJQUFJLElBQUlGO0lBQVcsT0FBTyxDQUFDRiwyQkFBMkIsU0FBU0EseUJBQXlCQyxDQUFDO1FBQUksT0FBT0EsSUFBSUcsSUFBSUQ7SUFBRyxHQUFHRjtBQUFJO0FBQ25PLFNBQVNULHdCQUF3QlMsQ0FBQyxFQUFFRSxDQUFDO0lBQUksSUFBSSxDQUFDQSxLQUFLRixLQUFLQSxFQUFFRixVQUFVLEVBQUUsT0FBT0U7SUFBRyxJQUFJLFNBQVNBLEtBQUssWUFBWXBCLFFBQVFvQixNQUFNLGNBQWMsT0FBT0EsR0FBRyxPQUFPO1FBQUUsV0FBV0E7SUFBRTtJQUFHLElBQUlHLElBQUlKLHlCQUF5Qkc7SUFBSSxJQUFJQyxLQUFLQSxFQUFFQyxHQUFHLENBQUNKLElBQUksT0FBT0csRUFBRUUsR0FBRyxDQUFDTDtJQUFJLElBQUlNLElBQUk7UUFBRUMsV0FBVztJQUFLLEdBQUdDLElBQUl2QixPQUFPQyxjQUFjLElBQUlELE9BQU93Qix3QkFBd0I7SUFBRSxJQUFLLElBQUlDLEtBQUtWLEVBQUcsSUFBSSxjQUFjVSxLQUFLLEVBQUMsR0FBRUMsY0FBYyxDQUFDQyxJQUFJLENBQUNaLEdBQUdVLElBQUk7UUFBRSxJQUFJRyxJQUFJTCxJQUFJdkIsT0FBT3dCLHdCQUF3QixDQUFDVCxHQUFHVSxLQUFLO1FBQU1HLEtBQU1BLENBQUFBLEVBQUVSLEdBQUcsSUFBSVEsRUFBRUMsR0FBRyxJQUFJN0IsT0FBT0MsY0FBYyxDQUFDb0IsR0FBR0ksR0FBR0csS0FBS1AsQ0FBQyxDQUFDSSxFQUFFLEdBQUdWLENBQUMsQ0FBQ1UsRUFBRTtJQUFFO0lBQUUsT0FBT0osQ0FBQyxDQUFDLFVBQVUsR0FBR04sR0FBR0csS0FBS0EsRUFBRVcsR0FBRyxDQUFDZCxHQUFHTSxJQUFJQTtBQUFHO0FBQ3prQixTQUFTUztJQUFhQSxXQUFXOUIsT0FBTytCLE1BQU0sR0FBRy9CLE9BQU8rQixNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVQyxNQUFNO1FBQUksSUFBSyxJQUFJTCxJQUFJLEdBQUdBLElBQUlNLFVBQVVDLE1BQU0sRUFBRVAsSUFBSztZQUFFLElBQUlRLFNBQVNGLFNBQVMsQ0FBQ04sRUFBRTtZQUFFLElBQUssSUFBSVMsT0FBT0QsT0FBUTtnQkFBRSxJQUFJcEMsT0FBT0QsU0FBUyxDQUFDMkIsY0FBYyxDQUFDQyxJQUFJLENBQUNTLFFBQVFDLE1BQU07b0JBQUVKLE1BQU0sQ0FBQ0ksSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7Z0JBQUU7WUFBRTtRQUFFO1FBQUUsT0FBT0o7SUFBUTtJQUFHLE9BQU9ILFNBQVNRLEtBQUssQ0FBQyxJQUFJLEVBQUVKO0FBQVksRUFBRTs7Q0FFblY7QUFDRCxJQUFJOUIsTUFBTUYsV0FBVyxHQUFHLFNBQVNFLElBQUltQyxLQUFLO0lBQ3hDLElBQUlDLEtBQUtELE1BQU1DLEVBQUUsRUFDZkMsS0FBS0YsTUFBTUUsRUFBRSxFQUNieEIsSUFBSXNCLE1BQU10QixDQUFDLEVBQ1h5QixZQUFZSCxNQUFNRyxTQUFTO0lBQzdCLElBQUlDLGFBQWEsQ0FBQyxHQUFHbkMsS0FBSyxDQUFDLFVBQVUsRUFBRSxnQkFBZ0JrQztJQUN2RCxJQUFJRixPQUFPLENBQUNBLE1BQU1DLE9BQU8sQ0FBQ0EsTUFBTXhCLE1BQU0sQ0FBQ0EsR0FBRztRQUN4QyxPQUFPLFdBQVcsR0FBRVosTUFBTXVDLGFBQWEsQ0FBQyxVQUFVZCxTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUduQixZQUFZa0MsV0FBVyxFQUFFTixPQUFPLFFBQVEsQ0FBQyxHQUFHN0IsT0FBT29DLGtCQUFrQixFQUFFUCxRQUFRO1lBQ2hKRyxXQUFXQztZQUNYSCxJQUFJQTtZQUNKQyxJQUFJQTtZQUNKeEIsR0FBR0E7UUFDTDtJQUNGO0lBQ0EsT0FBTztBQUNUIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxzaGFwZVxcRG90LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5Eb3QgPSB2b2lkIDA7XHJcbnZhciBSZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xyXG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4uL3V0aWwvdHlwZXNcIik7XHJcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxyXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgRG90XHJcbiAqL1xyXG52YXIgRG90ID0gZXhwb3J0cy5Eb3QgPSBmdW5jdGlvbiBEb3QocHJvcHMpIHtcclxuICB2YXIgY3ggPSBwcm9wcy5jeCxcclxuICAgIGN5ID0gcHJvcHMuY3ksXHJcbiAgICByID0gcHJvcHMucixcclxuICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZTtcclxuICB2YXIgbGF5ZXJDbGFzcyA9ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1kb3QnLCBjbGFzc05hbWUpO1xyXG4gIGlmIChjeCA9PT0gK2N4ICYmIGN5ID09PSArY3kgJiYgciA9PT0gK3IpIHtcclxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLCBfZXh0ZW5kcyh7fSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShwcm9wcywgZmFsc2UpLCAoMCwgX3R5cGVzLmFkYXB0RXZlbnRIYW5kbGVycykocHJvcHMpLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogbGF5ZXJDbGFzcyxcclxuICAgICAgY3g6IGN4LFxyXG4gICAgICBjeTogY3ksXHJcbiAgICAgIHI6IHJcclxuICAgIH0pKTtcclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn07Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkRvdCIsIlJlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX2Nsc3giLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX3R5cGVzIiwiX1JlYWN0VXRpbHMiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJhcHBseSIsInByb3BzIiwiY3giLCJjeSIsImNsYXNzTmFtZSIsImxheWVyQ2xhc3MiLCJjcmVhdGVFbGVtZW50IiwiZmlsdGVyUHJvcHMiLCJhZGFwdEV2ZW50SGFuZGxlcnMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/shape/Dot.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/shape/Polygon.js":
/*!****************************************************!*\
  !*** ./node_modules/recharts/lib/shape/Polygon.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Polygon = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"points\",\n    \"className\",\n    \"baseLinePoints\",\n    \"connectNulls\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n} /**\r\n * @fileOverview Polygon\r\n */ \nvar isValidatePoint = function isValidatePoint(point) {\n    return point && point.x === +point.x && point.y === +point.y;\n};\nvar getParsedPoints = function getParsedPoints() {\n    var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var segmentPoints = [\n        []\n    ];\n    points.forEach(function(entry) {\n        if (isValidatePoint(entry)) {\n            segmentPoints[segmentPoints.length - 1].push(entry);\n        } else if (segmentPoints[segmentPoints.length - 1].length > 0) {\n            // add another path\n            segmentPoints.push([]);\n        }\n    });\n    if (isValidatePoint(points[0])) {\n        segmentPoints[segmentPoints.length - 1].push(points[0]);\n    }\n    if (segmentPoints[segmentPoints.length - 1].length <= 0) {\n        segmentPoints = segmentPoints.slice(0, -1);\n    }\n    return segmentPoints;\n};\nvar getSinglePolygonPath = function getSinglePolygonPath(points, connectNulls) {\n    var segmentPoints = getParsedPoints(points);\n    if (connectNulls) {\n        segmentPoints = [\n            segmentPoints.reduce(function(res, segPoints) {\n                return [].concat(_toConsumableArray(res), _toConsumableArray(segPoints));\n            }, [])\n        ];\n    }\n    var polygonPath = segmentPoints.map(function(segPoints) {\n        return segPoints.reduce(function(path, point, index) {\n            return \"\".concat(path).concat(index === 0 ? 'M' : 'L').concat(point.x, \",\").concat(point.y);\n        }, '');\n    }).join('');\n    return segmentPoints.length === 1 ? \"\".concat(polygonPath, \"Z\") : polygonPath;\n};\nvar getRanglePath = function getRanglePath(points, baseLinePoints, connectNulls) {\n    var outerPath = getSinglePolygonPath(points, connectNulls);\n    return \"\".concat(outerPath.slice(-1) === 'Z' ? outerPath.slice(0, -1) : outerPath, \"L\").concat(getSinglePolygonPath(baseLinePoints.reverse(), connectNulls).slice(1));\n};\nvar Polygon = exports.Polygon = function Polygon(props) {\n    var points = props.points, className = props.className, baseLinePoints = props.baseLinePoints, connectNulls = props.connectNulls, others = _objectWithoutProperties(props, _excluded);\n    if (!points || !points.length) {\n        return null;\n    }\n    var layerClass = (0, _clsx[\"default\"])('recharts-polygon', className);\n    if (baseLinePoints && baseLinePoints.length) {\n        var hasStroke = others.stroke && others.stroke !== 'none';\n        var rangePath = getRanglePath(points, baseLinePoints, connectNulls);\n        return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", {\n            className: layerClass\n        }, /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(others, true), {\n            fill: rangePath.slice(-1) === 'Z' ? others.fill : 'none',\n            stroke: \"none\",\n            d: rangePath\n        })), hasStroke ? /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(others, true), {\n            fill: \"none\",\n            d: getSinglePolygonPath(points, connectNulls)\n        })) : null, hasStroke ? /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(others, true), {\n            fill: \"none\",\n            d: getSinglePolygonPath(baseLinePoints, connectNulls)\n        })) : null);\n    }\n    var singlePath = getSinglePolygonPath(points, connectNulls);\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(others, true), {\n        fill: singlePath.slice(-1) === 'Z' ? others.fill : 'none',\n        className: layerClass,\n        d: singlePath\n    }));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvc2hhcGUvUG9seWdvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsZUFBZSxHQUFHLEtBQUs7QUFDdkIsSUFBSUcsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNuRCxJQUFJQyxRQUFRRix1QkFBdUJDLG1CQUFPQSxDQUFDLHVCQUFNO0FBQ2pELElBQUlFLGNBQWNGLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM5QyxJQUFJRyxZQUFZO0lBQUM7SUFBVTtJQUFhO0lBQWtCO0NBQWU7QUFDekUsU0FBU0osdUJBQXVCSyxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFO0lBQWFBLFdBQVdiLE9BQU9jLE1BQU0sR0FBR2QsT0FBT2MsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVUMsTUFBTTtRQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFBRSxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFBRSxJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQUUsSUFBSXBCLE9BQU9zQixTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRQyxNQUFNO29CQUFFTCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO2dCQUFFO1lBQUU7UUFBRTtRQUFFLE9BQU9MO0lBQVE7SUFBRyxPQUFPSCxTQUFTWSxLQUFLLENBQUMsSUFBSSxFQUFFUDtBQUFZO0FBQ2xWLFNBQVNRLHlCQUF5Qk4sTUFBTSxFQUFFTyxRQUFRO0lBQUksSUFBSVAsVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUFHLElBQUlKLFNBQVNZLDhCQUE4QlIsUUFBUU87SUFBVyxJQUFJTixLQUFLSjtJQUFHLElBQUlqQixPQUFPNkIscUJBQXFCLEVBQUU7UUFBRSxJQUFJQyxtQkFBbUI5QixPQUFPNkIscUJBQXFCLENBQUNUO1FBQVMsSUFBS0gsSUFBSSxHQUFHQSxJQUFJYSxpQkFBaUJYLE1BQU0sRUFBRUYsSUFBSztZQUFFSSxNQUFNUyxnQkFBZ0IsQ0FBQ2IsRUFBRTtZQUFFLElBQUlVLFNBQVNJLE9BQU8sQ0FBQ1YsUUFBUSxHQUFHO1lBQVUsSUFBSSxDQUFDckIsT0FBT3NCLFNBQVMsQ0FBQ1Usb0JBQW9CLENBQUNSLElBQUksQ0FBQ0osUUFBUUMsTUFBTTtZQUFVTCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO1FBQUU7SUFBRTtJQUFFLE9BQU9MO0FBQVE7QUFDM2UsU0FBU1ksOEJBQThCUixNQUFNLEVBQUVPLFFBQVE7SUFBSSxJQUFJUCxVQUFVLE1BQU0sT0FBTyxDQUFDO0lBQUcsSUFBSUosU0FBUyxDQUFDO0lBQUcsSUFBSyxJQUFJSyxPQUFPRCxPQUFRO1FBQUUsSUFBSXBCLE9BQU9zQixTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRQyxNQUFNO1lBQUUsSUFBSU0sU0FBU0ksT0FBTyxDQUFDVixRQUFRLEdBQUc7WUFBVUwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtRQUFFO0lBQUU7SUFBRSxPQUFPTDtBQUFRO0FBQ3RSLFNBQVNpQixtQkFBbUJDLEdBQUc7SUFBSSxPQUFPQyxtQkFBbUJELFFBQVFFLGlCQUFpQkYsUUFBUUcsNEJBQTRCSCxRQUFRSTtBQUFzQjtBQUN4SixTQUFTQTtJQUF1QixNQUFNLElBQUlDLFVBQVU7QUFBeUk7QUFDN0wsU0FBU0YsNEJBQTRCRyxDQUFDLEVBQUVDLE1BQU07SUFBSSxJQUFJLENBQUNELEdBQUc7SUFBUSxJQUFJLE9BQU9BLE1BQU0sVUFBVSxPQUFPRSxrQkFBa0JGLEdBQUdDO0lBQVMsSUFBSUUsSUFBSTNDLE9BQU9zQixTQUFTLENBQUNzQixRQUFRLENBQUNwQixJQUFJLENBQUNnQixHQUFHSyxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQUksSUFBSUYsTUFBTSxZQUFZSCxFQUFFLFdBQVcsRUFBRUcsSUFBSUgsRUFBRSxXQUFXLENBQUNNLElBQUk7SUFBRSxJQUFJSCxNQUFNLFNBQVNBLE1BQU0sT0FBTyxPQUFPSSxNQUFNQyxJQUFJLENBQUNSO0lBQUksSUFBSUcsTUFBTSxlQUFlLDJDQUEyQ00sSUFBSSxDQUFDTixJQUFJLE9BQU9ELGtCQUFrQkYsR0FBR0M7QUFBUztBQUMvWixTQUFTTCxpQkFBaUJjLElBQUk7SUFBSSxJQUFJLE9BQU9DLFdBQVcsZUFBZUQsSUFBSSxDQUFDQyxPQUFPQyxRQUFRLENBQUMsSUFBSSxRQUFRRixJQUFJLENBQUMsYUFBYSxJQUFJLE1BQU0sT0FBT0gsTUFBTUMsSUFBSSxDQUFDRTtBQUFPO0FBQzdKLFNBQVNmLG1CQUFtQkQsR0FBRztJQUFJLElBQUlhLE1BQU1NLE9BQU8sQ0FBQ25CLE1BQU0sT0FBT1Esa0JBQWtCUjtBQUFNO0FBQzFGLFNBQVNRLGtCQUFrQlIsR0FBRyxFQUFFb0IsR0FBRztJQUFJLElBQUlBLE9BQU8sUUFBUUEsTUFBTXBCLElBQUlmLE1BQU0sRUFBRW1DLE1BQU1wQixJQUFJZixNQUFNO0lBQUUsSUFBSyxJQUFJRixJQUFJLEdBQUdzQyxPQUFPLElBQUlSLE1BQU1PLE1BQU1yQyxJQUFJcUMsS0FBS3JDLElBQUtzQyxJQUFJLENBQUN0QyxFQUFFLEdBQUdpQixHQUFHLENBQUNqQixFQUFFO0lBQUUsT0FBT3NDO0FBQU0sRUFBRTs7Q0FFbkw7QUFDRCxJQUFJQyxrQkFBa0IsU0FBU0EsZ0JBQWdCQyxLQUFLO0lBQ2xELE9BQU9BLFNBQVNBLE1BQU1DLENBQUMsS0FBSyxDQUFDRCxNQUFNQyxDQUFDLElBQUlELE1BQU1FLENBQUMsS0FBSyxDQUFDRixNQUFNRSxDQUFDO0FBQzlEO0FBQ0EsSUFBSUMsa0JBQWtCLFNBQVNBO0lBQzdCLElBQUlDLFNBQVMzQyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBSzRDLFlBQVk1QyxTQUFTLENBQUMsRUFBRSxHQUFHLEVBQUU7SUFDbkYsSUFBSTZDLGdCQUFnQjtRQUFDLEVBQUU7S0FBQztJQUN4QkYsT0FBT0csT0FBTyxDQUFDLFNBQVVDLEtBQUs7UUFDNUIsSUFBSVQsZ0JBQWdCUyxRQUFRO1lBQzFCRixhQUFhLENBQUNBLGNBQWM1QyxNQUFNLEdBQUcsRUFBRSxDQUFDK0MsSUFBSSxDQUFDRDtRQUMvQyxPQUFPLElBQUlGLGFBQWEsQ0FBQ0EsY0FBYzVDLE1BQU0sR0FBRyxFQUFFLENBQUNBLE1BQU0sR0FBRyxHQUFHO1lBQzdELG1CQUFtQjtZQUNuQjRDLGNBQWNHLElBQUksQ0FBQyxFQUFFO1FBQ3ZCO0lBQ0Y7SUFDQSxJQUFJVixnQkFBZ0JLLE1BQU0sQ0FBQyxFQUFFLEdBQUc7UUFDOUJFLGFBQWEsQ0FBQ0EsY0FBYzVDLE1BQU0sR0FBRyxFQUFFLENBQUMrQyxJQUFJLENBQUNMLE1BQU0sQ0FBQyxFQUFFO0lBQ3hEO0lBQ0EsSUFBSUUsYUFBYSxDQUFDQSxjQUFjNUMsTUFBTSxHQUFHLEVBQUUsQ0FBQ0EsTUFBTSxJQUFJLEdBQUc7UUFDdkQ0QyxnQkFBZ0JBLGNBQWNsQixLQUFLLENBQUMsR0FBRyxDQUFDO0lBQzFDO0lBQ0EsT0FBT2tCO0FBQ1Q7QUFDQSxJQUFJSSx1QkFBdUIsU0FBU0EscUJBQXFCTixNQUFNLEVBQUVPLFlBQVk7SUFDM0UsSUFBSUwsZ0JBQWdCSCxnQkFBZ0JDO0lBQ3BDLElBQUlPLGNBQWM7UUFDaEJMLGdCQUFnQjtZQUFDQSxjQUFjTSxNQUFNLENBQUMsU0FBVUMsR0FBRyxFQUFFQyxTQUFTO2dCQUM1RCxPQUFPLEVBQUUsQ0FBQ0MsTUFBTSxDQUFDdkMsbUJBQW1CcUMsTUFBTXJDLG1CQUFtQnNDO1lBQy9ELEdBQUcsRUFBRTtTQUFFO0lBQ1Q7SUFDQSxJQUFJRSxjQUFjVixjQUFjVyxHQUFHLENBQUMsU0FBVUgsU0FBUztRQUNyRCxPQUFPQSxVQUFVRixNQUFNLENBQUMsU0FBVU0sSUFBSSxFQUFFbEIsS0FBSyxFQUFFbUIsS0FBSztZQUNsRCxPQUFPLEdBQUdKLE1BQU0sQ0FBQ0csTUFBTUgsTUFBTSxDQUFDSSxVQUFVLElBQUksTUFBTSxLQUFLSixNQUFNLENBQUNmLE1BQU1DLENBQUMsRUFBRSxLQUFLYyxNQUFNLENBQUNmLE1BQU1FLENBQUM7UUFDNUYsR0FBRztJQUNMLEdBQUdrQixJQUFJLENBQUM7SUFDUixPQUFPZCxjQUFjNUMsTUFBTSxLQUFLLElBQUksR0FBR3FELE1BQU0sQ0FBQ0MsYUFBYSxPQUFPQTtBQUNwRTtBQUNBLElBQUlLLGdCQUFnQixTQUFTQSxjQUFjakIsTUFBTSxFQUFFa0IsY0FBYyxFQUFFWCxZQUFZO0lBQzdFLElBQUlZLFlBQVliLHFCQUFxQk4sUUFBUU87SUFDN0MsT0FBTyxHQUFHSSxNQUFNLENBQUNRLFVBQVVuQyxLQUFLLENBQUMsQ0FBQyxPQUFPLE1BQU1tQyxVQUFVbkMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLbUMsV0FBVyxLQUFLUixNQUFNLENBQUNMLHFCQUFxQlksZUFBZUUsT0FBTyxJQUFJYixjQUFjdkIsS0FBSyxDQUFDO0FBQ3BLO0FBQ0EsSUFBSXpDLFVBQVVGLGVBQWUsR0FBRyxTQUFTRSxRQUFROEUsS0FBSztJQUNwRCxJQUFJckIsU0FBU3FCLE1BQU1yQixNQUFNLEVBQ3ZCc0IsWUFBWUQsTUFBTUMsU0FBUyxFQUMzQkosaUJBQWlCRyxNQUFNSCxjQUFjLEVBQ3JDWCxlQUFlYyxNQUFNZCxZQUFZLEVBQ2pDZ0IsU0FBUzFELHlCQUF5QndELE9BQU94RTtJQUMzQyxJQUFJLENBQUNtRCxVQUFVLENBQUNBLE9BQU8xQyxNQUFNLEVBQUU7UUFDN0IsT0FBTztJQUNUO0lBQ0EsSUFBSWtFLGFBQWEsQ0FBQyxHQUFHN0UsS0FBSyxDQUFDLFVBQVUsRUFBRSxvQkFBb0IyRTtJQUMzRCxJQUFJSixrQkFBa0JBLGVBQWU1RCxNQUFNLEVBQUU7UUFDM0MsSUFBSW1FLFlBQVlGLE9BQU9HLE1BQU0sSUFBSUgsT0FBT0csTUFBTSxLQUFLO1FBQ25ELElBQUlDLFlBQVlWLGNBQWNqQixRQUFRa0IsZ0JBQWdCWDtRQUN0RCxPQUFPLFdBQVcsR0FBRS9ELE1BQU0sQ0FBQyxVQUFVLENBQUNvRixhQUFhLENBQUMsS0FBSztZQUN2RE4sV0FBV0U7UUFDYixHQUFHLFdBQVcsR0FBRWhGLE1BQU0sQ0FBQyxVQUFVLENBQUNvRixhQUFhLENBQUMsUUFBUTVFLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBR0osWUFBWWlGLFdBQVcsRUFBRU4sUUFBUSxPQUFPO1lBQy9HTyxNQUFNSCxVQUFVM0MsS0FBSyxDQUFDLENBQUMsT0FBTyxNQUFNdUMsT0FBT08sSUFBSSxHQUFHO1lBQ2xESixRQUFRO1lBQ1JLLEdBQUdKO1FBQ0wsS0FBS0YsWUFBWSxXQUFXLEdBQUVqRixNQUFNLENBQUMsVUFBVSxDQUFDb0YsYUFBYSxDQUFDLFFBQVE1RSxTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUdKLFlBQVlpRixXQUFXLEVBQUVOLFFBQVEsT0FBTztZQUM3SE8sTUFBTTtZQUNOQyxHQUFHekIscUJBQXFCTixRQUFRTztRQUNsQyxNQUFNLE1BQU1rQixZQUFZLFdBQVcsR0FBRWpGLE1BQU0sQ0FBQyxVQUFVLENBQUNvRixhQUFhLENBQUMsUUFBUTVFLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBR0osWUFBWWlGLFdBQVcsRUFBRU4sUUFBUSxPQUFPO1lBQ3BJTyxNQUFNO1lBQ05DLEdBQUd6QixxQkFBcUJZLGdCQUFnQlg7UUFDMUMsTUFBTTtJQUNSO0lBQ0EsSUFBSXlCLGFBQWExQixxQkFBcUJOLFFBQVFPO0lBQzlDLE9BQU8sV0FBVyxHQUFFL0QsTUFBTSxDQUFDLFVBQVUsQ0FBQ29GLGFBQWEsQ0FBQyxRQUFRNUUsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHSixZQUFZaUYsV0FBVyxFQUFFTixRQUFRLE9BQU87UUFDbkhPLE1BQU1FLFdBQVdoRCxLQUFLLENBQUMsQ0FBQyxPQUFPLE1BQU11QyxPQUFPTyxJQUFJLEdBQUc7UUFDbkRSLFdBQVdFO1FBQ1hPLEdBQUdDO0lBQ0w7QUFDRiIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcc2hhcGVcXFBvbHlnb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5Qb2x5Z29uID0gdm9pZCAwO1xyXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcclxudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmVhY3RVdGlsc1wiKTtcclxudmFyIF9leGNsdWRlZCA9IFtcInBvaW50c1wiLCBcImNsYXNzTmFtZVwiLCBcImJhc2VMaW5lUG9pbnRzXCIsIFwiY29ubmVjdE51bGxzXCJdO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XHJcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cclxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XHJcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxyXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XHJcbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9IC8qKlxyXG4gKiBAZmlsZU92ZXJ2aWV3IFBvbHlnb25cclxuICovXHJcbnZhciBpc1ZhbGlkYXRlUG9pbnQgPSBmdW5jdGlvbiBpc1ZhbGlkYXRlUG9pbnQocG9pbnQpIHtcclxuICByZXR1cm4gcG9pbnQgJiYgcG9pbnQueCA9PT0gK3BvaW50LnggJiYgcG9pbnQueSA9PT0gK3BvaW50Lnk7XHJcbn07XHJcbnZhciBnZXRQYXJzZWRQb2ludHMgPSBmdW5jdGlvbiBnZXRQYXJzZWRQb2ludHMoKSB7XHJcbiAgdmFyIHBvaW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XHJcbiAgdmFyIHNlZ21lbnRQb2ludHMgPSBbW11dO1xyXG4gIHBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgaWYgKGlzVmFsaWRhdGVQb2ludChlbnRyeSkpIHtcclxuICAgICAgc2VnbWVudFBvaW50c1tzZWdtZW50UG9pbnRzLmxlbmd0aCAtIDFdLnB1c2goZW50cnkpO1xyXG4gICAgfSBlbHNlIGlmIChzZWdtZW50UG9pbnRzW3NlZ21lbnRQb2ludHMubGVuZ3RoIC0gMV0ubGVuZ3RoID4gMCkge1xyXG4gICAgICAvLyBhZGQgYW5vdGhlciBwYXRoXHJcbiAgICAgIHNlZ21lbnRQb2ludHMucHVzaChbXSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgaWYgKGlzVmFsaWRhdGVQb2ludChwb2ludHNbMF0pKSB7XHJcbiAgICBzZWdtZW50UG9pbnRzW3NlZ21lbnRQb2ludHMubGVuZ3RoIC0gMV0ucHVzaChwb2ludHNbMF0pO1xyXG4gIH1cclxuICBpZiAoc2VnbWVudFBvaW50c1tzZWdtZW50UG9pbnRzLmxlbmd0aCAtIDFdLmxlbmd0aCA8PSAwKSB7XHJcbiAgICBzZWdtZW50UG9pbnRzID0gc2VnbWVudFBvaW50cy5zbGljZSgwLCAtMSk7XHJcbiAgfVxyXG4gIHJldHVybiBzZWdtZW50UG9pbnRzO1xyXG59O1xyXG52YXIgZ2V0U2luZ2xlUG9seWdvblBhdGggPSBmdW5jdGlvbiBnZXRTaW5nbGVQb2x5Z29uUGF0aChwb2ludHMsIGNvbm5lY3ROdWxscykge1xyXG4gIHZhciBzZWdtZW50UG9pbnRzID0gZ2V0UGFyc2VkUG9pbnRzKHBvaW50cyk7XHJcbiAgaWYgKGNvbm5lY3ROdWxscykge1xyXG4gICAgc2VnbWVudFBvaW50cyA9IFtzZWdtZW50UG9pbnRzLnJlZHVjZShmdW5jdGlvbiAocmVzLCBzZWdQb2ludHMpIHtcclxuICAgICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocmVzKSwgX3RvQ29uc3VtYWJsZUFycmF5KHNlZ1BvaW50cykpO1xyXG4gICAgfSwgW10pXTtcclxuICB9XHJcbiAgdmFyIHBvbHlnb25QYXRoID0gc2VnbWVudFBvaW50cy5tYXAoZnVuY3Rpb24gKHNlZ1BvaW50cykge1xyXG4gICAgcmV0dXJuIHNlZ1BvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKHBhdGgsIHBvaW50LCBpbmRleCkge1xyXG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQocGF0aCkuY29uY2F0KGluZGV4ID09PSAwID8gJ00nIDogJ0wnKS5jb25jYXQocG9pbnQueCwgXCIsXCIpLmNvbmNhdChwb2ludC55KTtcclxuICAgIH0sICcnKTtcclxuICB9KS5qb2luKCcnKTtcclxuICByZXR1cm4gc2VnbWVudFBvaW50cy5sZW5ndGggPT09IDEgPyBcIlwiLmNvbmNhdChwb2x5Z29uUGF0aCwgXCJaXCIpIDogcG9seWdvblBhdGg7XHJcbn07XHJcbnZhciBnZXRSYW5nbGVQYXRoID0gZnVuY3Rpb24gZ2V0UmFuZ2xlUGF0aChwb2ludHMsIGJhc2VMaW5lUG9pbnRzLCBjb25uZWN0TnVsbHMpIHtcclxuICB2YXIgb3V0ZXJQYXRoID0gZ2V0U2luZ2xlUG9seWdvblBhdGgocG9pbnRzLCBjb25uZWN0TnVsbHMpO1xyXG4gIHJldHVybiBcIlwiLmNvbmNhdChvdXRlclBhdGguc2xpY2UoLTEpID09PSAnWicgPyBvdXRlclBhdGguc2xpY2UoMCwgLTEpIDogb3V0ZXJQYXRoLCBcIkxcIikuY29uY2F0KGdldFNpbmdsZVBvbHlnb25QYXRoKGJhc2VMaW5lUG9pbnRzLnJldmVyc2UoKSwgY29ubmVjdE51bGxzKS5zbGljZSgxKSk7XHJcbn07XHJcbnZhciBQb2x5Z29uID0gZXhwb3J0cy5Qb2x5Z29uID0gZnVuY3Rpb24gUG9seWdvbihwcm9wcykge1xyXG4gIHZhciBwb2ludHMgPSBwcm9wcy5wb2ludHMsXHJcbiAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXHJcbiAgICBiYXNlTGluZVBvaW50cyA9IHByb3BzLmJhc2VMaW5lUG9pbnRzLFxyXG4gICAgY29ubmVjdE51bGxzID0gcHJvcHMuY29ubmVjdE51bGxzLFxyXG4gICAgb3RoZXJzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQpO1xyXG4gIGlmICghcG9pbnRzIHx8ICFwb2ludHMubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgdmFyIGxheWVyQ2xhc3MgPSAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtcG9seWdvbicsIGNsYXNzTmFtZSk7XHJcbiAgaWYgKGJhc2VMaW5lUG9pbnRzICYmIGJhc2VMaW5lUG9pbnRzLmxlbmd0aCkge1xyXG4gICAgdmFyIGhhc1N0cm9rZSA9IG90aGVycy5zdHJva2UgJiYgb3RoZXJzLnN0cm9rZSAhPT0gJ25vbmUnO1xyXG4gICAgdmFyIHJhbmdlUGF0aCA9IGdldFJhbmdsZVBhdGgocG9pbnRzLCBiYXNlTGluZVBvaW50cywgY29ubmVjdE51bGxzKTtcclxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogbGF5ZXJDbGFzc1xyXG4gICAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInBhdGhcIiwgX2V4dGVuZHMoe30sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykob3RoZXJzLCB0cnVlKSwge1xyXG4gICAgICBmaWxsOiByYW5nZVBhdGguc2xpY2UoLTEpID09PSAnWicgPyBvdGhlcnMuZmlsbCA6ICdub25lJyxcclxuICAgICAgc3Ryb2tlOiBcIm5vbmVcIixcclxuICAgICAgZDogcmFuZ2VQYXRoXHJcbiAgICB9KSksIGhhc1N0cm9rZSA/IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIF9leHRlbmRzKHt9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKG90aGVycywgdHJ1ZSksIHtcclxuICAgICAgZmlsbDogXCJub25lXCIsXHJcbiAgICAgIGQ6IGdldFNpbmdsZVBvbHlnb25QYXRoKHBvaW50cywgY29ubmVjdE51bGxzKVxyXG4gICAgfSkpIDogbnVsbCwgaGFzU3Ryb2tlID8gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInBhdGhcIiwgX2V4dGVuZHMoe30sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykob3RoZXJzLCB0cnVlKSwge1xyXG4gICAgICBmaWxsOiBcIm5vbmVcIixcclxuICAgICAgZDogZ2V0U2luZ2xlUG9seWdvblBhdGgoYmFzZUxpbmVQb2ludHMsIGNvbm5lY3ROdWxscylcclxuICAgIH0pKSA6IG51bGwpO1xyXG4gIH1cclxuICB2YXIgc2luZ2xlUGF0aCA9IGdldFNpbmdsZVBvbHlnb25QYXRoKHBvaW50cywgY29ubmVjdE51bGxzKTtcclxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInBhdGhcIiwgX2V4dGVuZHMoe30sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykob3RoZXJzLCB0cnVlKSwge1xyXG4gICAgZmlsbDogc2luZ2xlUGF0aC5zbGljZSgtMSkgPT09ICdaJyA/IG90aGVycy5maWxsIDogJ25vbmUnLFxyXG4gICAgY2xhc3NOYW1lOiBsYXllckNsYXNzLFxyXG4gICAgZDogc2luZ2xlUGF0aFxyXG4gIH0pKTtcclxufTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJQb2x5Z29uIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfY2xzeCIsIl9SZWFjdFV0aWxzIiwiX2V4Y2x1ZGVkIiwib2JqIiwiX19lc01vZHVsZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsImV4Y2x1ZGVkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzb3VyY2VTeW1ib2xLZXlzIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiYXJyIiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIlR5cGVFcnJvciIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJ0b1N0cmluZyIsInNsaWNlIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJpdGVyIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJpc0FycmF5IiwibGVuIiwiYXJyMiIsImlzVmFsaWRhdGVQb2ludCIsInBvaW50IiwieCIsInkiLCJnZXRQYXJzZWRQb2ludHMiLCJwb2ludHMiLCJ1bmRlZmluZWQiLCJzZWdtZW50UG9pbnRzIiwiZm9yRWFjaCIsImVudHJ5IiwicHVzaCIsImdldFNpbmdsZVBvbHlnb25QYXRoIiwiY29ubmVjdE51bGxzIiwicmVkdWNlIiwicmVzIiwic2VnUG9pbnRzIiwiY29uY2F0IiwicG9seWdvblBhdGgiLCJtYXAiLCJwYXRoIiwiaW5kZXgiLCJqb2luIiwiZ2V0UmFuZ2xlUGF0aCIsImJhc2VMaW5lUG9pbnRzIiwib3V0ZXJQYXRoIiwicmV2ZXJzZSIsInByb3BzIiwiY2xhc3NOYW1lIiwib3RoZXJzIiwibGF5ZXJDbGFzcyIsImhhc1N0cm9rZSIsInN0cm9rZSIsInJhbmdlUGF0aCIsImNyZWF0ZUVsZW1lbnQiLCJmaWx0ZXJQcm9wcyIsImZpbGwiLCJkIiwic2luZ2xlUGF0aCJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/shape/Polygon.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/shape/Rectangle.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/shape/Rectangle.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isInRectangle = exports.Rectangle = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Rectangle\r\n */ \nvar getRectanglePath = function getRectanglePath(x, y, width, height, radius) {\n    var maxRadius = Math.min(Math.abs(width) / 2, Math.abs(height) / 2);\n    var ySign = height >= 0 ? 1 : -1;\n    var xSign = width >= 0 ? 1 : -1;\n    var clockWise = height >= 0 && width >= 0 || height < 0 && width < 0 ? 1 : 0;\n    var path;\n    if (maxRadius > 0 && radius instanceof Array) {\n        var newRadius = [\n            0,\n            0,\n            0,\n            0\n        ];\n        for(var i = 0, len = 4; i < len; i++){\n            newRadius[i] = radius[i] > maxRadius ? maxRadius : radius[i];\n        }\n        path = \"M\".concat(x, \",\").concat(y + ySign * newRadius[0]);\n        if (newRadius[0] > 0) {\n            path += \"A \".concat(newRadius[0], \",\").concat(newRadius[0], \",0,0,\").concat(clockWise, \",\").concat(x + xSign * newRadius[0], \",\").concat(y);\n        }\n        path += \"L \".concat(x + width - xSign * newRadius[1], \",\").concat(y);\n        if (newRadius[1] > 0) {\n            path += \"A \".concat(newRadius[1], \",\").concat(newRadius[1], \",0,0,\").concat(clockWise, \",\\n        \").concat(x + width, \",\").concat(y + ySign * newRadius[1]);\n        }\n        path += \"L \".concat(x + width, \",\").concat(y + height - ySign * newRadius[2]);\n        if (newRadius[2] > 0) {\n            path += \"A \".concat(newRadius[2], \",\").concat(newRadius[2], \",0,0,\").concat(clockWise, \",\\n        \").concat(x + width - xSign * newRadius[2], \",\").concat(y + height);\n        }\n        path += \"L \".concat(x + xSign * newRadius[3], \",\").concat(y + height);\n        if (newRadius[3] > 0) {\n            path += \"A \".concat(newRadius[3], \",\").concat(newRadius[3], \",0,0,\").concat(clockWise, \",\\n        \").concat(x, \",\").concat(y + height - ySign * newRadius[3]);\n        }\n        path += 'Z';\n    } else if (maxRadius > 0 && radius === +radius && radius > 0) {\n        var _newRadius = Math.min(maxRadius, radius);\n        path = \"M \".concat(x, \",\").concat(y + ySign * _newRadius, \"\\n            A \").concat(_newRadius, \",\").concat(_newRadius, \",0,0,\").concat(clockWise, \",\").concat(x + xSign * _newRadius, \",\").concat(y, \"\\n            L \").concat(x + width - xSign * _newRadius, \",\").concat(y, \"\\n            A \").concat(_newRadius, \",\").concat(_newRadius, \",0,0,\").concat(clockWise, \",\").concat(x + width, \",\").concat(y + ySign * _newRadius, \"\\n            L \").concat(x + width, \",\").concat(y + height - ySign * _newRadius, \"\\n            A \").concat(_newRadius, \",\").concat(_newRadius, \",0,0,\").concat(clockWise, \",\").concat(x + width - xSign * _newRadius, \",\").concat(y + height, \"\\n            L \").concat(x + xSign * _newRadius, \",\").concat(y + height, \"\\n            A \").concat(_newRadius, \",\").concat(_newRadius, \",0,0,\").concat(clockWise, \",\").concat(x, \",\").concat(y + height - ySign * _newRadius, \" Z\");\n    } else {\n        path = \"M \".concat(x, \",\").concat(y, \" h \").concat(width, \" v \").concat(height, \" h \").concat(-width, \" Z\");\n    }\n    return path;\n};\nvar isInRectangle = exports.isInRectangle = function isInRectangle(point, rect) {\n    if (!point || !rect) {\n        return false;\n    }\n    var px = point.x, py = point.y;\n    var x = rect.x, y = rect.y, width = rect.width, height = rect.height;\n    if (Math.abs(width) > 0 && Math.abs(height) > 0) {\n        var minX = Math.min(x, x + width);\n        var maxX = Math.max(x, x + width);\n        var minY = Math.min(y, y + height);\n        var maxY = Math.max(y, y + height);\n        return px >= minX && px <= maxX && py >= minY && py <= maxY;\n    }\n    return false;\n};\nvar defaultProps = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n    // The radius of border\n    // The radius of four corners when radius is a number\n    // The radius of left-top, right-top, right-bottom, left-bottom when radius is an array\n    radius: 0,\n    isAnimationActive: false,\n    isUpdateAnimationActive: false,\n    animationBegin: 0,\n    animationDuration: 1500,\n    animationEasing: 'ease'\n};\nvar Rectangle = exports.Rectangle = function Rectangle(rectangleProps) {\n    var props = _objectSpread(_objectSpread({}, defaultProps), rectangleProps);\n    var pathRef = (0, _react.useRef)();\n    var _useState = (0, _react.useState)(-1), _useState2 = _slicedToArray(_useState, 2), totalLength = _useState2[0], setTotalLength = _useState2[1];\n    (0, _react.useEffect)(function() {\n        if (pathRef.current && pathRef.current.getTotalLength) {\n            try {\n                var pathTotalLength = pathRef.current.getTotalLength();\n                if (pathTotalLength) {\n                    setTotalLength(pathTotalLength);\n                }\n            } catch (err) {\n            // calculate total length error\n            }\n        }\n    }, []);\n    var x = props.x, y = props.y, width = props.width, height = props.height, radius = props.radius, className = props.className;\n    var animationEasing = props.animationEasing, animationDuration = props.animationDuration, animationBegin = props.animationBegin, isAnimationActive = props.isAnimationActive, isUpdateAnimationActive = props.isUpdateAnimationActive;\n    if (x !== +x || y !== +y || width !== +width || height !== +height || width === 0 || height === 0) {\n        return null;\n    }\n    var layerClass = (0, _clsx[\"default\"])('recharts-rectangle', className);\n    if (!isUpdateAnimationActive) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(props, true), {\n            className: layerClass,\n            d: getRectanglePath(x, y, width, height, radius)\n        }));\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n        canBegin: totalLength > 0,\n        from: {\n            width: width,\n            height: height,\n            x: x,\n            y: y\n        },\n        to: {\n            width: width,\n            height: height,\n            x: x,\n            y: y\n        },\n        duration: animationDuration,\n        animationEasing: animationEasing,\n        isActive: isUpdateAnimationActive\n    }, function(_ref) {\n        var currWidth = _ref.width, currHeight = _ref.height, currX = _ref.x, currY = _ref.y;\n        return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n            canBegin: totalLength > 0,\n            from: \"0px \".concat(totalLength === -1 ? 1 : totalLength, \"px\"),\n            to: \"\".concat(totalLength, \"px 0px\"),\n            attributeName: \"strokeDasharray\",\n            begin: animationBegin,\n            duration: animationDuration,\n            isActive: isAnimationActive,\n            easing: animationEasing\n        }, /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(props, true), {\n            className: layerClass,\n            d: getRectanglePath(currX, currY, currWidth, currHeight, radius),\n            ref: pathRef\n        })));\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvc2hhcGUvUmVjdGFuZ2xlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxxQkFBcUIsR0FBR0EsaUJBQWlCLEdBQUcsS0FBSztBQUNqRCxJQUFJSSxTQUFTQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3BELElBQUlDLFFBQVFDLHVCQUF1QkYsbUJBQU9BLENBQUMsdUJBQU07QUFDakQsSUFBSUcsZUFBZUQsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUNoRSxJQUFJSSxjQUFjSixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDOUMsU0FBU0UsdUJBQXVCRyxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFLHlCQUF5QkMsQ0FBQztJQUFJLElBQUksY0FBYyxPQUFPQyxTQUFTLE9BQU87SUFBTSxJQUFJQyxJQUFJLElBQUlELFdBQVdFLElBQUksSUFBSUY7SUFBVyxPQUFPLENBQUNGLDJCQUEyQixTQUFTQSx5QkFBeUJDLENBQUM7UUFBSSxPQUFPQSxJQUFJRyxJQUFJRDtJQUFHLEdBQUdGO0FBQUk7QUFDbk8sU0FBU1Qsd0JBQXdCUyxDQUFDLEVBQUVFLENBQUM7SUFBSSxJQUFJLENBQUNBLEtBQUtGLEtBQUtBLEVBQUVGLFVBQVUsRUFBRSxPQUFPRTtJQUFHLElBQUksU0FBU0EsS0FBSyxZQUFZSSxRQUFRSixNQUFNLGNBQWMsT0FBT0EsR0FBRyxPQUFPO1FBQUUsV0FBV0E7SUFBRTtJQUFHLElBQUlHLElBQUlKLHlCQUF5Qkc7SUFBSSxJQUFJQyxLQUFLQSxFQUFFRSxHQUFHLENBQUNMLElBQUksT0FBT0csRUFBRUcsR0FBRyxDQUFDTjtJQUFJLElBQUlPLElBQUk7UUFBRUMsV0FBVztJQUFLLEdBQUdDLElBQUl6QixPQUFPQyxjQUFjLElBQUlELE9BQU8wQix3QkFBd0I7SUFBRSxJQUFLLElBQUlDLEtBQUtYLEVBQUcsSUFBSSxjQUFjVyxLQUFLLEVBQUMsR0FBRUMsY0FBYyxDQUFDQyxJQUFJLENBQUNiLEdBQUdXLElBQUk7UUFBRSxJQUFJRyxJQUFJTCxJQUFJekIsT0FBTzBCLHdCQUF3QixDQUFDVixHQUFHVyxLQUFLO1FBQU1HLEtBQU1BLENBQUFBLEVBQUVSLEdBQUcsSUFBSVEsRUFBRUMsR0FBRyxJQUFJL0IsT0FBT0MsY0FBYyxDQUFDc0IsR0FBR0ksR0FBR0csS0FBS1AsQ0FBQyxDQUFDSSxFQUFFLEdBQUdYLENBQUMsQ0FBQ1csRUFBRTtJQUFFO0lBQUUsT0FBT0osQ0FBQyxDQUFDLFVBQVUsR0FBR1AsR0FBR0csS0FBS0EsRUFBRVksR0FBRyxDQUFDZixHQUFHTyxJQUFJQTtBQUFHO0FBQ3prQixTQUFTSCxRQUFRWSxDQUFDO0lBQUk7SUFBMkIsT0FBT1osVUFBVSxjQUFjLE9BQU9hLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRSxXQUFXLEtBQUtDLFVBQVVELE1BQU1DLE9BQU9FLFNBQVMsR0FBRyxXQUFXLE9BQU9IO0lBQUcsR0FBR1osUUFBUVk7QUFBSTtBQUM3VCxTQUFTSTtJQUFhQSxXQUFXcEMsT0FBT3FDLE1BQU0sR0FBR3JDLE9BQU9xQyxNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVQyxNQUFNO1FBQUksSUFBSyxJQUFJVCxJQUFJLEdBQUdBLElBQUlVLFVBQVVDLE1BQU0sRUFBRVgsSUFBSztZQUFFLElBQUlZLFNBQVNGLFNBQVMsQ0FBQ1YsRUFBRTtZQUFFLElBQUssSUFBSWEsT0FBT0QsT0FBUTtnQkFBRSxJQUFJMUMsT0FBT21DLFNBQVMsQ0FBQ1AsY0FBYyxDQUFDQyxJQUFJLENBQUNhLFFBQVFDLE1BQU07b0JBQUVKLE1BQU0sQ0FBQ0ksSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7Z0JBQUU7WUFBRTtRQUFFO1FBQUUsT0FBT0o7SUFBUTtJQUFHLE9BQU9ILFNBQVNRLEtBQUssQ0FBQyxJQUFJLEVBQUVKO0FBQVk7QUFDbFYsU0FBU0ssZUFBZUMsR0FBRyxFQUFFaEIsQ0FBQztJQUFJLE9BQU9pQixnQkFBZ0JELFFBQVFFLHNCQUFzQkYsS0FBS2hCLE1BQU1tQiw0QkFBNEJILEtBQUtoQixNQUFNb0I7QUFBb0I7QUFDN0osU0FBU0E7SUFBcUIsTUFBTSxJQUFJQyxVQUFVO0FBQThJO0FBQ2hNLFNBQVNGLDRCQUE0QmpCLENBQUMsRUFBRW9CLE1BQU07SUFBSSxJQUFJLENBQUNwQixHQUFHO0lBQVEsSUFBSSxPQUFPQSxNQUFNLFVBQVUsT0FBT3FCLGtCQUFrQnJCLEdBQUdvQjtJQUFTLElBQUk3QixJQUFJdkIsT0FBT21DLFNBQVMsQ0FBQ21CLFFBQVEsQ0FBQ3pCLElBQUksQ0FBQ0csR0FBR3VCLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFBSSxJQUFJaEMsTUFBTSxZQUFZUyxFQUFFLFdBQVcsRUFBRVQsSUFBSVMsRUFBRSxXQUFXLENBQUN3QixJQUFJO0lBQUUsSUFBSWpDLE1BQU0sU0FBU0EsTUFBTSxPQUFPLE9BQU9rQyxNQUFNQyxJQUFJLENBQUMxQjtJQUFJLElBQUlULE1BQU0sZUFBZSwyQ0FBMkNvQyxJQUFJLENBQUNwQyxJQUFJLE9BQU84QixrQkFBa0JyQixHQUFHb0I7QUFBUztBQUMvWixTQUFTQyxrQkFBa0JQLEdBQUcsRUFBRWMsR0FBRztJQUFJLElBQUlBLE9BQU8sUUFBUUEsTUFBTWQsSUFBSUwsTUFBTSxFQUFFbUIsTUFBTWQsSUFBSUwsTUFBTTtJQUFFLElBQUssSUFBSVgsSUFBSSxHQUFHK0IsT0FBTyxJQUFJSixNQUFNRyxNQUFNOUIsSUFBSThCLEtBQUs5QixJQUFLK0IsSUFBSSxDQUFDL0IsRUFBRSxHQUFHZ0IsR0FBRyxDQUFDaEIsRUFBRTtJQUFFLE9BQU8rQjtBQUFNO0FBQ2xMLFNBQVNiLHNCQUFzQjlCLENBQUMsRUFBRTRDLENBQUM7SUFBSSxJQUFJM0MsSUFBSSxRQUFRRCxJQUFJLE9BQU8sZUFBZSxPQUFPZSxVQUFVZixDQUFDLENBQUNlLE9BQU9DLFFBQVEsQ0FBQyxJQUFJaEIsQ0FBQyxDQUFDLGFBQWE7SUFBRSxJQUFJLFFBQVFDLEdBQUc7UUFBRSxJQUFJSCxHQUFHTyxHQUFHTyxHQUFHSCxHQUFHRixJQUFJLEVBQUUsRUFBRXNDLElBQUksQ0FBQyxHQUFHL0IsSUFBSSxDQUFDO1FBQUcsSUFBSTtZQUFFLElBQUlGLElBQUksQ0FBQ1gsSUFBSUEsRUFBRVUsSUFBSSxDQUFDWCxFQUFDLEVBQUc4QyxJQUFJLEVBQUUsTUFBTUYsR0FBRztnQkFBRSxJQUFJOUQsT0FBT21CLE9BQU9BLEdBQUc7Z0JBQVE0QyxJQUFJLENBQUM7WUFBRyxPQUFPLE1BQU8sQ0FBRUEsQ0FBQUEsSUFBSSxDQUFDL0MsSUFBSWMsRUFBRUQsSUFBSSxDQUFDVixFQUFDLEVBQUc4QyxJQUFJLEtBQU14QyxDQUFBQSxFQUFFeUMsSUFBSSxDQUFDbEQsRUFBRWIsS0FBSyxHQUFHc0IsRUFBRWdCLE1BQU0sS0FBS3FCLENBQUFBLEdBQUlDLElBQUksQ0FBQztRQUFJLEVBQUUsT0FBTzdDLEdBQUc7WUFBRWMsSUFBSSxDQUFDLEdBQUdULElBQUlMO1FBQUcsU0FBVTtZQUFFLElBQUk7Z0JBQUUsSUFBSSxDQUFDNkMsS0FBSyxRQUFRNUMsQ0FBQyxDQUFDLFNBQVMsSUFBS1EsQ0FBQUEsSUFBSVIsQ0FBQyxDQUFDLFNBQVMsSUFBSW5CLE9BQU8yQixPQUFPQSxDQUFBQSxHQUFJO1lBQVEsU0FBVTtnQkFBRSxJQUFJSyxHQUFHLE1BQU1UO1lBQUc7UUFBRTtRQUFFLE9BQU9FO0lBQUc7QUFBRTtBQUN6aEIsU0FBU3NCLGdCQUFnQkQsR0FBRztJQUFJLElBQUlXLE1BQU1VLE9BQU8sQ0FBQ3JCLE1BQU0sT0FBT0E7QUFBSztBQUNwRSxTQUFTc0IsUUFBUXBELENBQUMsRUFBRUUsQ0FBQztJQUFJLElBQUlDLElBQUluQixPQUFPcUUsSUFBSSxDQUFDckQ7SUFBSSxJQUFJaEIsT0FBT3NFLHFCQUFxQixFQUFFO1FBQUUsSUFBSXRDLElBQUloQyxPQUFPc0UscUJBQXFCLENBQUN0RDtRQUFJRSxLQUFNYyxDQUFBQSxJQUFJQSxFQUFFdUMsTUFBTSxDQUFDLFNBQVVyRCxDQUFDO1lBQUksT0FBT2xCLE9BQU8wQix3QkFBd0IsQ0FBQ1YsR0FBR0UsR0FBR3NELFVBQVU7UUFBRSxFQUFDLEdBQUlyRCxFQUFFK0MsSUFBSSxDQUFDdEIsS0FBSyxDQUFDekIsR0FBR2E7SUFBSTtJQUFFLE9BQU9iO0FBQUc7QUFDOVAsU0FBU3NELGNBQWN6RCxDQUFDO0lBQUksSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUlzQixVQUFVQyxNQUFNLEVBQUV2QixJQUFLO1FBQUUsSUFBSUMsSUFBSSxRQUFRcUIsU0FBUyxDQUFDdEIsRUFBRSxHQUFHc0IsU0FBUyxDQUFDdEIsRUFBRSxHQUFHLENBQUM7UUFBR0EsSUFBSSxJQUFJa0QsUUFBUXBFLE9BQU9tQixJQUFJLENBQUMsR0FBR3VELE9BQU8sQ0FBQyxTQUFVeEQsQ0FBQztZQUFJeUQsZ0JBQWdCM0QsR0FBR0UsR0FBR0MsQ0FBQyxDQUFDRCxFQUFFO1FBQUcsS0FBS2xCLE9BQU80RSx5QkFBeUIsR0FBRzVFLE9BQU82RSxnQkFBZ0IsQ0FBQzdELEdBQUdoQixPQUFPNEUseUJBQXlCLENBQUN6RCxNQUFNaUQsUUFBUXBFLE9BQU9tQixJQUFJdUQsT0FBTyxDQUFDLFNBQVV4RCxDQUFDO1lBQUlsQixPQUFPQyxjQUFjLENBQUNlLEdBQUdFLEdBQUdsQixPQUFPMEIsd0JBQXdCLENBQUNQLEdBQUdEO1FBQUs7SUFBSTtJQUFFLE9BQU9GO0FBQUc7QUFDdGIsU0FBUzJELGdCQUFnQjlELEdBQUcsRUFBRThCLEdBQUcsRUFBRXhDLEtBQUs7SUFBSXdDLE1BQU1tQyxlQUFlbkM7SUFBTSxJQUFJQSxPQUFPOUIsS0FBSztRQUFFYixPQUFPQyxjQUFjLENBQUNZLEtBQUs4QixLQUFLO1lBQUV4QyxPQUFPQTtZQUFPcUUsWUFBWTtZQUFNTyxjQUFjO1lBQU1DLFVBQVU7UUFBSztJQUFJLE9BQU87UUFBRW5FLEdBQUcsQ0FBQzhCLElBQUksR0FBR3hDO0lBQU87SUFBRSxPQUFPVTtBQUFLO0FBQzNPLFNBQVNpRSxlQUFlM0QsQ0FBQztJQUFJLElBQUlXLElBQUltRCxhQUFhOUQsR0FBRztJQUFXLE9BQU8sWUFBWUMsUUFBUVUsS0FBS0EsSUFBSUEsSUFBSTtBQUFJO0FBQzVHLFNBQVNtRCxhQUFhOUQsQ0FBQyxFQUFFRCxDQUFDO0lBQUksSUFBSSxZQUFZRSxRQUFRRCxNQUFNLENBQUNBLEdBQUcsT0FBT0E7SUFBRyxJQUFJSCxJQUFJRyxDQUFDLENBQUNjLE9BQU9pRCxXQUFXLENBQUM7SUFBRSxJQUFJLEtBQUssTUFBTWxFLEdBQUc7UUFBRSxJQUFJYyxJQUFJZCxFQUFFYSxJQUFJLENBQUNWLEdBQUdELEtBQUs7UUFBWSxJQUFJLFlBQVlFLFFBQVFVLElBQUksT0FBT0E7UUFBRyxNQUFNLElBQUlxQixVQUFVO0lBQWlEO0lBQUUsT0FBTyxDQUFDLGFBQWFqQyxJQUFJaUUsU0FBU0MsTUFBSyxFQUFHakU7QUFBSSxFQUFFOztDQUU1VDtBQUNELElBQUlrRSxtQkFBbUIsU0FBU0EsaUJBQWlCQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLE1BQU07SUFDMUUsSUFBSUMsWUFBWUMsS0FBS0MsR0FBRyxDQUFDRCxLQUFLRSxHQUFHLENBQUNOLFNBQVMsR0FBR0ksS0FBS0UsR0FBRyxDQUFDTCxVQUFVO0lBQ2pFLElBQUlNLFFBQVFOLFVBQVUsSUFBSSxJQUFJLENBQUM7SUFDL0IsSUFBSU8sUUFBUVIsU0FBUyxJQUFJLElBQUksQ0FBQztJQUM5QixJQUFJUyxZQUFZUixVQUFVLEtBQUtELFNBQVMsS0FBS0MsU0FBUyxLQUFLRCxRQUFRLElBQUksSUFBSTtJQUMzRSxJQUFJVTtJQUNKLElBQUlQLFlBQVksS0FBS0Qsa0JBQWtCakMsT0FBTztRQUM1QyxJQUFJMEMsWUFBWTtZQUFDO1lBQUc7WUFBRztZQUFHO1NBQUU7UUFDNUIsSUFBSyxJQUFJckUsSUFBSSxHQUFHOEIsTUFBTSxHQUFHOUIsSUFBSThCLEtBQUs5QixJQUFLO1lBQ3JDcUUsU0FBUyxDQUFDckUsRUFBRSxHQUFHNEQsTUFBTSxDQUFDNUQsRUFBRSxHQUFHNkQsWUFBWUEsWUFBWUQsTUFBTSxDQUFDNUQsRUFBRTtRQUM5RDtRQUNBb0UsT0FBTyxJQUFJRSxNQUFNLENBQUNkLEdBQUcsS0FBS2MsTUFBTSxDQUFDYixJQUFJUSxRQUFRSSxTQUFTLENBQUMsRUFBRTtRQUN6RCxJQUFJQSxTQUFTLENBQUMsRUFBRSxHQUFHLEdBQUc7WUFDcEJELFFBQVEsS0FBS0UsTUFBTSxDQUFDRCxTQUFTLENBQUMsRUFBRSxFQUFFLEtBQUtDLE1BQU0sQ0FBQ0QsU0FBUyxDQUFDLEVBQUUsRUFBRSxTQUFTQyxNQUFNLENBQUNILFdBQVcsS0FBS0csTUFBTSxDQUFDZCxJQUFJVSxRQUFRRyxTQUFTLENBQUMsRUFBRSxFQUFFLEtBQUtDLE1BQU0sQ0FBQ2I7UUFDM0k7UUFDQVcsUUFBUSxLQUFLRSxNQUFNLENBQUNkLElBQUlFLFFBQVFRLFFBQVFHLFNBQVMsQ0FBQyxFQUFFLEVBQUUsS0FBS0MsTUFBTSxDQUFDYjtRQUNsRSxJQUFJWSxTQUFTLENBQUMsRUFBRSxHQUFHLEdBQUc7WUFDcEJELFFBQVEsS0FBS0UsTUFBTSxDQUFDRCxTQUFTLENBQUMsRUFBRSxFQUFFLEtBQUtDLE1BQU0sQ0FBQ0QsU0FBUyxDQUFDLEVBQUUsRUFBRSxTQUFTQyxNQUFNLENBQUNILFdBQVcsZUFBZUcsTUFBTSxDQUFDZCxJQUFJRSxPQUFPLEtBQUtZLE1BQU0sQ0FBQ2IsSUFBSVEsUUFBUUksU0FBUyxDQUFDLEVBQUU7UUFDOUo7UUFDQUQsUUFBUSxLQUFLRSxNQUFNLENBQUNkLElBQUlFLE9BQU8sS0FBS1ksTUFBTSxDQUFDYixJQUFJRSxTQUFTTSxRQUFRSSxTQUFTLENBQUMsRUFBRTtRQUM1RSxJQUFJQSxTQUFTLENBQUMsRUFBRSxHQUFHLEdBQUc7WUFDcEJELFFBQVEsS0FBS0UsTUFBTSxDQUFDRCxTQUFTLENBQUMsRUFBRSxFQUFFLEtBQUtDLE1BQU0sQ0FBQ0QsU0FBUyxDQUFDLEVBQUUsRUFBRSxTQUFTQyxNQUFNLENBQUNILFdBQVcsZUFBZUcsTUFBTSxDQUFDZCxJQUFJRSxRQUFRUSxRQUFRRyxTQUFTLENBQUMsRUFBRSxFQUFFLEtBQUtDLE1BQU0sQ0FBQ2IsSUFBSUU7UUFDaks7UUFDQVMsUUFBUSxLQUFLRSxNQUFNLENBQUNkLElBQUlVLFFBQVFHLFNBQVMsQ0FBQyxFQUFFLEVBQUUsS0FBS0MsTUFBTSxDQUFDYixJQUFJRTtRQUM5RCxJQUFJVSxTQUFTLENBQUMsRUFBRSxHQUFHLEdBQUc7WUFDcEJELFFBQVEsS0FBS0UsTUFBTSxDQUFDRCxTQUFTLENBQUMsRUFBRSxFQUFFLEtBQUtDLE1BQU0sQ0FBQ0QsU0FBUyxDQUFDLEVBQUUsRUFBRSxTQUFTQyxNQUFNLENBQUNILFdBQVcsZUFBZUcsTUFBTSxDQUFDZCxHQUFHLEtBQUtjLE1BQU0sQ0FBQ2IsSUFBSUUsU0FBU00sUUFBUUksU0FBUyxDQUFDLEVBQUU7UUFDL0o7UUFDQUQsUUFBUTtJQUNWLE9BQU8sSUFBSVAsWUFBWSxLQUFLRCxXQUFXLENBQUNBLFVBQVVBLFNBQVMsR0FBRztRQUM1RCxJQUFJVyxhQUFhVCxLQUFLQyxHQUFHLENBQUNGLFdBQVdEO1FBQ3JDUSxPQUFPLEtBQUtFLE1BQU0sQ0FBQ2QsR0FBRyxLQUFLYyxNQUFNLENBQUNiLElBQUlRLFFBQVFNLFlBQVksb0JBQW9CRCxNQUFNLENBQUNDLFlBQVksS0FBS0QsTUFBTSxDQUFDQyxZQUFZLFNBQVNELE1BQU0sQ0FBQ0gsV0FBVyxLQUFLRyxNQUFNLENBQUNkLElBQUlVLFFBQVFLLFlBQVksS0FBS0QsTUFBTSxDQUFDYixHQUFHLG9CQUFvQmEsTUFBTSxDQUFDZCxJQUFJRSxRQUFRUSxRQUFRSyxZQUFZLEtBQUtELE1BQU0sQ0FBQ2IsR0FBRyxvQkFBb0JhLE1BQU0sQ0FBQ0MsWUFBWSxLQUFLRCxNQUFNLENBQUNDLFlBQVksU0FBU0QsTUFBTSxDQUFDSCxXQUFXLEtBQUtHLE1BQU0sQ0FBQ2QsSUFBSUUsT0FBTyxLQUFLWSxNQUFNLENBQUNiLElBQUlRLFFBQVFNLFlBQVksb0JBQW9CRCxNQUFNLENBQUNkLElBQUlFLE9BQU8sS0FBS1ksTUFBTSxDQUFDYixJQUFJRSxTQUFTTSxRQUFRTSxZQUFZLG9CQUFvQkQsTUFBTSxDQUFDQyxZQUFZLEtBQUtELE1BQU0sQ0FBQ0MsWUFBWSxTQUFTRCxNQUFNLENBQUNILFdBQVcsS0FBS0csTUFBTSxDQUFDZCxJQUFJRSxRQUFRUSxRQUFRSyxZQUFZLEtBQUtELE1BQU0sQ0FBQ2IsSUFBSUUsUUFBUSxvQkFBb0JXLE1BQU0sQ0FBQ2QsSUFBSVUsUUFBUUssWUFBWSxLQUFLRCxNQUFNLENBQUNiLElBQUlFLFFBQVEsb0JBQW9CVyxNQUFNLENBQUNDLFlBQVksS0FBS0QsTUFBTSxDQUFDQyxZQUFZLFNBQVNELE1BQU0sQ0FBQ0gsV0FBVyxLQUFLRyxNQUFNLENBQUNkLEdBQUcsS0FBS2MsTUFBTSxDQUFDYixJQUFJRSxTQUFTTSxRQUFRTSxZQUFZO0lBQzEzQixPQUFPO1FBQ0xILE9BQU8sS0FBS0UsTUFBTSxDQUFDZCxHQUFHLEtBQUtjLE1BQU0sQ0FBQ2IsR0FBRyxPQUFPYSxNQUFNLENBQUNaLE9BQU8sT0FBT1ksTUFBTSxDQUFDWCxRQUFRLE9BQU9XLE1BQU0sQ0FBQyxDQUFDWixPQUFPO0lBQ3hHO0lBQ0EsT0FBT1U7QUFDVDtBQUNBLElBQUk5RixnQkFBZ0JGLHFCQUFxQixHQUFHLFNBQVNFLGNBQWNrRyxLQUFLLEVBQUVDLElBQUk7SUFDNUUsSUFBSSxDQUFDRCxTQUFTLENBQUNDLE1BQU07UUFDbkIsT0FBTztJQUNUO0lBQ0EsSUFBSUMsS0FBS0YsTUFBTWhCLENBQUMsRUFDZG1CLEtBQUtILE1BQU1mLENBQUM7SUFDZCxJQUFJRCxJQUFJaUIsS0FBS2pCLENBQUMsRUFDWkMsSUFBSWdCLEtBQUtoQixDQUFDLEVBQ1ZDLFFBQVFlLEtBQUtmLEtBQUssRUFDbEJDLFNBQVNjLEtBQUtkLE1BQU07SUFDdEIsSUFBSUcsS0FBS0UsR0FBRyxDQUFDTixTQUFTLEtBQUtJLEtBQUtFLEdBQUcsQ0FBQ0wsVUFBVSxHQUFHO1FBQy9DLElBQUlpQixPQUFPZCxLQUFLQyxHQUFHLENBQUNQLEdBQUdBLElBQUlFO1FBQzNCLElBQUltQixPQUFPZixLQUFLZ0IsR0FBRyxDQUFDdEIsR0FBR0EsSUFBSUU7UUFDM0IsSUFBSXFCLE9BQU9qQixLQUFLQyxHQUFHLENBQUNOLEdBQUdBLElBQUlFO1FBQzNCLElBQUlxQixPQUFPbEIsS0FBS2dCLEdBQUcsQ0FBQ3JCLEdBQUdBLElBQUlFO1FBQzNCLE9BQU9lLE1BQU1FLFFBQVFGLE1BQU1HLFFBQVFGLE1BQU1JLFFBQVFKLE1BQU1LO0lBQ3pEO0lBQ0EsT0FBTztBQUNUO0FBQ0EsSUFBSUMsZUFBZTtJQUNqQnpCLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxPQUFPO0lBQ1BDLFFBQVE7SUFDUix1QkFBdUI7SUFDdkIscURBQXFEO0lBQ3JELHVGQUF1RjtJQUN2RkMsUUFBUTtJQUNSc0IsbUJBQW1CO0lBQ25CQyx5QkFBeUI7SUFDekJDLGdCQUFnQjtJQUNoQkMsbUJBQW1CO0lBQ25CQyxpQkFBaUI7QUFDbkI7QUFDQSxJQUFJL0csWUFBWUgsaUJBQWlCLEdBQUcsU0FBU0csVUFBVWdILGNBQWM7SUFDbkUsSUFBSUMsUUFBUTdDLGNBQWNBLGNBQWMsQ0FBQyxHQUFHc0MsZUFBZU07SUFDM0QsSUFBSUUsVUFBVSxDQUFDLEdBQUdqSCxPQUFPa0gsTUFBTTtJQUMvQixJQUFJQyxZQUFZLENBQUMsR0FBR25ILE9BQU9vSCxRQUFRLEVBQUUsQ0FBQyxJQUNwQ0MsYUFBYTlFLGVBQWU0RSxXQUFXLElBQ3ZDRyxjQUFjRCxVQUFVLENBQUMsRUFBRSxFQUMzQkUsaUJBQWlCRixVQUFVLENBQUMsRUFBRTtJQUMvQixJQUFHckgsT0FBT3dILFNBQVMsRUFBRTtRQUNwQixJQUFJUCxRQUFRUSxPQUFPLElBQUlSLFFBQVFRLE9BQU8sQ0FBQ0MsY0FBYyxFQUFFO1lBQ3JELElBQUk7Z0JBQ0YsSUFBSUMsa0JBQWtCVixRQUFRUSxPQUFPLENBQUNDLGNBQWM7Z0JBQ3BELElBQUlDLGlCQUFpQjtvQkFDbkJKLGVBQWVJO2dCQUNqQjtZQUNGLEVBQUUsT0FBT0MsS0FBSztZQUNaLCtCQUErQjtZQUNqQztRQUNGO0lBQ0YsR0FBRyxFQUFFO0lBQ0wsSUFBSTVDLElBQUlnQyxNQUFNaEMsQ0FBQyxFQUNiQyxJQUFJK0IsTUFBTS9CLENBQUMsRUFDWEMsUUFBUThCLE1BQU05QixLQUFLLEVBQ25CQyxTQUFTNkIsTUFBTTdCLE1BQU0sRUFDckJDLFNBQVM0QixNQUFNNUIsTUFBTSxFQUNyQnlDLFlBQVliLE1BQU1hLFNBQVM7SUFDN0IsSUFBSWYsa0JBQWtCRSxNQUFNRixlQUFlLEVBQ3pDRCxvQkFBb0JHLE1BQU1ILGlCQUFpQixFQUMzQ0QsaUJBQWlCSSxNQUFNSixjQUFjLEVBQ3JDRixvQkFBb0JNLE1BQU1OLGlCQUFpQixFQUMzQ0MsMEJBQTBCSyxNQUFNTCx1QkFBdUI7SUFDekQsSUFBSTNCLE1BQU0sQ0FBQ0EsS0FBS0MsTUFBTSxDQUFDQSxLQUFLQyxVQUFVLENBQUNBLFNBQVNDLFdBQVcsQ0FBQ0EsVUFBVUQsVUFBVSxLQUFLQyxXQUFXLEdBQUc7UUFDakcsT0FBTztJQUNUO0lBQ0EsSUFBSTJDLGFBQWEsQ0FBQyxHQUFHM0gsS0FBSyxDQUFDLFVBQVUsRUFBRSxzQkFBc0IwSDtJQUM3RCxJQUFJLENBQUNsQix5QkFBeUI7UUFDNUIsT0FBTyxXQUFXLEdBQUUzRyxNQUFNLENBQUMsVUFBVSxDQUFDK0gsYUFBYSxDQUFDLFFBQVFqRyxTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUd4QixZQUFZMEgsV0FBVyxFQUFFaEIsT0FBTyxPQUFPO1lBQ2xIYSxXQUFXQztZQUNYRyxHQUFHbEQsaUJBQWlCQyxHQUFHQyxHQUFHQyxPQUFPQyxRQUFRQztRQUMzQztJQUNGO0lBQ0EsT0FBTyxXQUFXLEdBQUVwRixNQUFNLENBQUMsVUFBVSxDQUFDK0gsYUFBYSxDQUFDMUgsWUFBWSxDQUFDLFVBQVUsRUFBRTtRQUMzRTZILFVBQVVaLGNBQWM7UUFDeEJsRSxNQUFNO1lBQ0o4QixPQUFPQTtZQUNQQyxRQUFRQTtZQUNSSCxHQUFHQTtZQUNIQyxHQUFHQTtRQUNMO1FBQ0FrRCxJQUFJO1lBQ0ZqRCxPQUFPQTtZQUNQQyxRQUFRQTtZQUNSSCxHQUFHQTtZQUNIQyxHQUFHQTtRQUNMO1FBQ0FtRCxVQUFVdkI7UUFDVkMsaUJBQWlCQTtRQUNqQnVCLFVBQVUxQjtJQUNaLEdBQUcsU0FBVTJCLElBQUk7UUFDZixJQUFJQyxZQUFZRCxLQUFLcEQsS0FBSyxFQUN4QnNELGFBQWFGLEtBQUtuRCxNQUFNLEVBQ3hCc0QsUUFBUUgsS0FBS3RELENBQUMsRUFDZDBELFFBQVFKLEtBQUtyRCxDQUFDO1FBQ2hCLE9BQU8sV0FBVyxHQUFFakYsTUFBTSxDQUFDLFVBQVUsQ0FBQytILGFBQWEsQ0FBQzFILFlBQVksQ0FBQyxVQUFVLEVBQUU7WUFDM0U2SCxVQUFVWixjQUFjO1lBQ3hCbEUsTUFBTSxPQUFPMEMsTUFBTSxDQUFDd0IsZ0JBQWdCLENBQUMsSUFBSSxJQUFJQSxhQUFhO1lBQzFEYSxJQUFJLEdBQUdyQyxNQUFNLENBQUN3QixhQUFhO1lBQzNCcUIsZUFBZTtZQUNmQyxPQUFPaEM7WUFDUHdCLFVBQVV2QjtZQUNWd0IsVUFBVTNCO1lBQ1ZtQyxRQUFRL0I7UUFDVixHQUFHLFdBQVcsR0FBRTlHLE1BQU0sQ0FBQyxVQUFVLENBQUMrSCxhQUFhLENBQUMsUUFBUWpHLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBR3hCLFlBQVkwSCxXQUFXLEVBQUVoQixPQUFPLE9BQU87WUFDOUdhLFdBQVdDO1lBQ1hHLEdBQUdsRCxpQkFBaUIwRCxPQUFPQyxPQUFPSCxXQUFXQyxZQUFZcEQ7WUFDekQwRCxLQUFLN0I7UUFDUDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXHNoYXBlXFxSZWN0YW5nbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5pc0luUmVjdGFuZ2xlID0gZXhwb3J0cy5SZWN0YW5nbGUgPSB2b2lkIDA7XHJcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcclxudmFyIF9yZWFjdFNtb290aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0LXNtb290aFwiKSk7XHJcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxyXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxyXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XHJcbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxyXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxyXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cclxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XHJcbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cclxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH0gLyoqXHJcbiAqIEBmaWxlT3ZlcnZpZXcgUmVjdGFuZ2xlXHJcbiAqL1xyXG52YXIgZ2V0UmVjdGFuZ2xlUGF0aCA9IGZ1bmN0aW9uIGdldFJlY3RhbmdsZVBhdGgoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XHJcbiAgdmFyIG1heFJhZGl1cyA9IE1hdGgubWluKE1hdGguYWJzKHdpZHRoKSAvIDIsIE1hdGguYWJzKGhlaWdodCkgLyAyKTtcclxuICB2YXIgeVNpZ24gPSBoZWlnaHQgPj0gMCA/IDEgOiAtMTtcclxuICB2YXIgeFNpZ24gPSB3aWR0aCA+PSAwID8gMSA6IC0xO1xyXG4gIHZhciBjbG9ja1dpc2UgPSBoZWlnaHQgPj0gMCAmJiB3aWR0aCA+PSAwIHx8IGhlaWdodCA8IDAgJiYgd2lkdGggPCAwID8gMSA6IDA7XHJcbiAgdmFyIHBhdGg7XHJcbiAgaWYgKG1heFJhZGl1cyA+IDAgJiYgcmFkaXVzIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgIHZhciBuZXdSYWRpdXMgPSBbMCwgMCwgMCwgMF07XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gNDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIG5ld1JhZGl1c1tpXSA9IHJhZGl1c1tpXSA+IG1heFJhZGl1cyA/IG1heFJhZGl1cyA6IHJhZGl1c1tpXTtcclxuICAgIH1cclxuICAgIHBhdGggPSBcIk1cIi5jb25jYXQoeCwgXCIsXCIpLmNvbmNhdCh5ICsgeVNpZ24gKiBuZXdSYWRpdXNbMF0pO1xyXG4gICAgaWYgKG5ld1JhZGl1c1swXSA+IDApIHtcclxuICAgICAgcGF0aCArPSBcIkEgXCIuY29uY2F0KG5ld1JhZGl1c1swXSwgXCIsXCIpLmNvbmNhdChuZXdSYWRpdXNbMF0sIFwiLDAsMCxcIikuY29uY2F0KGNsb2NrV2lzZSwgXCIsXCIpLmNvbmNhdCh4ICsgeFNpZ24gKiBuZXdSYWRpdXNbMF0sIFwiLFwiKS5jb25jYXQoeSk7XHJcbiAgICB9XHJcbiAgICBwYXRoICs9IFwiTCBcIi5jb25jYXQoeCArIHdpZHRoIC0geFNpZ24gKiBuZXdSYWRpdXNbMV0sIFwiLFwiKS5jb25jYXQoeSk7XHJcbiAgICBpZiAobmV3UmFkaXVzWzFdID4gMCkge1xyXG4gICAgICBwYXRoICs9IFwiQSBcIi5jb25jYXQobmV3UmFkaXVzWzFdLCBcIixcIikuY29uY2F0KG5ld1JhZGl1c1sxXSwgXCIsMCwwLFwiKS5jb25jYXQoY2xvY2tXaXNlLCBcIixcXG4gICAgICAgIFwiKS5jb25jYXQoeCArIHdpZHRoLCBcIixcIikuY29uY2F0KHkgKyB5U2lnbiAqIG5ld1JhZGl1c1sxXSk7XHJcbiAgICB9XHJcbiAgICBwYXRoICs9IFwiTCBcIi5jb25jYXQoeCArIHdpZHRoLCBcIixcIikuY29uY2F0KHkgKyBoZWlnaHQgLSB5U2lnbiAqIG5ld1JhZGl1c1syXSk7XHJcbiAgICBpZiAobmV3UmFkaXVzWzJdID4gMCkge1xyXG4gICAgICBwYXRoICs9IFwiQSBcIi5jb25jYXQobmV3UmFkaXVzWzJdLCBcIixcIikuY29uY2F0KG5ld1JhZGl1c1syXSwgXCIsMCwwLFwiKS5jb25jYXQoY2xvY2tXaXNlLCBcIixcXG4gICAgICAgIFwiKS5jb25jYXQoeCArIHdpZHRoIC0geFNpZ24gKiBuZXdSYWRpdXNbMl0sIFwiLFwiKS5jb25jYXQoeSArIGhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBwYXRoICs9IFwiTCBcIi5jb25jYXQoeCArIHhTaWduICogbmV3UmFkaXVzWzNdLCBcIixcIikuY29uY2F0KHkgKyBoZWlnaHQpO1xyXG4gICAgaWYgKG5ld1JhZGl1c1szXSA+IDApIHtcclxuICAgICAgcGF0aCArPSBcIkEgXCIuY29uY2F0KG5ld1JhZGl1c1szXSwgXCIsXCIpLmNvbmNhdChuZXdSYWRpdXNbM10sIFwiLDAsMCxcIikuY29uY2F0KGNsb2NrV2lzZSwgXCIsXFxuICAgICAgICBcIikuY29uY2F0KHgsIFwiLFwiKS5jb25jYXQoeSArIGhlaWdodCAtIHlTaWduICogbmV3UmFkaXVzWzNdKTtcclxuICAgIH1cclxuICAgIHBhdGggKz0gJ1onO1xyXG4gIH0gZWxzZSBpZiAobWF4UmFkaXVzID4gMCAmJiByYWRpdXMgPT09ICtyYWRpdXMgJiYgcmFkaXVzID4gMCkge1xyXG4gICAgdmFyIF9uZXdSYWRpdXMgPSBNYXRoLm1pbihtYXhSYWRpdXMsIHJhZGl1cyk7XHJcbiAgICBwYXRoID0gXCJNIFwiLmNvbmNhdCh4LCBcIixcIikuY29uY2F0KHkgKyB5U2lnbiAqIF9uZXdSYWRpdXMsIFwiXFxuICAgICAgICAgICAgQSBcIikuY29uY2F0KF9uZXdSYWRpdXMsIFwiLFwiKS5jb25jYXQoX25ld1JhZGl1cywgXCIsMCwwLFwiKS5jb25jYXQoY2xvY2tXaXNlLCBcIixcIikuY29uY2F0KHggKyB4U2lnbiAqIF9uZXdSYWRpdXMsIFwiLFwiKS5jb25jYXQoeSwgXCJcXG4gICAgICAgICAgICBMIFwiKS5jb25jYXQoeCArIHdpZHRoIC0geFNpZ24gKiBfbmV3UmFkaXVzLCBcIixcIikuY29uY2F0KHksIFwiXFxuICAgICAgICAgICAgQSBcIikuY29uY2F0KF9uZXdSYWRpdXMsIFwiLFwiKS5jb25jYXQoX25ld1JhZGl1cywgXCIsMCwwLFwiKS5jb25jYXQoY2xvY2tXaXNlLCBcIixcIikuY29uY2F0KHggKyB3aWR0aCwgXCIsXCIpLmNvbmNhdCh5ICsgeVNpZ24gKiBfbmV3UmFkaXVzLCBcIlxcbiAgICAgICAgICAgIEwgXCIpLmNvbmNhdCh4ICsgd2lkdGgsIFwiLFwiKS5jb25jYXQoeSArIGhlaWdodCAtIHlTaWduICogX25ld1JhZGl1cywgXCJcXG4gICAgICAgICAgICBBIFwiKS5jb25jYXQoX25ld1JhZGl1cywgXCIsXCIpLmNvbmNhdChfbmV3UmFkaXVzLCBcIiwwLDAsXCIpLmNvbmNhdChjbG9ja1dpc2UsIFwiLFwiKS5jb25jYXQoeCArIHdpZHRoIC0geFNpZ24gKiBfbmV3UmFkaXVzLCBcIixcIikuY29uY2F0KHkgKyBoZWlnaHQsIFwiXFxuICAgICAgICAgICAgTCBcIikuY29uY2F0KHggKyB4U2lnbiAqIF9uZXdSYWRpdXMsIFwiLFwiKS5jb25jYXQoeSArIGhlaWdodCwgXCJcXG4gICAgICAgICAgICBBIFwiKS5jb25jYXQoX25ld1JhZGl1cywgXCIsXCIpLmNvbmNhdChfbmV3UmFkaXVzLCBcIiwwLDAsXCIpLmNvbmNhdChjbG9ja1dpc2UsIFwiLFwiKS5jb25jYXQoeCwgXCIsXCIpLmNvbmNhdCh5ICsgaGVpZ2h0IC0geVNpZ24gKiBfbmV3UmFkaXVzLCBcIiBaXCIpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBwYXRoID0gXCJNIFwiLmNvbmNhdCh4LCBcIixcIikuY29uY2F0KHksIFwiIGggXCIpLmNvbmNhdCh3aWR0aCwgXCIgdiBcIikuY29uY2F0KGhlaWdodCwgXCIgaCBcIikuY29uY2F0KC13aWR0aCwgXCIgWlwiKTtcclxuICB9XHJcbiAgcmV0dXJuIHBhdGg7XHJcbn07XHJcbnZhciBpc0luUmVjdGFuZ2xlID0gZXhwb3J0cy5pc0luUmVjdGFuZ2xlID0gZnVuY3Rpb24gaXNJblJlY3RhbmdsZShwb2ludCwgcmVjdCkge1xyXG4gIGlmICghcG9pbnQgfHwgIXJlY3QpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgdmFyIHB4ID0gcG9pbnQueCxcclxuICAgIHB5ID0gcG9pbnQueTtcclxuICB2YXIgeCA9IHJlY3QueCxcclxuICAgIHkgPSByZWN0LnksXHJcbiAgICB3aWR0aCA9IHJlY3Qud2lkdGgsXHJcbiAgICBoZWlnaHQgPSByZWN0LmhlaWdodDtcclxuICBpZiAoTWF0aC5hYnMod2lkdGgpID4gMCAmJiBNYXRoLmFicyhoZWlnaHQpID4gMCkge1xyXG4gICAgdmFyIG1pblggPSBNYXRoLm1pbih4LCB4ICsgd2lkdGgpO1xyXG4gICAgdmFyIG1heFggPSBNYXRoLm1heCh4LCB4ICsgd2lkdGgpO1xyXG4gICAgdmFyIG1pblkgPSBNYXRoLm1pbih5LCB5ICsgaGVpZ2h0KTtcclxuICAgIHZhciBtYXhZID0gTWF0aC5tYXgoeSwgeSArIGhlaWdodCk7XHJcbiAgICByZXR1cm4gcHggPj0gbWluWCAmJiBweCA8PSBtYXhYICYmIHB5ID49IG1pblkgJiYgcHkgPD0gbWF4WTtcclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG52YXIgZGVmYXVsdFByb3BzID0ge1xyXG4gIHg6IDAsXHJcbiAgeTogMCxcclxuICB3aWR0aDogMCxcclxuICBoZWlnaHQ6IDAsXHJcbiAgLy8gVGhlIHJhZGl1cyBvZiBib3JkZXJcclxuICAvLyBUaGUgcmFkaXVzIG9mIGZvdXIgY29ybmVycyB3aGVuIHJhZGl1cyBpcyBhIG51bWJlclxyXG4gIC8vIFRoZSByYWRpdXMgb2YgbGVmdC10b3AsIHJpZ2h0LXRvcCwgcmlnaHQtYm90dG9tLCBsZWZ0LWJvdHRvbSB3aGVuIHJhZGl1cyBpcyBhbiBhcnJheVxyXG4gIHJhZGl1czogMCxcclxuICBpc0FuaW1hdGlvbkFjdGl2ZTogZmFsc2UsXHJcbiAgaXNVcGRhdGVBbmltYXRpb25BY3RpdmU6IGZhbHNlLFxyXG4gIGFuaW1hdGlvbkJlZ2luOiAwLFxyXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiAxNTAwLFxyXG4gIGFuaW1hdGlvbkVhc2luZzogJ2Vhc2UnXHJcbn07XHJcbnZhciBSZWN0YW5nbGUgPSBleHBvcnRzLlJlY3RhbmdsZSA9IGZ1bmN0aW9uIFJlY3RhbmdsZShyZWN0YW5nbGVQcm9wcykge1xyXG4gIHZhciBwcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdFByb3BzKSwgcmVjdGFuZ2xlUHJvcHMpO1xyXG4gIHZhciBwYXRoUmVmID0gKDAsIF9yZWFjdC51c2VSZWYpKCk7XHJcbiAgdmFyIF91c2VTdGF0ZSA9ICgwLCBfcmVhY3QudXNlU3RhdGUpKC0xKSxcclxuICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxyXG4gICAgdG90YWxMZW5ndGggPSBfdXNlU3RhdGUyWzBdLFxyXG4gICAgc2V0VG90YWxMZW5ndGggPSBfdXNlU3RhdGUyWzFdO1xyXG4gICgwLCBfcmVhY3QudXNlRWZmZWN0KShmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAocGF0aFJlZi5jdXJyZW50ICYmIHBhdGhSZWYuY3VycmVudC5nZXRUb3RhbExlbmd0aCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHZhciBwYXRoVG90YWxMZW5ndGggPSBwYXRoUmVmLmN1cnJlbnQuZ2V0VG90YWxMZW5ndGgoKTtcclxuICAgICAgICBpZiAocGF0aFRvdGFsTGVuZ3RoKSB7XHJcbiAgICAgICAgICBzZXRUb3RhbExlbmd0aChwYXRoVG90YWxMZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRvdGFsIGxlbmd0aCBlcnJvclxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW10pO1xyXG4gIHZhciB4ID0gcHJvcHMueCxcclxuICAgIHkgPSBwcm9wcy55LFxyXG4gICAgd2lkdGggPSBwcm9wcy53aWR0aCxcclxuICAgIGhlaWdodCA9IHByb3BzLmhlaWdodCxcclxuICAgIHJhZGl1cyA9IHByb3BzLnJhZGl1cyxcclxuICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZTtcclxuICB2YXIgYW5pbWF0aW9uRWFzaW5nID0gcHJvcHMuYW5pbWF0aW9uRWFzaW5nLFxyXG4gICAgYW5pbWF0aW9uRHVyYXRpb24gPSBwcm9wcy5hbmltYXRpb25EdXJhdGlvbixcclxuICAgIGFuaW1hdGlvbkJlZ2luID0gcHJvcHMuYW5pbWF0aW9uQmVnaW4sXHJcbiAgICBpc0FuaW1hdGlvbkFjdGl2ZSA9IHByb3BzLmlzQW5pbWF0aW9uQWN0aXZlLFxyXG4gICAgaXNVcGRhdGVBbmltYXRpb25BY3RpdmUgPSBwcm9wcy5pc1VwZGF0ZUFuaW1hdGlvbkFjdGl2ZTtcclxuICBpZiAoeCAhPT0gK3ggfHwgeSAhPT0gK3kgfHwgd2lkdGggIT09ICt3aWR0aCB8fCBoZWlnaHQgIT09ICtoZWlnaHQgfHwgd2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgdmFyIGxheWVyQ2xhc3MgPSAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtcmVjdGFuZ2xlJywgY2xhc3NOYW1lKTtcclxuICBpZiAoIWlzVXBkYXRlQW5pbWF0aW9uQWN0aXZlKSB7XHJcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInBhdGhcIiwgX2V4dGVuZHMoe30sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykocHJvcHMsIHRydWUpLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogbGF5ZXJDbGFzcyxcclxuICAgICAgZDogZ2V0UmVjdGFuZ2xlUGF0aCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpXHJcbiAgICB9KSk7XHJcbiAgfVxyXG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9yZWFjdFNtb290aFtcImRlZmF1bHRcIl0sIHtcclxuICAgIGNhbkJlZ2luOiB0b3RhbExlbmd0aCA+IDAsXHJcbiAgICBmcm9tOiB7XHJcbiAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgIHg6IHgsXHJcbiAgICAgIHk6IHlcclxuICAgIH0sXHJcbiAgICB0bzoge1xyXG4gICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICB4OiB4LFxyXG4gICAgICB5OiB5XHJcbiAgICB9LFxyXG4gICAgZHVyYXRpb246IGFuaW1hdGlvbkR1cmF0aW9uLFxyXG4gICAgYW5pbWF0aW9uRWFzaW5nOiBhbmltYXRpb25FYXNpbmcsXHJcbiAgICBpc0FjdGl2ZTogaXNVcGRhdGVBbmltYXRpb25BY3RpdmVcclxuICB9LCBmdW5jdGlvbiAoX3JlZikge1xyXG4gICAgdmFyIGN1cnJXaWR0aCA9IF9yZWYud2lkdGgsXHJcbiAgICAgIGN1cnJIZWlnaHQgPSBfcmVmLmhlaWdodCxcclxuICAgICAgY3VyclggPSBfcmVmLngsXHJcbiAgICAgIGN1cnJZID0gX3JlZi55O1xyXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX3JlYWN0U21vb3RoW1wiZGVmYXVsdFwiXSwge1xyXG4gICAgICBjYW5CZWdpbjogdG90YWxMZW5ndGggPiAwLFxyXG4gICAgICBmcm9tOiBcIjBweCBcIi5jb25jYXQodG90YWxMZW5ndGggPT09IC0xID8gMSA6IHRvdGFsTGVuZ3RoLCBcInB4XCIpLFxyXG4gICAgICB0bzogXCJcIi5jb25jYXQodG90YWxMZW5ndGgsIFwicHggMHB4XCIpLFxyXG4gICAgICBhdHRyaWJ1dGVOYW1lOiBcInN0cm9rZURhc2hhcnJheVwiLFxyXG4gICAgICBiZWdpbjogYW5pbWF0aW9uQmVnaW4sXHJcbiAgICAgIGR1cmF0aW9uOiBhbmltYXRpb25EdXJhdGlvbixcclxuICAgICAgaXNBY3RpdmU6IGlzQW5pbWF0aW9uQWN0aXZlLFxyXG4gICAgICBlYXNpbmc6IGFuaW1hdGlvbkVhc2luZ1xyXG4gICAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInBhdGhcIiwgX2V4dGVuZHMoe30sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykocHJvcHMsIHRydWUpLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogbGF5ZXJDbGFzcyxcclxuICAgICAgZDogZ2V0UmVjdGFuZ2xlUGF0aChjdXJyWCwgY3VyclksIGN1cnJXaWR0aCwgY3VyckhlaWdodCwgcmFkaXVzKSxcclxuICAgICAgcmVmOiBwYXRoUmVmXHJcbiAgICB9KSkpO1xyXG4gIH0pO1xyXG59OyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImlzSW5SZWN0YW5nbGUiLCJSZWN0YW5nbGUiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfY2xzeCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfcmVhY3RTbW9vdGgiLCJfUmVhY3RVdGlscyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX3R5cGVvZiIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJhcHBseSIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIlR5cGVFcnJvciIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwibGVuIiwiYXJyMiIsImwiLCJmIiwibmV4dCIsImRvbmUiLCJwdXNoIiwiaXNBcnJheSIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZW51bWVyYWJsZSIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJnZXRSZWN0YW5nbGVQYXRoIiwieCIsInkiLCJ3aWR0aCIsImhlaWdodCIsInJhZGl1cyIsIm1heFJhZGl1cyIsIk1hdGgiLCJtaW4iLCJhYnMiLCJ5U2lnbiIsInhTaWduIiwiY2xvY2tXaXNlIiwicGF0aCIsIm5ld1JhZGl1cyIsImNvbmNhdCIsIl9uZXdSYWRpdXMiLCJwb2ludCIsInJlY3QiLCJweCIsInB5IiwibWluWCIsIm1heFgiLCJtYXgiLCJtaW5ZIiwibWF4WSIsImRlZmF1bHRQcm9wcyIsImlzQW5pbWF0aW9uQWN0aXZlIiwiaXNVcGRhdGVBbmltYXRpb25BY3RpdmUiLCJhbmltYXRpb25CZWdpbiIsImFuaW1hdGlvbkR1cmF0aW9uIiwiYW5pbWF0aW9uRWFzaW5nIiwicmVjdGFuZ2xlUHJvcHMiLCJwcm9wcyIsInBhdGhSZWYiLCJ1c2VSZWYiLCJfdXNlU3RhdGUiLCJ1c2VTdGF0ZSIsIl91c2VTdGF0ZTIiLCJ0b3RhbExlbmd0aCIsInNldFRvdGFsTGVuZ3RoIiwidXNlRWZmZWN0IiwiY3VycmVudCIsImdldFRvdGFsTGVuZ3RoIiwicGF0aFRvdGFsTGVuZ3RoIiwiZXJyIiwiY2xhc3NOYW1lIiwibGF5ZXJDbGFzcyIsImNyZWF0ZUVsZW1lbnQiLCJmaWx0ZXJQcm9wcyIsImQiLCJjYW5CZWdpbiIsInRvIiwiZHVyYXRpb24iLCJpc0FjdGl2ZSIsIl9yZWYiLCJjdXJyV2lkdGgiLCJjdXJySGVpZ2h0IiwiY3VyclgiLCJjdXJyWSIsImF0dHJpYnV0ZU5hbWUiLCJiZWdpbiIsImVhc2luZyIsInJlZiJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/shape/Rectangle.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/shape/Sector.js":
/*!***************************************************!*\
  !*** ./node_modules/recharts/lib/shape/Sector.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Sector = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Sector\r\n */ \nvar getDeltaAngle = function getDeltaAngle(startAngle, endAngle) {\n    var sign = (0, _DataUtils.mathSign)(endAngle - startAngle);\n    var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 359.999);\n    return sign * deltaAngle;\n};\nvar getTangentCircle = function getTangentCircle(_ref) {\n    var cx = _ref.cx, cy = _ref.cy, radius = _ref.radius, angle = _ref.angle, sign = _ref.sign, isExternal = _ref.isExternal, cornerRadius = _ref.cornerRadius, cornerIsExternal = _ref.cornerIsExternal;\n    var centerRadius = cornerRadius * (isExternal ? 1 : -1) + radius;\n    var theta = Math.asin(cornerRadius / centerRadius) / _PolarUtils.RADIAN;\n    var centerAngle = cornerIsExternal ? angle : angle + sign * theta;\n    var center = (0, _PolarUtils.polarToCartesian)(cx, cy, centerRadius, centerAngle);\n    // The coordinate of point which is tangent to the circle\n    var circleTangency = (0, _PolarUtils.polarToCartesian)(cx, cy, radius, centerAngle);\n    // The coordinate of point which is tangent to the radius line\n    var lineTangencyAngle = cornerIsExternal ? angle - sign * theta : angle;\n    var lineTangency = (0, _PolarUtils.polarToCartesian)(cx, cy, centerRadius * Math.cos(theta * _PolarUtils.RADIAN), lineTangencyAngle);\n    return {\n        center: center,\n        circleTangency: circleTangency,\n        lineTangency: lineTangency,\n        theta: theta\n    };\n};\nvar getSectorPath = function getSectorPath(_ref2) {\n    var cx = _ref2.cx, cy = _ref2.cy, innerRadius = _ref2.innerRadius, outerRadius = _ref2.outerRadius, startAngle = _ref2.startAngle, endAngle = _ref2.endAngle;\n    var angle = getDeltaAngle(startAngle, endAngle);\n    // When the angle of sector equals to 360, star point and end point coincide\n    var tempEndAngle = startAngle + angle;\n    var outerStartPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, outerRadius, startAngle);\n    var outerEndPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, outerRadius, tempEndAngle);\n    var path = \"M \".concat(outerStartPoint.x, \",\").concat(outerStartPoint.y, \"\\n    A \").concat(outerRadius, \",\").concat(outerRadius, \",0,\\n    \").concat(+(Math.abs(angle) > 180), \",\").concat(+(startAngle > tempEndAngle), \",\\n    \").concat(outerEndPoint.x, \",\").concat(outerEndPoint.y, \"\\n  \");\n    if (innerRadius > 0) {\n        var innerStartPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, innerRadius, startAngle);\n        var innerEndPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, innerRadius, tempEndAngle);\n        path += \"L \".concat(innerEndPoint.x, \",\").concat(innerEndPoint.y, \"\\n            A \").concat(innerRadius, \",\").concat(innerRadius, \",0,\\n            \").concat(+(Math.abs(angle) > 180), \",\").concat(+(startAngle <= tempEndAngle), \",\\n            \").concat(innerStartPoint.x, \",\").concat(innerStartPoint.y, \" Z\");\n    } else {\n        path += \"L \".concat(cx, \",\").concat(cy, \" Z\");\n    }\n    return path;\n};\nvar getSectorWithCorner = function getSectorWithCorner(_ref3) {\n    var cx = _ref3.cx, cy = _ref3.cy, innerRadius = _ref3.innerRadius, outerRadius = _ref3.outerRadius, cornerRadius = _ref3.cornerRadius, forceCornerRadius = _ref3.forceCornerRadius, cornerIsExternal = _ref3.cornerIsExternal, startAngle = _ref3.startAngle, endAngle = _ref3.endAngle;\n    var sign = (0, _DataUtils.mathSign)(endAngle - startAngle);\n    var _getTangentCircle = getTangentCircle({\n        cx: cx,\n        cy: cy,\n        radius: outerRadius,\n        angle: startAngle,\n        sign: sign,\n        cornerRadius: cornerRadius,\n        cornerIsExternal: cornerIsExternal\n    }), soct = _getTangentCircle.circleTangency, solt = _getTangentCircle.lineTangency, sot = _getTangentCircle.theta;\n    var _getTangentCircle2 = getTangentCircle({\n        cx: cx,\n        cy: cy,\n        radius: outerRadius,\n        angle: endAngle,\n        sign: -sign,\n        cornerRadius: cornerRadius,\n        cornerIsExternal: cornerIsExternal\n    }), eoct = _getTangentCircle2.circleTangency, eolt = _getTangentCircle2.lineTangency, eot = _getTangentCircle2.theta;\n    var outerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sot - eot;\n    if (outerArcAngle < 0) {\n        if (forceCornerRadius) {\n            return \"M \".concat(solt.x, \",\").concat(solt.y, \"\\n        a\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,1,\").concat(cornerRadius * 2, \",0\\n        a\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,1,\").concat(-cornerRadius * 2, \",0\\n      \");\n        }\n        return getSectorPath({\n            cx: cx,\n            cy: cy,\n            innerRadius: innerRadius,\n            outerRadius: outerRadius,\n            startAngle: startAngle,\n            endAngle: endAngle\n        });\n    }\n    var path = \"M \".concat(solt.x, \",\").concat(solt.y, \"\\n    A\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,\").concat(+(sign < 0), \",\").concat(soct.x, \",\").concat(soct.y, \"\\n    A\").concat(outerRadius, \",\").concat(outerRadius, \",0,\").concat(+(outerArcAngle > 180), \",\").concat(+(sign < 0), \",\").concat(eoct.x, \",\").concat(eoct.y, \"\\n    A\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,\").concat(+(sign < 0), \",\").concat(eolt.x, \",\").concat(eolt.y, \"\\n  \");\n    if (innerRadius > 0) {\n        var _getTangentCircle3 = getTangentCircle({\n            cx: cx,\n            cy: cy,\n            radius: innerRadius,\n            angle: startAngle,\n            sign: sign,\n            isExternal: true,\n            cornerRadius: cornerRadius,\n            cornerIsExternal: cornerIsExternal\n        }), sict = _getTangentCircle3.circleTangency, silt = _getTangentCircle3.lineTangency, sit = _getTangentCircle3.theta;\n        var _getTangentCircle4 = getTangentCircle({\n            cx: cx,\n            cy: cy,\n            radius: innerRadius,\n            angle: endAngle,\n            sign: -sign,\n            isExternal: true,\n            cornerRadius: cornerRadius,\n            cornerIsExternal: cornerIsExternal\n        }), eict = _getTangentCircle4.circleTangency, eilt = _getTangentCircle4.lineTangency, eit = _getTangentCircle4.theta;\n        var innerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sit - eit;\n        if (innerArcAngle < 0 && cornerRadius === 0) {\n            return \"\".concat(path, \"L\").concat(cx, \",\").concat(cy, \"Z\");\n        }\n        path += \"L\".concat(eilt.x, \",\").concat(eilt.y, \"\\n      A\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,\").concat(+(sign < 0), \",\").concat(eict.x, \",\").concat(eict.y, \"\\n      A\").concat(innerRadius, \",\").concat(innerRadius, \",0,\").concat(+(innerArcAngle > 180), \",\").concat(+(sign > 0), \",\").concat(sict.x, \",\").concat(sict.y, \"\\n      A\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,\").concat(+(sign < 0), \",\").concat(silt.x, \",\").concat(silt.y, \"Z\");\n    } else {\n        path += \"L\".concat(cx, \",\").concat(cy, \"Z\");\n    }\n    return path;\n};\nvar defaultProps = {\n    cx: 0,\n    cy: 0,\n    innerRadius: 0,\n    outerRadius: 0,\n    startAngle: 0,\n    endAngle: 0,\n    cornerRadius: 0,\n    forceCornerRadius: false,\n    cornerIsExternal: false\n};\nvar Sector = exports.Sector = function Sector(sectorProps) {\n    var props = _objectSpread(_objectSpread({}, defaultProps), sectorProps);\n    var cx = props.cx, cy = props.cy, innerRadius = props.innerRadius, outerRadius = props.outerRadius, cornerRadius = props.cornerRadius, forceCornerRadius = props.forceCornerRadius, cornerIsExternal = props.cornerIsExternal, startAngle = props.startAngle, endAngle = props.endAngle, className = props.className;\n    if (outerRadius < innerRadius || startAngle === endAngle) {\n        return null;\n    }\n    var layerClass = (0, _clsx[\"default\"])('recharts-sector', className);\n    var deltaRadius = outerRadius - innerRadius;\n    var cr = (0, _DataUtils.getPercentValue)(cornerRadius, deltaRadius, 0, true);\n    var path;\n    if (cr > 0 && Math.abs(startAngle - endAngle) < 360) {\n        path = getSectorWithCorner({\n            cx: cx,\n            cy: cy,\n            innerRadius: innerRadius,\n            outerRadius: outerRadius,\n            cornerRadius: Math.min(cr, deltaRadius / 2),\n            forceCornerRadius: forceCornerRadius,\n            cornerIsExternal: cornerIsExternal,\n            startAngle: startAngle,\n            endAngle: endAngle\n        });\n    } else {\n        path = getSectorPath({\n            cx: cx,\n            cy: cy,\n            innerRadius: innerRadius,\n            outerRadius: outerRadius,\n            startAngle: startAngle,\n            endAngle: endAngle\n        });\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(props, true), {\n        className: layerClass,\n        d: path,\n        role: \"img\"\n    }));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvc2hhcGUvU2VjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxjQUFjLEdBQUcsS0FBSztBQUN0QixJQUFJRyxTQUFTQyx1QkFBdUJDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ25ELElBQUlDLFFBQVFGLHVCQUF1QkMsbUJBQU9BLENBQUMsdUJBQU07QUFDakQsSUFBSUUsY0FBY0YsbUJBQU9BLENBQUMsMkZBQW9CO0FBQzlDLElBQUlHLGNBQWNILG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM5QyxJQUFJSSxhQUFhSixtQkFBT0EsQ0FBQyx5RkFBbUI7QUFDNUMsU0FBU0QsdUJBQXVCTSxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFLFdBQVcsS0FBS0MsVUFBVUQsTUFBTUMsT0FBT0UsU0FBUyxHQUFHLFdBQVcsT0FBT0g7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNJO0lBQWFBLFdBQVduQixPQUFPb0IsTUFBTSxHQUFHcEIsT0FBT29CLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFBSSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQUUsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFO1lBQUUsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUFFLElBQUkx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QUNiL0IsWUFBWUE7WUFDWkMsVUFBVUE7UUFDWjtJQUNGO0lBQ0EsT0FBTyxXQUFXLEdBQUVuRCxNQUFNLENBQUMsVUFBVSxDQUFDd0gsYUFBYSxDQUFDLFFBQVExRyxTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUdWLFlBQVlxSCxXQUFXLEVBQUVQLE9BQU8sT0FBTztRQUNsSEMsV0FBV0M7UUFDWE0sR0FBR3JDO1FBQ0hzQyxNQUFNO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcc2hhcGVcXFNlY3Rvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLlNlY3RvciA9IHZvaWQgMDtcclxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XHJcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XHJcbnZhciBfUG9sYXJVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1BvbGFyVXRpbHNcIik7XHJcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRGF0YVV0aWxzXCIpO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cclxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cclxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxyXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfSAvKipcclxuICogQGZpbGVPdmVydmlldyBTZWN0b3JcclxuICovXHJcbnZhciBnZXREZWx0YUFuZ2xlID0gZnVuY3Rpb24gZ2V0RGVsdGFBbmdsZShzdGFydEFuZ2xlLCBlbmRBbmdsZSkge1xyXG4gIHZhciBzaWduID0gKDAsIF9EYXRhVXRpbHMubWF0aFNpZ24pKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XHJcbiAgdmFyIGRlbHRhQW5nbGUgPSBNYXRoLm1pbihNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpLCAzNTkuOTk5KTtcclxuICByZXR1cm4gc2lnbiAqIGRlbHRhQW5nbGU7XHJcbn07XHJcbnZhciBnZXRUYW5nZW50Q2lyY2xlID0gZnVuY3Rpb24gZ2V0VGFuZ2VudENpcmNsZShfcmVmKSB7XHJcbiAgdmFyIGN4ID0gX3JlZi5jeCxcclxuICAgIGN5ID0gX3JlZi5jeSxcclxuICAgIHJhZGl1cyA9IF9yZWYucmFkaXVzLFxyXG4gICAgYW5nbGUgPSBfcmVmLmFuZ2xlLFxyXG4gICAgc2lnbiA9IF9yZWYuc2lnbixcclxuICAgIGlzRXh0ZXJuYWwgPSBfcmVmLmlzRXh0ZXJuYWwsXHJcbiAgICBjb3JuZXJSYWRpdXMgPSBfcmVmLmNvcm5lclJhZGl1cyxcclxuICAgIGNvcm5lcklzRXh0ZXJuYWwgPSBfcmVmLmNvcm5lcklzRXh0ZXJuYWw7XHJcbiAgdmFyIGNlbnRlclJhZGl1cyA9IGNvcm5lclJhZGl1cyAqIChpc0V4dGVybmFsID8gMSA6IC0xKSArIHJhZGl1cztcclxuICB2YXIgdGhldGEgPSBNYXRoLmFzaW4oY29ybmVyUmFkaXVzIC8gY2VudGVyUmFkaXVzKSAvIF9Qb2xhclV0aWxzLlJBRElBTjtcclxuICB2YXIgY2VudGVyQW5nbGUgPSBjb3JuZXJJc0V4dGVybmFsID8gYW5nbGUgOiBhbmdsZSArIHNpZ24gKiB0aGV0YTtcclxuICB2YXIgY2VudGVyID0gKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKGN4LCBjeSwgY2VudGVyUmFkaXVzLCBjZW50ZXJBbmdsZSk7XHJcbiAgLy8gVGhlIGNvb3JkaW5hdGUgb2YgcG9pbnQgd2hpY2ggaXMgdGFuZ2VudCB0byB0aGUgY2lyY2xlXHJcbiAgdmFyIGNpcmNsZVRhbmdlbmN5ID0gKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKGN4LCBjeSwgcmFkaXVzLCBjZW50ZXJBbmdsZSk7XHJcbiAgLy8gVGhlIGNvb3JkaW5hdGUgb2YgcG9pbnQgd2hpY2ggaXMgdGFuZ2VudCB0byB0aGUgcmFkaXVzIGxpbmVcclxuICB2YXIgbGluZVRhbmdlbmN5QW5nbGUgPSBjb3JuZXJJc0V4dGVybmFsID8gYW5nbGUgLSBzaWduICogdGhldGEgOiBhbmdsZTtcclxuICB2YXIgbGluZVRhbmdlbmN5ID0gKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKGN4LCBjeSwgY2VudGVyUmFkaXVzICogTWF0aC5jb3ModGhldGEgKiBfUG9sYXJVdGlscy5SQURJQU4pLCBsaW5lVGFuZ2VuY3lBbmdsZSk7XHJcbiAgcmV0dXJuIHtcclxuICAgIGNlbnRlcjogY2VudGVyLFxyXG4gICAgY2lyY2xlVGFuZ2VuY3k6IGNpcmNsZVRhbmdlbmN5LFxyXG4gICAgbGluZVRhbmdlbmN5OiBsaW5lVGFuZ2VuY3ksXHJcbiAgICB0aGV0YTogdGhldGFcclxuICB9O1xyXG59O1xyXG52YXIgZ2V0U2VjdG9yUGF0aCA9IGZ1bmN0aW9uIGdldFNlY3RvclBhdGgoX3JlZjIpIHtcclxuICB2YXIgY3ggPSBfcmVmMi5jeCxcclxuICAgIGN5ID0gX3JlZjIuY3ksXHJcbiAgICBpbm5lclJhZGl1cyA9IF9yZWYyLmlubmVyUmFkaXVzLFxyXG4gICAgb3V0ZXJSYWRpdXMgPSBfcmVmMi5vdXRlclJhZGl1cyxcclxuICAgIHN0YXJ0QW5nbGUgPSBfcmVmMi5zdGFydEFuZ2xlLFxyXG4gICAgZW5kQW5nbGUgPSBfcmVmMi5lbmRBbmdsZTtcclxuICB2YXIgYW5nbGUgPSBnZXREZWx0YUFuZ2xlKHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcclxuXHJcbiAgLy8gV2hlbiB0aGUgYW5nbGUgb2Ygc2VjdG9yIGVxdWFscyB0byAzNjAsIHN0YXIgcG9pbnQgYW5kIGVuZCBwb2ludCBjb2luY2lkZVxyXG4gIHZhciB0ZW1wRW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgYW5nbGU7XHJcbiAgdmFyIG91dGVyU3RhcnRQb2ludCA9ICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjeCwgY3ksIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlKTtcclxuICB2YXIgb3V0ZXJFbmRQb2ludCA9ICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjeCwgY3ksIG91dGVyUmFkaXVzLCB0ZW1wRW5kQW5nbGUpO1xyXG4gIHZhciBwYXRoID0gXCJNIFwiLmNvbmNhdChvdXRlclN0YXJ0UG9pbnQueCwgXCIsXCIpLmNvbmNhdChvdXRlclN0YXJ0UG9pbnQueSwgXCJcXG4gICAgQSBcIikuY29uY2F0KG91dGVyUmFkaXVzLCBcIixcIikuY29uY2F0KG91dGVyUmFkaXVzLCBcIiwwLFxcbiAgICBcIikuY29uY2F0KCsoTWF0aC5hYnMoYW5nbGUpID4gMTgwKSwgXCIsXCIpLmNvbmNhdCgrKHN0YXJ0QW5nbGUgPiB0ZW1wRW5kQW5nbGUpLCBcIixcXG4gICAgXCIpLmNvbmNhdChvdXRlckVuZFBvaW50LngsIFwiLFwiKS5jb25jYXQob3V0ZXJFbmRQb2ludC55LCBcIlxcbiAgXCIpO1xyXG4gIGlmIChpbm5lclJhZGl1cyA+IDApIHtcclxuICAgIHZhciBpbm5lclN0YXJ0UG9pbnQgPSAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikoY3gsIGN5LCBpbm5lclJhZGl1cywgc3RhcnRBbmdsZSk7XHJcbiAgICB2YXIgaW5uZXJFbmRQb2ludCA9ICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjeCwgY3ksIGlubmVyUmFkaXVzLCB0ZW1wRW5kQW5nbGUpO1xyXG4gICAgcGF0aCArPSBcIkwgXCIuY29uY2F0KGlubmVyRW5kUG9pbnQueCwgXCIsXCIpLmNvbmNhdChpbm5lckVuZFBvaW50LnksIFwiXFxuICAgICAgICAgICAgQSBcIikuY29uY2F0KGlubmVyUmFkaXVzLCBcIixcIikuY29uY2F0KGlubmVyUmFkaXVzLCBcIiwwLFxcbiAgICAgICAgICAgIFwiKS5jb25jYXQoKyhNYXRoLmFicyhhbmdsZSkgPiAxODApLCBcIixcIikuY29uY2F0KCsoc3RhcnRBbmdsZSA8PSB0ZW1wRW5kQW5nbGUpLCBcIixcXG4gICAgICAgICAgICBcIikuY29uY2F0KGlubmVyU3RhcnRQb2ludC54LCBcIixcIikuY29uY2F0KGlubmVyU3RhcnRQb2ludC55LCBcIiBaXCIpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBwYXRoICs9IFwiTCBcIi5jb25jYXQoY3gsIFwiLFwiKS5jb25jYXQoY3ksIFwiIFpcIik7XHJcbiAgfVxyXG4gIHJldHVybiBwYXRoO1xyXG59O1xyXG52YXIgZ2V0U2VjdG9yV2l0aENvcm5lciA9IGZ1bmN0aW9uIGdldFNlY3RvcldpdGhDb3JuZXIoX3JlZjMpIHtcclxuICB2YXIgY3ggPSBfcmVmMy5jeCxcclxuICAgIGN5ID0gX3JlZjMuY3ksXHJcbiAgICBpbm5lclJhZGl1cyA9IF9yZWYzLmlubmVyUmFkaXVzLFxyXG4gICAgb3V0ZXJSYWRpdXMgPSBfcmVmMy5vdXRlclJhZGl1cyxcclxuICAgIGNvcm5lclJhZGl1cyA9IF9yZWYzLmNvcm5lclJhZGl1cyxcclxuICAgIGZvcmNlQ29ybmVyUmFkaXVzID0gX3JlZjMuZm9yY2VDb3JuZXJSYWRpdXMsXHJcbiAgICBjb3JuZXJJc0V4dGVybmFsID0gX3JlZjMuY29ybmVySXNFeHRlcm5hbCxcclxuICAgIHN0YXJ0QW5nbGUgPSBfcmVmMy5zdGFydEFuZ2xlLFxyXG4gICAgZW5kQW5nbGUgPSBfcmVmMy5lbmRBbmdsZTtcclxuICB2YXIgc2lnbiA9ICgwLCBfRGF0YVV0aWxzLm1hdGhTaWduKShlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xyXG4gIHZhciBfZ2V0VGFuZ2VudENpcmNsZSA9IGdldFRhbmdlbnRDaXJjbGUoe1xyXG4gICAgICBjeDogY3gsXHJcbiAgICAgIGN5OiBjeSxcclxuICAgICAgcmFkaXVzOiBvdXRlclJhZGl1cyxcclxuICAgICAgYW5nbGU6IHN0YXJ0QW5nbGUsXHJcbiAgICAgIHNpZ246IHNpZ24sXHJcbiAgICAgIGNvcm5lclJhZGl1czogY29ybmVyUmFkaXVzLFxyXG4gICAgICBjb3JuZXJJc0V4dGVybmFsOiBjb3JuZXJJc0V4dGVybmFsXHJcbiAgICB9KSxcclxuICAgIHNvY3QgPSBfZ2V0VGFuZ2VudENpcmNsZS5jaXJjbGVUYW5nZW5jeSxcclxuICAgIHNvbHQgPSBfZ2V0VGFuZ2VudENpcmNsZS5saW5lVGFuZ2VuY3ksXHJcbiAgICBzb3QgPSBfZ2V0VGFuZ2VudENpcmNsZS50aGV0YTtcclxuICB2YXIgX2dldFRhbmdlbnRDaXJjbGUyID0gZ2V0VGFuZ2VudENpcmNsZSh7XHJcbiAgICAgIGN4OiBjeCxcclxuICAgICAgY3k6IGN5LFxyXG4gICAgICByYWRpdXM6IG91dGVyUmFkaXVzLFxyXG4gICAgICBhbmdsZTogZW5kQW5nbGUsXHJcbiAgICAgIHNpZ246IC1zaWduLFxyXG4gICAgICBjb3JuZXJSYWRpdXM6IGNvcm5lclJhZGl1cyxcclxuICAgICAgY29ybmVySXNFeHRlcm5hbDogY29ybmVySXNFeHRlcm5hbFxyXG4gICAgfSksXHJcbiAgICBlb2N0ID0gX2dldFRhbmdlbnRDaXJjbGUyLmNpcmNsZVRhbmdlbmN5LFxyXG4gICAgZW9sdCA9IF9nZXRUYW5nZW50Q2lyY2xlMi5saW5lVGFuZ2VuY3ksXHJcbiAgICBlb3QgPSBfZ2V0VGFuZ2VudENpcmNsZTIudGhldGE7XHJcbiAgdmFyIG91dGVyQXJjQW5nbGUgPSBjb3JuZXJJc0V4dGVybmFsID8gTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSA6IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSkgLSBzb3QgLSBlb3Q7XHJcbiAgaWYgKG91dGVyQXJjQW5nbGUgPCAwKSB7XHJcbiAgICBpZiAoZm9yY2VDb3JuZXJSYWRpdXMpIHtcclxuICAgICAgcmV0dXJuIFwiTSBcIi5jb25jYXQoc29sdC54LCBcIixcIikuY29uY2F0KHNvbHQueSwgXCJcXG4gICAgICAgIGFcIikuY29uY2F0KGNvcm5lclJhZGl1cywgXCIsXCIpLmNvbmNhdChjb3JuZXJSYWRpdXMsIFwiLDAsMCwxLFwiKS5jb25jYXQoY29ybmVyUmFkaXVzICogMiwgXCIsMFxcbiAgICAgICAgYVwiKS5jb25jYXQoY29ybmVyUmFkaXVzLCBcIixcIikuY29uY2F0KGNvcm5lclJhZGl1cywgXCIsMCwwLDEsXCIpLmNvbmNhdCgtY29ybmVyUmFkaXVzICogMiwgXCIsMFxcbiAgICAgIFwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBnZXRTZWN0b3JQYXRoKHtcclxuICAgICAgY3g6IGN4LFxyXG4gICAgICBjeTogY3ksXHJcbiAgICAgIGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcclxuICAgICAgb3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxyXG4gICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxyXG4gICAgICBlbmRBbmdsZTogZW5kQW5nbGVcclxuICAgIH0pO1xyXG4gIH1cclxuICB2YXIgcGF0aCA9IFwiTSBcIi5jb25jYXQoc29sdC54LCBcIixcIikuY29uY2F0KHNvbHQueSwgXCJcXG4gICAgQVwiKS5jb25jYXQoY29ybmVyUmFkaXVzLCBcIixcIikuY29uY2F0KGNvcm5lclJhZGl1cywgXCIsMCwwLFwiKS5jb25jYXQoKyhzaWduIDwgMCksIFwiLFwiKS5jb25jYXQoc29jdC54LCBcIixcIikuY29uY2F0KHNvY3QueSwgXCJcXG4gICAgQVwiKS5jb25jYXQob3V0ZXJSYWRpdXMsIFwiLFwiKS5jb25jYXQob3V0ZXJSYWRpdXMsIFwiLDAsXCIpLmNvbmNhdCgrKG91dGVyQXJjQW5nbGUgPiAxODApLCBcIixcIikuY29uY2F0KCsoc2lnbiA8IDApLCBcIixcIikuY29uY2F0KGVvY3QueCwgXCIsXCIpLmNvbmNhdChlb2N0LnksIFwiXFxuICAgIEFcIikuY29uY2F0KGNvcm5lclJhZGl1cywgXCIsXCIpLmNvbmNhdChjb3JuZXJSYWRpdXMsIFwiLDAsMCxcIikuY29uY2F0KCsoc2lnbiA8IDApLCBcIixcIikuY29uY2F0KGVvbHQueCwgXCIsXCIpLmNvbmNhdChlb2x0LnksIFwiXFxuICBcIik7XHJcbiAgaWYgKGlubmVyUmFkaXVzID4gMCkge1xyXG4gICAgdmFyIF9nZXRUYW5nZW50Q2lyY2xlMyA9IGdldFRhbmdlbnRDaXJjbGUoe1xyXG4gICAgICAgIGN4OiBjeCxcclxuICAgICAgICBjeTogY3ksXHJcbiAgICAgICAgcmFkaXVzOiBpbm5lclJhZGl1cyxcclxuICAgICAgICBhbmdsZTogc3RhcnRBbmdsZSxcclxuICAgICAgICBzaWduOiBzaWduLFxyXG4gICAgICAgIGlzRXh0ZXJuYWw6IHRydWUsXHJcbiAgICAgICAgY29ybmVyUmFkaXVzOiBjb3JuZXJSYWRpdXMsXHJcbiAgICAgICAgY29ybmVySXNFeHRlcm5hbDogY29ybmVySXNFeHRlcm5hbFxyXG4gICAgICB9KSxcclxuICAgICAgc2ljdCA9IF9nZXRUYW5nZW50Q2lyY2xlMy5jaXJjbGVUYW5nZW5jeSxcclxuICAgICAgc2lsdCA9IF9nZXRUYW5nZW50Q2lyY2xlMy5saW5lVGFuZ2VuY3ksXHJcbiAgICAgIHNpdCA9IF9nZXRUYW5nZW50Q2lyY2xlMy50aGV0YTtcclxuICAgIHZhciBfZ2V0VGFuZ2VudENpcmNsZTQgPSBnZXRUYW5nZW50Q2lyY2xlKHtcclxuICAgICAgICBjeDogY3gsXHJcbiAgICAgICAgY3k6IGN5LFxyXG4gICAgICAgIHJhZGl1czogaW5uZXJSYWRpdXMsXHJcbiAgICAgICAgYW5nbGU6IGVuZEFuZ2xlLFxyXG4gICAgICAgIHNpZ246IC1zaWduLFxyXG4gICAgICAgIGlzRXh0ZXJuYWw6IHRydWUsXHJcbiAgICAgICAgY29ybmVyUmFkaXVzOiBjb3JuZXJSYWRpdXMsXHJcbiAgICAgICAgY29ybmVySXNFeHRlcm5hbDogY29ybmVySXNFeHRlcm5hbFxyXG4gICAgICB9KSxcclxuICAgICAgZWljdCA9IF9nZXRUYW5nZW50Q2lyY2xlNC5jaXJjbGVUYW5nZW5jeSxcclxuICAgICAgZWlsdCA9IF9nZXRUYW5nZW50Q2lyY2xlNC5saW5lVGFuZ2VuY3ksXHJcbiAgICAgIGVpdCA9IF9nZXRUYW5nZW50Q2lyY2xlNC50aGV0YTtcclxuICAgIHZhciBpbm5lckFyY0FuZ2xlID0gY29ybmVySXNFeHRlcm5hbCA/IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSkgOiBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpIC0gc2l0IC0gZWl0O1xyXG4gICAgaWYgKGlubmVyQXJjQW5nbGUgPCAwICYmIGNvcm5lclJhZGl1cyA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQocGF0aCwgXCJMXCIpLmNvbmNhdChjeCwgXCIsXCIpLmNvbmNhdChjeSwgXCJaXCIpO1xyXG4gICAgfVxyXG4gICAgcGF0aCArPSBcIkxcIi5jb25jYXQoZWlsdC54LCBcIixcIikuY29uY2F0KGVpbHQueSwgXCJcXG4gICAgICBBXCIpLmNvbmNhdChjb3JuZXJSYWRpdXMsIFwiLFwiKS5jb25jYXQoY29ybmVyUmFkaXVzLCBcIiwwLDAsXCIpLmNvbmNhdCgrKHNpZ24gPCAwKSwgXCIsXCIpLmNvbmNhdChlaWN0LngsIFwiLFwiKS5jb25jYXQoZWljdC55LCBcIlxcbiAgICAgIEFcIikuY29uY2F0KGlubmVyUmFkaXVzLCBcIixcIikuY29uY2F0KGlubmVyUmFkaXVzLCBcIiwwLFwiKS5jb25jYXQoKyhpbm5lckFyY0FuZ2xlID4gMTgwKSwgXCIsXCIpLmNvbmNhdCgrKHNpZ24gPiAwKSwgXCIsXCIpLmNvbmNhdChzaWN0LngsIFwiLFwiKS5jb25jYXQoc2ljdC55LCBcIlxcbiAgICAgIEFcIikuY29uY2F0KGNvcm5lclJhZGl1cywgXCIsXCIpLmNvbmNhdChjb3JuZXJSYWRpdXMsIFwiLDAsMCxcIikuY29uY2F0KCsoc2lnbiA8IDApLCBcIixcIikuY29uY2F0KHNpbHQueCwgXCIsXCIpLmNvbmNhdChzaWx0LnksIFwiWlwiKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcGF0aCArPSBcIkxcIi5jb25jYXQoY3gsIFwiLFwiKS5jb25jYXQoY3ksIFwiWlwiKTtcclxuICB9XHJcbiAgcmV0dXJuIHBhdGg7XHJcbn07XHJcbnZhciBkZWZhdWx0UHJvcHMgPSB7XHJcbiAgY3g6IDAsXHJcbiAgY3k6IDAsXHJcbiAgaW5uZXJSYWRpdXM6IDAsXHJcbiAgb3V0ZXJSYWRpdXM6IDAsXHJcbiAgc3RhcnRBbmdsZTogMCxcclxuICBlbmRBbmdsZTogMCxcclxuICBjb3JuZXJSYWRpdXM6IDAsXHJcbiAgZm9yY2VDb3JuZXJSYWRpdXM6IGZhbHNlLFxyXG4gIGNvcm5lcklzRXh0ZXJuYWw6IGZhbHNlXHJcbn07XHJcbnZhciBTZWN0b3IgPSBleHBvcnRzLlNlY3RvciA9IGZ1bmN0aW9uIFNlY3RvcihzZWN0b3JQcm9wcykge1xyXG4gIHZhciBwcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdFByb3BzKSwgc2VjdG9yUHJvcHMpO1xyXG4gIHZhciBjeCA9IHByb3BzLmN4LFxyXG4gICAgY3kgPSBwcm9wcy5jeSxcclxuICAgIGlubmVyUmFkaXVzID0gcHJvcHMuaW5uZXJSYWRpdXMsXHJcbiAgICBvdXRlclJhZGl1cyA9IHByb3BzLm91dGVyUmFkaXVzLFxyXG4gICAgY29ybmVyUmFkaXVzID0gcHJvcHMuY29ybmVyUmFkaXVzLFxyXG4gICAgZm9yY2VDb3JuZXJSYWRpdXMgPSBwcm9wcy5mb3JjZUNvcm5lclJhZGl1cyxcclxuICAgIGNvcm5lcklzRXh0ZXJuYWwgPSBwcm9wcy5jb3JuZXJJc0V4dGVybmFsLFxyXG4gICAgc3RhcnRBbmdsZSA9IHByb3BzLnN0YXJ0QW5nbGUsXHJcbiAgICBlbmRBbmdsZSA9IHByb3BzLmVuZEFuZ2xlLFxyXG4gICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lO1xyXG4gIGlmIChvdXRlclJhZGl1cyA8IGlubmVyUmFkaXVzIHx8IHN0YXJ0QW5nbGUgPT09IGVuZEFuZ2xlKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgdmFyIGxheWVyQ2xhc3MgPSAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtc2VjdG9yJywgY2xhc3NOYW1lKTtcclxuICB2YXIgZGVsdGFSYWRpdXMgPSBvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzO1xyXG4gIHZhciBjciA9ICgwLCBfRGF0YVV0aWxzLmdldFBlcmNlbnRWYWx1ZSkoY29ybmVyUmFkaXVzLCBkZWx0YVJhZGl1cywgMCwgdHJ1ZSk7XHJcbiAgdmFyIHBhdGg7XHJcbiAgaWYgKGNyID4gMCAmJiBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpIDwgMzYwKSB7XHJcbiAgICBwYXRoID0gZ2V0U2VjdG9yV2l0aENvcm5lcih7XHJcbiAgICAgIGN4OiBjeCxcclxuICAgICAgY3k6IGN5LFxyXG4gICAgICBpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXHJcbiAgICAgIG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcclxuICAgICAgY29ybmVyUmFkaXVzOiBNYXRoLm1pbihjciwgZGVsdGFSYWRpdXMgLyAyKSxcclxuICAgICAgZm9yY2VDb3JuZXJSYWRpdXM6IGZvcmNlQ29ybmVyUmFkaXVzLFxyXG4gICAgICBjb3JuZXJJc0V4dGVybmFsOiBjb3JuZXJJc0V4dGVybmFsLFxyXG4gICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxyXG4gICAgICBlbmRBbmdsZTogZW5kQW5nbGVcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBwYXRoID0gZ2V0U2VjdG9yUGF0aCh7XHJcbiAgICAgIGN4OiBjeCxcclxuICAgICAgY3k6IGN5LFxyXG4gICAgICBpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXHJcbiAgICAgIG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcclxuICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcclxuICAgICAgZW5kQW5nbGU6IGVuZEFuZ2xlXHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIF9leHRlbmRzKHt9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHByb3BzLCB0cnVlKSwge1xyXG4gICAgY2xhc3NOYW1lOiBsYXllckNsYXNzLFxyXG4gICAgZDogcGF0aCxcclxuICAgIHJvbGU6IFwiaW1nXCJcclxuICB9KSk7XHJcbn07Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU2VjdG9yIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfY2xzeCIsIl9SZWFjdFV0aWxzIiwiX1BvbGFyVXRpbHMiLCJfRGF0YVV0aWxzIiwib2JqIiwiX19lc01vZHVsZSIsIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJvd25LZXlzIiwiZSIsInIiLCJ0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsImdldERlbHRhQW5nbGUiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJzaWduIiwibWF0aFNpZ24iLCJkZWx0YUFuZ2xlIiwiTWF0aCIsIm1pbiIsImFicyIsImdldFRhbmdlbnRDaXJjbGUiLCJfcmVmIiwiY3giLCJjeSIsInJhZGl1cyIsImFuZ2xlIiwiaXNFeHRlcm5hbCIsImNvcm5lclJhZGl1cyIsImNvcm5lcklzRXh0ZXJuYWwiLCJjZW50ZXJSYWRpdXMiLCJ0aGV0YSIsImFzaW4iLCJSQURJQU4iLCJjZW50ZXJBbmdsZSIsImNlbnRlciIsInBvbGFyVG9DYXJ0ZXNpYW4iLCJjaXJjbGVUYW5nZW5jeSIsImxpbmVUYW5nZW5jeUFuZ2xlIiwibGluZVRhbmdlbmN5IiwiY29zIiwiZ2V0U2VjdG9yUGF0aCIsIl9yZWYyIiwiaW5uZXJSYWRpdXMiLCJvdXRlclJhZGl1cyIsInRlbXBFbmRBbmdsZSIsIm91dGVyU3RhcnRQb2ludCIsIm91dGVyRW5kUG9pbnQiLCJwYXRoIiwiY29uY2F0IiwieCIsInkiLCJpbm5lclN0YXJ0UG9pbnQiLCJpbm5lckVuZFBvaW50IiwiZ2V0U2VjdG9yV2l0aENvcm5lciIsIl9yZWYzIiwiZm9yY2VDb3JuZXJSYWRpdXMiLCJfZ2V0VGFuZ2VudENpcmNsZSIsInNvY3QiLCJzb2x0Iiwic290IiwiX2dldFRhbmdlbnRDaXJjbGUyIiwiZW9jdCIsImVvbHQiLCJlb3QiLCJvdXRlckFyY0FuZ2xlIiwiX2dldFRhbmdlbnRDaXJjbGUzIiwic2ljdCIsInNpbHQiLCJzaXQiLCJfZ2V0VGFuZ2VudENpcmNsZTQiLCJlaWN0IiwiZWlsdCIsImVpdCIsImlubmVyQXJjQW5nbGUiLCJkZWZhdWx0UHJvcHMiLCJzZWN0b3JQcm9wcyIsInByb3BzIiwiY2xhc3NOYW1lIiwibGF5ZXJDbGFzcyIsImRlbHRhUmFkaXVzIiwiY3IiLCJnZXRQZXJjZW50VmFsdWUiLCJjcmVhdGVFbGVtZW50IiwiZmlsdGVyUHJvcHMiLCJkIiwicm9sZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/shape/Sector.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/shape/Symbols.js":
/*!****************************************************!*\
  !*** ./node_modules/recharts/lib/shape/Symbols.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Symbols = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _upperFirst = _interopRequireDefault(__webpack_require__(/*! lodash/upperFirst */ \"lodash/upperFirst\"));\nvar _d3Shape = __webpack_require__(/*! victory-vendor/d3-shape */ \"victory-vendor/d3-shape\");\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"type\",\n    \"size\",\n    \"sizeType\"\n];\n/**\r\n * @fileOverview Curve\r\n */ function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nvar symbolFactories = {\n    symbolCircle: _d3Shape.symbolCircle,\n    symbolCross: _d3Shape.symbolCross,\n    symbolDiamond: _d3Shape.symbolDiamond,\n    symbolSquare: _d3Shape.symbolSquare,\n    symbolStar: _d3Shape.symbolStar,\n    symbolTriangle: _d3Shape.symbolTriangle,\n    symbolWye: _d3Shape.symbolWye\n};\nvar RADIAN = Math.PI / 180;\nvar getSymbolFactory = function getSymbolFactory(type) {\n    var name = \"symbol\".concat((0, _upperFirst[\"default\"])(type));\n    return symbolFactories[name] || _d3Shape.symbolCircle;\n};\nvar calculateAreaSize = function calculateAreaSize(size, sizeType, type) {\n    if (sizeType === 'area') {\n        return size;\n    }\n    switch(type){\n        case 'cross':\n            return 5 * size * size / 9;\n        case 'diamond':\n            return 0.5 * size * size / Math.sqrt(3);\n        case 'square':\n            return size * size;\n        case 'star':\n            {\n                var angle = 18 * RADIAN;\n                return 1.25 * size * size * (Math.tan(angle) - Math.tan(angle * 2) * Math.pow(Math.tan(angle), 2));\n            }\n        case 'triangle':\n            return Math.sqrt(3) * size * size / 4;\n        case 'wye':\n            return (21 - 10 * Math.sqrt(3)) * size * size / 8;\n        default:\n            return Math.PI * size * size / 4;\n    }\n};\nvar registerSymbol = function registerSymbol(key, factory) {\n    symbolFactories[\"symbol\".concat((0, _upperFirst[\"default\"])(key))] = factory;\n};\nvar Symbols = exports.Symbols = function Symbols(_ref) {\n    var _ref$type = _ref.type, type = _ref$type === void 0 ? 'circle' : _ref$type, _ref$size = _ref.size, size = _ref$size === void 0 ? 64 : _ref$size, _ref$sizeType = _ref.sizeType, sizeType = _ref$sizeType === void 0 ? 'area' : _ref$sizeType, rest = _objectWithoutProperties(_ref, _excluded);\n    var props = _objectSpread(_objectSpread({}, rest), {}, {\n        type: type,\n        size: size,\n        sizeType: sizeType\n    });\n    /**\r\n   * Calculate the path of curve\r\n   * @return {String} path\r\n   */ var getPath = function getPath() {\n        var symbolFactory = getSymbolFactory(type);\n        var symbol = (0, _d3Shape.symbol)().type(symbolFactory).size(calculateAreaSize(size, sizeType, type));\n        return symbol();\n    };\n    var className = props.className, cx = props.cx, cy = props.cy;\n    var filteredProps = (0, _ReactUtils.filterProps)(props, true);\n    if (cx === +cx && cy === +cy && size === +size) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, filteredProps, {\n            className: (0, _clsx[\"default\"])('recharts-symbols', className),\n            transform: \"translate(\".concat(cx, \", \").concat(cy, \")\"),\n            d: getPath()\n        }));\n    }\n    return null;\n};\nSymbols.registerSymbol = registerSymbol;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvc2hhcGUvU3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFLFdBQVcsS0FBS0MsVUFBVUQsTUFBTUMsT0FBT0UsU0FBUyxHQUFHLFdBQVcsT0FBT0g7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdUSSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsZUFBZSxHQUFHLEtBQUs7QUFDdkIsSUFBSUcsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNuRCxJQUFJQyxjQUFjRix1QkFBdUJDLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJRSxXQUFXRixtQkFBT0EsQ0FBQyx3REFBeUI7QUFDaEQsSUFBSUcsUUFBUUosdUJBQXVCQyxtQkFBT0EsQ0FBQyx1QkFBTTtBQUNqRCxJQUFJSSxjQUFjSixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDOUMsSUFBSUssWUFBWTtJQUFDO0lBQVE7SUFBUTtDQUFXO0FBQzVDOztDQUVDLEdBQ0QsU0FBU04sdUJBQXVCTyxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFO0lBQWFBLFdBQVdmLE9BQU9nQixNQUFNLEdBQUdoQixPQUFPZ0IsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVUMsTUFBTTtRQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFBRSxJQUFJRyxTQUFT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Q0EsT0FBTztBQUNUO0FBQ0FsRixRQUFRMEUsY0FBYyxHQUFHQSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcc2hhcGVcXFN5bWJvbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLlN5bWJvbHMgPSB2b2lkIDA7XHJcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBfdXBwZXJGaXJzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC91cHBlckZpcnN0XCIpKTtcclxudmFyIF9kM1NoYXBlID0gcmVxdWlyZShcInZpY3RvcnktdmVuZG9yL2QzLXNoYXBlXCIpO1xyXG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcclxudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmVhY3RVdGlsc1wiKTtcclxudmFyIF9leGNsdWRlZCA9IFtcInR5cGVcIiwgXCJzaXplXCIsIFwic2l6ZVR5cGVcIl07XHJcbi8qKlxyXG4gKiBAZmlsZU92ZXJ2aWV3IEN1cnZlXHJcbiAqL1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XHJcbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cclxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxyXG52YXIgc3ltYm9sRmFjdG9yaWVzID0ge1xyXG4gIHN5bWJvbENpcmNsZTogX2QzU2hhcGUuc3ltYm9sQ2lyY2xlLFxyXG4gIHN5bWJvbENyb3NzOiBfZDNTaGFwZS5zeW1ib2xDcm9zcyxcclxuICBzeW1ib2xEaWFtb25kOiBfZDNTaGFwZS5zeW1ib2xEaWFtb25kLFxyXG4gIHN5bWJvbFNxdWFyZTogX2QzU2hhcGUuc3ltYm9sU3F1YXJlLFxyXG4gIHN5bWJvbFN0YXI6IF9kM1NoYXBlLnN5bWJvbFN0YXIsXHJcbiAgc3ltYm9sVHJpYW5nbGU6IF9kM1NoYXBlLnN5bWJvbFRyaWFuZ2xlLFxyXG4gIHN5bWJvbFd5ZTogX2QzU2hhcGUuc3ltYm9sV3llXHJcbn07XHJcbnZhciBSQURJQU4gPSBNYXRoLlBJIC8gMTgwO1xyXG52YXIgZ2V0U3ltYm9sRmFjdG9yeSA9IGZ1bmN0aW9uIGdldFN5bWJvbEZhY3RvcnkodHlwZSkge1xyXG4gIHZhciBuYW1lID0gXCJzeW1ib2xcIi5jb25jYXQoKDAsIF91cHBlckZpcnN0W1wiZGVmYXVsdFwiXSkodHlwZSkpO1xyXG4gIHJldHVybiBzeW1ib2xGYWN0b3JpZXNbbmFtZV0gfHwgX2QzU2hhcGUuc3ltYm9sQ2lyY2xlO1xyXG59O1xyXG52YXIgY2FsY3VsYXRlQXJlYVNpemUgPSBmdW5jdGlvbiBjYWxjdWxhdGVBcmVhU2l6ZShzaXplLCBzaXplVHlwZSwgdHlwZSkge1xyXG4gIGlmIChzaXplVHlwZSA9PT0gJ2FyZWEnKSB7XHJcbiAgICByZXR1cm4gc2l6ZTtcclxuICB9XHJcbiAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICBjYXNlICdjcm9zcyc6XHJcbiAgICAgIHJldHVybiA1ICogc2l6ZSAqIHNpemUgLyA5O1xyXG4gICAgY2FzZSAnZGlhbW9uZCc6XHJcbiAgICAgIHJldHVybiAwLjUgKiBzaXplICogc2l6ZSAvIE1hdGguc3FydCgzKTtcclxuICAgIGNhc2UgJ3NxdWFyZSc6XHJcbiAgICAgIHJldHVybiBzaXplICogc2l6ZTtcclxuICAgIGNhc2UgJ3N0YXInOlxyXG4gICAgICB7XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gMTggKiBSQURJQU47XHJcbiAgICAgICAgcmV0dXJuIDEuMjUgKiBzaXplICogc2l6ZSAqIChNYXRoLnRhbihhbmdsZSkgLSBNYXRoLnRhbihhbmdsZSAqIDIpICogTWF0aC5wb3coTWF0aC50YW4oYW5nbGUpLCAyKSk7XHJcbiAgICAgIH1cclxuICAgIGNhc2UgJ3RyaWFuZ2xlJzpcclxuICAgICAgcmV0dXJuIE1hdGguc3FydCgzKSAqIHNpemUgKiBzaXplIC8gNDtcclxuICAgIGNhc2UgJ3d5ZSc6XHJcbiAgICAgIHJldHVybiAoMjEgLSAxMCAqIE1hdGguc3FydCgzKSkgKiBzaXplICogc2l6ZSAvIDg7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gTWF0aC5QSSAqIHNpemUgKiBzaXplIC8gNDtcclxuICB9XHJcbn07XHJcbnZhciByZWdpc3RlclN5bWJvbCA9IGZ1bmN0aW9uIHJlZ2lzdGVyU3ltYm9sKGtleSwgZmFjdG9yeSkge1xyXG4gIHN5bWJvbEZhY3Rvcmllc1tcInN5bWJvbFwiLmNvbmNhdCgoMCwgX3VwcGVyRmlyc3RbXCJkZWZhdWx0XCJdKShrZXkpKV0gPSBmYWN0b3J5O1xyXG59O1xyXG52YXIgU3ltYm9scyA9IGV4cG9ydHMuU3ltYm9scyA9IGZ1bmN0aW9uIFN5bWJvbHMoX3JlZikge1xyXG4gIHZhciBfcmVmJHR5cGUgPSBfcmVmLnR5cGUsXHJcbiAgICB0eXBlID0gX3JlZiR0eXBlID09PSB2b2lkIDAgPyAnY2lyY2xlJyA6IF9yZWYkdHlwZSxcclxuICAgIF9yZWYkc2l6ZSA9IF9yZWYuc2l6ZSxcclxuICAgIHNpemUgPSBfcmVmJHNpemUgPT09IHZvaWQgMCA/IDY0IDogX3JlZiRzaXplLFxyXG4gICAgX3JlZiRzaXplVHlwZSA9IF9yZWYuc2l6ZVR5cGUsXHJcbiAgICBzaXplVHlwZSA9IF9yZWYkc2l6ZVR5cGUgPT09IHZvaWQgMCA/ICdhcmVhJyA6IF9yZWYkc2l6ZVR5cGUsXHJcbiAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XHJcbiAgdmFyIHByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXN0KSwge30sIHtcclxuICAgIHR5cGU6IHR5cGUsXHJcbiAgICBzaXplOiBzaXplLFxyXG4gICAgc2l6ZVR5cGU6IHNpemVUeXBlXHJcbiAgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSB0aGUgcGF0aCBvZiBjdXJ2ZVxyXG4gICAqIEByZXR1cm4ge1N0cmluZ30gcGF0aFxyXG4gICAqL1xyXG4gIHZhciBnZXRQYXRoID0gZnVuY3Rpb24gZ2V0UGF0aCgpIHtcclxuICAgIHZhciBzeW1ib2xGYWN0b3J5ID0gZ2V0U3ltYm9sRmFjdG9yeSh0eXBlKTtcclxuICAgIHZhciBzeW1ib2wgPSAoMCwgX2QzU2hhcGUuc3ltYm9sKSgpLnR5cGUoc3ltYm9sRmFjdG9yeSkuc2l6ZShjYWxjdWxhdGVBcmVhU2l6ZShzaXplLCBzaXplVHlwZSwgdHlwZSkpO1xyXG4gICAgcmV0dXJuIHN5bWJvbCgpO1xyXG4gIH07XHJcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcclxuICAgIGN4ID0gcHJvcHMuY3gsXHJcbiAgICBjeSA9IHByb3BzLmN5O1xyXG4gIHZhciBmaWx0ZXJlZFByb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShwcm9wcywgdHJ1ZSk7XHJcbiAgaWYgKGN4ID09PSArY3ggJiYgY3kgPT09ICtjeSAmJiBzaXplID09PSArc2l6ZSkge1xyXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIF9leHRlbmRzKHt9LCBmaWx0ZXJlZFByb3BzLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXN5bWJvbHMnLCBjbGFzc05hbWUpLFxyXG4gICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiLmNvbmNhdChjeCwgXCIsIFwiKS5jb25jYXQoY3ksIFwiKVwiKSxcclxuICAgICAgZDogZ2V0UGF0aCgpXHJcbiAgICB9KSk7XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59O1xyXG5TeW1ib2xzLnJlZ2lzdGVyU3ltYm9sID0gcmVnaXN0ZXJTeW1ib2w7Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlN5bWJvbHMiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl91cHBlckZpcnN0IiwiX2QzU2hhcGUiLCJfY2xzeCIsIl9SZWFjdFV0aWxzIiwiX2V4Y2x1ZGVkIiwib2JqIiwiX19lc01vZHVsZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIm93bktleXMiLCJlIiwiciIsInQiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsInNvdXJjZVN5bWJvbEtleXMiLCJpbmRleE9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJzeW1ib2xGYWN0b3JpZXMiLCJzeW1ib2xDaXJjbGUiLCJzeW1ib2xDcm9zcyIsInN5bWJvbERpYW1vbmQiLCJzeW1ib2xTcXVhcmUiLCJzeW1ib2xTdGFyIiwic3ltYm9sVHJpYW5nbGUiLCJzeW1ib2xXeWUiLCJSQURJQU4iLCJNYXRoIiwiUEkiLCJnZXRTeW1ib2xGYWN0b3J5IiwidHlwZSIsIm5hbWUiLCJjb25jYXQiLCJjYWxjdWxhdGVBcmVhU2l6ZSIsInNpemUiLCJzaXplVHlwZSIsInNxcnQiLCJhbmdsZSIsInRhbiIsInBvdyIsInJlZ2lzdGVyU3ltYm9sIiwiZmFjdG9yeSIsIl9yZWYiLCJfcmVmJHR5cGUiLCJfcmVmJHNpemUiLCJfcmVmJHNpemVUeXBlIiwicmVzdCIsInByb3BzIiwiZ2V0UGF0aCIsInN5bWJvbEZhY3RvcnkiLCJzeW1ib2wiLCJjbGFzc05hbWUiLCJjeCIsImN5IiwiZmlsdGVyZWRQcm9wcyIsImZpbHRlclByb3BzIiwiY3JlYXRlRWxlbWVudCIsInRyYW5zZm9ybSIsImQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/shape/Symbols.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/shape/Trapezoid.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/shape/Trapezoid.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Trapezoid = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\r\n * @fileOverview Rectangle\r\n */ \nvar getTrapezoidPath = function getTrapezoidPath(x, y, upperWidth, lowerWidth, height) {\n    var widthGap = upperWidth - lowerWidth;\n    var path;\n    path = \"M \".concat(x, \",\").concat(y);\n    path += \"L \".concat(x + upperWidth, \",\").concat(y);\n    path += \"L \".concat(x + upperWidth - widthGap / 2, \",\").concat(y + height);\n    path += \"L \".concat(x + upperWidth - widthGap / 2 - lowerWidth, \",\").concat(y + height);\n    path += \"L \".concat(x, \",\").concat(y, \" Z\");\n    return path;\n};\nvar defaultProps = {\n    x: 0,\n    y: 0,\n    upperWidth: 0,\n    lowerWidth: 0,\n    height: 0,\n    isUpdateAnimationActive: false,\n    animationBegin: 0,\n    animationDuration: 1500,\n    animationEasing: 'ease'\n};\nvar Trapezoid = exports.Trapezoid = function Trapezoid(props) {\n    var trapezoidProps = _objectSpread(_objectSpread({}, defaultProps), props);\n    var pathRef = (0, _react.useRef)();\n    var _useState = (0, _react.useState)(-1), _useState2 = _slicedToArray(_useState, 2), totalLength = _useState2[0], setTotalLength = _useState2[1];\n    (0, _react.useEffect)(function() {\n        if (pathRef.current && pathRef.current.getTotalLength) {\n            try {\n                var pathTotalLength = pathRef.current.getTotalLength();\n                if (pathTotalLength) {\n                    setTotalLength(pathTotalLength);\n                }\n            } catch (err) {\n            // calculate total length error\n            }\n        }\n    }, []);\n    var x = trapezoidProps.x, y = trapezoidProps.y, upperWidth = trapezoidProps.upperWidth, lowerWidth = trapezoidProps.lowerWidth, height = trapezoidProps.height, className = trapezoidProps.className;\n    var animationEasing = trapezoidProps.animationEasing, animationDuration = trapezoidProps.animationDuration, animationBegin = trapezoidProps.animationBegin, isUpdateAnimationActive = trapezoidProps.isUpdateAnimationActive;\n    if (x !== +x || y !== +y || upperWidth !== +upperWidth || lowerWidth !== +lowerWidth || height !== +height || upperWidth === 0 && lowerWidth === 0 || height === 0) {\n        return null;\n    }\n    var layerClass = (0, _clsx[\"default\"])('recharts-trapezoid', className);\n    if (!isUpdateAnimationActive) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", null, /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(trapezoidProps, true), {\n            className: layerClass,\n            d: getTrapezoidPath(x, y, upperWidth, lowerWidth, height)\n        })));\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n        canBegin: totalLength > 0,\n        from: {\n            upperWidth: 0,\n            lowerWidth: 0,\n            height: height,\n            x: x,\n            y: y\n        },\n        to: {\n            upperWidth: upperWidth,\n            lowerWidth: lowerWidth,\n            height: height,\n            x: x,\n            y: y\n        },\n        duration: animationDuration,\n        animationEasing: animationEasing,\n        isActive: isUpdateAnimationActive\n    }, function(_ref) {\n        var currUpperWidth = _ref.upperWidth, currLowerWidth = _ref.lowerWidth, currHeight = _ref.height, currX = _ref.x, currY = _ref.y;\n        return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n            canBegin: totalLength > 0,\n            from: \"0px \".concat(totalLength === -1 ? 1 : totalLength, \"px\"),\n            to: \"\".concat(totalLength, \"px 0px\"),\n            attributeName: \"strokeDasharray\",\n            begin: animationBegin,\n            duration: animationDuration,\n            easing: animationEasing\n        }, /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(trapezoidProps, true), {\n            className: layerClass,\n            d: getTrapezoidPath(currX, currY, currUpperWidth, currLowerWidth, currHeight),\n            ref: pathRef\n        })));\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvc2hhcGUvVHJhcGV6b2lkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLElBQUlHLFNBQVNDLHdCQUF3QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUMsUUFBUUMsdUJBQXVCRixtQkFBT0EsQ0FBQyx1QkFBTTtBQUNqRCxJQUFJRyxlQUFlRCx1QkFBdUJGLG1CQUFPQSxDQUFDLGtDQUFjO0FBQ2hFLElBQUlJLGNBQWNKLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM5QyxTQUFTRSx1QkFBdUJHLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UseUJBQXlCQyxDQUFDO0lBQUksSUFBSSxjQUFjLE9BQU9DLFNBQVMsT0FBTztJQUFNLElBQUlDLElBQUksSUFBSUQsV0FBV0UsSUFBSSxJQUFJRjtJQUFXLE9BQU8sQ0FBQ0YsMkJBQTJCLFNBQVNBLHlCQUF5QkMsQ0FBQztRQUFJLE9BQU9BLElBQUlHLElBQUlEO0lBQUcsR0FBR0Y7QUFBSTtBQUNuTyxTQUFTVCx3QkFBd0JTLENBQUMsRUFBRUUsQ0FBQztJQUFJLElBQUksQ0FBQ0EsS0FBS0YsS0FBS0EsRUFBRUYsVUFBVSxFQUFFLE9BQU9FO0lBQUcsSUFBSSxTQUFTQSxLQUFLLFlBQVlJLFFBQVFKLE1BQU0sY0FBYyxPQUFPQSxHQUFHLE9BQU87UUFBRSxXQUFXQTtJQUFFO0lBQUcsSUFBSUcsSUFBSUoseUJBQXlCRztJQUFJLElBQUlDLEtBQUtBLEVBQUVFLEdBQUcsQ0FBQ0wsSUFBSSxPQUFPRyxFQUFFRyxHQUFHLENBQUNOO0lBQUksSUFBSU8sSUFBSTtRQUFFQyxXQUFXO0lBQUssR0FBR0MsSUFBSXhCLE9BQU9DLGNBQWMs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LGlCQUFpQkYsS0FBS2pDLFVBQVUsRUFDaENvQyxhQUFhSCxLQUFLaEMsTUFBTSxFQUN4Qm9DLFFBQVFKLEtBQUtwQyxDQUFDLEVBQ2R5QyxRQUFRTCxLQUFLbkMsQ0FBQztRQUNoQixPQUFPLFdBQVcsR0FBRWpGLE1BQU0sQ0FBQyxVQUFVLENBQUM2RyxhQUFhLENBQUN4RyxZQUFZLENBQUMsVUFBVSxFQUFFO1lBQzNFMkcsVUFBVVosY0FBYztZQUN4QmhELE1BQU0sT0FBT21DLE1BQU0sQ0FBQ2EsZ0JBQWdCLENBQUMsSUFBSSxJQUFJQSxhQUFhO1lBQzFEYSxJQUFJLEdBQUcxQixNQUFNLENBQUNhLGFBQWE7WUFDM0JzQixlQUFlO1lBQ2ZDLE9BQU9qQztZQUNQd0IsVUFBVXZCO1lBQ1ZpQyxRQUFRaEM7UUFDVixHQUFHLFdBQVcsR0FBRTVGLE1BQU0sQ0FBQyxVQUFVLENBQUM2RyxhQUFhLENBQUMsUUFBUS9FLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBR3hCLFlBQVl3RyxXQUFXLEVBQUVoQixnQkFBZ0IsT0FBTztZQUN2SGEsV0FBV0M7WUFDWEcsR0FBR2hDLGlCQUFpQnlDLE9BQU9DLE9BQU9KLGdCQUFnQkMsZ0JBQWdCQztZQUNsRU0sS0FBSzlCO1FBQ1A7SUFDRjtBQUNGIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFxzaGFwZVxcVHJhcGV6b2lkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuVHJhcGV6b2lkID0gdm9pZCAwO1xyXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XHJcbnZhciBfcmVhY3RTbW9vdGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1zbW9vdGhcIikpO1xyXG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cclxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cclxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxyXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cclxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cclxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XHJcbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxyXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XHJcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxyXG4gKiBAZmlsZU92ZXJ2aWV3IFJlY3RhbmdsZVxyXG4gKi9cclxudmFyIGdldFRyYXBlem9pZFBhdGggPSBmdW5jdGlvbiBnZXRUcmFwZXpvaWRQYXRoKHgsIHksIHVwcGVyV2lkdGgsIGxvd2VyV2lkdGgsIGhlaWdodCkge1xyXG4gIHZhciB3aWR0aEdhcCA9IHVwcGVyV2lkdGggLSBsb3dlcldpZHRoO1xyXG4gIHZhciBwYXRoO1xyXG4gIHBhdGggPSBcIk0gXCIuY29uY2F0KHgsIFwiLFwiKS5jb25jYXQoeSk7XHJcbiAgcGF0aCArPSBcIkwgXCIuY29uY2F0KHggKyB1cHBlcldpZHRoLCBcIixcIikuY29uY2F0KHkpO1xyXG4gIHBhdGggKz0gXCJMIFwiLmNvbmNhdCh4ICsgdXBwZXJXaWR0aCAtIHdpZHRoR2FwIC8gMiwgXCIsXCIpLmNvbmNhdCh5ICsgaGVpZ2h0KTtcclxuICBwYXRoICs9IFwiTCBcIi5jb25jYXQoeCArIHVwcGVyV2lkdGggLSB3aWR0aEdhcCAvIDIgLSBsb3dlcldpZHRoLCBcIixcIikuY29uY2F0KHkgKyBoZWlnaHQpO1xyXG4gIHBhdGggKz0gXCJMIFwiLmNvbmNhdCh4LCBcIixcIikuY29uY2F0KHksIFwiIFpcIik7XHJcbiAgcmV0dXJuIHBhdGg7XHJcbn07XHJcbnZhciBkZWZhdWx0UHJvcHMgPSB7XHJcbiAgeDogMCxcclxuICB5OiAwLFxyXG4gIHVwcGVyV2lkdGg6IDAsXHJcbiAgbG93ZXJXaWR0aDogMCxcclxuICBoZWlnaHQ6IDAsXHJcbiAgaXNVcGRhdGVBbmltYXRpb25BY3RpdmU6IGZhbHNlLFxyXG4gIGFuaW1hdGlvbkJlZ2luOiAwLFxyXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiAxNTAwLFxyXG4gIGFuaW1hdGlvbkVhc2luZzogJ2Vhc2UnXHJcbn07XHJcbnZhciBUcmFwZXpvaWQgPSBleHBvcnRzLlRyYXBlem9pZCA9IGZ1bmN0aW9uIFRyYXBlem9pZChwcm9wcykge1xyXG4gIHZhciB0cmFwZXpvaWRQcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdFByb3BzKSwgcHJvcHMpO1xyXG4gIHZhciBwYXRoUmVmID0gKDAsIF9yZWFjdC51c2VSZWYpKCk7XHJcbiAgdmFyIF91c2VTdGF0ZSA9ICgwLCBfcmVhY3QudXNlU3RhdGUpKC0xKSxcclxuICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxyXG4gICAgdG90YWxMZW5ndGggPSBfdXNlU3RhdGUyWzBdLFxyXG4gICAgc2V0VG90YWxMZW5ndGggPSBfdXNlU3RhdGUyWzFdO1xyXG4gICgwLCBfcmVhY3QudXNlRWZmZWN0KShmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAocGF0aFJlZi5jdXJyZW50ICYmIHBhdGhSZWYuY3VycmVudC5nZXRUb3RhbExlbmd0aCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHZhciBwYXRoVG90YWxMZW5ndGggPSBwYXRoUmVmLmN1cnJlbnQuZ2V0VG90YWxMZW5ndGgoKTtcclxuICAgICAgICBpZiAocGF0aFRvdGFsTGVuZ3RoKSB7XHJcbiAgICAgICAgICBzZXRUb3RhbExlbmd0aChwYXRoVG90YWxMZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRvdGFsIGxlbmd0aCBlcnJvclxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW10pO1xyXG4gIHZhciB4ID0gdHJhcGV6b2lkUHJvcHMueCxcclxuICAgIHkgPSB0cmFwZXpvaWRQcm9wcy55LFxyXG4gICAgdXBwZXJXaWR0aCA9IHRyYXBlem9pZFByb3BzLnVwcGVyV2lkdGgsXHJcbiAgICBsb3dlcldpZHRoID0gdHJhcGV6b2lkUHJvcHMubG93ZXJXaWR0aCxcclxuICAgIGhlaWdodCA9IHRyYXBlem9pZFByb3BzLmhlaWdodCxcclxuICAgIGNsYXNzTmFtZSA9IHRyYXBlem9pZFByb3BzLmNsYXNzTmFtZTtcclxuICB2YXIgYW5pbWF0aW9uRWFzaW5nID0gdHJhcGV6b2lkUHJvcHMuYW5pbWF0aW9uRWFzaW5nLFxyXG4gICAgYW5pbWF0aW9uRHVyYXRpb24gPSB0cmFwZXpvaWRQcm9wcy5hbmltYXRpb25EdXJhdGlvbixcclxuICAgIGFuaW1hdGlvbkJlZ2luID0gdHJhcGV6b2lkUHJvcHMuYW5pbWF0aW9uQmVnaW4sXHJcbiAgICBpc1VwZGF0ZUFuaW1hdGlvbkFjdGl2ZSA9IHRyYXBlem9pZFByb3BzLmlzVXBkYXRlQW5pbWF0aW9uQWN0aXZlO1xyXG4gIGlmICh4ICE9PSAreCB8fCB5ICE9PSAreSB8fCB1cHBlcldpZHRoICE9PSArdXBwZXJXaWR0aCB8fCBsb3dlcldpZHRoICE9PSArbG93ZXJXaWR0aCB8fCBoZWlnaHQgIT09ICtoZWlnaHQgfHwgdXBwZXJXaWR0aCA9PT0gMCAmJiBsb3dlcldpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHZhciBsYXllckNsYXNzID0gKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXRyYXBlem9pZCcsIGNsYXNzTmFtZSk7XHJcbiAgaWYgKCFpc1VwZGF0ZUFuaW1hdGlvbkFjdGl2ZSkge1xyXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIG51bGwsIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIF9leHRlbmRzKHt9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRyYXBlem9pZFByb3BzLCB0cnVlKSwge1xyXG4gICAgICBjbGFzc05hbWU6IGxheWVyQ2xhc3MsXHJcbiAgICAgIGQ6IGdldFRyYXBlem9pZFBhdGgoeCwgeSwgdXBwZXJXaWR0aCwgbG93ZXJXaWR0aCwgaGVpZ2h0KVxyXG4gICAgfSkpKTtcclxuICB9XHJcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX3JlYWN0U21vb3RoW1wiZGVmYXVsdFwiXSwge1xyXG4gICAgY2FuQmVnaW46IHRvdGFsTGVuZ3RoID4gMCxcclxuICAgIGZyb206IHtcclxuICAgICAgdXBwZXJXaWR0aDogMCxcclxuICAgICAgbG93ZXJXaWR0aDogMCxcclxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgIHg6IHgsXHJcbiAgICAgIHk6IHlcclxuICAgIH0sXHJcbiAgICB0bzoge1xyXG4gICAgICB1cHBlcldpZHRoOiB1cHBlcldpZHRoLFxyXG4gICAgICBsb3dlcldpZHRoOiBsb3dlcldpZHRoLFxyXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgeDogeCxcclxuICAgICAgeTogeVxyXG4gICAgfSxcclxuICAgIGR1cmF0aW9uOiBhbmltYXRpb25EdXJhdGlvbixcclxuICAgIGFuaW1hdGlvbkVhc2luZzogYW5pbWF0aW9uRWFzaW5nLFxyXG4gICAgaXNBY3RpdmU6IGlzVXBkYXRlQW5pbWF0aW9uQWN0aXZlXHJcbiAgfSwgZnVuY3Rpb24gKF9yZWYpIHtcclxuICAgIHZhciBjdXJyVXBwZXJXaWR0aCA9IF9yZWYudXBwZXJXaWR0aCxcclxuICAgICAgY3Vyckxvd2VyV2lkdGggPSBfcmVmLmxvd2VyV2lkdGgsXHJcbiAgICAgIGN1cnJIZWlnaHQgPSBfcmVmLmhlaWdodCxcclxuICAgICAgY3VyclggPSBfcmVmLngsXHJcbiAgICAgIGN1cnJZID0gX3JlZi55O1xyXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX3JlYWN0U21vb3RoW1wiZGVmYXVsdFwiXSwge1xyXG4gICAgICBjYW5CZWdpbjogdG90YWxMZW5ndGggPiAwLFxyXG4gICAgICBmcm9tOiBcIjBweCBcIi5jb25jYXQodG90YWxMZW5ndGggPT09IC0xID8gMSA6IHRvdGFsTGVuZ3RoLCBcInB4XCIpLFxyXG4gICAgICB0bzogXCJcIi5jb25jYXQodG90YWxMZW5ndGgsIFwicHggMHB4XCIpLFxyXG4gICAgICBhdHRyaWJ1dGVOYW1lOiBcInN0cm9rZURhc2hhcnJheVwiLFxyXG4gICAgICBiZWdpbjogYW5pbWF0aW9uQmVnaW4sXHJcbiAgICAgIGR1cmF0aW9uOiBhbmltYXRpb25EdXJhdGlvbixcclxuICAgICAgZWFzaW5nOiBhbmltYXRpb25FYXNpbmdcclxuICAgIH0sIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIF9leHRlbmRzKHt9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRyYXBlem9pZFByb3BzLCB0cnVlKSwge1xyXG4gICAgICBjbGFzc05hbWU6IGxheWVyQ2xhc3MsXHJcbiAgICAgIGQ6IGdldFRyYXBlem9pZFBhdGgoY3VyclgsIGN1cnJZLCBjdXJyVXBwZXJXaWR0aCwgY3Vyckxvd2VyV2lkdGgsIGN1cnJIZWlnaHQpLFxyXG4gICAgICByZWY6IHBhdGhSZWZcclxuICAgIH0pKSk7XHJcbiAgfSk7XHJcbn07Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVHJhcGV6b2lkIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX2Nsc3giLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX3JlYWN0U21vb3RoIiwiX1JlYWN0VXRpbHMiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwicHJvdG90eXBlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwiYXBwbHkiLCJfc2xpY2VkVG9BcnJheSIsImFyciIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJUeXBlRXJyb3IiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsInRvU3RyaW5nIiwic2xpY2UiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsImxlbiIsImFycjIiLCJsIiwiZiIsIm5leHQiLCJkb25lIiwicHVzaCIsImlzQXJyYXkiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImVudW1lcmFibGUiLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiZ2V0VHJhcGV6b2lkUGF0aCIsIngiLCJ5IiwidXBwZXJXaWR0aCIsImxvd2VyV2lkdGgiLCJoZWlnaHQiLCJ3aWR0aEdhcCIsInBhdGgiLCJjb25jYXQiLCJkZWZhdWx0UHJvcHMiLCJpc1VwZGF0ZUFuaW1hdGlvbkFjdGl2ZSIsImFuaW1hdGlvbkJlZ2luIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJhbmltYXRpb25FYXNpbmciLCJwcm9wcyIsInRyYXBlem9pZFByb3BzIiwicGF0aFJlZiIsInVzZVJlZiIsIl91c2VTdGF0ZSIsInVzZVN0YXRlIiwiX3VzZVN0YXRlMiIsInRvdGFsTGVuZ3RoIiwic2V0VG90YWxMZW5ndGgiLCJ1c2VFZmZlY3QiLCJjdXJyZW50IiwiZ2V0VG90YWxMZW5ndGgiLCJwYXRoVG90YWxMZW5ndGgiLCJlcnIiLCJjbGFzc05hbWUiLCJsYXllckNsYXNzIiwiY3JlYXRlRWxlbWVudCIsImZpbHRlclByb3BzIiwiZCIsImNhbkJlZ2luIiwidG8iLCJkdXJhdGlvbiIsImlzQWN0aXZlIiwiX3JlZiIsImN1cnJVcHBlcldpZHRoIiwiY3Vyckxvd2VyV2lkdGgiLCJjdXJySGVpZ2h0IiwiY3VyclgiLCJjdXJyWSIsImF0dHJpYnV0ZU5hbWUiLCJiZWdpbiIsImVhc2luZyIsInJlZiJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/shape/Trapezoid.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/ActiveShapeUtils.js":
/*!************************************************************!*\
  !*** ./node_modules/recharts/lib/util/ActiveShapeUtils.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Shape = Shape;\nexports.compareFunnel = compareFunnel;\nexports.comparePie = comparePie;\nexports.compareScatter = compareScatter;\nexports.getActiveShapeIndexForTooltip = getActiveShapeIndexForTooltip;\nexports.getPropsFromShapeOption = getPropsFromShapeOption;\nexports.isFunnel = isFunnel;\nexports.isPie = isPie;\nexports.isScatter = isScatter;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _isPlainObject = _interopRequireDefault(__webpack_require__(/*! lodash/isPlainObject */ \"lodash/isPlainObject\"));\nvar _isBoolean = _interopRequireDefault(__webpack_require__(/*! lodash/isBoolean */ \"lodash/isBoolean\"));\nvar _isEqual = _interopRequireDefault(__webpack_require__(/*! lodash/isEqual */ \"lodash/isEqual\"));\nvar _Rectangle = __webpack_require__(/*! ../shape/Rectangle */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Rectangle.js\");\nvar _Trapezoid = __webpack_require__(/*! ../shape/Trapezoid */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Trapezoid.js\");\nvar _Sector = __webpack_require__(/*! ../shape/Sector */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Sector.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"(pages-dir-node)/./node_modules/recharts/lib/container/Layer.js\");\nvar _Symbols = __webpack_require__(/*! ../shape/Symbols */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Symbols.js\");\nvar _excluded = [\n    \"option\",\n    \"shapeType\",\n    \"propTransformer\",\n    \"activeClassName\",\n    \"isActive\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n/**\r\n * This is an abstraction for rendering a user defined prop for a customized shape in several forms.\r\n *\r\n * <Shape /> is the root and will handle taking in:\r\n *  - an object of svg properties\r\n *  - a boolean\r\n *  - a render prop(inline function that returns jsx)\r\n *  - a react element\r\n *\r\n * <ShapeSelector /> is a subcomponent of <Shape /> and used to match a component\r\n * to the value of props.shapeType that is passed to the root.\r\n *\r\n */ function defaultPropTransformer(option, props) {\n    return _objectSpread(_objectSpread({}, props), option);\n}\nfunction isSymbolsProps(shapeType, _elementProps) {\n    return shapeType === 'symbols';\n}\nfunction ShapeSelector(_ref) {\n    var shapeType = _ref.shapeType, elementProps = _ref.elementProps;\n    switch(shapeType){\n        case 'rectangle':\n            return /*#__PURE__*/ _react[\"default\"].createElement(_Rectangle.Rectangle, elementProps);\n        case 'trapezoid':\n            return /*#__PURE__*/ _react[\"default\"].createElement(_Trapezoid.Trapezoid, elementProps);\n        case 'sector':\n            return /*#__PURE__*/ _react[\"default\"].createElement(_Sector.Sector, elementProps);\n        case 'symbols':\n            if (isSymbolsProps(shapeType, elementProps)) {\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Symbols.Symbols, elementProps);\n            }\n            break;\n        default:\n            return null;\n    }\n}\nfunction getPropsFromShapeOption(option) {\n    if (/*#__PURE__*/ (0, _react.isValidElement)(option)) {\n        return option.props;\n    }\n    return option;\n}\nfunction Shape(_ref2) {\n    var option = _ref2.option, shapeType = _ref2.shapeType, _ref2$propTransformer = _ref2.propTransformer, propTransformer = _ref2$propTransformer === void 0 ? defaultPropTransformer : _ref2$propTransformer, _ref2$activeClassName = _ref2.activeClassName, activeClassName = _ref2$activeClassName === void 0 ? 'recharts-active-shape' : _ref2$activeClassName, isActive = _ref2.isActive, props = _objectWithoutProperties(_ref2, _excluded);\n    var shape;\n    if (/*#__PURE__*/ (0, _react.isValidElement)(option)) {\n        shape = /*#__PURE__*/ (0, _react.cloneElement)(option, _objectSpread(_objectSpread({}, props), getPropsFromShapeOption(option)));\n    } else if ((0, _isFunction[\"default\"])(option)) {\n        shape = option(props);\n    } else if ((0, _isPlainObject[\"default\"])(option) && !(0, _isBoolean[\"default\"])(option)) {\n        var nextProps = propTransformer(option, props);\n        shape = /*#__PURE__*/ _react[\"default\"].createElement(ShapeSelector, {\n            shapeType: shapeType,\n            elementProps: nextProps\n        });\n    } else {\n        var elementProps = props;\n        shape = /*#__PURE__*/ _react[\"default\"].createElement(ShapeSelector, {\n            shapeType: shapeType,\n            elementProps: elementProps\n        });\n    }\n    if (isActive) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n            className: activeClassName\n        }, shape);\n    }\n    return shape;\n}\n/**\r\n * This is an abstraction to handle identifying the active index from a tooltip mouse interaction\r\n */ function isFunnel(graphicalItem, _item) {\n    return _item != null && 'trapezoids' in graphicalItem.props;\n}\nfunction isPie(graphicalItem, _item) {\n    return _item != null && 'sectors' in graphicalItem.props;\n}\nfunction isScatter(graphicalItem, _item) {\n    return _item != null && 'points' in graphicalItem.props;\n}\nfunction compareFunnel(shapeData, activeTooltipItem) {\n    var _activeTooltipItem$la, _activeTooltipItem$la2;\n    var xMatches = shapeData.x === (activeTooltipItem === null || activeTooltipItem === void 0 || (_activeTooltipItem$la = activeTooltipItem.labelViewBox) === null || _activeTooltipItem$la === void 0 ? void 0 : _activeTooltipItem$la.x) || shapeData.x === activeTooltipItem.x;\n    var yMatches = shapeData.y === (activeTooltipItem === null || activeTooltipItem === void 0 || (_activeTooltipItem$la2 = activeTooltipItem.labelViewBox) === null || _activeTooltipItem$la2 === void 0 ? void 0 : _activeTooltipItem$la2.y) || shapeData.y === activeTooltipItem.y;\n    return xMatches && yMatches;\n}\nfunction comparePie(shapeData, activeTooltipItem) {\n    var startAngleMatches = shapeData.endAngle === activeTooltipItem.endAngle;\n    var endAngleMatches = shapeData.startAngle === activeTooltipItem.startAngle;\n    return startAngleMatches && endAngleMatches;\n}\nfunction compareScatter(shapeData, activeTooltipItem) {\n    var xMatches = shapeData.x === activeTooltipItem.x;\n    var yMatches = shapeData.y === activeTooltipItem.y;\n    var zMatches = shapeData.z === activeTooltipItem.z;\n    return xMatches && yMatches && zMatches;\n}\nfunction getComparisonFn(graphicalItem, activeItem) {\n    var comparison;\n    if (isFunnel(graphicalItem, activeItem)) {\n        comparison = compareFunnel;\n    } else if (isPie(graphicalItem, activeItem)) {\n        comparison = comparePie;\n    } else if (isScatter(graphicalItem, activeItem)) {\n        comparison = compareScatter;\n    }\n    return comparison;\n}\nfunction getShapeDataKey(graphicalItem, activeItem) {\n    var shapeKey;\n    if (isFunnel(graphicalItem, activeItem)) {\n        shapeKey = 'trapezoids';\n    } else if (isPie(graphicalItem, activeItem)) {\n        shapeKey = 'sectors';\n    } else if (isScatter(graphicalItem, activeItem)) {\n        shapeKey = 'points';\n    }\n    return shapeKey;\n}\nfunction getActiveShapeTooltipPayload(graphicalItem, activeItem) {\n    if (isFunnel(graphicalItem, activeItem)) {\n        var _activeItem$tooltipPa;\n        return (_activeItem$tooltipPa = activeItem.tooltipPayload) === null || _activeItem$tooltipPa === void 0 || (_activeItem$tooltipPa = _activeItem$tooltipPa[0]) === null || _activeItem$tooltipPa === void 0 || (_activeItem$tooltipPa = _activeItem$tooltipPa.payload) === null || _activeItem$tooltipPa === void 0 ? void 0 : _activeItem$tooltipPa.payload;\n    }\n    if (isPie(graphicalItem, activeItem)) {\n        var _activeItem$tooltipPa2;\n        return (_activeItem$tooltipPa2 = activeItem.tooltipPayload) === null || _activeItem$tooltipPa2 === void 0 || (_activeItem$tooltipPa2 = _activeItem$tooltipPa2[0]) === null || _activeItem$tooltipPa2 === void 0 || (_activeItem$tooltipPa2 = _activeItem$tooltipPa2.payload) === null || _activeItem$tooltipPa2 === void 0 ? void 0 : _activeItem$tooltipPa2.payload;\n    }\n    if (isScatter(graphicalItem, activeItem)) {\n        return activeItem.payload;\n    }\n    return {};\n}\n/**\r\n *\r\n * @param {GetActiveShapeIndexForTooltip} arg an object of incoming attributes from Tooltip\r\n * @returns {number}\r\n *\r\n * To handle possible duplicates in the data set,\r\n * match both the data value of the active item to a data value on a graph item,\r\n * and match the mouse coordinates of the active item to the coordinates of in a particular components shape data.\r\n * This assumes equal lengths of shape objects to data items.\r\n */ function getActiveShapeIndexForTooltip(_ref3) {\n    var activeTooltipItem = _ref3.activeTooltipItem, graphicalItem = _ref3.graphicalItem, itemData = _ref3.itemData;\n    var shapeKey = getShapeDataKey(graphicalItem, activeTooltipItem);\n    var tooltipPayload = getActiveShapeTooltipPayload(graphicalItem, activeTooltipItem);\n    var activeItemMatches = itemData.filter(function(datum, dataIndex) {\n        var valuesMatch = (0, _isEqual[\"default\"])(tooltipPayload, datum);\n        var mouseCoordinateMatches = graphicalItem.props[shapeKey].filter(function(shapeData) {\n            var comparison = getComparisonFn(graphicalItem, activeTooltipItem);\n            return comparison(shapeData, activeTooltipItem);\n        });\n        // get the last index in case of multiple matches\n        var indexOfMouseCoordinates = graphicalItem.props[shapeKey].indexOf(mouseCoordinateMatches[mouseCoordinateMatches.length - 1]);\n        var coordinatesMatch = dataIndex === indexOfMouseCoordinates;\n        return valuesMatch && coordinatesMatch;\n    });\n    // get the last index in case of multiple matches\n    var activeIndex = itemData.indexOf(activeItemMatches[activeItemMatches.length - 1]);\n    return activeIndex;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9BY3RpdmVTaGFwZVV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxhQUFhLEdBQUdFO0FBQ2hCRixxQkFBcUIsR0FBR0c7QUFDeEJILGtCQUFrQixHQUFHSTtBQUNyQkosc0JBQXNCLEdBQUdLO0FBQ3pCTCxxQ0FBcUMsR0FBR007QUFDeENOLCtCQUErQixHQUFHTztBQUNsQ1AsZ0JBQWdCLEdBQUdRO0FBQ25CUixhQUFhLEdBQUdTO0FBQ2hCVCxpQkFBaUIsR0FBR1U7QUFDcEIsSUFBSUMsU0FBU0Msd0JBQXdCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNwRCxJQUFJQyxjQUFjQyx1QkFBdUJGLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJRyxpQkFBaUJELHVCQUF1QkYsbUJBQU9BLENBQUMsa0RBQXNCO0FBQzFFLElBQUlJLGFBQWFGLHVCQUF1QkYsbUJBQU9BLENBQUMsMENBQWtCO0FBQ2xFLElBQUlLLFdBQVdILHVCQUF1QkYsbUJBQU9BLENBQUMsc0NBQWdCO0FBQzlELElBQUlNLGFBQWFOLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUM3QyxJQUFJTyxhQUFhUCxtQkFBT0EsQ0FBQywyRkFBb0I7QUFDN0MsSUFBSVEsVUFBVVIsbUJBQU9BLENBQUMscUZBQWlCO0FBQ3ZDLElBQUlTLFNBQVNULG1CQUFPQSxDQUFDLDJGQUFvQjtBQUN6QyxJQUFJVSxXQUFXVixtQkFBT0EsQ0FBQyx1RkFBa0I7QUFDekMsSUFBSVcsWUFBWTtJQUFDO0lBQVU7SUFBYTtJQUFtQjtJQUFtQjtDQUFXO0FBQ3pGLFNBQVNULHVCQUF1QlUsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSx5QkFBeUJDLENBQUM7SUFBSSxJ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SCxLQUFLO0lBQzFDLElBQUl4QixvQkFBb0J3QixNQUFNeEIsaUJBQWlCLEVBQzdDSCxnQkFBZ0IyQixNQUFNM0IsYUFBYSxFQUNuQzRCLFdBQVdELE1BQU1DLFFBQVE7SUFDM0IsSUFBSVAsV0FBV0QsZ0JBQWdCcEIsZUFBZUc7SUFDOUMsSUFBSXFCLGlCQUFpQkYsNkJBQTZCdEIsZUFBZUc7SUFDakUsSUFBSTBCLG9CQUFvQkQsU0FBU3hFLE1BQU0sQ0FBQyxTQUFVMEUsS0FBSyxFQUFFQyxTQUFTO1FBQ2hFLElBQUlDLGNBQWMsQ0FBQyxHQUFHdkgsUUFBUSxDQUFDLFVBQVUsRUFBRStHLGdCQUFnQk07UUFDM0QsSUFBSUcseUJBQXlCakMsY0FBY3hCLEtBQUssQ0FBQzZDLFNBQVMsQ0FBQ2pFLE1BQU0sQ0FBQyxTQUFVOEMsU0FBUztZQUNuRixJQUFJaUIsYUFBYUYsZ0JBQWdCakIsZUFBZUc7WUFDaEQsT0FBT2dCLFdBQVdqQixXQUFXQztRQUMvQjtRQUVBLGlEQUFpRDtRQUNqRCxJQUFJK0IsMEJBQTBCbEMsY0FBY3hCLEtBQUssQ0FBQzZDLFNBQVMsQ0FBQ3JFLE9BQU8sQ0FBQ2lGLHNCQUFzQixDQUFDQSx1QkFBdUJsRixNQUFNLEdBQUcsRUFBRTtRQUM3SCxJQUFJb0YsbUJBQW1CSixjQUFjRztRQUNyQyxPQUFPRixlQUFlRztJQUN4QjtJQUVBLGlEQUFpRDtJQUNqRCxJQUFJQyxjQUFjUixTQUFTNUUsT0FBTyxDQUFDNkUsaUJBQWlCLENBQUNBLGtCQUFrQjlFLE1BQU0sR0FBRyxFQUFFO0lBQ2xGLE9BQU9xRjtBQUNUIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFx1dGlsXFxBY3RpdmVTaGFwZVV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuU2hhcGUgPSBTaGFwZTtcclxuZXhwb3J0cy5jb21wYXJlRnVubmVsID0gY29tcGFyZUZ1bm5lbDtcclxuZXhwb3J0cy5jb21wYXJlUGllID0gY29tcGFyZVBpZTtcclxuZXhwb3J0cy5jb21wYXJlU2NhdHRlciA9IGNvbXBhcmVTY2F0dGVyO1xyXG5leHBvcnRzLmdldEFjdGl2ZVNoYXBlSW5kZXhGb3JUb29sdGlwID0gZ2V0QWN0aXZlU2hhcGVJbmRleEZvclRvb2x0aXA7XHJcbmV4cG9ydHMuZ2V0UHJvcHNGcm9tU2hhcGVPcHRpb24gPSBnZXRQcm9wc0Zyb21TaGFwZU9wdGlvbjtcclxuZXhwb3J0cy5pc0Z1bm5lbCA9IGlzRnVubmVsO1xyXG5leHBvcnRzLmlzUGllID0gaXNQaWU7XHJcbmV4cG9ydHMuaXNTY2F0dGVyID0gaXNTY2F0dGVyO1xyXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xyXG52YXIgX2lzUGxhaW5PYmplY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiKSk7XHJcbnZhciBfaXNCb29sZWFuID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzQm9vbGVhblwiKSk7XHJcbnZhciBfaXNFcXVhbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0VxdWFsXCIpKTtcclxudmFyIF9SZWN0YW5nbGUgPSByZXF1aXJlKFwiLi4vc2hhcGUvUmVjdGFuZ2xlXCIpO1xyXG52YXIgX1RyYXBlem9pZCA9IHJlcXVpcmUoXCIuLi9zaGFwZS9UcmFwZXpvaWRcIik7XHJcbnZhciBfU2VjdG9yID0gcmVxdWlyZShcIi4uL3NoYXBlL1NlY3RvclwiKTtcclxudmFyIF9MYXllciA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvTGF5ZXJcIik7XHJcbnZhciBfU3ltYm9scyA9IHJlcXVpcmUoXCIuLi9zaGFwZS9TeW1ib2xzXCIpO1xyXG52YXIgX2V4Y2x1ZGVkID0gW1wib3B0aW9uXCIsIFwic2hhcGVUeXBlXCIsIFwicHJvcFRyYW5zZm9ybWVyXCIsIFwiYWN0aXZlQ2xhc3NOYW1lXCIsIFwiaXNBY3RpdmVcIl07XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cclxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxyXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxyXG4vKipcclxuICogVGhpcyBpcyBhbiBhYnN0cmFjdGlvbiBmb3IgcmVuZGVyaW5nIGEgdXNlciBkZWZpbmVkIHByb3AgZm9yIGEgY3VzdG9taXplZCBzaGFwZSBpbiBzZXZlcmFsIGZvcm1zLlxyXG4gKlxyXG4gKiA8U2hhcGUgLz4gaXMgdGhlIHJvb3QgYW5kIHdpbGwgaGFuZGxlIHRha2luZyBpbjpcclxuICogIC0gYW4gb2JqZWN0IG9mIHN2ZyBwcm9wZXJ0aWVzXHJcbiAqICAtIGEgYm9vbGVhblxyXG4gKiAgLSBhIHJlbmRlciBwcm9wKGlubGluZSBmdW5jdGlvbiB0aGF0IHJldHVybnMganN4KVxyXG4gKiAgLSBhIHJlYWN0IGVsZW1lbnRcclxuICpcclxuICogPFNoYXBlU2VsZWN0b3IgLz4gaXMgYSBzdWJjb21wb25lbnQgb2YgPFNoYXBlIC8+IGFuZCB1c2VkIHRvIG1hdGNoIGEgY29tcG9uZW50XHJcbiAqIHRvIHRoZSB2YWx1ZSBvZiBwcm9wcy5zaGFwZVR5cGUgdGhhdCBpcyBwYXNzZWQgdG8gdGhlIHJvb3QuXHJcbiAqXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gZGVmYXVsdFByb3BUcmFuc2Zvcm1lcihvcHRpb24sIHByb3BzKSB7XHJcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCBvcHRpb24pO1xyXG59XHJcbmZ1bmN0aW9uIGlzU3ltYm9sc1Byb3BzKHNoYXBlVHlwZSwgX2VsZW1lbnRQcm9wcykge1xyXG4gIHJldHVybiBzaGFwZVR5cGUgPT09ICdzeW1ib2xzJztcclxufVxyXG5mdW5jdGlvbiBTaGFwZVNlbGVjdG9yKF9yZWYpIHtcclxuICB2YXIgc2hhcGVUeXBlID0gX3JlZi5zaGFwZVR5cGUsXHJcbiAgICBlbGVtZW50UHJvcHMgPSBfcmVmLmVsZW1lbnRQcm9wcztcclxuICBzd2l0Y2ggKHNoYXBlVHlwZSkge1xyXG4gICAgY2FzZSAncmVjdGFuZ2xlJzpcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX1JlY3RhbmdsZS5SZWN0YW5nbGUsIGVsZW1lbnRQcm9wcyk7XHJcbiAgICBjYXNlICd0cmFwZXpvaWQnOlxyXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfVHJhcGV6b2lkLlRyYXBlem9pZCwgZWxlbWVudFByb3BzKTtcclxuICAgIGNhc2UgJ3NlY3Rvcic6XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9TZWN0b3IuU2VjdG9yLCBlbGVtZW50UHJvcHMpO1xyXG4gICAgY2FzZSAnc3ltYm9scyc6XHJcbiAgICAgIGlmIChpc1N5bWJvbHNQcm9wcyhzaGFwZVR5cGUsIGVsZW1lbnRQcm9wcykpIHtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfU3ltYm9scy5TeW1ib2xzLCBlbGVtZW50UHJvcHMpO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFByb3BzRnJvbVNoYXBlT3B0aW9uKG9wdGlvbikge1xyXG4gIGlmICggLyojX19QVVJFX18qLygwLCBfcmVhY3QuaXNWYWxpZEVsZW1lbnQpKG9wdGlvbikpIHtcclxuICAgIHJldHVybiBvcHRpb24ucHJvcHM7XHJcbiAgfVxyXG4gIHJldHVybiBvcHRpb247XHJcbn1cclxuZnVuY3Rpb24gU2hhcGUoX3JlZjIpIHtcclxuICB2YXIgb3B0aW9uID0gX3JlZjIub3B0aW9uLFxyXG4gICAgc2hhcGVUeXBlID0gX3JlZjIuc2hhcGVUeXBlLFxyXG4gICAgX3JlZjIkcHJvcFRyYW5zZm9ybWVyID0gX3JlZjIucHJvcFRyYW5zZm9ybWVyLFxyXG4gICAgcHJvcFRyYW5zZm9ybWVyID0gX3JlZjIkcHJvcFRyYW5zZm9ybWVyID09PSB2b2lkIDAgPyBkZWZhdWx0UHJvcFRyYW5zZm9ybWVyIDogX3JlZjIkcHJvcFRyYW5zZm9ybWVyLFxyXG4gICAgX3JlZjIkYWN0aXZlQ2xhc3NOYW1lID0gX3JlZjIuYWN0aXZlQ2xhc3NOYW1lLFxyXG4gICAgYWN0aXZlQ2xhc3NOYW1lID0gX3JlZjIkYWN0aXZlQ2xhc3NOYW1lID09PSB2b2lkIDAgPyAncmVjaGFydHMtYWN0aXZlLXNoYXBlJyA6IF9yZWYyJGFjdGl2ZUNsYXNzTmFtZSxcclxuICAgIGlzQWN0aXZlID0gX3JlZjIuaXNBY3RpdmUsXHJcbiAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgX2V4Y2x1ZGVkKTtcclxuICB2YXIgc2hhcGU7XHJcbiAgaWYgKCAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5pc1ZhbGlkRWxlbWVudCkob3B0aW9uKSkge1xyXG4gICAgc2hhcGUgPSAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jbG9uZUVsZW1lbnQpKG9wdGlvbiwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIGdldFByb3BzRnJvbVNoYXBlT3B0aW9uKG9wdGlvbikpKTtcclxuICB9IGVsc2UgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9wdGlvbikpIHtcclxuICAgIHNoYXBlID0gb3B0aW9uKHByb3BzKTtcclxuICB9IGVsc2UgaWYgKCgwLCBfaXNQbGFpbk9iamVjdFtcImRlZmF1bHRcIl0pKG9wdGlvbikgJiYgISgwLCBfaXNCb29sZWFuW1wiZGVmYXVsdFwiXSkob3B0aW9uKSkge1xyXG4gICAgdmFyIG5leHRQcm9wcyA9IHByb3BUcmFuc2Zvcm1lcihvcHRpb24sIHByb3BzKTtcclxuICAgIHNoYXBlID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChTaGFwZVNlbGVjdG9yLCB7XHJcbiAgICAgIHNoYXBlVHlwZTogc2hhcGVUeXBlLFxyXG4gICAgICBlbGVtZW50UHJvcHM6IG5leHRQcm9wc1xyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBlbGVtZW50UHJvcHMgPSBwcm9wcztcclxuICAgIHNoYXBlID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChTaGFwZVNlbGVjdG9yLCB7XHJcbiAgICAgIHNoYXBlVHlwZTogc2hhcGVUeXBlLFxyXG4gICAgICBlbGVtZW50UHJvcHM6IGVsZW1lbnRQcm9wc1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGlmIChpc0FjdGl2ZSkge1xyXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogYWN0aXZlQ2xhc3NOYW1lXHJcbiAgICB9LCBzaGFwZSk7XHJcbiAgfVxyXG4gIHJldHVybiBzaGFwZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgYW4gYWJzdHJhY3Rpb24gdG8gaGFuZGxlIGlkZW50aWZ5aW5nIHRoZSBhY3RpdmUgaW5kZXggZnJvbSBhIHRvb2x0aXAgbW91c2UgaW50ZXJhY3Rpb25cclxuICovXHJcblxyXG5mdW5jdGlvbiBpc0Z1bm5lbChncmFwaGljYWxJdGVtLCBfaXRlbSkge1xyXG4gIHJldHVybiBfaXRlbSAhPSBudWxsICYmICd0cmFwZXpvaWRzJyBpbiBncmFwaGljYWxJdGVtLnByb3BzO1xyXG59XHJcbmZ1bmN0aW9uIGlzUGllKGdyYXBoaWNhbEl0ZW0sIF9pdGVtKSB7XHJcbiAgcmV0dXJuIF9pdGVtICE9IG51bGwgJiYgJ3NlY3RvcnMnIGluIGdyYXBoaWNhbEl0ZW0ucHJvcHM7XHJcbn1cclxuZnVuY3Rpb24gaXNTY2F0dGVyKGdyYXBoaWNhbEl0ZW0sIF9pdGVtKSB7XHJcbiAgcmV0dXJuIF9pdGVtICE9IG51bGwgJiYgJ3BvaW50cycgaW4gZ3JhcGhpY2FsSXRlbS5wcm9wcztcclxufVxyXG5mdW5jdGlvbiBjb21wYXJlRnVubmVsKHNoYXBlRGF0YSwgYWN0aXZlVG9vbHRpcEl0ZW0pIHtcclxuICB2YXIgX2FjdGl2ZVRvb2x0aXBJdGVtJGxhLCBfYWN0aXZlVG9vbHRpcEl0ZW0kbGEyO1xyXG4gIHZhciB4TWF0Y2hlcyA9IHNoYXBlRGF0YS54ID09PSAoYWN0aXZlVG9vbHRpcEl0ZW0gPT09IG51bGwgfHwgYWN0aXZlVG9vbHRpcEl0ZW0gPT09IHZvaWQgMCB8fCAoX2FjdGl2ZVRvb2x0aXBJdGVtJGxhID0gYWN0aXZlVG9vbHRpcEl0ZW0ubGFiZWxWaWV3Qm94KSA9PT0gbnVsbCB8fCBfYWN0aXZlVG9vbHRpcEl0ZW0kbGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hY3RpdmVUb29sdGlwSXRlbSRsYS54KSB8fCBzaGFwZURhdGEueCA9PT0gYWN0aXZlVG9vbHRpcEl0ZW0ueDtcclxuICB2YXIgeU1hdGNoZXMgPSBzaGFwZURhdGEueSA9PT0gKGFjdGl2ZVRvb2x0aXBJdGVtID09PSBudWxsIHx8IGFjdGl2ZVRvb2x0aXBJdGVtID09PSB2b2lkIDAgfHwgKF9hY3RpdmVUb29sdGlwSXRlbSRsYTIgPSBhY3RpdmVUb29sdGlwSXRlbS5sYWJlbFZpZXdCb3gpID09PSBudWxsIHx8IF9hY3RpdmVUb29sdGlwSXRlbSRsYTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hY3RpdmVUb29sdGlwSXRlbSRsYTIueSkgfHwgc2hhcGVEYXRhLnkgPT09IGFjdGl2ZVRvb2x0aXBJdGVtLnk7XHJcbiAgcmV0dXJuIHhNYXRjaGVzICYmIHlNYXRjaGVzO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXBhcmVQaWUoc2hhcGVEYXRhLCBhY3RpdmVUb29sdGlwSXRlbSkge1xyXG4gIHZhciBzdGFydEFuZ2xlTWF0Y2hlcyA9IHNoYXBlRGF0YS5lbmRBbmdsZSA9PT0gYWN0aXZlVG9vbHRpcEl0ZW0uZW5kQW5nbGU7XHJcbiAgdmFyIGVuZEFuZ2xlTWF0Y2hlcyA9IHNoYXBlRGF0YS5zdGFydEFuZ2xlID09PSBhY3RpdmVUb29sdGlwSXRlbS5zdGFydEFuZ2xlO1xyXG4gIHJldHVybiBzdGFydEFuZ2xlTWF0Y2hlcyAmJiBlbmRBbmdsZU1hdGNoZXM7XHJcbn1cclxuZnVuY3Rpb24gY29tcGFyZVNjYXR0ZXIoc2hhcGVEYXRhLCBhY3RpdmVUb29sdGlwSXRlbSkge1xyXG4gIHZhciB4TWF0Y2hlcyA9IHNoYXBlRGF0YS54ID09PSBhY3RpdmVUb29sdGlwSXRlbS54O1xyXG4gIHZhciB5TWF0Y2hlcyA9IHNoYXBlRGF0YS55ID09PSBhY3RpdmVUb29sdGlwSXRlbS55O1xyXG4gIHZhciB6TWF0Y2hlcyA9IHNoYXBlRGF0YS56ID09PSBhY3RpdmVUb29sdGlwSXRlbS56O1xyXG4gIHJldHVybiB4TWF0Y2hlcyAmJiB5TWF0Y2hlcyAmJiB6TWF0Y2hlcztcclxufVxyXG5mdW5jdGlvbiBnZXRDb21wYXJpc29uRm4oZ3JhcGhpY2FsSXRlbSwgYWN0aXZlSXRlbSkge1xyXG4gIHZhciBjb21wYXJpc29uO1xyXG4gIGlmIChpc0Z1bm5lbChncmFwaGljYWxJdGVtLCBhY3RpdmVJdGVtKSkge1xyXG4gICAgY29tcGFyaXNvbiA9IGNvbXBhcmVGdW5uZWw7XHJcbiAgfSBlbHNlIGlmIChpc1BpZShncmFwaGljYWxJdGVtLCBhY3RpdmVJdGVtKSkge1xyXG4gICAgY29tcGFyaXNvbiA9IGNvbXBhcmVQaWU7XHJcbiAgfSBlbHNlIGlmIChpc1NjYXR0ZXIoZ3JhcGhpY2FsSXRlbSwgYWN0aXZlSXRlbSkpIHtcclxuICAgIGNvbXBhcmlzb24gPSBjb21wYXJlU2NhdHRlcjtcclxuICB9XHJcbiAgcmV0dXJuIGNvbXBhcmlzb247XHJcbn1cclxuZnVuY3Rpb24gZ2V0U2hhcGVEYXRhS2V5KGdyYXBoaWNhbEl0ZW0sIGFjdGl2ZUl0ZW0pIHtcclxuICB2YXIgc2hhcGVLZXk7XHJcbiAgaWYgKGlzRnVubmVsKGdyYXBoaWNhbEl0ZW0sIGFjdGl2ZUl0ZW0pKSB7XHJcbiAgICBzaGFwZUtleSA9ICd0cmFwZXpvaWRzJztcclxuICB9IGVsc2UgaWYgKGlzUGllKGdyYXBoaWNhbEl0ZW0sIGFjdGl2ZUl0ZW0pKSB7XHJcbiAgICBzaGFwZUtleSA9ICdzZWN0b3JzJztcclxuICB9IGVsc2UgaWYgKGlzU2NhdHRlcihncmFwaGljYWxJdGVtLCBhY3RpdmVJdGVtKSkge1xyXG4gICAgc2hhcGVLZXkgPSAncG9pbnRzJztcclxuICB9XHJcbiAgcmV0dXJuIHNoYXBlS2V5O1xyXG59XHJcbmZ1bmN0aW9uIGdldEFjdGl2ZVNoYXBlVG9vbHRpcFBheWxvYWQoZ3JhcGhpY2FsSXRlbSwgYWN0aXZlSXRlbSkge1xyXG4gIGlmIChpc0Z1bm5lbChncmFwaGljYWxJdGVtLCBhY3RpdmVJdGVtKSkge1xyXG4gICAgdmFyIF9hY3RpdmVJdGVtJHRvb2x0aXBQYTtcclxuICAgIHJldHVybiAoX2FjdGl2ZUl0ZW0kdG9vbHRpcFBhID0gYWN0aXZlSXRlbS50b29sdGlwUGF5bG9hZCkgPT09IG51bGwgfHwgX2FjdGl2ZUl0ZW0kdG9vbHRpcFBhID09PSB2b2lkIDAgfHwgKF9hY3RpdmVJdGVtJHRvb2x0aXBQYSA9IF9hY3RpdmVJdGVtJHRvb2x0aXBQYVswXSkgPT09IG51bGwgfHwgX2FjdGl2ZUl0ZW0kdG9vbHRpcFBhID09PSB2b2lkIDAgfHwgKF9hY3RpdmVJdGVtJHRvb2x0aXBQYSA9IF9hY3RpdmVJdGVtJHRvb2x0aXBQYS5wYXlsb2FkKSA9PT0gbnVsbCB8fCBfYWN0aXZlSXRlbSR0b29sdGlwUGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hY3RpdmVJdGVtJHRvb2x0aXBQYS5wYXlsb2FkO1xyXG4gIH1cclxuICBpZiAoaXNQaWUoZ3JhcGhpY2FsSXRlbSwgYWN0aXZlSXRlbSkpIHtcclxuICAgIHZhciBfYWN0aXZlSXRlbSR0b29sdGlwUGEyO1xyXG4gICAgcmV0dXJuIChfYWN0aXZlSXRlbSR0b29sdGlwUGEyID0gYWN0aXZlSXRlbS50b29sdGlwUGF5bG9hZCkgPT09IG51bGwgfHwgX2FjdGl2ZUl0ZW0kdG9vbHRpcFBhMiA9PT0gdm9pZCAwIHx8IChfYWN0aXZlSXRlbSR0b29sdGlwUGEyID0gX2FjdGl2ZUl0ZW0kdG9vbHRpcFBhMlswXSkgPT09IG51bGwgfHwgX2FjdGl2ZUl0ZW0kdG9vbHRpcFBhMiA9PT0gdm9pZCAwIHx8IChfYWN0aXZlSXRlbSR0b29sdGlwUGEyID0gX2FjdGl2ZUl0ZW0kdG9vbHRpcFBhMi5wYXlsb2FkKSA9PT0gbnVsbCB8fCBfYWN0aXZlSXRlbSR0b29sdGlwUGEyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYWN0aXZlSXRlbSR0b29sdGlwUGEyLnBheWxvYWQ7XHJcbiAgfVxyXG4gIGlmIChpc1NjYXR0ZXIoZ3JhcGhpY2FsSXRlbSwgYWN0aXZlSXRlbSkpIHtcclxuICAgIHJldHVybiBhY3RpdmVJdGVtLnBheWxvYWQ7XHJcbiAgfVxyXG4gIHJldHVybiB7fTtcclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHtHZXRBY3RpdmVTaGFwZUluZGV4Rm9yVG9vbHRpcH0gYXJnIGFuIG9iamVjdCBvZiBpbmNvbWluZyBhdHRyaWJ1dGVzIGZyb20gVG9vbHRpcFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKlxyXG4gKiBUbyBoYW5kbGUgcG9zc2libGUgZHVwbGljYXRlcyBpbiB0aGUgZGF0YSBzZXQsXHJcbiAqIG1hdGNoIGJvdGggdGhlIGRhdGEgdmFsdWUgb2YgdGhlIGFjdGl2ZSBpdGVtIHRvIGEgZGF0YSB2YWx1ZSBvbiBhIGdyYXBoIGl0ZW0sXHJcbiAqIGFuZCBtYXRjaCB0aGUgbW91c2UgY29vcmRpbmF0ZXMgb2YgdGhlIGFjdGl2ZSBpdGVtIHRvIHRoZSBjb29yZGluYXRlcyBvZiBpbiBhIHBhcnRpY3VsYXIgY29tcG9uZW50cyBzaGFwZSBkYXRhLlxyXG4gKiBUaGlzIGFzc3VtZXMgZXF1YWwgbGVuZ3RocyBvZiBzaGFwZSBvYmplY3RzIHRvIGRhdGEgaXRlbXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBY3RpdmVTaGFwZUluZGV4Rm9yVG9vbHRpcChfcmVmMykge1xyXG4gIHZhciBhY3RpdmVUb29sdGlwSXRlbSA9IF9yZWYzLmFjdGl2ZVRvb2x0aXBJdGVtLFxyXG4gICAgZ3JhcGhpY2FsSXRlbSA9IF9yZWYzLmdyYXBoaWNhbEl0ZW0sXHJcbiAgICBpdGVtRGF0YSA9IF9yZWYzLml0ZW1EYXRhO1xyXG4gIHZhciBzaGFwZUtleSA9IGdldFNoYXBlRGF0YUtleShncmFwaGljYWxJdGVtLCBhY3RpdmVUb29sdGlwSXRlbSk7XHJcbiAgdmFyIHRvb2x0aXBQYXlsb2FkID0gZ2V0QWN0aXZlU2hhcGVUb29sdGlwUGF5bG9hZChncmFwaGljYWxJdGVtLCBhY3RpdmVUb29sdGlwSXRlbSk7XHJcbiAgdmFyIGFjdGl2ZUl0ZW1NYXRjaGVzID0gaXRlbURhdGEuZmlsdGVyKGZ1bmN0aW9uIChkYXR1bSwgZGF0YUluZGV4KSB7XHJcbiAgICB2YXIgdmFsdWVzTWF0Y2ggPSAoMCwgX2lzRXF1YWxbXCJkZWZhdWx0XCJdKSh0b29sdGlwUGF5bG9hZCwgZGF0dW0pO1xyXG4gICAgdmFyIG1vdXNlQ29vcmRpbmF0ZU1hdGNoZXMgPSBncmFwaGljYWxJdGVtLnByb3BzW3NoYXBlS2V5XS5maWx0ZXIoZnVuY3Rpb24gKHNoYXBlRGF0YSkge1xyXG4gICAgICB2YXIgY29tcGFyaXNvbiA9IGdldENvbXBhcmlzb25GbihncmFwaGljYWxJdGVtLCBhY3RpdmVUb29sdGlwSXRlbSk7XHJcbiAgICAgIHJldHVybiBjb21wYXJpc29uKHNoYXBlRGF0YSwgYWN0aXZlVG9vbHRpcEl0ZW0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gZ2V0IHRoZSBsYXN0IGluZGV4IGluIGNhc2Ugb2YgbXVsdGlwbGUgbWF0Y2hlc1xyXG4gICAgdmFyIGluZGV4T2ZNb3VzZUNvb3JkaW5hdGVzID0gZ3JhcGhpY2FsSXRlbS5wcm9wc1tzaGFwZUtleV0uaW5kZXhPZihtb3VzZUNvb3JkaW5hdGVNYXRjaGVzW21vdXNlQ29vcmRpbmF0ZU1hdGNoZXMubGVuZ3RoIC0gMV0pO1xyXG4gICAgdmFyIGNvb3JkaW5hdGVzTWF0Y2ggPSBkYXRhSW5kZXggPT09IGluZGV4T2ZNb3VzZUNvb3JkaW5hdGVzO1xyXG4gICAgcmV0dXJuIHZhbHVlc01hdGNoICYmIGNvb3JkaW5hdGVzTWF0Y2g7XHJcbiAgfSk7XHJcblxyXG4gIC8vIGdldCB0aGUgbGFzdCBpbmRleCBpbiBjYXNlIG9mIG11bHRpcGxlIG1hdGNoZXNcclxuICB2YXIgYWN0aXZlSW5kZXggPSBpdGVtRGF0YS5pbmRleE9mKGFjdGl2ZUl0ZW1NYXRjaGVzW2FjdGl2ZUl0ZW1NYXRjaGVzLmxlbmd0aCAtIDFdKTtcclxuICByZXR1cm4gYWN0aXZlSW5kZXg7XHJcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTaGFwZSIsImNvbXBhcmVGdW5uZWwiLCJjb21wYXJlUGllIiwiY29tcGFyZVNjYXR0ZXIiLCJnZXRBY3RpdmVTaGFwZUluZGV4Rm9yVG9vbHRpcCIsImdldFByb3BzRnJvbVNoYXBlT3B0aW9uIiwiaXNGdW5uZWwiLCJpc1BpZSIsImlzU2NhdHRlciIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9pc0Z1bmN0aW9uIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9pc1BsYWluT2JqZWN0IiwiX2lzQm9vbGVhbiIsIl9pc0VxdWFsIiwiX1JlY3RhbmdsZSIsIl9UcmFwZXpvaWQiLCJfU2VjdG9yIiwiX0xheWVyIiwiX1N5bWJvbHMiLCJfZXhjbHVkZWQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwicHJvdG90eXBlIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwic291cmNlIiwiZXhjbHVkZWQiLCJ0YXJnZXQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImtleSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNvdXJjZVN5bWJvbEtleXMiLCJsZW5ndGgiLCJpbmRleE9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJvd25LZXlzIiwia2V5cyIsImZpbHRlciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiZGVmYXVsdFByb3BUcmFuc2Zvcm1lciIsIm9wdGlvbiIsInByb3BzIiwiaXNTeW1ib2xzUHJvcHMiLCJzaGFwZVR5cGUiLCJfZWxlbWVudFByb3BzIiwiU2hhcGVTZWxlY3RvciIsIl9yZWYiLCJlbGVtZW50UHJvcHMiLCJjcmVhdGVFbGVtZW50IiwiUmVjdGFuZ2xlIiwiVHJhcGV6b2lkIiwiU2VjdG9yIiwiU3ltYm9scyIsImlzVmFsaWRFbGVtZW50IiwiX3JlZjIiLCJfcmVmMiRwcm9wVHJhbnNmb3JtZXIiLCJwcm9wVHJhbnNmb3JtZXIiLCJfcmVmMiRhY3RpdmVDbGFzc05hbWUiLCJhY3RpdmVDbGFzc05hbWUiLCJpc0FjdGl2ZSIsInNoYXBlIiwiY2xvbmVFbGVtZW50IiwibmV4dFByb3BzIiwiTGF5ZXIiLCJjbGFzc05hbWUiLCJncmFwaGljYWxJdGVtIiwiX2l0ZW0iLCJzaGFwZURhdGEiLCJhY3RpdmVUb29sdGlwSXRlbSIsIl9hY3RpdmVUb29sdGlwSXRlbSRsYSIsIl9hY3RpdmVUb29sdGlwSXRlbSRsYTIiLCJ4TWF0Y2hlcyIsIngiLCJsYWJlbFZpZXdCb3giLCJ5TWF0Y2hlcyIsInkiLCJzdGFydEFuZ2xlTWF0Y2hlcyIsImVuZEFuZ2xlIiwiZW5kQW5nbGVNYXRjaGVzIiwic3RhcnRBbmdsZSIsInpNYXRjaGVzIiwieiIsImdldENvbXBhcmlzb25GbiIsImFjdGl2ZUl0ZW0iLCJjb21wYXJpc29uIiwiZ2V0U2hhcGVEYXRhS2V5Iiwic2hhcGVLZXkiLCJnZXRBY3RpdmVTaGFwZVRvb2x0aXBQYXlsb2FkIiwiX2FjdGl2ZUl0ZW0kdG9vbHRpcFBhIiwidG9vbHRpcFBheWxvYWQiLCJwYXlsb2FkIiwiX2FjdGl2ZUl0ZW0kdG9vbHRpcFBhMiIsIl9yZWYzIiwiaXRlbURhdGEiLCJhY3RpdmVJdGVtTWF0Y2hlcyIsImRhdHVtIiwiZGF0YUluZGV4IiwidmFsdWVzTWF0Y2giLCJtb3VzZUNvb3JkaW5hdGVNYXRjaGVzIiwiaW5kZXhPZk1vdXNlQ29vcmRpbmF0ZXMiLCJjb29yZGluYXRlc01hdGNoIiwiYWN0aXZlSW5kZXgiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/ActiveShapeUtils.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/BarUtils.js":
/*!****************************************************!*\
  !*** ./node_modules/recharts/lib/util/BarUtils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BarRectangle = BarRectangle;\nexports.minPointSizeCallback = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _tinyInvariant = _interopRequireDefault(__webpack_require__(/*! tiny-invariant */ \"tiny-invariant\"));\nvar _ActiveShapeUtils = __webpack_require__(/*! ./ActiveShapeUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ActiveShapeUtils.js\");\nvar _DataUtils = __webpack_require__(/*! ./DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _excluded = [\n    \"x\",\n    \"y\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\n// Rectangle props is expecting x, y, height, width as numbers, name as a string, and radius as a custom type\n// When props are being spread in from a user defined component in Bar,\n// the prop types of an SVGElement have these typed as something else.\n// This function will return the passed in props\n// along with x, y, height as numbers, name as a string, and radius as number | [number, number, number, number]\nfunction typeguardBarRectangleProps(_ref, props) {\n    var xProp = _ref.x, yProp = _ref.y, option = _objectWithoutProperties(_ref, _excluded);\n    var xValue = \"\".concat(xProp);\n    var x = parseInt(xValue, 10);\n    var yValue = \"\".concat(yProp);\n    var y = parseInt(yValue, 10);\n    var heightValue = \"\".concat(props.height || option.height);\n    var height = parseInt(heightValue, 10);\n    var widthValue = \"\".concat(props.width || option.width);\n    var width = parseInt(widthValue, 10);\n    return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, props), option), x ? {\n        x: x\n    } : {}), y ? {\n        y: y\n    } : {}), {}, {\n        height: height,\n        width: width,\n        name: props.name,\n        radius: props.radius\n    });\n}\nfunction BarRectangle(props) {\n    return /*#__PURE__*/ _react[\"default\"].createElement(_ActiveShapeUtils.Shape, _extends({\n        shapeType: \"rectangle\",\n        propTransformer: typeguardBarRectangleProps,\n        activeClassName: \"recharts-active-bar\"\n    }, props));\n}\n/**\r\n * Safely gets minPointSize from from the minPointSize prop if it is a function\r\n * @param minPointSize minPointSize as passed to the Bar component\r\n * @param defaultValue default minPointSize\r\n * @returns minPointSize\r\n */ var minPointSizeCallback = exports.minPointSizeCallback = function minPointSizeCallback(minPointSize) {\n    var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return function(value, index) {\n        if (typeof minPointSize === 'number') return minPointSize;\n        var isValueNumberOrNil = (0, _DataUtils.isNumber)(value) || (0, _DataUtils.isNullish)(value);\n        if (isValueNumberOrNil) {\n            return minPointSize(value, index);\n        }\n        !isValueNumberOrNil ?  true ? (0, _tinyInvariant[\"default\"])(false, \"minPointSize callback function received a value with type of \".concat(_typeof(value), \". Currently only numbers or null/undefined are supported.\")) : 0 : void 0;\n        return defaultValue;\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9CYXJVdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsb0JBQW9CLEdBQUdFO0FBQ3ZCRiw0QkFBNEIsR0FBRyxLQUFLO0FBQ3BDLElBQUlJLFNBQVNDLHVCQUF1QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDbkQsSUFBSUMsaUJBQWlCRix1QkFBdUJDLG1CQUFPQSxDQUFDLHNDQUFnQjtBQUNwRSxJQUFJRSxvQkFBb0JGLG1CQUFPQSxDQUFDLGlHQUFvQjtBQUNwRCxJQUFJRyxhQUFhSCxtQkFBT0EsQ0FBQyxtRkFBYTtBQUN0QyxJQUFJSSxZQUFZO0lBQUM7SUFBSztDQUFJO0FBQzFCLFNBQVNMLHVCQUF1Qk0sR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRSxXQUFXLEtBQUtDLFVBQVVELE1BQU1DLE9BQU9FLFNBQVMsR0FBRyxXQUFXLE9BQU9IO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSTtJQUFhQSxXQUFXcEIsT0FBT3FCLE1BQU0sR0FBR3JCLE9BQU9xQixNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVQyxNQUFNO1FBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUFFLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUFFLElBQUssSUFBSUksT0FBT0QsT0FBUTtnQkFBRSxJQUFJM0IsT0FBT21CLFNBQVMsQ0FBQ1UsY0FBYyxDQUFDQyxJQUFJLENBQUNILFFBQVFDLE1BQU07b0JBQUVMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7Z0JBQUU7WUFBRTtRQUFFO1FBQUUsT0FBT0w7SUFBUTtJQUFHLE9BQU9ILFNBQVNXLEtBQUssQ0FBQyxJQUFJLEVBQUVOO0FBQVk7QUFDbFYsU0FBU08sUUFBUUMsQ0FBQyxFQUFFQyxDQUFDO0lBQUksSUFBSUMsSUFBSW5DLE9BQU9vQyxJQUFJLENBQUNIO0lBQUksSUFBSWpDLE9BQU9xQyxxQkFBcUIsRUFBRTtRQUFFLElBQUlyQixJQUFJaEIsT0FBT3FDLHFCQUFxQixDQUFDSjtRQUFJQyxLQUFNbEIsQ0FBQUEsSUFBSUEsRUFBRXNCLE1BQU0sQ0FBQyxTQUFVSixDQUFDO1lBQUksT0FBT2xDLE9BQU91Qyx3QkFBd0IsQ0FBQ04sR0FBR0MsR0FBR00sVUFBVTtRQUFFLEVBQUMsR0FBSUwsRUFBRU0sSUFBSSxDQUFDVixLQUFLLENBQUNJLEdBQUduQjtJQUFJO0lBQUUsT0FBT21CO0FBQUc7QUFDOVAsU0FBU08sY0FBY1QsQ0FBQztJQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJVCxVQUFVQyxNQUFNLEVBQUVRLElBQUs7UUFBRSxJQUFJQyxJQUFJLFFBQVFWLFNBQVMsQ0FBQ1MsRUFBRSxHQUFHVCxTQUFTLENBQUNTLEVBQUUsR0FBRyxDQUFDO1FBQUdBLElBQUksSUFBSUYsUUFBUWhDLE9BQU9tQyxJQUFJLENBQUMsR0FBR1EsT0FBTyxDQUFDLFNBQVVULENBQUM7WUFBSVUsZ0JBQWdCWCxHQUFHQyxHQUFHQyxDQUFDLENBQUNELEVBQUU7UUFBRyxLQUFLbEMsT0FBTzZDLHlCQUF5QixHQUFHN0MsT0FBTzhDLGdCQUFnQixDQUFDYixHQUFHakMsT0FBTzZDLHlCQUF5QixDQUFDVixNQUFNSCxRQUFRaEMsT0FBT21DLElBQUlRLE9BQU8sQ0FBQyxTQUFVVCxDQUFDO1lBQUlsQyxPQUFPQyxjQUFjLENBQUNnQyxHQUFHQyxHQUFHbEMsT0FBT3VDLHdCQUF3QixDQUFDSixHQUFHRDtRQUFLO0lBQUk7SUFBRSxPQUFPRDtBQUFHO0FBQ3RiLFNBQVNXLGdCQUFnQi9CLEdBQUcsRUFBRWUsR0FBRyxFQUFFekIsS0FBSztJQUFJeUIsTUFBTW1CLGVBQWVuQjtJQUFNLElBQUlBLE9BQU9mLEtBQUs7UUFBRWIsT0FBT0MsY0FBYyxDQUFDWSxLQUFLZSxLQUFLO1lBQUV6QixPQUFPQTtZQUFPcUMsWUFBWTtZQUFNUSxjQUFjO1lBQU1DLFVBQVU7UUFBSztJQUFJLE9BQU87UUFBRXBDLEdBQUcsQ0FBQ2UsSUFBSSxHQUFHekI7SUFBTztJQUFFLE9BQU9VO0FBQUs7QUFDM08sU0FBU2tDLGVBQWVaLENBQUM7SUFBSSxJQUFJWCxJQUFJMEIsYUFBYWYsR0FBRztJQUFXLE9BQU8sWUFBWXBCLFFBQVFTLEtBQUtBLElBQUlBLElBQUk7QUFBSTtBQUM1RyxTQUFTMEIsYUFBYWYsQ0FBQyxFQUFFRCxDQUFDO0lBQUksSUFBSSxZQUFZbkIsUUFBUW9CLE1BQU0sQ0FBQ0EsR0FBRyxPQUFPQTtJQUFHLElBQUlGLElBQUlFLENBQUMsQ0FBQ2xCLE9BQU9rQyxXQUFXLENBQUM7SUFBRSxJQUFJLEtBQUssTUFBTWxCLEdBQUc7UUFBRSxJQUFJVCxJQUFJUyxFQUFFSCxJQUFJLENBQUNLLEdBQUdELEtBQUs7UUFBWSxJQUFJLFlBQVluQixRQUFRUyxJQUFJLE9BQU9BO1FBQUcsTUFBTSxJQUFJNEIsVUFBVTtJQUFpRDtJQUFFLE9BQU8sQ0FBQyxhQUFhbEIsSUFBSW1CLFNBQVNDLE1BQUssRUFBR25CO0FBQUk7QUFDM1QsU0FBU29CLHlCQUF5QjVCLE1BQU0sRUFBRTZCLFFBQVE7SUFBSSxJQUFJN0IsVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUFHLElBQUlKLFNBQVNrQyw4QkFBOEI5QixRQUFRNkI7SUFBVyxJQUFJNUIsS0FBS0o7SUFBRyxJQUFJeEIsT0FBT3FDLHFCQUFxQixFQUFFO1FBQUUsSUFBSXFCLG1CQUFtQjFELE9BQU9xQyxxQkFBcUIsQ0FBQ1Y7UUFBUyxJQUFLSCxJQUFJLEdBQUdBLElBQUlrQyxpQkFBaUJoQyxNQUFNLEVBQUVGLElBQUs7WUFBRUksTUFBTThCLGdCQUFnQixDQUFDbEMsRUFBRTtZQUFFLElBQUlnQyxTQUFTRyxPQUFPLENBQUMvQixRQUFRLEdBQUc7WUFBVSxJQUFJLENBQUM1QixPQUFPbUIsU0FBUyxDQUFDeUMsb0JBQW9CLENBQUM5QixJQUFJLENBQUNILFFBQVFDLE1BQU07WUFBVUwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtRQUFFO0lBQUU7SUFBRSxPQUFPTDtBQUFRO0FBQzNlLFNBQVNrQyw4QkFBOEI5QixNQUFNLEVBQUU2QixRQUFRO0lBQUksSUFBSTdCLFVBQVUsTUFBTSxPQUFPLENBQUM7SUFBRyxJQUFJSixTQUFTLENBQUM7SUFBRyxJQUFLLElBQUlLLE9BQU9ELE9BQVE7UUFBRSxJQUFJM0IsT0FBT21CLFNBQVMsQ0FBQ1UsY0FBYyxDQUFDQyxJQUFJLENBQUNILFFBQVFDLE1BQU07WUFBRSxJQUFJNEIsU0FBU0csT0FBTyxDQUFDL0IsUUFBUSxHQUFHO1lBQVVMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7UUFBRTtJQUFFO0lBQUUsT0FBT0w7QUFBUTtBQUN0Uiw2R0FBNkc7QUFDN0csdUVBQXVFO0FBQ3ZFLHNFQUFzRTtBQUN0RSxnREFBZ0Q7QUFDaEQsZ0hBQWdIO0FBQ2hILFNBQVNzQywyQkFBMkJDLElBQUksRUFBRUMsS0FBSztJQUM3QyxJQUFJQyxRQUFRRixLQUFLRyxDQUFDLEVBQ2hCQyxRQUFRSixLQUFLSyxDQUFDLEVBQ2RDLFNBQVNiLHlCQUF5Qk8sTUFBTWxEO0lBQzFDLElBQUl5RCxTQUFTLEdBQUdDLE1BQU0sQ0FBQ047SUFDdkIsSUFBSUMsSUFBSU0sU0FBU0YsUUFBUTtJQUN6QixJQUFJRyxTQUFTLEdBQUdGLE1BQU0sQ0FBQ0o7SUFDdkIsSUFBSUMsSUFBSUksU0FBU0MsUUFBUTtJQUN6QixJQUFJQyxjQUFjLEdBQUdILE1BQU0sQ0FBQ1AsTUFBTVcsTUFBTSxJQUFJTixPQUFPTSxNQUFNO0lBQ3pELElBQUlBLFNBQVNILFNBQVNFLGFBQWE7SUFDbkMsSUFBSUUsYUFBYSxHQUFHTCxNQUFNLENBQUNQLE1BQU1hLEtBQUssSUFBSVIsT0FBT1EsS0FBSztJQUN0RCxJQUFJQSxRQUFRTCxTQUFTSSxZQUFZO0lBQ2pDLE9BQU9qQyxjQUFjQSxjQUFjQSxjQUFjQSxjQUFjQSxjQUFjLENBQUMsR0FBR3FCLFFBQVFLLFNBQVNILElBQUk7UUFDcEdBLEdBQUdBO0lBQ0wsSUFBSSxDQUFDLElBQUlFLElBQUk7UUFDWEEsR0FBR0E7SUFDTCxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUc7UUFDWE8sUUFBUUE7UUFDUkUsT0FBT0E7UUFDUEMsTUFBTWQsTUFBTWMsSUFBSTtRQUNoQkMsUUFBUWYsTUFBTWUsTUFBTTtJQUN0QjtBQUNGO0FBQ0EsU0FBUzFFLGFBQWEyRCxLQUFLO0lBQ3pCLE9BQU8sV0FBVyxHQUFFekQsTUFBTSxDQUFDLFVBQVUsQ0FBQ3lFLGFBQWEsQ0FBQ3JFLGtCQUFrQnNFLEtBQUssRUFBRTVELFNBQVM7UUFDcEY2RCxXQUFXO1FBQ1hDLGlCQUFpQnJCO1FBQ2pCc0IsaUJBQWlCO0lBQ25CLEdBQUdwQjtBQUNMO0FBQ0E7Ozs7O0NBS0MsR0FDRCxJQUFJMUQsdUJBQXVCSCw0QkFBNEIsR0FBRyxTQUFTRyxxQkFBcUIrRSxZQUFZO0lBQ2xHLElBQUlDLGVBQWU1RCxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBSzZELFlBQVk3RCxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQ3ZGLE9BQU8sU0FBVXRCLEtBQUssRUFBRW9GLEtBQUs7UUFDM0IsSUFBSSxPQUFPSCxpQkFBaUIsVUFBVSxPQUFPQTtRQUM3QyxJQUFJSSxxQkFBcUIsQ0FBQyxHQUFHN0UsV0FBVzhFLFFBQVEsRUFBRXRGLFVBQVUsQ0FBQyxHQUFHUSxXQUFXK0UsU0FBUyxFQUFFdkY7UUFDdEYsSUFBSXFGLG9CQUFvQjtZQUN0QixPQUFPSixhQUFhakYsT0FBT29GO1FBQzdCO1FBQ0EsQ0FBQ0MscUJBQXFCRyxLQUFxQyxHQUFHLENBQUMsR0FBR2xGLGNBQWMsQ0FBQyxVQUFVLEVBQUUsT0FBTyxnRUFBZ0U2RCxNQUFNLENBQUN2RCxRQUFRWixRQUFRLGdFQUFnRSxDQUFxQyxHQUFHLEtBQUs7UUFDeFMsT0FBT2tGO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcdXRpbFxcQmFyVXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5CYXJSZWN0YW5nbGUgPSBCYXJSZWN0YW5nbGU7XHJcbmV4cG9ydHMubWluUG9pbnRTaXplQ2FsbGJhY2sgPSB2b2lkIDA7XHJcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBfdGlueUludmFyaWFudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInRpbnktaW52YXJpYW50XCIpKTtcclxudmFyIF9BY3RpdmVTaGFwZVV0aWxzID0gcmVxdWlyZShcIi4vQWN0aXZlU2hhcGVVdGlsc1wiKTtcclxudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi9EYXRhVXRpbHNcIik7XHJcbnZhciBfZXhjbHVkZWQgPSBbXCJ4XCIsIFwieVwiXTtcclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XHJcbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cclxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XHJcbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cclxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxyXG4vLyBSZWN0YW5nbGUgcHJvcHMgaXMgZXhwZWN0aW5nIHgsIHksIGhlaWdodCwgd2lkdGggYXMgbnVtYmVycywgbmFtZSBhcyBhIHN0cmluZywgYW5kIHJhZGl1cyBhcyBhIGN1c3RvbSB0eXBlXHJcbi8vIFdoZW4gcHJvcHMgYXJlIGJlaW5nIHNwcmVhZCBpbiBmcm9tIGEgdXNlciBkZWZpbmVkIGNvbXBvbmVudCBpbiBCYXIsXHJcbi8vIHRoZSBwcm9wIHR5cGVzIG9mIGFuIFNWR0VsZW1lbnQgaGF2ZSB0aGVzZSB0eXBlZCBhcyBzb21ldGhpbmcgZWxzZS5cclxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcGFzc2VkIGluIHByb3BzXHJcbi8vIGFsb25nIHdpdGggeCwgeSwgaGVpZ2h0IGFzIG51bWJlcnMsIG5hbWUgYXMgYSBzdHJpbmcsIGFuZCByYWRpdXMgYXMgbnVtYmVyIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl1cclxuZnVuY3Rpb24gdHlwZWd1YXJkQmFyUmVjdGFuZ2xlUHJvcHMoX3JlZiwgcHJvcHMpIHtcclxuICB2YXIgeFByb3AgPSBfcmVmLngsXHJcbiAgICB5UHJvcCA9IF9yZWYueSxcclxuICAgIG9wdGlvbiA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQpO1xyXG4gIHZhciB4VmFsdWUgPSBcIlwiLmNvbmNhdCh4UHJvcCk7XHJcbiAgdmFyIHggPSBwYXJzZUludCh4VmFsdWUsIDEwKTtcclxuICB2YXIgeVZhbHVlID0gXCJcIi5jb25jYXQoeVByb3ApO1xyXG4gIHZhciB5ID0gcGFyc2VJbnQoeVZhbHVlLCAxMCk7XHJcbiAgdmFyIGhlaWdodFZhbHVlID0gXCJcIi5jb25jYXQocHJvcHMuaGVpZ2h0IHx8IG9wdGlvbi5oZWlnaHQpO1xyXG4gIHZhciBoZWlnaHQgPSBwYXJzZUludChoZWlnaHRWYWx1ZSwgMTApO1xyXG4gIHZhciB3aWR0aFZhbHVlID0gXCJcIi5jb25jYXQocHJvcHMud2lkdGggfHwgb3B0aW9uLndpZHRoKTtcclxuICB2YXIgd2lkdGggPSBwYXJzZUludCh3aWR0aFZhbHVlLCAxMCk7XHJcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCBvcHRpb24pLCB4ID8ge1xyXG4gICAgeDogeFxyXG4gIH0gOiB7fSksIHkgPyB7XHJcbiAgICB5OiB5XHJcbiAgfSA6IHt9KSwge30sIHtcclxuICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgbmFtZTogcHJvcHMubmFtZSxcclxuICAgIHJhZGl1czogcHJvcHMucmFkaXVzXHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gQmFyUmVjdGFuZ2xlKHByb3BzKSB7XHJcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0FjdGl2ZVNoYXBlVXRpbHMuU2hhcGUsIF9leHRlbmRzKHtcclxuICAgIHNoYXBlVHlwZTogXCJyZWN0YW5nbGVcIixcclxuICAgIHByb3BUcmFuc2Zvcm1lcjogdHlwZWd1YXJkQmFyUmVjdGFuZ2xlUHJvcHMsXHJcbiAgICBhY3RpdmVDbGFzc05hbWU6IFwicmVjaGFydHMtYWN0aXZlLWJhclwiXHJcbiAgfSwgcHJvcHMpKTtcclxufVxyXG4vKipcclxuICogU2FmZWx5IGdldHMgbWluUG9pbnRTaXplIGZyb20gZnJvbSB0aGUgbWluUG9pbnRTaXplIHByb3AgaWYgaXQgaXMgYSBmdW5jdGlvblxyXG4gKiBAcGFyYW0gbWluUG9pbnRTaXplIG1pblBvaW50U2l6ZSBhcyBwYXNzZWQgdG8gdGhlIEJhciBjb21wb25lbnRcclxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBkZWZhdWx0IG1pblBvaW50U2l6ZVxyXG4gKiBAcmV0dXJucyBtaW5Qb2ludFNpemVcclxuICovXHJcbnZhciBtaW5Qb2ludFNpemVDYWxsYmFjayA9IGV4cG9ydHMubWluUG9pbnRTaXplQ2FsbGJhY2sgPSBmdW5jdGlvbiBtaW5Qb2ludFNpemVDYWxsYmFjayhtaW5Qb2ludFNpemUpIHtcclxuICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xyXG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XHJcbiAgICBpZiAodHlwZW9mIG1pblBvaW50U2l6ZSA9PT0gJ251bWJlcicpIHJldHVybiBtaW5Qb2ludFNpemU7XHJcbiAgICB2YXIgaXNWYWx1ZU51bWJlck9yTmlsID0gKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHZhbHVlKSB8fCAoMCwgX0RhdGFVdGlscy5pc051bGxpc2gpKHZhbHVlKTtcclxuICAgIGlmIChpc1ZhbHVlTnVtYmVyT3JOaWwpIHtcclxuICAgICAgcmV0dXJuIG1pblBvaW50U2l6ZSh2YWx1ZSwgaW5kZXgpO1xyXG4gICAgfVxyXG4gICAgIWlzVmFsdWVOdW1iZXJPck5pbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/ICgwLCBfdGlueUludmFyaWFudFtcImRlZmF1bHRcIl0pKGZhbHNlLCBcIm1pblBvaW50U2l6ZSBjYWxsYmFjayBmdW5jdGlvbiByZWNlaXZlZCBhIHZhbHVlIHdpdGggdHlwZSBvZiBcIi5jb25jYXQoX3R5cGVvZih2YWx1ZSksIFwiLiBDdXJyZW50bHkgb25seSBudW1iZXJzIG9yIG51bGwvdW5kZWZpbmVkIGFyZSBzdXBwb3J0ZWQuXCIpKSA6ICgwLCBfdGlueUludmFyaWFudFtcImRlZmF1bHRcIl0pKGZhbHNlKSA6IHZvaWQgMDtcclxuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XHJcbiAgfTtcclxufTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJCYXJSZWN0YW5nbGUiLCJtaW5Qb2ludFNpemVDYWxsYmFjayIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX3RpbnlJbnZhcmlhbnQiLCJfQWN0aXZlU2hhcGVVdGlscyIsIl9EYXRhVXRpbHMiLCJfZXhjbHVkZWQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIm93bktleXMiLCJlIiwiciIsInQiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsInNvdXJjZVN5bWJvbEtleXMiLCJpbmRleE9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJ0eXBlZ3VhcmRCYXJSZWN0YW5nbGVQcm9wcyIsIl9yZWYiLCJwcm9wcyIsInhQcm9wIiwieCIsInlQcm9wIiwieSIsIm9wdGlvbiIsInhWYWx1ZSIsImNvbmNhdCIsInBhcnNlSW50IiwieVZhbHVlIiwiaGVpZ2h0VmFsdWUiLCJoZWlnaHQiLCJ3aWR0aFZhbHVlIiwid2lkdGgiLCJuYW1lIiwicmFkaXVzIiwiY3JlYXRlRWxlbWVudCIsIlNoYXBlIiwic2hhcGVUeXBlIiwicHJvcFRyYW5zZm9ybWVyIiwiYWN0aXZlQ2xhc3NOYW1lIiwibWluUG9pbnRTaXplIiwiZGVmYXVsdFZhbHVlIiwidW5kZWZpbmVkIiwiaW5kZXgiLCJpc1ZhbHVlTnVtYmVyT3JOaWwiLCJpc051bWJlciIsImlzTnVsbGlzaCIsInByb2Nlc3MiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/BarUtils.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/CartesianUtils.js":
/*!**********************************************************!*\
  !*** ./node_modules/recharts/lib/util/CartesianUtils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getAngledRectangleWidth = exports.formatAxisMap = exports.createLabeledScales = exports.ScaleHelper = void 0;\nexports.normalizeAngle = normalizeAngle;\nexports.rectWithPoints = exports.rectWithCoords = void 0;\nvar _mapValues = _interopRequireDefault(__webpack_require__(/*! lodash/mapValues */ \"lodash/mapValues\"));\nvar _every = _interopRequireDefault(__webpack_require__(/*! lodash/every */ \"lodash/every\"));\nvar _ChartUtils = __webpack_require__(/*! ./ChartUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ./ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _DataUtils = __webpack_require__(/*! ./DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _Bar = __webpack_require__(/*! ../cartesian/Bar */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/Bar.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n/**\r\n * Calculate the scale function, position, width, height of axes\r\n * @param  {Object} props     Latest props\r\n * @param  {Object} axisMap   The configuration of axes\r\n * @param  {Object} offset    The offset of main part in the svg element\r\n * @param  {String} axisType  The type of axes, x-axis or y-axis\r\n * @param  {String} chartName The name of chart\r\n * @return {Object} Configuration\r\n */ var formatAxisMap = exports.formatAxisMap = function formatAxisMap(props, axisMap, offset, axisType, chartName) {\n    var width = props.width, height = props.height, layout = props.layout, children = props.children;\n    var ids = Object.keys(axisMap);\n    var steps = {\n        left: offset.left,\n        leftMirror: offset.left,\n        right: width - offset.right,\n        rightMirror: width - offset.right,\n        top: offset.top,\n        topMirror: offset.top,\n        bottom: height - offset.bottom,\n        bottomMirror: height - offset.bottom\n    };\n    var hasBar = !!(0, _ReactUtils.findChildByType)(children, _Bar.Bar);\n    return ids.reduce(function(result, id) {\n        var axis = axisMap[id];\n        var orientation = axis.orientation, domain = axis.domain, _axis$padding = axis.padding, padding = _axis$padding === void 0 ? {} : _axis$padding, mirror = axis.mirror, reversed = axis.reversed;\n        var offsetKey = \"\".concat(orientation).concat(mirror ? 'Mirror' : '');\n        var calculatedPadding, range, x, y, needSpace;\n        if (axis.type === 'number' && (axis.padding === 'gap' || axis.padding === 'no-gap')) {\n            var diff = domain[1] - domain[0];\n            var smallestDistanceBetweenValues = Infinity;\n            var sortedValues = axis.categoricalDomain.sort(_DataUtils.compareValues);\n            sortedValues.forEach(function(value, index) {\n                if (index > 0) {\n                    smallestDistanceBetweenValues = Math.min((value || 0) - (sortedValues[index - 1] || 0), smallestDistanceBetweenValues);\n                }\n            });\n            if (Number.isFinite(smallestDistanceBetweenValues)) {\n                var smallestDistanceInPercent = smallestDistanceBetweenValues / diff;\n                var rangeWidth = axis.layout === 'vertical' ? offset.height : offset.width;\n                if (axis.padding === 'gap') {\n                    calculatedPadding = smallestDistanceInPercent * rangeWidth / 2;\n                }\n                if (axis.padding === 'no-gap') {\n                    var gap = (0, _DataUtils.getPercentValue)(props.barCategoryGap, smallestDistanceInPercent * rangeWidth);\n                    var halfBand = smallestDistanceInPercent * rangeWidth / 2;\n                    calculatedPadding = halfBand - gap - (halfBand - gap) / rangeWidth * gap;\n                }\n            }\n        }\n        if (axisType === 'xAxis') {\n            range = [\n                offset.left + (padding.left || 0) + (calculatedPadding || 0),\n                offset.left + offset.width - (padding.right || 0) - (calculatedPadding || 0)\n            ];\n        } else if (axisType === 'yAxis') {\n            range = layout === 'horizontal' ? [\n                offset.top + offset.height - (padding.bottom || 0),\n                offset.top + (padding.top || 0)\n            ] : [\n                offset.top + (padding.top || 0) + (calculatedPadding || 0),\n                offset.top + offset.height - (padding.bottom || 0) - (calculatedPadding || 0)\n            ];\n        } else {\n            range = axis.range;\n        }\n        if (reversed) {\n            range = [\n                range[1],\n                range[0]\n            ];\n        }\n        var _parseScale = (0, _ChartUtils.parseScale)(axis, chartName, hasBar), scale = _parseScale.scale, realScaleType = _parseScale.realScaleType;\n        scale.domain(domain).range(range);\n        (0, _ChartUtils.checkDomainOfScale)(scale);\n        var ticks = (0, _ChartUtils.getTicksOfScale)(scale, _objectSpread(_objectSpread({}, axis), {}, {\n            realScaleType: realScaleType\n        }));\n        if (axisType === 'xAxis') {\n            needSpace = orientation === 'top' && !mirror || orientation === 'bottom' && mirror;\n            x = offset.left;\n            y = steps[offsetKey] - needSpace * axis.height;\n        } else if (axisType === 'yAxis') {\n            needSpace = orientation === 'left' && !mirror || orientation === 'right' && mirror;\n            x = steps[offsetKey] - needSpace * axis.width;\n            y = offset.top;\n        }\n        var finalAxis = _objectSpread(_objectSpread(_objectSpread({}, axis), ticks), {}, {\n            realScaleType: realScaleType,\n            x: x,\n            y: y,\n            scale: scale,\n            width: axisType === 'xAxis' ? offset.width : axis.width,\n            height: axisType === 'yAxis' ? offset.height : axis.height\n        });\n        finalAxis.bandSize = (0, _ChartUtils.getBandSizeOfAxis)(finalAxis, ticks);\n        if (!axis.hide && axisType === 'xAxis') {\n            steps[offsetKey] += (needSpace ? -1 : 1) * finalAxis.height;\n        } else if (!axis.hide) {\n            steps[offsetKey] += (needSpace ? -1 : 1) * finalAxis.width;\n        }\n        return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, id, finalAxis));\n    }, {});\n};\nvar rectWithPoints = exports.rectWithPoints = function rectWithPoints(_ref, _ref2) {\n    var x1 = _ref.x, y1 = _ref.y;\n    var x2 = _ref2.x, y2 = _ref2.y;\n    return {\n        x: Math.min(x1, x2),\n        y: Math.min(y1, y2),\n        width: Math.abs(x2 - x1),\n        height: Math.abs(y2 - y1)\n    };\n};\n/**\r\n * Compute the x, y, width, and height of a box from two reference points.\r\n * @param  {Object} coords     x1, x2, y1, and y2\r\n * @return {Object} object\r\n */ var rectWithCoords = exports.rectWithCoords = function rectWithCoords(_ref3) {\n    var x1 = _ref3.x1, y1 = _ref3.y1, x2 = _ref3.x2, y2 = _ref3.y2;\n    return rectWithPoints({\n        x: x1,\n        y: y1\n    }, {\n        x: x2,\n        y: y2\n    });\n};\nvar ScaleHelper = exports.ScaleHelper = /*#__PURE__*/ function() {\n    function ScaleHelper(scale) {\n        _classCallCheck(this, ScaleHelper);\n        this.scale = scale;\n    }\n    return _createClass(ScaleHelper, [\n        {\n            key: \"domain\",\n            get: function get() {\n                return this.scale.domain;\n            }\n        },\n        {\n            key: \"range\",\n            get: function get() {\n                return this.scale.range;\n            }\n        },\n        {\n            key: \"rangeMin\",\n            get: function get() {\n                return this.range()[0];\n            }\n        },\n        {\n            key: \"rangeMax\",\n            get: function get() {\n                return this.range()[1];\n            }\n        },\n        {\n            key: \"bandwidth\",\n            get: function get() {\n                return this.scale.bandwidth;\n            }\n        },\n        {\n            key: \"apply\",\n            value: function apply(value) {\n                var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, bandAware = _ref4.bandAware, position = _ref4.position;\n                if (value === undefined) {\n                    return undefined;\n                }\n                if (position) {\n                    switch(position){\n                        case 'start':\n                            {\n                                return this.scale(value);\n                            }\n                        case 'middle':\n                            {\n                                var offset = this.bandwidth ? this.bandwidth() / 2 : 0;\n                                return this.scale(value) + offset;\n                            }\n                        case 'end':\n                            {\n                                var _offset = this.bandwidth ? this.bandwidth() : 0;\n                                return this.scale(value) + _offset;\n                            }\n                        default:\n                            {\n                                return this.scale(value);\n                            }\n                    }\n                }\n                if (bandAware) {\n                    var _offset2 = this.bandwidth ? this.bandwidth() / 2 : 0;\n                    return this.scale(value) + _offset2;\n                }\n                return this.scale(value);\n            }\n        },\n        {\n            key: \"isInRange\",\n            value: function isInRange(value) {\n                var range = this.range();\n                var first = range[0];\n                var last = range[range.length - 1];\n                return first <= last ? value >= first && value <= last : value >= last && value <= first;\n            }\n        }\n    ], [\n        {\n            key: \"create\",\n            value: function create(obj) {\n                return new ScaleHelper(obj);\n            }\n        }\n    ]);\n}();\n_defineProperty(ScaleHelper, \"EPS\", 1e-4);\nvar createLabeledScales = exports.createLabeledScales = function createLabeledScales(options) {\n    var scales = Object.keys(options).reduce(function(res, key) {\n        return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, key, ScaleHelper.create(options[key])));\n    }, {});\n    return _objectSpread(_objectSpread({}, scales), {}, {\n        apply: function apply(coord) {\n            var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, bandAware = _ref5.bandAware, position = _ref5.position;\n            return (0, _mapValues[\"default\"])(coord, function(value, label) {\n                return scales[label].apply(value, {\n                    bandAware: bandAware,\n                    position: position\n                });\n            });\n        },\n        isInRange: function isInRange(coord) {\n            return (0, _every[\"default\"])(coord, function(value, label) {\n                return scales[label].isInRange(value);\n            });\n        }\n    });\n};\n/** Normalizes the angle so that 0 <= angle < 180.\r\n * @param {number} angle Angle in degrees.\r\n * @return {number} the normalized angle with a value of at least 0 and never greater or equal to 180. */ function normalizeAngle(angle) {\n    return (angle % 180 + 180) % 180;\n}\n/** Calculates the width of the largest horizontal line that fits inside a rectangle that is displayed at an angle.\r\n * @param {Object} size Width and height of the text in a horizontal position.\r\n * @param {number} angle Angle in degrees in which the text is displayed.\r\n * @return {number} The width of the largest horizontal line that fits inside a rectangle that is displayed at an angle.\r\n */ var getAngledRectangleWidth = exports.getAngledRectangleWidth = function getAngledRectangleWidth(_ref6) {\n    var width = _ref6.width, height = _ref6.height;\n    var angle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    // Ensure angle is >= 0 && < 180\n    var normalizedAngle = normalizeAngle(angle);\n    var angleRadians = normalizedAngle * Math.PI / 180;\n    /* Depending on the height and width of the rectangle, we may need to use different formulas to calculate the angled\r\n   * width. This threshold defines when each formula should kick in. */ var angleThreshold = Math.atan(height / width);\n    var angledWidth = angleRadians > angleThreshold && angleRadians < Math.PI - angleThreshold ? height / Math.sin(angleRadians) : width / Math.cos(angleRadians);\n    return Math.abs(angledWidth);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9DYXJ0ZXNpYW5VdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsK0JBQStCLEdBQUdBLHFCQUFxQixHQUFHQSwyQkFBMkIsR0FBR0EsbUJBQW1CLEdBQUcsS0FBSztBQUNuSEEsc0JBQXNCLEdBQUdNO0FBQ3pCTixzQkFBc0IsR0FBR0Esc0JBQXNCLEdBQUcsS0FBSztBQUN2RCxJQUFJUyxhQUFhQyx1QkFBdUJDLG1CQUFPQSxDQUFDLDBDQUFrQjtBQUNsRSxJQUFJQyxTQUFTRix1QkFBdUJDLG1CQUFPQSxDQUFDLGtDQUFjO0FBQzFELElBQUlFLGNBQWNGLG1CQUFPQSxDQUFDLHFGQUFjO0FBQ3hDLElBQUlHLGNBQWNILG1CQUFPQSxDQUFDLHFGQUFjO0FBQ3hDLElBQUlJLGFBQWFKLG1CQUFPQSxDQUFDLG1GQUFhO0FBQ3RDLElBQUlLLE9BQU9MLG1CQUFPQSxDQUFDLHVGQUFrQjtBQUNyQyxTQUFTRCx1QkFBdUJPLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUUsV0FBVyxLQUFLQyxVQUFVRCxNQUFNQyxPQUFPRSxTQUFTLEdBQUcsV0FBVyxPQUFPSDtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1QsU0FBU0ksZ0JBQWdCQyxRQUFRLEVBQUVDLFdBQVc7SUFBSSxJQUFJLENBQUVELENBQUFBLG9CQUFvQkMsV0FB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LEtBQUssRUFDckJDLFNBQVN5RixNQUFNekYsTUFBTTtJQUN2QixJQUFJd0YsUUFBUXZHLFVBQVVyQixNQUFNLEdBQUcsS0FBS3FCLFNBQVMsQ0FBQyxFQUFFLEtBQUt3RixZQUFZeEYsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUNoRixnQ0FBZ0M7SUFDaEMsSUFBSXlHLGtCQUFrQnhKLGVBQWVzSjtJQUNyQyxJQUFJRyxlQUFlRCxrQkFBa0JoRCxLQUFLa0QsRUFBRSxHQUFHO0lBRS9DO3FFQUNtRSxHQUNuRSxJQUFJQyxpQkFBaUJuRCxLQUFLb0QsSUFBSSxDQUFDOUYsU0FBU0Q7SUFDeEMsSUFBSWdHLGNBQWNKLGVBQWVFLGtCQUFrQkYsZUFBZWpELEtBQUtrRCxFQUFFLEdBQUdDLGlCQUFpQjdGLFNBQVMwQyxLQUFLc0QsR0FBRyxDQUFDTCxnQkFBZ0I1RixRQUFRMkMsS0FBS3VELEdBQUcsQ0FBQ047SUFDaEosT0FBT2pELEtBQUswQixHQUFHLENBQUMyQjtBQUNsQiIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcdXRpbFxcQ2FydGVzaWFuVXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5nZXRBbmdsZWRSZWN0YW5nbGVXaWR0aCA9IGV4cG9ydHMuZm9ybWF0QXhpc01hcCA9IGV4cG9ydHMuY3JlYXRlTGFiZWxlZFNjYWxlcyA9IGV4cG9ydHMuU2NhbGVIZWxwZXIgPSB2b2lkIDA7XHJcbmV4cG9ydHMubm9ybWFsaXplQW5nbGUgPSBub3JtYWxpemVBbmdsZTtcclxuZXhwb3J0cy5yZWN0V2l0aFBvaW50cyA9IGV4cG9ydHMucmVjdFdpdGhDb29yZHMgPSB2b2lkIDA7XHJcbnZhciBfbWFwVmFsdWVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL21hcFZhbHVlc1wiKSk7XHJcbnZhciBfZXZlcnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZXZlcnlcIikpO1xyXG52YXIgX0NoYXJ0VXRpbHMgPSByZXF1aXJlKFwiLi9DaGFydFV0aWxzXCIpO1xyXG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi9SZWFjdFV0aWxzXCIpO1xyXG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuL0RhdGFVdGlsc1wiKTtcclxudmFyIF9CYXIgPSByZXF1aXJlKFwiLi4vY2FydGVzaWFuL0JhclwiKTtcclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XHJcbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cclxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cclxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cclxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxyXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxyXG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBzY2FsZSBmdW5jdGlvbiwgcG9zaXRpb24sIHdpZHRoLCBoZWlnaHQgb2YgYXhlc1xyXG4gKiBAcGFyYW0gIHtPYmplY3R9IHByb3BzICAgICBMYXRlc3QgcHJvcHNcclxuICogQHBhcmFtICB7T2JqZWN0fSBheGlzTWFwICAgVGhlIGNvbmZpZ3VyYXRpb24gb2YgYXhlc1xyXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9mZnNldCAgICBUaGUgb2Zmc2V0IG9mIG1haW4gcGFydCBpbiB0aGUgc3ZnIGVsZW1lbnRcclxuICogQHBhcmFtICB7U3RyaW5nfSBheGlzVHlwZSAgVGhlIHR5cGUgb2YgYXhlcywgeC1heGlzIG9yIHktYXhpc1xyXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGNoYXJ0TmFtZSBUaGUgbmFtZSBvZiBjaGFydFxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IENvbmZpZ3VyYXRpb25cclxuICovXHJcbnZhciBmb3JtYXRBeGlzTWFwID0gZXhwb3J0cy5mb3JtYXRBeGlzTWFwID0gZnVuY3Rpb24gZm9ybWF0QXhpc01hcChwcm9wcywgYXhpc01hcCwgb2Zmc2V0LCBheGlzVHlwZSwgY2hhcnROYW1lKSB7XHJcbiAgdmFyIHdpZHRoID0gcHJvcHMud2lkdGgsXHJcbiAgICBoZWlnaHQgPSBwcm9wcy5oZWlnaHQsXHJcbiAgICBsYXlvdXQgPSBwcm9wcy5sYXlvdXQsXHJcbiAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xyXG4gIHZhciBpZHMgPSBPYmplY3Qua2V5cyhheGlzTWFwKTtcclxuICB2YXIgc3RlcHMgPSB7XHJcbiAgICBsZWZ0OiBvZmZzZXQubGVmdCxcclxuICAgIGxlZnRNaXJyb3I6IG9mZnNldC5sZWZ0LFxyXG4gICAgcmlnaHQ6IHdpZHRoIC0gb2Zmc2V0LnJpZ2h0LFxyXG4gICAgcmlnaHRNaXJyb3I6IHdpZHRoIC0gb2Zmc2V0LnJpZ2h0LFxyXG4gICAgdG9wOiBvZmZzZXQudG9wLFxyXG4gICAgdG9wTWlycm9yOiBvZmZzZXQudG9wLFxyXG4gICAgYm90dG9tOiBoZWlnaHQgLSBvZmZzZXQuYm90dG9tLFxyXG4gICAgYm90dG9tTWlycm9yOiBoZWlnaHQgLSBvZmZzZXQuYm90dG9tXHJcbiAgfTtcclxuICB2YXIgaGFzQmFyID0gISEoMCwgX1JlYWN0VXRpbHMuZmluZENoaWxkQnlUeXBlKShjaGlsZHJlbiwgX0Jhci5CYXIpO1xyXG4gIHJldHVybiBpZHMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGlkKSB7XHJcbiAgICB2YXIgYXhpcyA9IGF4aXNNYXBbaWRdO1xyXG4gICAgdmFyIG9yaWVudGF0aW9uID0gYXhpcy5vcmllbnRhdGlvbixcclxuICAgICAgZG9tYWluID0gYXhpcy5kb21haW4sXHJcbiAgICAgIF9heGlzJHBhZGRpbmcgPSBheGlzLnBhZGRpbmcsXHJcbiAgICAgIHBhZGRpbmcgPSBfYXhpcyRwYWRkaW5nID09PSB2b2lkIDAgPyB7fSA6IF9heGlzJHBhZGRpbmcsXHJcbiAgICAgIG1pcnJvciA9IGF4aXMubWlycm9yLFxyXG4gICAgICByZXZlcnNlZCA9IGF4aXMucmV2ZXJzZWQ7XHJcbiAgICB2YXIgb2Zmc2V0S2V5ID0gXCJcIi5jb25jYXQob3JpZW50YXRpb24pLmNvbmNhdChtaXJyb3IgPyAnTWlycm9yJyA6ICcnKTtcclxuICAgIHZhciBjYWxjdWxhdGVkUGFkZGluZywgcmFuZ2UsIHgsIHksIG5lZWRTcGFjZTtcclxuICAgIGlmIChheGlzLnR5cGUgPT09ICdudW1iZXInICYmIChheGlzLnBhZGRpbmcgPT09ICdnYXAnIHx8IGF4aXMucGFkZGluZyA9PT0gJ25vLWdhcCcpKSB7XHJcbiAgICAgIHZhciBkaWZmID0gZG9tYWluWzFdIC0gZG9tYWluWzBdO1xyXG4gICAgICB2YXIgc21hbGxlc3REaXN0YW5jZUJldHdlZW5WYWx1ZXMgPSBJbmZpbml0eTtcclxuICAgICAgdmFyIHNvcnRlZFZhbHVlcyA9IGF4aXMuY2F0ZWdvcmljYWxEb21haW4uc29ydChfRGF0YVV0aWxzLmNvbXBhcmVWYWx1ZXMpO1xyXG4gICAgICBzb3J0ZWRWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID4gMCkge1xyXG4gICAgICAgICAgc21hbGxlc3REaXN0YW5jZUJldHdlZW5WYWx1ZXMgPSBNYXRoLm1pbigodmFsdWUgfHwgMCkgLSAoc29ydGVkVmFsdWVzW2luZGV4IC0gMV0gfHwgMCksIHNtYWxsZXN0RGlzdGFuY2VCZXR3ZWVuVmFsdWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHNtYWxsZXN0RGlzdGFuY2VCZXR3ZWVuVmFsdWVzKSkge1xyXG4gICAgICAgIHZhciBzbWFsbGVzdERpc3RhbmNlSW5QZXJjZW50ID0gc21hbGxlc3REaXN0YW5jZUJldHdlZW5WYWx1ZXMgLyBkaWZmO1xyXG4gICAgICAgIHZhciByYW5nZVdpZHRoID0gYXhpcy5sYXlvdXQgPT09ICd2ZXJ0aWNhbCcgPyBvZmZzZXQuaGVpZ2h0IDogb2Zmc2V0LndpZHRoO1xyXG4gICAgICAgIGlmIChheGlzLnBhZGRpbmcgPT09ICdnYXAnKSB7XHJcbiAgICAgICAgICBjYWxjdWxhdGVkUGFkZGluZyA9IHNtYWxsZXN0RGlzdGFuY2VJblBlcmNlbnQgKiByYW5nZVdpZHRoIC8gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGF4aXMucGFkZGluZyA9PT0gJ25vLWdhcCcpIHtcclxuICAgICAgICAgIHZhciBnYXAgPSAoMCwgX0RhdGFVdGlscy5nZXRQZXJjZW50VmFsdWUpKHByb3BzLmJhckNhdGVnb3J5R2FwLCBzbWFsbGVzdERpc3RhbmNlSW5QZXJjZW50ICogcmFuZ2VXaWR0aCk7XHJcbiAgICAgICAgICB2YXIgaGFsZkJhbmQgPSBzbWFsbGVzdERpc3RhbmNlSW5QZXJjZW50ICogcmFuZ2VXaWR0aCAvIDI7XHJcbiAgICAgICAgICBjYWxjdWxhdGVkUGFkZGluZyA9IGhhbGZCYW5kIC0gZ2FwIC0gKGhhbGZCYW5kIC0gZ2FwKSAvIHJhbmdlV2lkdGggKiBnYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYXhpc1R5cGUgPT09ICd4QXhpcycpIHtcclxuICAgICAgcmFuZ2UgPSBbb2Zmc2V0LmxlZnQgKyAocGFkZGluZy5sZWZ0IHx8IDApICsgKGNhbGN1bGF0ZWRQYWRkaW5nIHx8IDApLCBvZmZzZXQubGVmdCArIG9mZnNldC53aWR0aCAtIChwYWRkaW5nLnJpZ2h0IHx8IDApIC0gKGNhbGN1bGF0ZWRQYWRkaW5nIHx8IDApXTtcclxuICAgIH0gZWxzZSBpZiAoYXhpc1R5cGUgPT09ICd5QXhpcycpIHtcclxuICAgICAgcmFuZ2UgPSBsYXlvdXQgPT09ICdob3Jpem9udGFsJyA/IFtvZmZzZXQudG9wICsgb2Zmc2V0LmhlaWdodCAtIChwYWRkaW5nLmJvdHRvbSB8fCAwKSwgb2Zmc2V0LnRvcCArIChwYWRkaW5nLnRvcCB8fCAwKV0gOiBbb2Zmc2V0LnRvcCArIChwYWRkaW5nLnRvcCB8fCAwKSArIChjYWxjdWxhdGVkUGFkZGluZyB8fCAwKSwgb2Zmc2V0LnRvcCArIG9mZnNldC5oZWlnaHQgLSAocGFkZGluZy5ib3R0b20gfHwgMCkgLSAoY2FsY3VsYXRlZFBhZGRpbmcgfHwgMCldO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmFuZ2UgPSBheGlzLnJhbmdlO1xyXG4gICAgfVxyXG4gICAgaWYgKHJldmVyc2VkKSB7XHJcbiAgICAgIHJhbmdlID0gW3JhbmdlWzFdLCByYW5nZVswXV07XHJcbiAgICB9XHJcbiAgICB2YXIgX3BhcnNlU2NhbGUgPSAoMCwgX0NoYXJ0VXRpbHMucGFyc2VTY2FsZSkoYXhpcywgY2hhcnROYW1lLCBoYXNCYXIpLFxyXG4gICAgICBzY2FsZSA9IF9wYXJzZVNjYWxlLnNjYWxlLFxyXG4gICAgICByZWFsU2NhbGVUeXBlID0gX3BhcnNlU2NhbGUucmVhbFNjYWxlVHlwZTtcclxuICAgIHNjYWxlLmRvbWFpbihkb21haW4pLnJhbmdlKHJhbmdlKTtcclxuICAgICgwLCBfQ2hhcnRVdGlscy5jaGVja0RvbWFpbk9mU2NhbGUpKHNjYWxlKTtcclxuICAgIHZhciB0aWNrcyA9ICgwLCBfQ2hhcnRVdGlscy5nZXRUaWNrc09mU2NhbGUpKHNjYWxlLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGF4aXMpLCB7fSwge1xyXG4gICAgICByZWFsU2NhbGVUeXBlOiByZWFsU2NhbGVUeXBlXHJcbiAgICB9KSk7XHJcbiAgICBpZiAoYXhpc1R5cGUgPT09ICd4QXhpcycpIHtcclxuICAgICAgbmVlZFNwYWNlID0gb3JpZW50YXRpb24gPT09ICd0b3AnICYmICFtaXJyb3IgfHwgb3JpZW50YXRpb24gPT09ICdib3R0b20nICYmIG1pcnJvcjtcclxuICAgICAgeCA9IG9mZnNldC5sZWZ0O1xyXG4gICAgICB5ID0gc3RlcHNbb2Zmc2V0S2V5XSAtIG5lZWRTcGFjZSAqIGF4aXMuaGVpZ2h0O1xyXG4gICAgfSBlbHNlIGlmIChheGlzVHlwZSA9PT0gJ3lBeGlzJykge1xyXG4gICAgICBuZWVkU3BhY2UgPSBvcmllbnRhdGlvbiA9PT0gJ2xlZnQnICYmICFtaXJyb3IgfHwgb3JpZW50YXRpb24gPT09ICdyaWdodCcgJiYgbWlycm9yO1xyXG4gICAgICB4ID0gc3RlcHNbb2Zmc2V0S2V5XSAtIG5lZWRTcGFjZSAqIGF4aXMud2lkdGg7XHJcbiAgICAgIHkgPSBvZmZzZXQudG9wO1xyXG4gICAgfVxyXG4gICAgdmFyIGZpbmFsQXhpcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBheGlzKSwgdGlja3MpLCB7fSwge1xyXG4gICAgICByZWFsU2NhbGVUeXBlOiByZWFsU2NhbGVUeXBlLFxyXG4gICAgICB4OiB4LFxyXG4gICAgICB5OiB5LFxyXG4gICAgICBzY2FsZTogc2NhbGUsXHJcbiAgICAgIHdpZHRoOiBheGlzVHlwZSA9PT0gJ3hBeGlzJyA/IG9mZnNldC53aWR0aCA6IGF4aXMud2lkdGgsXHJcbiAgICAgIGhlaWdodDogYXhpc1R5cGUgPT09ICd5QXhpcycgPyBvZmZzZXQuaGVpZ2h0IDogYXhpcy5oZWlnaHRcclxuICAgIH0pO1xyXG4gICAgZmluYWxBeGlzLmJhbmRTaXplID0gKDAsIF9DaGFydFV0aWxzLmdldEJhbmRTaXplT2ZBeGlzKShmaW5hbEF4aXMsIHRpY2tzKTtcclxuICAgIGlmICghYXhpcy5oaWRlICYmIGF4aXNUeXBlID09PSAneEF4aXMnKSB7XHJcbiAgICAgIHN0ZXBzW29mZnNldEtleV0gKz0gKG5lZWRTcGFjZSA/IC0xIDogMSkgKiBmaW5hbEF4aXMuaGVpZ2h0O1xyXG4gICAgfSBlbHNlIGlmICghYXhpcy5oaWRlKSB7XHJcbiAgICAgIHN0ZXBzW29mZnNldEtleV0gKz0gKG5lZWRTcGFjZSA/IC0xIDogMSkgKiBmaW5hbEF4aXMud2lkdGg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXN1bHQpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBpZCwgZmluYWxBeGlzKSk7XHJcbiAgfSwge30pO1xyXG59O1xyXG52YXIgcmVjdFdpdGhQb2ludHMgPSBleHBvcnRzLnJlY3RXaXRoUG9pbnRzID0gZnVuY3Rpb24gcmVjdFdpdGhQb2ludHMoX3JlZiwgX3JlZjIpIHtcclxuICB2YXIgeDEgPSBfcmVmLngsXHJcbiAgICB5MSA9IF9yZWYueTtcclxuICB2YXIgeDIgPSBfcmVmMi54LFxyXG4gICAgeTIgPSBfcmVmMi55O1xyXG4gIHJldHVybiB7XHJcbiAgICB4OiBNYXRoLm1pbih4MSwgeDIpLFxyXG4gICAgeTogTWF0aC5taW4oeTEsIHkyKSxcclxuICAgIHdpZHRoOiBNYXRoLmFicyh4MiAtIHgxKSxcclxuICAgIGhlaWdodDogTWF0aC5hYnMoeTIgLSB5MSlcclxuICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGUgdGhlIHgsIHksIHdpZHRoLCBhbmQgaGVpZ2h0IG9mIGEgYm94IGZyb20gdHdvIHJlZmVyZW5jZSBwb2ludHMuXHJcbiAqIEBwYXJhbSAge09iamVjdH0gY29vcmRzICAgICB4MSwgeDIsIHkxLCBhbmQgeTJcclxuICogQHJldHVybiB7T2JqZWN0fSBvYmplY3RcclxuICovXHJcbnZhciByZWN0V2l0aENvb3JkcyA9IGV4cG9ydHMucmVjdFdpdGhDb29yZHMgPSBmdW5jdGlvbiByZWN0V2l0aENvb3JkcyhfcmVmMykge1xyXG4gIHZhciB4MSA9IF9yZWYzLngxLFxyXG4gICAgeTEgPSBfcmVmMy55MSxcclxuICAgIHgyID0gX3JlZjMueDIsXHJcbiAgICB5MiA9IF9yZWYzLnkyO1xyXG4gIHJldHVybiByZWN0V2l0aFBvaW50cyh7XHJcbiAgICB4OiB4MSxcclxuICAgIHk6IHkxXHJcbiAgfSwge1xyXG4gICAgeDogeDIsXHJcbiAgICB5OiB5MlxyXG4gIH0pO1xyXG59O1xyXG52YXIgU2NhbGVIZWxwZXIgPSBleHBvcnRzLlNjYWxlSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBTY2FsZUhlbHBlcihzY2FsZSkge1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNjYWxlSGVscGVyKTtcclxuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcclxuICB9XHJcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhTY2FsZUhlbHBlciwgW3tcclxuICAgIGtleTogXCJkb21haW5cIixcclxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zY2FsZS5kb21haW47XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJhbmdlXCIsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2NhbGUucmFuZ2U7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJhbmdlTWluXCIsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucmFuZ2UoKVswXTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmFuZ2VNYXhcIixcclxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5yYW5nZSgpWzFdO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJiYW5kd2lkdGhcIixcclxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zY2FsZS5iYW5kd2lkdGg7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImFwcGx5XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkodmFsdWUpIHtcclxuICAgICAgdmFyIF9yZWY0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcclxuICAgICAgICBiYW5kQXdhcmUgPSBfcmVmNC5iYW5kQXdhcmUsXHJcbiAgICAgICAgcG9zaXRpb24gPSBfcmVmNC5wb3NpdGlvbjtcclxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwb3NpdGlvbikge1xyXG4gICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcclxuICAgICAgICAgIGNhc2UgJ3N0YXJ0JzpcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgY2FzZSAnbWlkZGxlJzpcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmJhbmR3aWR0aCA/IHRoaXMuYmFuZHdpZHRoKCkgLyAyIDogMDtcclxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZSh2YWx1ZSkgKyBvZmZzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIGNhc2UgJ2VuZCc6XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICB2YXIgX29mZnNldCA9IHRoaXMuYmFuZHdpZHRoID8gdGhpcy5iYW5kd2lkdGgoKSA6IDA7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUodmFsdWUpICsgX29mZnNldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoYmFuZEF3YXJlKSB7XHJcbiAgICAgICAgdmFyIF9vZmZzZXQyID0gdGhpcy5iYW5kd2lkdGggPyB0aGlzLmJhbmR3aWR0aCgpIC8gMiA6IDA7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUodmFsdWUpICsgX29mZnNldDI7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuc2NhbGUodmFsdWUpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJpc0luUmFuZ2VcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0luUmFuZ2UodmFsdWUpIHtcclxuICAgICAgdmFyIHJhbmdlID0gdGhpcy5yYW5nZSgpO1xyXG4gICAgICB2YXIgZmlyc3QgPSByYW5nZVswXTtcclxuICAgICAgdmFyIGxhc3QgPSByYW5nZVtyYW5nZS5sZW5ndGggLSAxXTtcclxuICAgICAgcmV0dXJuIGZpcnN0IDw9IGxhc3QgPyB2YWx1ZSA+PSBmaXJzdCAmJiB2YWx1ZSA8PSBsYXN0IDogdmFsdWUgPj0gbGFzdCAmJiB2YWx1ZSA8PSBmaXJzdDtcclxuICAgIH1cclxuICB9XSwgW3tcclxuICAgIGtleTogXCJjcmVhdGVcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUob2JqKSB7XHJcbiAgICAgIHJldHVybiBuZXcgU2NhbGVIZWxwZXIob2JqKTtcclxuICAgIH1cclxuICB9XSk7XHJcbn0oKTtcclxuX2RlZmluZVByb3BlcnR5KFNjYWxlSGVscGVyLCBcIkVQU1wiLCAxZS00KTtcclxudmFyIGNyZWF0ZUxhYmVsZWRTY2FsZXMgPSBleHBvcnRzLmNyZWF0ZUxhYmVsZWRTY2FsZXMgPSBmdW5jdGlvbiBjcmVhdGVMYWJlbGVkU2NhbGVzKG9wdGlvbnMpIHtcclxuICB2YXIgc2NhbGVzID0gT2JqZWN0LmtleXMob3B0aW9ucykucmVkdWNlKGZ1bmN0aW9uIChyZXMsIGtleSkge1xyXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmVzKSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCBTY2FsZUhlbHBlci5jcmVhdGUob3B0aW9uc1trZXldKSkpO1xyXG4gIH0sIHt9KTtcclxuICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzY2FsZXMpLCB7fSwge1xyXG4gICAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KGNvb3JkKSB7XHJcbiAgICAgIHZhciBfcmVmNSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXHJcbiAgICAgICAgYmFuZEF3YXJlID0gX3JlZjUuYmFuZEF3YXJlLFxyXG4gICAgICAgIHBvc2l0aW9uID0gX3JlZjUucG9zaXRpb247XHJcbiAgICAgIHJldHVybiAoMCwgX21hcFZhbHVlc1tcImRlZmF1bHRcIl0pKGNvb3JkLCBmdW5jdGlvbiAodmFsdWUsIGxhYmVsKSB7XHJcbiAgICAgICAgcmV0dXJuIHNjYWxlc1tsYWJlbF0uYXBwbHkodmFsdWUsIHtcclxuICAgICAgICAgIGJhbmRBd2FyZTogYmFuZEF3YXJlLFxyXG4gICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGlzSW5SYW5nZTogZnVuY3Rpb24gaXNJblJhbmdlKGNvb3JkKSB7XHJcbiAgICAgIHJldHVybiAoMCwgX2V2ZXJ5W1wiZGVmYXVsdFwiXSkoY29vcmQsIGZ1bmN0aW9uICh2YWx1ZSwgbGFiZWwpIHtcclxuICAgICAgICByZXR1cm4gc2NhbGVzW2xhYmVsXS5pc0luUmFuZ2UodmFsdWUpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxufTtcclxuXHJcbi8qKiBOb3JtYWxpemVzIHRoZSBhbmdsZSBzbyB0aGF0IDAgPD0gYW5nbGUgPCAxODAuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBBbmdsZSBpbiBkZWdyZWVzLlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBub3JtYWxpemVkIGFuZ2xlIHdpdGggYSB2YWx1ZSBvZiBhdCBsZWFzdCAwIGFuZCBuZXZlciBncmVhdGVyIG9yIGVxdWFsIHRvIDE4MC4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplQW5nbGUoYW5nbGUpIHtcclxuICByZXR1cm4gKGFuZ2xlICUgMTgwICsgMTgwKSAlIDE4MDtcclxufVxyXG5cclxuLyoqIENhbGN1bGF0ZXMgdGhlIHdpZHRoIG9mIHRoZSBsYXJnZXN0IGhvcml6b250YWwgbGluZSB0aGF0IGZpdHMgaW5zaWRlIGEgcmVjdGFuZ2xlIHRoYXQgaXMgZGlzcGxheWVkIGF0IGFuIGFuZ2xlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gc2l6ZSBXaWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB0ZXh0IGluIGEgaG9yaXpvbnRhbCBwb3NpdGlvbi5cclxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIEFuZ2xlIGluIGRlZ3JlZXMgaW4gd2hpY2ggdGhlIHRleHQgaXMgZGlzcGxheWVkLlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgbGFyZ2VzdCBob3Jpem9udGFsIGxpbmUgdGhhdCBmaXRzIGluc2lkZSBhIHJlY3RhbmdsZSB0aGF0IGlzIGRpc3BsYXllZCBhdCBhbiBhbmdsZS5cclxuICovXHJcbnZhciBnZXRBbmdsZWRSZWN0YW5nbGVXaWR0aCA9IGV4cG9ydHMuZ2V0QW5nbGVkUmVjdGFuZ2xlV2lkdGggPSBmdW5jdGlvbiBnZXRBbmdsZWRSZWN0YW5nbGVXaWR0aChfcmVmNikge1xyXG4gIHZhciB3aWR0aCA9IF9yZWY2LndpZHRoLFxyXG4gICAgaGVpZ2h0ID0gX3JlZjYuaGVpZ2h0O1xyXG4gIHZhciBhbmdsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcclxuICAvLyBFbnN1cmUgYW5nbGUgaXMgPj0gMCAmJiA8IDE4MFxyXG4gIHZhciBub3JtYWxpemVkQW5nbGUgPSBub3JtYWxpemVBbmdsZShhbmdsZSk7XHJcbiAgdmFyIGFuZ2xlUmFkaWFucyA9IG5vcm1hbGl6ZWRBbmdsZSAqIE1hdGguUEkgLyAxODA7XHJcblxyXG4gIC8qIERlcGVuZGluZyBvbiB0aGUgaGVpZ2h0IGFuZCB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlLCB3ZSBtYXkgbmVlZCB0byB1c2UgZGlmZmVyZW50IGZvcm11bGFzIHRvIGNhbGN1bGF0ZSB0aGUgYW5nbGVkXHJcbiAgICogd2lkdGguIFRoaXMgdGhyZXNob2xkIGRlZmluZXMgd2hlbiBlYWNoIGZvcm11bGEgc2hvdWxkIGtpY2sgaW4uICovXHJcbiAgdmFyIGFuZ2xlVGhyZXNob2xkID0gTWF0aC5hdGFuKGhlaWdodCAvIHdpZHRoKTtcclxuICB2YXIgYW5nbGVkV2lkdGggPSBhbmdsZVJhZGlhbnMgPiBhbmdsZVRocmVzaG9sZCAmJiBhbmdsZVJhZGlhbnMgPCBNYXRoLlBJIC0gYW5nbGVUaHJlc2hvbGQgPyBoZWlnaHQgLyBNYXRoLnNpbihhbmdsZVJhZGlhbnMpIDogd2lkdGggLyBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xyXG4gIHJldHVybiBNYXRoLmFicyhhbmdsZWRXaWR0aCk7XHJcbn07Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0QW5nbGVkUmVjdGFuZ2xlV2lkdGgiLCJmb3JtYXRBeGlzTWFwIiwiY3JlYXRlTGFiZWxlZFNjYWxlcyIsIlNjYWxlSGVscGVyIiwibm9ybWFsaXplQW5nbGUiLCJyZWN0V2l0aFBvaW50cyIsInJlY3RXaXRoQ29vcmRzIiwiX21hcFZhbHVlcyIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2V2ZXJ5IiwiX0NoYXJ0VXRpbHMiLCJfUmVhY3RVdGlscyIsIl9EYXRhVXRpbHMiLCJfQmFyIiwib2JqIiwiX19lc01vZHVsZSIsIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJvd25LZXlzIiwiZSIsInIiLCJ0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsImNhbGwiLCJTdHJpbmciLCJOdW1iZXIiLCJheGlzTWFwIiwib2Zmc2V0IiwiYXhpc1R5cGUiLCJjaGFydE5hbWUiLCJ3aWR0aCIsImhlaWdodCIsImxheW91dCIsImNoaWxkcmVuIiwiaWRzIiwic3RlcHMiLCJsZWZ0IiwibGVmdE1pcnJvciIsInJpZ2h0IiwicmlnaHRNaXJyb3IiLCJ0b3AiLCJ0b3BNaXJyb3IiLCJib3R0b20iLCJib3R0b21NaXJyb3IiLCJoYXNCYXIiLCJmaW5kQ2hpbGRCeVR5cGUiLCJCYXIiLCJyZWR1Y2UiLCJyZXN1bHQiLCJpZCIsImF4aXMiLCJvcmllbnRhdGlvbiIsImRvbWFpbiIsIl9heGlzJHBhZGRpbmciLCJwYWRkaW5nIiwibWlycm9yIiwicmV2ZXJzZWQiLCJvZmZzZXRLZXkiLCJjb25jYXQiLCJjYWxjdWxhdGVkUGFkZGluZyIsInJhbmdlIiwieCIsInkiLCJuZWVkU3BhY2UiLCJ0eXBlIiwiZGlmZiIsInNtYWxsZXN0RGlzdGFuY2VCZXR3ZWVuVmFsdWVzIiwiSW5maW5pdHkiLCJzb3J0ZWRWYWx1ZXMiLCJjYXRlZ29yaWNhbERvbWFpbiIsInNvcnQiLCJjb21wYXJlVmFsdWVzIiwiaW5kZXgiLCJNYXRoIiwibWluIiwiaXNGaW5pdGUiLCJzbWFsbGVzdERpc3RhbmNlSW5QZXJjZW50IiwicmFuZ2VXaWR0aCIsImdhcCIsImdldFBlcmNlbnRWYWx1ZSIsImJhckNhdGVnb3J5R2FwIiwiaGFsZkJhbmQiLCJfcGFyc2VTY2FsZSIsInBhcnNlU2NhbGUiLCJzY2FsZSIsInJlYWxTY2FsZVR5cGUiLCJjaGVja0RvbWFpbk9mU2NhbGUiLCJ0aWNrcyIsImdldFRpY2tzT2ZTY2FsZSIsImZpbmFsQXhpcyIsImJhbmRTaXplIiwiZ2V0QmFuZFNpemVPZkF4aXMiLCJoaWRlIiwiX3JlZiIsIl9yZWYyIiwieDEiLCJ5MSIsIngyIiwieTIiLCJhYnMiLCJfcmVmMyIsImdldCIsImJhbmR3aWR0aCIsIl9yZWY0IiwidW5kZWZpbmVkIiwiYmFuZEF3YXJlIiwicG9zaXRpb24iLCJfb2Zmc2V0IiwiX29mZnNldDIiLCJpc0luUmFuZ2UiLCJmaXJzdCIsImxhc3QiLCJjcmVhdGUiLCJvcHRpb25zIiwic2NhbGVzIiwicmVzIiwiY29vcmQiLCJfcmVmNSIsImxhYmVsIiwiYW5nbGUiLCJfcmVmNiIsIm5vcm1hbGl6ZWRBbmdsZSIsImFuZ2xlUmFkaWFucyIsIlBJIiwiYW5nbGVUaHJlc2hvbGQiLCJhdGFuIiwiYW5nbGVkV2lkdGgiLCJzaW4iLCJjb3MiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/CartesianUtils.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/util/ChartUtils.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getCateCoordinateOfBar = exports.getBaseValueOfBar = exports.getBarSizeList = exports.getBarPosition = exports.getBandSizeOfAxis = exports.findPositionOfBar = exports.combineEventHandlers = exports.checkDomainOfScale = exports.calculateActiveTickIndex = exports.appendOffsetOfLegend = exports.MIN_VALUE_REG = exports.MAX_VALUE_REG = void 0;\nexports.getCateCoordinateOfLine = getCateCoordinateOfLine;\nexports.getCoordinatesOfGrid = void 0;\nexports.getDomainOfDataByKey = getDomainOfDataByKey;\nexports.getDomainOfStackGroups = exports.getDomainOfItemsWithSameAxis = exports.getDomainOfErrorBars = void 0;\nObject.defineProperty(exports, \"getLegendProps\", ({\n    enumerable: true,\n    get: function get() {\n        return _getLegendProps.getLegendProps;\n    }\n}));\nexports.getTooltipItem = exports.getTicksOfScale = exports.getTicksOfAxis = exports.getStackedDataOfItem = exports.getStackedData = exports.getStackGroupsByAxisId = exports.getMainColorOfGraphicItem = void 0;\nexports.getValueByDataKey = getValueByDataKey;\nexports.truncateByDomain = exports.parseSpecifiedDomain = exports.parseScale = exports.parseErrorBarsOfAxis = exports.parseDomainOfCategoryAxis = exports.offsetSign = exports.offsetPositive = exports.isCategoricalAxis = void 0;\nvar d3Scales = _interopRequireWildcard(__webpack_require__(/*! victory-vendor/d3-scale */ \"victory-vendor/d3-scale\"));\nvar _d3Shape = __webpack_require__(/*! victory-vendor/d3-shape */ \"victory-vendor/d3-shape\");\nvar _max = _interopRequireDefault(__webpack_require__(/*! lodash/max */ \"lodash/max\"));\nvar _min = _interopRequireDefault(__webpack_require__(/*! lodash/min */ \"lodash/min\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _isString = _interopRequireDefault(__webpack_require__(/*! lodash/isString */ \"lodash/isString\"));\nvar _get = _interopRequireDefault(__webpack_require__(/*! lodash/get */ \"lodash/get\"));\nvar _flatMap = _interopRequireDefault(__webpack_require__(/*! lodash/flatMap */ \"lodash/flatMap\"));\nvar _isNaN = _interopRequireDefault(__webpack_require__(/*! lodash/isNaN */ \"lodash/isNaN\"));\nvar _upperFirst = _interopRequireDefault(__webpack_require__(/*! lodash/upperFirst */ \"lodash/upperFirst\"));\nvar _isEqual = _interopRequireDefault(__webpack_require__(/*! lodash/isEqual */ \"lodash/isEqual\"));\nvar _sortBy = _interopRequireDefault(__webpack_require__(/*! lodash/sortBy */ \"lodash/sortBy\"));\nvar _rechartsScale = __webpack_require__(/*! recharts-scale */ \"recharts-scale\");\nvar _ErrorBar = __webpack_require__(/*! ../cartesian/ErrorBar */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/ErrorBar.js\");\nvar _DataUtils = __webpack_require__(/*! ./DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ./ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _getLegendProps = __webpack_require__(/*! ./getLegendProps */ \"(pages-dir-node)/./node_modules/recharts/lib/util/getLegendProps.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} // TODO: Cause of circular dependency. Needs refactor.\n// import { RadiusAxisProps, AngleAxisProps } from '../polar/types';\n// Exported for backwards compatibility\nfunction getValueByDataKey(obj, dataKey, defaultValue) {\n    if ((0, _isNil[\"default\"])(obj) || (0, _isNil[\"default\"])(dataKey)) {\n        return defaultValue;\n    }\n    if ((0, _DataUtils.isNumOrStr)(dataKey)) {\n        return (0, _get[\"default\"])(obj, dataKey, defaultValue);\n    }\n    if ((0, _isFunction[\"default\"])(dataKey)) {\n        return dataKey(obj);\n    }\n    return defaultValue;\n}\n/**\r\n * Get domain of data by key.\r\n * @param  {Array}   data      The data displayed in the chart\r\n * @param  {String}  key       The unique key of a group of data\r\n * @param  {String}  type      The type of axis\r\n * @param  {Boolean} filterNil Whether or not filter nil values\r\n * @return {Array} Domain of data\r\n */ function getDomainOfDataByKey(data, key, type, filterNil) {\n    var flattenData = (0, _flatMap[\"default\"])(data, function(entry) {\n        return getValueByDataKey(entry, key);\n    });\n    if (type === 'number') {\n        // @ts-expect-error parseFloat type only accepts strings\n        var domain = flattenData.filter(function(entry) {\n            return (0, _DataUtils.isNumber)(entry) || parseFloat(entry);\n        });\n        return domain.length ? [\n            (0, _min[\"default\"])(domain),\n            (0, _max[\"default\"])(domain)\n        ] : [\n            Infinity,\n            -Infinity\n        ];\n    }\n    var validateData = filterNil ? flattenData.filter(function(entry) {\n        return !(0, _isNil[\"default\"])(entry);\n    }) : flattenData;\n    // Supports x-axis of Date type\n    return validateData.map(function(entry) {\n        return (0, _DataUtils.isNumOrStr)(entry) || entry instanceof Date ? entry : '';\n    });\n}\nvar calculateActiveTickIndex = exports.calculateActiveTickIndex = function calculateActiveTickIndex(coordinate) {\n    var _ticks$length;\n    var ticks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var unsortedTicks = arguments.length > 2 ? arguments[2] : undefined;\n    var axis = arguments.length > 3 ? arguments[3] : undefined;\n    var index = -1;\n    var len = (_ticks$length = ticks === null || ticks === void 0 ? void 0 : ticks.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;\n    // if there are 1 or less ticks ticks then the active tick is at index 0\n    if (len <= 1) {\n        return 0;\n    }\n    if (axis && axis.axisType === 'angleAxis' && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {\n        var range = axis.range;\n        // ticks are distributed in a circle\n        for(var i = 0; i < len; i++){\n            var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;\n            var cur = unsortedTicks[i].coordinate;\n            var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;\n            var sameDirectionCoord = void 0;\n            if ((0, _DataUtils.mathSign)(cur - before) !== (0, _DataUtils.mathSign)(after - cur)) {\n                var diffInterval = [];\n                if ((0, _DataUtils.mathSign)(after - cur) === (0, _DataUtils.mathSign)(range[1] - range[0])) {\n                    sameDirectionCoord = after;\n                    var curInRange = cur + range[1] - range[0];\n                    diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);\n                    diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);\n                } else {\n                    sameDirectionCoord = before;\n                    var afterInRange = after + range[1] - range[0];\n                    diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);\n                    diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);\n                }\n                var sameInterval = [\n                    Math.min(cur, (sameDirectionCoord + cur) / 2),\n                    Math.max(cur, (sameDirectionCoord + cur) / 2)\n                ];\n                if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {\n                    index = unsortedTicks[i].index;\n                    break;\n                }\n            } else {\n                var minValue = Math.min(before, after);\n                var maxValue = Math.max(before, after);\n                if (coordinate > (minValue + cur) / 2 && coordinate <= (maxValue + cur) / 2) {\n                    index = unsortedTicks[i].index;\n                    break;\n                }\n            }\n        }\n    } else {\n        // ticks are distributed in a single direction\n        for(var _i = 0; _i < len; _i++){\n            if (_i === 0 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2) {\n                index = ticks[_i].index;\n                break;\n            }\n        }\n    }\n    return index;\n};\n/**\r\n * Get the main color of each graphic item\r\n * @param  {ReactElement} item A graphic item\r\n * @return {String}            Color\r\n */ var getMainColorOfGraphicItem = exports.getMainColorOfGraphicItem = function getMainColorOfGraphicItem(item) {\n    var _item$type;\n    var _ref = item, displayName = _ref.type.displayName; // TODO: check if displayName is valid.\n    var defaultedProps = (_item$type = item.type) !== null && _item$type !== void 0 && _item$type.defaultProps ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;\n    var stroke = defaultedProps.stroke, fill = defaultedProps.fill;\n    var result;\n    switch(displayName){\n        case 'Line':\n            result = stroke;\n            break;\n        case 'Area':\n        case 'Radar':\n            result = stroke && stroke !== 'none' ? stroke : fill;\n            break;\n        default:\n            result = fill;\n            break;\n    }\n    return result;\n};\n/**\r\n * Calculate the size of all groups for stacked bar graph\r\n * @param  {Object} stackGroups The items grouped by axisId and stackId\r\n * @return {Object} The size of all groups\r\n */ var getBarSizeList = exports.getBarSizeList = function getBarSizeList(_ref2) {\n    var globalSize = _ref2.barSize, totalSize = _ref2.totalSize, _ref2$stackGroups = _ref2.stackGroups, stackGroups = _ref2$stackGroups === void 0 ? {} : _ref2$stackGroups;\n    if (!stackGroups) {\n        return {};\n    }\n    var result = {};\n    var numericAxisIds = Object.keys(stackGroups);\n    for(var i = 0, len = numericAxisIds.length; i < len; i++){\n        var sgs = stackGroups[numericAxisIds[i]].stackGroups;\n        var stackIds = Object.keys(sgs);\n        for(var j = 0, sLen = stackIds.length; j < sLen; j++){\n            var _sgs$stackIds$j = sgs[stackIds[j]], items = _sgs$stackIds$j.items, cateAxisId = _sgs$stackIds$j.cateAxisId;\n            var barItems = items.filter(function(item) {\n                return (0, _ReactUtils.getDisplayName)(item.type).indexOf('Bar') >= 0;\n            });\n            if (barItems && barItems.length) {\n                var barItemDefaultProps = barItems[0].type.defaultProps;\n                var barItemProps = barItemDefaultProps !== undefined ? _objectSpread(_objectSpread({}, barItemDefaultProps), barItems[0].props) : barItems[0].props;\n                var selfSize = barItemProps.barSize;\n                var cateId = barItemProps[cateAxisId];\n                if (!result[cateId]) {\n                    result[cateId] = [];\n                }\n                var barSize = (0, _isNil[\"default\"])(selfSize) ? globalSize : selfSize;\n                result[cateId].push({\n                    item: barItems[0],\n                    stackList: barItems.slice(1),\n                    barSize: (0, _isNil[\"default\"])(barSize) ? undefined : (0, _DataUtils.getPercentValue)(barSize, totalSize, 0)\n                });\n            }\n        }\n    }\n    return result;\n};\n/**\r\n * Calculate the size of each bar and offset between start of band and the bar\r\n *\r\n * @param  {number} bandSize is the size of area where bars can render\r\n * @param  {number | string} barGap is the gap size, as a percentage of `bandSize`.\r\n *                                  Can be defined as number or percent string\r\n * @param  {number | string} barCategoryGap is the gap size, as a percentage of `bandSize`.\r\n *                                  Can be defined as number or percent string\r\n * @param  {Array<object>} sizeList Sizes of all groups\r\n * @param  {number} maxBarSize The maximum size of each bar\r\n * @return {Array<object>} The size and offset of each bar\r\n */ var getBarPosition = exports.getBarPosition = function getBarPosition(_ref3) {\n    var barGap = _ref3.barGap, barCategoryGap = _ref3.barCategoryGap, bandSize = _ref3.bandSize, _ref3$sizeList = _ref3.sizeList, sizeList = _ref3$sizeList === void 0 ? [] : _ref3$sizeList, maxBarSize = _ref3.maxBarSize;\n    var len = sizeList.length;\n    if (len < 1) return null;\n    var realBarGap = (0, _DataUtils.getPercentValue)(barGap, bandSize, 0, true);\n    var result;\n    var initialValue = [];\n    // whether or not is barSize setted by user\n    if (sizeList[0].barSize === +sizeList[0].barSize) {\n        var useFull = false;\n        var fullBarSize = bandSize / len;\n        // @ts-expect-error the type check above does not check for type number explicitly\n        var sum = sizeList.reduce(function(res, entry) {\n            return res + entry.barSize || 0;\n        }, 0);\n        sum += (len - 1) * realBarGap;\n        if (sum >= bandSize) {\n            sum -= (len - 1) * realBarGap;\n            realBarGap = 0;\n        }\n        if (sum >= bandSize && fullBarSize > 0) {\n            useFull = true;\n            fullBarSize *= 0.9;\n            sum = len * fullBarSize;\n        }\n        var offset = (bandSize - sum) / 2 >> 0;\n        var prev = {\n            offset: offset - realBarGap,\n            size: 0\n        };\n        result = sizeList.reduce(function(res, entry) {\n            var newPosition = {\n                item: entry.item,\n                position: {\n                    offset: prev.offset + prev.size + realBarGap,\n                    // @ts-expect-error the type check above does not check for type number explicitly\n                    size: useFull ? fullBarSize : entry.barSize\n                }\n            };\n            var newRes = [].concat(_toConsumableArray(res), [\n                newPosition\n            ]);\n            prev = newRes[newRes.length - 1].position;\n            if (entry.stackList && entry.stackList.length) {\n                entry.stackList.forEach(function(item) {\n                    newRes.push({\n                        item: item,\n                        position: prev\n                    });\n                });\n            }\n            return newRes;\n        }, initialValue);\n    } else {\n        var _offset = (0, _DataUtils.getPercentValue)(barCategoryGap, bandSize, 0, true);\n        if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {\n            realBarGap = 0;\n        }\n        var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;\n        if (originalSize > 1) {\n            originalSize >>= 0;\n        }\n        var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;\n        result = sizeList.reduce(function(res, entry, i) {\n            var newRes = [].concat(_toConsumableArray(res), [\n                {\n                    item: entry.item,\n                    position: {\n                        offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,\n                        size: size\n                    }\n                }\n            ]);\n            if (entry.stackList && entry.stackList.length) {\n                entry.stackList.forEach(function(item) {\n                    newRes.push({\n                        item: item,\n                        position: newRes[newRes.length - 1].position\n                    });\n                });\n            }\n            return newRes;\n        }, initialValue);\n    }\n    return result;\n};\nvar appendOffsetOfLegend = exports.appendOffsetOfLegend = function appendOffsetOfLegend(offset, _unused, props, legendBox) {\n    var children = props.children, width = props.width, margin = props.margin;\n    var legendWidth = width - (margin.left || 0) - (margin.right || 0);\n    var legendProps = (0, _getLegendProps.getLegendProps)({\n        children: children,\n        legendWidth: legendWidth\n    });\n    if (legendProps) {\n        var _ref4 = legendBox || {}, boxWidth = _ref4.width, boxHeight = _ref4.height;\n        var align = legendProps.align, verticalAlign = legendProps.verticalAlign, layout = legendProps.layout;\n        if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'middle') && align !== 'center' && (0, _DataUtils.isNumber)(offset[align])) {\n            return _objectSpread(_objectSpread({}, offset), {}, _defineProperty({}, align, offset[align] + (boxWidth || 0)));\n        }\n        if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && verticalAlign !== 'middle' && (0, _DataUtils.isNumber)(offset[verticalAlign])) {\n            return _objectSpread(_objectSpread({}, offset), {}, _defineProperty({}, verticalAlign, offset[verticalAlign] + (boxHeight || 0)));\n        }\n    }\n    return offset;\n};\nvar isErrorBarRelevantForAxis = function isErrorBarRelevantForAxis(layout, axisType, direction) {\n    if ((0, _isNil[\"default\"])(axisType)) {\n        return true;\n    }\n    if (layout === 'horizontal') {\n        return axisType === 'yAxis';\n    }\n    if (layout === 'vertical') {\n        return axisType === 'xAxis';\n    }\n    if (direction === 'x') {\n        return axisType === 'xAxis';\n    }\n    if (direction === 'y') {\n        return axisType === 'yAxis';\n    }\n    return true;\n};\nvar getDomainOfErrorBars = exports.getDomainOfErrorBars = function getDomainOfErrorBars(data, item, dataKey, layout, axisType) {\n    var children = item.props.children;\n    var errorBars = (0, _ReactUtils.findAllByType)(children, _ErrorBar.ErrorBar).filter(function(errorBarChild) {\n        return isErrorBarRelevantForAxis(layout, axisType, errorBarChild.props.direction);\n    });\n    if (errorBars && errorBars.length) {\n        var keys = errorBars.map(function(errorBarChild) {\n            return errorBarChild.props.dataKey;\n        });\n        return data.reduce(function(result, entry) {\n            var entryValue = getValueByDataKey(entry, dataKey);\n            if ((0, _isNil[\"default\"])(entryValue)) return result;\n            var mainValue = Array.isArray(entryValue) ? [\n                (0, _min[\"default\"])(entryValue),\n                (0, _max[\"default\"])(entryValue)\n            ] : [\n                entryValue,\n                entryValue\n            ];\n            var errorDomain = keys.reduce(function(prevErrorArr, k) {\n                var errorValue = getValueByDataKey(entry, k, 0);\n                var lowerValue = mainValue[0] - Math.abs(Array.isArray(errorValue) ? errorValue[0] : errorValue);\n                var upperValue = mainValue[1] + Math.abs(Array.isArray(errorValue) ? errorValue[1] : errorValue);\n                return [\n                    Math.min(lowerValue, prevErrorArr[0]),\n                    Math.max(upperValue, prevErrorArr[1])\n                ];\n            }, [\n                Infinity,\n                -Infinity\n            ]);\n            return [\n                Math.min(errorDomain[0], result[0]),\n                Math.max(errorDomain[1], result[1])\n            ];\n        }, [\n            Infinity,\n            -Infinity\n        ]);\n    }\n    return null;\n};\nvar parseErrorBarsOfAxis = exports.parseErrorBarsOfAxis = function parseErrorBarsOfAxis(data, items, dataKey, axisType, layout) {\n    var domains = items.map(function(item) {\n        return getDomainOfErrorBars(data, item, dataKey, layout, axisType);\n    }).filter(function(entry) {\n        return !(0, _isNil[\"default\"])(entry);\n    });\n    if (domains && domains.length) {\n        return domains.reduce(function(result, entry) {\n            return [\n                Math.min(result[0], entry[0]),\n                Math.max(result[1], entry[1])\n            ];\n        }, [\n            Infinity,\n            -Infinity\n        ]);\n    }\n    return null;\n};\n/**\r\n * Get domain of data by the configuration of item element\r\n * @param  {Array}   data      The data displayed in the chart\r\n * @param  {Array}   items     The instances of item\r\n * @param  {String}  type      The type of axis, number - Number Axis, category - Category Axis\r\n * @param  {LayoutType} layout The type of layout\r\n * @param  {Boolean} filterNil Whether or not filter nil values\r\n * @return {Array}        Domain\r\n */ var getDomainOfItemsWithSameAxis = exports.getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis(data, items, type, layout, filterNil) {\n    var domains = items.map(function(item) {\n        var dataKey = item.props.dataKey;\n        if (type === 'number' && dataKey) {\n            return getDomainOfErrorBars(data, item, dataKey, layout) || getDomainOfDataByKey(data, dataKey, type, filterNil);\n        }\n        return getDomainOfDataByKey(data, dataKey, type, filterNil);\n    });\n    if (type === 'number') {\n        // Calculate the domain of number axis\n        return domains.reduce(// @ts-expect-error if (type === number) means that the domain is numerical type\n        // - but this link is missing in the type definition\n        function(result, entry) {\n            return [\n                Math.min(result[0], entry[0]),\n                Math.max(result[1], entry[1])\n            ];\n        }, [\n            Infinity,\n            -Infinity\n        ]);\n    }\n    var tag = {};\n    // Get the union set of category axis\n    return domains.reduce(function(result, entry) {\n        for(var i = 0, len = entry.length; i < len; i++){\n            // @ts-expect-error Date cannot index an object\n            if (!tag[entry[i]]) {\n                // @ts-expect-error Date cannot index an object\n                tag[entry[i]] = true;\n                // @ts-expect-error Date cannot index an object\n                result.push(entry[i]);\n            }\n        }\n        return result;\n    }, []);\n};\nvar isCategoricalAxis = exports.isCategoricalAxis = function isCategoricalAxis(layout, axisType) {\n    return layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n};\n/**\r\n * Calculate the Coordinates of grid\r\n * @param  {Array} ticks           The ticks in axis\r\n * @param {Number} minValue        The minimun value of axis\r\n * @param {Number} maxValue        The maximun value of axis\r\n * @param {boolean} syncWithTicks  Synchronize grid lines with ticks or not\r\n * @return {Array}                 Coordinates\r\n */ var getCoordinatesOfGrid = exports.getCoordinatesOfGrid = function getCoordinatesOfGrid(ticks, minValue, maxValue, syncWithTicks) {\n    if (syncWithTicks) {\n        return ticks.map(function(entry) {\n            return entry.coordinate;\n        });\n    }\n    var hasMin, hasMax;\n    var values = ticks.map(function(entry) {\n        if (entry.coordinate === minValue) {\n            hasMin = true;\n        }\n        if (entry.coordinate === maxValue) {\n            hasMax = true;\n        }\n        return entry.coordinate;\n    });\n    if (!hasMin) {\n        values.push(minValue);\n    }\n    if (!hasMax) {\n        values.push(maxValue);\n    }\n    return values;\n};\n/**\r\n * Get the ticks of an axis\r\n * @param  {Object}  axis The configuration of an axis\r\n * @param {Boolean} isGrid Whether or not are the ticks in grid\r\n * @param {Boolean} isAll Return the ticks of all the points or not\r\n * @return {Array}  Ticks\r\n */ var getTicksOfAxis = exports.getTicksOfAxis = function getTicksOfAxis(axis, isGrid, isAll) {\n    if (!axis) return null;\n    var scale = axis.scale;\n    var duplicateDomain = axis.duplicateDomain, type = axis.type, range = axis.range;\n    var offsetForBand = axis.realScaleType === 'scaleBand' ? scale.bandwidth() / 2 : 2;\n    var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n    offset = axis.axisType === 'angleAxis' && (range === null || range === void 0 ? void 0 : range.length) >= 2 ? (0, _DataUtils.mathSign)(range[0] - range[1]) * 2 * offset : offset;\n    // The ticks set by user should only affect the ticks adjacent to axis line\n    if (isGrid && (axis.ticks || axis.niceTicks)) {\n        var result = (axis.ticks || axis.niceTicks).map(function(entry) {\n            var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n            return {\n                // If the scaleContent is not a number, the coordinate will be NaN.\n                // That could be the case for example with a PointScale and a string as domain.\n                coordinate: scale(scaleContent) + offset,\n                value: entry,\n                offset: offset\n            };\n        });\n        return result.filter(function(row) {\n            return !(0, _isNaN[\"default\"])(row.coordinate);\n        });\n    }\n    // When axis is a categorial axis, but the type of axis is number or the scale of axis is not \"auto\"\n    if (axis.isCategorical && axis.categoricalDomain) {\n        return axis.categoricalDomain.map(function(entry, index) {\n            return {\n                coordinate: scale(entry) + offset,\n                value: entry,\n                index: index,\n                offset: offset\n            };\n        });\n    }\n    if (scale.ticks && !isAll) {\n        return scale.ticks(axis.tickCount).map(function(entry) {\n            return {\n                coordinate: scale(entry) + offset,\n                value: entry,\n                offset: offset\n            };\n        });\n    }\n    // When axis has duplicated text, serial numbers are used to generate scale\n    return scale.domain().map(function(entry, index) {\n        return {\n            coordinate: scale(entry) + offset,\n            value: duplicateDomain ? duplicateDomain[entry] : entry,\n            index: index,\n            offset: offset\n        };\n    });\n};\n/**\r\n * combine the handlers\r\n * @param  {Function} defaultHandler Internal private handler\r\n * @param  {Function} childHandler Handler function specified in child component\r\n * @return {Function}                The combined handler\r\n */ var handlerWeakMap = new WeakMap();\nvar combineEventHandlers = exports.combineEventHandlers = function combineEventHandlers(defaultHandler, childHandler) {\n    if (typeof childHandler !== 'function') {\n        return defaultHandler;\n    }\n    if (!handlerWeakMap.has(defaultHandler)) {\n        handlerWeakMap.set(defaultHandler, new WeakMap());\n    }\n    var childWeakMap = handlerWeakMap.get(defaultHandler);\n    if (childWeakMap.has(childHandler)) {\n        return childWeakMap.get(childHandler);\n    }\n    var combineHandler = function combineHandler() {\n        defaultHandler.apply(void 0, arguments);\n        childHandler.apply(void 0, arguments);\n    };\n    childWeakMap.set(childHandler, combineHandler);\n    return combineHandler;\n};\n/**\r\n * Parse the scale function of axis\r\n * @param  {Object}   axis          The option of axis\r\n * @param  {String}   chartType     The displayName of chart\r\n * @param  {Boolean}  hasBar        if it has a bar\r\n * @return {object}               The scale function and resolved name\r\n */ var parseScale = exports.parseScale = function parseScale(axis, chartType, hasBar) {\n    var scale = axis.scale, type = axis.type, layout = axis.layout, axisType = axis.axisType;\n    if (scale === 'auto') {\n        if (layout === 'radial' && axisType === 'radiusAxis') {\n            return {\n                scale: d3Scales.scaleBand(),\n                realScaleType: 'band'\n            };\n        }\n        if (layout === 'radial' && axisType === 'angleAxis') {\n            return {\n                scale: d3Scales.scaleLinear(),\n                realScaleType: 'linear'\n            };\n        }\n        if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0 || chartType.indexOf('ComposedChart') >= 0 && !hasBar)) {\n            return {\n                scale: d3Scales.scalePoint(),\n                realScaleType: 'point'\n            };\n        }\n        if (type === 'category') {\n            return {\n                scale: d3Scales.scaleBand(),\n                realScaleType: 'band'\n            };\n        }\n        return {\n            scale: d3Scales.scaleLinear(),\n            realScaleType: 'linear'\n        };\n    }\n    if ((0, _isString[\"default\"])(scale)) {\n        var name = \"scale\".concat((0, _upperFirst[\"default\"])(scale));\n        return {\n            scale: (d3Scales[name] || d3Scales.scalePoint)(),\n            realScaleType: d3Scales[name] ? name : 'point'\n        };\n    }\n    return (0, _isFunction[\"default\"])(scale) ? {\n        scale: scale\n    } : {\n        scale: d3Scales.scalePoint(),\n        realScaleType: 'point'\n    };\n};\nvar EPS = 1e-4;\nvar checkDomainOfScale = exports.checkDomainOfScale = function checkDomainOfScale(scale) {\n    var domain = scale.domain();\n    if (!domain || domain.length <= 2) {\n        return;\n    }\n    var len = domain.length;\n    var range = scale.range();\n    var minValue = Math.min(range[0], range[1]) - EPS;\n    var maxValue = Math.max(range[0], range[1]) + EPS;\n    var first = scale(domain[0]);\n    var last = scale(domain[len - 1]);\n    if (first < minValue || first > maxValue || last < minValue || last > maxValue) {\n        scale.domain([\n            domain[0],\n            domain[len - 1]\n        ]);\n    }\n};\nvar findPositionOfBar = exports.findPositionOfBar = function findPositionOfBar(barPosition, child) {\n    if (!barPosition) {\n        return null;\n    }\n    for(var i = 0, len = barPosition.length; i < len; i++){\n        if (barPosition[i].item === child) {\n            return barPosition[i].position;\n        }\n    }\n    return null;\n};\n/**\r\n * Both value and domain are tuples of two numbers\r\n * - but the type stays as array of numbers until we have better support in rest of the app\r\n * @param {Array} value input that will be truncated\r\n * @param {Array} domain boundaries\r\n * @returns {Array} tuple of two numbers\r\n */ var truncateByDomain = exports.truncateByDomain = function truncateByDomain(value, domain) {\n    if (!domain || domain.length !== 2 || !(0, _DataUtils.isNumber)(domain[0]) || !(0, _DataUtils.isNumber)(domain[1])) {\n        return value;\n    }\n    var minValue = Math.min(domain[0], domain[1]);\n    var maxValue = Math.max(domain[0], domain[1]);\n    var result = [\n        value[0],\n        value[1]\n    ];\n    if (!(0, _DataUtils.isNumber)(value[0]) || value[0] < minValue) {\n        result[0] = minValue;\n    }\n    if (!(0, _DataUtils.isNumber)(value[1]) || value[1] > maxValue) {\n        result[1] = maxValue;\n    }\n    if (result[0] > maxValue) {\n        result[0] = maxValue;\n    }\n    if (result[1] < minValue) {\n        result[1] = minValue;\n    }\n    return result;\n};\n/**\r\n * Stacks all positive numbers above zero and all negative numbers below zero.\r\n *\r\n * If all values in the series are positive then this behaves the same as 'none' stacker.\r\n *\r\n * @param {Array} series from d3-shape Stack\r\n * @return {Array} series with applied offset\r\n */ var offsetSign = exports.offsetSign = function offsetSign(series) {\n    var n = series.length;\n    if (n <= 0) {\n        return;\n    }\n    for(var j = 0, m = series[0].length; j < m; ++j){\n        var positive = 0;\n        var negative = 0;\n        for(var i = 0; i < n; ++i){\n            var value = (0, _isNaN[\"default\"])(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n            /* eslint-disable prefer-destructuring, no-param-reassign */ if (value >= 0) {\n                series[i][j][0] = positive;\n                series[i][j][1] = positive + value;\n                positive = series[i][j][1];\n            } else {\n                series[i][j][0] = negative;\n                series[i][j][1] = negative + value;\n                negative = series[i][j][1];\n            }\n        /* eslint-enable prefer-destructuring, no-param-reassign */ }\n    }\n};\n/**\r\n * Replaces all negative values with zero when stacking data.\r\n *\r\n * If all values in the series are positive then this behaves the same as 'none' stacker.\r\n *\r\n * @param {Array} series from d3-shape Stack\r\n * @return {Array} series with applied offset\r\n */ var offsetPositive = exports.offsetPositive = function offsetPositive(series) {\n    var n = series.length;\n    if (n <= 0) {\n        return;\n    }\n    for(var j = 0, m = series[0].length; j < m; ++j){\n        var positive = 0;\n        for(var i = 0; i < n; ++i){\n            var value = (0, _isNaN[\"default\"])(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n            /* eslint-disable prefer-destructuring, no-param-reassign */ if (value >= 0) {\n                series[i][j][0] = positive;\n                series[i][j][1] = positive + value;\n                positive = series[i][j][1];\n            } else {\n                series[i][j][0] = 0;\n                series[i][j][1] = 0;\n            }\n        /* eslint-enable prefer-destructuring, no-param-reassign */ }\n    }\n};\n/**\r\n * Function type to compute offset for stacked data.\r\n *\r\n * d3-shape has something fishy going on with its types.\r\n * In @definitelytyped/d3-shape, this function (the offset accessor) is typed as Series<> => void.\r\n * However! When I actually open the storybook I can see that the offset accessor actually receives Array<Series<>>.\r\n * The same I can see in the source code itself:\r\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\r\n * That one unfortunately has no types but we can tell it passes three-dimensional array.\r\n *\r\n * Which leads me to believe that definitelytyped is wrong on this one.\r\n * There's open discussion on this topic without much attention:\r\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\r\n */ var STACK_OFFSET_MAP = {\n    sign: offsetSign,\n    // @ts-expect-error definitelytyped types are incorrect\n    expand: _d3Shape.stackOffsetExpand,\n    // @ts-expect-error definitelytyped types are incorrect\n    none: _d3Shape.stackOffsetNone,\n    // @ts-expect-error definitelytyped types are incorrect\n    silhouette: _d3Shape.stackOffsetSilhouette,\n    // @ts-expect-error definitelytyped types are incorrect\n    wiggle: _d3Shape.stackOffsetWiggle,\n    positive: offsetPositive\n};\nvar getStackedData = exports.getStackedData = function getStackedData(data, stackItems, offsetType) {\n    var dataKeys = stackItems.map(function(item) {\n        return item.props.dataKey;\n    });\n    var offsetAccessor = STACK_OFFSET_MAP[offsetType];\n    var stack = (0, _d3Shape.stack)()// @ts-expect-error stack.keys type wants an array of strings, but we provide array of DataKeys\n    .keys(dataKeys).value(function(d, key) {\n        return +getValueByDataKey(d, key, 0);\n    }).order(_d3Shape.stackOrderNone)// @ts-expect-error definitelytyped types are incorrect\n    .offset(offsetAccessor);\n    return stack(data);\n};\nvar getStackGroupsByAxisId = exports.getStackGroupsByAxisId = function getStackGroupsByAxisId(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {\n    if (!data) {\n        return null;\n    }\n    // reversing items to affect render order (for layering)\n    var items = reverseStackOrder ? _items.reverse() : _items;\n    var parentStackGroupsInitialValue = {};\n    var stackGroups = items.reduce(function(result, item) {\n        var _item$type2;\n        var defaultedProps = (_item$type2 = item.type) !== null && _item$type2 !== void 0 && _item$type2.defaultProps ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;\n        var stackId = defaultedProps.stackId, hide = defaultedProps.hide;\n        if (hide) {\n            return result;\n        }\n        var axisId = defaultedProps[numericAxisId];\n        var parentGroup = result[axisId] || {\n            hasStack: false,\n            stackGroups: {}\n        };\n        if ((0, _DataUtils.isNumOrStr)(stackId)) {\n            var childGroup = parentGroup.stackGroups[stackId] || {\n                numericAxisId: numericAxisId,\n                cateAxisId: cateAxisId,\n                items: []\n            };\n            childGroup.items.push(item);\n            parentGroup.hasStack = true;\n            parentGroup.stackGroups[stackId] = childGroup;\n        } else {\n            parentGroup.stackGroups[(0, _DataUtils.uniqueId)('_stackId_')] = {\n                numericAxisId: numericAxisId,\n                cateAxisId: cateAxisId,\n                items: [\n                    item\n                ]\n            };\n        }\n        return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, parentGroup));\n    }, parentStackGroupsInitialValue);\n    var axisStackGroupsInitialValue = {};\n    return Object.keys(stackGroups).reduce(function(result, axisId) {\n        var group = stackGroups[axisId];\n        if (group.hasStack) {\n            var stackGroupsInitialValue = {};\n            group.stackGroups = Object.keys(group.stackGroups).reduce(function(res, stackId) {\n                var g = group.stackGroups[stackId];\n                return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, stackId, {\n                    numericAxisId: numericAxisId,\n                    cateAxisId: cateAxisId,\n                    items: g.items,\n                    stackedData: getStackedData(data, g.items, offsetType)\n                }));\n            }, stackGroupsInitialValue);\n        }\n        return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, group));\n    }, axisStackGroupsInitialValue);\n};\n/**\r\n * Configure the scale function of axis\r\n * @param {Object} scale The scale function\r\n * @param {Object} opts  The configuration of axis\r\n * @return {Object}      null\r\n */ var getTicksOfScale = exports.getTicksOfScale = function getTicksOfScale(scale, opts) {\n    var realScaleType = opts.realScaleType, type = opts.type, tickCount = opts.tickCount, originalDomain = opts.originalDomain, allowDecimals = opts.allowDecimals;\n    var scaleType = realScaleType || opts.scale;\n    if (scaleType !== 'auto' && scaleType !== 'linear') {\n        return null;\n    }\n    if (tickCount && type === 'number' && originalDomain && (originalDomain[0] === 'auto' || originalDomain[1] === 'auto')) {\n        // Calculate the ticks by the number of grid when the axis is a number axis\n        var domain = scale.domain();\n        if (!domain.length) {\n            return null;\n        }\n        var tickValues = (0, _rechartsScale.getNiceTickValues)(domain, tickCount, allowDecimals);\n        scale.domain([\n            (0, _min[\"default\"])(tickValues),\n            (0, _max[\"default\"])(tickValues)\n        ]);\n        return {\n            niceTicks: tickValues\n        };\n    }\n    if (tickCount && type === 'number') {\n        var _domain = scale.domain();\n        var _tickValues = (0, _rechartsScale.getTickValuesFixedDomain)(_domain, tickCount, allowDecimals);\n        return {\n            niceTicks: _tickValues\n        };\n    }\n    return null;\n};\nfunction getCateCoordinateOfLine(_ref5) {\n    var axis = _ref5.axis, ticks = _ref5.ticks, bandSize = _ref5.bandSize, entry = _ref5.entry, index = _ref5.index, dataKey = _ref5.dataKey;\n    if (axis.type === 'category') {\n        // find coordinate of category axis by the value of category\n        // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n        if (!axis.allowDuplicatedCategory && axis.dataKey && !(0, _isNil[\"default\"])(entry[axis.dataKey])) {\n            // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n            var matchedTick = (0, _DataUtils.findEntryInArray)(ticks, 'value', entry[axis.dataKey]);\n            if (matchedTick) {\n                return matchedTick.coordinate + bandSize / 2;\n            }\n        }\n        return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n    }\n    var value = getValueByDataKey(entry, !(0, _isNil[\"default\"])(dataKey) ? dataKey : axis.dataKey);\n    return !(0, _isNil[\"default\"])(value) ? axis.scale(value) : null;\n}\nvar getCateCoordinateOfBar = exports.getCateCoordinateOfBar = function getCateCoordinateOfBar(_ref6) {\n    var axis = _ref6.axis, ticks = _ref6.ticks, offset = _ref6.offset, bandSize = _ref6.bandSize, entry = _ref6.entry, index = _ref6.index;\n    if (axis.type === 'category') {\n        return ticks[index] ? ticks[index].coordinate + offset : null;\n    }\n    var value = getValueByDataKey(entry, axis.dataKey, axis.domain[index]);\n    return !(0, _isNil[\"default\"])(value) ? axis.scale(value) - bandSize / 2 + offset : null;\n};\nvar getBaseValueOfBar = exports.getBaseValueOfBar = function getBaseValueOfBar(_ref7) {\n    var numericAxis = _ref7.numericAxis;\n    var domain = numericAxis.scale.domain();\n    if (numericAxis.type === 'number') {\n        var minValue = Math.min(domain[0], domain[1]);\n        var maxValue = Math.max(domain[0], domain[1]);\n        if (minValue <= 0 && maxValue >= 0) {\n            return 0;\n        }\n        if (maxValue < 0) {\n            return maxValue;\n        }\n        return minValue;\n    }\n    return domain[0];\n};\nvar getStackedDataOfItem = exports.getStackedDataOfItem = function getStackedDataOfItem(item, stackGroups) {\n    var _item$type3;\n    var defaultedProps = (_item$type3 = item.type) !== null && _item$type3 !== void 0 && _item$type3.defaultProps ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;\n    var stackId = defaultedProps.stackId;\n    if ((0, _DataUtils.isNumOrStr)(stackId)) {\n        var group = stackGroups[stackId];\n        if (group) {\n            var itemIndex = group.items.indexOf(item);\n            return itemIndex >= 0 ? group.stackedData[itemIndex] : null;\n        }\n    }\n    return null;\n};\nvar getDomainOfSingle = function getDomainOfSingle(data) {\n    return data.reduce(function(result, entry) {\n        return [\n            (0, _min[\"default\"])(entry.concat([\n                result[0]\n            ]).filter(_DataUtils.isNumber)),\n            (0, _max[\"default\"])(entry.concat([\n                result[1]\n            ]).filter(_DataUtils.isNumber))\n        ];\n    }, [\n        Infinity,\n        -Infinity\n    ]);\n};\nvar getDomainOfStackGroups = exports.getDomainOfStackGroups = function getDomainOfStackGroups(stackGroups, startIndex, endIndex) {\n    return Object.keys(stackGroups).reduce(function(result, stackId) {\n        var group = stackGroups[stackId];\n        var stackedData = group.stackedData;\n        var domain = stackedData.reduce(function(res, entry) {\n            var s = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));\n            return [\n                Math.min(res[0], s[0]),\n                Math.max(res[1], s[1])\n            ];\n        }, [\n            Infinity,\n            -Infinity\n        ]);\n        return [\n            Math.min(domain[0], result[0]),\n            Math.max(domain[1], result[1])\n        ];\n    }, [\n        Infinity,\n        -Infinity\n    ]).map(function(result) {\n        return result === Infinity || result === -Infinity ? 0 : result;\n    });\n};\nvar MIN_VALUE_REG = exports.MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nvar MAX_VALUE_REG = exports.MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nvar parseSpecifiedDomain = exports.parseSpecifiedDomain = function parseSpecifiedDomain(specifiedDomain, dataDomain, allowDataOverflow) {\n    if ((0, _isFunction[\"default\"])(specifiedDomain)) {\n        return specifiedDomain(dataDomain, allowDataOverflow);\n    }\n    if (!Array.isArray(specifiedDomain)) {\n        return dataDomain;\n    }\n    var domain = [];\n    /* eslint-disable prefer-destructuring */ if ((0, _DataUtils.isNumber)(specifiedDomain[0])) {\n        domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);\n    } else if (MIN_VALUE_REG.test(specifiedDomain[0])) {\n        var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];\n        domain[0] = dataDomain[0] - value;\n    } else if ((0, _isFunction[\"default\"])(specifiedDomain[0])) {\n        domain[0] = specifiedDomain[0](dataDomain[0]);\n    } else {\n        domain[0] = dataDomain[0];\n    }\n    if ((0, _DataUtils.isNumber)(specifiedDomain[1])) {\n        domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);\n    } else if (MAX_VALUE_REG.test(specifiedDomain[1])) {\n        var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];\n        domain[1] = dataDomain[1] + _value;\n    } else if ((0, _isFunction[\"default\"])(specifiedDomain[1])) {\n        domain[1] = specifiedDomain[1](dataDomain[1]);\n    } else {\n        domain[1] = dataDomain[1];\n    }\n    /* eslint-enable prefer-destructuring */ return domain;\n};\n/**\r\n * Calculate the size between two category\r\n * @param  {Object} axis  The options of axis\r\n * @param  {Array}  ticks The ticks of axis\r\n * @param  {Boolean} isBar if items in axis are bars\r\n * @return {Number} Size\r\n */ var getBandSizeOfAxis = exports.getBandSizeOfAxis = function getBandSizeOfAxis(axis, ticks, isBar) {\n    // @ts-expect-error we need to rethink scale type\n    if (axis && axis.scale && axis.scale.bandwidth) {\n        // @ts-expect-error we need to rethink scale type\n        var bandWidth = axis.scale.bandwidth();\n        if (!isBar || bandWidth > 0) {\n            return bandWidth;\n        }\n    }\n    if (axis && ticks && ticks.length >= 2) {\n        var orderedTicks = (0, _sortBy[\"default\"])(ticks, function(o) {\n            return o.coordinate;\n        });\n        var bandSize = Infinity;\n        for(var i = 1, len = orderedTicks.length; i < len; i++){\n            var cur = orderedTicks[i];\n            var prev = orderedTicks[i - 1];\n            bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);\n        }\n        return bandSize === Infinity ? 0 : bandSize;\n    }\n    return isBar ? undefined : 0;\n};\n/**\r\n * parse the domain of a category axis when a domain is specified\r\n * @param   {Array}        specifiedDomain  The domain specified by users\r\n * @param   {Array}        calculatedDomain The domain calculated by dateKey\r\n * @param   {ReactElement} axisChild        The axis ReactElement\r\n * @returns {Array}        domains\r\n */ var parseDomainOfCategoryAxis = exports.parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis(specifiedDomain, calculatedDomain, axisChild) {\n    if (!specifiedDomain || !specifiedDomain.length) {\n        return calculatedDomain;\n    }\n    if ((0, _isEqual[\"default\"])(specifiedDomain, (0, _get[\"default\"])(axisChild, 'type.defaultProps.domain'))) {\n        return calculatedDomain;\n    }\n    return specifiedDomain;\n};\nvar getTooltipItem = exports.getTooltipItem = function getTooltipItem(graphicalItem, payload) {\n    var defaultedProps = graphicalItem.type.defaultProps ? _objectSpread(_objectSpread({}, graphicalItem.type.defaultProps), graphicalItem.props) : graphicalItem.props;\n    var dataKey = defaultedProps.dataKey, name = defaultedProps.name, unit = defaultedProps.unit, formatter = defaultedProps.formatter, tooltipType = defaultedProps.tooltipType, chartType = defaultedProps.chartType, hide = defaultedProps.hide;\n    return _objectSpread(_objectSpread({}, (0, _ReactUtils.filterProps)(graphicalItem, false)), {}, {\n        dataKey: dataKey,\n        unit: unit,\n        formatter: formatter,\n        name: name || dataKey,\n        color: getMainColorOfGraphicItem(graphicalItem),\n        value: getValueByDataKey(payload, dataKey),\n        type: tooltipType,\n        payload: payload,\n        chartType: chartType,\n        hide: hide\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9DaGFydFV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCw4QkFBOEIsR0FBR0EseUJBQXlCLEdBQUdBLHNCQUFzQixHQUFHQSxzQkFBc0IsR0FBR0EseUJBQXlCLEdBQUdBLHlCQUF5QixHQUFHQSw0QkFBNEIsR0FBR0EsMEJBQTBCLEdBQUdBLGdDQUFnQyxHQUFHQSw0QkFBNEIsR0FBR0EscUJBQXFCLEdBQUdBLHFCQUFxQixHQUFHLEtBQUs7QUFDMVZBLCtCQUErQixHQUFHYztBQUNsQ2QsNEJBQTRCLEdBQUcsS0FBSztBQUNwQ0EsNEJBQTRCLEdBQUdnQjtBQUMvQmhCLDhCQUE4QixHQUFHQSxvQ0FBb0MsR0FBR0EsNEJBQTRCLEdBQUcsS0FBSztBQUM1R0Ysa0RBQWlEO0lBQy9Dc0IsWUFBWTtJQUNaQyxLQUFLLFNBQVNBO1FBQ1osT0FBT0MsZ0JBQWdCQyxjQUFjO0lBQ3ZDO0FBQ0YsQ0FBQyxFQUFDO0FBQ0Z2QixzQkFBc0IsR0FBR0EsdUJBQXVCLEdBQUdBLHNCQUFzQixHQUFHQSw0QkFBNEIsR0FBR0Esc0JBQXNCLEdBQUdBLDhCQUE4QixHQUFHQSxpQ0FBaUMsR0FBRyxLQUFLO0FBQzlNQSx5QkFBeUIsR0FBRytCO0FBQzVCL0Isd0JBQXdCLEdBQUdBLDRCQUE0QixHQUFHQSxrQkFBa0IsR0FBR0EsNEJBQTRCLEdBQUdBLGlDQUFpQyxHQUFHQSxrQkFBa0IsR0FBR0Esc0JBQXNCLEdBQUdBLHlCQUF5QixHQUFHLEtBQUs7QUFDak8sSUFBSXdDLFdBQVdDLHdCQUF3QkMsbUJBQU9BLENBQUMsd0RBQXlCO0FBQ3hFLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDLHdEQUF5QjtBQUNoRCxJQUFJRSxPQUFPQyx1QkFBdUJILG1CQUFPQSxDQUFDLDhCQUFZO0FBQ3RELElBQUlJLE9BQU9ELHVC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RiIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcdXRpbFxcQ2hhcnRVdGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmdldENhdGVDb29yZGluYXRlT2ZCYXIgPSBleHBvcnRzLmdldEJhc2VWYWx1ZU9mQmFyID0gZXhwb3J0cy5nZXRCYXJTaXplTGlzdCA9IGV4cG9ydHMuZ2V0QmFyUG9zaXRpb24gPSBleHBvcnRzLmdldEJhbmRTaXplT2ZBeGlzID0gZXhwb3J0cy5maW5kUG9zaXRpb25PZkJhciA9IGV4cG9ydHMuY29tYmluZUV2ZW50SGFuZGxlcnMgPSBleHBvcnRzLmNoZWNrRG9tYWluT2ZTY2FsZSA9IGV4cG9ydHMuY2FsY3VsYXRlQWN0aXZlVGlja0luZGV4ID0gZXhwb3J0cy5hcHBlbmRPZmZzZXRPZkxlZ2VuZCA9IGV4cG9ydHMuTUlOX1ZBTFVFX1JFRyA9IGV4cG9ydHMuTUFYX1ZBTFVFX1JFRyA9IHZvaWQgMDtcclxuZXhwb3J0cy5nZXRDYXRlQ29vcmRpbmF0ZU9mTGluZSA9IGdldENhdGVDb29yZGluYXRlT2ZMaW5lO1xyXG5leHBvcnRzLmdldENvb3JkaW5hdGVzT2ZHcmlkID0gdm9pZCAwO1xyXG5leHBvcnRzLmdldERvbWFpbk9mRGF0YUJ5S2V5ID0gZ2V0RG9tYWluT2ZEYXRhQnlLZXk7XHJcbmV4cG9ydHMuZ2V0RG9tYWluT2ZTdGFja0dyb3VwcyA9IGV4cG9ydHMuZ2V0RG9tYWluT2ZJdGVtc1dpdGhTYW1lQXhpcyA9IGV4cG9ydHMuZ2V0RG9tYWluT2ZFcnJvckJhcnMgPSB2b2lkIDA7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldExlZ2VuZFByb3BzXCIsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgcmV0dXJuIF9nZXRMZWdlbmRQcm9wcy5nZXRMZWdlbmRQcm9wcztcclxuICB9XHJcbn0pO1xyXG5leHBvcnRzLmdldFRvb2x0aXBJdGVtID0gZXhwb3J0cy5nZXRUaWNrc09mU2NhbGUgPSBleHBvcnRzLmdldFRpY2tzT2ZBeGlzID0gZXhwb3J0cy5nZXRTdGFja2VkRGF0YU9mSXRlbSA9IGV4cG9ydHMuZ2V0U3RhY2tlZERhdGEgPSBleHBvcnRzLmdldFN0YWNrR3JvdXBzQnlBeGlzSWQgPSBleHBvcnRzLmdldE1haW5Db2xvck9mR3JhcGhpY0l0ZW0gPSB2b2lkIDA7XHJcbmV4cG9ydHMuZ2V0VmFsdWVCeURhdGFLZXkgPSBnZXRWYWx1ZUJ5RGF0YUtleTtcclxuZXhwb3J0cy50cnVuY2F0ZUJ5RG9tYWluID0gZXhwb3J0cy5wYXJzZVNwZWNpZmllZERvbWFpbiA9IGV4cG9ydHMucGFyc2VTY2FsZSA9IGV4cG9ydHMucGFyc2VFcnJvckJhcnNPZkF4aXMgPSBleHBvcnRzLnBhcnNlRG9tYWluT2ZDYXRlZ29yeUF4aXMgPSBleHBvcnRzLm9mZnNldFNpZ24gPSBleHBvcnRzLm9mZnNldFBvc2l0aXZlID0gZXhwb3J0cy5pc0NhdGVnb3JpY2FsQXhpcyA9IHZvaWQgMDtcclxudmFyIGQzU2NhbGVzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInZpY3RvcnktdmVuZG9yL2QzLXNjYWxlXCIpKTtcclxudmFyIF9kM1NoYXBlID0gcmVxdWlyZShcInZpY3RvcnktdmVuZG9yL2QzLXNoYXBlXCIpO1xyXG52YXIgX21heCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9tYXhcIikpO1xyXG52YXIgX21pbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9taW5cIikpO1xyXG52YXIgX2lzTmlsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzTmlsXCIpKTtcclxudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xyXG52YXIgX2lzU3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzU3RyaW5nXCIpKTtcclxudmFyIF9nZXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZ2V0XCIpKTtcclxudmFyIF9mbGF0TWFwID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2ZsYXRNYXBcIikpO1xyXG52YXIgX2lzTmFOID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzTmFOXCIpKTtcclxudmFyIF91cHBlckZpcnN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL3VwcGVyRmlyc3RcIikpO1xyXG52YXIgX2lzRXF1YWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNFcXVhbFwiKSk7XHJcbnZhciBfc29ydEJ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL3NvcnRCeVwiKSk7XHJcbnZhciBfcmVjaGFydHNTY2FsZSA9IHJlcXVpcmUoXCJyZWNoYXJ0cy1zY2FsZVwiKTtcclxudmFyIF9FcnJvckJhciA9IHJlcXVpcmUoXCIuLi9jYXJ0ZXNpYW4vRXJyb3JCYXJcIik7XHJcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4vRGF0YVV0aWxzXCIpO1xyXG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi9SZWFjdFV0aWxzXCIpO1xyXG52YXIgX2dldExlZ2VuZFByb3BzID0gcmVxdWlyZShcIi4vZ2V0TGVnZW5kUHJvcHNcIik7XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxyXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XHJcbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxyXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cclxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxyXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxyXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XHJcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8vIFRPRE86IENhdXNlIG9mIGNpcmN1bGFyIGRlcGVuZGVuY3kuIE5lZWRzIHJlZmFjdG9yLlxyXG4vLyBpbXBvcnQgeyBSYWRpdXNBeGlzUHJvcHMsIEFuZ2xlQXhpc1Byb3BzIH0gZnJvbSAnLi4vcG9sYXIvdHlwZXMnO1xyXG4vLyBFeHBvcnRlZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuZnVuY3Rpb24gZ2V0VmFsdWVCeURhdGFLZXkob2JqLCBkYXRhS2V5LCBkZWZhdWx0VmFsdWUpIHtcclxuICBpZiAoKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKG9iaikgfHwgKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGRhdGFLZXkpKSB7XHJcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xyXG4gIH1cclxuICBpZiAoKDAsIF9EYXRhVXRpbHMuaXNOdW1PclN0cikoZGF0YUtleSkpIHtcclxuICAgIHJldHVybiAoMCwgX2dldFtcImRlZmF1bHRcIl0pKG9iaiwgZGF0YUtleSwgZGVmYXVsdFZhbHVlKTtcclxuICB9XHJcbiAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKGRhdGFLZXkpKSB7XHJcbiAgICByZXR1cm4gZGF0YUtleShvYmopO1xyXG4gIH1cclxuICByZXR1cm4gZGVmYXVsdFZhbHVlO1xyXG59XHJcbi8qKlxyXG4gKiBHZXQgZG9tYWluIG9mIGRhdGEgYnkga2V5LlxyXG4gKiBAcGFyYW0gIHtBcnJheX0gICBkYXRhICAgICAgVGhlIGRhdGEgZGlzcGxheWVkIGluIHRoZSBjaGFydFxyXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBrZXkgICAgICAgVGhlIHVuaXF1ZSBrZXkgb2YgYSBncm91cCBvZiBkYXRhXHJcbiAqIEBwYXJhbSAge1N0cmluZ30gIHR5cGUgICAgICBUaGUgdHlwZSBvZiBheGlzXHJcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGZpbHRlck5pbCBXaGV0aGVyIG9yIG5vdCBmaWx0ZXIgbmlsIHZhbHVlc1xyXG4gKiBAcmV0dXJuIHtBcnJheX0gRG9tYWluIG9mIGRhdGFcclxuICovXHJcbmZ1bmN0aW9uIGdldERvbWFpbk9mRGF0YUJ5S2V5KGRhdGEsIGtleSwgdHlwZSwgZmlsdGVyTmlsKSB7XHJcbiAgdmFyIGZsYXR0ZW5EYXRhID0gKDAsIF9mbGF0TWFwW1wiZGVmYXVsdFwiXSkoZGF0YSwgZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICByZXR1cm4gZ2V0VmFsdWVCeURhdGFLZXkoZW50cnksIGtleSk7XHJcbiAgfSk7XHJcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHBhcnNlRmxvYXQgdHlwZSBvbmx5IGFjY2VwdHMgc3RyaW5nc1xyXG4gICAgdmFyIGRvbWFpbiA9IGZsYXR0ZW5EYXRhLmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgcmV0dXJuICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShlbnRyeSkgfHwgcGFyc2VGbG9hdChlbnRyeSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBkb21haW4ubGVuZ3RoID8gWygwLCBfbWluW1wiZGVmYXVsdFwiXSkoZG9tYWluKSwgKDAsIF9tYXhbXCJkZWZhdWx0XCJdKShkb21haW4pXSA6IFtJbmZpbml0eSwgLUluZmluaXR5XTtcclxuICB9XHJcbiAgdmFyIHZhbGlkYXRlRGF0YSA9IGZpbHRlck5pbCA/IGZsYXR0ZW5EYXRhLmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgIHJldHVybiAhKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGVudHJ5KTtcclxuICB9KSA6IGZsYXR0ZW5EYXRhO1xyXG5cclxuICAvLyBTdXBwb3J0cyB4LWF4aXMgb2YgRGF0ZSB0eXBlXHJcbiAgcmV0dXJuIHZhbGlkYXRlRGF0YS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICByZXR1cm4gKDAsIF9EYXRhVXRpbHMuaXNOdW1PclN0cikoZW50cnkpIHx8IGVudHJ5IGluc3RhbmNlb2YgRGF0ZSA/IGVudHJ5IDogJyc7XHJcbiAgfSk7XHJcbn1cclxudmFyIGNhbGN1bGF0ZUFjdGl2ZVRpY2tJbmRleCA9IGV4cG9ydHMuY2FsY3VsYXRlQWN0aXZlVGlja0luZGV4ID0gZnVuY3Rpb24gY2FsY3VsYXRlQWN0aXZlVGlja0luZGV4KGNvb3JkaW5hdGUpIHtcclxuICB2YXIgX3RpY2tzJGxlbmd0aDtcclxuICB2YXIgdGlja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xyXG4gIHZhciB1bnNvcnRlZFRpY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XHJcbiAgdmFyIGF4aXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcclxuICB2YXIgaW5kZXggPSAtMTtcclxuICB2YXIgbGVuID0gKF90aWNrcyRsZW5ndGggPSB0aWNrcyA9PT0gbnVsbCB8fCB0aWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGlja3MubGVuZ3RoKSAhPT0gbnVsbCAmJiBfdGlja3MkbGVuZ3RoICE9PSB2b2lkIDAgPyBfdGlja3MkbGVuZ3RoIDogMDtcclxuXHJcbiAgLy8gaWYgdGhlcmUgYXJlIDEgb3IgbGVzcyB0aWNrcyB0aWNrcyB0aGVuIHRoZSBhY3RpdmUgdGljayBpcyBhdCBpbmRleCAwXHJcbiAgaWYgKGxlbiA8PSAxKSB7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbiAgaWYgKGF4aXMgJiYgYXhpcy5heGlzVHlwZSA9PT0gJ2FuZ2xlQXhpcycgJiYgTWF0aC5hYnMoTWF0aC5hYnMoYXhpcy5yYW5nZVsxXSAtIGF4aXMucmFuZ2VbMF0pIC0gMzYwKSA8PSAxZS02KSB7XHJcbiAgICB2YXIgcmFuZ2UgPSBheGlzLnJhbmdlO1xyXG4gICAgLy8gdGlja3MgYXJlIGRpc3RyaWJ1dGVkIGluIGEgY2lyY2xlXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIHZhciBiZWZvcmUgPSBpID4gMCA/IHVuc29ydGVkVGlja3NbaSAtIDFdLmNvb3JkaW5hdGUgOiB1bnNvcnRlZFRpY2tzW2xlbiAtIDFdLmNvb3JkaW5hdGU7XHJcbiAgICAgIHZhciBjdXIgPSB1bnNvcnRlZFRpY2tzW2ldLmNvb3JkaW5hdGU7XHJcbiAgICAgIHZhciBhZnRlciA9IGkgPj0gbGVuIC0gMSA/IHVuc29ydGVkVGlja3NbMF0uY29vcmRpbmF0ZSA6IHVuc29ydGVkVGlja3NbaSArIDFdLmNvb3JkaW5hdGU7XHJcbiAgICAgIHZhciBzYW1lRGlyZWN0aW9uQ29vcmQgPSB2b2lkIDA7XHJcbiAgICAgIGlmICgoMCwgX0RhdGFVdGlscy5tYXRoU2lnbikoY3VyIC0gYmVmb3JlKSAhPT0gKDAsIF9EYXRhVXRpbHMubWF0aFNpZ24pKGFmdGVyIC0gY3VyKSkge1xyXG4gICAgICAgIHZhciBkaWZmSW50ZXJ2YWwgPSBbXTtcclxuICAgICAgICBpZiAoKDAsIF9EYXRhVXRpbHMubWF0aFNpZ24pKGFmdGVyIC0gY3VyKSA9PT0gKDAsIF9EYXRhVXRpbHMubWF0aFNpZ24pKHJhbmdlWzFdIC0gcmFuZ2VbMF0pKSB7XHJcbiAgICAgICAgICBzYW1lRGlyZWN0aW9uQ29vcmQgPSBhZnRlcjtcclxuICAgICAgICAgIHZhciBjdXJJblJhbmdlID0gY3VyICsgcmFuZ2VbMV0gLSByYW5nZVswXTtcclxuICAgICAgICAgIGRpZmZJbnRlcnZhbFswXSA9IE1hdGgubWluKGN1ckluUmFuZ2UsIChjdXJJblJhbmdlICsgYmVmb3JlKSAvIDIpO1xyXG4gICAgICAgICAgZGlmZkludGVydmFsWzFdID0gTWF0aC5tYXgoY3VySW5SYW5nZSwgKGN1ckluUmFuZ2UgKyBiZWZvcmUpIC8gMik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNhbWVEaXJlY3Rpb25Db29yZCA9IGJlZm9yZTtcclxuICAgICAgICAgIHZhciBhZnRlckluUmFuZ2UgPSBhZnRlciArIHJhbmdlWzFdIC0gcmFuZ2VbMF07XHJcbiAgICAgICAgICBkaWZmSW50ZXJ2YWxbMF0gPSBNYXRoLm1pbihjdXIsIChhZnRlckluUmFuZ2UgKyBjdXIpIC8gMik7XHJcbiAgICAgICAgICBkaWZmSW50ZXJ2YWxbMV0gPSBNYXRoLm1heChjdXIsIChhZnRlckluUmFuZ2UgKyBjdXIpIC8gMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzYW1lSW50ZXJ2YWwgPSBbTWF0aC5taW4oY3VyLCAoc2FtZURpcmVjdGlvbkNvb3JkICsgY3VyKSAvIDIpLCBNYXRoLm1heChjdXIsIChzYW1lRGlyZWN0aW9uQ29vcmQgKyBjdXIpIC8gMildO1xyXG4gICAgICAgIGlmIChjb29yZGluYXRlID4gc2FtZUludGVydmFsWzBdICYmIGNvb3JkaW5hdGUgPD0gc2FtZUludGVydmFsWzFdIHx8IGNvb3JkaW5hdGUgPj0gZGlmZkludGVydmFsWzBdICYmIGNvb3JkaW5hdGUgPD0gZGlmZkludGVydmFsWzFdKSB7XHJcbiAgICAgICAgICBpbmRleCA9IHVuc29ydGVkVGlja3NbaV0uaW5kZXg7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIG1pblZhbHVlID0gTWF0aC5taW4oYmVmb3JlLCBhZnRlcik7XHJcbiAgICAgICAgdmFyIG1heFZhbHVlID0gTWF0aC5tYXgoYmVmb3JlLCBhZnRlcik7XHJcbiAgICAgICAgaWYgKGNvb3JkaW5hdGUgPiAobWluVmFsdWUgKyBjdXIpIC8gMiAmJiBjb29yZGluYXRlIDw9IChtYXhWYWx1ZSArIGN1cikgLyAyKSB7XHJcbiAgICAgICAgICBpbmRleCA9IHVuc29ydGVkVGlja3NbaV0uaW5kZXg7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgLy8gdGlja3MgYXJlIGRpc3RyaWJ1dGVkIGluIGEgc2luZ2xlIGRpcmVjdGlvblxyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxlbjsgX2krKykge1xyXG4gICAgICBpZiAoX2kgPT09IDAgJiYgY29vcmRpbmF0ZSA8PSAodGlja3NbX2ldLmNvb3JkaW5hdGUgKyB0aWNrc1tfaSArIDFdLmNvb3JkaW5hdGUpIC8gMiB8fCBfaSA+IDAgJiYgX2kgPCBsZW4gLSAxICYmIGNvb3JkaW5hdGUgPiAodGlja3NbX2ldLmNvb3JkaW5hdGUgKyB0aWNrc1tfaSAtIDFdLmNvb3JkaW5hdGUpIC8gMiAmJiBjb29yZGluYXRlIDw9ICh0aWNrc1tfaV0uY29vcmRpbmF0ZSArIHRpY2tzW19pICsgMV0uY29vcmRpbmF0ZSkgLyAyIHx8IF9pID09PSBsZW4gLSAxICYmIGNvb3JkaW5hdGUgPiAodGlja3NbX2ldLmNvb3JkaW5hdGUgKyB0aWNrc1tfaSAtIDFdLmNvb3JkaW5hdGUpIC8gMikge1xyXG4gICAgICAgIGluZGV4ID0gdGlja3NbX2ldLmluZGV4O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBpbmRleDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIG1haW4gY29sb3Igb2YgZWFjaCBncmFwaGljIGl0ZW1cclxuICogQHBhcmFtICB7UmVhY3RFbGVtZW50fSBpdGVtIEEgZ3JhcGhpYyBpdGVtXHJcbiAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICBDb2xvclxyXG4gKi9cclxudmFyIGdldE1haW5Db2xvck9mR3JhcGhpY0l0ZW0gPSBleHBvcnRzLmdldE1haW5Db2xvck9mR3JhcGhpY0l0ZW0gPSBmdW5jdGlvbiBnZXRNYWluQ29sb3JPZkdyYXBoaWNJdGVtKGl0ZW0pIHtcclxuICB2YXIgX2l0ZW0kdHlwZTtcclxuICB2YXIgX3JlZiA9IGl0ZW0sXHJcbiAgICBkaXNwbGF5TmFtZSA9IF9yZWYudHlwZS5kaXNwbGF5TmFtZTsgLy8gVE9ETzogY2hlY2sgaWYgZGlzcGxheU5hbWUgaXMgdmFsaWQuXHJcbiAgdmFyIGRlZmF1bHRlZFByb3BzID0gKF9pdGVtJHR5cGUgPSBpdGVtLnR5cGUpICE9PSBudWxsICYmIF9pdGVtJHR5cGUgIT09IHZvaWQgMCAmJiBfaXRlbSR0eXBlLmRlZmF1bHRQcm9wcyA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaXRlbS50eXBlLmRlZmF1bHRQcm9wcyksIGl0ZW0ucHJvcHMpIDogaXRlbS5wcm9wcztcclxuICB2YXIgc3Ryb2tlID0gZGVmYXVsdGVkUHJvcHMuc3Ryb2tlLFxyXG4gICAgZmlsbCA9IGRlZmF1bHRlZFByb3BzLmZpbGw7XHJcbiAgdmFyIHJlc3VsdDtcclxuICBzd2l0Y2ggKGRpc3BsYXlOYW1lKSB7XHJcbiAgICBjYXNlICdMaW5lJzpcclxuICAgICAgcmVzdWx0ID0gc3Ryb2tlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ0FyZWEnOlxyXG4gICAgY2FzZSAnUmFkYXInOlxyXG4gICAgICByZXN1bHQgPSBzdHJva2UgJiYgc3Ryb2tlICE9PSAnbm9uZScgPyBzdHJva2UgOiBmaWxsO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJlc3VsdCA9IGZpbGw7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBzaXplIG9mIGFsbCBncm91cHMgZm9yIHN0YWNrZWQgYmFyIGdyYXBoXHJcbiAqIEBwYXJhbSAge09iamVjdH0gc3RhY2tHcm91cHMgVGhlIGl0ZW1zIGdyb3VwZWQgYnkgYXhpc0lkIGFuZCBzdGFja0lkXHJcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHNpemUgb2YgYWxsIGdyb3Vwc1xyXG4gKi9cclxudmFyIGdldEJhclNpemVMaXN0ID0gZXhwb3J0cy5nZXRCYXJTaXplTGlzdCA9IGZ1bmN0aW9uIGdldEJhclNpemVMaXN0KF9yZWYyKSB7XHJcbiAgdmFyIGdsb2JhbFNpemUgPSBfcmVmMi5iYXJTaXplLFxyXG4gICAgdG90YWxTaXplID0gX3JlZjIudG90YWxTaXplLFxyXG4gICAgX3JlZjIkc3RhY2tHcm91cHMgPSBfcmVmMi5zdGFja0dyb3VwcyxcclxuICAgIHN0YWNrR3JvdXBzID0gX3JlZjIkc3RhY2tHcm91cHMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjIkc3RhY2tHcm91cHM7XHJcbiAgaWYgKCFzdGFja0dyb3Vwcykge1xyXG4gICAgcmV0dXJuIHt9O1xyXG4gIH1cclxuICB2YXIgcmVzdWx0ID0ge307XHJcbiAgdmFyIG51bWVyaWNBeGlzSWRzID0gT2JqZWN0LmtleXMoc3RhY2tHcm91cHMpO1xyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBudW1lcmljQXhpc0lkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgdmFyIHNncyA9IHN0YWNrR3JvdXBzW251bWVyaWNBeGlzSWRzW2ldXS5zdGFja0dyb3VwcztcclxuICAgIHZhciBzdGFja0lkcyA9IE9iamVjdC5rZXlzKHNncyk7XHJcbiAgICBmb3IgKHZhciBqID0gMCwgc0xlbiA9IHN0YWNrSWRzLmxlbmd0aDsgaiA8IHNMZW47IGorKykge1xyXG4gICAgICB2YXIgX3NncyRzdGFja0lkcyRqID0gc2dzW3N0YWNrSWRzW2pdXSxcclxuICAgICAgICBpdGVtcyA9IF9zZ3Mkc3RhY2tJZHMkai5pdGVtcyxcclxuICAgICAgICBjYXRlQXhpc0lkID0gX3NncyRzdGFja0lkcyRqLmNhdGVBeGlzSWQ7XHJcbiAgICAgIHZhciBiYXJJdGVtcyA9IGl0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHJldHVybiAoMCwgX1JlYWN0VXRpbHMuZ2V0RGlzcGxheU5hbWUpKGl0ZW0udHlwZSkuaW5kZXhPZignQmFyJykgPj0gMDtcclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChiYXJJdGVtcyAmJiBiYXJJdGVtcy5sZW5ndGgpIHtcclxuICAgICAgICB2YXIgYmFySXRlbURlZmF1bHRQcm9wcyA9IGJhckl0ZW1zWzBdLnR5cGUuZGVmYXVsdFByb3BzO1xyXG4gICAgICAgIHZhciBiYXJJdGVtUHJvcHMgPSBiYXJJdGVtRGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGJhckl0ZW1EZWZhdWx0UHJvcHMpLCBiYXJJdGVtc1swXS5wcm9wcykgOiBiYXJJdGVtc1swXS5wcm9wcztcclxuICAgICAgICB2YXIgc2VsZlNpemUgPSBiYXJJdGVtUHJvcHMuYmFyU2l6ZTtcclxuICAgICAgICB2YXIgY2F0ZUlkID0gYmFySXRlbVByb3BzW2NhdGVBeGlzSWRdO1xyXG4gICAgICAgIGlmICghcmVzdWx0W2NhdGVJZF0pIHtcclxuICAgICAgICAgIHJlc3VsdFtjYXRlSWRdID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiYXJTaXplID0gKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKHNlbGZTaXplKSA/IGdsb2JhbFNpemUgOiBzZWxmU2l6ZTtcclxuICAgICAgICByZXN1bHRbY2F0ZUlkXS5wdXNoKHtcclxuICAgICAgICAgIGl0ZW06IGJhckl0ZW1zWzBdLFxyXG4gICAgICAgICAgc3RhY2tMaXN0OiBiYXJJdGVtcy5zbGljZSgxKSxcclxuICAgICAgICAgIGJhclNpemU6ICgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShiYXJTaXplKSA/IHVuZGVmaW5lZCA6ICgwLCBfRGF0YVV0aWxzLmdldFBlcmNlbnRWYWx1ZSkoYmFyU2l6ZSwgdG90YWxTaXplLCAwKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgdGhlIHNpemUgb2YgZWFjaCBiYXIgYW5kIG9mZnNldCBiZXR3ZWVuIHN0YXJ0IG9mIGJhbmQgYW5kIHRoZSBiYXJcclxuICpcclxuICogQHBhcmFtICB7bnVtYmVyfSBiYW5kU2l6ZSBpcyB0aGUgc2l6ZSBvZiBhcmVhIHdoZXJlIGJhcnMgY2FuIHJlbmRlclxyXG4gKiBAcGFyYW0gIHtudW1iZXIgfCBzdHJpbmd9IGJhckdhcCBpcyB0aGUgZ2FwIHNpemUsIGFzIGEgcGVyY2VudGFnZSBvZiBgYmFuZFNpemVgLlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgZGVmaW5lZCBhcyBudW1iZXIgb3IgcGVyY2VudCBzdHJpbmdcclxuICogQHBhcmFtICB7bnVtYmVyIHwgc3RyaW5nfSBiYXJDYXRlZ29yeUdhcCBpcyB0aGUgZ2FwIHNpemUsIGFzIGEgcGVyY2VudGFnZSBvZiBgYmFuZFNpemVgLlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgZGVmaW5lZCBhcyBudW1iZXIgb3IgcGVyY2VudCBzdHJpbmdcclxuICogQHBhcmFtICB7QXJyYXk8b2JqZWN0Pn0gc2l6ZUxpc3QgU2l6ZXMgb2YgYWxsIGdyb3Vwc1xyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IG1heEJhclNpemUgVGhlIG1heGltdW0gc2l6ZSBvZiBlYWNoIGJhclxyXG4gKiBAcmV0dXJuIHtBcnJheTxvYmplY3Q+fSBUaGUgc2l6ZSBhbmQgb2Zmc2V0IG9mIGVhY2ggYmFyXHJcbiAqL1xyXG52YXIgZ2V0QmFyUG9zaXRpb24gPSBleHBvcnRzLmdldEJhclBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0QmFyUG9zaXRpb24oX3JlZjMpIHtcclxuICB2YXIgYmFyR2FwID0gX3JlZjMuYmFyR2FwLFxyXG4gICAgYmFyQ2F0ZWdvcnlHYXAgPSBfcmVmMy5iYXJDYXRlZ29yeUdhcCxcclxuICAgIGJhbmRTaXplID0gX3JlZjMuYmFuZFNpemUsXHJcbiAgICBfcmVmMyRzaXplTGlzdCA9IF9yZWYzLnNpemVMaXN0LFxyXG4gICAgc2l6ZUxpc3QgPSBfcmVmMyRzaXplTGlzdCA9PT0gdm9pZCAwID8gW10gOiBfcmVmMyRzaXplTGlzdCxcclxuICAgIG1heEJhclNpemUgPSBfcmVmMy5tYXhCYXJTaXplO1xyXG4gIHZhciBsZW4gPSBzaXplTGlzdC5sZW5ndGg7XHJcbiAgaWYgKGxlbiA8IDEpIHJldHVybiBudWxsO1xyXG4gIHZhciByZWFsQmFyR2FwID0gKDAsIF9EYXRhVXRpbHMuZ2V0UGVyY2VudFZhbHVlKShiYXJHYXAsIGJhbmRTaXplLCAwLCB0cnVlKTtcclxuICB2YXIgcmVzdWx0O1xyXG4gIHZhciBpbml0aWFsVmFsdWUgPSBbXTtcclxuXHJcbiAgLy8gd2hldGhlciBvciBub3QgaXMgYmFyU2l6ZSBzZXR0ZWQgYnkgdXNlclxyXG4gIGlmIChzaXplTGlzdFswXS5iYXJTaXplID09PSArc2l6ZUxpc3RbMF0uYmFyU2l6ZSkge1xyXG4gICAgdmFyIHVzZUZ1bGwgPSBmYWxzZTtcclxuICAgIHZhciBmdWxsQmFyU2l6ZSA9IGJhbmRTaXplIC8gbGVuO1xyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGUgdHlwZSBjaGVjayBhYm92ZSBkb2VzIG5vdCBjaGVjayBmb3IgdHlwZSBudW1iZXIgZXhwbGljaXRseVxyXG4gICAgdmFyIHN1bSA9IHNpemVMaXN0LnJlZHVjZShmdW5jdGlvbiAocmVzLCBlbnRyeSkge1xyXG4gICAgICByZXR1cm4gcmVzICsgZW50cnkuYmFyU2l6ZSB8fCAwO1xyXG4gICAgfSwgMCk7XHJcbiAgICBzdW0gKz0gKGxlbiAtIDEpICogcmVhbEJhckdhcDtcclxuICAgIGlmIChzdW0gPj0gYmFuZFNpemUpIHtcclxuICAgICAgc3VtIC09IChsZW4gLSAxKSAqIHJlYWxCYXJHYXA7XHJcbiAgICAgIHJlYWxCYXJHYXAgPSAwO1xyXG4gICAgfVxyXG4gICAgaWYgKHN1bSA+PSBiYW5kU2l6ZSAmJiBmdWxsQmFyU2l6ZSA+IDApIHtcclxuICAgICAgdXNlRnVsbCA9IHRydWU7XHJcbiAgICAgIGZ1bGxCYXJTaXplICo9IDAuOTtcclxuICAgICAgc3VtID0gbGVuICogZnVsbEJhclNpemU7XHJcbiAgICB9XHJcbiAgICB2YXIgb2Zmc2V0ID0gKGJhbmRTaXplIC0gc3VtKSAvIDIgPj4gMDtcclxuICAgIHZhciBwcmV2ID0ge1xyXG4gICAgICBvZmZzZXQ6IG9mZnNldCAtIHJlYWxCYXJHYXAsXHJcbiAgICAgIHNpemU6IDBcclxuICAgIH07XHJcbiAgICByZXN1bHQgPSBzaXplTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKHJlcywgZW50cnkpIHtcclxuICAgICAgdmFyIG5ld1Bvc2l0aW9uID0ge1xyXG4gICAgICAgIGl0ZW06IGVudHJ5Lml0ZW0sXHJcbiAgICAgICAgcG9zaXRpb246IHtcclxuICAgICAgICAgIG9mZnNldDogcHJldi5vZmZzZXQgKyBwcmV2LnNpemUgKyByZWFsQmFyR2FwLFxyXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGUgdHlwZSBjaGVjayBhYm92ZSBkb2VzIG5vdCBjaGVjayBmb3IgdHlwZSBudW1iZXIgZXhwbGljaXRseVxyXG4gICAgICAgICAgc2l6ZTogdXNlRnVsbCA/IGZ1bGxCYXJTaXplIDogZW50cnkuYmFyU2l6ZVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgdmFyIG5ld1JlcyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocmVzKSwgW25ld1Bvc2l0aW9uXSk7XHJcbiAgICAgIHByZXYgPSBuZXdSZXNbbmV3UmVzLmxlbmd0aCAtIDFdLnBvc2l0aW9uO1xyXG4gICAgICBpZiAoZW50cnkuc3RhY2tMaXN0ICYmIGVudHJ5LnN0YWNrTGlzdC5sZW5ndGgpIHtcclxuICAgICAgICBlbnRyeS5zdGFja0xpc3QuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgbmV3UmVzLnB1c2goe1xyXG4gICAgICAgICAgICBpdGVtOiBpdGVtLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogcHJldlxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ld1JlcztcclxuICAgIH0sIGluaXRpYWxWYWx1ZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBfb2Zmc2V0ID0gKDAsIF9EYXRhVXRpbHMuZ2V0UGVyY2VudFZhbHVlKShiYXJDYXRlZ29yeUdhcCwgYmFuZFNpemUsIDAsIHRydWUpO1xyXG4gICAgaWYgKGJhbmRTaXplIC0gMiAqIF9vZmZzZXQgLSAobGVuIC0gMSkgKiByZWFsQmFyR2FwIDw9IDApIHtcclxuICAgICAgcmVhbEJhckdhcCA9IDA7XHJcbiAgICB9XHJcbiAgICB2YXIgb3JpZ2luYWxTaXplID0gKGJhbmRTaXplIC0gMiAqIF9vZmZzZXQgLSAobGVuIC0gMSkgKiByZWFsQmFyR2FwKSAvIGxlbjtcclxuICAgIGlmIChvcmlnaW5hbFNpemUgPiAxKSB7XHJcbiAgICAgIG9yaWdpbmFsU2l6ZSA+Pj0gMDtcclxuICAgIH1cclxuICAgIHZhciBzaXplID0gbWF4QmFyU2l6ZSA9PT0gK21heEJhclNpemUgPyBNYXRoLm1pbihvcmlnaW5hbFNpemUsIG1heEJhclNpemUpIDogb3JpZ2luYWxTaXplO1xyXG4gICAgcmVzdWx0ID0gc2l6ZUxpc3QucmVkdWNlKGZ1bmN0aW9uIChyZXMsIGVudHJ5LCBpKSB7XHJcbiAgICAgIHZhciBuZXdSZXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHJlcyksIFt7XHJcbiAgICAgICAgaXRlbTogZW50cnkuaXRlbSxcclxuICAgICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0ICsgKG9yaWdpbmFsU2l6ZSArIHJlYWxCYXJHYXApICogaSArIChvcmlnaW5hbFNpemUgLSBzaXplKSAvIDIsXHJcbiAgICAgICAgICBzaXplOiBzaXplXHJcbiAgICAgICAgfVxyXG4gICAgICB9XSk7XHJcbiAgICAgIGlmIChlbnRyeS5zdGFja0xpc3QgJiYgZW50cnkuc3RhY2tMaXN0Lmxlbmd0aCkge1xyXG4gICAgICAgIGVudHJ5LnN0YWNrTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICBuZXdSZXMucHVzaCh7XHJcbiAgICAgICAgICAgIGl0ZW06IGl0ZW0sXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXdSZXNbbmV3UmVzLmxlbmd0aCAtIDFdLnBvc2l0aW9uXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3UmVzO1xyXG4gICAgfSwgaW5pdGlhbFZhbHVlKTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxudmFyIGFwcGVuZE9mZnNldE9mTGVnZW5kID0gZXhwb3J0cy5hcHBlbmRPZmZzZXRPZkxlZ2VuZCA9IGZ1bmN0aW9uIGFwcGVuZE9mZnNldE9mTGVnZW5kKG9mZnNldCwgX3VudXNlZCwgcHJvcHMsIGxlZ2VuZEJveCkge1xyXG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxyXG4gICAgd2lkdGggPSBwcm9wcy53aWR0aCxcclxuICAgIG1hcmdpbiA9IHByb3BzLm1hcmdpbjtcclxuICB2YXIgbGVnZW5kV2lkdGggPSB3aWR0aCAtIChtYXJnaW4ubGVmdCB8fCAwKSAtIChtYXJnaW4ucmlnaHQgfHwgMCk7XHJcbiAgdmFyIGxlZ2VuZFByb3BzID0gKDAsIF9nZXRMZWdlbmRQcm9wcy5nZXRMZWdlbmRQcm9wcykoe1xyXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxyXG4gICAgbGVnZW5kV2lkdGg6IGxlZ2VuZFdpZHRoXHJcbiAgfSk7XHJcbiAgaWYgKGxlZ2VuZFByb3BzKSB7XHJcbiAgICB2YXIgX3JlZjQgPSBsZWdlbmRCb3ggfHwge30sXHJcbiAgICAgIGJveFdpZHRoID0gX3JlZjQud2lkdGgsXHJcbiAgICAgIGJveEhlaWdodCA9IF9yZWY0LmhlaWdodDtcclxuICAgIHZhciBhbGlnbiA9IGxlZ2VuZFByb3BzLmFsaWduLFxyXG4gICAgICB2ZXJ0aWNhbEFsaWduID0gbGVnZW5kUHJvcHMudmVydGljYWxBbGlnbixcclxuICAgICAgbGF5b3V0ID0gbGVnZW5kUHJvcHMubGF5b3V0O1xyXG4gICAgaWYgKChsYXlvdXQgPT09ICd2ZXJ0aWNhbCcgfHwgbGF5b3V0ID09PSAnaG9yaXpvbnRhbCcgJiYgdmVydGljYWxBbGlnbiA9PT0gJ21pZGRsZScpICYmIGFsaWduICE9PSAnY2VudGVyJyAmJiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikob2Zmc2V0W2FsaWduXSkpIHtcclxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb2Zmc2V0KSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwgYWxpZ24sIG9mZnNldFthbGlnbl0gKyAoYm94V2lkdGggfHwgMCkpKTtcclxuICAgIH1cclxuICAgIGlmICgobGF5b3V0ID09PSAnaG9yaXpvbnRhbCcgfHwgbGF5b3V0ID09PSAndmVydGljYWwnICYmIGFsaWduID09PSAnY2VudGVyJykgJiYgdmVydGljYWxBbGlnbiAhPT0gJ21pZGRsZScgJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKG9mZnNldFt2ZXJ0aWNhbEFsaWduXSkpIHtcclxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb2Zmc2V0KSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwgdmVydGljYWxBbGlnbiwgb2Zmc2V0W3ZlcnRpY2FsQWxpZ25dICsgKGJveEhlaWdodCB8fCAwKSkpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gb2Zmc2V0O1xyXG59O1xyXG52YXIgaXNFcnJvckJhclJlbGV2YW50Rm9yQXhpcyA9IGZ1bmN0aW9uIGlzRXJyb3JCYXJSZWxldmFudEZvckF4aXMobGF5b3V0LCBheGlzVHlwZSwgZGlyZWN0aW9uKSB7XHJcbiAgaWYgKCgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShheGlzVHlwZSkpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBpZiAobGF5b3V0ID09PSAnaG9yaXpvbnRhbCcpIHtcclxuICAgIHJldHVybiBheGlzVHlwZSA9PT0gJ3lBeGlzJztcclxuICB9XHJcbiAgaWYgKGxheW91dCA9PT0gJ3ZlcnRpY2FsJykge1xyXG4gICAgcmV0dXJuIGF4aXNUeXBlID09PSAneEF4aXMnO1xyXG4gIH1cclxuICBpZiAoZGlyZWN0aW9uID09PSAneCcpIHtcclxuICAgIHJldHVybiBheGlzVHlwZSA9PT0gJ3hBeGlzJztcclxuICB9XHJcbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ3knKSB7XHJcbiAgICByZXR1cm4gYXhpc1R5cGUgPT09ICd5QXhpcyc7XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG52YXIgZ2V0RG9tYWluT2ZFcnJvckJhcnMgPSBleHBvcnRzLmdldERvbWFpbk9mRXJyb3JCYXJzID0gZnVuY3Rpb24gZ2V0RG9tYWluT2ZFcnJvckJhcnMoZGF0YSwgaXRlbSwgZGF0YUtleSwgbGF5b3V0LCBheGlzVHlwZSkge1xyXG4gIHZhciBjaGlsZHJlbiA9IGl0ZW0ucHJvcHMuY2hpbGRyZW47XHJcbiAgdmFyIGVycm9yQmFycyA9ICgwLCBfUmVhY3RVdGlscy5maW5kQWxsQnlUeXBlKShjaGlsZHJlbiwgX0Vycm9yQmFyLkVycm9yQmFyKS5maWx0ZXIoZnVuY3Rpb24gKGVycm9yQmFyQ2hpbGQpIHtcclxuICAgIHJldHVybiBpc0Vycm9yQmFyUmVsZXZhbnRGb3JBeGlzKGxheW91dCwgYXhpc1R5cGUsIGVycm9yQmFyQ2hpbGQucHJvcHMuZGlyZWN0aW9uKTtcclxuICB9KTtcclxuICBpZiAoZXJyb3JCYXJzICYmIGVycm9yQmFycy5sZW5ndGgpIHtcclxuICAgIHZhciBrZXlzID0gZXJyb3JCYXJzLm1hcChmdW5jdGlvbiAoZXJyb3JCYXJDaGlsZCkge1xyXG4gICAgICByZXR1cm4gZXJyb3JCYXJDaGlsZC5wcm9wcy5kYXRhS2V5O1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZGF0YS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgZW50cnkpIHtcclxuICAgICAgdmFyIGVudHJ5VmFsdWUgPSBnZXRWYWx1ZUJ5RGF0YUtleShlbnRyeSwgZGF0YUtleSk7XHJcbiAgICAgIGlmICgoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoZW50cnlWYWx1ZSkpIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIHZhciBtYWluVmFsdWUgPSBBcnJheS5pc0FycmF5KGVudHJ5VmFsdWUpID8gWygwLCBfbWluW1wiZGVmYXVsdFwiXSkoZW50cnlWYWx1ZSksICgwLCBfbWF4W1wiZGVmYXVsdFwiXSkoZW50cnlWYWx1ZSldIDogW2VudHJ5VmFsdWUsIGVudHJ5VmFsdWVdO1xyXG4gICAgICB2YXIgZXJyb3JEb21haW4gPSBrZXlzLnJlZHVjZShmdW5jdGlvbiAocHJldkVycm9yQXJyLCBrKSB7XHJcbiAgICAgICAgdmFyIGVycm9yVmFsdWUgPSBnZXRWYWx1ZUJ5RGF0YUtleShlbnRyeSwgaywgMCk7XHJcbiAgICAgICAgdmFyIGxvd2VyVmFsdWUgPSBtYWluVmFsdWVbMF0gLSBNYXRoLmFicyhBcnJheS5pc0FycmF5KGVycm9yVmFsdWUpID8gZXJyb3JWYWx1ZVswXSA6IGVycm9yVmFsdWUpO1xyXG4gICAgICAgIHZhciB1cHBlclZhbHVlID0gbWFpblZhbHVlWzFdICsgTWF0aC5hYnMoQXJyYXkuaXNBcnJheShlcnJvclZhbHVlKSA/IGVycm9yVmFsdWVbMV0gOiBlcnJvclZhbHVlKTtcclxuICAgICAgICByZXR1cm4gW01hdGgubWluKGxvd2VyVmFsdWUsIHByZXZFcnJvckFyclswXSksIE1hdGgubWF4KHVwcGVyVmFsdWUsIHByZXZFcnJvckFyclsxXSldO1xyXG4gICAgICB9LCBbSW5maW5pdHksIC1JbmZpbml0eV0pO1xyXG4gICAgICByZXR1cm4gW01hdGgubWluKGVycm9yRG9tYWluWzBdLCByZXN1bHRbMF0pLCBNYXRoLm1heChlcnJvckRvbWFpblsxXSwgcmVzdWx0WzFdKV07XHJcbiAgICB9LCBbSW5maW5pdHksIC1JbmZpbml0eV0pO1xyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufTtcclxudmFyIHBhcnNlRXJyb3JCYXJzT2ZBeGlzID0gZXhwb3J0cy5wYXJzZUVycm9yQmFyc09mQXhpcyA9IGZ1bmN0aW9uIHBhcnNlRXJyb3JCYXJzT2ZBeGlzKGRhdGEsIGl0ZW1zLCBkYXRhS2V5LCBheGlzVHlwZSwgbGF5b3V0KSB7XHJcbiAgdmFyIGRvbWFpbnMgPSBpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgIHJldHVybiBnZXREb21haW5PZkVycm9yQmFycyhkYXRhLCBpdGVtLCBkYXRhS2V5LCBsYXlvdXQsIGF4aXNUeXBlKTtcclxuICB9KS5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICByZXR1cm4gISgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShlbnRyeSk7XHJcbiAgfSk7XHJcbiAgaWYgKGRvbWFpbnMgJiYgZG9tYWlucy5sZW5ndGgpIHtcclxuICAgIHJldHVybiBkb21haW5zLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBlbnRyeSkge1xyXG4gICAgICByZXR1cm4gW01hdGgubWluKHJlc3VsdFswXSwgZW50cnlbMF0pLCBNYXRoLm1heChyZXN1bHRbMV0sIGVudHJ5WzFdKV07XHJcbiAgICB9LCBbSW5maW5pdHksIC1JbmZpbml0eV0pO1xyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgZG9tYWluIG9mIGRhdGEgYnkgdGhlIGNvbmZpZ3VyYXRpb24gb2YgaXRlbSBlbGVtZW50XHJcbiAqIEBwYXJhbSAge0FycmF5fSAgIGRhdGEgICAgICBUaGUgZGF0YSBkaXNwbGF5ZWQgaW4gdGhlIGNoYXJ0XHJcbiAqIEBwYXJhbSAge0FycmF5fSAgIGl0ZW1zICAgICBUaGUgaW5zdGFuY2VzIG9mIGl0ZW1cclxuICogQHBhcmFtICB7U3RyaW5nfSAgdHlwZSAgICAgIFRoZSB0eXBlIG9mIGF4aXMsIG51bWJlciAtIE51bWJlciBBeGlzLCBjYXRlZ29yeSAtIENhdGVnb3J5IEF4aXNcclxuICogQHBhcmFtICB7TGF5b3V0VHlwZX0gbGF5b3V0IFRoZSB0eXBlIG9mIGxheW91dFxyXG4gKiBAcGFyYW0gIHtCb29sZWFufSBmaWx0ZXJOaWwgV2hldGhlciBvciBub3QgZmlsdGVyIG5pbCB2YWx1ZXNcclxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICBEb21haW5cclxuICovXHJcbnZhciBnZXREb21haW5PZkl0ZW1zV2l0aFNhbWVBeGlzID0gZXhwb3J0cy5nZXREb21haW5PZkl0ZW1zV2l0aFNhbWVBeGlzID0gZnVuY3Rpb24gZ2V0RG9tYWluT2ZJdGVtc1dpdGhTYW1lQXhpcyhkYXRhLCBpdGVtcywgdHlwZSwgbGF5b3V0LCBmaWx0ZXJOaWwpIHtcclxuICB2YXIgZG9tYWlucyA9IGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgdmFyIGRhdGFLZXkgPSBpdGVtLnByb3BzLmRhdGFLZXk7XHJcbiAgICBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgZGF0YUtleSkge1xyXG4gICAgICByZXR1cm4gZ2V0RG9tYWluT2ZFcnJvckJhcnMoZGF0YSwgaXRlbSwgZGF0YUtleSwgbGF5b3V0KSB8fCBnZXREb21haW5PZkRhdGFCeUtleShkYXRhLCBkYXRhS2V5LCB0eXBlLCBmaWx0ZXJOaWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdldERvbWFpbk9mRGF0YUJ5S2V5KGRhdGEsIGRhdGFLZXksIHR5cGUsIGZpbHRlck5pbCk7XHJcbiAgfSk7XHJcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRvbWFpbiBvZiBudW1iZXIgYXhpc1xyXG4gICAgcmV0dXJuIGRvbWFpbnMucmVkdWNlKFxyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBpZiAodHlwZSA9PT0gbnVtYmVyKSBtZWFucyB0aGF0IHRoZSBkb21haW4gaXMgbnVtZXJpY2FsIHR5cGVcclxuICAgIC8vIC0gYnV0IHRoaXMgbGluayBpcyBtaXNzaW5nIGluIHRoZSB0eXBlIGRlZmluaXRpb25cclxuICAgIGZ1bmN0aW9uIChyZXN1bHQsIGVudHJ5KSB7XHJcbiAgICAgIHJldHVybiBbTWF0aC5taW4ocmVzdWx0WzBdLCBlbnRyeVswXSksIE1hdGgubWF4KHJlc3VsdFsxXSwgZW50cnlbMV0pXTtcclxuICAgIH0sIFtJbmZpbml0eSwgLUluZmluaXR5XSk7XHJcbiAgfVxyXG4gIHZhciB0YWcgPSB7fTtcclxuICAvLyBHZXQgdGhlIHVuaW9uIHNldCBvZiBjYXRlZ29yeSBheGlzXHJcbiAgcmV0dXJuIGRvbWFpbnMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGVudHJ5KSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZW50cnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBEYXRlIGNhbm5vdCBpbmRleCBhbiBvYmplY3RcclxuICAgICAgaWYgKCF0YWdbZW50cnlbaV1dKSB7XHJcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBEYXRlIGNhbm5vdCBpbmRleCBhbiBvYmplY3RcclxuICAgICAgICB0YWdbZW50cnlbaV1dID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBEYXRlIGNhbm5vdCBpbmRleCBhbiBvYmplY3RcclxuICAgICAgICByZXN1bHQucHVzaChlbnRyeVtpXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSwgW10pO1xyXG59O1xyXG52YXIgaXNDYXRlZ29yaWNhbEF4aXMgPSBleHBvcnRzLmlzQ2F0ZWdvcmljYWxBeGlzID0gZnVuY3Rpb24gaXNDYXRlZ29yaWNhbEF4aXMobGF5b3V0LCBheGlzVHlwZSkge1xyXG4gIHJldHVybiBsYXlvdXQgPT09ICdob3Jpem9udGFsJyAmJiBheGlzVHlwZSA9PT0gJ3hBeGlzJyB8fCBsYXlvdXQgPT09ICd2ZXJ0aWNhbCcgJiYgYXhpc1R5cGUgPT09ICd5QXhpcycgfHwgbGF5b3V0ID09PSAnY2VudHJpYycgJiYgYXhpc1R5cGUgPT09ICdhbmdsZUF4aXMnIHx8IGxheW91dCA9PT0gJ3JhZGlhbCcgJiYgYXhpc1R5cGUgPT09ICdyYWRpdXNBeGlzJztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgdGhlIENvb3JkaW5hdGVzIG9mIGdyaWRcclxuICogQHBhcmFtICB7QXJyYXl9IHRpY2tzICAgICAgICAgICBUaGUgdGlja3MgaW4gYXhpc1xyXG4gKiBAcGFyYW0ge051bWJlcn0gbWluVmFsdWUgICAgICAgIFRoZSBtaW5pbXVuIHZhbHVlIG9mIGF4aXNcclxuICogQHBhcmFtIHtOdW1iZXJ9IG1heFZhbHVlICAgICAgICBUaGUgbWF4aW11biB2YWx1ZSBvZiBheGlzXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3luY1dpdGhUaWNrcyAgU3luY2hyb25pemUgZ3JpZCBsaW5lcyB3aXRoIHRpY2tzIG9yIG5vdFxyXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgICAgIENvb3JkaW5hdGVzXHJcbiAqL1xyXG52YXIgZ2V0Q29vcmRpbmF0ZXNPZkdyaWQgPSBleHBvcnRzLmdldENvb3JkaW5hdGVzT2ZHcmlkID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXNPZkdyaWQodGlja3MsIG1pblZhbHVlLCBtYXhWYWx1ZSwgc3luY1dpdGhUaWNrcykge1xyXG4gIGlmIChzeW5jV2l0aFRpY2tzKSB7XHJcbiAgICByZXR1cm4gdGlja3MubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICByZXR1cm4gZW50cnkuY29vcmRpbmF0ZTtcclxuICAgIH0pO1xyXG4gIH1cclxuICB2YXIgaGFzTWluLCBoYXNNYXg7XHJcbiAgdmFyIHZhbHVlcyA9IHRpY2tzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgIGlmIChlbnRyeS5jb29yZGluYXRlID09PSBtaW5WYWx1ZSkge1xyXG4gICAgICBoYXNNaW4gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGVudHJ5LmNvb3JkaW5hdGUgPT09IG1heFZhbHVlKSB7XHJcbiAgICAgIGhhc01heCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW50cnkuY29vcmRpbmF0ZTtcclxuICB9KTtcclxuICBpZiAoIWhhc01pbikge1xyXG4gICAgdmFsdWVzLnB1c2gobWluVmFsdWUpO1xyXG4gIH1cclxuICBpZiAoIWhhc01heCkge1xyXG4gICAgdmFsdWVzLnB1c2gobWF4VmFsdWUpO1xyXG4gIH1cclxuICByZXR1cm4gdmFsdWVzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgdGlja3Mgb2YgYW4gYXhpc1xyXG4gKiBAcGFyYW0gIHtPYmplY3R9ICBheGlzIFRoZSBjb25maWd1cmF0aW9uIG9mIGFuIGF4aXNcclxuICogQHBhcmFtIHtCb29sZWFufSBpc0dyaWQgV2hldGhlciBvciBub3QgYXJlIHRoZSB0aWNrcyBpbiBncmlkXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBbGwgUmV0dXJuIHRoZSB0aWNrcyBvZiBhbGwgdGhlIHBvaW50cyBvciBub3RcclxuICogQHJldHVybiB7QXJyYXl9ICBUaWNrc1xyXG4gKi9cclxudmFyIGdldFRpY2tzT2ZBeGlzID0gZXhwb3J0cy5nZXRUaWNrc09mQXhpcyA9IGZ1bmN0aW9uIGdldFRpY2tzT2ZBeGlzKGF4aXMsIGlzR3JpZCwgaXNBbGwpIHtcclxuICBpZiAoIWF4aXMpIHJldHVybiBudWxsO1xyXG4gIHZhciBzY2FsZSA9IGF4aXMuc2NhbGU7XHJcbiAgdmFyIGR1cGxpY2F0ZURvbWFpbiA9IGF4aXMuZHVwbGljYXRlRG9tYWluLFxyXG4gICAgdHlwZSA9IGF4aXMudHlwZSxcclxuICAgIHJhbmdlID0gYXhpcy5yYW5nZTtcclxuICB2YXIgb2Zmc2V0Rm9yQmFuZCA9IGF4aXMucmVhbFNjYWxlVHlwZSA9PT0gJ3NjYWxlQmFuZCcgPyBzY2FsZS5iYW5kd2lkdGgoKSAvIDIgOiAyO1xyXG4gIHZhciBvZmZzZXQgPSAoaXNHcmlkIHx8IGlzQWxsKSAmJiB0eXBlID09PSAnY2F0ZWdvcnknICYmIHNjYWxlLmJhbmR3aWR0aCA/IHNjYWxlLmJhbmR3aWR0aCgpIC8gb2Zmc2V0Rm9yQmFuZCA6IDA7XHJcbiAgb2Zmc2V0ID0gYXhpcy5heGlzVHlwZSA9PT0gJ2FuZ2xlQXhpcycgJiYgKHJhbmdlID09PSBudWxsIHx8IHJhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByYW5nZS5sZW5ndGgpID49IDIgPyAoMCwgX0RhdGFVdGlscy5tYXRoU2lnbikocmFuZ2VbMF0gLSByYW5nZVsxXSkgKiAyICogb2Zmc2V0IDogb2Zmc2V0O1xyXG5cclxuICAvLyBUaGUgdGlja3Mgc2V0IGJ5IHVzZXIgc2hvdWxkIG9ubHkgYWZmZWN0IHRoZSB0aWNrcyBhZGphY2VudCB0byBheGlzIGxpbmVcclxuICBpZiAoaXNHcmlkICYmIChheGlzLnRpY2tzIHx8IGF4aXMubmljZVRpY2tzKSkge1xyXG4gICAgdmFyIHJlc3VsdCA9IChheGlzLnRpY2tzIHx8IGF4aXMubmljZVRpY2tzKS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgIHZhciBzY2FsZUNvbnRlbnQgPSBkdXBsaWNhdGVEb21haW4gPyBkdXBsaWNhdGVEb21haW4uaW5kZXhPZihlbnRyeSkgOiBlbnRyeTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAvLyBJZiB0aGUgc2NhbGVDb250ZW50IGlzIG5vdCBhIG51bWJlciwgdGhlIGNvb3JkaW5hdGUgd2lsbCBiZSBOYU4uXHJcbiAgICAgICAgLy8gVGhhdCBjb3VsZCBiZSB0aGUgY2FzZSBmb3IgZXhhbXBsZSB3aXRoIGEgUG9pbnRTY2FsZSBhbmQgYSBzdHJpbmcgYXMgZG9tYWluLlxyXG4gICAgICAgIGNvb3JkaW5hdGU6IHNjYWxlKHNjYWxlQ29udGVudCkgKyBvZmZzZXQsXHJcbiAgICAgICAgdmFsdWU6IGVudHJ5LFxyXG4gICAgICAgIG9mZnNldDogb2Zmc2V0XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgcmV0dXJuICEoMCwgX2lzTmFOW1wiZGVmYXVsdFwiXSkocm93LmNvb3JkaW5hdGUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBXaGVuIGF4aXMgaXMgYSBjYXRlZ29yaWFsIGF4aXMsIGJ1dCB0aGUgdHlwZSBvZiBheGlzIGlzIG51bWJlciBvciB0aGUgc2NhbGUgb2YgYXhpcyBpcyBub3QgXCJhdXRvXCJcclxuICBpZiAoYXhpcy5pc0NhdGVnb3JpY2FsICYmIGF4aXMuY2F0ZWdvcmljYWxEb21haW4pIHtcclxuICAgIHJldHVybiBheGlzLmNhdGVnb3JpY2FsRG9tYWluLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgY29vcmRpbmF0ZTogc2NhbGUoZW50cnkpICsgb2Zmc2V0LFxyXG4gICAgICAgIHZhbHVlOiBlbnRyeSxcclxuICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXRcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBpZiAoc2NhbGUudGlja3MgJiYgIWlzQWxsKSB7XHJcbiAgICByZXR1cm4gc2NhbGUudGlja3MoYXhpcy50aWNrQ291bnQpLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBjb29yZGluYXRlOiBzY2FsZShlbnRyeSkgKyBvZmZzZXQsXHJcbiAgICAgICAgdmFsdWU6IGVudHJ5LFxyXG4gICAgICAgIG9mZnNldDogb2Zmc2V0XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIFdoZW4gYXhpcyBoYXMgZHVwbGljYXRlZCB0ZXh0LCBzZXJpYWwgbnVtYmVycyBhcmUgdXNlZCB0byBnZW5lcmF0ZSBzY2FsZVxyXG4gIHJldHVybiBzY2FsZS5kb21haW4oKS5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY29vcmRpbmF0ZTogc2NhbGUoZW50cnkpICsgb2Zmc2V0LFxyXG4gICAgICB2YWx1ZTogZHVwbGljYXRlRG9tYWluID8gZHVwbGljYXRlRG9tYWluW2VudHJ5XSA6IGVudHJ5LFxyXG4gICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgIG9mZnNldDogb2Zmc2V0XHJcbiAgICB9O1xyXG4gIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIGNvbWJpbmUgdGhlIGhhbmRsZXJzXHJcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBkZWZhdWx0SGFuZGxlciBJbnRlcm5hbCBwcml2YXRlIGhhbmRsZXJcclxuICogQHBhcmFtICB7RnVuY3Rpb259IGNoaWxkSGFuZGxlciBIYW5kbGVyIGZ1bmN0aW9uIHNwZWNpZmllZCBpbiBjaGlsZCBjb21wb25lbnRcclxuICogQHJldHVybiB7RnVuY3Rpb259ICAgICAgICAgICAgICAgIFRoZSBjb21iaW5lZCBoYW5kbGVyXHJcbiAqL1xyXG5cclxudmFyIGhhbmRsZXJXZWFrTWFwID0gbmV3IFdlYWtNYXAoKTtcclxudmFyIGNvbWJpbmVFdmVudEhhbmRsZXJzID0gZXhwb3J0cy5jb21iaW5lRXZlbnRIYW5kbGVycyA9IGZ1bmN0aW9uIGNvbWJpbmVFdmVudEhhbmRsZXJzKGRlZmF1bHRIYW5kbGVyLCBjaGlsZEhhbmRsZXIpIHtcclxuICBpZiAodHlwZW9mIGNoaWxkSGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcmV0dXJuIGRlZmF1bHRIYW5kbGVyO1xyXG4gIH1cclxuICBpZiAoIWhhbmRsZXJXZWFrTWFwLmhhcyhkZWZhdWx0SGFuZGxlcikpIHtcclxuICAgIGhhbmRsZXJXZWFrTWFwLnNldChkZWZhdWx0SGFuZGxlciwgbmV3IFdlYWtNYXAoKSk7XHJcbiAgfVxyXG4gIHZhciBjaGlsZFdlYWtNYXAgPSBoYW5kbGVyV2Vha01hcC5nZXQoZGVmYXVsdEhhbmRsZXIpO1xyXG4gIGlmIChjaGlsZFdlYWtNYXAuaGFzKGNoaWxkSGFuZGxlcikpIHtcclxuICAgIHJldHVybiBjaGlsZFdlYWtNYXAuZ2V0KGNoaWxkSGFuZGxlcik7XHJcbiAgfVxyXG4gIHZhciBjb21iaW5lSGFuZGxlciA9IGZ1bmN0aW9uIGNvbWJpbmVIYW5kbGVyKCkge1xyXG4gICAgZGVmYXVsdEhhbmRsZXIuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xyXG4gICAgY2hpbGRIYW5kbGVyLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcclxuICB9O1xyXG4gIGNoaWxkV2Vha01hcC5zZXQoY2hpbGRIYW5kbGVyLCBjb21iaW5lSGFuZGxlcik7XHJcbiAgcmV0dXJuIGNvbWJpbmVIYW5kbGVyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlIHRoZSBzY2FsZSBmdW5jdGlvbiBvZiBheGlzXHJcbiAqIEBwYXJhbSAge09iamVjdH0gICBheGlzICAgICAgICAgIFRoZSBvcHRpb24gb2YgYXhpc1xyXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgY2hhcnRUeXBlICAgICBUaGUgZGlzcGxheU5hbWUgb2YgY2hhcnRcclxuICogQHBhcmFtICB7Qm9vbGVhbn0gIGhhc0JhciAgICAgICAgaWYgaXQgaGFzIGEgYmFyXHJcbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICBUaGUgc2NhbGUgZnVuY3Rpb24gYW5kIHJlc29sdmVkIG5hbWVcclxuICovXHJcbnZhciBwYXJzZVNjYWxlID0gZXhwb3J0cy5wYXJzZVNjYWxlID0gZnVuY3Rpb24gcGFyc2VTY2FsZShheGlzLCBjaGFydFR5cGUsIGhhc0Jhcikge1xyXG4gIHZhciBzY2FsZSA9IGF4aXMuc2NhbGUsXHJcbiAgICB0eXBlID0gYXhpcy50eXBlLFxyXG4gICAgbGF5b3V0ID0gYXhpcy5sYXlvdXQsXHJcbiAgICBheGlzVHlwZSA9IGF4aXMuYXhpc1R5cGU7XHJcbiAgaWYgKHNjYWxlID09PSAnYXV0bycpIHtcclxuICAgIGlmIChsYXlvdXQgPT09ICdyYWRpYWwnICYmIGF4aXNUeXBlID09PSAncmFkaXVzQXhpcycpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzY2FsZTogZDNTY2FsZXMuc2NhbGVCYW5kKCksXHJcbiAgICAgICAgcmVhbFNjYWxlVHlwZTogJ2JhbmQnXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAobGF5b3V0ID09PSAncmFkaWFsJyAmJiBheGlzVHlwZSA9PT0gJ2FuZ2xlQXhpcycpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzY2FsZTogZDNTY2FsZXMuc2NhbGVMaW5lYXIoKSxcclxuICAgICAgICByZWFsU2NhbGVUeXBlOiAnbGluZWFyJ1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGUgPT09ICdjYXRlZ29yeScgJiYgY2hhcnRUeXBlICYmIChjaGFydFR5cGUuaW5kZXhPZignTGluZUNoYXJ0JykgPj0gMCB8fCBjaGFydFR5cGUuaW5kZXhPZignQXJlYUNoYXJ0JykgPj0gMCB8fCBjaGFydFR5cGUuaW5kZXhPZignQ29tcG9zZWRDaGFydCcpID49IDAgJiYgIWhhc0JhcikpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzY2FsZTogZDNTY2FsZXMuc2NhbGVQb2ludCgpLFxyXG4gICAgICAgIHJlYWxTY2FsZVR5cGU6ICdwb2ludCdcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlID09PSAnY2F0ZWdvcnknKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc2NhbGU6IGQzU2NhbGVzLnNjYWxlQmFuZCgpLFxyXG4gICAgICAgIHJlYWxTY2FsZVR5cGU6ICdiYW5kJ1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc2NhbGU6IGQzU2NhbGVzLnNjYWxlTGluZWFyKCksXHJcbiAgICAgIHJlYWxTY2FsZVR5cGU6ICdsaW5lYXInXHJcbiAgICB9O1xyXG4gIH1cclxuICBpZiAoKDAsIF9pc1N0cmluZ1tcImRlZmF1bHRcIl0pKHNjYWxlKSkge1xyXG4gICAgdmFyIG5hbWUgPSBcInNjYWxlXCIuY29uY2F0KCgwLCBfdXBwZXJGaXJzdFtcImRlZmF1bHRcIl0pKHNjYWxlKSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzY2FsZTogKGQzU2NhbGVzW25hbWVdIHx8IGQzU2NhbGVzLnNjYWxlUG9pbnQpKCksXHJcbiAgICAgIHJlYWxTY2FsZVR5cGU6IGQzU2NhbGVzW25hbWVdID8gbmFtZSA6ICdwb2ludCdcclxuICAgIH07XHJcbiAgfVxyXG4gIHJldHVybiAoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShzY2FsZSkgPyB7XHJcbiAgICBzY2FsZTogc2NhbGVcclxuICB9IDoge1xyXG4gICAgc2NhbGU6IGQzU2NhbGVzLnNjYWxlUG9pbnQoKSxcclxuICAgIHJlYWxTY2FsZVR5cGU6ICdwb2ludCdcclxuICB9O1xyXG59O1xyXG52YXIgRVBTID0gMWUtNDtcclxudmFyIGNoZWNrRG9tYWluT2ZTY2FsZSA9IGV4cG9ydHMuY2hlY2tEb21haW5PZlNjYWxlID0gZnVuY3Rpb24gY2hlY2tEb21haW5PZlNjYWxlKHNjYWxlKSB7XHJcbiAgdmFyIGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpO1xyXG4gIGlmICghZG9tYWluIHx8IGRvbWFpbi5sZW5ndGggPD0gMikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgbGVuID0gZG9tYWluLmxlbmd0aDtcclxuICB2YXIgcmFuZ2UgPSBzY2FsZS5yYW5nZSgpO1xyXG4gIHZhciBtaW5WYWx1ZSA9IE1hdGgubWluKHJhbmdlWzBdLCByYW5nZVsxXSkgLSBFUFM7XHJcbiAgdmFyIG1heFZhbHVlID0gTWF0aC5tYXgocmFuZ2VbMF0sIHJhbmdlWzFdKSArIEVQUztcclxuICB2YXIgZmlyc3QgPSBzY2FsZShkb21haW5bMF0pO1xyXG4gIHZhciBsYXN0ID0gc2NhbGUoZG9tYWluW2xlbiAtIDFdKTtcclxuICBpZiAoZmlyc3QgPCBtaW5WYWx1ZSB8fCBmaXJzdCA+IG1heFZhbHVlIHx8IGxhc3QgPCBtaW5WYWx1ZSB8fCBsYXN0ID4gbWF4VmFsdWUpIHtcclxuICAgIHNjYWxlLmRvbWFpbihbZG9tYWluWzBdLCBkb21haW5bbGVuIC0gMV1dKTtcclxuICB9XHJcbn07XHJcbnZhciBmaW5kUG9zaXRpb25PZkJhciA9IGV4cG9ydHMuZmluZFBvc2l0aW9uT2ZCYXIgPSBmdW5jdGlvbiBmaW5kUG9zaXRpb25PZkJhcihiYXJQb3NpdGlvbiwgY2hpbGQpIHtcclxuICBpZiAoIWJhclBvc2l0aW9uKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJhclBvc2l0aW9uLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICBpZiAoYmFyUG9zaXRpb25baV0uaXRlbSA9PT0gY2hpbGQpIHtcclxuICAgICAgcmV0dXJuIGJhclBvc2l0aW9uW2ldLnBvc2l0aW9uO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBCb3RoIHZhbHVlIGFuZCBkb21haW4gYXJlIHR1cGxlcyBvZiB0d28gbnVtYmVyc1xyXG4gKiAtIGJ1dCB0aGUgdHlwZSBzdGF5cyBhcyBhcnJheSBvZiBudW1iZXJzIHVudGlsIHdlIGhhdmUgYmV0dGVyIHN1cHBvcnQgaW4gcmVzdCBvZiB0aGUgYXBwXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlIGlucHV0IHRoYXQgd2lsbCBiZSB0cnVuY2F0ZWRcclxuICogQHBhcmFtIHtBcnJheX0gZG9tYWluIGJvdW5kYXJpZXNcclxuICogQHJldHVybnMge0FycmF5fSB0dXBsZSBvZiB0d28gbnVtYmVyc1xyXG4gKi9cclxudmFyIHRydW5jYXRlQnlEb21haW4gPSBleHBvcnRzLnRydW5jYXRlQnlEb21haW4gPSBmdW5jdGlvbiB0cnVuY2F0ZUJ5RG9tYWluKHZhbHVlLCBkb21haW4pIHtcclxuICBpZiAoIWRvbWFpbiB8fCBkb21haW4ubGVuZ3RoICE9PSAyIHx8ICEoMCwgX0RhdGFVdGlscy5pc051bWJlcikoZG9tYWluWzBdKSB8fCAhKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGRvbWFpblsxXSkpIHtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcbiAgdmFyIG1pblZhbHVlID0gTWF0aC5taW4oZG9tYWluWzBdLCBkb21haW5bMV0pO1xyXG4gIHZhciBtYXhWYWx1ZSA9IE1hdGgubWF4KGRvbWFpblswXSwgZG9tYWluWzFdKTtcclxuICB2YXIgcmVzdWx0ID0gW3ZhbHVlWzBdLCB2YWx1ZVsxXV07XHJcbiAgaWYgKCEoMCwgX0RhdGFVdGlscy5pc051bWJlcikodmFsdWVbMF0pIHx8IHZhbHVlWzBdIDwgbWluVmFsdWUpIHtcclxuICAgIHJlc3VsdFswXSA9IG1pblZhbHVlO1xyXG4gIH1cclxuICBpZiAoISgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKSh2YWx1ZVsxXSkgfHwgdmFsdWVbMV0gPiBtYXhWYWx1ZSkge1xyXG4gICAgcmVzdWx0WzFdID0gbWF4VmFsdWU7XHJcbiAgfVxyXG4gIGlmIChyZXN1bHRbMF0gPiBtYXhWYWx1ZSkge1xyXG4gICAgcmVzdWx0WzBdID0gbWF4VmFsdWU7XHJcbiAgfVxyXG4gIGlmIChyZXN1bHRbMV0gPCBtaW5WYWx1ZSkge1xyXG4gICAgcmVzdWx0WzFdID0gbWluVmFsdWU7XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogU3RhY2tzIGFsbCBwb3NpdGl2ZSBudW1iZXJzIGFib3ZlIHplcm8gYW5kIGFsbCBuZWdhdGl2ZSBudW1iZXJzIGJlbG93IHplcm8uXHJcbiAqXHJcbiAqIElmIGFsbCB2YWx1ZXMgaW4gdGhlIHNlcmllcyBhcmUgcG9zaXRpdmUgdGhlbiB0aGlzIGJlaGF2ZXMgdGhlIHNhbWUgYXMgJ25vbmUnIHN0YWNrZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHNlcmllcyBmcm9tIGQzLXNoYXBlIFN0YWNrXHJcbiAqIEByZXR1cm4ge0FycmF5fSBzZXJpZXMgd2l0aCBhcHBsaWVkIG9mZnNldFxyXG4gKi9cclxudmFyIG9mZnNldFNpZ24gPSBleHBvcnRzLm9mZnNldFNpZ24gPSBmdW5jdGlvbiBvZmZzZXRTaWduKHNlcmllcykge1xyXG4gIHZhciBuID0gc2VyaWVzLmxlbmd0aDtcclxuICBpZiAobiA8PSAwKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGZvciAodmFyIGogPSAwLCBtID0gc2VyaWVzWzBdLmxlbmd0aDsgaiA8IG07ICsraikge1xyXG4gICAgdmFyIHBvc2l0aXZlID0gMDtcclxuICAgIHZhciBuZWdhdGl2ZSA9IDA7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICB2YXIgdmFsdWUgPSAoMCwgX2lzTmFOW1wiZGVmYXVsdFwiXSkoc2VyaWVzW2ldW2pdWzFdKSA/IHNlcmllc1tpXVtqXVswXSA6IHNlcmllc1tpXVtqXVsxXTtcclxuXHJcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHByZWZlci1kZXN0cnVjdHVyaW5nLCBuby1wYXJhbS1yZWFzc2lnbiAqL1xyXG4gICAgICBpZiAodmFsdWUgPj0gMCkge1xyXG4gICAgICAgIHNlcmllc1tpXVtqXVswXSA9IHBvc2l0aXZlO1xyXG4gICAgICAgIHNlcmllc1tpXVtqXVsxXSA9IHBvc2l0aXZlICsgdmFsdWU7XHJcbiAgICAgICAgcG9zaXRpdmUgPSBzZXJpZXNbaV1bal1bMV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2VyaWVzW2ldW2pdWzBdID0gbmVnYXRpdmU7XHJcbiAgICAgICAgc2VyaWVzW2ldW2pdWzFdID0gbmVnYXRpdmUgKyB2YWx1ZTtcclxuICAgICAgICBuZWdhdGl2ZSA9IHNlcmllc1tpXVtqXVsxXTtcclxuICAgICAgfVxyXG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHByZWZlci1kZXN0cnVjdHVyaW5nLCBuby1wYXJhbS1yZWFzc2lnbiAqL1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXBsYWNlcyBhbGwgbmVnYXRpdmUgdmFsdWVzIHdpdGggemVybyB3aGVuIHN0YWNraW5nIGRhdGEuXHJcbiAqXHJcbiAqIElmIGFsbCB2YWx1ZXMgaW4gdGhlIHNlcmllcyBhcmUgcG9zaXRpdmUgdGhlbiB0aGlzIGJlaGF2ZXMgdGhlIHNhbWUgYXMgJ25vbmUnIHN0YWNrZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHNlcmllcyBmcm9tIGQzLXNoYXBlIFN0YWNrXHJcbiAqIEByZXR1cm4ge0FycmF5fSBzZXJpZXMgd2l0aCBhcHBsaWVkIG9mZnNldFxyXG4gKi9cclxudmFyIG9mZnNldFBvc2l0aXZlID0gZXhwb3J0cy5vZmZzZXRQb3NpdGl2ZSA9IGZ1bmN0aW9uIG9mZnNldFBvc2l0aXZlKHNlcmllcykge1xyXG4gIHZhciBuID0gc2VyaWVzLmxlbmd0aDtcclxuICBpZiAobiA8PSAwKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGZvciAodmFyIGogPSAwLCBtID0gc2VyaWVzWzBdLmxlbmd0aDsgaiA8IG07ICsraikge1xyXG4gICAgdmFyIHBvc2l0aXZlID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9ICgwLCBfaXNOYU5bXCJkZWZhdWx0XCJdKShzZXJpZXNbaV1bal1bMV0pID8gc2VyaWVzW2ldW2pdWzBdIDogc2VyaWVzW2ldW2pdWzFdO1xyXG5cclxuICAgICAgLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWRlc3RydWN0dXJpbmcsIG5vLXBhcmFtLXJlYXNzaWduICovXHJcbiAgICAgIGlmICh2YWx1ZSA+PSAwKSB7XHJcbiAgICAgICAgc2VyaWVzW2ldW2pdWzBdID0gcG9zaXRpdmU7XHJcbiAgICAgICAgc2VyaWVzW2ldW2pdWzFdID0gcG9zaXRpdmUgKyB2YWx1ZTtcclxuICAgICAgICBwb3NpdGl2ZSA9IHNlcmllc1tpXVtqXVsxXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZXJpZXNbaV1bal1bMF0gPSAwO1xyXG4gICAgICAgIHNlcmllc1tpXVtqXVsxXSA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgLyogZXNsaW50LWVuYWJsZSBwcmVmZXItZGVzdHJ1Y3R1cmluZywgbm8tcGFyYW0tcmVhc3NpZ24gKi9cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRnVuY3Rpb24gdHlwZSB0byBjb21wdXRlIG9mZnNldCBmb3Igc3RhY2tlZCBkYXRhLlxyXG4gKlxyXG4gKiBkMy1zaGFwZSBoYXMgc29tZXRoaW5nIGZpc2h5IGdvaW5nIG9uIHdpdGggaXRzIHR5cGVzLlxyXG4gKiBJbiBAZGVmaW5pdGVseXR5cGVkL2QzLXNoYXBlLCB0aGlzIGZ1bmN0aW9uICh0aGUgb2Zmc2V0IGFjY2Vzc29yKSBpcyB0eXBlZCBhcyBTZXJpZXM8PiA9PiB2b2lkLlxyXG4gKiBIb3dldmVyISBXaGVuIEkgYWN0dWFsbHkgb3BlbiB0aGUgc3Rvcnlib29rIEkgY2FuIHNlZSB0aGF0IHRoZSBvZmZzZXQgYWNjZXNzb3IgYWN0dWFsbHkgcmVjZWl2ZXMgQXJyYXk8U2VyaWVzPD4+LlxyXG4gKiBUaGUgc2FtZSBJIGNhbiBzZWUgaW4gdGhlIHNvdXJjZSBjb2RlIGl0c2VsZjpcclxuICogaHR0cHM6Ly9naXRodWIuY29tL0RlZmluaXRlbHlUeXBlZC9EZWZpbml0ZWx5VHlwZWQvZGlzY3Vzc2lvbnMvNjYwNDJcclxuICogVGhhdCBvbmUgdW5mb3J0dW5hdGVseSBoYXMgbm8gdHlwZXMgYnV0IHdlIGNhbiB0ZWxsIGl0IHBhc3NlcyB0aHJlZS1kaW1lbnNpb25hbCBhcnJheS5cclxuICpcclxuICogV2hpY2ggbGVhZHMgbWUgdG8gYmVsaWV2ZSB0aGF0IGRlZmluaXRlbHl0eXBlZCBpcyB3cm9uZyBvbiB0aGlzIG9uZS5cclxuICogVGhlcmUncyBvcGVuIGRpc2N1c3Npb24gb24gdGhpcyB0b3BpYyB3aXRob3V0IG11Y2ggYXR0ZW50aW9uOlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vRGVmaW5pdGVseVR5cGVkL0RlZmluaXRlbHlUeXBlZC9kaXNjdXNzaW9ucy82NjA0MlxyXG4gKi9cclxuXHJcbnZhciBTVEFDS19PRkZTRVRfTUFQID0ge1xyXG4gIHNpZ246IG9mZnNldFNpZ24sXHJcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBkZWZpbml0ZWx5dHlwZWQgdHlwZXMgYXJlIGluY29ycmVjdFxyXG4gIGV4cGFuZDogX2QzU2hhcGUuc3RhY2tPZmZzZXRFeHBhbmQsXHJcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBkZWZpbml0ZWx5dHlwZWQgdHlwZXMgYXJlIGluY29ycmVjdFxyXG4gIG5vbmU6IF9kM1NoYXBlLnN0YWNrT2Zmc2V0Tm9uZSxcclxuICAvLyBAdHMtZXhwZWN0LWVycm9yIGRlZmluaXRlbHl0eXBlZCB0eXBlcyBhcmUgaW5jb3JyZWN0XHJcbiAgc2lsaG91ZXR0ZTogX2QzU2hhcGUuc3RhY2tPZmZzZXRTaWxob3VldHRlLFxyXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgZGVmaW5pdGVseXR5cGVkIHR5cGVzIGFyZSBpbmNvcnJlY3RcclxuICB3aWdnbGU6IF9kM1NoYXBlLnN0YWNrT2Zmc2V0V2lnZ2xlLFxyXG4gIHBvc2l0aXZlOiBvZmZzZXRQb3NpdGl2ZVxyXG59O1xyXG52YXIgZ2V0U3RhY2tlZERhdGEgPSBleHBvcnRzLmdldFN0YWNrZWREYXRhID0gZnVuY3Rpb24gZ2V0U3RhY2tlZERhdGEoZGF0YSwgc3RhY2tJdGVtcywgb2Zmc2V0VHlwZSkge1xyXG4gIHZhciBkYXRhS2V5cyA9IHN0YWNrSXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICByZXR1cm4gaXRlbS5wcm9wcy5kYXRhS2V5O1xyXG4gIH0pO1xyXG4gIHZhciBvZmZzZXRBY2Nlc3NvciA9IFNUQUNLX09GRlNFVF9NQVBbb2Zmc2V0VHlwZV07XHJcbiAgdmFyIHN0YWNrID0gKDAsIF9kM1NoYXBlLnN0YWNrKSgpXHJcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBzdGFjay5rZXlzIHR5cGUgd2FudHMgYW4gYXJyYXkgb2Ygc3RyaW5ncywgYnV0IHdlIHByb3ZpZGUgYXJyYXkgb2YgRGF0YUtleXNcclxuICAua2V5cyhkYXRhS2V5cykudmFsdWUoZnVuY3Rpb24gKGQsIGtleSkge1xyXG4gICAgcmV0dXJuICtnZXRWYWx1ZUJ5RGF0YUtleShkLCBrZXksIDApO1xyXG4gIH0pLm9yZGVyKF9kM1NoYXBlLnN0YWNrT3JkZXJOb25lKVxyXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgZGVmaW5pdGVseXR5cGVkIHR5cGVzIGFyZSBpbmNvcnJlY3RcclxuICAub2Zmc2V0KG9mZnNldEFjY2Vzc29yKTtcclxuICByZXR1cm4gc3RhY2soZGF0YSk7XHJcbn07XHJcbnZhciBnZXRTdGFja0dyb3Vwc0J5QXhpc0lkID0gZXhwb3J0cy5nZXRTdGFja0dyb3Vwc0J5QXhpc0lkID0gZnVuY3Rpb24gZ2V0U3RhY2tHcm91cHNCeUF4aXNJZChkYXRhLCBfaXRlbXMsIG51bWVyaWNBeGlzSWQsIGNhdGVBeGlzSWQsIG9mZnNldFR5cGUsIHJldmVyc2VTdGFja09yZGVyKSB7XHJcbiAgaWYgKCFkYXRhKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIHJldmVyc2luZyBpdGVtcyB0byBhZmZlY3QgcmVuZGVyIG9yZGVyIChmb3IgbGF5ZXJpbmcpXHJcbiAgdmFyIGl0ZW1zID0gcmV2ZXJzZVN0YWNrT3JkZXIgPyBfaXRlbXMucmV2ZXJzZSgpIDogX2l0ZW1zO1xyXG4gIHZhciBwYXJlbnRTdGFja0dyb3Vwc0luaXRpYWxWYWx1ZSA9IHt9O1xyXG4gIHZhciBzdGFja0dyb3VwcyA9IGl0ZW1zLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBpdGVtKSB7XHJcbiAgICB2YXIgX2l0ZW0kdHlwZTI7XHJcbiAgICB2YXIgZGVmYXVsdGVkUHJvcHMgPSAoX2l0ZW0kdHlwZTIgPSBpdGVtLnR5cGUpICE9PSBudWxsICYmIF9pdGVtJHR5cGUyICE9PSB2b2lkIDAgJiYgX2l0ZW0kdHlwZTIuZGVmYXVsdFByb3BzID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBpdGVtLnR5cGUuZGVmYXVsdFByb3BzKSwgaXRlbS5wcm9wcykgOiBpdGVtLnByb3BzO1xyXG4gICAgdmFyIHN0YWNrSWQgPSBkZWZhdWx0ZWRQcm9wcy5zdGFja0lkLFxyXG4gICAgICBoaWRlID0gZGVmYXVsdGVkUHJvcHMuaGlkZTtcclxuICAgIGlmIChoaWRlKSB7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICB2YXIgYXhpc0lkID0gZGVmYXVsdGVkUHJvcHNbbnVtZXJpY0F4aXNJZF07XHJcbiAgICB2YXIgcGFyZW50R3JvdXAgPSByZXN1bHRbYXhpc0lkXSB8fCB7XHJcbiAgICAgIGhhc1N0YWNrOiBmYWxzZSxcclxuICAgICAgc3RhY2tHcm91cHM6IHt9XHJcbiAgICB9O1xyXG4gICAgaWYgKCgwLCBfRGF0YVV0aWxzLmlzTnVtT3JTdHIpKHN0YWNrSWQpKSB7XHJcbiAgICAgIHZhciBjaGlsZEdyb3VwID0gcGFyZW50R3JvdXAuc3RhY2tHcm91cHNbc3RhY2tJZF0gfHwge1xyXG4gICAgICAgIG51bWVyaWNBeGlzSWQ6IG51bWVyaWNBeGlzSWQsXHJcbiAgICAgICAgY2F0ZUF4aXNJZDogY2F0ZUF4aXNJZCxcclxuICAgICAgICBpdGVtczogW11cclxuICAgICAgfTtcclxuICAgICAgY2hpbGRHcm91cC5pdGVtcy5wdXNoKGl0ZW0pO1xyXG4gICAgICBwYXJlbnRHcm91cC5oYXNTdGFjayA9IHRydWU7XHJcbiAgICAgIHBhcmVudEdyb3VwLnN0YWNrR3JvdXBzW3N0YWNrSWRdID0gY2hpbGRHcm91cDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBhcmVudEdyb3VwLnN0YWNrR3JvdXBzWygwLCBfRGF0YVV0aWxzLnVuaXF1ZUlkKSgnX3N0YWNrSWRfJyldID0ge1xyXG4gICAgICAgIG51bWVyaWNBeGlzSWQ6IG51bWVyaWNBeGlzSWQsXHJcbiAgICAgICAgY2F0ZUF4aXNJZDogY2F0ZUF4aXNJZCxcclxuICAgICAgICBpdGVtczogW2l0ZW1dXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXN1bHQpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBheGlzSWQsIHBhcmVudEdyb3VwKSk7XHJcbiAgfSwgcGFyZW50U3RhY2tHcm91cHNJbml0aWFsVmFsdWUpO1xyXG4gIHZhciBheGlzU3RhY2tHcm91cHNJbml0aWFsVmFsdWUgPSB7fTtcclxuICByZXR1cm4gT2JqZWN0LmtleXMoc3RhY2tHcm91cHMpLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBheGlzSWQpIHtcclxuICAgIHZhciBncm91cCA9IHN0YWNrR3JvdXBzW2F4aXNJZF07XHJcbiAgICBpZiAoZ3JvdXAuaGFzU3RhY2spIHtcclxuICAgICAgdmFyIHN0YWNrR3JvdXBzSW5pdGlhbFZhbHVlID0ge307XHJcbiAgICAgIGdyb3VwLnN0YWNrR3JvdXBzID0gT2JqZWN0LmtleXMoZ3JvdXAuc3RhY2tHcm91cHMpLnJlZHVjZShmdW5jdGlvbiAocmVzLCBzdGFja0lkKSB7XHJcbiAgICAgICAgdmFyIGcgPSBncm91cC5zdGFja0dyb3Vwc1tzdGFja0lkXTtcclxuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXMpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBzdGFja0lkLCB7XHJcbiAgICAgICAgICBudW1lcmljQXhpc0lkOiBudW1lcmljQXhpc0lkLFxyXG4gICAgICAgICAgY2F0ZUF4aXNJZDogY2F0ZUF4aXNJZCxcclxuICAgICAgICAgIGl0ZW1zOiBnLml0ZW1zLFxyXG4gICAgICAgICAgc3RhY2tlZERhdGE6IGdldFN0YWNrZWREYXRhKGRhdGEsIGcuaXRlbXMsIG9mZnNldFR5cGUpXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9LCBzdGFja0dyb3Vwc0luaXRpYWxWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXN1bHQpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBheGlzSWQsIGdyb3VwKSk7XHJcbiAgfSwgYXhpc1N0YWNrR3JvdXBzSW5pdGlhbFZhbHVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb25maWd1cmUgdGhlIHNjYWxlIGZ1bmN0aW9uIG9mIGF4aXNcclxuICogQHBhcmFtIHtPYmplY3R9IHNjYWxlIFRoZSBzY2FsZSBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyAgVGhlIGNvbmZpZ3VyYXRpb24gb2YgYXhpc1xyXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgbnVsbFxyXG4gKi9cclxudmFyIGdldFRpY2tzT2ZTY2FsZSA9IGV4cG9ydHMuZ2V0VGlja3NPZlNjYWxlID0gZnVuY3Rpb24gZ2V0VGlja3NPZlNjYWxlKHNjYWxlLCBvcHRzKSB7XHJcbiAgdmFyIHJlYWxTY2FsZVR5cGUgPSBvcHRzLnJlYWxTY2FsZVR5cGUsXHJcbiAgICB0eXBlID0gb3B0cy50eXBlLFxyXG4gICAgdGlja0NvdW50ID0gb3B0cy50aWNrQ291bnQsXHJcbiAgICBvcmlnaW5hbERvbWFpbiA9IG9wdHMub3JpZ2luYWxEb21haW4sXHJcbiAgICBhbGxvd0RlY2ltYWxzID0gb3B0cy5hbGxvd0RlY2ltYWxzO1xyXG4gIHZhciBzY2FsZVR5cGUgPSByZWFsU2NhbGVUeXBlIHx8IG9wdHMuc2NhbGU7XHJcbiAgaWYgKHNjYWxlVHlwZSAhPT0gJ2F1dG8nICYmIHNjYWxlVHlwZSAhPT0gJ2xpbmVhcicpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICBpZiAodGlja0NvdW50ICYmIHR5cGUgPT09ICdudW1iZXInICYmIG9yaWdpbmFsRG9tYWluICYmIChvcmlnaW5hbERvbWFpblswXSA9PT0gJ2F1dG8nIHx8IG9yaWdpbmFsRG9tYWluWzFdID09PSAnYXV0bycpKSB7XHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHRpY2tzIGJ5IHRoZSBudW1iZXIgb2YgZ3JpZCB3aGVuIHRoZSBheGlzIGlzIGEgbnVtYmVyIGF4aXNcclxuICAgIHZhciBkb21haW4gPSBzY2FsZS5kb21haW4oKTtcclxuICAgIGlmICghZG9tYWluLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHZhciB0aWNrVmFsdWVzID0gKDAsIF9yZWNoYXJ0c1NjYWxlLmdldE5pY2VUaWNrVmFsdWVzKShkb21haW4sIHRpY2tDb3VudCwgYWxsb3dEZWNpbWFscyk7XHJcbiAgICBzY2FsZS5kb21haW4oWygwLCBfbWluW1wiZGVmYXVsdFwiXSkodGlja1ZhbHVlcyksICgwLCBfbWF4W1wiZGVmYXVsdFwiXSkodGlja1ZhbHVlcyldKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5pY2VUaWNrczogdGlja1ZhbHVlc1xyXG4gICAgfTtcclxuICB9XHJcbiAgaWYgKHRpY2tDb3VudCAmJiB0eXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgdmFyIF9kb21haW4gPSBzY2FsZS5kb21haW4oKTtcclxuICAgIHZhciBfdGlja1ZhbHVlcyA9ICgwLCBfcmVjaGFydHNTY2FsZS5nZXRUaWNrVmFsdWVzRml4ZWREb21haW4pKF9kb21haW4sIHRpY2tDb3VudCwgYWxsb3dEZWNpbWFscyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuaWNlVGlja3M6IF90aWNrVmFsdWVzXHJcbiAgICB9O1xyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufTtcclxuZnVuY3Rpb24gZ2V0Q2F0ZUNvb3JkaW5hdGVPZkxpbmUoX3JlZjUpIHtcclxuICB2YXIgYXhpcyA9IF9yZWY1LmF4aXMsXHJcbiAgICB0aWNrcyA9IF9yZWY1LnRpY2tzLFxyXG4gICAgYmFuZFNpemUgPSBfcmVmNS5iYW5kU2l6ZSxcclxuICAgIGVudHJ5ID0gX3JlZjUuZW50cnksXHJcbiAgICBpbmRleCA9IF9yZWY1LmluZGV4LFxyXG4gICAgZGF0YUtleSA9IF9yZWY1LmRhdGFLZXk7XHJcbiAgaWYgKGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xyXG4gICAgLy8gZmluZCBjb29yZGluYXRlIG9mIGNhdGVnb3J5IGF4aXMgYnkgdGhlIHZhbHVlIG9mIGNhdGVnb3J5XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHdoeSBkb2VzIHRoaXMgdXNlIGRpcmVjdCBvYmplY3QgYWNjZXNzIGluc3RlYWQgb2YgZ2V0VmFsdWVCeURhdGFLZXk/XHJcbiAgICBpZiAoIWF4aXMuYWxsb3dEdXBsaWNhdGVkQ2F0ZWdvcnkgJiYgYXhpcy5kYXRhS2V5ICYmICEoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoZW50cnlbYXhpcy5kYXRhS2V5XSkpIHtcclxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB3aHkgZG9lcyB0aGlzIHVzZSBkaXJlY3Qgb2JqZWN0IGFjY2VzcyBpbnN0ZWFkIG9mIGdldFZhbHVlQnlEYXRhS2V5P1xyXG4gICAgICB2YXIgbWF0Y2hlZFRpY2sgPSAoMCwgX0RhdGFVdGlscy5maW5kRW50cnlJbkFycmF5KSh0aWNrcywgJ3ZhbHVlJywgZW50cnlbYXhpcy5kYXRhS2V5XSk7XHJcbiAgICAgIGlmIChtYXRjaGVkVGljaykge1xyXG4gICAgICAgIHJldHVybiBtYXRjaGVkVGljay5jb29yZGluYXRlICsgYmFuZFNpemUgLyAyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGlja3NbaW5kZXhdID8gdGlja3NbaW5kZXhdLmNvb3JkaW5hdGUgKyBiYW5kU2l6ZSAvIDIgOiBudWxsO1xyXG4gIH1cclxuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZUJ5RGF0YUtleShlbnRyeSwgISgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShkYXRhS2V5KSA/IGRhdGFLZXkgOiBheGlzLmRhdGFLZXkpO1xyXG4gIHJldHVybiAhKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKHZhbHVlKSA/IGF4aXMuc2NhbGUodmFsdWUpIDogbnVsbDtcclxufVxyXG52YXIgZ2V0Q2F0ZUNvb3JkaW5hdGVPZkJhciA9IGV4cG9ydHMuZ2V0Q2F0ZUNvb3JkaW5hdGVPZkJhciA9IGZ1bmN0aW9uIGdldENhdGVDb29yZGluYXRlT2ZCYXIoX3JlZjYpIHtcclxuICB2YXIgYXhpcyA9IF9yZWY2LmF4aXMsXHJcbiAgICB0aWNrcyA9IF9yZWY2LnRpY2tzLFxyXG4gICAgb2Zmc2V0ID0gX3JlZjYub2Zmc2V0LFxyXG4gICAgYmFuZFNpemUgPSBfcmVmNi5iYW5kU2l6ZSxcclxuICAgIGVudHJ5ID0gX3JlZjYuZW50cnksXHJcbiAgICBpbmRleCA9IF9yZWY2LmluZGV4O1xyXG4gIGlmIChheGlzLnR5cGUgPT09ICdjYXRlZ29yeScpIHtcclxuICAgIHJldHVybiB0aWNrc1tpbmRleF0gPyB0aWNrc1tpbmRleF0uY29vcmRpbmF0ZSArIG9mZnNldCA6IG51bGw7XHJcbiAgfVxyXG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlQnlEYXRhS2V5KGVudHJ5LCBheGlzLmRhdGFLZXksIGF4aXMuZG9tYWluW2luZGV4XSk7XHJcbiAgcmV0dXJuICEoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkodmFsdWUpID8gYXhpcy5zY2FsZSh2YWx1ZSkgLSBiYW5kU2l6ZSAvIDIgKyBvZmZzZXQgOiBudWxsO1xyXG59O1xyXG52YXIgZ2V0QmFzZVZhbHVlT2ZCYXIgPSBleHBvcnRzLmdldEJhc2VWYWx1ZU9mQmFyID0gZnVuY3Rpb24gZ2V0QmFzZVZhbHVlT2ZCYXIoX3JlZjcpIHtcclxuICB2YXIgbnVtZXJpY0F4aXMgPSBfcmVmNy5udW1lcmljQXhpcztcclxuICB2YXIgZG9tYWluID0gbnVtZXJpY0F4aXMuc2NhbGUuZG9tYWluKCk7XHJcbiAgaWYgKG51bWVyaWNBeGlzLnR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICB2YXIgbWluVmFsdWUgPSBNYXRoLm1pbihkb21haW5bMF0sIGRvbWFpblsxXSk7XHJcbiAgICB2YXIgbWF4VmFsdWUgPSBNYXRoLm1heChkb21haW5bMF0sIGRvbWFpblsxXSk7XHJcbiAgICBpZiAobWluVmFsdWUgPD0gMCAmJiBtYXhWYWx1ZSA+PSAwKSB7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgaWYgKG1heFZhbHVlIDwgMCkge1xyXG4gICAgICByZXR1cm4gbWF4VmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWluVmFsdWU7XHJcbiAgfVxyXG4gIHJldHVybiBkb21haW5bMF07XHJcbn07XHJcbnZhciBnZXRTdGFja2VkRGF0YU9mSXRlbSA9IGV4cG9ydHMuZ2V0U3RhY2tlZERhdGFPZkl0ZW0gPSBmdW5jdGlvbiBnZXRTdGFja2VkRGF0YU9mSXRlbShpdGVtLCBzdGFja0dyb3Vwcykge1xyXG4gIHZhciBfaXRlbSR0eXBlMztcclxuICB2YXIgZGVmYXVsdGVkUHJvcHMgPSAoX2l0ZW0kdHlwZTMgPSBpdGVtLnR5cGUpICE9PSBudWxsICYmIF9pdGVtJHR5cGUzICE9PSB2b2lkIDAgJiYgX2l0ZW0kdHlwZTMuZGVmYXVsdFByb3BzID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBpdGVtLnR5cGUuZGVmYXVsdFByb3BzKSwgaXRlbS5wcm9wcykgOiBpdGVtLnByb3BzO1xyXG4gIHZhciBzdGFja0lkID0gZGVmYXVsdGVkUHJvcHMuc3RhY2tJZDtcclxuICBpZiAoKDAsIF9EYXRhVXRpbHMuaXNOdW1PclN0cikoc3RhY2tJZCkpIHtcclxuICAgIHZhciBncm91cCA9IHN0YWNrR3JvdXBzW3N0YWNrSWRdO1xyXG4gICAgaWYgKGdyb3VwKSB7XHJcbiAgICAgIHZhciBpdGVtSW5kZXggPSBncm91cC5pdGVtcy5pbmRleE9mKGl0ZW0pO1xyXG4gICAgICByZXR1cm4gaXRlbUluZGV4ID49IDAgPyBncm91cC5zdGFja2VkRGF0YVtpdGVtSW5kZXhdIDogbnVsbDtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn07XHJcbnZhciBnZXREb21haW5PZlNpbmdsZSA9IGZ1bmN0aW9uIGdldERvbWFpbk9mU2luZ2xlKGRhdGEpIHtcclxuICByZXR1cm4gZGF0YS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgZW50cnkpIHtcclxuICAgIHJldHVybiBbKDAsIF9taW5bXCJkZWZhdWx0XCJdKShlbnRyeS5jb25jYXQoW3Jlc3VsdFswXV0pLmZpbHRlcihfRGF0YVV0aWxzLmlzTnVtYmVyKSksICgwLCBfbWF4W1wiZGVmYXVsdFwiXSkoZW50cnkuY29uY2F0KFtyZXN1bHRbMV1dKS5maWx0ZXIoX0RhdGFVdGlscy5pc051bWJlcikpXTtcclxuICB9LCBbSW5maW5pdHksIC1JbmZpbml0eV0pO1xyXG59O1xyXG52YXIgZ2V0RG9tYWluT2ZTdGFja0dyb3VwcyA9IGV4cG9ydHMuZ2V0RG9tYWluT2ZTdGFja0dyb3VwcyA9IGZ1bmN0aW9uIGdldERvbWFpbk9mU3RhY2tHcm91cHMoc3RhY2tHcm91cHMsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XHJcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHN0YWNrR3JvdXBzKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgc3RhY2tJZCkge1xyXG4gICAgdmFyIGdyb3VwID0gc3RhY2tHcm91cHNbc3RhY2tJZF07XHJcbiAgICB2YXIgc3RhY2tlZERhdGEgPSBncm91cC5zdGFja2VkRGF0YTtcclxuICAgIHZhciBkb21haW4gPSBzdGFja2VkRGF0YS5yZWR1Y2UoZnVuY3Rpb24gKHJlcywgZW50cnkpIHtcclxuICAgICAgdmFyIHMgPSBnZXREb21haW5PZlNpbmdsZShlbnRyeS5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCArIDEpKTtcclxuICAgICAgcmV0dXJuIFtNYXRoLm1pbihyZXNbMF0sIHNbMF0pLCBNYXRoLm1heChyZXNbMV0sIHNbMV0pXTtcclxuICAgIH0sIFtJbmZpbml0eSwgLUluZmluaXR5XSk7XHJcbiAgICByZXR1cm4gW01hdGgubWluKGRvbWFpblswXSwgcmVzdWx0WzBdKSwgTWF0aC5tYXgoZG9tYWluWzFdLCByZXN1bHRbMV0pXTtcclxuICB9LCBbSW5maW5pdHksIC1JbmZpbml0eV0pLm1hcChmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICByZXR1cm4gcmVzdWx0ID09PSBJbmZpbml0eSB8fCByZXN1bHQgPT09IC1JbmZpbml0eSA/IDAgOiByZXN1bHQ7XHJcbiAgfSk7XHJcbn07XHJcbnZhciBNSU5fVkFMVUVfUkVHID0gZXhwb3J0cy5NSU5fVkFMVUVfUkVHID0gL15kYXRhTWluW1xcc10qLVtcXHNdKihbMC05XSsoWy5dezF9WzAtOV0rKXswLDF9KSQvO1xyXG52YXIgTUFYX1ZBTFVFX1JFRyA9IGV4cG9ydHMuTUFYX1ZBTFVFX1JFRyA9IC9eZGF0YU1heFtcXHNdKlxcK1tcXHNdKihbMC05XSsoWy5dezF9WzAtOV0rKXswLDF9KSQvO1xyXG52YXIgcGFyc2VTcGVjaWZpZWREb21haW4gPSBleHBvcnRzLnBhcnNlU3BlY2lmaWVkRG9tYWluID0gZnVuY3Rpb24gcGFyc2VTcGVjaWZpZWREb21haW4oc3BlY2lmaWVkRG9tYWluLCBkYXRhRG9tYWluLCBhbGxvd0RhdGFPdmVyZmxvdykge1xyXG4gIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShzcGVjaWZpZWREb21haW4pKSB7XHJcbiAgICByZXR1cm4gc3BlY2lmaWVkRG9tYWluKGRhdGFEb21haW4sIGFsbG93RGF0YU92ZXJmbG93KTtcclxuICB9XHJcbiAgaWYgKCFBcnJheS5pc0FycmF5KHNwZWNpZmllZERvbWFpbikpIHtcclxuICAgIHJldHVybiBkYXRhRG9tYWluO1xyXG4gIH1cclxuICB2YXIgZG9tYWluID0gW107XHJcblxyXG4gIC8qIGVzbGludC1kaXNhYmxlIHByZWZlci1kZXN0cnVjdHVyaW5nICovXHJcbiAgaWYgKCgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShzcGVjaWZpZWREb21haW5bMF0pKSB7XHJcbiAgICBkb21haW5bMF0gPSBhbGxvd0RhdGFPdmVyZmxvdyA/IHNwZWNpZmllZERvbWFpblswXSA6IE1hdGgubWluKHNwZWNpZmllZERvbWFpblswXSwgZGF0YURvbWFpblswXSk7XHJcbiAgfSBlbHNlIGlmIChNSU5fVkFMVUVfUkVHLnRlc3Qoc3BlY2lmaWVkRG9tYWluWzBdKSkge1xyXG4gICAgdmFyIHZhbHVlID0gK01JTl9WQUxVRV9SRUcuZXhlYyhzcGVjaWZpZWREb21haW5bMF0pWzFdO1xyXG4gICAgZG9tYWluWzBdID0gZGF0YURvbWFpblswXSAtIHZhbHVlO1xyXG4gIH0gZWxzZSBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkoc3BlY2lmaWVkRG9tYWluWzBdKSkge1xyXG4gICAgZG9tYWluWzBdID0gc3BlY2lmaWVkRG9tYWluWzBdKGRhdGFEb21haW5bMF0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBkb21haW5bMF0gPSBkYXRhRG9tYWluWzBdO1xyXG4gIH1cclxuICBpZiAoKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHNwZWNpZmllZERvbWFpblsxXSkpIHtcclxuICAgIGRvbWFpblsxXSA9IGFsbG93RGF0YU92ZXJmbG93ID8gc3BlY2lmaWVkRG9tYWluWzFdIDogTWF0aC5tYXgoc3BlY2lmaWVkRG9tYWluWzFdLCBkYXRhRG9tYWluWzFdKTtcclxuICB9IGVsc2UgaWYgKE1BWF9WQUxVRV9SRUcudGVzdChzcGVjaWZpZWREb21haW5bMV0pKSB7XHJcbiAgICB2YXIgX3ZhbHVlID0gK01BWF9WQUxVRV9SRUcuZXhlYyhzcGVjaWZpZWREb21haW5bMV0pWzFdO1xyXG4gICAgZG9tYWluWzFdID0gZGF0YURvbWFpblsxXSArIF92YWx1ZTtcclxuICB9IGVsc2UgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKHNwZWNpZmllZERvbWFpblsxXSkpIHtcclxuICAgIGRvbWFpblsxXSA9IHNwZWNpZmllZERvbWFpblsxXShkYXRhRG9tYWluWzFdKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZG9tYWluWzFdID0gZGF0YURvbWFpblsxXTtcclxuICB9XHJcbiAgLyogZXNsaW50LWVuYWJsZSBwcmVmZXItZGVzdHJ1Y3R1cmluZyAqL1xyXG5cclxuICByZXR1cm4gZG9tYWluO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSB0aGUgc2l6ZSBiZXR3ZWVuIHR3byBjYXRlZ29yeVxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IGF4aXMgIFRoZSBvcHRpb25zIG9mIGF4aXNcclxuICogQHBhcmFtICB7QXJyYXl9ICB0aWNrcyBUaGUgdGlja3Mgb2YgYXhpc1xyXG4gKiBAcGFyYW0gIHtCb29sZWFufSBpc0JhciBpZiBpdGVtcyBpbiBheGlzIGFyZSBiYXJzXHJcbiAqIEByZXR1cm4ge051bWJlcn0gU2l6ZVxyXG4gKi9cclxudmFyIGdldEJhbmRTaXplT2ZBeGlzID0gZXhwb3J0cy5nZXRCYW5kU2l6ZU9mQXhpcyA9IGZ1bmN0aW9uIGdldEJhbmRTaXplT2ZBeGlzKGF4aXMsIHRpY2tzLCBpc0Jhcikge1xyXG4gIC8vIEB0cy1leHBlY3QtZXJyb3Igd2UgbmVlZCB0byByZXRoaW5rIHNjYWxlIHR5cGVcclxuICBpZiAoYXhpcyAmJiBheGlzLnNjYWxlICYmIGF4aXMuc2NhbGUuYmFuZHdpZHRoKSB7XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHdlIG5lZWQgdG8gcmV0aGluayBzY2FsZSB0eXBlXHJcbiAgICB2YXIgYmFuZFdpZHRoID0gYXhpcy5zY2FsZS5iYW5kd2lkdGgoKTtcclxuICAgIGlmICghaXNCYXIgfHwgYmFuZFdpZHRoID4gMCkge1xyXG4gICAgICByZXR1cm4gYmFuZFdpZHRoO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoYXhpcyAmJiB0aWNrcyAmJiB0aWNrcy5sZW5ndGggPj0gMikge1xyXG4gICAgdmFyIG9yZGVyZWRUaWNrcyA9ICgwLCBfc29ydEJ5W1wiZGVmYXVsdFwiXSkodGlja3MsIGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgIHJldHVybiBvLmNvb3JkaW5hdGU7XHJcbiAgICB9KTtcclxuICAgIHZhciBiYW5kU2l6ZSA9IEluZmluaXR5O1xyXG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IG9yZGVyZWRUaWNrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICB2YXIgY3VyID0gb3JkZXJlZFRpY2tzW2ldO1xyXG4gICAgICB2YXIgcHJldiA9IG9yZGVyZWRUaWNrc1tpIC0gMV07XHJcbiAgICAgIGJhbmRTaXplID0gTWF0aC5taW4oKGN1ci5jb29yZGluYXRlIHx8IDApIC0gKHByZXYuY29vcmRpbmF0ZSB8fCAwKSwgYmFuZFNpemUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJhbmRTaXplID09PSBJbmZpbml0eSA/IDAgOiBiYW5kU2l6ZTtcclxuICB9XHJcbiAgcmV0dXJuIGlzQmFyID8gdW5kZWZpbmVkIDogMDtcclxufTtcclxuLyoqXHJcbiAqIHBhcnNlIHRoZSBkb21haW4gb2YgYSBjYXRlZ29yeSBheGlzIHdoZW4gYSBkb21haW4gaXMgc3BlY2lmaWVkXHJcbiAqIEBwYXJhbSAgIHtBcnJheX0gICAgICAgIHNwZWNpZmllZERvbWFpbiAgVGhlIGRvbWFpbiBzcGVjaWZpZWQgYnkgdXNlcnNcclxuICogQHBhcmFtICAge0FycmF5fSAgICAgICAgY2FsY3VsYXRlZERvbWFpbiBUaGUgZG9tYWluIGNhbGN1bGF0ZWQgYnkgZGF0ZUtleVxyXG4gKiBAcGFyYW0gICB7UmVhY3RFbGVtZW50fSBheGlzQ2hpbGQgICAgICAgIFRoZSBheGlzIFJlYWN0RWxlbWVudFxyXG4gKiBAcmV0dXJucyB7QXJyYXl9ICAgICAgICBkb21haW5zXHJcbiAqL1xyXG52YXIgcGFyc2VEb21haW5PZkNhdGVnb3J5QXhpcyA9IGV4cG9ydHMucGFyc2VEb21haW5PZkNhdGVnb3J5QXhpcyA9IGZ1bmN0aW9uIHBhcnNlRG9tYWluT2ZDYXRlZ29yeUF4aXMoc3BlY2lmaWVkRG9tYWluLCBjYWxjdWxhdGVkRG9tYWluLCBheGlzQ2hpbGQpIHtcclxuICBpZiAoIXNwZWNpZmllZERvbWFpbiB8fCAhc3BlY2lmaWVkRG9tYWluLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIGNhbGN1bGF0ZWREb21haW47XHJcbiAgfVxyXG4gIGlmICgoMCwgX2lzRXF1YWxbXCJkZWZhdWx0XCJdKShzcGVjaWZpZWREb21haW4sICgwLCBfZ2V0W1wiZGVmYXVsdFwiXSkoYXhpc0NoaWxkLCAndHlwZS5kZWZhdWx0UHJvcHMuZG9tYWluJykpKSB7XHJcbiAgICByZXR1cm4gY2FsY3VsYXRlZERvbWFpbjtcclxuICB9XHJcbiAgcmV0dXJuIHNwZWNpZmllZERvbWFpbjtcclxufTtcclxudmFyIGdldFRvb2x0aXBJdGVtID0gZXhwb3J0cy5nZXRUb29sdGlwSXRlbSA9IGZ1bmN0aW9uIGdldFRvb2x0aXBJdGVtKGdyYXBoaWNhbEl0ZW0sIHBheWxvYWQpIHtcclxuICB2YXIgZGVmYXVsdGVkUHJvcHMgPSBncmFwaGljYWxJdGVtLnR5cGUuZGVmYXVsdFByb3BzID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBncmFwaGljYWxJdGVtLnR5cGUuZGVmYXVsdFByb3BzKSwgZ3JhcGhpY2FsSXRlbS5wcm9wcykgOiBncmFwaGljYWxJdGVtLnByb3BzO1xyXG4gIHZhciBkYXRhS2V5ID0gZGVmYXVsdGVkUHJvcHMuZGF0YUtleSxcclxuICAgIG5hbWUgPSBkZWZhdWx0ZWRQcm9wcy5uYW1lLFxyXG4gICAgdW5pdCA9IGRlZmF1bHRlZFByb3BzLnVuaXQsXHJcbiAgICBmb3JtYXR0ZXIgPSBkZWZhdWx0ZWRQcm9wcy5mb3JtYXR0ZXIsXHJcbiAgICB0b29sdGlwVHlwZSA9IGRlZmF1bHRlZFByb3BzLnRvb2x0aXBUeXBlLFxyXG4gICAgY2hhcnRUeXBlID0gZGVmYXVsdGVkUHJvcHMuY2hhcnRUeXBlLFxyXG4gICAgaGlkZSA9IGRlZmF1bHRlZFByb3BzLmhpZGU7XHJcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShncmFwaGljYWxJdGVtLCBmYWxzZSkpLCB7fSwge1xyXG4gICAgZGF0YUtleTogZGF0YUtleSxcclxuICAgIHVuaXQ6IHVuaXQsXHJcbiAgICBmb3JtYXR0ZXI6IGZvcm1hdHRlcixcclxuICAgIG5hbWU6IG5hbWUgfHwgZGF0YUtleSxcclxuICAgIGNvbG9yOiBnZXRNYWluQ29sb3JPZkdyYXBoaWNJdGVtKGdyYXBoaWNhbEl0ZW0pLFxyXG4gICAgdmFsdWU6IGdldFZhbHVlQnlEYXRhS2V5KHBheWxvYWQsIGRhdGFLZXkpLFxyXG4gICAgdHlwZTogdG9vbHRpcFR5cGUsXHJcbiAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXHJcbiAgICBoaWRlOiBoaWRlXHJcbiAgfSk7XHJcbn07Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0Q2F0ZUNvb3JkaW5hdGVPZkJhciIsImdldEJhc2VWYWx1ZU9mQmFyIiwiZ2V0QmFyU2l6ZUxpc3QiLCJnZXRCYXJQb3NpdGlvbiIsImdldEJhbmRTaXplT2ZBeGlzIiwiZmluZFBvc2l0aW9uT2ZCYXIiLCJjb21iaW5lRXZlbnRIYW5kbGVycyIsImNoZWNrRG9tYWluT2ZTY2FsZSIsImNhbGN1bGF0ZUFjdGl2ZVRpY2tJbmRleCIsImFwcGVuZE9mZnNldE9mTGVnZW5kIiwiTUlOX1ZBTFVFX1JFRyIsIk1BWF9WQUxVRV9SRUciLCJnZXRDYXRlQ29vcmRpbmF0ZU9mTGluZSIsImdldENvb3JkaW5hdGVzT2ZHcmlkIiwiZ2V0RG9tYWluT2ZEYXRhQnlLZXkiLCJnZXREb21haW5PZlN0YWNrR3JvdXBzIiwiZ2V0RG9tYWluT2ZJdGVtc1dpdGhTYW1lQXhpcyIsImdldERvbWFpbk9mRXJyb3JCYXJzIiwiZW51bWVyYWJsZSIsImdldCIsIl9nZXRMZWdlbmRQcm9wcyIsImdldExlZ2VuZFByb3BzIiwiZ2V0VG9vbHRpcEl0ZW0iLCJnZXRUaWNrc09mU2NhbGUiLCJnZXRUaWNrc09mQXhpcyIsImdldFN0YWNrZWREYXRhT2ZJdGVtIiwiZ2V0U3RhY2tlZERhdGEiLCJnZXRTdGFja0dyb3Vwc0J5QXhpc0lkIiwiZ2V0TWFpbkNvbG9yT2ZHcmFwaGljSXRlbSIsImdldFZhbHVlQnlEYXRhS2V5IiwidHJ1bmNhdGVCeURvbWFpbiIsInBhcnNlU3BlY2lmaWVkRG9tYWluIiwicGFyc2VTY2FsZSIsInBhcnNlRXJyb3JCYXJzT2ZBeGlzIiwicGFyc2VEb21haW5PZkNhdGVnb3J5QXhpcyIsIm9mZnNldFNpZ24iLCJvZmZzZXRQb3NpdGl2ZSIsImlzQ2F0ZWdvcmljYWxBeGlzIiwiZDNTY2FsZXMiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfZDNTaGFwZSIsIl9tYXgiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX21pbiIsIl9pc05pbCIsIl9pc0Z1bmN0aW9uIiwiX2lzU3RyaW5nIiwiX2dldCIsIl9mbGF0TWFwIiwiX2lzTmFOIiwiX3VwcGVyRmlyc3QiLCJfaXNFcXVhbCIsIl9zb3J0QnkiLCJfcmVjaGFydHNTY2FsZSIsIl9FcnJvckJhciIsIl9EYXRhVXRpbHMiLCJfUmVhY3RVdGlscyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX3R5cGVvZiIsImhhcyIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiVHlwZUVycm9yIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJ0b1N0cmluZyIsInNsaWNlIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJpdGVyIiwiaXNBcnJheSIsImxlbiIsImxlbmd0aCIsImFycjIiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJrZXkiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJkYXRhS2V5IiwiZGVmYXVsdFZhbHVlIiwiaXNOdW1PclN0ciIsImRhdGEiLCJ0eXBlIiwiZmlsdGVyTmlsIiwiZmxhdHRlbkRhdGEiLCJlbnRyeSIsImRvbWFpbiIsImlzTnVtYmVyIiwicGFyc2VGbG9hdCIsIkluZmluaXR5IiwidmFsaWRhdGVEYXRhIiwibWFwIiwiRGF0ZSIsImNvb3JkaW5hdGUiLCJfdGlja3MkbGVuZ3RoIiwidGlja3MiLCJ1bmRlZmluZWQiLCJ1bnNvcnRlZFRpY2tzIiwiYXhpcyIsImluZGV4IiwiYXhpc1R5cGUiLCJNYXRoIiwiYWJzIiwicmFuZ2UiLCJiZWZvcmUiLCJjdXIiLCJhZnRlciIsInNhbWVEaXJlY3Rpb25Db29yZCIsIm1hdGhTaWduIiwiZGlmZkludGVydmFsIiwiY3VySW5SYW5nZSIsIm1pbiIsIm1heCIsImFmdGVySW5SYW5nZSIsInNhbWVJbnRlcnZhbCIsIm1pblZhbHVlIiwibWF4VmFsdWUiLCJfaSIsIml0ZW0iLCJfaXRlbSR0eXBlIiwiX3JlZiIsImRpc3BsYXlOYW1lIiwiZGVmYXVsdGVkUHJvcHMiLCJkZWZhdWx0UHJvcHMiLCJwcm9wcyIsInN0cm9rZSIsImZpbGwiLCJyZXN1bHQiLCJfcmVmMiIsImdsb2JhbFNpemUiLCJiYXJTaXplIiwidG90YWxTaXplIiwiX3JlZjIkc3RhY2tHcm91cHMiLCJzdGFja0dyb3VwcyIsIm51bWVyaWNBeGlzSWRzIiwic2dzIiwic3RhY2tJZHMiLCJqIiwic0xlbiIsIl9zZ3Mkc3RhY2tJZHMkaiIsIml0ZW1zIiwiY2F0ZUF4aXNJZCIsImJhckl0ZW1zIiwiZ2V0RGlzcGxheU5hbWUiLCJpbmRleE9mIiwiYmFySXRlbURlZmF1bHRQcm9wcyIsImJhckl0ZW1Qcm9wcyIsInNlbGZTaXplIiwiY2F0ZUlkIiwic3RhY2tMaXN0IiwiZ2V0UGVyY2VudFZhbHVlIiwiX3JlZjMiLCJiYXJHYXAiLCJiYXJDYXRlZ29yeUdhcCIsImJhbmRTaXplIiwiX3JlZjMkc2l6ZUxpc3QiLCJzaXplTGlzdCIsIm1heEJhclNpemUiLCJyZWFsQmFyR2FwIiwiaW5pdGlhbFZhbHVlIiwidXNlRnVsbCIsImZ1bGxCYXJTaXplIiwic3VtIiwicmVkdWNlIiwicmVzIiwib2Zmc2V0IiwicHJldiIsInNpemUiLCJuZXdQb3NpdGlvbiIsInBvc2l0aW9uIiwibmV3UmVzIiwiY29uY2F0IiwiX29mZnNldCIsIm9yaWdpbmFsU2l6ZSIsIl91bnVzZWQiLCJsZWdlbmRCb3giLCJjaGlsZHJlbiIsIndpZHRoIiwibWFyZ2luIiwibGVnZW5kV2lkdGgiLCJsZWZ0IiwicmlnaHQiLCJsZWdlbmRQcm9wcyIsIl9yZWY0IiwiYm94V2lkdGgiLCJib3hIZWlnaHQiLCJoZWlnaHQiLCJhbGlnbiIsInZlcnRpY2FsQWxpZ24iLCJsYXlvdXQiLCJpc0Vycm9yQmFyUmVsZXZhbnRGb3JBeGlzIiwiZGlyZWN0aW9uIiwiZXJyb3JCYXJzIiwiZmluZEFsbEJ5VHlwZSIsIkVycm9yQmFyIiwiZXJyb3JCYXJDaGlsZCIsImVudHJ5VmFsdWUiLCJtYWluVmFsdWUiLCJlcnJvckRvbWFpbiIsInByZXZFcnJvckFyciIsImsiLCJlcnJvclZhbHVlIiwibG93ZXJWYWx1ZSIsInVwcGVyVmFsdWUiLCJkb21haW5zIiwidGFnIiwic3luY1dpdGhUaWNrcyIsImhhc01pbiIsImhhc01heCIsInZhbHVlcyIsImlzR3JpZCIsImlzQWxsIiwic2NhbGUiLCJkdXBsaWNhdGVEb21haW4iLCJvZmZzZXRGb3JCYW5kIiwicmVhbFNjYWxlVHlwZSIsImJhbmR3aWR0aCIsIm5pY2VUaWNrcyIsInNjYWxlQ29udGVudCIsInJvdyIsImlzQ2F0ZWdvcmljYWwiLCJjYXRlZ29yaWNhbERvbWFpbiIsInRpY2tDb3VudCIsImhhbmRsZXJXZWFrTWFwIiwiZGVmYXVsdEhhbmRsZXIiLCJjaGlsZEhhbmRsZXIiLCJjaGlsZFdlYWtNYXAiLCJjb21iaW5lSGFuZGxlciIsImNoYXJ0VHlwZSIsImhhc0JhciIsInNjYWxlQmFuZCIsInNjYWxlTGluZWFyIiwic2NhbGVQb2ludCIsIkVQUyIsImZpcnN0IiwibGFzdCIsImJhclBvc2l0aW9uIiwiY2hpbGQiLCJzZXJpZXMiLCJtIiwicG9zaXRpdmUiLCJuZWdhdGl2ZSIsIlNUQUNLX09GRlNFVF9NQVAiLCJzaWduIiwiZXhwYW5kIiwic3RhY2tPZmZzZXRFeHBhbmQiLCJub25lIiwic3RhY2tPZmZzZXROb25lIiwic2lsaG91ZXR0ZSIsInN0YWNrT2Zmc2V0U2lsaG91ZXR0ZSIsIndpZ2dsZSIsInN0YWNrT2Zmc2V0V2lnZ2xlIiwic3RhY2tJdGVtcyIsIm9mZnNldFR5cGUiLCJkYXRhS2V5cyIsIm9mZnNldEFjY2Vzc29yIiwic3RhY2siLCJkIiwib3JkZXIiLCJzdGFja09yZGVyTm9uZSIsIl9pdGVtcyIsIm51bWVyaWNBeGlzSWQiLCJyZXZlcnNlU3RhY2tPcmRlciIsInJldmVyc2UiLCJwYXJlbnRTdGFja0dyb3Vwc0luaXRpYWxWYWx1ZSIsIl9pdGVtJHR5cGUyIiwic3RhY2tJZCIsImhpZGUiLCJheGlzSWQiLCJwYXJlbnRHcm91cCIsImhhc1N0YWNrIiwiY2hpbGRHcm91cCIsInVuaXF1ZUlkIiwiYXhpc1N0YWNrR3JvdXBzSW5pdGlhbFZhbHVlIiwiZ3JvdXAiLCJzdGFja0dyb3Vwc0luaXRpYWxWYWx1ZSIsImciLCJzdGFja2VkRGF0YSIsIm9wdHMiLCJvcmlnaW5hbERvbWFpbiIsImFsbG93RGVjaW1hbHMiLCJzY2FsZVR5cGUiLCJ0aWNrVmFsdWVzIiwiZ2V0TmljZVRpY2tWYWx1ZXMiLCJfZG9tYWluIiwiX3RpY2tWYWx1ZXMiLCJnZXRUaWNrVmFsdWVzRml4ZWREb21haW4iLCJfcmVmNSIsImFsbG93RHVwbGljYXRlZENhdGVnb3J5IiwibWF0Y2hlZFRpY2siLCJmaW5kRW50cnlJbkFycmF5IiwiX3JlZjYiLCJfcmVmNyIsIm51bWVyaWNBeGlzIiwiX2l0ZW0kdHlwZTMiLCJpdGVtSW5kZXgiLCJnZXREb21haW5PZlNpbmdsZSIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsInMiLCJzcGVjaWZpZWREb21haW4iLCJkYXRhRG9tYWluIiwiYWxsb3dEYXRhT3ZlcmZsb3ciLCJleGVjIiwiX3ZhbHVlIiwiaXNCYXIiLCJiYW5kV2lkdGgiLCJvcmRlcmVkVGlja3MiLCJjYWxjdWxhdGVkRG9tYWluIiwiYXhpc0NoaWxkIiwiZ3JhcGhpY2FsSXRlbSIsInBheWxvYWQiLCJ1bml0IiwiZm9ybWF0dGVyIiwidG9vbHRpcFR5cGUiLCJmaWx0ZXJQcm9wcyIsImNvbG9yIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/Constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/recharts/lib/util/Constants.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.COLOR_PANEL = void 0;\nvar COLOR_PANEL = exports.COLOR_PANEL = [\n    '#1890FF',\n    '#66B5FF',\n    '#41D9C7',\n    '#2FC25B',\n    '#6EDB8F',\n    '#9AE65C',\n    '#FACC14',\n    '#E6965C',\n    '#57AD71',\n    '#223273',\n    '#738AE6',\n    '#7564CC',\n    '#8543E0',\n    '#A877ED',\n    '#5C8EE6',\n    '#13C2C2',\n    '#70E0E0',\n    '#5CA3E6',\n    '#3436C7',\n    '#8082FF',\n    '#DD81E6',\n    '#F04864',\n    '#FA7D92',\n    '#D598D9'\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9Db25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELG1CQUFtQixHQUFHLEtBQUs7QUFDM0IsSUFBSUUsY0FBY0YsbUJBQW1CLEdBQUc7SUFBQztJQUFXO0lBQVc7SUFBVztJQUFXO0lBQVc7SUFBVztJQUFXO0lBQVc7SUFBVztJQUFXO0lBQVc7SUFBVztJQUFXO0lBQVc7SUFBVztJQUFXO0lBQVc7SUFBVztJQUFXO0lBQVc7SUFBVztJQUFXO0lBQVc7Q0FBVSIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcdXRpbFxcQ29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuQ09MT1JfUEFORUwgPSB2b2lkIDA7XHJcbnZhciBDT0xPUl9QQU5FTCA9IGV4cG9ydHMuQ09MT1JfUEFORUwgPSBbJyMxODkwRkYnLCAnIzY2QjVGRicsICcjNDFEOUM3JywgJyMyRkMyNUInLCAnIzZFREI4RicsICcjOUFFNjVDJywgJyNGQUNDMTQnLCAnI0U2OTY1QycsICcjNTdBRDcxJywgJyMyMjMyNzMnLCAnIzczOEFFNicsICcjNzU2NENDJywgJyM4NTQzRTAnLCAnI0E4NzdFRCcsICcjNUM4RUU2JywgJyMxM0MyQzInLCAnIzcwRTBFMCcsICcjNUNBM0U2JywgJyMzNDM2QzcnLCAnIzgwODJGRicsICcjREQ4MUU2JywgJyNGMDQ4NjQnLCAnI0ZBN0Q5MicsICcjRDU5OEQ5J107Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ09MT1JfUEFORUwiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/Constants.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/CssPrefixUtils.js":
/*!**********************************************************!*\
  !*** ./node_modules/recharts/lib/util/CssPrefixUtils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.generatePrefixStyle = void 0;\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar PREFIX_LIST = [\n    'Webkit',\n    'Moz',\n    'O',\n    'ms'\n];\nvar generatePrefixStyle = exports.generatePrefixStyle = function generatePrefixStyle(name, value) {\n    if (!name) {\n        return null;\n    }\n    var camelName = name.replace(/(\\w)/, function(v) {\n        return v.toUpperCase();\n    });\n    var result = PREFIX_LIST.reduce(function(res, entry) {\n        return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, entry + camelName, value));\n    }, {});\n    result[name] = value;\n    return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9Dc3NQcmVmaXhVdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsMkJBQTJCLEdBQUcsS0FBSztBQUNuQyxTQUFTRyxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRSxXQUFXLEtBQUtDLFVBQVVELE1BQU1DLE9BQU9FLFNBQVMsR0FBRyxXQUFXLE9BQU9IO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSSxRQUFRQyxDQUFDLEVBQUVDLENBQUM7SUFBSSxJQUFJQyxJQUFJYixPQUFPYyxJQUFJLENBQUNIO0lBQUksSUFBSVgsT0FBT2UscUJBQXFCLEVBQUU7UUFBRSxJQUFJVCxJQUFJTixPQUFPZSxxQkFBcUIsQ0FBQ0o7UUFBSUMsS0FBTU4sQ0FBQUEsSUFBSUEsRUFBRVUsTUFBTSxDQUFDLFNBQVVKLENBQUM7WUFBSSxPQUFPWixPQUFPaUIsd0JBQXdCLENBQUNOLEdBQUdDLEdBQUdNLFVBQVU7UUFBRSxFQUFDLEdBQUlMLEVBQUVNLElBQUksQ0FBQ0MsS0FBSyxDQUFDUCxHQUFHUDtJQUFJO0lBQUUsT0FBT087QUFBRztBQUM5UCxTQUFTUSxjQUFjVixDQUFDO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlVLFVBQVVDLE1BQU0sRUFBRVgsSUFBSztRQUFFLElBQUlDLElBQUksUUFBUVMsU0FBUyxDQUFDVixFQUFFLEdBQUdVLFNBQVMsQ0FBQ1YsRUFBRSxHQUFHLENBQUM7UUFBR0EsSUFBSSxJQUFJRixRQUFRVixPQUFPYSxJQUFJLENBQUMsR0FBR1csT0FBTyxDQUFDLFNBQVVaLENBQUM7WUFBSWEsZ0JBQWdCZCxHQUFHQyxHQUFHQyxDQUFDLENBQUNELEVBQUU7UUFBRyxLQUFLWixPQUFPMEIseUJBQXlCLEdBQUcxQixPQUFPMkIsZ0JBQWdCLENBQUNoQixHQUFHWCxPQUFPMEIseUJBQXlCLENBQUNiLE1BQU1ILFFBQVFWLE9BQU9hLElBQUlXLE9BQU8sQ0FBQyxTQUFVWixDQUFDO1lBQUlaLE9BQU9DLGNBQWMsQ0FBQ1UsR0FBR0MsR0FBR1osT0FBT2lCLHdCQUF3QixDQUFDSixHQUFHRDtRQUFLO0lBQUk7SUFBRSxPQUFPRDtBQUFHO0FBQ3RiLFNBQVNjLGdCQUFnQkcsR0FBRyxFQUFFQyxHQUFHLEVBQUUxQixLQUFLO0lBQUkwQixNQUFNQyxlQUFlRDtJQUFNLElBQUlBLE9BQU9ELEtBQUs7UUFBRTVCLE9BQU9DLGNBQWMsQ0FBQzJCLEtBQUtDLEtBQUs7WUFBRTFCLE9BQU9BO1lBQU9lLFlBQVk7WUFBTWEsY0FBYztZQUFNQyxVQUFVO1FBQUs7SUFBSSxPQUFPO1FBQUVKLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHMUI7SUFBTztJQUFFLE9BQU95QjtBQUFLO0FBQzNPLFNBQVNFLGVBQWVqQixDQUFDO0lBQUksSUFBSW9CLElBQUlDLGFBQWFyQixHQUFHO0lBQVcsT0FBTyxZQUFZUixRQUFRNEIsS0FBS0EsSUFBSUEsSUFBSTtBQUFJO0FBQzVHLFNBQVNDLGFBQWFyQixDQUFDLEVBQUVELENBQUM7SUFBSSxJQUFJLFlBQVlQLFFBQVFRLE1BQU0sQ0FBQ0EsR0FBRyxPQUFPQTtJQUFHLElBQUlGLElBQUlFLENBQUMsQ0FBQ04sT0FBTzRCLFdBQVcsQ0FBQztJQUFFLElBQUksS0FBSyxNQUFNeEIsR0FBRztRQUFFLElBQUlzQixJQUFJdEIsRUFBRXlCLElBQUksQ0FBQ3ZCLEdBQUdELEtBQUs7UUFBWSxJQUFJLFlBQVlQLFFBQVE0QixJQUFJLE9BQU9BO1FBQUcsTUFBTSxJQUFJSSxVQUFVO0lBQWlEO0lBQUUsT0FBTyxDQUFDLGFBQWF6QixJQUFJMEIsU0FBU0MsTUFBSyxFQUFHMUI7QUFBSTtBQUMzVCxJQUFJMkIsY0FBYztJQUFDO0lBQVU7SUFBTztJQUFLO0NBQUs7QUFDOUMsSUFBSXBDLHNCQUFzQkYsMkJBQTJCLEdBQUcsU0FBU0Usb0JBQW9CcUMsSUFBSSxFQUFFdEMsS0FBSztJQUM5RixJQUFJLENBQUNzQyxNQUFNO1FBQ1QsT0FBTztJQUNUO0lBQ0EsSUFBSUMsWUFBWUQsS0FBS0UsT0FBTyxDQUFDLFFBQVEsU0FBVUMsQ0FBQztRQUM5QyxPQUFPQSxFQUFFQyxXQUFXO0lBQ3RCO0lBQ0EsSUFBSUMsU0FBU04sWUFBWU8sTUFBTSxDQUFDLFNBQVVDLEdBQUcsRUFBRUMsS0FBSztRQUNsRCxPQUFPNUIsY0FBY0EsY0FBYyxDQUFDLEdBQUcyQixNQUFNLENBQUMsR0FBR3ZCLGdCQUFnQixDQUFDLEdBQUd3QixRQUFRUCxXQUFXdkM7SUFDMUYsR0FBRyxDQUFDO0lBQ0oyQyxNQUFNLENBQUNMLEtBQUssR0FBR3RDO0lBQ2YsT0FBTzJDO0FBQ1QiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXHV0aWxcXENzc1ByZWZpeFV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZ2VuZXJhdGVQcmVmaXhTdHlsZSA9IHZvaWQgMDtcclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxyXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XHJcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XHJcbnZhciBQUkVGSVhfTElTVCA9IFsnV2Via2l0JywgJ01veicsICdPJywgJ21zJ107XHJcbnZhciBnZW5lcmF0ZVByZWZpeFN0eWxlID0gZXhwb3J0cy5nZW5lcmF0ZVByZWZpeFN0eWxlID0gZnVuY3Rpb24gZ2VuZXJhdGVQcmVmaXhTdHlsZShuYW1lLCB2YWx1ZSkge1xyXG4gIGlmICghbmFtZSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHZhciBjYW1lbE5hbWUgPSBuYW1lLnJlcGxhY2UoLyhcXHcpLywgZnVuY3Rpb24gKHYpIHtcclxuICAgIHJldHVybiB2LnRvVXBwZXJDYXNlKCk7XHJcbiAgfSk7XHJcbiAgdmFyIHJlc3VsdCA9IFBSRUZJWF9MSVNULnJlZHVjZShmdW5jdGlvbiAocmVzLCBlbnRyeSkge1xyXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmVzKSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwgZW50cnkgKyBjYW1lbE5hbWUsIHZhbHVlKSk7XHJcbiAgfSwge30pO1xyXG4gIHJlc3VsdFtuYW1lXSA9IHZhbHVlO1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2VuZXJhdGVQcmVmaXhTdHlsZSIsIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJvd25LZXlzIiwiZSIsInIiLCJ0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwib2JqIiwia2V5IiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImkiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJQUkVGSVhfTElTVCIsIm5hbWUiLCJjYW1lbE5hbWUiLCJyZXBsYWNlIiwidiIsInRvVXBwZXJDYXNlIiwicmVzdWx0IiwicmVkdWNlIiwicmVzIiwiZW50cnkiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/CssPrefixUtils.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/DOMUtils.js":
/*!****************************************************!*\
  !*** ./node_modules/recharts/lib/util/DOMUtils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getStyleString = exports.getStringSize = exports.getOffset = void 0;\nvar _Global = __webpack_require__(/*! ./Global */ \"(pages-dir-node)/./node_modules/recharts/lib/util/Global.js\");\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nvar stringCache = {\n    widthCache: {},\n    cacheCount: 0\n};\nvar MAX_CACHE_NUM = 2000;\nvar SPAN_STYLE = {\n    position: 'absolute',\n    top: '-20000px',\n    left: 0,\n    padding: 0,\n    margin: 0,\n    border: 'none',\n    whiteSpace: 'pre'\n};\nvar STYLE_LIST = [\n    'minWidth',\n    'maxWidth',\n    'width',\n    'minHeight',\n    'maxHeight',\n    'height',\n    'top',\n    'left',\n    'fontSize',\n    'lineHeight',\n    'padding',\n    'margin',\n    'paddingLeft',\n    'paddingRight',\n    'paddingTop',\n    'paddingBottom',\n    'marginLeft',\n    'marginRight',\n    'marginTop',\n    'marginBottom'\n];\nvar MEASUREMENT_SPAN_ID = 'recharts_measurement_span';\nfunction autoCompleteStyle(name, value) {\n    if (STYLE_LIST.indexOf(name) >= 0 && value === +value) {\n        return \"\".concat(value, \"px\");\n    }\n    return value;\n}\nfunction camelToMiddleLine(text) {\n    var strs = text.split('');\n    var formatStrs = strs.reduce(function(result, entry) {\n        if (entry === entry.toUpperCase()) {\n            return [].concat(_toConsumableArray(result), [\n                '-',\n                entry.toLowerCase()\n            ]);\n        }\n        return [].concat(_toConsumableArray(result), [\n            entry\n        ]);\n    }, []);\n    return formatStrs.join('');\n}\nvar getStyleString = exports.getStyleString = function getStyleString(style) {\n    return Object.keys(style).reduce(function(result, s) {\n        return \"\".concat(result).concat(camelToMiddleLine(s), \":\").concat(autoCompleteStyle(s, style[s]), \";\");\n    }, '');\n};\nfunction removeInvalidKeys(obj) {\n    var copyObj = _objectSpread({}, obj);\n    Object.keys(copyObj).forEach(function(key) {\n        if (!copyObj[key]) {\n            delete copyObj[key];\n        }\n    });\n    return copyObj;\n}\nvar getStringSize = exports.getStringSize = function getStringSize(text) {\n    var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (text === undefined || text === null || _Global.Global.isSsr) {\n        return {\n            width: 0,\n            height: 0\n        };\n    }\n    var copyStyle = removeInvalidKeys(style);\n    var cacheKey = JSON.stringify({\n        text: text,\n        copyStyle: copyStyle\n    });\n    if (stringCache.widthCache[cacheKey]) {\n        return stringCache.widthCache[cacheKey];\n    }\n    try {\n        var measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);\n        if (!measurementSpan) {\n            measurementSpan = document.createElement('span');\n            measurementSpan.setAttribute('id', MEASUREMENT_SPAN_ID);\n            measurementSpan.setAttribute('aria-hidden', 'true');\n            document.body.appendChild(measurementSpan);\n        }\n        // Need to use CSS Object Model (CSSOM) to be able to comply with Content Security Policy (CSP)\n        // https://en.wikipedia.org/wiki/Content_Security_Policy\n        var measurementSpanStyle = _objectSpread(_objectSpread({}, SPAN_STYLE), copyStyle);\n        Object.assign(measurementSpan.style, measurementSpanStyle);\n        measurementSpan.textContent = \"\".concat(text);\n        var rect = measurementSpan.getBoundingClientRect();\n        var result = {\n            width: rect.width,\n            height: rect.height\n        };\n        stringCache.widthCache[cacheKey] = result;\n        if (++stringCache.cacheCount > MAX_CACHE_NUM) {\n            stringCache.cacheCount = 0;\n            stringCache.widthCache = {};\n        }\n        return result;\n    } catch (e) {\n        return {\n            width: 0,\n            height: 0\n        };\n    }\n};\nvar getOffset = exports.getOffset = function getOffset(rect) {\n    return {\n        top: rect.top + window.scrollY - document.documentElement.clientTop,\n        left: rect.left + window.scrollX - document.documentElement.clientLeft\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9ET01VdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFLFdBQVcsS0FBS0MsVUFBVUQsTUFBTUMsT0FBT0UsU0FBUyxHQUFHLFdBQVcsT0FBT0g7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdUSSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsc0JBQXNCLEdBQUdBLHFCQUFxQixHQUFHQSxpQkFBaUIsR0FBRyxLQUFLO0FBQzFFLElBQUlLLFVBQVVDLG1CQUFPQSxDQUFDLDZFQUFVO0FBQ2hDLFNBQVNDLFFBQVFDLENBQUMsRUFBRUMsQ0FBQztJQUFJLElBQUlDLElBQUlaLE9BQU9hLElBQUksQ0FBQ0g7SUFBSSxJQUFJVixPQUFPYyxxQkFBcUIsRUFBRTtRQUFFLElBQUlsQixJQUFJSSxPQUFPYyxxQkFBcUIsQ0FBQ0o7UUFBSUMsS0FBTWYsQ0FBQUEsSUFBSUEsRUFBRW1CLE1BQU0sQ0FBQyxTQUFVSixDQUFDO1lBQUksT0FBT1gsT0FBT2dCLHdCQUF3QixDQUFDTixHQUFHQyxHQUFHTSxVQUFVO1FBQUUsRUFBQyxHQUFJTCxFQUFFTSxJQUFJLENBQUNDLEtBQUssQ0FBQ1AsR0FBR2hCO0lBQUk7SUFBRSxPQUFPZ0I7QUFBRztBQUM5UCxTQUFTUSxjQUFjVixDQUFDO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlVLFVBQVVDLE1BQU0sRUFBRVgsSUFBSztRQUFFLElBQUlDLElBQUksUUFBUVMsU0FBUyxDQUFDVixFQUFFLEdBQUdV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S0FBSzVDLElBQUksR0FBRzhDLE9BQU9JLE9BQU8sR0FBR2YsU0FBU2EsZUFBZSxDQUFDRyxVQUFVO0lBQ3hFO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXHV0aWxcXERPTVV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5nZXRTdHlsZVN0cmluZyA9IGV4cG9ydHMuZ2V0U3RyaW5nU2l6ZSA9IGV4cG9ydHMuZ2V0T2Zmc2V0ID0gdm9pZCAwO1xyXG52YXIgX0dsb2JhbCA9IHJlcXVpcmUoXCIuL0dsb2JhbFwiKTtcclxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cclxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxyXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxyXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cclxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxyXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cclxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XHJcbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cclxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cclxudmFyIHN0cmluZ0NhY2hlID0ge1xyXG4gIHdpZHRoQ2FjaGU6IHt9LFxyXG4gIGNhY2hlQ291bnQ6IDBcclxufTtcclxudmFyIE1BWF9DQUNIRV9OVU0gPSAyMDAwO1xyXG52YXIgU1BBTl9TVFlMRSA9IHtcclxuICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICB0b3A6ICctMjAwMDBweCcsXHJcbiAgbGVmdDogMCxcclxuICBwYWRkaW5nOiAwLFxyXG4gIG1hcmdpbjogMCxcclxuICBib3JkZXI6ICdub25lJyxcclxuICB3aGl0ZVNwYWNlOiAncHJlJ1xyXG59O1xyXG52YXIgU1RZTEVfTElTVCA9IFsnbWluV2lkdGgnLCAnbWF4V2lkdGgnLCAnd2lkdGgnLCAnbWluSGVpZ2h0JywgJ21heEhlaWdodCcsICdoZWlnaHQnLCAndG9wJywgJ2xlZnQnLCAnZm9udFNpemUnLCAnbGluZUhlaWdodCcsICdwYWRkaW5nJywgJ21hcmdpbicsICdwYWRkaW5nTGVmdCcsICdwYWRkaW5nUmlnaHQnLCAncGFkZGluZ1RvcCcsICdwYWRkaW5nQm90dG9tJywgJ21hcmdpbkxlZnQnLCAnbWFyZ2luUmlnaHQnLCAnbWFyZ2luVG9wJywgJ21hcmdpbkJvdHRvbSddO1xyXG52YXIgTUVBU1VSRU1FTlRfU1BBTl9JRCA9ICdyZWNoYXJ0c19tZWFzdXJlbWVudF9zcGFuJztcclxuZnVuY3Rpb24gYXV0b0NvbXBsZXRlU3R5bGUobmFtZSwgdmFsdWUpIHtcclxuICBpZiAoU1RZTEVfTElTVC5pbmRleE9mKG5hbWUpID49IDAgJiYgdmFsdWUgPT09ICt2YWx1ZSkge1xyXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHZhbHVlLCBcInB4XCIpO1xyXG4gIH1cclxuICByZXR1cm4gdmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gY2FtZWxUb01pZGRsZUxpbmUodGV4dCkge1xyXG4gIHZhciBzdHJzID0gdGV4dC5zcGxpdCgnJyk7XHJcbiAgdmFyIGZvcm1hdFN0cnMgPSBzdHJzLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBlbnRyeSkge1xyXG4gICAgaWYgKGVudHJ5ID09PSBlbnRyeS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHJlc3VsdCksIFsnLScsIGVudHJ5LnRvTG93ZXJDYXNlKCldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHJlc3VsdCksIFtlbnRyeV0pO1xyXG4gIH0sIFtdKTtcclxuICByZXR1cm4gZm9ybWF0U3Rycy5qb2luKCcnKTtcclxufVxyXG52YXIgZ2V0U3R5bGVTdHJpbmcgPSBleHBvcnRzLmdldFN0eWxlU3RyaW5nID0gZnVuY3Rpb24gZ2V0U3R5bGVTdHJpbmcoc3R5bGUpIHtcclxuICByZXR1cm4gT2JqZWN0LmtleXMoc3R5bGUpLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBzKSB7XHJcbiAgICByZXR1cm4gXCJcIi5jb25jYXQocmVzdWx0KS5jb25jYXQoY2FtZWxUb01pZGRsZUxpbmUocyksIFwiOlwiKS5jb25jYXQoYXV0b0NvbXBsZXRlU3R5bGUocywgc3R5bGVbc10pLCBcIjtcIik7XHJcbiAgfSwgJycpO1xyXG59O1xyXG5mdW5jdGlvbiByZW1vdmVJbnZhbGlkS2V5cyhvYmopIHtcclxuICB2YXIgY29weU9iaiA9IF9vYmplY3RTcHJlYWQoe30sIG9iaik7XHJcbiAgT2JqZWN0LmtleXMoY29weU9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICBpZiAoIWNvcHlPYmpba2V5XSkge1xyXG4gICAgICBkZWxldGUgY29weU9ialtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBjb3B5T2JqO1xyXG59XHJcbnZhciBnZXRTdHJpbmdTaXplID0gZXhwb3J0cy5nZXRTdHJpbmdTaXplID0gZnVuY3Rpb24gZ2V0U3RyaW5nU2l6ZSh0ZXh0KSB7XHJcbiAgdmFyIHN0eWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcclxuICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkIHx8IHRleHQgPT09IG51bGwgfHwgX0dsb2JhbC5HbG9iYWwuaXNTc3IpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHdpZHRoOiAwLFxyXG4gICAgICBoZWlnaHQ6IDBcclxuICAgIH07XHJcbiAgfVxyXG4gIHZhciBjb3B5U3R5bGUgPSByZW1vdmVJbnZhbGlkS2V5cyhzdHlsZSk7XHJcbiAgdmFyIGNhY2hlS2V5ID0gSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgdGV4dDogdGV4dCxcclxuICAgIGNvcHlTdHlsZTogY29weVN0eWxlXHJcbiAgfSk7XHJcbiAgaWYgKHN0cmluZ0NhY2hlLndpZHRoQ2FjaGVbY2FjaGVLZXldKSB7XHJcbiAgICByZXR1cm4gc3RyaW5nQ2FjaGUud2lkdGhDYWNoZVtjYWNoZUtleV07XHJcbiAgfVxyXG4gIHRyeSB7XHJcbiAgICB2YXIgbWVhc3VyZW1lbnRTcGFuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoTUVBU1VSRU1FTlRfU1BBTl9JRCk7XHJcbiAgICBpZiAoIW1lYXN1cmVtZW50U3Bhbikge1xyXG4gICAgICBtZWFzdXJlbWVudFNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICAgIG1lYXN1cmVtZW50U3Bhbi5zZXRBdHRyaWJ1dGUoJ2lkJywgTUVBU1VSRU1FTlRfU1BBTl9JRCk7XHJcbiAgICAgIG1lYXN1cmVtZW50U3Bhbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcclxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtZWFzdXJlbWVudFNwYW4pO1xyXG4gICAgfVxyXG4gICAgLy8gTmVlZCB0byB1c2UgQ1NTIE9iamVjdCBNb2RlbCAoQ1NTT00pIHRvIGJlIGFibGUgdG8gY29tcGx5IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgKENTUClcclxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbnRlbnRfU2VjdXJpdHlfUG9saWN5XHJcbiAgICB2YXIgbWVhc3VyZW1lbnRTcGFuU3R5bGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIFNQQU5fU1RZTEUpLCBjb3B5U3R5bGUpO1xyXG4gICAgT2JqZWN0LmFzc2lnbihtZWFzdXJlbWVudFNwYW4uc3R5bGUsIG1lYXN1cmVtZW50U3BhblN0eWxlKTtcclxuICAgIG1lYXN1cmVtZW50U3Bhbi50ZXh0Q29udGVudCA9IFwiXCIuY29uY2F0KHRleHQpO1xyXG4gICAgdmFyIHJlY3QgPSBtZWFzdXJlbWVudFNwYW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICB3aWR0aDogcmVjdC53aWR0aCxcclxuICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodFxyXG4gICAgfTtcclxuICAgIHN0cmluZ0NhY2hlLndpZHRoQ2FjaGVbY2FjaGVLZXldID0gcmVzdWx0O1xyXG4gICAgaWYgKCsrc3RyaW5nQ2FjaGUuY2FjaGVDb3VudCA+IE1BWF9DQUNIRV9OVU0pIHtcclxuICAgICAgc3RyaW5nQ2FjaGUuY2FjaGVDb3VudCA9IDA7XHJcbiAgICAgIHN0cmluZ0NhY2hlLndpZHRoQ2FjaGUgPSB7fTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgd2lkdGg6IDAsXHJcbiAgICAgIGhlaWdodDogMFxyXG4gICAgfTtcclxuICB9XHJcbn07XHJcbnZhciBnZXRPZmZzZXQgPSBleHBvcnRzLmdldE9mZnNldCA9IGZ1bmN0aW9uIGdldE9mZnNldChyZWN0KSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHRvcDogcmVjdC50b3AgKyB3aW5kb3cuc2Nyb2xsWSAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRUb3AsXHJcbiAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW5kb3cuc2Nyb2xsWCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRMZWZ0XHJcbiAgfTtcclxufTsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0U3R5bGVTdHJpbmciLCJnZXRTdHJpbmdTaXplIiwiZ2V0T2Zmc2V0IiwiX0dsb2JhbCIsInJlcXVpcmUiLCJvd25LZXlzIiwiZSIsInIiLCJ0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwib2JqIiwia2V5IiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImkiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwiaXRlciIsImlzQXJyYXkiLCJsZW4iLCJhcnIyIiwic3RyaW5nQ2FjaGUiLCJ3aWR0aENhY2hlIiwiY2FjaGVDb3VudCIsIk1BWF9DQUNIRV9OVU0iLCJTUEFOX1NUWUxFIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwicGFkZGluZyIsIm1hcmdpbiIsImJvcmRlciIsIndoaXRlU3BhY2UiLCJTVFlMRV9MSVNUIiwiTUVBU1VSRU1FTlRfU1BBTl9JRCIsImF1dG9Db21wbGV0ZVN0eWxlIiwiaW5kZXhPZiIsImNvbmNhdCIsImNhbWVsVG9NaWRkbGVMaW5lIiwidGV4dCIsInN0cnMiLCJzcGxpdCIsImZvcm1hdFN0cnMiLCJyZWR1Y2UiLCJyZXN1bHQiLCJlbnRyeSIsInRvVXBwZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJqb2luIiwic3R5bGUiLCJzIiwicmVtb3ZlSW52YWxpZEtleXMiLCJjb3B5T2JqIiwidW5kZWZpbmVkIiwiR2xvYmFsIiwiaXNTc3IiLCJ3aWR0aCIsImhlaWdodCIsImNvcHlTdHlsZSIsImNhY2hlS2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1lYXN1cmVtZW50U3BhbiIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwiYm9keSIsImFwcGVuZENoaWxkIiwibWVhc3VyZW1lbnRTcGFuU3R5bGUiLCJhc3NpZ24iLCJ0ZXh0Q29udGVudCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aW5kb3ciLCJzY3JvbGxZIiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50VG9wIiwic2Nyb2xsWCIsImNsaWVudExlZnQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/DOMUtils.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js":
/*!*****************************************************!*\
  !*** ./node_modules/recharts/lib/util/DataUtils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.compareValues = void 0;\nexports.findEntryInArray = findEntryInArray;\nexports.uniqueId = exports.mathSign = exports.isPercent = exports.isNumber = exports.isNumOrStr = exports.isNullish = exports.interpolateNumber = exports.hasDuplicate = exports.getPercentValue = exports.getLinearRegression = exports.getAnyElementOfObject = void 0;\nvar _isString = _interopRequireDefault(__webpack_require__(/*! lodash/isString */ \"lodash/isString\"));\nvar _isNaN = _interopRequireDefault(__webpack_require__(/*! lodash/isNaN */ \"lodash/isNaN\"));\nvar _get = _interopRequireDefault(__webpack_require__(/*! lodash/get */ \"lodash/get\"));\nvar _isNumber = _interopRequireDefault(__webpack_require__(/*! lodash/isNumber */ \"lodash/isNumber\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nvar mathSign = exports.mathSign = function mathSign(value) {\n    if (value === 0) {\n        return 0;\n    }\n    if (value > 0) {\n        return 1;\n    }\n    return -1;\n};\nvar isPercent = exports.isPercent = function isPercent(value) {\n    return (0, _isString[\"default\"])(value) && value.indexOf('%') === value.length - 1;\n};\nvar isNumber = exports.isNumber = function isNumber(value) {\n    return (0, _isNumber[\"default\"])(value) && !(0, _isNaN[\"default\"])(value);\n};\nvar isNullish = exports.isNullish = function isNullish(value) {\n    return (0, _isNil[\"default\"])(value);\n};\nvar isNumOrStr = exports.isNumOrStr = function isNumOrStr(value) {\n    return isNumber(value) || (0, _isString[\"default\"])(value);\n};\nvar idCounter = 0;\nvar uniqueId = exports.uniqueId = function uniqueId(prefix) {\n    var id = ++idCounter;\n    return \"\".concat(prefix || '').concat(id);\n};\n/**\r\n * Get percent value of a total value\r\n * @param {number|string} percent A percent\r\n * @param {number} totalValue     Total value\r\n * @param {number} defaultValue   The value returned when percent is undefined or invalid\r\n * @param {boolean} validate      If set to be true, the result will be validated\r\n * @return {number} value\r\n */ var getPercentValue = exports.getPercentValue = function getPercentValue(percent, totalValue) {\n    var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var validate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (!isNumber(percent) && !(0, _isString[\"default\"])(percent)) {\n        return defaultValue;\n    }\n    var value;\n    if (isPercent(percent)) {\n        var index = percent.indexOf('%');\n        value = totalValue * parseFloat(percent.slice(0, index)) / 100;\n    } else {\n        value = +percent;\n    }\n    if ((0, _isNaN[\"default\"])(value)) {\n        value = defaultValue;\n    }\n    if (validate && value > totalValue) {\n        value = totalValue;\n    }\n    return value;\n};\nvar getAnyElementOfObject = exports.getAnyElementOfObject = function getAnyElementOfObject(obj) {\n    if (!obj) {\n        return null;\n    }\n    var keys = Object.keys(obj);\n    if (keys && keys.length) {\n        return obj[keys[0]];\n    }\n    return null;\n};\nvar hasDuplicate = exports.hasDuplicate = function hasDuplicate(ary) {\n    if (!Array.isArray(ary)) {\n        return false;\n    }\n    var len = ary.length;\n    var cache = {};\n    for(var i = 0; i < len; i++){\n        if (!cache[ary[i]]) {\n            cache[ary[i]] = true;\n        } else {\n            return true;\n        }\n    }\n    return false;\n};\n/* @todo consider to rename this function into `getInterpolator` */ var interpolateNumber = exports.interpolateNumber = function interpolateNumber(numberA, numberB) {\n    if (isNumber(numberA) && isNumber(numberB)) {\n        return function(t) {\n            return numberA + t * (numberB - numberA);\n        };\n    }\n    return function() {\n        return numberB;\n    };\n};\nfunction findEntryInArray(ary, specifiedKey, specifiedValue) {\n    if (!ary || !ary.length) {\n        return null;\n    }\n    return ary.find(function(entry) {\n        return entry && (typeof specifiedKey === 'function' ? specifiedKey(entry) : (0, _get[\"default\"])(entry, specifiedKey)) === specifiedValue;\n    });\n}\n/**\r\n * The least square linear regression\r\n * @param {Array} data The array of points\r\n * @returns {Object} The domain of x, and the parameter of linear function\r\n */ var getLinearRegression = exports.getLinearRegression = function getLinearRegression(data) {\n    if (!data || !data.length) {\n        return null;\n    }\n    var len = data.length;\n    var xsum = 0;\n    var ysum = 0;\n    var xysum = 0;\n    var xxsum = 0;\n    var xmin = Infinity;\n    var xmax = -Infinity;\n    var xcurrent = 0;\n    var ycurrent = 0;\n    for(var i = 0; i < len; i++){\n        xcurrent = data[i].cx || 0;\n        ycurrent = data[i].cy || 0;\n        xsum += xcurrent;\n        ysum += ycurrent;\n        xysum += xcurrent * ycurrent;\n        xxsum += xcurrent * xcurrent;\n        xmin = Math.min(xmin, xcurrent);\n        xmax = Math.max(xmax, xcurrent);\n    }\n    var a = len * xxsum !== xsum * xsum ? (len * xysum - xsum * ysum) / (len * xxsum - xsum * xsum) : 0;\n    return {\n        xmin: xmin,\n        xmax: xmax,\n        a: a,\n        b: (ysum - a * xsum) / len\n    };\n};\n/**\r\n * Compare values.\r\n *\r\n * This function is intended to be passed to `Array.prototype.sort()`. It properly compares generic homogeneous arrays that are either `string[]`,\r\n * `number[]`, or `Date[]`. When comparing heterogeneous arrays or homogeneous arrays of other types, it will attempt to compare items properly but\r\n * will fall back to string comparison for mismatched or unsupported types.\r\n *\r\n * For some background, `Array.prototype.sort()`'s default comparator coerces each of the array's items into a string and compares the strings. This\r\n * often leads to undesirable behavior, especially with numerical items.\r\n *\r\n * @param {unknown} a The first item to compare\r\n * @param {unknown} b The second item to compare\r\n * @return {number} A negative number if a < b, a positive number if a > b, 0 if equal\r\n */ var compareValues = exports.compareValues = function compareValues(a, b) {\n    if (isNumber(a) && isNumber(b)) {\n        return a - b;\n    }\n    if ((0, _isString[\"default\"])(a) && (0, _isString[\"default\"])(b)) {\n        return a.localeCompare(b);\n    }\n    if (a instanceof Date && b instanceof Date) {\n        return a.getTime() - b.getTime();\n    }\n    return String(a).localeCompare(String(b));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9EYXRhVXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELHFCQUFxQixHQUFHLEtBQUs7QUFDN0JBLHdCQUF3QixHQUFHRztBQUMzQkgsZ0JBQWdCLEdBQUdBLGdCQUFnQixHQUFHQSxpQkFBaUIsR0FBR0EsZ0JBQWdCLEdBQUdBLGtCQUFrQixHQUFHQSxpQkFBaUIsR0FBR0EseUJBQXlCLEdBQUdBLG9CQUFvQixHQUFHQSx1QkFBdUIsR0FBR0EsMkJBQTJCLEdBQUdBLDZCQUE2QixHQUFHLEtBQUs7QUFDdFEsSUFBSWUsWUFBWUMsdUJBQXVCQyxtQkFBT0EsQ0FBQyx3Q0FBaUI7QUFDaEUsSUFBSUMsU0FBU0YsdUJBQXVCQyxtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJRSxPQUFPSCx1QkFBdUJDLG1CQUFPQSxDQUFDLDhCQUFZO0FBQ3RELElBQUlHLFlBQVlKLHVCQUF1QkMsbUJBQU9BLENBQUMsd0NBQWlCO0FBQ2hFLElBQUlJLFNBQVNMLHVCQUF1QkMsbUJBQU9BLENBQUMsa0NBQWM7QUFDMUQsU0FBU0QsdUJBQXVCTSxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLElBQUlqQixXQUFXTCxnQkFBZ0IsR0FBRyxTQUFTSyxTQUFTSixLQUFLO0lBQ3ZELElBQUlBLFVBQVUsR0FBRztRQUNmLE9BQU87SUFDVDtJQUNBLElBQUlBLFFBQVEsR0FBRztRQUNiLE9BQU87SUFDVDtJQUNBLE9BQU8sQ0FBQztBQUNWO0FBQ0EsSUFBSUssWUFBWU4saUJBQWlCLEdBQUcsU0FBU00sVUFBVUwsS0FBSztJQUMxRCxPQUFPLENBQUMsR0FBR2MsU0FBUyxDQUFDLFVBQVUsRUFBRWQsVUFBVUEsTUFBTXVCLE9BQU8sQ0FBQyxT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T0FBT08sS0FBS0MsR0FBRyxDQUFDUixNQUFNRztRQUN0QkQsT0FBT0ssS0FBS0UsR0FBRyxDQUFDUCxNQUFNQztJQUN4QjtJQUNBLElBQUlPLElBQUl6QixNQUFNYyxVQUFVSCxPQUFPQSxPQUFPLENBQUNYLE1BQU1hLFFBQVFGLE9BQU9DLElBQUcsSUFBTVosQ0FBQUEsTUFBTWMsUUFBUUgsT0FBT0EsSUFBRyxJQUFLO0lBQ2xHLE9BQU87UUFDTEksTUFBTUE7UUFDTkUsTUFBTUE7UUFDTlEsR0FBR0E7UUFDSEMsR0FBRyxDQUFDZCxPQUFPYSxJQUFJZCxJQUFHLElBQUtYO0lBQ3pCO0FBQ0Y7QUFFQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ0QsSUFBSXpDLGdCQUFnQkYscUJBQXFCLEdBQUcsU0FBU0UsY0FBY2tFLENBQUMsRUFBRUMsQ0FBQztJQUNyRSxJQUFJOUQsU0FBUzZELE1BQU03RCxTQUFTOEQsSUFBSTtRQUM5QixPQUFPRCxJQUFJQztJQUNiO0lBQ0EsSUFBSSxDQUFDLEdBQUd0RCxTQUFTLENBQUMsVUFBVSxFQUFFcUQsTUFBTSxDQUFDLEdBQUdyRCxTQUFTLENBQUMsVUFBVSxFQUFFc0QsSUFBSTtRQUNoRSxPQUFPRCxFQUFFRSxhQUFhLENBQUNEO0lBQ3pCO0lBQ0EsSUFBSUQsYUFBYUcsUUFBUUYsYUFBYUUsTUFBTTtRQUMxQyxPQUFPSCxFQUFFSSxPQUFPLEtBQUtILEVBQUVHLE9BQU87SUFDaEM7SUFDQSxPQUFPQyxPQUFPTCxHQUFHRSxhQUFhLENBQUNHLE9BQU9KO0FBQ3hDIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFx1dGlsXFxEYXRhVXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5jb21wYXJlVmFsdWVzID0gdm9pZCAwO1xyXG5leHBvcnRzLmZpbmRFbnRyeUluQXJyYXkgPSBmaW5kRW50cnlJbkFycmF5O1xyXG5leHBvcnRzLnVuaXF1ZUlkID0gZXhwb3J0cy5tYXRoU2lnbiA9IGV4cG9ydHMuaXNQZXJjZW50ID0gZXhwb3J0cy5pc051bWJlciA9IGV4cG9ydHMuaXNOdW1PclN0ciA9IGV4cG9ydHMuaXNOdWxsaXNoID0gZXhwb3J0cy5pbnRlcnBvbGF0ZU51bWJlciA9IGV4cG9ydHMuaGFzRHVwbGljYXRlID0gZXhwb3J0cy5nZXRQZXJjZW50VmFsdWUgPSBleHBvcnRzLmdldExpbmVhclJlZ3Jlc3Npb24gPSBleHBvcnRzLmdldEFueUVsZW1lbnRPZk9iamVjdCA9IHZvaWQgMDtcclxudmFyIF9pc1N0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc1N0cmluZ1wiKSk7XHJcbnZhciBfaXNOYU4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNOYU5cIikpO1xyXG52YXIgX2dldCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9nZXRcIikpO1xyXG52YXIgX2lzTnVtYmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzTnVtYmVyXCIpKTtcclxudmFyIF9pc05pbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc05pbFwiKSk7XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG52YXIgbWF0aFNpZ24gPSBleHBvcnRzLm1hdGhTaWduID0gZnVuY3Rpb24gbWF0aFNpZ24odmFsdWUpIHtcclxuICBpZiAodmFsdWUgPT09IDApIHtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuICBpZiAodmFsdWUgPiAwKSB7XHJcbiAgICByZXR1cm4gMTtcclxuICB9XHJcbiAgcmV0dXJuIC0xO1xyXG59O1xyXG52YXIgaXNQZXJjZW50ID0gZXhwb3J0cy5pc1BlcmNlbnQgPSBmdW5jdGlvbiBpc1BlcmNlbnQodmFsdWUpIHtcclxuICByZXR1cm4gKDAsIF9pc1N0cmluZ1tcImRlZmF1bHRcIl0pKHZhbHVlKSAmJiB2YWx1ZS5pbmRleE9mKCclJykgPT09IHZhbHVlLmxlbmd0aCAtIDE7XHJcbn07XHJcbnZhciBpc051bWJlciA9IGV4cG9ydHMuaXNOdW1iZXIgPSBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xyXG4gIHJldHVybiAoMCwgX2lzTnVtYmVyW1wiZGVmYXVsdFwiXSkodmFsdWUpICYmICEoMCwgX2lzTmFOW1wiZGVmYXVsdFwiXSkodmFsdWUpO1xyXG59O1xyXG52YXIgaXNOdWxsaXNoID0gZXhwb3J0cy5pc051bGxpc2ggPSBmdW5jdGlvbiBpc051bGxpc2godmFsdWUpIHtcclxuICByZXR1cm4gKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKHZhbHVlKTtcclxufTtcclxudmFyIGlzTnVtT3JTdHIgPSBleHBvcnRzLmlzTnVtT3JTdHIgPSBmdW5jdGlvbiBpc051bU9yU3RyKHZhbHVlKSB7XHJcbiAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSB8fCAoMCwgX2lzU3RyaW5nW1wiZGVmYXVsdFwiXSkodmFsdWUpO1xyXG59O1xyXG52YXIgaWRDb3VudGVyID0gMDtcclxudmFyIHVuaXF1ZUlkID0gZXhwb3J0cy51bmlxdWVJZCA9IGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xyXG4gIHZhciBpZCA9ICsraWRDb3VudGVyO1xyXG4gIHJldHVybiBcIlwiLmNvbmNhdChwcmVmaXggfHwgJycpLmNvbmNhdChpZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHBlcmNlbnQgdmFsdWUgb2YgYSB0b3RhbCB2YWx1ZVxyXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHBlcmNlbnQgQSBwZXJjZW50XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3RhbFZhbHVlICAgICBUb3RhbCB2YWx1ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdFZhbHVlICAgVGhlIHZhbHVlIHJldHVybmVkIHdoZW4gcGVyY2VudCBpcyB1bmRlZmluZWQgb3IgaW52YWxpZFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbGlkYXRlICAgICAgSWYgc2V0IHRvIGJlIHRydWUsIHRoZSByZXN1bHQgd2lsbCBiZSB2YWxpZGF0ZWRcclxuICogQHJldHVybiB7bnVtYmVyfSB2YWx1ZVxyXG4gKi9cclxudmFyIGdldFBlcmNlbnRWYWx1ZSA9IGV4cG9ydHMuZ2V0UGVyY2VudFZhbHVlID0gZnVuY3Rpb24gZ2V0UGVyY2VudFZhbHVlKHBlcmNlbnQsIHRvdGFsVmFsdWUpIHtcclxuICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xyXG4gIHZhciB2YWxpZGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XHJcbiAgaWYgKCFpc051bWJlcihwZXJjZW50KSAmJiAhKDAsIF9pc1N0cmluZ1tcImRlZmF1bHRcIl0pKHBlcmNlbnQpKSB7XHJcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xyXG4gIH1cclxuICB2YXIgdmFsdWU7XHJcbiAgaWYgKGlzUGVyY2VudChwZXJjZW50KSkge1xyXG4gICAgdmFyIGluZGV4ID0gcGVyY2VudC5pbmRleE9mKCclJyk7XHJcbiAgICB2YWx1ZSA9IHRvdGFsVmFsdWUgKiBwYXJzZUZsb2F0KHBlcmNlbnQuc2xpY2UoMCwgaW5kZXgpKSAvIDEwMDtcclxuICB9IGVsc2Uge1xyXG4gICAgdmFsdWUgPSArcGVyY2VudDtcclxuICB9XHJcbiAgaWYgKCgwLCBfaXNOYU5bXCJkZWZhdWx0XCJdKSh2YWx1ZSkpIHtcclxuICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG4gIH1cclxuICBpZiAodmFsaWRhdGUgJiYgdmFsdWUgPiB0b3RhbFZhbHVlKSB7XHJcbiAgICB2YWx1ZSA9IHRvdGFsVmFsdWU7XHJcbiAgfVxyXG4gIHJldHVybiB2YWx1ZTtcclxufTtcclxudmFyIGdldEFueUVsZW1lbnRPZk9iamVjdCA9IGV4cG9ydHMuZ2V0QW55RWxlbWVudE9mT2JqZWN0ID0gZnVuY3Rpb24gZ2V0QW55RWxlbWVudE9mT2JqZWN0KG9iaikge1xyXG4gIGlmICghb2JqKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xyXG4gIGlmIChrZXlzICYmIGtleXMubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gb2JqW2tleXNbMF1dO1xyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufTtcclxudmFyIGhhc0R1cGxpY2F0ZSA9IGV4cG9ydHMuaGFzRHVwbGljYXRlID0gZnVuY3Rpb24gaGFzRHVwbGljYXRlKGFyeSkge1xyXG4gIGlmICghQXJyYXkuaXNBcnJheShhcnkpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHZhciBsZW4gPSBhcnkubGVuZ3RoO1xyXG4gIHZhciBjYWNoZSA9IHt9O1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIGlmICghY2FjaGVbYXJ5W2ldXSkge1xyXG4gICAgICBjYWNoZVthcnlbaV1dID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG4vKiBAdG9kbyBjb25zaWRlciB0byByZW5hbWUgdGhpcyBmdW5jdGlvbiBpbnRvIGBnZXRJbnRlcnBvbGF0b3JgICovXHJcbnZhciBpbnRlcnBvbGF0ZU51bWJlciA9IGV4cG9ydHMuaW50ZXJwb2xhdGVOdW1iZXIgPSBmdW5jdGlvbiBpbnRlcnBvbGF0ZU51bWJlcihudW1iZXJBLCBudW1iZXJCKSB7XHJcbiAgaWYgKGlzTnVtYmVyKG51bWJlckEpICYmIGlzTnVtYmVyKG51bWJlckIpKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcclxuICAgICAgcmV0dXJuIG51bWJlckEgKyB0ICogKG51bWJlckIgLSBudW1iZXJBKTtcclxuICAgIH07XHJcbiAgfVxyXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbnVtYmVyQjtcclxuICB9O1xyXG59O1xyXG5mdW5jdGlvbiBmaW5kRW50cnlJbkFycmF5KGFyeSwgc3BlY2lmaWVkS2V5LCBzcGVjaWZpZWRWYWx1ZSkge1xyXG4gIGlmICghYXJ5IHx8ICFhcnkubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgcmV0dXJuIGFyeS5maW5kKGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgcmV0dXJuIGVudHJ5ICYmICh0eXBlb2Ygc3BlY2lmaWVkS2V5ID09PSAnZnVuY3Rpb24nID8gc3BlY2lmaWVkS2V5KGVudHJ5KSA6ICgwLCBfZ2V0W1wiZGVmYXVsdFwiXSkoZW50cnksIHNwZWNpZmllZEtleSkpID09PSBzcGVjaWZpZWRWYWx1ZTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBsZWFzdCBzcXVhcmUgbGluZWFyIHJlZ3Jlc3Npb25cclxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgYXJyYXkgb2YgcG9pbnRzXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkb21haW4gb2YgeCwgYW5kIHRoZSBwYXJhbWV0ZXIgb2YgbGluZWFyIGZ1bmN0aW9uXHJcbiAqL1xyXG52YXIgZ2V0TGluZWFyUmVncmVzc2lvbiA9IGV4cG9ydHMuZ2V0TGluZWFyUmVncmVzc2lvbiA9IGZ1bmN0aW9uIGdldExpbmVhclJlZ3Jlc3Npb24oZGF0YSkge1xyXG4gIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICB2YXIgbGVuID0gZGF0YS5sZW5ndGg7XHJcbiAgdmFyIHhzdW0gPSAwO1xyXG4gIHZhciB5c3VtID0gMDtcclxuICB2YXIgeHlzdW0gPSAwO1xyXG4gIHZhciB4eHN1bSA9IDA7XHJcbiAgdmFyIHhtaW4gPSBJbmZpbml0eTtcclxuICB2YXIgeG1heCA9IC1JbmZpbml0eTtcclxuICB2YXIgeGN1cnJlbnQgPSAwO1xyXG4gIHZhciB5Y3VycmVudCA9IDA7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgeGN1cnJlbnQgPSBkYXRhW2ldLmN4IHx8IDA7XHJcbiAgICB5Y3VycmVudCA9IGRhdGFbaV0uY3kgfHwgMDtcclxuICAgIHhzdW0gKz0geGN1cnJlbnQ7XHJcbiAgICB5c3VtICs9IHljdXJyZW50O1xyXG4gICAgeHlzdW0gKz0geGN1cnJlbnQgKiB5Y3VycmVudDtcclxuICAgIHh4c3VtICs9IHhjdXJyZW50ICogeGN1cnJlbnQ7XHJcbiAgICB4bWluID0gTWF0aC5taW4oeG1pbiwgeGN1cnJlbnQpO1xyXG4gICAgeG1heCA9IE1hdGgubWF4KHhtYXgsIHhjdXJyZW50KTtcclxuICB9XHJcbiAgdmFyIGEgPSBsZW4gKiB4eHN1bSAhPT0geHN1bSAqIHhzdW0gPyAobGVuICogeHlzdW0gLSB4c3VtICogeXN1bSkgLyAobGVuICogeHhzdW0gLSB4c3VtICogeHN1bSkgOiAwO1xyXG4gIHJldHVybiB7XHJcbiAgICB4bWluOiB4bWluLFxyXG4gICAgeG1heDogeG1heCxcclxuICAgIGE6IGEsXHJcbiAgICBiOiAoeXN1bSAtIGEgKiB4c3VtKSAvIGxlblxyXG4gIH07XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcGFyZSB2YWx1ZXMuXHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgaW50ZW5kZWQgdG8gYmUgcGFzc2VkIHRvIGBBcnJheS5wcm90b3R5cGUuc29ydCgpYC4gSXQgcHJvcGVybHkgY29tcGFyZXMgZ2VuZXJpYyBob21vZ2VuZW91cyBhcnJheXMgdGhhdCBhcmUgZWl0aGVyIGBzdHJpbmdbXWAsXHJcbiAqIGBudW1iZXJbXWAsIG9yIGBEYXRlW11gLiBXaGVuIGNvbXBhcmluZyBoZXRlcm9nZW5lb3VzIGFycmF5cyBvciBob21vZ2VuZW91cyBhcnJheXMgb2Ygb3RoZXIgdHlwZXMsIGl0IHdpbGwgYXR0ZW1wdCB0byBjb21wYXJlIGl0ZW1zIHByb3Blcmx5IGJ1dFxyXG4gKiB3aWxsIGZhbGwgYmFjayB0byBzdHJpbmcgY29tcGFyaXNvbiBmb3IgbWlzbWF0Y2hlZCBvciB1bnN1cHBvcnRlZCB0eXBlcy5cclxuICpcclxuICogRm9yIHNvbWUgYmFja2dyb3VuZCwgYEFycmF5LnByb3RvdHlwZS5zb3J0KClgJ3MgZGVmYXVsdCBjb21wYXJhdG9yIGNvZXJjZXMgZWFjaCBvZiB0aGUgYXJyYXkncyBpdGVtcyBpbnRvIGEgc3RyaW5nIGFuZCBjb21wYXJlcyB0aGUgc3RyaW5ncy4gVGhpc1xyXG4gKiBvZnRlbiBsZWFkcyB0byB1bmRlc2lyYWJsZSBiZWhhdmlvciwgZXNwZWNpYWxseSB3aXRoIG51bWVyaWNhbCBpdGVtcy5cclxuICpcclxuICogQHBhcmFtIHt1bmtub3dufSBhIFRoZSBmaXJzdCBpdGVtIHRvIGNvbXBhcmVcclxuICogQHBhcmFtIHt1bmtub3dufSBiIFRoZSBzZWNvbmQgaXRlbSB0byBjb21wYXJlXHJcbiAqIEByZXR1cm4ge251bWJlcn0gQSBuZWdhdGl2ZSBudW1iZXIgaWYgYSA8IGIsIGEgcG9zaXRpdmUgbnVtYmVyIGlmIGEgPiBiLCAwIGlmIGVxdWFsXHJcbiAqL1xyXG52YXIgY29tcGFyZVZhbHVlcyA9IGV4cG9ydHMuY29tcGFyZVZhbHVlcyA9IGZ1bmN0aW9uIGNvbXBhcmVWYWx1ZXMoYSwgYikge1xyXG4gIGlmIChpc051bWJlcihhKSAmJiBpc051bWJlcihiKSkge1xyXG4gICAgcmV0dXJuIGEgLSBiO1xyXG4gIH1cclxuICBpZiAoKDAsIF9pc1N0cmluZ1tcImRlZmF1bHRcIl0pKGEpICYmICgwLCBfaXNTdHJpbmdbXCJkZWZhdWx0XCJdKShiKSkge1xyXG4gICAgcmV0dXJuIGEubG9jYWxlQ29tcGFyZShiKTtcclxuICB9XHJcbiAgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICByZXR1cm4gYS5nZXRUaW1lKCkgLSBiLmdldFRpbWUoKTtcclxuICB9XHJcbiAgcmV0dXJuIFN0cmluZyhhKS5sb2NhbGVDb21wYXJlKFN0cmluZyhiKSk7XHJcbn07Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY29tcGFyZVZhbHVlcyIsImZpbmRFbnRyeUluQXJyYXkiLCJ1bmlxdWVJZCIsIm1hdGhTaWduIiwiaXNQZXJjZW50IiwiaXNOdW1iZXIiLCJpc051bU9yU3RyIiwiaXNOdWxsaXNoIiwiaW50ZXJwb2xhdGVOdW1iZXIiLCJoYXNEdXBsaWNhdGUiLCJnZXRQZXJjZW50VmFsdWUiLCJnZXRMaW5lYXJSZWdyZXNzaW9uIiwiZ2V0QW55RWxlbWVudE9mT2JqZWN0IiwiX2lzU3RyaW5nIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfaXNOYU4iLCJfZ2V0IiwiX2lzTnVtYmVyIiwiX2lzTmlsIiwib2JqIiwiX19lc01vZHVsZSIsImluZGV4T2YiLCJsZW5ndGgiLCJpZENvdW50ZXIiLCJwcmVmaXgiLCJpZCIsImNvbmNhdCIsInBlcmNlbnQiLCJ0b3RhbFZhbHVlIiwiZGVmYXVsdFZhbHVlIiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwidmFsaWRhdGUiLCJpbmRleCIsInBhcnNlRmxvYXQiLCJzbGljZSIsImtleXMiLCJhcnkiLCJBcnJheSIsImlzQXJyYXkiLCJsZW4iLCJjYWNoZSIsImkiLCJudW1iZXJBIiwibnVtYmVyQiIsInQiLCJzcGVjaWZpZWRLZXkiLCJzcGVjaWZpZWRWYWx1ZSIsImZpbmQiLCJlbnRyeSIsImRhdGEiLCJ4c3VtIiwieXN1bSIsInh5c3VtIiwieHhzdW0iLCJ4bWluIiwiSW5maW5pdHkiLCJ4bWF4IiwieGN1cnJlbnQiLCJ5Y3VycmVudCIsImN4IiwiY3kiLCJNYXRoIiwibWluIiwibWF4IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwiRGF0ZSIsImdldFRpbWUiLCJTdHJpbmciXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/DetectReferenceElementsDomain.js":
/*!*************************************************************************!*\
  !*** ./node_modules/recharts/lib/util/DetectReferenceElementsDomain.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.detectReferenceElementsDomain = void 0;\nvar _ReferenceDot = __webpack_require__(/*! ../cartesian/ReferenceDot */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/ReferenceDot.js\");\nvar _ReferenceLine = __webpack_require__(/*! ../cartesian/ReferenceLine */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/ReferenceLine.js\");\nvar _ReferenceArea = __webpack_require__(/*! ../cartesian/ReferenceArea */ \"(pages-dir-node)/./node_modules/recharts/lib/cartesian/ReferenceArea.js\");\nvar _IfOverflowMatches = __webpack_require__(/*! ./IfOverflowMatches */ \"(pages-dir-node)/./node_modules/recharts/lib/util/IfOverflowMatches.js\");\nvar _ReactUtils = __webpack_require__(/*! ./ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _DataUtils = __webpack_require__(/*! ./DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nvar detectReferenceElementsDomain = exports.detectReferenceElementsDomain = function detectReferenceElementsDomain(children, domain, axisId, axisType, specifiedTicks) {\n    var lines = (0, _ReactUtils.findAllByType)(children, _ReferenceLine.ReferenceLine);\n    var dots = (0, _ReactUtils.findAllByType)(children, _ReferenceDot.ReferenceDot);\n    var elements = [].concat(_toConsumableArray(lines), _toConsumableArray(dots));\n    var areas = (0, _ReactUtils.findAllByType)(children, _ReferenceArea.ReferenceArea);\n    var idKey = \"\".concat(axisType, \"Id\");\n    var valueKey = axisType[0];\n    var finalDomain = domain;\n    if (elements.length) {\n        finalDomain = elements.reduce(function(result, el) {\n            if (el.props[idKey] === axisId && (0, _IfOverflowMatches.ifOverflowMatches)(el.props, 'extendDomain') && (0, _DataUtils.isNumber)(el.props[valueKey])) {\n                var value = el.props[valueKey];\n                return [\n                    Math.min(result[0], value),\n                    Math.max(result[1], value)\n                ];\n            }\n            return result;\n        }, finalDomain);\n    }\n    if (areas.length) {\n        var key1 = \"\".concat(valueKey, \"1\");\n        var key2 = \"\".concat(valueKey, \"2\");\n        finalDomain = areas.reduce(function(result, el) {\n            if (el.props[idKey] === axisId && (0, _IfOverflowMatches.ifOverflowMatches)(el.props, 'extendDomain') && (0, _DataUtils.isNumber)(el.props[key1]) && (0, _DataUtils.isNumber)(el.props[key2])) {\n                var value1 = el.props[key1];\n                var value2 = el.props[key2];\n                return [\n                    Math.min(result[0], value1, value2),\n                    Math.max(result[1], value1, value2)\n                ];\n            }\n            return result;\n        }, finalDomain);\n    }\n    if (specifiedTicks && specifiedTicks.length) {\n        finalDomain = specifiedTicks.reduce(function(result, tick) {\n            if ((0, _DataUtils.isNumber)(tick)) {\n                return [\n                    Math.min(result[0], tick),\n                    Math.max(result[1], tick)\n                ];\n            }\n            return result;\n        }, finalDomain);\n    }\n    return finalDomain;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9EZXRlY3RSZWZlcmVuY2VFbGVtZW50c0RvbWFpbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQscUNBQXFDLEdBQUcsS0FBSztBQUM3QyxJQUFJRyxnQkFBZ0JDLG1CQUFPQSxDQUFDLHlHQUEyQjtBQUN2RCxJQUFJQyxpQkFBaUJELG1CQUFPQSxDQUFDLDJHQUE0QjtBQUN6RCxJQUFJRSxpQkFBaUJGLG1CQUFPQSxDQUFDLDJHQUE0QjtBQUN6RCxJQUFJRyxxQkFBcUJILG1CQUFPQSxDQUFDLG1HQUFxQjtBQUN0RCxJQUFJSSxjQUFjSixtQkFBT0EsQ0FBQyxxRkFBYztBQUN4QyxJQUFJSyxhQUFhTCxtQkFBT0EsQ0FBQyxtRkFBYTtBQUN0QyxTQUFTTSxtQkFBbUJDLEdBQUc7SUFBSSxPQUFPQyxtQkFBbUJELFFBQVFFLGlCQUFpQkYsUUFBUUcsNEJBQTRCSCxRQUFRSTtBQUFzQjtBQUN4SixTQUFTQTtJQUF1QixNQUFNLElBQUlDLFVBQVU7QUFBeUk7QUFDN0wsU0FBU0YsNEJBQTRCRyxDQUFDLEVBQUVDLE1BQU07SUFBSSxJQUFJLENBQUNELEdBQUc7SUFBUSxJQUFJLE9BQU9BLE1BQU0sVUFBVSxPQUFPRSxrQkFBa0JGLEdBQUdDO0lBQVMsSUFBSUUsSUFBSXRCLE9BQU91QixTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDTixHQUFHTyxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQUksSUFBSUosTUFBTSxZQUFZSCxFQUFFLFdBQVcsRUFBRUcsSUFBSUgsRUFBRSxXQUFXLENBQUNRLElBQUk7SUFBRSxJQUFJTCxNQUFNLFNBQVNBLE1BQU0sT0FBTyxPQUFPTSxNQUFNQyxJQUFJLENBQUNWO0lBQUksSUFBSUcsTUFBTSxlQUFlLDJDQUEyQ1EsSUFBSSxDQUFDUixJQUFJLE9BQU9ELGtCQUFr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QzNCLE9BQU87b0JBQUNKLEtBQUtDLEdBQUcsQ0FBQ04sTUFBTSxDQUFDLEVBQUUsRUFBRVUsUUFBUUM7b0JBQVNOLEtBQUtFLEdBQUcsQ0FBQ1AsTUFBTSxDQUFDLEVBQUUsRUFBRVUsUUFBUUM7aUJBQVE7WUFDbkY7WUFDQSxPQUFPWDtRQUNULEdBQUdGO0lBQ0w7SUFDQSxJQUFJWixrQkFBa0JBLGVBQWVQLE1BQU0sRUFBRTtRQUMzQ21CLGNBQWNaLGVBQWVhLE1BQU0sQ0FBQyxTQUFVQyxNQUFNLEVBQUVZLElBQUk7WUFDeEQsSUFBSSxDQUFDLEdBQUcxRCxXQUFXa0QsUUFBUSxFQUFFUSxPQUFPO2dCQUNsQyxPQUFPO29CQUFDUCxLQUFLQyxHQUFHLENBQUNOLE1BQU0sQ0FBQyxFQUFFLEVBQUVZO29CQUFPUCxLQUFLRSxHQUFHLENBQUNQLE1BQU0sQ0FBQyxFQUFFLEVBQUVZO2lCQUFNO1lBQy9EO1lBQ0EsT0FBT1o7UUFDVCxHQUFHRjtJQUNMO0lBQ0EsT0FBT0E7QUFDVCIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcdXRpbFxcRGV0ZWN0UmVmZXJlbmNlRWxlbWVudHNEb21haW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZXRlY3RSZWZlcmVuY2VFbGVtZW50c0RvbWFpbiA9IHZvaWQgMDtcclxudmFyIF9SZWZlcmVuY2VEb3QgPSByZXF1aXJlKFwiLi4vY2FydGVzaWFuL1JlZmVyZW5jZURvdFwiKTtcclxudmFyIF9SZWZlcmVuY2VMaW5lID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9SZWZlcmVuY2VMaW5lXCIpO1xyXG52YXIgX1JlZmVyZW5jZUFyZWEgPSByZXF1aXJlKFwiLi4vY2FydGVzaWFuL1JlZmVyZW5jZUFyZWFcIik7XHJcbnZhciBfSWZPdmVyZmxvd01hdGNoZXMgPSByZXF1aXJlKFwiLi9JZk92ZXJmbG93TWF0Y2hlc1wiKTtcclxudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4vUmVhY3RVdGlsc1wiKTtcclxudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi9EYXRhVXRpbHNcIik7XHJcbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxyXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XHJcbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxyXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cclxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxyXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxyXG52YXIgZGV0ZWN0UmVmZXJlbmNlRWxlbWVudHNEb21haW4gPSBleHBvcnRzLmRldGVjdFJlZmVyZW5jZUVsZW1lbnRzRG9tYWluID0gZnVuY3Rpb24gZGV0ZWN0UmVmZXJlbmNlRWxlbWVudHNEb21haW4oY2hpbGRyZW4sIGRvbWFpbiwgYXhpc0lkLCBheGlzVHlwZSwgc3BlY2lmaWVkVGlja3MpIHtcclxuICB2YXIgbGluZXMgPSAoMCwgX1JlYWN0VXRpbHMuZmluZEFsbEJ5VHlwZSkoY2hpbGRyZW4sIF9SZWZlcmVuY2VMaW5lLlJlZmVyZW5jZUxpbmUpO1xyXG4gIHZhciBkb3RzID0gKDAsIF9SZWFjdFV0aWxzLmZpbmRBbGxCeVR5cGUpKGNoaWxkcmVuLCBfUmVmZXJlbmNlRG90LlJlZmVyZW5jZURvdCk7XHJcbiAgdmFyIGVsZW1lbnRzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShsaW5lcyksIF90b0NvbnN1bWFibGVBcnJheShkb3RzKSk7XHJcbiAgdmFyIGFyZWFzID0gKDAsIF9SZWFjdFV0aWxzLmZpbmRBbGxCeVR5cGUpKGNoaWxkcmVuLCBfUmVmZXJlbmNlQXJlYS5SZWZlcmVuY2VBcmVhKTtcclxuICB2YXIgaWRLZXkgPSBcIlwiLmNvbmNhdChheGlzVHlwZSwgXCJJZFwiKTtcclxuICB2YXIgdmFsdWVLZXkgPSBheGlzVHlwZVswXTtcclxuICB2YXIgZmluYWxEb21haW4gPSBkb21haW47XHJcbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZmluYWxEb21haW4gPSBlbGVtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgZWwpIHtcclxuICAgICAgaWYgKGVsLnByb3BzW2lkS2V5XSA9PT0gYXhpc0lkICYmICgwLCBfSWZPdmVyZmxvd01hdGNoZXMuaWZPdmVyZmxvd01hdGNoZXMpKGVsLnByb3BzLCAnZXh0ZW5kRG9tYWluJykgJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGVsLnByb3BzW3ZhbHVlS2V5XSkpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBlbC5wcm9wc1t2YWx1ZUtleV07XHJcbiAgICAgICAgcmV0dXJuIFtNYXRoLm1pbihyZXN1bHRbMF0sIHZhbHVlKSwgTWF0aC5tYXgocmVzdWx0WzFdLCB2YWx1ZSldO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LCBmaW5hbERvbWFpbik7XHJcbiAgfVxyXG4gIGlmIChhcmVhcy5sZW5ndGgpIHtcclxuICAgIHZhciBrZXkxID0gXCJcIi5jb25jYXQodmFsdWVLZXksIFwiMVwiKTtcclxuICAgIHZhciBrZXkyID0gXCJcIi5jb25jYXQodmFsdWVLZXksIFwiMlwiKTtcclxuICAgIGZpbmFsRG9tYWluID0gYXJlYXMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGVsKSB7XHJcbiAgICAgIGlmIChlbC5wcm9wc1tpZEtleV0gPT09IGF4aXNJZCAmJiAoMCwgX0lmT3ZlcmZsb3dNYXRjaGVzLmlmT3ZlcmZsb3dNYXRjaGVzKShlbC5wcm9wcywgJ2V4dGVuZERvbWFpbicpICYmICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShlbC5wcm9wc1trZXkxXSkgJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGVsLnByb3BzW2tleTJdKSkge1xyXG4gICAgICAgIHZhciB2YWx1ZTEgPSBlbC5wcm9wc1trZXkxXTtcclxuICAgICAgICB2YXIgdmFsdWUyID0gZWwucHJvcHNba2V5Ml07XHJcbiAgICAgICAgcmV0dXJuIFtNYXRoLm1pbihyZXN1bHRbMF0sIHZhbHVlMSwgdmFsdWUyKSwgTWF0aC5tYXgocmVzdWx0WzFdLCB2YWx1ZTEsIHZhbHVlMildO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LCBmaW5hbERvbWFpbik7XHJcbiAgfVxyXG4gIGlmIChzcGVjaWZpZWRUaWNrcyAmJiBzcGVjaWZpZWRUaWNrcy5sZW5ndGgpIHtcclxuICAgIGZpbmFsRG9tYWluID0gc3BlY2lmaWVkVGlja3MucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHRpY2spIHtcclxuICAgICAgaWYgKCgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKSh0aWNrKSkge1xyXG4gICAgICAgIHJldHVybiBbTWF0aC5taW4ocmVzdWx0WzBdLCB0aWNrKSwgTWF0aC5tYXgocmVzdWx0WzFdLCB0aWNrKV07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sIGZpbmFsRG9tYWluKTtcclxuICB9XHJcbiAgcmV0dXJuIGZpbmFsRG9tYWluO1xyXG59OyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRldGVjdFJlZmVyZW5jZUVsZW1lbnRzRG9tYWluIiwiX1JlZmVyZW5jZURvdCIsInJlcXVpcmUiLCJfUmVmZXJlbmNlTGluZSIsIl9SZWZlcmVuY2VBcmVhIiwiX0lmT3ZlcmZsb3dNYXRjaGVzIiwiX1JlYWN0VXRpbHMiLCJfRGF0YVV0aWxzIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiYXJyIiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIlR5cGVFcnJvciIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwiaXRlciIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiaXNBcnJheSIsImxlbiIsImxlbmd0aCIsImkiLCJhcnIyIiwiY2hpbGRyZW4iLCJkb21haW4iLCJheGlzSWQiLCJheGlzVHlwZSIsInNwZWNpZmllZFRpY2tzIiwibGluZXMiLCJmaW5kQWxsQnlUeXBlIiwiUmVmZXJlbmNlTGluZSIsImRvdHMiLCJSZWZlcmVuY2VEb3QiLCJlbGVtZW50cyIsImNvbmNhdCIsImFyZWFzIiwiUmVmZXJlbmNlQXJlYSIsImlkS2V5IiwidmFsdWVLZXkiLCJmaW5hbERvbWFpbiIsInJlZHVjZSIsInJlc3VsdCIsImVsIiwicHJvcHMiLCJpZk92ZXJmbG93TWF0Y2hlcyIsImlzTnVtYmVyIiwiTWF0aCIsIm1pbiIsIm1heCIsImtleTEiLCJrZXkyIiwidmFsdWUxIiwidmFsdWUyIiwidGljayJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/DetectReferenceElementsDomain.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/Events.js":
/*!**************************************************!*\
  !*** ./node_modules/recharts/lib/util/Events.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.eventCenter = exports.SYNC_EVENT = void 0;\nvar _eventemitter = _interopRequireDefault(__webpack_require__(/*! eventemitter3 */ \"eventemitter3\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nvar eventCenter = exports.eventCenter = new _eventemitter[\"default\"]();\nvar SYNC_EVENT = exports.SYNC_EVENT = 'recharts.syncMouseEvents';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9FdmVudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELG1CQUFtQixHQUFHQSxrQkFBa0IsR0FBRyxLQUFLO0FBQ2hELElBQUlJLGdCQUFnQkMsdUJBQXVCQyxtQkFBT0EsQ0FBQyxvQ0FBZTtBQUNsRSxTQUFTRCx1QkFBdUJFLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsSUFBSUwsY0FBY0YsbUJBQW1CLEdBQUcsSUFBSUksYUFBYSxDQUFDLFVBQVU7QUFDcEUsSUFBSUQsYUFBYUgsa0JBQWtCLEdBQUciLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXHV0aWxcXEV2ZW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmV2ZW50Q2VudGVyID0gZXhwb3J0cy5TWU5DX0VWRU5UID0gdm9pZCAwO1xyXG52YXIgX2V2ZW50ZW1pdHRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImV2ZW50ZW1pdHRlcjNcIikpO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxudmFyIGV2ZW50Q2VudGVyID0gZXhwb3J0cy5ldmVudENlbnRlciA9IG5ldyBfZXZlbnRlbWl0dGVyW1wiZGVmYXVsdFwiXSgpO1xyXG52YXIgU1lOQ19FVkVOVCA9IGV4cG9ydHMuU1lOQ19FVkVOVCA9ICdyZWNoYXJ0cy5zeW5jTW91c2VFdmVudHMnOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImV2ZW50Q2VudGVyIiwiU1lOQ19FVkVOVCIsIl9ldmVudGVtaXR0ZXIiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIm9iaiIsIl9fZXNNb2R1bGUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/Events.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/FunnelUtils.js":
/*!*******************************************************!*\
  !*** ./node_modules/recharts/lib/util/FunnelUtils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FunnelTrapezoid = FunnelTrapezoid;\nexports.typeGuardTrapezoidProps = typeGuardTrapezoidProps;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _ActiveShapeUtils = __webpack_require__(/*! ./ActiveShapeUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ActiveShapeUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n// Trapezoid props is expecting x, y, height as numbers.\n// When props are being spread in from a user defined component in Funnel,\n// the prop types of an SVGElement have these typed as string | number.\n// This function will return the passed in props along with x, y, height as numbers.\nfunction typeGuardTrapezoidProps(option, props) {\n    var xValue = \"\".concat(props.x || option.x);\n    var x = parseInt(xValue, 10);\n    var yValue = \"\".concat(props.y || option.y);\n    var y = parseInt(yValue, 10);\n    var heightValue = \"\".concat((props === null || props === void 0 ? void 0 : props.height) || (option === null || option === void 0 ? void 0 : option.height));\n    var height = parseInt(heightValue, 10);\n    return _objectSpread(_objectSpread(_objectSpread({}, props), (0, _ActiveShapeUtils.getPropsFromShapeOption)(option)), {}, {\n        height: height,\n        x: x,\n        y: y\n    });\n}\nfunction FunnelTrapezoid(props) {\n    return /*#__PURE__*/ _react[\"default\"].createElement(_ActiveShapeUtils.Shape, _extends({\n        shapeType: \"trapezoid\",\n        propTransformer: typeGuardTrapezoidProps\n    }, props));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9GdW5uZWxVdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsdUJBQXVCLEdBQUdFO0FBQzFCRiwrQkFBK0IsR0FBR0c7QUFDbEMsSUFBSUMsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNuRCxJQUFJQyxvQkFBb0JELG1CQUFPQSxDQUFDLGlHQUFvQjtBQUNwRCxTQUFTRCx1QkFBdUJHLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUUsV0FBVyxLQUFLQyxVQUFVRCxNQUFNQyxPQUFPRSxTQUFTLEdBQUcsV0FBVyxPQUFPSDtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1QsU0FBU0k7SUFBYUEsV0FBV2pCLE9BQU9rQixNQUFNLEdBQUdsQixPQUFPa0IsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVUMsTUFBTTtRQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFBRSxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFBRSxJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQUUsSUFBSXhCLE9BQU9nQixTQUFTLENBQUNVLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSCxRQUFRQyxNQUFNO29CQUFFTCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJ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RSxjQUFjLEdBQUdMLE1BQU0sQ0FBQyxDQUFDRixVQUFVLFFBQVFBLFVBQVUsS0FBSyxJQUFJLEtBQUssSUFBSUEsTUFBTVEsTUFBTSxLQUFNVCxDQUFBQSxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT1MsTUFBTTtJQUMxSixJQUFJQSxTQUFTSixTQUFTRyxhQUFhO0lBQ25DLE9BQU9yQixjQUFjQSxjQUFjQSxjQUFjLENBQUMsR0FBR2MsUUFBUSxDQUFDLEdBQUc1QyxrQkFBa0JxRCx1QkFBdUIsRUFBRVYsVUFBVSxDQUFDLEdBQUc7UUFDeEhTLFFBQVFBO1FBQ1JMLEdBQUdBO1FBQ0hHLEdBQUdBO0lBQ0w7QUFDRjtBQUNBLFNBQVN2RCxnQkFBZ0JpRCxLQUFLO0lBQzVCLE9BQU8sV0FBVyxHQUFFL0MsTUFBTSxDQUFDLFVBQVUsQ0FBQ3lELGFBQWEsQ0FBQ3RELGtCQUFrQnVELEtBQUssRUFBRS9DLFNBQVM7UUFDcEZnRCxXQUFXO1FBQ1hDLGlCQUFpQjdEO0lBQ25CLEdBQUdnRDtBQUNMIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFx1dGlsXFxGdW5uZWxVdGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLkZ1bm5lbFRyYXBlem9pZCA9IEZ1bm5lbFRyYXBlem9pZDtcclxuZXhwb3J0cy50eXBlR3VhcmRUcmFwZXpvaWRQcm9wcyA9IHR5cGVHdWFyZFRyYXBlem9pZFByb3BzO1xyXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgX0FjdGl2ZVNoYXBlVXRpbHMgPSByZXF1aXJlKFwiLi9BY3RpdmVTaGFwZVV0aWxzXCIpO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cclxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cclxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxyXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxyXG4vLyBUcmFwZXpvaWQgcHJvcHMgaXMgZXhwZWN0aW5nIHgsIHksIGhlaWdodCBhcyBudW1iZXJzLlxyXG4vLyBXaGVuIHByb3BzIGFyZSBiZWluZyBzcHJlYWQgaW4gZnJvbSBhIHVzZXIgZGVmaW5lZCBjb21wb25lbnQgaW4gRnVubmVsLFxyXG4vLyB0aGUgcHJvcCB0eXBlcyBvZiBhbiBTVkdFbGVtZW50IGhhdmUgdGhlc2UgdHlwZWQgYXMgc3RyaW5nIHwgbnVtYmVyLlxyXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBwYXNzZWQgaW4gcHJvcHMgYWxvbmcgd2l0aCB4LCB5LCBoZWlnaHQgYXMgbnVtYmVycy5cclxuZnVuY3Rpb24gdHlwZUd1YXJkVHJhcGV6b2lkUHJvcHMob3B0aW9uLCBwcm9wcykge1xyXG4gIHZhciB4VmFsdWUgPSBcIlwiLmNvbmNhdChwcm9wcy54IHx8IG9wdGlvbi54KTtcclxuICB2YXIgeCA9IHBhcnNlSW50KHhWYWx1ZSwgMTApO1xyXG4gIHZhciB5VmFsdWUgPSBcIlwiLmNvbmNhdChwcm9wcy55IHx8IG9wdGlvbi55KTtcclxuICB2YXIgeSA9IHBhcnNlSW50KHlWYWx1ZSwgMTApO1xyXG4gIHZhciBoZWlnaHRWYWx1ZSA9IFwiXCIuY29uY2F0KChwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMuaGVpZ2h0KSB8fCAob3B0aW9uID09PSBudWxsIHx8IG9wdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uLmhlaWdodCkpO1xyXG4gIHZhciBoZWlnaHQgPSBwYXJzZUludChoZWlnaHRWYWx1ZSwgMTApO1xyXG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCAoMCwgX0FjdGl2ZVNoYXBlVXRpbHMuZ2V0UHJvcHNGcm9tU2hhcGVPcHRpb24pKG9wdGlvbikpLCB7fSwge1xyXG4gICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICB4OiB4LFxyXG4gICAgeTogeVxyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIEZ1bm5lbFRyYXBlem9pZChwcm9wcykge1xyXG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9BY3RpdmVTaGFwZVV0aWxzLlNoYXBlLCBfZXh0ZW5kcyh7XHJcbiAgICBzaGFwZVR5cGU6IFwidHJhcGV6b2lkXCIsXHJcbiAgICBwcm9wVHJhbnNmb3JtZXI6IHR5cGVHdWFyZFRyYXBlem9pZFByb3BzXHJcbiAgfSwgcHJvcHMpKTtcclxufSJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkZ1bm5lbFRyYXBlem9pZCIsInR5cGVHdWFyZFRyYXBlem9pZFByb3BzIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfQWN0aXZlU2hhcGVVdGlscyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwicHJvdG90eXBlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5Iiwib3duS2V5cyIsImUiLCJyIiwidCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJvcHRpb24iLCJwcm9wcyIsInhWYWx1ZSIsImNvbmNhdCIsIngiLCJwYXJzZUludCIsInlWYWx1ZSIsInkiLCJoZWlnaHRWYWx1ZSIsImhlaWdodCIsImdldFByb3BzRnJvbVNoYXBlT3B0aW9uIiwiY3JlYXRlRWxlbWVudCIsIlNoYXBlIiwic2hhcGVUeXBlIiwicHJvcFRyYW5zZm9ybWVyIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/FunnelUtils.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/Global.js":
/*!**************************************************!*\
  !*** ./node_modules/recharts/lib/util/Global.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Global = void 0;\nvar parseIsSsrByDefault = function parseIsSsrByDefault() {\n    return !( false && 0);\n};\nvar Global = exports.Global = {\n    isSsr: parseIsSsrByDefault(),\n    get: function get(key) {\n        return Global[key];\n    },\n    set: function set(key, value) {\n        if (typeof key === 'string') {\n            Global[key] = value;\n        } else {\n            var keys = Object.keys(key);\n            if (keys && keys.length) {\n                keys.forEach(function(k) {\n                    Global[k] = key[k];\n                });\n            }\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9HbG9iYWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGNBQWMsR0FBRyxLQUFLO0FBQ3RCLElBQUlHLHNCQUFzQixTQUFTQTtJQUNqQyxPQUFPLENBQUUsT0FBaUYsSUFBSUMsQ0FBaUI7QUFDakg7QUFDQSxJQUFJRixTQUFTRixjQUFjLEdBQUc7SUFDNUJRLE9BQU9MO0lBQ1BNLEtBQUssU0FBU0EsSUFBSUMsR0FBRztRQUNuQixPQUFPUixNQUFNLENBQUNRLElBQUk7SUFDcEI7SUFDQUMsS0FBSyxTQUFTQSxJQUFJRCxHQUFHLEVBQUVULEtBQUs7UUFDMUIsSUFBSSxPQUFPUyxRQUFRLFVBQVU7WUFDM0JSLE1BQU0sQ0FBQ1EsSUFBSSxHQUFHVDtRQUNoQixPQUFPO1lBQ0wsSUFBSVcsT0FBT2QsT0FBT2MsSUFBSSxDQUFDRjtZQUN2QixJQUFJRSxRQUFRQSxLQUFLQyxNQUFNLEVBQUU7Z0JBQ3ZCRCxLQUFLRSxPQUFPLENBQUMsU0FBVUMsQ0FBQztvQkFDdEJiLE1BQU0sQ0FBQ2EsRUFBRSxHQUFHTCxHQUFHLENBQUNLLEVBQUU7Z0JBQ3BCO1lBQ0Y7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXHV0aWxcXEdsb2JhbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLkdsb2JhbCA9IHZvaWQgMDtcclxudmFyIHBhcnNlSXNTc3JCeURlZmF1bHQgPSBmdW5jdGlvbiBwYXJzZUlzU3NyQnlEZWZhdWx0KCkge1xyXG4gIHJldHVybiAhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAmJiB3aW5kb3cuc2V0VGltZW91dCk7XHJcbn07XHJcbnZhciBHbG9iYWwgPSBleHBvcnRzLkdsb2JhbCA9IHtcclxuICBpc1NzcjogcGFyc2VJc1NzckJ5RGVmYXVsdCgpLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xyXG4gICAgcmV0dXJuIEdsb2JhbFtrZXldO1xyXG4gIH0sXHJcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIEdsb2JhbFtrZXldID0gdmFsdWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGtleSk7XHJcbiAgICAgIGlmIChrZXlzICYmIGtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgICAgICBHbG9iYWxba10gPSBrZXlba107XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiR2xvYmFsIiwicGFyc2VJc1NzckJ5RGVmYXVsdCIsIndpbmRvdyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNldFRpbWVvdXQiLCJpc1NzciIsImdldCIsImtleSIsInNldCIsImtleXMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiayJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/Global.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/IfOverflowMatches.js":
/*!*************************************************************!*\
  !*** ./node_modules/recharts/lib/util/IfOverflowMatches.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ifOverflowMatches = void 0;\nvar ifOverflowMatches = exports.ifOverflowMatches = function ifOverflowMatches(props, value) {\n    var alwaysShow = props.alwaysShow;\n    var ifOverflow = props.ifOverflow;\n    if (alwaysShow) {\n        ifOverflow = 'extendDomain';\n    }\n    return ifOverflow === value;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9JZk92ZXJmbG93TWF0Y2hlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQseUJBQXlCLEdBQUcsS0FBSztBQUNqQyxJQUFJRSxvQkFBb0JGLHlCQUF5QixHQUFHLFNBQVNFLGtCQUFrQkMsS0FBSyxFQUFFRixLQUFLO0lBQ3pGLElBQUlHLGFBQWFELE1BQU1DLFVBQVU7SUFDakMsSUFBSUMsYUFBYUYsTUFBTUUsVUFBVTtJQUNqQyxJQUFJRCxZQUFZO1FBQ2RDLGFBQWE7SUFDZjtJQUNBLE9BQU9BLGVBQWVKO0FBQ3hCIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFx1dGlsXFxJZk92ZXJmbG93TWF0Y2hlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmlmT3ZlcmZsb3dNYXRjaGVzID0gdm9pZCAwO1xyXG52YXIgaWZPdmVyZmxvd01hdGNoZXMgPSBleHBvcnRzLmlmT3ZlcmZsb3dNYXRjaGVzID0gZnVuY3Rpb24gaWZPdmVyZmxvd01hdGNoZXMocHJvcHMsIHZhbHVlKSB7XHJcbiAgdmFyIGFsd2F5c1Nob3cgPSBwcm9wcy5hbHdheXNTaG93O1xyXG4gIHZhciBpZk92ZXJmbG93ID0gcHJvcHMuaWZPdmVyZmxvdztcclxuICBpZiAoYWx3YXlzU2hvdykge1xyXG4gICAgaWZPdmVyZmxvdyA9ICdleHRlbmREb21haW4nO1xyXG4gIH1cclxuICByZXR1cm4gaWZPdmVyZmxvdyA9PT0gdmFsdWU7XHJcbn07Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaWZPdmVyZmxvd01hdGNoZXMiLCJwcm9wcyIsImFsd2F5c1Nob3ciLCJpZk92ZXJmbG93Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/IfOverflowMatches.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/LogUtils.js":
/*!****************************************************!*\
  !*** ./node_modules/recharts/lib/util/LogUtils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.warn = void 0;\n/* eslint no-console: 0 */ var isDev = \"development\" !== 'production';\nvar warn = exports.warn = function warn(condition, format) {\n    for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n        args[_key - 2] = arguments[_key];\n    }\n    if (isDev && typeof console !== 'undefined' && console.warn) {\n        if (format === undefined) {\n            console.warn('LogUtils requires an error message argument');\n        }\n        if (!condition) {\n            if (format === undefined) {\n                console.warn('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n            } else {\n                var argIndex = 0;\n                console.warn(format.replace(/%s/g, function() {\n                    return args[argIndex++];\n                }));\n            }\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9Mb2dVdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsWUFBWSxHQUFHLEtBQUs7QUFDcEIsd0JBQXdCLEdBQ3hCLElBQUlHLFFBQVFDLGtCQUF5QjtBQUNyQyxJQUFJRixPQUFPRixZQUFZLEdBQUcsU0FBU0UsS0FBS0csU0FBUyxFQUFFQyxNQUFNO0lBQ3ZELElBQUssSUFBSUMsT0FBT0MsVUFBVUMsTUFBTSxFQUFFQyxPQUFPLElBQUlDLE1BQU1KLE9BQU8sSUFBSUEsT0FBTyxJQUFJLElBQUlLLE9BQU8sR0FBR0EsT0FBT0wsTUFBTUssT0FBUTtRQUMxR0YsSUFBSSxDQUFDRSxPQUFPLEVBQUUsR0FBR0osU0FBUyxDQUFDSSxLQUFLO0lBQ2xDO0lBQ0EsSUFBSVQsU0FBUyxPQUFPVSxZQUFZLGVBQWVBLFFBQVFYLElBQUksRUFBRTtRQUMzRCxJQUFJSSxXQUFXUSxXQUFXO1lBQ3hCRCxRQUFRWCxJQUFJLENBQUM7UUFDZjtRQUNBLElBQUksQ0FBQ0csV0FBVztZQUNkLElBQUlDLFdBQVdRLFdBQVc7Z0JBQ3hCRCxRQUFRWCxJQUFJLENBQUMsdUVBQXVFO1lBQ3RGLE9BQU87Z0JBQ0wsSUFBSWEsV0FBVztnQkFDZkYsUUFBUVgsSUFBSSxDQUFDSSxPQUFPVSxPQUFPLENBQUMsT0FBTztvQkFDakMsT0FBT04sSUFBSSxDQUFDSyxXQUFXO2dCQUN6QjtZQUNGO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFx1dGlsXFxMb2dVdGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLndhcm4gPSB2b2lkIDA7XHJcbi8qIGVzbGludCBuby1jb25zb2xlOiAwICovXHJcbnZhciBpc0RldiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbic7XHJcbnZhciB3YXJuID0gZXhwb3J0cy53YXJuID0gZnVuY3Rpb24gd2Fybihjb25kaXRpb24sIGZvcm1hdCkge1xyXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xyXG4gIH1cclxuICBpZiAoaXNEZXYgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2Fybikge1xyXG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignTG9nVXRpbHMgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFjb25kaXRpb24pIHtcclxuICAgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcclxuICAgICAgICBjb25zb2xlLndhcm4oZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ3YXJuIiwiaXNEZXYiLCJwcm9jZXNzIiwiY29uZGl0aW9uIiwiZm9ybWF0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJjb25zb2xlIiwidW5kZWZpbmVkIiwiYXJnSW5kZXgiLCJyZXBsYWNlIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/LogUtils.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/PolarUtils.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/util/PolarUtils.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.radianToDegree = exports.polarToCartesian = exports.inRangeOfSector = exports.getTickClassName = exports.getMaxRadius = exports.getAngleOfPoint = exports.formatAxisMap = exports.formatAngleOfSector = exports.distanceBetweenPoints = exports.degreeToRadian = exports.RADIAN = void 0;\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _react = __webpack_require__(/*! react */ \"react\");\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _DataUtils = __webpack_require__(/*! ./DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ./ChartUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nvar RADIAN = exports.RADIAN = Math.PI / 180;\nvar degreeToRadian = exports.degreeToRadian = function degreeToRadian(angle) {\n    return angle * Math.PI / 180;\n};\nvar radianToDegree = exports.radianToDegree = function radianToDegree(angleInRadian) {\n    return angleInRadian * 180 / Math.PI;\n};\nvar polarToCartesian = exports.polarToCartesian = function polarToCartesian(cx, cy, radius, angle) {\n    return {\n        x: cx + Math.cos(-RADIAN * angle) * radius,\n        y: cy + Math.sin(-RADIAN * angle) * radius\n    };\n};\nvar getMaxRadius = exports.getMaxRadius = function getMaxRadius(width, height) {\n    var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n    };\n    return Math.min(Math.abs(width - (offset.left || 0) - (offset.right || 0)), Math.abs(height - (offset.top || 0) - (offset.bottom || 0))) / 2;\n};\n/**\r\n * Calculate the scale function, position, width, height of axes\r\n * @param  {Object} props     Latest props\r\n * @param  {Object} axisMap   The configuration of axes\r\n * @param  {Object} offset    The offset of main part in the svg element\r\n * @param  {Object} axisType  The type of axes, radius-axis or angle-axis\r\n * @param  {String} chartName The name of chart\r\n * @return {Object} Configuration\r\n */ var formatAxisMap = exports.formatAxisMap = function formatAxisMap(props, axisMap, offset, axisType, chartName) {\n    var width = props.width, height = props.height;\n    var startAngle = props.startAngle, endAngle = props.endAngle;\n    var cx = (0, _DataUtils.getPercentValue)(props.cx, width, width / 2);\n    var cy = (0, _DataUtils.getPercentValue)(props.cy, height, height / 2);\n    var maxRadius = getMaxRadius(width, height, offset);\n    var innerRadius = (0, _DataUtils.getPercentValue)(props.innerRadius, maxRadius, 0);\n    var outerRadius = (0, _DataUtils.getPercentValue)(props.outerRadius, maxRadius, maxRadius * 0.8);\n    var ids = Object.keys(axisMap);\n    return ids.reduce(function(result, id) {\n        var axis = axisMap[id];\n        var domain = axis.domain, reversed = axis.reversed;\n        var range;\n        if ((0, _isNil[\"default\"])(axis.range)) {\n            if (axisType === 'angleAxis') {\n                range = [\n                    startAngle,\n                    endAngle\n                ];\n            } else if (axisType === 'radiusAxis') {\n                range = [\n                    innerRadius,\n                    outerRadius\n                ];\n            }\n            if (reversed) {\n                range = [\n                    range[1],\n                    range[0]\n                ];\n            }\n        } else {\n            range = axis.range;\n            var _range = range;\n            var _range2 = _slicedToArray(_range, 2);\n            startAngle = _range2[0];\n            endAngle = _range2[1];\n        }\n        var _parseScale = (0, _ChartUtils.parseScale)(axis, chartName), realScaleType = _parseScale.realScaleType, scale = _parseScale.scale;\n        scale.domain(domain).range(range);\n        (0, _ChartUtils.checkDomainOfScale)(scale);\n        var ticks = (0, _ChartUtils.getTicksOfScale)(scale, _objectSpread(_objectSpread({}, axis), {}, {\n            realScaleType: realScaleType\n        }));\n        var finalAxis = _objectSpread(_objectSpread(_objectSpread({}, axis), ticks), {}, {\n            range: range,\n            radius: outerRadius,\n            realScaleType: realScaleType,\n            scale: scale,\n            cx: cx,\n            cy: cy,\n            innerRadius: innerRadius,\n            outerRadius: outerRadius,\n            startAngle: startAngle,\n            endAngle: endAngle\n        });\n        return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, id, finalAxis));\n    }, {});\n};\nvar distanceBetweenPoints = exports.distanceBetweenPoints = function distanceBetweenPoints(point, anotherPoint) {\n    var x1 = point.x, y1 = point.y;\n    var x2 = anotherPoint.x, y2 = anotherPoint.y;\n    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n};\nvar getAngleOfPoint = exports.getAngleOfPoint = function getAngleOfPoint(_ref, _ref2) {\n    var x = _ref.x, y = _ref.y;\n    var cx = _ref2.cx, cy = _ref2.cy;\n    var radius = distanceBetweenPoints({\n        x: x,\n        y: y\n    }, {\n        x: cx,\n        y: cy\n    });\n    if (radius <= 0) {\n        return {\n            radius: radius\n        };\n    }\n    var cos = (x - cx) / radius;\n    var angleInRadian = Math.acos(cos);\n    if (y > cy) {\n        angleInRadian = 2 * Math.PI - angleInRadian;\n    }\n    return {\n        radius: radius,\n        angle: radianToDegree(angleInRadian),\n        angleInRadian: angleInRadian\n    };\n};\nvar formatAngleOfSector = exports.formatAngleOfSector = function formatAngleOfSector(_ref3) {\n    var startAngle = _ref3.startAngle, endAngle = _ref3.endAngle;\n    var startCnt = Math.floor(startAngle / 360);\n    var endCnt = Math.floor(endAngle / 360);\n    var min = Math.min(startCnt, endCnt);\n    return {\n        startAngle: startAngle - min * 360,\n        endAngle: endAngle - min * 360\n    };\n};\nvar reverseFormatAngleOfSetor = function reverseFormatAngleOfSetor(angle, _ref4) {\n    var startAngle = _ref4.startAngle, endAngle = _ref4.endAngle;\n    var startCnt = Math.floor(startAngle / 360);\n    var endCnt = Math.floor(endAngle / 360);\n    var min = Math.min(startCnt, endCnt);\n    return angle + min * 360;\n};\nvar inRangeOfSector = exports.inRangeOfSector = function inRangeOfSector(_ref5, sector) {\n    var x = _ref5.x, y = _ref5.y;\n    var _getAngleOfPoint = getAngleOfPoint({\n        x: x,\n        y: y\n    }, sector), radius = _getAngleOfPoint.radius, angle = _getAngleOfPoint.angle;\n    var innerRadius = sector.innerRadius, outerRadius = sector.outerRadius;\n    if (radius < innerRadius || radius > outerRadius) {\n        return false;\n    }\n    if (radius === 0) {\n        return true;\n    }\n    var _formatAngleOfSector = formatAngleOfSector(sector), startAngle = _formatAngleOfSector.startAngle, endAngle = _formatAngleOfSector.endAngle;\n    var formatAngle = angle;\n    var inRange;\n    if (startAngle <= endAngle) {\n        while(formatAngle > endAngle){\n            formatAngle -= 360;\n        }\n        while(formatAngle < startAngle){\n            formatAngle += 360;\n        }\n        inRange = formatAngle >= startAngle && formatAngle <= endAngle;\n    } else {\n        while(formatAngle > startAngle){\n            formatAngle -= 360;\n        }\n        while(formatAngle < endAngle){\n            formatAngle += 360;\n        }\n        inRange = formatAngle >= endAngle && formatAngle <= startAngle;\n    }\n    if (inRange) {\n        return _objectSpread(_objectSpread({}, sector), {}, {\n            radius: radius,\n            angle: reverseFormatAngleOfSetor(formatAngle, sector)\n        });\n    }\n    return null;\n};\nvar getTickClassName = exports.getTickClassName = function getTickClassName(tick) {\n    return !/*#__PURE__*/ (0, _react.isValidElement)(tick) && !(0, _isFunction[\"default\"])(tick) && typeof tick !== 'boolean' ? tick.className : '';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9Qb2xhclV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUUsV0FBVyxLQUFLQyxVQUFVRCxNQUFNQyxPQUFPRSxTQUFTLEdBQUcsV0FBVyxPQUFPSDtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1RJLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxzQkFBc0IsR0FBR0Esd0JBQXdCLEdBQUdBLHVCQUF1QixHQUFHQSx3QkFBd0IsR0FBR0Esb0JBQW9CLEdBQUdBLHVCQUF1QixHQUFHQSxxQkFBcUIsR0FBR0EsMkJBQTJCLEdBQUdBLDZCQUE2QixHQUFHQSxzQkFBc0IsR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDL1IsSUFBSWEsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJQyxTQUFTRCxtQkFBT0EsQ0FBQyxvQkFBTztBQUM1QixJQUFJRSxjQUFjSCx1QkFBdUJDLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJRyxhQUFhSCxtQkFBT0EsQ0FBQyxtRkFBYTtBQUN0QyxJQUFJSSxjQUFjSixtQkFBT0EsQ0FBQyxxRkFBYztBQUN4QyxTQUFTRCx1QkFBdUJNLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UsUUFBUUMsQ0FBQyxFQUFFQyxDQUFDO0lBQUksSUFBSUMsSUFBSTNCLE9BQU80QixJQUFJLENBQUNIO0lBQUksSUFB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dXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcdXRpbFxcUG9sYXJVdGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMucmFkaWFuVG9EZWdyZWUgPSBleHBvcnRzLnBvbGFyVG9DYXJ0ZXNpYW4gPSBleHBvcnRzLmluUmFuZ2VPZlNlY3RvciA9IGV4cG9ydHMuZ2V0VGlja0NsYXNzTmFtZSA9IGV4cG9ydHMuZ2V0TWF4UmFkaXVzID0gZXhwb3J0cy5nZXRBbmdsZU9mUG9pbnQgPSBleHBvcnRzLmZvcm1hdEF4aXNNYXAgPSBleHBvcnRzLmZvcm1hdEFuZ2xlT2ZTZWN0b3IgPSBleHBvcnRzLmRpc3RhbmNlQmV0d2VlblBvaW50cyA9IGV4cG9ydHMuZGVncmVlVG9SYWRpYW4gPSBleHBvcnRzLlJBRElBTiA9IHZvaWQgMDtcclxudmFyIF9pc05pbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc05pbFwiKSk7XHJcbnZhciBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XHJcbnZhciBfaXNGdW5jdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpKTtcclxudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi9EYXRhVXRpbHNcIik7XHJcbnZhciBfQ2hhcnRVdGlscyA9IHJlcXVpcmUoXCIuL0NoYXJ0VXRpbHNcIik7XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxyXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XHJcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XHJcbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XHJcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cclxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XHJcbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XHJcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxyXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cclxudmFyIFJBRElBTiA9IGV4cG9ydHMuUkFESUFOID0gTWF0aC5QSSAvIDE4MDtcclxudmFyIGRlZ3JlZVRvUmFkaWFuID0gZXhwb3J0cy5kZWdyZWVUb1JhZGlhbiA9IGZ1bmN0aW9uIGRlZ3JlZVRvUmFkaWFuKGFuZ2xlKSB7XHJcbiAgcmV0dXJuIGFuZ2xlICogTWF0aC5QSSAvIDE4MDtcclxufTtcclxudmFyIHJhZGlhblRvRGVncmVlID0gZXhwb3J0cy5yYWRpYW5Ub0RlZ3JlZSA9IGZ1bmN0aW9uIHJhZGlhblRvRGVncmVlKGFuZ2xlSW5SYWRpYW4pIHtcclxuICByZXR1cm4gYW5nbGVJblJhZGlhbiAqIDE4MCAvIE1hdGguUEk7XHJcbn07XHJcbnZhciBwb2xhclRvQ2FydGVzaWFuID0gZXhwb3J0cy5wb2xhclRvQ2FydGVzaWFuID0gZnVuY3Rpb24gcG9sYXJUb0NhcnRlc2lhbihjeCwgY3ksIHJhZGl1cywgYW5nbGUpIHtcclxuICByZXR1cm4ge1xyXG4gICAgeDogY3ggKyBNYXRoLmNvcygtUkFESUFOICogYW5nbGUpICogcmFkaXVzLFxyXG4gICAgeTogY3kgKyBNYXRoLnNpbigtUkFESUFOICogYW5nbGUpICogcmFkaXVzXHJcbiAgfTtcclxufTtcclxudmFyIGdldE1heFJhZGl1cyA9IGV4cG9ydHMuZ2V0TWF4UmFkaXVzID0gZnVuY3Rpb24gZ2V0TWF4UmFkaXVzKHdpZHRoLCBoZWlnaHQpIHtcclxuICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7XHJcbiAgICB0b3A6IDAsXHJcbiAgICByaWdodDogMCxcclxuICAgIGJvdHRvbTogMCxcclxuICAgIGxlZnQ6IDBcclxuICB9O1xyXG4gIHJldHVybiBNYXRoLm1pbihNYXRoLmFicyh3aWR0aCAtIChvZmZzZXQubGVmdCB8fCAwKSAtIChvZmZzZXQucmlnaHQgfHwgMCkpLCBNYXRoLmFicyhoZWlnaHQgLSAob2Zmc2V0LnRvcCB8fCAwKSAtIChvZmZzZXQuYm90dG9tIHx8IDApKSkgLyAyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSB0aGUgc2NhbGUgZnVuY3Rpb24sIHBvc2l0aW9uLCB3aWR0aCwgaGVpZ2h0IG9mIGF4ZXNcclxuICogQHBhcmFtICB7T2JqZWN0fSBwcm9wcyAgICAgTGF0ZXN0IHByb3BzXHJcbiAqIEBwYXJhbSAge09iamVjdH0gYXhpc01hcCAgIFRoZSBjb25maWd1cmF0aW9uIG9mIGF4ZXNcclxuICogQHBhcmFtICB7T2JqZWN0fSBvZmZzZXQgICAgVGhlIG9mZnNldCBvZiBtYWluIHBhcnQgaW4gdGhlIHN2ZyBlbGVtZW50XHJcbiAqIEBwYXJhbSAge09iamVjdH0gYXhpc1R5cGUgIFRoZSB0eXBlIG9mIGF4ZXMsIHJhZGl1cy1heGlzIG9yIGFuZ2xlLWF4aXNcclxuICogQHBhcmFtICB7U3RyaW5nfSBjaGFydE5hbWUgVGhlIG5hbWUgb2YgY2hhcnRcclxuICogQHJldHVybiB7T2JqZWN0fSBDb25maWd1cmF0aW9uXHJcbiAqL1xyXG52YXIgZm9ybWF0QXhpc01hcCA9IGV4cG9ydHMuZm9ybWF0QXhpc01hcCA9IGZ1bmN0aW9uIGZvcm1hdEF4aXNNYXAocHJvcHMsIGF4aXNNYXAsIG9mZnNldCwgYXhpc1R5cGUsIGNoYXJ0TmFtZSkge1xyXG4gIHZhciB3aWR0aCA9IHByb3BzLndpZHRoLFxyXG4gICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0O1xyXG4gIHZhciBzdGFydEFuZ2xlID0gcHJvcHMuc3RhcnRBbmdsZSxcclxuICAgIGVuZEFuZ2xlID0gcHJvcHMuZW5kQW5nbGU7XHJcbiAgdmFyIGN4ID0gKDAsIF9EYXRhVXRpbHMuZ2V0UGVyY2VudFZhbHVlKShwcm9wcy5jeCwgd2lkdGgsIHdpZHRoIC8gMik7XHJcbiAgdmFyIGN5ID0gKDAsIF9EYXRhVXRpbHMuZ2V0UGVyY2VudFZhbHVlKShwcm9wcy5jeSwgaGVpZ2h0LCBoZWlnaHQgLyAyKTtcclxuICB2YXIgbWF4UmFkaXVzID0gZ2V0TWF4UmFkaXVzKHdpZHRoLCBoZWlnaHQsIG9mZnNldCk7XHJcbiAgdmFyIGlubmVyUmFkaXVzID0gKDAsIF9EYXRhVXRpbHMuZ2V0UGVyY2VudFZhbHVlKShwcm9wcy5pbm5lclJhZGl1cywgbWF4UmFkaXVzLCAwKTtcclxuICB2YXIgb3V0ZXJSYWRpdXMgPSAoMCwgX0RhdGFVdGlscy5nZXRQZXJjZW50VmFsdWUpKHByb3BzLm91dGVyUmFkaXVzLCBtYXhSYWRpdXMsIG1heFJhZGl1cyAqIDAuOCk7XHJcbiAgdmFyIGlkcyA9IE9iamVjdC5rZXlzKGF4aXNNYXApO1xyXG4gIHJldHVybiBpZHMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGlkKSB7XHJcbiAgICB2YXIgYXhpcyA9IGF4aXNNYXBbaWRdO1xyXG4gICAgdmFyIGRvbWFpbiA9IGF4aXMuZG9tYWluLFxyXG4gICAgICByZXZlcnNlZCA9IGF4aXMucmV2ZXJzZWQ7XHJcbiAgICB2YXIgcmFuZ2U7XHJcbiAgICBpZiAoKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGF4aXMucmFuZ2UpKSB7XHJcbiAgICAgIGlmIChheGlzVHlwZSA9PT0gJ2FuZ2xlQXhpcycpIHtcclxuICAgICAgICByYW5nZSA9IFtzdGFydEFuZ2xlLCBlbmRBbmdsZV07XHJcbiAgICAgIH0gZWxzZSBpZiAoYXhpc1R5cGUgPT09ICdyYWRpdXNBeGlzJykge1xyXG4gICAgICAgIHJhbmdlID0gW2lubmVyUmFkaXVzLCBvdXRlclJhZGl1c107XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJldmVyc2VkKSB7XHJcbiAgICAgICAgcmFuZ2UgPSBbcmFuZ2VbMV0sIHJhbmdlWzBdXTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmFuZ2UgPSBheGlzLnJhbmdlO1xyXG4gICAgICB2YXIgX3JhbmdlID0gcmFuZ2U7XHJcbiAgICAgIHZhciBfcmFuZ2UyID0gX3NsaWNlZFRvQXJyYXkoX3JhbmdlLCAyKTtcclxuICAgICAgc3RhcnRBbmdsZSA9IF9yYW5nZTJbMF07XHJcbiAgICAgIGVuZEFuZ2xlID0gX3JhbmdlMlsxXTtcclxuICAgIH1cclxuICAgIHZhciBfcGFyc2VTY2FsZSA9ICgwLCBfQ2hhcnRVdGlscy5wYXJzZVNjYWxlKShheGlzLCBjaGFydE5hbWUpLFxyXG4gICAgICByZWFsU2NhbGVUeXBlID0gX3BhcnNlU2NhbGUucmVhbFNjYWxlVHlwZSxcclxuICAgICAgc2NhbGUgPSBfcGFyc2VTY2FsZS5zY2FsZTtcclxuICAgIHNjYWxlLmRvbWFpbihkb21haW4pLnJhbmdlKHJhbmdlKTtcclxuICAgICgwLCBfQ2hhcnRVdGlscy5jaGVja0RvbWFpbk9mU2NhbGUpKHNjYWxlKTtcclxuICAgIHZhciB0aWNrcyA9ICgwLCBfQ2hhcnRVdGlscy5nZXRUaWNrc09mU2NhbGUpKHNjYWxlLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGF4aXMpLCB7fSwge1xyXG4gICAgICByZWFsU2NhbGVUeXBlOiByZWFsU2NhbGVUeXBlXHJcbiAgICB9KSk7XHJcbiAgICB2YXIgZmluYWxBeGlzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGF4aXMpLCB0aWNrcyksIHt9LCB7XHJcbiAgICAgIHJhbmdlOiByYW5nZSxcclxuICAgICAgcmFkaXVzOiBvdXRlclJhZGl1cyxcclxuICAgICAgcmVhbFNjYWxlVHlwZTogcmVhbFNjYWxlVHlwZSxcclxuICAgICAgc2NhbGU6IHNjYWxlLFxyXG4gICAgICBjeDogY3gsXHJcbiAgICAgIGN5OiBjeSxcclxuICAgICAgaW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxyXG4gICAgICBvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXHJcbiAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXHJcbiAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXN1bHQpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBpZCwgZmluYWxBeGlzKSk7XHJcbiAgfSwge30pO1xyXG59O1xyXG52YXIgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzID0gZXhwb3J0cy5kaXN0YW5jZUJldHdlZW5Qb2ludHMgPSBmdW5jdGlvbiBkaXN0YW5jZUJldHdlZW5Qb2ludHMocG9pbnQsIGFub3RoZXJQb2ludCkge1xyXG4gIHZhciB4MSA9IHBvaW50LngsXHJcbiAgICB5MSA9IHBvaW50Lnk7XHJcbiAgdmFyIHgyID0gYW5vdGhlclBvaW50LngsXHJcbiAgICB5MiA9IGFub3RoZXJQb2ludC55O1xyXG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MiwgMikgKyBNYXRoLnBvdyh5MSAtIHkyLCAyKSk7XHJcbn07XHJcbnZhciBnZXRBbmdsZU9mUG9pbnQgPSBleHBvcnRzLmdldEFuZ2xlT2ZQb2ludCA9IGZ1bmN0aW9uIGdldEFuZ2xlT2ZQb2ludChfcmVmLCBfcmVmMikge1xyXG4gIHZhciB4ID0gX3JlZi54LFxyXG4gICAgeSA9IF9yZWYueTtcclxuICB2YXIgY3ggPSBfcmVmMi5jeCxcclxuICAgIGN5ID0gX3JlZjIuY3k7XHJcbiAgdmFyIHJhZGl1cyA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyh7XHJcbiAgICB4OiB4LFxyXG4gICAgeTogeVxyXG4gIH0sIHtcclxuICAgIHg6IGN4LFxyXG4gICAgeTogY3lcclxuICB9KTtcclxuICBpZiAocmFkaXVzIDw9IDApIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJhZGl1czogcmFkaXVzXHJcbiAgICB9O1xyXG4gIH1cclxuICB2YXIgY29zID0gKHggLSBjeCkgLyByYWRpdXM7XHJcbiAgdmFyIGFuZ2xlSW5SYWRpYW4gPSBNYXRoLmFjb3MoY29zKTtcclxuICBpZiAoeSA+IGN5KSB7XHJcbiAgICBhbmdsZUluUmFkaWFuID0gMiAqIE1hdGguUEkgLSBhbmdsZUluUmFkaWFuO1xyXG4gIH1cclxuICByZXR1cm4ge1xyXG4gICAgcmFkaXVzOiByYWRpdXMsXHJcbiAgICBhbmdsZTogcmFkaWFuVG9EZWdyZWUoYW5nbGVJblJhZGlhbiksXHJcbiAgICBhbmdsZUluUmFkaWFuOiBhbmdsZUluUmFkaWFuXHJcbiAgfTtcclxufTtcclxudmFyIGZvcm1hdEFuZ2xlT2ZTZWN0b3IgPSBleHBvcnRzLmZvcm1hdEFuZ2xlT2ZTZWN0b3IgPSBmdW5jdGlvbiBmb3JtYXRBbmdsZU9mU2VjdG9yKF9yZWYzKSB7XHJcbiAgdmFyIHN0YXJ0QW5nbGUgPSBfcmVmMy5zdGFydEFuZ2xlLFxyXG4gICAgZW5kQW5nbGUgPSBfcmVmMy5lbmRBbmdsZTtcclxuICB2YXIgc3RhcnRDbnQgPSBNYXRoLmZsb29yKHN0YXJ0QW5nbGUgLyAzNjApO1xyXG4gIHZhciBlbmRDbnQgPSBNYXRoLmZsb29yKGVuZEFuZ2xlIC8gMzYwKTtcclxuICB2YXIgbWluID0gTWF0aC5taW4oc3RhcnRDbnQsIGVuZENudCk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUgLSBtaW4gKiAzNjAsXHJcbiAgICBlbmRBbmdsZTogZW5kQW5nbGUgLSBtaW4gKiAzNjBcclxuICB9O1xyXG59O1xyXG52YXIgcmV2ZXJzZUZvcm1hdEFuZ2xlT2ZTZXRvciA9IGZ1bmN0aW9uIHJldmVyc2VGb3JtYXRBbmdsZU9mU2V0b3IoYW5nbGUsIF9yZWY0KSB7XHJcbiAgdmFyIHN0YXJ0QW5nbGUgPSBfcmVmNC5zdGFydEFuZ2xlLFxyXG4gICAgZW5kQW5nbGUgPSBfcmVmNC5lbmRBbmdsZTtcclxuICB2YXIgc3RhcnRDbnQgPSBNYXRoLmZsb29yKHN0YXJ0QW5nbGUgLyAzNjApO1xyXG4gIHZhciBlbmRDbnQgPSBNYXRoLmZsb29yKGVuZEFuZ2xlIC8gMzYwKTtcclxuICB2YXIgbWluID0gTWF0aC5taW4oc3RhcnRDbnQsIGVuZENudCk7XHJcbiAgcmV0dXJuIGFuZ2xlICsgbWluICogMzYwO1xyXG59O1xyXG52YXIgaW5SYW5nZU9mU2VjdG9yID0gZXhwb3J0cy5pblJhbmdlT2ZTZWN0b3IgPSBmdW5jdGlvbiBpblJhbmdlT2ZTZWN0b3IoX3JlZjUsIHNlY3Rvcikge1xyXG4gIHZhciB4ID0gX3JlZjUueCxcclxuICAgIHkgPSBfcmVmNS55O1xyXG4gIHZhciBfZ2V0QW5nbGVPZlBvaW50ID0gZ2V0QW5nbGVPZlBvaW50KHtcclxuICAgICAgeDogeCxcclxuICAgICAgeTogeVxyXG4gICAgfSwgc2VjdG9yKSxcclxuICAgIHJhZGl1cyA9IF9nZXRBbmdsZU9mUG9pbnQucmFkaXVzLFxyXG4gICAgYW5nbGUgPSBfZ2V0QW5nbGVPZlBvaW50LmFuZ2xlO1xyXG4gIHZhciBpbm5lclJhZGl1cyA9IHNlY3Rvci5pbm5lclJhZGl1cyxcclxuICAgIG91dGVyUmFkaXVzID0gc2VjdG9yLm91dGVyUmFkaXVzO1xyXG4gIGlmIChyYWRpdXMgPCBpbm5lclJhZGl1cyB8fCByYWRpdXMgPiBvdXRlclJhZGl1cykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAocmFkaXVzID09PSAwKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgdmFyIF9mb3JtYXRBbmdsZU9mU2VjdG9yID0gZm9ybWF0QW5nbGVPZlNlY3RvcihzZWN0b3IpLFxyXG4gICAgc3RhcnRBbmdsZSA9IF9mb3JtYXRBbmdsZU9mU2VjdG9yLnN0YXJ0QW5nbGUsXHJcbiAgICBlbmRBbmdsZSA9IF9mb3JtYXRBbmdsZU9mU2VjdG9yLmVuZEFuZ2xlO1xyXG4gIHZhciBmb3JtYXRBbmdsZSA9IGFuZ2xlO1xyXG4gIHZhciBpblJhbmdlO1xyXG4gIGlmIChzdGFydEFuZ2xlIDw9IGVuZEFuZ2xlKSB7XHJcbiAgICB3aGlsZSAoZm9ybWF0QW5nbGUgPiBlbmRBbmdsZSkge1xyXG4gICAgICBmb3JtYXRBbmdsZSAtPSAzNjA7XHJcbiAgICB9XHJcbiAgICB3aGlsZSAoZm9ybWF0QW5nbGUgPCBzdGFydEFuZ2xlKSB7XHJcbiAgICAgIGZvcm1hdEFuZ2xlICs9IDM2MDtcclxuICAgIH1cclxuICAgIGluUmFuZ2UgPSBmb3JtYXRBbmdsZSA+PSBzdGFydEFuZ2xlICYmIGZvcm1hdEFuZ2xlIDw9IGVuZEFuZ2xlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB3aGlsZSAoZm9ybWF0QW5nbGUgPiBzdGFydEFuZ2xlKSB7XHJcbiAgICAgIGZvcm1hdEFuZ2xlIC09IDM2MDtcclxuICAgIH1cclxuICAgIHdoaWxlIChmb3JtYXRBbmdsZSA8IGVuZEFuZ2xlKSB7XHJcbiAgICAgIGZvcm1hdEFuZ2xlICs9IDM2MDtcclxuICAgIH1cclxuICAgIGluUmFuZ2UgPSBmb3JtYXRBbmdsZSA+PSBlbmRBbmdsZSAmJiBmb3JtYXRBbmdsZSA8PSBzdGFydEFuZ2xlO1xyXG4gIH1cclxuICBpZiAoaW5SYW5nZSkge1xyXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc2VjdG9yKSwge30sIHtcclxuICAgICAgcmFkaXVzOiByYWRpdXMsXHJcbiAgICAgIGFuZ2xlOiByZXZlcnNlRm9ybWF0QW5nbGVPZlNldG9yKGZvcm1hdEFuZ2xlLCBzZWN0b3IpXHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn07XHJcbnZhciBnZXRUaWNrQ2xhc3NOYW1lID0gZXhwb3J0cy5nZXRUaWNrQ2xhc3NOYW1lID0gZnVuY3Rpb24gZ2V0VGlja0NsYXNzTmFtZSh0aWNrKSB7XHJcbiAgcmV0dXJuICEgLyojX19QVVJFX18qLygwLCBfcmVhY3QuaXNWYWxpZEVsZW1lbnQpKHRpY2spICYmICEoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKSh0aWNrKSAmJiB0eXBlb2YgdGljayAhPT0gJ2Jvb2xlYW4nID8gdGljay5jbGFzc05hbWUgOiAnJztcclxufTsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicmFkaWFuVG9EZWdyZWUiLCJwb2xhclRvQ2FydGVzaWFuIiwiaW5SYW5nZU9mU2VjdG9yIiwiZ2V0VGlja0NsYXNzTmFtZSIsImdldE1heFJhZGl1cyIsImdldEFuZ2xlT2ZQb2ludCIsImZvcm1hdEF4aXNNYXAiLCJmb3JtYXRBbmdsZU9mU2VjdG9yIiwiZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIiwiZGVncmVlVG9SYWRpYW4iLCJSQURJQU4iLCJfaXNOaWwiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9yZWFjdCIsIl9pc0Z1bmN0aW9uIiwiX0RhdGFVdGlscyIsIl9DaGFydFV0aWxzIiwib2JqIiwiX19lc01vZHVsZSIsIm93bktleXMiLCJlIiwiciIsInQiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJrZXkiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiaSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiY2FsbCIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwibiIsInRvU3RyaW5nIiwic2xpY2UiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsImxlbiIsImFycjIiLCJsIiwidSIsImEiLCJmIiwibmV4dCIsImRvbmUiLCJpc0FycmF5IiwiTWF0aCIsIlBJIiwiYW5nbGUiLCJhbmdsZUluUmFkaWFuIiwiY3giLCJjeSIsInJhZGl1cyIsIngiLCJjb3MiLCJ5Iiwic2luIiwid2lkdGgiLCJoZWlnaHQiLCJvZmZzZXQiLCJ1bmRlZmluZWQiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJtaW4iLCJhYnMiLCJwcm9wcyIsImF4aXNNYXAiLCJheGlzVHlwZSIsImNoYXJ0TmFtZSIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsImdldFBlcmNlbnRWYWx1ZSIsIm1heFJhZGl1cyIsImlubmVyUmFkaXVzIiwib3V0ZXJSYWRpdXMiLCJpZHMiLCJyZWR1Y2UiLCJyZXN1bHQiLCJpZCIsImF4aXMiLCJkb21haW4iLCJyZXZlcnNlZCIsInJhbmdlIiwiX3JhbmdlIiwiX3JhbmdlMiIsIl9wYXJzZVNjYWxlIiwicGFyc2VTY2FsZSIsInJlYWxTY2FsZVR5cGUiLCJzY2FsZSIsImNoZWNrRG9tYWluT2ZTY2FsZSIsInRpY2tzIiwiZ2V0VGlja3NPZlNjYWxlIiwiZmluYWxBeGlzIiwicG9pbnQiLCJhbm90aGVyUG9pbnQiLCJ4MSIsInkxIiwieDIiLCJ5MiIsInNxcnQiLCJwb3ciLCJfcmVmIiwiX3JlZjIiLCJhY29zIiwiX3JlZjMiLCJzdGFydENudCIsImZsb29yIiwiZW5kQ250IiwicmV2ZXJzZUZvcm1hdEFuZ2xlT2ZTZXRvciIsIl9yZWY0IiwiX3JlZjUiLCJzZWN0b3IiLCJfZ2V0QW5nbGVPZlBvaW50IiwiX2Zvcm1hdEFuZ2xlT2ZTZWN0b3IiLCJmb3JtYXRBbmdsZSIsImluUmFuZ2UiLCJ0aWNrIiwiaXNWYWxpZEVsZW1lbnQiLCJjbGFzc05hbWUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/PolarUtils.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/RadialBarUtils.js":
/*!**********************************************************!*\
  !*** ./node_modules/recharts/lib/util/RadialBarUtils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RadialBarSector = RadialBarSector;\nexports.parseCornerRadius = parseCornerRadius;\nexports.typeGuardSectorProps = typeGuardSectorProps;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _ActiveShapeUtils = __webpack_require__(/*! ./ActiveShapeUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ActiveShapeUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction parseCornerRadius(cornerRadius) {\n    if (typeof cornerRadius === 'string') {\n        return parseInt(cornerRadius, 10);\n    }\n    return cornerRadius;\n}\n// Sector props is expecting cx, cy as numbers.\n// When props are being spread in from a user defined component in RadialBar,\n// the prop types of an SVGElement have these typed as string | number.\n// This function will return the passed in props along with cx, cy as numbers.\nfunction typeGuardSectorProps(option, props) {\n    var cxValue = \"\".concat(props.cx || option.cx);\n    var cx = Number(cxValue);\n    var cyValue = \"\".concat(props.cy || option.cy);\n    var cy = Number(cyValue);\n    return _objectSpread(_objectSpread(_objectSpread({}, props), option), {}, {\n        cx: cx,\n        cy: cy\n    });\n}\nfunction RadialBarSector(props) {\n    return /*#__PURE__*/ _react[\"default\"].createElement(_ActiveShapeUtils.Shape, _extends({\n        shapeType: \"sector\",\n        propTransformer: typeGuardSectorProps\n    }, props));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9SYWRpYWxCYXJVdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsdUJBQXVCLEdBQUdFO0FBQzFCRix5QkFBeUIsR0FBR0c7QUFDNUJILDRCQUE0QixHQUFHSTtBQUMvQixJQUFJQyxTQUFTQyx1QkFBdUJDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ25ELElBQUlDLG9CQUFvQkQsbUJBQU9BLENBQUMsaUdBQW9CO0FBQ3BELFNBQVNELHVCQUF1QkcsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRSxXQUFXLEtBQUtDLFVBQVVELE1BQU1DLE9BQU9FLFNBQVMsR0FBRyxXQUFXLE9BQU9IO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSTtJQUFhQSxXQUFXbEIsT0FBT21CLE1BQU0sR0FBR25CLE9BQU9tQixNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVQyxNQUFNO1FBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUFFLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUFFLElBQUssSUFBSUksT0FBT0QsT0FBUTtnQkFBRSxJQUFJekIsT0FBT2lCLFNBQVMsQ0FBQ1UsY0FBYyxDQUFDQyxJQUFJLENBQUNILFFBQVFDLE1BQU07b0JBQUVMLE1BQU0sQ0FBQ0ss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QUFJQSxLQUFLUCxPQUFPSztJQUNoQixJQUFJRyxVQUFVLEdBQUdGLE1BQU0sQ0FBQ0YsTUFBTUssRUFBRSxJQUFJTixPQUFPTSxFQUFFO0lBQzdDLElBQUlBLEtBQUtULE9BQU9RO0lBQ2hCLE9BQU9wQixjQUFjQSxjQUFjQSxjQUFjLENBQUMsR0FBR2dCLFFBQVFELFNBQVMsQ0FBQyxHQUFHO1FBQ3hFSSxJQUFJQTtRQUNKRSxJQUFJQTtJQUNOO0FBQ0Y7QUFDQSxTQUFTekQsZ0JBQWdCb0QsS0FBSztJQUM1QixPQUFPLFdBQVcsR0FBRWpELE1BQU0sQ0FBQyxVQUFVLENBQUN1RCxhQUFhLENBQUNwRCxrQkFBa0JxRCxLQUFLLEVBQUU3QyxTQUFTO1FBQ3BGOEMsV0FBVztRQUNYQyxpQkFBaUIzRDtJQUNuQixHQUFHa0Q7QUFDTCIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcdXRpbFxcUmFkaWFsQmFyVXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5SYWRpYWxCYXJTZWN0b3IgPSBSYWRpYWxCYXJTZWN0b3I7XHJcbmV4cG9ydHMucGFyc2VDb3JuZXJSYWRpdXMgPSBwYXJzZUNvcm5lclJhZGl1cztcclxuZXhwb3J0cy50eXBlR3VhcmRTZWN0b3JQcm9wcyA9IHR5cGVHdWFyZFNlY3RvclByb3BzO1xyXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgX0FjdGl2ZVNoYXBlVXRpbHMgPSByZXF1aXJlKFwiLi9BY3RpdmVTaGFwZVV0aWxzXCIpO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cclxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cclxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxyXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxyXG5mdW5jdGlvbiBwYXJzZUNvcm5lclJhZGl1cyhjb3JuZXJSYWRpdXMpIHtcclxuICBpZiAodHlwZW9mIGNvcm5lclJhZGl1cyA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBwYXJzZUludChjb3JuZXJSYWRpdXMsIDEwKTtcclxuICB9XHJcbiAgcmV0dXJuIGNvcm5lclJhZGl1cztcclxufVxyXG5cclxuLy8gU2VjdG9yIHByb3BzIGlzIGV4cGVjdGluZyBjeCwgY3kgYXMgbnVtYmVycy5cclxuLy8gV2hlbiBwcm9wcyBhcmUgYmVpbmcgc3ByZWFkIGluIGZyb20gYSB1c2VyIGRlZmluZWQgY29tcG9uZW50IGluIFJhZGlhbEJhcixcclxuLy8gdGhlIHByb3AgdHlwZXMgb2YgYW4gU1ZHRWxlbWVudCBoYXZlIHRoZXNlIHR5cGVkIGFzIHN0cmluZyB8IG51bWJlci5cclxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcGFzc2VkIGluIHByb3BzIGFsb25nIHdpdGggY3gsIGN5IGFzIG51bWJlcnMuXHJcbmZ1bmN0aW9uIHR5cGVHdWFyZFNlY3RvclByb3BzKG9wdGlvbiwgcHJvcHMpIHtcclxuICB2YXIgY3hWYWx1ZSA9IFwiXCIuY29uY2F0KHByb3BzLmN4IHx8IG9wdGlvbi5jeCk7XHJcbiAgdmFyIGN4ID0gTnVtYmVyKGN4VmFsdWUpO1xyXG4gIHZhciBjeVZhbHVlID0gXCJcIi5jb25jYXQocHJvcHMuY3kgfHwgb3B0aW9uLmN5KTtcclxuICB2YXIgY3kgPSBOdW1iZXIoY3lWYWx1ZSk7XHJcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIG9wdGlvbiksIHt9LCB7XHJcbiAgICBjeDogY3gsXHJcbiAgICBjeTogY3lcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBSYWRpYWxCYXJTZWN0b3IocHJvcHMpIHtcclxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfQWN0aXZlU2hhcGVVdGlscy5TaGFwZSwgX2V4dGVuZHMoe1xyXG4gICAgc2hhcGVUeXBlOiBcInNlY3RvclwiLFxyXG4gICAgcHJvcFRyYW5zZm9ybWVyOiB0eXBlR3VhcmRTZWN0b3JQcm9wc1xyXG4gIH0sIHByb3BzKSk7XHJcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSYWRpYWxCYXJTZWN0b3IiLCJwYXJzZUNvcm5lclJhZGl1cyIsInR5cGVHdWFyZFNlY3RvclByb3BzIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfQWN0aXZlU2hhcGVVdGlscyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwicHJvdG90eXBlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5Iiwib3duS2V5cyIsImUiLCJyIiwidCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJjb3JuZXJSYWRpdXMiLCJwYXJzZUludCIsIm9wdGlvbiIsInByb3BzIiwiY3hWYWx1ZSIsImNvbmNhdCIsImN4IiwiY3lWYWx1ZSIsImN5IiwiY3JlYXRlRWxlbWVudCIsIlNoYXBlIiwic2hhcGVUeXBlIiwicHJvcFRyYW5zZm9ybWVyIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/RadialBarUtils.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/util/ReactUtils.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.filterSvgElements = exports.filterProps = exports.TOOLTIP_TYPES = exports.SCALE_TYPES = exports.LEGEND_TYPES = void 0;\nexports.findAllByType = findAllByType;\nexports.findChildByType = findChildByType;\nexports.withoutType = exports.validateWidthHeight = exports.toArray = exports.renderByOrder = exports.parseChildIndex = exports.isValidSpreadableProp = exports.isSingleChildEqual = exports.isChildrenEqual = exports.hasClipDot = exports.getReactEventByType = exports.getDisplayName = void 0;\nvar _get = _interopRequireDefault(__webpack_require__(/*! lodash/get */ \"lodash/get\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _isString = _interopRequireDefault(__webpack_require__(/*! lodash/isString */ \"lodash/isString\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _isObject = _interopRequireDefault(__webpack_require__(/*! lodash/isObject */ \"lodash/isObject\"));\nvar _react = __webpack_require__(/*! react */ \"react\");\nvar _reactIs = __webpack_require__(/*! react-is */ \"(pages-dir-node)/./node_modules/recharts/node_modules/react-is/index.js\");\nvar _DataUtils = __webpack_require__(/*! ./DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ShallowEqual = __webpack_require__(/*! ./ShallowEqual */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ShallowEqual.js\");\nvar _types = __webpack_require__(/*! ./types */ \"(pages-dir-node)/./node_modules/recharts/lib/util/types.js\");\nvar _excluded = [\n    \"children\"\n], _excluded2 = [\n    \"children\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nvar REACT_BROWSER_EVENT_MAP = {\n    click: 'onClick',\n    mousedown: 'onMouseDown',\n    mouseup: 'onMouseUp',\n    mouseover: 'onMouseOver',\n    mousemove: 'onMouseMove',\n    mouseout: 'onMouseOut',\n    mouseenter: 'onMouseEnter',\n    mouseleave: 'onMouseLeave',\n    touchcancel: 'onTouchCancel',\n    touchend: 'onTouchEnd',\n    touchmove: 'onTouchMove',\n    touchstart: 'onTouchStart',\n    contextmenu: 'onContextMenu',\n    dblclick: 'onDoubleClick'\n};\nvar SCALE_TYPES = exports.SCALE_TYPES = [\n    'auto',\n    'linear',\n    'pow',\n    'sqrt',\n    'log',\n    'identity',\n    'time',\n    'band',\n    'point',\n    'ordinal',\n    'quantile',\n    'quantize',\n    'utc',\n    'sequential',\n    'threshold'\n];\nvar LEGEND_TYPES = exports.LEGEND_TYPES = [\n    'plainline',\n    'line',\n    'square',\n    'rect',\n    'circle',\n    'cross',\n    'diamond',\n    'star',\n    'triangle',\n    'wye',\n    'none'\n];\nvar TOOLTIP_TYPES = exports.TOOLTIP_TYPES = [\n    'none'\n];\n/**\r\n * Get the display name of a component\r\n * @param  {Object} Comp Specified Component\r\n * @return {String}      Display name of Component\r\n */ var getDisplayName = exports.getDisplayName = function getDisplayName(Comp) {\n    if (typeof Comp === 'string') {\n        return Comp;\n    }\n    if (!Comp) {\n        return '';\n    }\n    return Comp.displayName || Comp.name || 'Component';\n};\n// `toArray` gets called multiple times during the render\n// so we can memoize last invocation (since reference to `children` is the same)\nvar lastChildren = null;\nvar lastResult = null;\nvar toArray = exports.toArray = function toArray(children) {\n    if (children === lastChildren && Array.isArray(lastResult)) {\n        return lastResult;\n    }\n    var result = [];\n    _react.Children.forEach(children, function(child) {\n        if ((0, _isNil[\"default\"])(child)) return;\n        if ((0, _reactIs.isFragment)(child)) {\n            result = result.concat(toArray(child.props.children));\n        } else {\n            // @ts-expect-error this could still be Iterable<ReactNode> and TS does not like that\n            result.push(child);\n        }\n    });\n    lastResult = result;\n    lastChildren = children;\n    return result;\n};\n/*\r\n * Find and return all matched children by type.\r\n * `type` must be a React.ComponentType\r\n */ function findAllByType(children, type) {\n    var result = [];\n    var types = [];\n    if (Array.isArray(type)) {\n        types = type.map(function(t) {\n            return getDisplayName(t);\n        });\n    } else {\n        types = [\n            getDisplayName(type)\n        ];\n    }\n    toArray(children).forEach(function(child) {\n        var childType = (0, _get[\"default\"])(child, 'type.displayName') || (0, _get[\"default\"])(child, 'type.name');\n        if (types.indexOf(childType) !== -1) {\n            result.push(child);\n        }\n    });\n    return result;\n}\n/*\r\n * Return the first matched child by type, return null otherwise.\r\n * `type` must be a React.ComponentType\r\n */ function findChildByType(children, type) {\n    var result = findAllByType(children, type);\n    return result && result[0];\n}\n/*\r\n * Create a new array of children excluding the ones matched the type\r\n */ var withoutType = exports.withoutType = function withoutType(children, type) {\n    var newChildren = [];\n    var types;\n    if (Array.isArray(type)) {\n        types = type.map(function(t) {\n            return getDisplayName(t);\n        });\n    } else {\n        types = [\n            getDisplayName(type)\n        ];\n    }\n    toArray(children).forEach(function(child) {\n        var displayName = (0, _get[\"default\"])(child, 'type.displayName');\n        if (displayName && types.indexOf(displayName) !== -1) {\n            return;\n        }\n        newChildren.push(child);\n    });\n    return newChildren;\n};\n/**\r\n * validate the width and height props of a chart element\r\n * @param  {Object} el A chart element\r\n * @return {Boolean}   true If the props width and height are number, and greater than 0\r\n */ var validateWidthHeight = exports.validateWidthHeight = function validateWidthHeight(el) {\n    if (!el || !el.props) {\n        return false;\n    }\n    var _el$props = el.props, width = _el$props.width, height = _el$props.height;\n    if (!(0, _DataUtils.isNumber)(width) || width <= 0 || !(0, _DataUtils.isNumber)(height) || height <= 0) {\n        return false;\n    }\n    return true;\n};\nvar SVG_TAGS = [\n    'a',\n    'altGlyph',\n    'altGlyphDef',\n    'altGlyphItem',\n    'animate',\n    'animateColor',\n    'animateMotion',\n    'animateTransform',\n    'circle',\n    'clipPath',\n    'color-profile',\n    'cursor',\n    'defs',\n    'desc',\n    'ellipse',\n    'feBlend',\n    'feColormatrix',\n    'feComponentTransfer',\n    'feComposite',\n    'feConvolveMatrix',\n    'feDiffuseLighting',\n    'feDisplacementMap',\n    'feDistantLight',\n    'feFlood',\n    'feFuncA',\n    'feFuncB',\n    'feFuncG',\n    'feFuncR',\n    'feGaussianBlur',\n    'feImage',\n    'feMerge',\n    'feMergeNode',\n    'feMorphology',\n    'feOffset',\n    'fePointLight',\n    'feSpecularLighting',\n    'feSpotLight',\n    'feTile',\n    'feTurbulence',\n    'filter',\n    'font',\n    'font-face',\n    'font-face-format',\n    'font-face-name',\n    'font-face-url',\n    'foreignObject',\n    'g',\n    'glyph',\n    'glyphRef',\n    'hkern',\n    'image',\n    'line',\n    'lineGradient',\n    'marker',\n    'mask',\n    'metadata',\n    'missing-glyph',\n    'mpath',\n    'path',\n    'pattern',\n    'polygon',\n    'polyline',\n    'radialGradient',\n    'rect',\n    'script',\n    'set',\n    'stop',\n    'style',\n    'svg',\n    'switch',\n    'symbol',\n    'text',\n    'textPath',\n    'title',\n    'tref',\n    'tspan',\n    'use',\n    'view',\n    'vkern'\n];\nvar isSvgElement = function isSvgElement(child) {\n    return child && child.type && (0, _isString[\"default\"])(child.type) && SVG_TAGS.indexOf(child.type) >= 0;\n};\nvar hasClipDot = exports.hasClipDot = function hasClipDot(dot) {\n    return dot && _typeof(dot) === 'object' && 'clipDot' in dot;\n};\n/**\r\n * Checks if the property is valid to spread onto an SVG element or onto a specific component\r\n * @param {unknown} property property value currently being compared\r\n * @param {string} key property key currently being compared\r\n * @param {boolean} includeEvents if events are included in spreadable props\r\n * @param {boolean} svgElementType checks against map of SVG element types to attributes\r\n * @returns {boolean} is prop valid\r\n */ var isValidSpreadableProp = exports.isValidSpreadableProp = function isValidSpreadableProp(property, key, includeEvents, svgElementType) {\n    var _FilteredElementKeyMa;\n    /**\r\n   * If the svg element type is explicitly included, check against the filtered element key map\r\n   * to determine if there are attributes that should only exist on that element type.\r\n   * @todo Add an internal cjs version of https://github.com/wooorm/svg-element-attributes for full coverage.\r\n   */ var matchingElementTypeKeys = (_FilteredElementKeyMa = _types.FilteredElementKeyMap === null || _types.FilteredElementKeyMap === void 0 ? void 0 : _types.FilteredElementKeyMap[svgElementType]) !== null && _FilteredElementKeyMa !== void 0 ? _FilteredElementKeyMa : [];\n    return key.startsWith('data-') || !(0, _isFunction[\"default\"])(property) && (svgElementType && matchingElementTypeKeys.includes(key) || _types.SVGElementPropKeys.includes(key)) || includeEvents && _types.EventKeys.includes(key);\n};\n/**\r\n * Filter all the svg elements of children\r\n * @param  {Array} children The children of a react element\r\n * @return {Array}          All the svg elements\r\n */ var filterSvgElements = exports.filterSvgElements = function filterSvgElements(children) {\n    var svgElements = [];\n    toArray(children).forEach(function(entry) {\n        if (isSvgElement(entry)) {\n            svgElements.push(entry);\n        }\n    });\n    return svgElements;\n};\nvar filterProps = exports.filterProps = function filterProps(props, includeEvents, svgElementType) {\n    if (!props || typeof props === 'function' || typeof props === 'boolean') {\n        return null;\n    }\n    var inputProps = props;\n    if (/*#__PURE__*/ (0, _react.isValidElement)(props)) {\n        inputProps = props.props;\n    }\n    if (!(0, _isObject[\"default\"])(inputProps)) {\n        return null;\n    }\n    var out = {};\n    /**\r\n   * Props are blindly spread onto SVG elements. This loop filters out properties that we don't want to spread.\r\n   * Items filtered out are as follows:\r\n   *   - functions in properties that are SVG attributes (functions are included when includeEvents is true)\r\n   *   - props that are SVG attributes but don't matched the passed svgElementType\r\n   *   - any prop that is not in SVGElementPropKeys (or in EventKeys if includeEvents is true)\r\n   */ Object.keys(inputProps).forEach(function(key) {\n        var _inputProps;\n        if (isValidSpreadableProp((_inputProps = inputProps) === null || _inputProps === void 0 ? void 0 : _inputProps[key], key, includeEvents, svgElementType)) {\n            out[key] = inputProps[key];\n        }\n    });\n    return out;\n};\n/**\r\n * Wether props of children changed\r\n * @param  {Object} nextChildren The latest children\r\n * @param  {Object} prevChildren The prev children\r\n * @return {Boolean}             equal or not\r\n */ var isChildrenEqual = exports.isChildrenEqual = function isChildrenEqual(nextChildren, prevChildren) {\n    if (nextChildren === prevChildren) {\n        return true;\n    }\n    var count = _react.Children.count(nextChildren);\n    if (count !== _react.Children.count(prevChildren)) {\n        return false;\n    }\n    if (count === 0) {\n        return true;\n    }\n    if (count === 1) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return isSingleChildEqual(Array.isArray(nextChildren) ? nextChildren[0] : nextChildren, Array.isArray(prevChildren) ? prevChildren[0] : prevChildren);\n    }\n    for(var i = 0; i < count; i++){\n        var nextChild = nextChildren[i];\n        var prevChild = prevChildren[i];\n        if (Array.isArray(nextChild) || Array.isArray(prevChild)) {\n            if (!isChildrenEqual(nextChild, prevChild)) {\n                return false;\n            }\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        } else if (!isSingleChildEqual(nextChild, prevChild)) {\n            return false;\n        }\n    }\n    return true;\n};\nvar isSingleChildEqual = exports.isSingleChildEqual = function isSingleChildEqual(nextChild, prevChild) {\n    if ((0, _isNil[\"default\"])(nextChild) && (0, _isNil[\"default\"])(prevChild)) {\n        return true;\n    }\n    if (!(0, _isNil[\"default\"])(nextChild) && !(0, _isNil[\"default\"])(prevChild)) {\n        var _ref = nextChild.props || {}, nextChildren = _ref.children, nextProps = _objectWithoutProperties(_ref, _excluded);\n        var _ref2 = prevChild.props || {}, prevChildren = _ref2.children, prevProps = _objectWithoutProperties(_ref2, _excluded2);\n        if (nextChildren && prevChildren) {\n            return (0, _ShallowEqual.shallowEqual)(nextProps, prevProps) && isChildrenEqual(nextChildren, prevChildren);\n        }\n        if (!nextChildren && !prevChildren) {\n            return (0, _ShallowEqual.shallowEqual)(nextProps, prevProps);\n        }\n        return false;\n    }\n    return false;\n};\nvar renderByOrder = exports.renderByOrder = function renderByOrder(children, renderMap) {\n    var elements = [];\n    var record = {};\n    toArray(children).forEach(function(child, index) {\n        if (isSvgElement(child)) {\n            elements.push(child);\n        } else if (child) {\n            var displayName = getDisplayName(child.type);\n            var _ref3 = renderMap[displayName] || {}, handler = _ref3.handler, once = _ref3.once;\n            if (handler && (!once || !record[displayName])) {\n                var results = handler(child, displayName, index);\n                elements.push(results);\n                record[displayName] = true;\n            }\n        }\n    });\n    return elements;\n};\nvar getReactEventByType = exports.getReactEventByType = function getReactEventByType(e) {\n    var type = e && e.type;\n    if (type && REACT_BROWSER_EVENT_MAP[type]) {\n        return REACT_BROWSER_EVENT_MAP[type];\n    }\n    return null;\n};\nvar parseChildIndex = exports.parseChildIndex = function parseChildIndex(child, children) {\n    return toArray(children).indexOf(child);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9SZWFjdFV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCx5QkFBeUIsR0FBR0EsbUJBQW1CLEdBQUdBLHFCQUFxQixHQUFHQSxtQkFBbUIsR0FBR0Esb0JBQW9CLEdBQUcsS0FBSztBQUM1SEEscUJBQXFCLEdBQUdPO0FBQ3hCUCx1QkFBdUIsR0FBR1E7QUFDMUJSLG1CQUFtQixHQUFHQSwyQkFBMkIsR0FBR0EsZUFBZSxHQUFHQSxxQkFBcUIsR0FBR0EsdUJBQXVCLEdBQUdBLDZCQUE2QixHQUFHQSwwQkFBMEIsR0FBR0EsdUJBQXVCLEdBQUdBLGtCQUFrQixHQUFHQSwyQkFBMkIsR0FBR0Esc0JBQXNCLEdBQUcsS0FBSztBQUNoUyxJQUFJb0IsT0FBT0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyw4QkFBWTtBQUN0RCxJQUFJQyxTQUFTRix1QkFBdUJDLG1CQUFPQSxDQUFDLGtDQUFjO0FBQzFELElBQUlFLFlBQVlILHVCQUF1QkMsbUJBQU9BLENBQUMsd0NBQWlCO0FBQ2hFLElBQUlHLGNBQWNKLHVCQUF1QkMsbUJBQU9BLENBQUMsNENBQW1CO0FBQ3BFLElBQUlJLFlBQVlMLHVCQUF1QkMsbUJBQU9BLENBQUMsd0NBQWlCO0FBQ2hFLElBQUlLLFNBQVNMLG1CQUFPQSxDQUFDLG9CQUFPO0FBQzVCLElBQUlNLFdBQVdOLG1CQUFPQSxDQUFDLHlGQUFVO0FBQ2pDLElBQUlPLGFBQWFQLG1CQUFPQSxDQUFDLG1GQUFhO0FBQ3RDLElBQUlRLGdCQUFnQlIsbUJBQU9BLENBQUMseUZBQWdCO0FBQzVDLElBQUlTLFNBQVNULG1CQUFPQSxDQUFDLDJFQUFTO0FBQzlCLElBQUlVLFlBQVk7SUFBQztDQUFXLEVBQzFCQyxhQUFhO0lBQUM7Q0FBVztBQUMzQixTQUFTWix1QkFBdUJhLEdBQUc7SUFBSSxPQUFP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M0MsSUFBSSxDQUFDSjtRQUNoQixPQUFPLElBQUlBLE9BQU87WUFDaEIsSUFBSVYsY0FBY3BELGVBQWU4RCxNQUFNSyxJQUFJO1lBQzNDLElBQUk2QyxRQUFRSixTQUFTLENBQUN4RCxZQUFZLElBQUksQ0FBQyxHQUNyQzZELFVBQVVELE1BQU1DLE9BQU8sRUFDdkJDLE9BQU9GLE1BQU1FLElBQUk7WUFDbkIsSUFBSUQsV0FBWSxFQUFDQyxRQUFRLENBQUNKLE1BQU0sQ0FBQzFELFlBQVksR0FBRztnQkFDOUMsSUFBSStELFVBQVVGLFFBQVFuRCxPQUFPVixhQUFhMkQ7Z0JBQzFDRixTQUFTM0MsSUFBSSxDQUFDaUQ7Z0JBQ2RMLE1BQU0sQ0FBQzFELFlBQVksR0FBRztZQUN4QjtRQUNGO0lBQ0Y7SUFDQSxPQUFPeUQ7QUFDVDtBQUNBLElBQUk5RyxzQkFBc0JsQiwyQkFBMkIsR0FBRyxTQUFTa0Isb0JBQW9CcUgsQ0FBQztJQUNwRixJQUFJakQsT0FBT2lELEtBQUtBLEVBQUVqRCxJQUFJO0lBQ3RCLElBQUlBLFFBQVEvQix1QkFBdUIsQ0FBQytCLEtBQUssRUFBRTtRQUN6QyxPQUFPL0IsdUJBQXVCLENBQUMrQixLQUFLO0lBQ3RDO0lBQ0EsT0FBTztBQUNUO0FBQ0EsSUFBSXpFLGtCQUFrQmIsdUJBQXVCLEdBQUcsU0FBU2EsZ0JBQWdCb0UsS0FBSyxFQUFFTixRQUFRO0lBQ3RGLE9BQU9oRSxRQUFRZ0UsVUFBVTdCLE9BQU8sQ0FBQ21DO0FBQ25DIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFx1dGlsXFxSZWFjdFV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZmlsdGVyU3ZnRWxlbWVudHMgPSBleHBvcnRzLmZpbHRlclByb3BzID0gZXhwb3J0cy5UT09MVElQX1RZUEVTID0gZXhwb3J0cy5TQ0FMRV9UWVBFUyA9IGV4cG9ydHMuTEVHRU5EX1RZUEVTID0gdm9pZCAwO1xyXG5leHBvcnRzLmZpbmRBbGxCeVR5cGUgPSBmaW5kQWxsQnlUeXBlO1xyXG5leHBvcnRzLmZpbmRDaGlsZEJ5VHlwZSA9IGZpbmRDaGlsZEJ5VHlwZTtcclxuZXhwb3J0cy53aXRob3V0VHlwZSA9IGV4cG9ydHMudmFsaWRhdGVXaWR0aEhlaWdodCA9IGV4cG9ydHMudG9BcnJheSA9IGV4cG9ydHMucmVuZGVyQnlPcmRlciA9IGV4cG9ydHMucGFyc2VDaGlsZEluZGV4ID0gZXhwb3J0cy5pc1ZhbGlkU3ByZWFkYWJsZVByb3AgPSBleHBvcnRzLmlzU2luZ2xlQ2hpbGRFcXVhbCA9IGV4cG9ydHMuaXNDaGlsZHJlbkVxdWFsID0gZXhwb3J0cy5oYXNDbGlwRG90ID0gZXhwb3J0cy5nZXRSZWFjdEV2ZW50QnlUeXBlID0gZXhwb3J0cy5nZXREaXNwbGF5TmFtZSA9IHZvaWQgMDtcclxudmFyIF9nZXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZ2V0XCIpKTtcclxudmFyIF9pc05pbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc05pbFwiKSk7XHJcbnZhciBfaXNTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNTdHJpbmdcIikpO1xyXG52YXIgX2lzRnVuY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XHJcbnZhciBfaXNPYmplY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNPYmplY3RcIikpO1xyXG52YXIgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG52YXIgX3JlYWN0SXMgPSByZXF1aXJlKFwicmVhY3QtaXNcIik7XHJcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4vRGF0YVV0aWxzXCIpO1xyXG52YXIgX1NoYWxsb3dFcXVhbCA9IHJlcXVpcmUoXCIuL1NoYWxsb3dFcXVhbFwiKTtcclxudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xyXG52YXIgX2V4Y2x1ZGVkID0gW1wiY2hpbGRyZW5cIl0sXHJcbiAgX2V4Y2x1ZGVkMiA9IFtcImNoaWxkcmVuXCJdO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbnZhciBSRUFDVF9CUk9XU0VSX0VWRU5UX01BUCA9IHtcclxuICBjbGljazogJ29uQ2xpY2snLFxyXG4gIG1vdXNlZG93bjogJ29uTW91c2VEb3duJyxcclxuICBtb3VzZXVwOiAnb25Nb3VzZVVwJyxcclxuICBtb3VzZW92ZXI6ICdvbk1vdXNlT3ZlcicsXHJcbiAgbW91c2Vtb3ZlOiAnb25Nb3VzZU1vdmUnLFxyXG4gIG1vdXNlb3V0OiAnb25Nb3VzZU91dCcsXHJcbiAgbW91c2VlbnRlcjogJ29uTW91c2VFbnRlcicsXHJcbiAgbW91c2VsZWF2ZTogJ29uTW91c2VMZWF2ZScsXHJcbiAgdG91Y2hjYW5jZWw6ICdvblRvdWNoQ2FuY2VsJyxcclxuICB0b3VjaGVuZDogJ29uVG91Y2hFbmQnLFxyXG4gIHRvdWNobW92ZTogJ29uVG91Y2hNb3ZlJyxcclxuICB0b3VjaHN0YXJ0OiAnb25Ub3VjaFN0YXJ0JyxcclxuICBjb250ZXh0bWVudTogJ29uQ29udGV4dE1lbnUnLFxyXG4gIGRibGNsaWNrOiAnb25Eb3VibGVDbGljaydcclxufTtcclxudmFyIFNDQUxFX1RZUEVTID0gZXhwb3J0cy5TQ0FMRV9UWVBFUyA9IFsnYXV0bycsICdsaW5lYXInLCAncG93JywgJ3NxcnQnLCAnbG9nJywgJ2lkZW50aXR5JywgJ3RpbWUnLCAnYmFuZCcsICdwb2ludCcsICdvcmRpbmFsJywgJ3F1YW50aWxlJywgJ3F1YW50aXplJywgJ3V0YycsICdzZXF1ZW50aWFsJywgJ3RocmVzaG9sZCddO1xyXG52YXIgTEVHRU5EX1RZUEVTID0gZXhwb3J0cy5MRUdFTkRfVFlQRVMgPSBbJ3BsYWlubGluZScsICdsaW5lJywgJ3NxdWFyZScsICdyZWN0JywgJ2NpcmNsZScsICdjcm9zcycsICdkaWFtb25kJywgJ3N0YXInLCAndHJpYW5nbGUnLCAnd3llJywgJ25vbmUnXTtcclxudmFyIFRPT0xUSVBfVFlQRVMgPSBleHBvcnRzLlRPT0xUSVBfVFlQRVMgPSBbJ25vbmUnXTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGRpc3BsYXkgbmFtZSBvZiBhIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IENvbXAgU3BlY2lmaWVkIENvbXBvbmVudFxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgRGlzcGxheSBuYW1lIG9mIENvbXBvbmVudFxyXG4gKi9cclxudmFyIGdldERpc3BsYXlOYW1lID0gZXhwb3J0cy5nZXREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKENvbXApIHtcclxuICBpZiAodHlwZW9mIENvbXAgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gQ29tcDtcclxuICB9XHJcbiAgaWYgKCFDb21wKSB7XHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfVxyXG4gIHJldHVybiBDb21wLmRpc3BsYXlOYW1lIHx8IENvbXAubmFtZSB8fCAnQ29tcG9uZW50JztcclxufTtcclxuXHJcbi8vIGB0b0FycmF5YCBnZXRzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgdGhlIHJlbmRlclxyXG4vLyBzbyB3ZSBjYW4gbWVtb2l6ZSBsYXN0IGludm9jYXRpb24gKHNpbmNlIHJlZmVyZW5jZSB0byBgY2hpbGRyZW5gIGlzIHRoZSBzYW1lKVxyXG52YXIgbGFzdENoaWxkcmVuID0gbnVsbDtcclxudmFyIGxhc3RSZXN1bHQgPSBudWxsO1xyXG52YXIgdG9BcnJheSA9IGV4cG9ydHMudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcclxuICBpZiAoY2hpbGRyZW4gPT09IGxhc3RDaGlsZHJlbiAmJiBBcnJheS5pc0FycmF5KGxhc3RSZXN1bHQpKSB7XHJcbiAgICByZXR1cm4gbGFzdFJlc3VsdDtcclxuICB9XHJcbiAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gIF9yZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgIGlmICgoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoY2hpbGQpKSByZXR1cm47XHJcbiAgICBpZiAoKDAsIF9yZWFjdElzLmlzRnJhZ21lbnQpKGNoaWxkKSkge1xyXG4gICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRvQXJyYXkoY2hpbGQucHJvcHMuY2hpbGRyZW4pKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdGhpcyBjb3VsZCBzdGlsbCBiZSBJdGVyYWJsZTxSZWFjdE5vZGU+IGFuZCBUUyBkb2VzIG5vdCBsaWtlIHRoYXRcclxuICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIGxhc3RSZXN1bHQgPSByZXN1bHQ7XHJcbiAgbGFzdENoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qXHJcbiAqIEZpbmQgYW5kIHJldHVybiBhbGwgbWF0Y2hlZCBjaGlsZHJlbiBieSB0eXBlLlxyXG4gKiBgdHlwZWAgbXVzdCBiZSBhIFJlYWN0LkNvbXBvbmVudFR5cGVcclxuICovXHJcbmZ1bmN0aW9uIGZpbmRBbGxCeVR5cGUoY2hpbGRyZW4sIHR5cGUpIHtcclxuICB2YXIgcmVzdWx0ID0gW107XHJcbiAgdmFyIHR5cGVzID0gW107XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcclxuICAgIHR5cGVzID0gdHlwZS5tYXAoZnVuY3Rpb24gKHQpIHtcclxuICAgICAgcmV0dXJuIGdldERpc3BsYXlOYW1lKHQpO1xyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHR5cGVzID0gW2dldERpc3BsYXlOYW1lKHR5cGUpXTtcclxuICB9XHJcbiAgdG9BcnJheShjaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgIHZhciBjaGlsZFR5cGUgPSAoMCwgX2dldFtcImRlZmF1bHRcIl0pKGNoaWxkLCAndHlwZS5kaXNwbGF5TmFtZScpIHx8ICgwLCBfZ2V0W1wiZGVmYXVsdFwiXSkoY2hpbGQsICd0eXBlLm5hbWUnKTtcclxuICAgIGlmICh0eXBlcy5pbmRleE9mKGNoaWxkVHlwZSkgIT09IC0xKSB7XHJcbiAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdGhlIGZpcnN0IG1hdGNoZWQgY2hpbGQgYnkgdHlwZSwgcmV0dXJuIG51bGwgb3RoZXJ3aXNlLlxyXG4gKiBgdHlwZWAgbXVzdCBiZSBhIFJlYWN0LkNvbXBvbmVudFR5cGVcclxuICovXHJcbmZ1bmN0aW9uIGZpbmRDaGlsZEJ5VHlwZShjaGlsZHJlbiwgdHlwZSkge1xyXG4gIHZhciByZXN1bHQgPSBmaW5kQWxsQnlUeXBlKGNoaWxkcmVuLCB0eXBlKTtcclxuICByZXR1cm4gcmVzdWx0ICYmIHJlc3VsdFswXTtcclxufVxyXG5cclxuLypcclxuICogQ3JlYXRlIGEgbmV3IGFycmF5IG9mIGNoaWxkcmVuIGV4Y2x1ZGluZyB0aGUgb25lcyBtYXRjaGVkIHRoZSB0eXBlXHJcbiAqL1xyXG52YXIgd2l0aG91dFR5cGUgPSBleHBvcnRzLndpdGhvdXRUeXBlID0gZnVuY3Rpb24gd2l0aG91dFR5cGUoY2hpbGRyZW4sIHR5cGUpIHtcclxuICB2YXIgbmV3Q2hpbGRyZW4gPSBbXTtcclxuICB2YXIgdHlwZXM7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcclxuICAgIHR5cGVzID0gdHlwZS5tYXAoZnVuY3Rpb24gKHQpIHtcclxuICAgICAgcmV0dXJuIGdldERpc3BsYXlOYW1lKHQpO1xyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHR5cGVzID0gW2dldERpc3BsYXlOYW1lKHR5cGUpXTtcclxuICB9XHJcbiAgdG9BcnJheShjaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgIHZhciBkaXNwbGF5TmFtZSA9ICgwLCBfZ2V0W1wiZGVmYXVsdFwiXSkoY2hpbGQsICd0eXBlLmRpc3BsYXlOYW1lJyk7XHJcbiAgICBpZiAoZGlzcGxheU5hbWUgJiYgdHlwZXMuaW5kZXhPZihkaXNwbGF5TmFtZSkgIT09IC0xKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIG5ld0NoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG4gIH0pO1xyXG4gIHJldHVybiBuZXdDaGlsZHJlbjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiB2YWxpZGF0ZSB0aGUgd2lkdGggYW5kIGhlaWdodCBwcm9wcyBvZiBhIGNoYXJ0IGVsZW1lbnRcclxuICogQHBhcmFtICB7T2JqZWN0fSBlbCBBIGNoYXJ0IGVsZW1lbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn0gICB0cnVlIElmIHRoZSBwcm9wcyB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBudW1iZXIsIGFuZCBncmVhdGVyIHRoYW4gMFxyXG4gKi9cclxudmFyIHZhbGlkYXRlV2lkdGhIZWlnaHQgPSBleHBvcnRzLnZhbGlkYXRlV2lkdGhIZWlnaHQgPSBmdW5jdGlvbiB2YWxpZGF0ZVdpZHRoSGVpZ2h0KGVsKSB7XHJcbiAgaWYgKCFlbCB8fCAhZWwucHJvcHMpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgdmFyIF9lbCRwcm9wcyA9IGVsLnByb3BzLFxyXG4gICAgd2lkdGggPSBfZWwkcHJvcHMud2lkdGgsXHJcbiAgICBoZWlnaHQgPSBfZWwkcHJvcHMuaGVpZ2h0O1xyXG4gIGlmICghKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHdpZHRoKSB8fCB3aWR0aCA8PSAwIHx8ICEoMCwgX0RhdGFVdGlscy5pc051bWJlcikoaGVpZ2h0KSB8fCBoZWlnaHQgPD0gMCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxudmFyIFNWR19UQUdTID0gWydhJywgJ2FsdEdseXBoJywgJ2FsdEdseXBoRGVmJywgJ2FsdEdseXBoSXRlbScsICdhbmltYXRlJywgJ2FuaW1hdGVDb2xvcicsICdhbmltYXRlTW90aW9uJywgJ2FuaW1hdGVUcmFuc2Zvcm0nLCAnY2lyY2xlJywgJ2NsaXBQYXRoJywgJ2NvbG9yLXByb2ZpbGUnLCAnY3Vyc29yJywgJ2RlZnMnLCAnZGVzYycsICdlbGxpcHNlJywgJ2ZlQmxlbmQnLCAnZmVDb2xvcm1hdHJpeCcsICdmZUNvbXBvbmVudFRyYW5zZmVyJywgJ2ZlQ29tcG9zaXRlJywgJ2ZlQ29udm9sdmVNYXRyaXgnLCAnZmVEaWZmdXNlTGlnaHRpbmcnLCAnZmVEaXNwbGFjZW1lbnRNYXAnLCAnZmVEaXN0YW50TGlnaHQnLCAnZmVGbG9vZCcsICdmZUZ1bmNBJywgJ2ZlRnVuY0InLCAnZmVGdW5jRycsICdmZUZ1bmNSJywgJ2ZlR2F1c3NpYW5CbHVyJywgJ2ZlSW1hZ2UnLCAnZmVNZXJnZScsICdmZU1lcmdlTm9kZScsICdmZU1vcnBob2xvZ3knLCAnZmVPZmZzZXQnLCAnZmVQb2ludExpZ2h0JywgJ2ZlU3BlY3VsYXJMaWdodGluZycsICdmZVNwb3RMaWdodCcsICdmZVRpbGUnLCAnZmVUdXJidWxlbmNlJywgJ2ZpbHRlcicsICdmb250JywgJ2ZvbnQtZmFjZScsICdmb250LWZhY2UtZm9ybWF0JywgJ2ZvbnQtZmFjZS1uYW1lJywgJ2ZvbnQtZmFjZS11cmwnLCAnZm9yZWlnbk9iamVjdCcsICdnJywgJ2dseXBoJywgJ2dseXBoUmVmJywgJ2hrZXJuJywgJ2ltYWdlJywgJ2xpbmUnLCAnbGluZUdyYWRpZW50JywgJ21hcmtlcicsICdtYXNrJywgJ21ldGFkYXRhJywgJ21pc3NpbmctZ2x5cGgnLCAnbXBhdGgnLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsR3JhZGllbnQnLCAncmVjdCcsICdzY3JpcHQnLCAnc2V0JywgJ3N0b3AnLCAnc3R5bGUnLCAnc3ZnJywgJ3N3aXRjaCcsICdzeW1ib2wnLCAndGV4dCcsICd0ZXh0UGF0aCcsICd0aXRsZScsICd0cmVmJywgJ3RzcGFuJywgJ3VzZScsICd2aWV3JywgJ3ZrZXJuJ107XHJcbnZhciBpc1N2Z0VsZW1lbnQgPSBmdW5jdGlvbiBpc1N2Z0VsZW1lbnQoY2hpbGQpIHtcclxuICByZXR1cm4gY2hpbGQgJiYgY2hpbGQudHlwZSAmJiAoMCwgX2lzU3RyaW5nW1wiZGVmYXVsdFwiXSkoY2hpbGQudHlwZSkgJiYgU1ZHX1RBR1MuaW5kZXhPZihjaGlsZC50eXBlKSA+PSAwO1xyXG59O1xyXG52YXIgaGFzQ2xpcERvdCA9IGV4cG9ydHMuaGFzQ2xpcERvdCA9IGZ1bmN0aW9uIGhhc0NsaXBEb3QoZG90KSB7XHJcbiAgcmV0dXJuIGRvdCAmJiBfdHlwZW9mKGRvdCkgPT09ICdvYmplY3QnICYmICdjbGlwRG90JyBpbiBkb3Q7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIHRoZSBwcm9wZXJ0eSBpcyB2YWxpZCB0byBzcHJlYWQgb250byBhbiBTVkcgZWxlbWVudCBvciBvbnRvIGEgc3BlY2lmaWMgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7dW5rbm93bn0gcHJvcGVydHkgcHJvcGVydHkgdmFsdWUgY3VycmVudGx5IGJlaW5nIGNvbXBhcmVkXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgcHJvcGVydHkga2V5IGN1cnJlbnRseSBiZWluZyBjb21wYXJlZFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVFdmVudHMgaWYgZXZlbnRzIGFyZSBpbmNsdWRlZCBpbiBzcHJlYWRhYmxlIHByb3BzXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3ZnRWxlbWVudFR5cGUgY2hlY2tzIGFnYWluc3QgbWFwIG9mIFNWRyBlbGVtZW50IHR5cGVzIHRvIGF0dHJpYnV0ZXNcclxuICogQHJldHVybnMge2Jvb2xlYW59IGlzIHByb3AgdmFsaWRcclxuICovXHJcbnZhciBpc1ZhbGlkU3ByZWFkYWJsZVByb3AgPSBleHBvcnRzLmlzVmFsaWRTcHJlYWRhYmxlUHJvcCA9IGZ1bmN0aW9uIGlzVmFsaWRTcHJlYWRhYmxlUHJvcChwcm9wZXJ0eSwga2V5LCBpbmNsdWRlRXZlbnRzLCBzdmdFbGVtZW50VHlwZSkge1xyXG4gIHZhciBfRmlsdGVyZWRFbGVtZW50S2V5TWE7XHJcbiAgLyoqXHJcbiAgICogSWYgdGhlIHN2ZyBlbGVtZW50IHR5cGUgaXMgZXhwbGljaXRseSBpbmNsdWRlZCwgY2hlY2sgYWdhaW5zdCB0aGUgZmlsdGVyZWQgZWxlbWVudCBrZXkgbWFwXHJcbiAgICogdG8gZGV0ZXJtaW5lIGlmIHRoZXJlIGFyZSBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIG9ubHkgZXhpc3Qgb24gdGhhdCBlbGVtZW50IHR5cGUuXHJcbiAgICogQHRvZG8gQWRkIGFuIGludGVybmFsIGNqcyB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS93b29vcm0vc3ZnLWVsZW1lbnQtYXR0cmlidXRlcyBmb3IgZnVsbCBjb3ZlcmFnZS5cclxuICAgKi9cclxuICB2YXIgbWF0Y2hpbmdFbGVtZW50VHlwZUtleXMgPSAoX0ZpbHRlcmVkRWxlbWVudEtleU1hID0gX3R5cGVzLkZpbHRlcmVkRWxlbWVudEtleU1hcCA9PT0gbnVsbCB8fCBfdHlwZXMuRmlsdGVyZWRFbGVtZW50S2V5TWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdHlwZXMuRmlsdGVyZWRFbGVtZW50S2V5TWFwW3N2Z0VsZW1lbnRUeXBlXSkgIT09IG51bGwgJiYgX0ZpbHRlcmVkRWxlbWVudEtleU1hICE9PSB2b2lkIDAgPyBfRmlsdGVyZWRFbGVtZW50S2V5TWEgOiBbXTtcclxuICByZXR1cm4ga2V5LnN0YXJ0c1dpdGgoJ2RhdGEtJykgfHwgISgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKHByb3BlcnR5KSAmJiAoc3ZnRWxlbWVudFR5cGUgJiYgbWF0Y2hpbmdFbGVtZW50VHlwZUtleXMuaW5jbHVkZXMoa2V5KSB8fCBfdHlwZXMuU1ZHRWxlbWVudFByb3BLZXlzLmluY2x1ZGVzKGtleSkpIHx8IGluY2x1ZGVFdmVudHMgJiYgX3R5cGVzLkV2ZW50S2V5cy5pbmNsdWRlcyhrZXkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZpbHRlciBhbGwgdGhlIHN2ZyBlbGVtZW50cyBvZiBjaGlsZHJlblxyXG4gKiBAcGFyYW0gIHtBcnJheX0gY2hpbGRyZW4gVGhlIGNoaWxkcmVuIG9mIGEgcmVhY3QgZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgQWxsIHRoZSBzdmcgZWxlbWVudHNcclxuICovXHJcbnZhciBmaWx0ZXJTdmdFbGVtZW50cyA9IGV4cG9ydHMuZmlsdGVyU3ZnRWxlbWVudHMgPSBmdW5jdGlvbiBmaWx0ZXJTdmdFbGVtZW50cyhjaGlsZHJlbikge1xyXG4gIHZhciBzdmdFbGVtZW50cyA9IFtdO1xyXG4gIHRvQXJyYXkoY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICBpZiAoaXNTdmdFbGVtZW50KGVudHJ5KSkge1xyXG4gICAgICBzdmdFbGVtZW50cy5wdXNoKGVudHJ5KTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gc3ZnRWxlbWVudHM7XHJcbn07XHJcbnZhciBmaWx0ZXJQcm9wcyA9IGV4cG9ydHMuZmlsdGVyUHJvcHMgPSBmdW5jdGlvbiBmaWx0ZXJQcm9wcyhwcm9wcywgaW5jbHVkZUV2ZW50cywgc3ZnRWxlbWVudFR5cGUpIHtcclxuICBpZiAoIXByb3BzIHx8IHR5cGVvZiBwcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcHJvcHMgPT09ICdib29sZWFuJykge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHZhciBpbnB1dFByb3BzID0gcHJvcHM7XHJcbiAgaWYgKCAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5pc1ZhbGlkRWxlbWVudCkocHJvcHMpKSB7XHJcbiAgICBpbnB1dFByb3BzID0gcHJvcHMucHJvcHM7XHJcbiAgfVxyXG4gIGlmICghKDAsIF9pc09iamVjdFtcImRlZmF1bHRcIl0pKGlucHV0UHJvcHMpKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgdmFyIG91dCA9IHt9O1xyXG5cclxuICAvKipcclxuICAgKiBQcm9wcyBhcmUgYmxpbmRseSBzcHJlYWQgb250byBTVkcgZWxlbWVudHMuIFRoaXMgbG9vcCBmaWx0ZXJzIG91dCBwcm9wZXJ0aWVzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0byBzcHJlYWQuXHJcbiAgICogSXRlbXMgZmlsdGVyZWQgb3V0IGFyZSBhcyBmb2xsb3dzOlxyXG4gICAqICAgLSBmdW5jdGlvbnMgaW4gcHJvcGVydGllcyB0aGF0IGFyZSBTVkcgYXR0cmlidXRlcyAoZnVuY3Rpb25zIGFyZSBpbmNsdWRlZCB3aGVuIGluY2x1ZGVFdmVudHMgaXMgdHJ1ZSlcclxuICAgKiAgIC0gcHJvcHMgdGhhdCBhcmUgU1ZHIGF0dHJpYnV0ZXMgYnV0IGRvbid0IG1hdGNoZWQgdGhlIHBhc3NlZCBzdmdFbGVtZW50VHlwZVxyXG4gICAqICAgLSBhbnkgcHJvcCB0aGF0IGlzIG5vdCBpbiBTVkdFbGVtZW50UHJvcEtleXMgKG9yIGluIEV2ZW50S2V5cyBpZiBpbmNsdWRlRXZlbnRzIGlzIHRydWUpXHJcbiAgICovXHJcbiAgT2JqZWN0LmtleXMoaW5wdXRQcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICB2YXIgX2lucHV0UHJvcHM7XHJcbiAgICBpZiAoaXNWYWxpZFNwcmVhZGFibGVQcm9wKChfaW5wdXRQcm9wcyA9IGlucHV0UHJvcHMpID09PSBudWxsIHx8IF9pbnB1dFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW5wdXRQcm9wc1trZXldLCBrZXksIGluY2x1ZGVFdmVudHMsIHN2Z0VsZW1lbnRUeXBlKSkge1xyXG4gICAgICBvdXRba2V5XSA9IGlucHV0UHJvcHNba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdldGhlciBwcm9wcyBvZiBjaGlsZHJlbiBjaGFuZ2VkXHJcbiAqIEBwYXJhbSAge09iamVjdH0gbmV4dENoaWxkcmVuIFRoZSBsYXRlc3QgY2hpbGRyZW5cclxuICogQHBhcmFtICB7T2JqZWN0fSBwcmV2Q2hpbGRyZW4gVGhlIHByZXYgY2hpbGRyZW5cclxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgZXF1YWwgb3Igbm90XHJcbiAqL1xyXG52YXIgaXNDaGlsZHJlbkVxdWFsID0gZXhwb3J0cy5pc0NoaWxkcmVuRXF1YWwgPSBmdW5jdGlvbiBpc0NoaWxkcmVuRXF1YWwobmV4dENoaWxkcmVuLCBwcmV2Q2hpbGRyZW4pIHtcclxuICBpZiAobmV4dENoaWxkcmVuID09PSBwcmV2Q2hpbGRyZW4pIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICB2YXIgY291bnQgPSBfcmVhY3QuQ2hpbGRyZW4uY291bnQobmV4dENoaWxkcmVuKTtcclxuICBpZiAoY291bnQgIT09IF9yZWFjdC5DaGlsZHJlbi5jb3VudChwcmV2Q2hpbGRyZW4pKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGlmIChjb3VudCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIGlmIChjb3VudCA9PT0gMSkge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxyXG4gICAgcmV0dXJuIGlzU2luZ2xlQ2hpbGRFcXVhbChBcnJheS5pc0FycmF5KG5leHRDaGlsZHJlbikgPyBuZXh0Q2hpbGRyZW5bMF0gOiBuZXh0Q2hpbGRyZW4sIEFycmF5LmlzQXJyYXkocHJldkNoaWxkcmVuKSA/IHByZXZDaGlsZHJlblswXSA6IHByZXZDaGlsZHJlbik7XHJcbiAgfVxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgdmFyIG5leHRDaGlsZCA9IG5leHRDaGlsZHJlbltpXTtcclxuICAgIHZhciBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW5baV07XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXh0Q2hpbGQpIHx8IEFycmF5LmlzQXJyYXkocHJldkNoaWxkKSkge1xyXG4gICAgICBpZiAoIWlzQ2hpbGRyZW5FcXVhbChuZXh0Q2hpbGQsIHByZXZDaGlsZCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxyXG4gICAgfSBlbHNlIGlmICghaXNTaW5nbGVDaGlsZEVxdWFsKG5leHRDaGlsZCwgcHJldkNoaWxkKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG52YXIgaXNTaW5nbGVDaGlsZEVxdWFsID0gZXhwb3J0cy5pc1NpbmdsZUNoaWxkRXF1YWwgPSBmdW5jdGlvbiBpc1NpbmdsZUNoaWxkRXF1YWwobmV4dENoaWxkLCBwcmV2Q2hpbGQpIHtcclxuICBpZiAoKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKG5leHRDaGlsZCkgJiYgKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKHByZXZDaGlsZCkpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBpZiAoISgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShuZXh0Q2hpbGQpICYmICEoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkocHJldkNoaWxkKSkge1xyXG4gICAgdmFyIF9yZWYgPSBuZXh0Q2hpbGQucHJvcHMgfHwge30sXHJcbiAgICAgIG5leHRDaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXHJcbiAgICAgIG5leHRQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQpO1xyXG4gICAgdmFyIF9yZWYyID0gcHJldkNoaWxkLnByb3BzIHx8IHt9LFxyXG4gICAgICBwcmV2Q2hpbGRyZW4gPSBfcmVmMi5jaGlsZHJlbixcclxuICAgICAgcHJldlByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBfZXhjbHVkZWQyKTtcclxuICAgIGlmIChuZXh0Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuKSB7XHJcbiAgICAgIHJldHVybiAoMCwgX1NoYWxsb3dFcXVhbC5zaGFsbG93RXF1YWwpKG5leHRQcm9wcywgcHJldlByb3BzKSAmJiBpc0NoaWxkcmVuRXF1YWwobmV4dENoaWxkcmVuLCBwcmV2Q2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgaWYgKCFuZXh0Q2hpbGRyZW4gJiYgIXByZXZDaGlsZHJlbikge1xyXG4gICAgICByZXR1cm4gKDAsIF9TaGFsbG93RXF1YWwuc2hhbGxvd0VxdWFsKShuZXh0UHJvcHMsIHByZXZQcm9wcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufTtcclxudmFyIHJlbmRlckJ5T3JkZXIgPSBleHBvcnRzLnJlbmRlckJ5T3JkZXIgPSBmdW5jdGlvbiByZW5kZXJCeU9yZGVyKGNoaWxkcmVuLCByZW5kZXJNYXApIHtcclxuICB2YXIgZWxlbWVudHMgPSBbXTtcclxuICB2YXIgcmVjb3JkID0ge307XHJcbiAgdG9BcnJheShjaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XHJcbiAgICBpZiAoaXNTdmdFbGVtZW50KGNoaWxkKSkge1xyXG4gICAgICBlbGVtZW50cy5wdXNoKGNoaWxkKTtcclxuICAgIH0gZWxzZSBpZiAoY2hpbGQpIHtcclxuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gZ2V0RGlzcGxheU5hbWUoY2hpbGQudHlwZSk7XHJcbiAgICAgIHZhciBfcmVmMyA9IHJlbmRlck1hcFtkaXNwbGF5TmFtZV0gfHwge30sXHJcbiAgICAgICAgaGFuZGxlciA9IF9yZWYzLmhhbmRsZXIsXHJcbiAgICAgICAgb25jZSA9IF9yZWYzLm9uY2U7XHJcbiAgICAgIGlmIChoYW5kbGVyICYmICghb25jZSB8fCAhcmVjb3JkW2Rpc3BsYXlOYW1lXSkpIHtcclxuICAgICAgICB2YXIgcmVzdWx0cyA9IGhhbmRsZXIoY2hpbGQsIGRpc3BsYXlOYW1lLCBpbmRleCk7XHJcbiAgICAgICAgZWxlbWVudHMucHVzaChyZXN1bHRzKTtcclxuICAgICAgICByZWNvcmRbZGlzcGxheU5hbWVdID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBlbGVtZW50cztcclxufTtcclxudmFyIGdldFJlYWN0RXZlbnRCeVR5cGUgPSBleHBvcnRzLmdldFJlYWN0RXZlbnRCeVR5cGUgPSBmdW5jdGlvbiBnZXRSZWFjdEV2ZW50QnlUeXBlKGUpIHtcclxuICB2YXIgdHlwZSA9IGUgJiYgZS50eXBlO1xyXG4gIGlmICh0eXBlICYmIFJFQUNUX0JST1dTRVJfRVZFTlRfTUFQW3R5cGVdKSB7XHJcbiAgICByZXR1cm4gUkVBQ1RfQlJPV1NFUl9FVkVOVF9NQVBbdHlwZV07XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59O1xyXG52YXIgcGFyc2VDaGlsZEluZGV4ID0gZXhwb3J0cy5wYXJzZUNoaWxkSW5kZXggPSBmdW5jdGlvbiBwYXJzZUNoaWxkSW5kZXgoY2hpbGQsIGNoaWxkcmVuKSB7XHJcbiAgcmV0dXJuIHRvQXJyYXkoY2hpbGRyZW4pLmluZGV4T2YoY2hpbGQpO1xyXG59OyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImZpbHRlclN2Z0VsZW1lbnRzIiwiZmlsdGVyUHJvcHMiLCJUT09MVElQX1RZUEVTIiwiU0NBTEVfVFlQRVMiLCJMRUdFTkRfVFlQRVMiLCJmaW5kQWxsQnlUeXBlIiwiZmluZENoaWxkQnlUeXBlIiwid2l0aG91dFR5cGUiLCJ2YWxpZGF0ZVdpZHRoSGVpZ2h0IiwidG9BcnJheSIsInJlbmRlckJ5T3JkZXIiLCJwYXJzZUNoaWxkSW5kZXgiLCJpc1ZhbGlkU3ByZWFkYWJsZVByb3AiLCJpc1NpbmdsZUNoaWxkRXF1YWwiLCJpc0NoaWxkcmVuRXF1YWwiLCJoYXNDbGlwRG90IiwiZ2V0UmVhY3RFdmVudEJ5VHlwZSIsImdldERpc3BsYXlOYW1lIiwiX2dldCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2lzTmlsIiwiX2lzU3RyaW5nIiwiX2lzRnVuY3Rpb24iLCJfaXNPYmplY3QiLCJfcmVhY3QiLCJfcmVhY3RJcyIsIl9EYXRhVXRpbHMiLCJfU2hhbGxvd0VxdWFsIiwiX3R5cGVzIiwiX2V4Y2x1ZGVkIiwiX2V4Y2x1ZGVkMiIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJzb3VyY2UiLCJleGNsdWRlZCIsInRhcmdldCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwia2V5IiwiaSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNvdXJjZVN5bWJvbEtleXMiLCJsZW5ndGgiLCJpbmRleE9mIiwicHJvdG90eXBlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJjYWxsIiwiaGFzT3duUHJvcGVydHkiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiUkVBQ1RfQlJPV1NFUl9FVkVOVF9NQVAiLCJjbGljayIsIm1vdXNlZG93biIsIm1vdXNldXAiLCJtb3VzZW92ZXIiLCJtb3VzZW1vdmUiLCJtb3VzZW91dCIsIm1vdXNlZW50ZXIiLCJtb3VzZWxlYXZlIiwidG91Y2hjYW5jZWwiLCJ0b3VjaGVuZCIsInRvdWNobW92ZSIsInRvdWNoc3RhcnQiLCJjb250ZXh0bWVudSIsImRibGNsaWNrIiwiQ29tcCIsImRpc3BsYXlOYW1lIiwibmFtZSIsImxhc3RDaGlsZHJlbiIsImxhc3RSZXN1bHQiLCJjaGlsZHJlbiIsIkFycmF5IiwiaXNBcnJheSIsInJlc3VsdCIsIkNoaWxkcmVuIiwiZm9yRWFjaCIsImNoaWxkIiwiaXNGcmFnbWVudCIsImNvbmNhdCIsInByb3BzIiwicHVzaCIsInR5cGUiLCJ0eXBlcyIsIm1hcCIsInQiLCJjaGlsZFR5cGUiLCJuZXdDaGlsZHJlbiIsImVsIiwiX2VsJHByb3BzIiwid2lkdGgiLCJoZWlnaHQiLCJpc051bWJlciIsIlNWR19UQUdTIiwiaXNTdmdFbGVtZW50IiwiZG90IiwicHJvcGVydHkiLCJpbmNsdWRlRXZlbnRzIiwic3ZnRWxlbWVudFR5cGUiLCJfRmlsdGVyZWRFbGVtZW50S2V5TWEiLCJtYXRjaGluZ0VsZW1lbnRUeXBlS2V5cyIsIkZpbHRlcmVkRWxlbWVudEtleU1hcCIsInN0YXJ0c1dpdGgiLCJpbmNsdWRlcyIsIlNWR0VsZW1lbnRQcm9wS2V5cyIsIkV2ZW50S2V5cyIsInN2Z0VsZW1lbnRzIiwiZW50cnkiLCJpbnB1dFByb3BzIiwiaXNWYWxpZEVsZW1lbnQiLCJvdXQiLCJrZXlzIiwiX2lucHV0UHJvcHMiLCJuZXh0Q2hpbGRyZW4iLCJwcmV2Q2hpbGRyZW4iLCJjb3VudCIsIm5leHRDaGlsZCIsInByZXZDaGlsZCIsIl9yZWYiLCJuZXh0UHJvcHMiLCJfcmVmMiIsInByZXZQcm9wcyIsInNoYWxsb3dFcXVhbCIsInJlbmRlck1hcCIsImVsZW1lbnRzIiwicmVjb3JkIiwiaW5kZXgiLCJfcmVmMyIsImhhbmRsZXIiLCJvbmNlIiwicmVzdWx0cyIsImUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/ReduceCSSCalc.js":
/*!*********************************************************!*\
  !*** ./node_modules/recharts/lib/util/ReduceCSSCalc.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.reduceCSSCalc = reduceCSSCalc;\nexports.safeEvaluateExpression = safeEvaluateExpression;\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar MULTIPLY_OR_DIVIDE_REGEX = /(-?\\d+(?:\\.\\d+)?[a-zA-Z%]*)([*/])(-?\\d+(?:\\.\\d+)?[a-zA-Z%]*)/;\nvar ADD_OR_SUBTRACT_REGEX = /(-?\\d+(?:\\.\\d+)?[a-zA-Z%]*)([+-])(-?\\d+(?:\\.\\d+)?[a-zA-Z%]*)/;\nvar CSS_LENGTH_UNIT_REGEX = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/;\nvar NUM_SPLIT_REGEX = /(-?\\d+(?:\\.\\d+)?)([a-zA-Z%]+)?/;\nvar CONVERSION_RATES = {\n    cm: 96 / 2.54,\n    mm: 96 / 25.4,\n    pt: 96 / 72,\n    pc: 96 / 6,\n    \"in\": 96,\n    Q: 96 / (2.54 * 40),\n    px: 1\n};\nvar FIXED_CSS_LENGTH_UNITS = Object.keys(CONVERSION_RATES);\nvar STR_NAN = 'NaN';\nfunction convertToPx(value, unit) {\n    return value * CONVERSION_RATES[unit];\n}\nvar DecimalCSS = /*#__PURE__*/ function() {\n    function DecimalCSS(num, unit) {\n        _classCallCheck(this, DecimalCSS);\n        this.num = num;\n        this.unit = unit;\n        this.num = num;\n        this.unit = unit;\n        if (Number.isNaN(num)) {\n            this.unit = '';\n        }\n        if (unit !== '' && !CSS_LENGTH_UNIT_REGEX.test(unit)) {\n            this.num = NaN;\n            this.unit = '';\n        }\n        if (FIXED_CSS_LENGTH_UNITS.includes(unit)) {\n            this.num = convertToPx(num, unit);\n            this.unit = 'px';\n        }\n    }\n    return _createClass(DecimalCSS, [\n        {\n            key: \"add\",\n            value: function add(other) {\n                if (this.unit !== other.unit) {\n                    return new DecimalCSS(NaN, '');\n                }\n                return new DecimalCSS(this.num + other.num, this.unit);\n            }\n        },\n        {\n            key: \"subtract\",\n            value: function subtract(other) {\n                if (this.unit !== other.unit) {\n                    return new DecimalCSS(NaN, '');\n                }\n                return new DecimalCSS(this.num - other.num, this.unit);\n            }\n        },\n        {\n            key: \"multiply\",\n            value: function multiply(other) {\n                if (this.unit !== '' && other.unit !== '' && this.unit !== other.unit) {\n                    return new DecimalCSS(NaN, '');\n                }\n                return new DecimalCSS(this.num * other.num, this.unit || other.unit);\n            }\n        },\n        {\n            key: \"divide\",\n            value: function divide(other) {\n                if (this.unit !== '' && other.unit !== '' && this.unit !== other.unit) {\n                    return new DecimalCSS(NaN, '');\n                }\n                return new DecimalCSS(this.num / other.num, this.unit || other.unit);\n            }\n        },\n        {\n            key: \"toString\",\n            value: function toString() {\n                return \"\".concat(this.num).concat(this.unit);\n            }\n        },\n        {\n            key: \"isNaN\",\n            value: function isNaN() {\n                return Number.isNaN(this.num);\n            }\n        }\n    ], [\n        {\n            key: \"parse\",\n            value: function parse(str) {\n                var _NUM_SPLIT_REGEX$exec;\n                var _ref = (_NUM_SPLIT_REGEX$exec = NUM_SPLIT_REGEX.exec(str)) !== null && _NUM_SPLIT_REGEX$exec !== void 0 ? _NUM_SPLIT_REGEX$exec : [], _ref2 = _slicedToArray(_ref, 3), numStr = _ref2[1], unit = _ref2[2];\n                return new DecimalCSS(parseFloat(numStr), unit !== null && unit !== void 0 ? unit : '');\n            }\n        }\n    ]);\n}();\nfunction calculateArithmetic(expr) {\n    if (expr.includes(STR_NAN)) {\n        return STR_NAN;\n    }\n    var newExpr = expr;\n    while(newExpr.includes('*') || newExpr.includes('/')){\n        var _MULTIPLY_OR_DIVIDE_R;\n        var _ref3 = (_MULTIPLY_OR_DIVIDE_R = MULTIPLY_OR_DIVIDE_REGEX.exec(newExpr)) !== null && _MULTIPLY_OR_DIVIDE_R !== void 0 ? _MULTIPLY_OR_DIVIDE_R : [], _ref4 = _slicedToArray(_ref3, 4), leftOperand = _ref4[1], operator = _ref4[2], rightOperand = _ref4[3];\n        var lTs = DecimalCSS.parse(leftOperand !== null && leftOperand !== void 0 ? leftOperand : '');\n        var rTs = DecimalCSS.parse(rightOperand !== null && rightOperand !== void 0 ? rightOperand : '');\n        var result = operator === '*' ? lTs.multiply(rTs) : lTs.divide(rTs);\n        if (result.isNaN()) {\n            return STR_NAN;\n        }\n        newExpr = newExpr.replace(MULTIPLY_OR_DIVIDE_REGEX, result.toString());\n    }\n    while(newExpr.includes('+') || /.-\\d+(?:\\.\\d+)?/.test(newExpr)){\n        var _ADD_OR_SUBTRACT_REGE;\n        var _ref5 = (_ADD_OR_SUBTRACT_REGE = ADD_OR_SUBTRACT_REGEX.exec(newExpr)) !== null && _ADD_OR_SUBTRACT_REGE !== void 0 ? _ADD_OR_SUBTRACT_REGE : [], _ref6 = _slicedToArray(_ref5, 4), _leftOperand = _ref6[1], _operator = _ref6[2], _rightOperand = _ref6[3];\n        var _lTs = DecimalCSS.parse(_leftOperand !== null && _leftOperand !== void 0 ? _leftOperand : '');\n        var _rTs = DecimalCSS.parse(_rightOperand !== null && _rightOperand !== void 0 ? _rightOperand : '');\n        var _result = _operator === '+' ? _lTs.add(_rTs) : _lTs.subtract(_rTs);\n        if (_result.isNaN()) {\n            return STR_NAN;\n        }\n        newExpr = newExpr.replace(ADD_OR_SUBTRACT_REGEX, _result.toString());\n    }\n    return newExpr;\n}\nvar PARENTHESES_REGEX = /\\(([^()]*)\\)/;\nfunction calculateParentheses(expr) {\n    var newExpr = expr;\n    while(newExpr.includes('(')){\n        var _PARENTHESES_REGEX$ex = PARENTHESES_REGEX.exec(newExpr), _PARENTHESES_REGEX$ex2 = _slicedToArray(_PARENTHESES_REGEX$ex, 2), parentheticalExpression = _PARENTHESES_REGEX$ex2[1];\n        newExpr = newExpr.replace(PARENTHESES_REGEX, calculateArithmetic(parentheticalExpression));\n    }\n    return newExpr;\n}\nfunction evaluateExpression(expression) {\n    var newExpr = expression.replace(/\\s+/g, '');\n    newExpr = calculateParentheses(newExpr);\n    newExpr = calculateArithmetic(newExpr);\n    return newExpr;\n}\nfunction safeEvaluateExpression(expression) {\n    try {\n        return evaluateExpression(expression);\n    } catch (e) {\n        /* istanbul ignore next */ return STR_NAN;\n    }\n}\nfunction reduceCSSCalc(expression) {\n    var result = safeEvaluateExpression(expression.slice(5, -1));\n    if (result === STR_NAN) {\n        // notify the user\n        return '';\n    }\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9SZWR1Y2VDU1NDYWxjLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxxQkFBcUIsR0FBR0U7QUFDeEJGLDhCQUE4QixHQUFHRztBQUNqQyxTQUFTQyxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRSxXQUFXLEtBQUtDLFVBQVVELE1BQU1DLE9BQU9FLFNBQVMsR0FBRyxXQUFXLE9BQU9IO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSSxlQUFlQyxHQUFHLEVBQUVDLENBQUM7SUFBSSxPQUFPQyxnQkFBZ0JGLFFBQVFHLHNCQUFzQkgsS0FBS0MsTUFBTUcsNEJBQTRCSixLQUFLQyxNQUFNSTtBQUFvQjtBQUM3SixTQUFTQTtJQUFxQixNQUFNLElBQUlDLFVBQVU7QUFBOEk7QUFDaE0sU0FBU0YsNEJBQTRCVCxDQUFDLEVBQUVZLE1BQU07SUFBSSxJQUFJLENBQUNaLEdBQUc7SUFBUSxJQUFJLE9BQU9BLE1BQU0sVUFBVSxPQUFPYSxrQkFBa0JiLEdBQUdZO0lBQVMsSUFBSUUsSUFBSXJCLE9BQU9VLFNBQVMsQ0FBQ1ksUUFBUSxDQUFDQyxJQUFJLENBQUNoQixHQUFHaUIsS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUFJLElBQUlILE1BQU0sWUFBWWQsRUFBRSxXQUFXLEVBQUVjLElBQUlkLEVBQUUsV0FBVyxDQUFDa0IsSUFBSTtJQUFFLElBQUlKLE1BQU0sU0FBU0EsTUFBTSxPQUFPLE9BQU9LLE1BQU1DLElBQUksQ0FBQ3BCO0lBQUksSUFBSWMsTUFB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Q0EsU0FBUzlGLHVCQUF1QndILFVBQVU7SUFDeEMsSUFBSTtRQUNGLE9BQU9ELG1CQUFtQkM7SUFDNUIsRUFBRSxPQUFPMUYsR0FBRztRQUNWLHdCQUF3QixHQUN4QixPQUFPd0M7SUFDVDtBQUNGO0FBQ0EsU0FBU3ZFLGNBQWN5SCxVQUFVO0lBQy9CLElBQUlqQixTQUFTdkcsdUJBQXVCd0gsV0FBV3JHLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFDekQsSUFBSW9GLFdBQVdqQyxTQUFTO1FBQ3RCLGtCQUFrQjtRQUNsQixPQUFPO0lBQ1Q7SUFDQSxPQUFPaUM7QUFDVCIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcdXRpbFxcUmVkdWNlQ1NTQ2FsYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLnJlZHVjZUNTU0NhbGMgPSByZWR1Y2VDU1NDYWxjO1xyXG5leHBvcnRzLnNhZmVFdmFsdWF0ZUV4cHJlc3Npb24gPSBzYWZlRXZhbHVhdGVFeHByZXNzaW9uO1xyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XHJcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cclxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XHJcbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XHJcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxyXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cclxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cclxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxyXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxyXG52YXIgTVVMVElQTFlfT1JfRElWSURFX1JFR0VYID0gLygtP1xcZCsoPzpcXC5cXGQrKT9bYS16QS1aJV0qKShbKi9dKSgtP1xcZCsoPzpcXC5cXGQrKT9bYS16QS1aJV0qKS87XHJcbnZhciBBRERfT1JfU1VCVFJBQ1RfUkVHRVggPSAvKC0/XFxkKyg/OlxcLlxcZCspP1thLXpBLVolXSopKFsrLV0pKC0/XFxkKyg/OlxcLlxcZCspP1thLXpBLVolXSopLztcclxudmFyIENTU19MRU5HVEhfVU5JVF9SRUdFWCA9IC9ecHh8Y218dmh8dnd8ZW18cmVtfCV8bW18aW58cHR8cGN8ZXh8Y2h8dm1pbnx2bWF4fFEkLztcclxudmFyIE5VTV9TUExJVF9SRUdFWCA9IC8oLT9cXGQrKD86XFwuXFxkKyk/KShbYS16QS1aJV0rKT8vO1xyXG52YXIgQ09OVkVSU0lPTl9SQVRFUyA9IHtcclxuICBjbTogOTYgLyAyLjU0LFxyXG4gIG1tOiA5NiAvIDI1LjQsXHJcbiAgcHQ6IDk2IC8gNzIsXHJcbiAgcGM6IDk2IC8gNixcclxuICBcImluXCI6IDk2LFxyXG4gIFE6IDk2IC8gKDIuNTQgKiA0MCksXHJcbiAgcHg6IDFcclxufTtcclxudmFyIEZJWEVEX0NTU19MRU5HVEhfVU5JVFMgPSBPYmplY3Qua2V5cyhDT05WRVJTSU9OX1JBVEVTKTtcclxudmFyIFNUUl9OQU4gPSAnTmFOJztcclxuZnVuY3Rpb24gY29udmVydFRvUHgodmFsdWUsIHVuaXQpIHtcclxuICByZXR1cm4gdmFsdWUgKiBDT05WRVJTSU9OX1JBVEVTW3VuaXRdO1xyXG59XHJcbnZhciBEZWNpbWFsQ1NTID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBEZWNpbWFsQ1NTKG51bSwgdW5pdCkge1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlY2ltYWxDU1MpO1xyXG4gICAgdGhpcy5udW0gPSBudW07XHJcbiAgICB0aGlzLnVuaXQgPSB1bml0O1xyXG4gICAgdGhpcy5udW0gPSBudW07XHJcbiAgICB0aGlzLnVuaXQgPSB1bml0O1xyXG4gICAgaWYgKE51bWJlci5pc05hTihudW0pKSB7XHJcbiAgICAgIHRoaXMudW5pdCA9ICcnO1xyXG4gICAgfVxyXG4gICAgaWYgKHVuaXQgIT09ICcnICYmICFDU1NfTEVOR1RIX1VOSVRfUkVHRVgudGVzdCh1bml0KSkge1xyXG4gICAgICB0aGlzLm51bSA9IE5hTjtcclxuICAgICAgdGhpcy51bml0ID0gJyc7XHJcbiAgICB9XHJcbiAgICBpZiAoRklYRURfQ1NTX0xFTkdUSF9VTklUUy5pbmNsdWRlcyh1bml0KSkge1xyXG4gICAgICB0aGlzLm51bSA9IGNvbnZlcnRUb1B4KG51bSwgdW5pdCk7XHJcbiAgICAgIHRoaXMudW5pdCA9ICdweCc7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRGVjaW1hbENTUywgW3tcclxuICAgIGtleTogXCJhZGRcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQob3RoZXIpIHtcclxuICAgICAgaWYgKHRoaXMudW5pdCAhPT0gb3RoZXIudW5pdCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGVjaW1hbENTUyhOYU4sICcnKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3IERlY2ltYWxDU1ModGhpcy5udW0gKyBvdGhlci5udW0sIHRoaXMudW5pdCk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInN1YnRyYWN0XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VidHJhY3Qob3RoZXIpIHtcclxuICAgICAgaWYgKHRoaXMudW5pdCAhPT0gb3RoZXIudW5pdCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGVjaW1hbENTUyhOYU4sICcnKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3IERlY2ltYWxDU1ModGhpcy5udW0gLSBvdGhlci5udW0sIHRoaXMudW5pdCk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcIm11bHRpcGx5XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gbXVsdGlwbHkob3RoZXIpIHtcclxuICAgICAgaWYgKHRoaXMudW5pdCAhPT0gJycgJiYgb3RoZXIudW5pdCAhPT0gJycgJiYgdGhpcy51bml0ICE9PSBvdGhlci51bml0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsQ1NTKE5hTiwgJycpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXcgRGVjaW1hbENTUyh0aGlzLm51bSAqIG90aGVyLm51bSwgdGhpcy51bml0IHx8IG90aGVyLnVuaXQpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJkaXZpZGVcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXZpZGUob3RoZXIpIHtcclxuICAgICAgaWYgKHRoaXMudW5pdCAhPT0gJycgJiYgb3RoZXIudW5pdCAhPT0gJycgJiYgdGhpcy51bml0ICE9PSBvdGhlci51bml0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsQ1NTKE5hTiwgJycpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXcgRGVjaW1hbENTUyh0aGlzLm51bSAvIG90aGVyLm51bSwgdGhpcy51bml0IHx8IG90aGVyLnVuaXQpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5udW0pLmNvbmNhdCh0aGlzLnVuaXQpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJpc05hTlwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzTmFOKCkge1xyXG4gICAgICByZXR1cm4gTnVtYmVyLmlzTmFOKHRoaXMubnVtKTtcclxuICAgIH1cclxuICB9XSwgW3tcclxuICAgIGtleTogXCJwYXJzZVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKHN0cikge1xyXG4gICAgICB2YXIgX05VTV9TUExJVF9SRUdFWCRleGVjO1xyXG4gICAgICB2YXIgX3JlZiA9IChfTlVNX1NQTElUX1JFR0VYJGV4ZWMgPSBOVU1fU1BMSVRfUkVHRVguZXhlYyhzdHIpKSAhPT0gbnVsbCAmJiBfTlVNX1NQTElUX1JFR0VYJGV4ZWMgIT09IHZvaWQgMCA/IF9OVU1fU1BMSVRfUkVHRVgkZXhlYyA6IFtdLFxyXG4gICAgICAgIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMyksXHJcbiAgICAgICAgbnVtU3RyID0gX3JlZjJbMV0sXHJcbiAgICAgICAgdW5pdCA9IF9yZWYyWzJdO1xyXG4gICAgICByZXR1cm4gbmV3IERlY2ltYWxDU1MocGFyc2VGbG9hdChudW1TdHIpLCB1bml0ICE9PSBudWxsICYmIHVuaXQgIT09IHZvaWQgMCA/IHVuaXQgOiAnJyk7XHJcbiAgICB9XHJcbiAgfV0pO1xyXG59KCk7XHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZUFyaXRobWV0aWMoZXhwcikge1xyXG4gIGlmIChleHByLmluY2x1ZGVzKFNUUl9OQU4pKSB7XHJcbiAgICByZXR1cm4gU1RSX05BTjtcclxuICB9XHJcbiAgdmFyIG5ld0V4cHIgPSBleHByO1xyXG4gIHdoaWxlIChuZXdFeHByLmluY2x1ZGVzKCcqJykgfHwgbmV3RXhwci5pbmNsdWRlcygnLycpKSB7XHJcbiAgICB2YXIgX01VTFRJUExZX09SX0RJVklERV9SO1xyXG4gICAgdmFyIF9yZWYzID0gKF9NVUxUSVBMWV9PUl9ESVZJREVfUiA9IE1VTFRJUExZX09SX0RJVklERV9SRUdFWC5leGVjKG5ld0V4cHIpKSAhPT0gbnVsbCAmJiBfTVVMVElQTFlfT1JfRElWSURFX1IgIT09IHZvaWQgMCA/IF9NVUxUSVBMWV9PUl9ESVZJREVfUiA6IFtdLFxyXG4gICAgICBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCA0KSxcclxuICAgICAgbGVmdE9wZXJhbmQgPSBfcmVmNFsxXSxcclxuICAgICAgb3BlcmF0b3IgPSBfcmVmNFsyXSxcclxuICAgICAgcmlnaHRPcGVyYW5kID0gX3JlZjRbM107XHJcbiAgICB2YXIgbFRzID0gRGVjaW1hbENTUy5wYXJzZShsZWZ0T3BlcmFuZCAhPT0gbnVsbCAmJiBsZWZ0T3BlcmFuZCAhPT0gdm9pZCAwID8gbGVmdE9wZXJhbmQgOiAnJyk7XHJcbiAgICB2YXIgclRzID0gRGVjaW1hbENTUy5wYXJzZShyaWdodE9wZXJhbmQgIT09IG51bGwgJiYgcmlnaHRPcGVyYW5kICE9PSB2b2lkIDAgPyByaWdodE9wZXJhbmQgOiAnJyk7XHJcbiAgICB2YXIgcmVzdWx0ID0gb3BlcmF0b3IgPT09ICcqJyA/IGxUcy5tdWx0aXBseShyVHMpIDogbFRzLmRpdmlkZShyVHMpO1xyXG4gICAgaWYgKHJlc3VsdC5pc05hTigpKSB7XHJcbiAgICAgIHJldHVybiBTVFJfTkFOO1xyXG4gICAgfVxyXG4gICAgbmV3RXhwciA9IG5ld0V4cHIucmVwbGFjZShNVUxUSVBMWV9PUl9ESVZJREVfUkVHRVgsIHJlc3VsdC50b1N0cmluZygpKTtcclxuICB9XHJcbiAgd2hpbGUgKG5ld0V4cHIuaW5jbHVkZXMoJysnKSB8fCAvLi1cXGQrKD86XFwuXFxkKyk/Ly50ZXN0KG5ld0V4cHIpKSB7XHJcbiAgICB2YXIgX0FERF9PUl9TVUJUUkFDVF9SRUdFO1xyXG4gICAgdmFyIF9yZWY1ID0gKF9BRERfT1JfU1VCVFJBQ1RfUkVHRSA9IEFERF9PUl9TVUJUUkFDVF9SRUdFWC5leGVjKG5ld0V4cHIpKSAhPT0gbnVsbCAmJiBfQUREX09SX1NVQlRSQUNUX1JFR0UgIT09IHZvaWQgMCA/IF9BRERfT1JfU1VCVFJBQ1RfUkVHRSA6IFtdLFxyXG4gICAgICBfcmVmNiA9IF9zbGljZWRUb0FycmF5KF9yZWY1LCA0KSxcclxuICAgICAgX2xlZnRPcGVyYW5kID0gX3JlZjZbMV0sXHJcbiAgICAgIF9vcGVyYXRvciA9IF9yZWY2WzJdLFxyXG4gICAgICBfcmlnaHRPcGVyYW5kID0gX3JlZjZbM107XHJcbiAgICB2YXIgX2xUcyA9IERlY2ltYWxDU1MucGFyc2UoX2xlZnRPcGVyYW5kICE9PSBudWxsICYmIF9sZWZ0T3BlcmFuZCAhPT0gdm9pZCAwID8gX2xlZnRPcGVyYW5kIDogJycpO1xyXG4gICAgdmFyIF9yVHMgPSBEZWNpbWFsQ1NTLnBhcnNlKF9yaWdodE9wZXJhbmQgIT09IG51bGwgJiYgX3JpZ2h0T3BlcmFuZCAhPT0gdm9pZCAwID8gX3JpZ2h0T3BlcmFuZCA6ICcnKTtcclxuICAgIHZhciBfcmVzdWx0ID0gX29wZXJhdG9yID09PSAnKycgPyBfbFRzLmFkZChfclRzKSA6IF9sVHMuc3VidHJhY3QoX3JUcyk7XHJcbiAgICBpZiAoX3Jlc3VsdC5pc05hTigpKSB7XHJcbiAgICAgIHJldHVybiBTVFJfTkFOO1xyXG4gICAgfVxyXG4gICAgbmV3RXhwciA9IG5ld0V4cHIucmVwbGFjZShBRERfT1JfU1VCVFJBQ1RfUkVHRVgsIF9yZXN1bHQudG9TdHJpbmcoKSk7XHJcbiAgfVxyXG4gIHJldHVybiBuZXdFeHByO1xyXG59XHJcbnZhciBQQVJFTlRIRVNFU19SRUdFWCA9IC9cXCgoW14oKV0qKVxcKS87XHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZVBhcmVudGhlc2VzKGV4cHIpIHtcclxuICB2YXIgbmV3RXhwciA9IGV4cHI7XHJcbiAgd2hpbGUgKG5ld0V4cHIuaW5jbHVkZXMoJygnKSkge1xyXG4gICAgdmFyIF9QQVJFTlRIRVNFU19SRUdFWCRleCA9IFBBUkVOVEhFU0VTX1JFR0VYLmV4ZWMobmV3RXhwciksXHJcbiAgICAgIF9QQVJFTlRIRVNFU19SRUdFWCRleDIgPSBfc2xpY2VkVG9BcnJheShfUEFSRU5USEVTRVNfUkVHRVgkZXgsIDIpLFxyXG4gICAgICBwYXJlbnRoZXRpY2FsRXhwcmVzc2lvbiA9IF9QQVJFTlRIRVNFU19SRUdFWCRleDJbMV07XHJcbiAgICBuZXdFeHByID0gbmV3RXhwci5yZXBsYWNlKFBBUkVOVEhFU0VTX1JFR0VYLCBjYWxjdWxhdGVBcml0aG1ldGljKHBhcmVudGhldGljYWxFeHByZXNzaW9uKSk7XHJcbiAgfVxyXG4gIHJldHVybiBuZXdFeHByO1xyXG59XHJcbmZ1bmN0aW9uIGV2YWx1YXRlRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XHJcbiAgdmFyIG5ld0V4cHIgPSBleHByZXNzaW9uLnJlcGxhY2UoL1xccysvZywgJycpO1xyXG4gIG5ld0V4cHIgPSBjYWxjdWxhdGVQYXJlbnRoZXNlcyhuZXdFeHByKTtcclxuICBuZXdFeHByID0gY2FsY3VsYXRlQXJpdGhtZXRpYyhuZXdFeHByKTtcclxuICByZXR1cm4gbmV3RXhwcjtcclxufVxyXG5mdW5jdGlvbiBzYWZlRXZhbHVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGV2YWx1YXRlRXhwcmVzc2lvbihleHByZXNzaW9uKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgcmV0dXJuIFNUUl9OQU47XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlZHVjZUNTU0NhbGMoZXhwcmVzc2lvbikge1xyXG4gIHZhciByZXN1bHQgPSBzYWZlRXZhbHVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24uc2xpY2UoNSwgLTEpKTtcclxuICBpZiAocmVzdWx0ID09PSBTVFJfTkFOKSB7XHJcbiAgICAvLyBub3RpZnkgdGhlIHVzZXJcclxuICAgIHJldHVybiAnJztcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufSJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlZHVjZUNTU0NhbGMiLCJzYWZlRXZhbHVhdGVFeHByZXNzaW9uIiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiaSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJUeXBlRXJyb3IiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwibGVuIiwibGVuZ3RoIiwiYXJyMiIsInIiLCJsIiwidCIsImUiLCJ1IiwiYSIsImYiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJpc0FycmF5IiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsIk1VTFRJUExZX09SX0RJVklERV9SRUdFWCIsIkFERF9PUl9TVUJUUkFDVF9SRUdFWCIsIkNTU19MRU5HVEhfVU5JVF9SRUdFWCIsIk5VTV9TUExJVF9SRUdFWCIsIkNPTlZFUlNJT05fUkFURVMiLCJjbSIsIm1tIiwicHQiLCJwYyIsIlEiLCJweCIsIkZJWEVEX0NTU19MRU5HVEhfVU5JVFMiLCJrZXlzIiwiU1RSX05BTiIsImNvbnZlcnRUb1B4IiwidW5pdCIsIkRlY2ltYWxDU1MiLCJudW0iLCJpc05hTiIsIk5hTiIsImluY2x1ZGVzIiwiYWRkIiwib3RoZXIiLCJzdWJ0cmFjdCIsIm11bHRpcGx5IiwiZGl2aWRlIiwiY29uY2F0IiwicGFyc2UiLCJzdHIiLCJfTlVNX1NQTElUX1JFR0VYJGV4ZWMiLCJfcmVmIiwiZXhlYyIsIl9yZWYyIiwibnVtU3RyIiwicGFyc2VGbG9hdCIsImNhbGN1bGF0ZUFyaXRobWV0aWMiLCJleHByIiwibmV3RXhwciIsIl9NVUxUSVBMWV9PUl9ESVZJREVfUiIsIl9yZWYzIiwiX3JlZjQiLCJsZWZ0T3BlcmFuZCIsIm9wZXJhdG9yIiwicmlnaHRPcGVyYW5kIiwibFRzIiwiclRzIiwicmVzdWx0IiwicmVwbGFjZSIsIl9BRERfT1JfU1VCVFJBQ1RfUkVHRSIsIl9yZWY1IiwiX3JlZjYiLCJfbGVmdE9wZXJhbmQiLCJfb3BlcmF0b3IiLCJfcmlnaHRPcGVyYW5kIiwiX2xUcyIsIl9yVHMiLCJfcmVzdWx0IiwiUEFSRU5USEVTRVNfUkVHRVgiLCJjYWxjdWxhdGVQYXJlbnRoZXNlcyIsIl9QQVJFTlRIRVNFU19SRUdFWCRleCIsIl9QQVJFTlRIRVNFU19SRUdFWCRleDIiLCJwYXJlbnRoZXRpY2FsRXhwcmVzc2lvbiIsImV2YWx1YXRlRXhwcmVzc2lvbiIsImV4cHJlc3Npb24iXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/ReduceCSSCalc.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/ScatterUtils.js":
/*!********************************************************!*\
  !*** ./node_modules/recharts/lib/util/ScatterUtils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ScatterSymbol = ScatterSymbol;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _Symbols = __webpack_require__(/*! ../shape/Symbols */ \"(pages-dir-node)/./node_modules/recharts/lib/shape/Symbols.js\");\nvar _ActiveShapeUtils = __webpack_require__(/*! ./ActiveShapeUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ActiveShapeUtils.js\");\nvar _excluded = [\n    \"option\",\n    \"isActive\"\n];\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction ScatterSymbol(_ref) {\n    var option = _ref.option, isActive = _ref.isActive, props = _objectWithoutProperties(_ref, _excluded);\n    if (typeof option === 'string') {\n        return /*#__PURE__*/ React.createElement(_ActiveShapeUtils.Shape, _extends({\n            option: /*#__PURE__*/ React.createElement(_Symbols.Symbols, _extends({\n                type: option\n            }, props)),\n            isActive: isActive,\n            shapeType: \"symbols\"\n        }, props));\n    }\n    return /*#__PURE__*/ React.createElement(_ActiveShapeUtils.Shape, _extends({\n        option: option,\n        isActive: isActive,\n        shapeType: \"symbols\"\n    }, props));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9TY2F0dGVyVXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRSxXQUFXLEtBQUtDLFVBQVVELE1BQU1DLE9BQU9FLFNBQVMsR0FBRyxXQUFXLE9BQU9IO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VEksOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELHFCQUFxQixHQUFHRTtBQUN4QixJQUFJQyxRQUFRQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ25ELElBQUlDLFdBQVdELG1CQUFPQSxDQUFDLHVGQUFrQjtBQUN6QyxJQUFJRSxvQkFBb0JGLG1CQUFPQSxDQUFDLGlHQUFvQjtBQUNwRCxJQUFJRyxZQUFZO0lBQUM7SUFBVTtDQUFXO0FBQ3RDLFNBQVNDLHlCQUF5QkMsQ0FBQztJQUFJLElBQUksY0FBYyxPQUFPQyxTQUFTLE9BQU87SUFBTSxJQUFJQyxJQUFJLElBQUlELFdBQVdFLElBQUksSUFBSUY7SUFBVyxPQUFPLENBQUNGLDJCQUEyQixTQUFTQSx5QkFBeUJDLENBQUM7UUFBSSxPQUFPQSxJQUFJRyxJQUFJRDtJQUFHLEdBQUdGO0FBQUk7QUFDbk8sU0FBU04sd0JBQXdCTSxDQUFDLEVBQUVFLENBQUM7SUFBSSxJQUFJLENBQUNBLEtBQUtGLEtBQUtBLEVBQUVJLFVBQVUsRUFBRSxPQUFPSjtJQUFHLElBQUksU0FBU0EsS0FBSyxZQUFZakIsUUFBUWlCLE1BQU0sY0FBYyxPQUFPQSxHQUFHLE9BQU87UUFBRSxXQUFXQTtJQUFF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LENBQUN2QyxrQkFBa0J3QyxLQUFLLEVBQUVyQixTQUFTO1lBQ3hFaUIsUUFBUSxXQUFXLEdBQUV4QyxNQUFNMkMsYUFBYSxDQUFDeEMsU0FBUzBDLE9BQU8sRUFBRXRCLFNBQVM7Z0JBQ2xFdUIsTUFBTU47WUFDUixHQUFHRTtZQUNIRCxVQUFVQTtZQUNWTSxXQUFXO1FBQ2IsR0FBR0w7SUFDTDtJQUNBLE9BQU8sV0FBVyxHQUFFMUMsTUFBTTJDLGFBQWEsQ0FBQ3ZDLGtCQUFrQndDLEtBQUssRUFBRXJCLFNBQVM7UUFDeEVpQixRQUFRQTtRQUNSQyxVQUFVQTtRQUNWTSxXQUFXO0lBQ2IsR0FBR0w7QUFDTCIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcdXRpbFxcU2NhdHRlclV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5TY2F0dGVyU3ltYm9sID0gU2NhdHRlclN5bWJvbDtcclxudmFyIFJlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIF9TeW1ib2xzID0gcmVxdWlyZShcIi4uL3NoYXBlL1N5bWJvbHNcIik7XHJcbnZhciBfQWN0aXZlU2hhcGVVdGlscyA9IHJlcXVpcmUoXCIuL0FjdGl2ZVNoYXBlVXRpbHNcIik7XHJcbnZhciBfZXhjbHVkZWQgPSBbXCJvcHRpb25cIiwgXCJpc0FjdGl2ZVwiXTtcclxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cclxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cclxuZnVuY3Rpb24gU2NhdHRlclN5bWJvbChfcmVmKSB7XHJcbiAgdmFyIG9wdGlvbiA9IF9yZWYub3B0aW9uLFxyXG4gICAgaXNBY3RpdmUgPSBfcmVmLmlzQWN0aXZlLFxyXG4gICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkKTtcclxuICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChfQWN0aXZlU2hhcGVVdGlscy5TaGFwZSwgX2V4dGVuZHMoe1xyXG4gICAgICBvcHRpb246IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KF9TeW1ib2xzLlN5bWJvbHMsIF9leHRlbmRzKHtcclxuICAgICAgICB0eXBlOiBvcHRpb25cclxuICAgICAgfSwgcHJvcHMpKSxcclxuICAgICAgaXNBY3RpdmU6IGlzQWN0aXZlLFxyXG4gICAgICBzaGFwZVR5cGU6IFwic3ltYm9sc1wiXHJcbiAgICB9LCBwcm9wcykpO1xyXG4gIH1cclxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoX0FjdGl2ZVNoYXBlVXRpbHMuU2hhcGUsIF9leHRlbmRzKHtcclxuICAgIG9wdGlvbjogb3B0aW9uLFxyXG4gICAgaXNBY3RpdmU6IGlzQWN0aXZlLFxyXG4gICAgc2hhcGVUeXBlOiBcInN5bWJvbHNcIlxyXG4gIH0sIHByb3BzKSk7XHJcbn0iXSwibmFtZXMiOlsiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU2NhdHRlclN5bWJvbCIsIlJlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX1N5bWJvbHMiLCJfQWN0aXZlU2hhcGVVdGlscyIsIl9leGNsdWRlZCIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJfX2VzTW9kdWxlIiwiaGFzIiwiZ2V0IiwibiIsIl9fcHJvdG9fXyIsImEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ1IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaSIsInNldCIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsImFwcGx5IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNvdXJjZVN5bWJvbEtleXMiLCJpbmRleE9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfcmVmIiwib3B0aW9uIiwiaXNBY3RpdmUiLCJwcm9wcyIsImNyZWF0ZUVsZW1lbnQiLCJTaGFwZSIsIlN5bWJvbHMiLCJ0eXBlIiwic2hhcGVUeXBlIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/ScatterUtils.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/ShallowEqual.js":
/*!********************************************************!*\
  !*** ./node_modules/recharts/lib/util/ShallowEqual.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.shallowEqual = shallowEqual;\nfunction shallowEqual(a, b) {\n    /* eslint-disable no-restricted-syntax */ for(var key in a){\n        if (({}).hasOwnProperty.call(a, key) && (!({}).hasOwnProperty.call(b, key) || a[key] !== b[key])) {\n            return false;\n        }\n    }\n    for(var _key in b){\n        if (({}).hasOwnProperty.call(b, _key) && !({}).hasOwnProperty.call(a, _key)) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9TaGFsbG93RXF1YWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELG9CQUFvQixHQUFHRTtBQUN2QixTQUFTQSxhQUFhQyxDQUFDLEVBQUVDLENBQUM7SUFDeEIsdUNBQXVDLEdBQ3ZDLElBQUssSUFBSUMsT0FBT0YsRUFBRztRQUNqQixJQUFJLEVBQUMsR0FBRUcsY0FBYyxDQUFDQyxJQUFJLENBQUNKLEdBQUdFLFFBQVMsRUFBQyxFQUFDLEdBQUVDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSCxHQUFHQyxRQUFRRixDQUFDLENBQUNFLElBQUksS0FBS0QsQ0FBQyxDQUFDQyxJQUFJLEdBQUc7WUFDNUYsT0FBTztRQUNUO0lBQ0Y7SUFDQSxJQUFLLElBQUlHLFFBQVFKLEVBQUc7UUFDbEIsSUFBSSxFQUFDLEdBQUVFLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSCxHQUFHSSxTQUFTLENBQUMsRUFBQyxHQUFFRixjQUFjLENBQUNDLElBQUksQ0FBQ0osR0FBR0ssT0FBTztZQUN2RSxPQUFPO1FBQ1Q7SUFDRjtJQUNBLE9BQU87QUFDVCIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcdXRpbFxcU2hhbGxvd0VxdWFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuc2hhbGxvd0VxdWFsID0gc2hhbGxvd0VxdWFsO1xyXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwoYSwgYikge1xyXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtc3ludGF4ICovXHJcbiAgZm9yICh2YXIga2V5IGluIGEpIHtcclxuICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGtleSkgJiYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleSkgfHwgYVtrZXldICE9PSBiW2tleV0pKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbiAgZm9yICh2YXIgX2tleSBpbiBiKSB7XHJcbiAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChiLCBfa2V5KSAmJiAhe30uaGFzT3duUHJvcGVydHkuY2FsbChhLCBfa2V5KSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2hhbGxvd0VxdWFsIiwiYSIsImIiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJfa2V5Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/ShallowEqual.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/TickUtils.js":
/*!*****************************************************!*\
  !*** ./node_modules/recharts/lib/util/TickUtils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getAngledTickWidth = getAngledTickWidth;\nexports.getNumberIntervalTicks = getNumberIntervalTicks;\nexports.getTickBoundaries = getTickBoundaries;\nexports.isVisible = isVisible;\nvar _CartesianUtils = __webpack_require__(/*! ./CartesianUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/CartesianUtils.js\");\nvar _getEveryNthWithCondition = __webpack_require__(/*! ./getEveryNthWithCondition */ \"(pages-dir-node)/./node_modules/recharts/lib/util/getEveryNthWithCondition.js\");\nfunction getAngledTickWidth(contentSize, unitSize, angle) {\n    var size = {\n        width: contentSize.width + unitSize.width,\n        height: contentSize.height + unitSize.height\n    };\n    return (0, _CartesianUtils.getAngledRectangleWidth)(size, angle);\n}\nfunction getTickBoundaries(viewBox, sign, sizeKey) {\n    var isWidth = sizeKey === 'width';\n    var x = viewBox.x, y = viewBox.y, width = viewBox.width, height = viewBox.height;\n    if (sign === 1) {\n        return {\n            start: isWidth ? x : y,\n            end: isWidth ? x + width : y + height\n        };\n    }\n    return {\n        start: isWidth ? x + width : y + height,\n        end: isWidth ? x : y\n    };\n}\nfunction isVisible(sign, tickPosition, getSize, start, end) {\n    /* Since getSize() is expensive (it reads the ticks' size from the DOM), we do this check first to avoid calculating\r\n   * the tick's size. */ if (sign * tickPosition < sign * start || sign * tickPosition > sign * end) {\n        return false;\n    }\n    var size = getSize();\n    return sign * (tickPosition - sign * size / 2 - start) >= 0 && sign * (tickPosition + sign * size / 2 - end) <= 0;\n}\nfunction getNumberIntervalTicks(ticks, interval) {\n    return (0, _getEveryNthWithCondition.getEveryNthWithCondition)(ticks, interval + 1);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9UaWNrVXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELDBCQUEwQixHQUFHRTtBQUM3QkYsOEJBQThCLEdBQUdHO0FBQ2pDSCx5QkFBeUIsR0FBR0k7QUFDNUJKLGlCQUFpQixHQUFHSztBQUNwQixJQUFJQyxrQkFBa0JDLG1CQUFPQSxDQUFDLDZGQUFrQjtBQUNoRCxJQUFJQyw0QkFBNEJELG1CQUFPQSxDQUFDLGlIQUE0QjtBQUNwRSxTQUFTTCxtQkFBbUJPLFdBQVcsRUFBRUMsUUFBUSxFQUFFQyxLQUFLO0lBQ3RELElBQUlDLE9BQU87UUFDVEMsT0FBT0osWUFBWUksS0FBSyxHQUFHSCxTQUFTRyxLQUFLO1FBQ3pDQyxRQUFRTCxZQUFZSyxNQUFNLEdBQUdKLFNBQVNJLE1BQU07SUFDOUM7SUFDQSxPQUFPLENBQUMsR0FBR1IsZ0JBQWdCUyx1QkFBdUIsRUFBRUgsTUFBTUQ7QUFDNUQ7QUFDQSxTQUFTUCxrQkFBa0JZLE9BQU8sRUFBRUMsSUFBSSxFQUFFQyxPQUFPO0lBQy9DLElBQUlDLFVBQVVELFlBQVk7SUFDMUIsSUFBSUUsSUFBSUosUUFBUUksQ0FBQyxFQUNmQyxJQUFJTCxRQUFRSyxDQUFDLEVBQ2JSLFFBQVFHLFFBQVFILEtBQUssRUFDckJDLFNBQVNFLFFBQVFGLE1BQU07SUFDekIsSUFBSUcsU0FBUyxHQUFHO1FBQ2QsT0FBTztZQUNMSyxPQUFPSCxVQUFVQyxJQUFJQztZQUNyQkUsS0FBS0osVUFBVUMsSUFBSVAsUUFBUVEsSUFBSVA7UUFDakM7SUFDRjtJQUNBLE9BQU87UUFDTFEsT0FBT0gsVUFBVUMsSUFBSVAsUUFBUVEsSUFBSVA7UUFDakNTLEtBQUtKLFVBQVVDLElBQUlDO0lBQ3JCO0FBQ0Y7QUFDQSxTQUFTaEIsVUFBVVksSUFBSSxFQUFFTyxZQUFZLEVBQUVDLE9BQU8sRUFBRUgsS0FBSyxFQUFFQyxHQUFHO0lBQ3hEO3NCQUNvQixHQUNwQixJQUFJTixPQUFPTyxlQUFlUCxPQUFPSyxTQUFTTCxPQUFPTyxlQUFlUCxPQUFPTSxLQUFLO1FBQzFFLE9BQU87SUFDVDtJQUNBLElBQUlYLE9BQU9hO0lBQ1gsT0FBT1IsT0FBUU8sQ0FBQUEsZUFBZVAsT0FBT0wsT0FBTyxJQUFJVSxLQUFJLEtBQU0sS0FBS0wsT0FBUU8sQ0FBQUEsZUFBZVAsT0FBT0wsT0FBTyxJQUFJVyxHQUFFLEtBQU07QUFDbEg7QUFDQSxTQUFTcEIsdUJBQXVCdUIsS0FBSyxFQUFFQyxRQUFRO0lBQzdDLE9BQU8sQ0FBQyxHQUFHbkIsMEJBQTBCb0Isd0JBQXdCLEVBQUVGLE9BQU9DLFdBQVc7QUFDbkYiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXHV0aWxcXFRpY2tVdGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmdldEFuZ2xlZFRpY2tXaWR0aCA9IGdldEFuZ2xlZFRpY2tXaWR0aDtcclxuZXhwb3J0cy5nZXROdW1iZXJJbnRlcnZhbFRpY2tzID0gZ2V0TnVtYmVySW50ZXJ2YWxUaWNrcztcclxuZXhwb3J0cy5nZXRUaWNrQm91bmRhcmllcyA9IGdldFRpY2tCb3VuZGFyaWVzO1xyXG5leHBvcnRzLmlzVmlzaWJsZSA9IGlzVmlzaWJsZTtcclxudmFyIF9DYXJ0ZXNpYW5VdGlscyA9IHJlcXVpcmUoXCIuL0NhcnRlc2lhblV0aWxzXCIpO1xyXG52YXIgX2dldEV2ZXJ5TnRoV2l0aENvbmRpdGlvbiA9IHJlcXVpcmUoXCIuL2dldEV2ZXJ5TnRoV2l0aENvbmRpdGlvblwiKTtcclxuZnVuY3Rpb24gZ2V0QW5nbGVkVGlja1dpZHRoKGNvbnRlbnRTaXplLCB1bml0U2l6ZSwgYW5nbGUpIHtcclxuICB2YXIgc2l6ZSA9IHtcclxuICAgIHdpZHRoOiBjb250ZW50U2l6ZS53aWR0aCArIHVuaXRTaXplLndpZHRoLFxyXG4gICAgaGVpZ2h0OiBjb250ZW50U2l6ZS5oZWlnaHQgKyB1bml0U2l6ZS5oZWlnaHRcclxuICB9O1xyXG4gIHJldHVybiAoMCwgX0NhcnRlc2lhblV0aWxzLmdldEFuZ2xlZFJlY3RhbmdsZVdpZHRoKShzaXplLCBhbmdsZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VGlja0JvdW5kYXJpZXModmlld0JveCwgc2lnbiwgc2l6ZUtleSkge1xyXG4gIHZhciBpc1dpZHRoID0gc2l6ZUtleSA9PT0gJ3dpZHRoJztcclxuICB2YXIgeCA9IHZpZXdCb3gueCxcclxuICAgIHkgPSB2aWV3Qm94LnksXHJcbiAgICB3aWR0aCA9IHZpZXdCb3gud2lkdGgsXHJcbiAgICBoZWlnaHQgPSB2aWV3Qm94LmhlaWdodDtcclxuICBpZiAoc2lnbiA9PT0gMSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3RhcnQ6IGlzV2lkdGggPyB4IDogeSxcclxuICAgICAgZW5kOiBpc1dpZHRoID8geCArIHdpZHRoIDogeSArIGhlaWdodFxyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHN0YXJ0OiBpc1dpZHRoID8geCArIHdpZHRoIDogeSArIGhlaWdodCxcclxuICAgIGVuZDogaXNXaWR0aCA/IHggOiB5XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBpc1Zpc2libGUoc2lnbiwgdGlja1Bvc2l0aW9uLCBnZXRTaXplLCBzdGFydCwgZW5kKSB7XHJcbiAgLyogU2luY2UgZ2V0U2l6ZSgpIGlzIGV4cGVuc2l2ZSAoaXQgcmVhZHMgdGhlIHRpY2tzJyBzaXplIGZyb20gdGhlIERPTSksIHdlIGRvIHRoaXMgY2hlY2sgZmlyc3QgdG8gYXZvaWQgY2FsY3VsYXRpbmdcclxuICAgKiB0aGUgdGljaydzIHNpemUuICovXHJcbiAgaWYgKHNpZ24gKiB0aWNrUG9zaXRpb24gPCBzaWduICogc3RhcnQgfHwgc2lnbiAqIHRpY2tQb3NpdGlvbiA+IHNpZ24gKiBlbmQpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgdmFyIHNpemUgPSBnZXRTaXplKCk7XHJcbiAgcmV0dXJuIHNpZ24gKiAodGlja1Bvc2l0aW9uIC0gc2lnbiAqIHNpemUgLyAyIC0gc3RhcnQpID49IDAgJiYgc2lnbiAqICh0aWNrUG9zaXRpb24gKyBzaWduICogc2l6ZSAvIDIgLSBlbmQpIDw9IDA7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TnVtYmVySW50ZXJ2YWxUaWNrcyh0aWNrcywgaW50ZXJ2YWwpIHtcclxuICByZXR1cm4gKDAsIF9nZXRFdmVyeU50aFdpdGhDb25kaXRpb24uZ2V0RXZlcnlOdGhXaXRoQ29uZGl0aW9uKSh0aWNrcywgaW50ZXJ2YWwgKyAxKTtcclxufSJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldEFuZ2xlZFRpY2tXaWR0aCIsImdldE51bWJlckludGVydmFsVGlja3MiLCJnZXRUaWNrQm91bmRhcmllcyIsImlzVmlzaWJsZSIsIl9DYXJ0ZXNpYW5VdGlscyIsInJlcXVpcmUiLCJfZ2V0RXZlcnlOdGhXaXRoQ29uZGl0aW9uIiwiY29udGVudFNpemUiLCJ1bml0U2l6ZSIsImFuZ2xlIiwic2l6ZSIsIndpZHRoIiwiaGVpZ2h0IiwiZ2V0QW5nbGVkUmVjdGFuZ2xlV2lkdGgiLCJ2aWV3Qm94Iiwic2lnbiIsInNpemVLZXkiLCJpc1dpZHRoIiwieCIsInkiLCJzdGFydCIsImVuZCIsInRpY2tQb3NpdGlvbiIsImdldFNpemUiLCJ0aWNrcyIsImludGVydmFsIiwiZ2V0RXZlcnlOdGhXaXRoQ29uZGl0aW9uIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/TickUtils.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/calculateViewBox.js":
/*!************************************************************!*\
  !*** ./node_modules/recharts/lib/util/calculateViewBox.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.calculateViewBox = void 0;\nvar _memoize = _interopRequireDefault(__webpack_require__(/*! lodash/memoize */ \"lodash/memoize\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\n/**\r\n * This is memoized because the viewBox is unlikely to change often\r\n * - but because it is computed from offset, any change to it would re-render all children.\r\n *\r\n * And because we have many readers of the viewBox, and update it only rarely,\r\n * then let's optimize with memoization.\r\n */ var calculateViewBox = exports.calculateViewBox = (0, _memoize[\"default\"])(function(offset) {\n    return {\n        x: offset.left,\n        y: offset.top,\n        width: offset.width,\n        height: offset.height\n    };\n}, function(offset) {\n    return [\n        'l',\n        offset.left,\n        't',\n        offset.top,\n        'w',\n        offset.width,\n        'h',\n        offset.height\n    ].join('');\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9jYWxjdWxhdGVWaWV3Qm94LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCx3QkFBd0IsR0FBRyxLQUFLO0FBQ2hDLElBQUlHLFdBQVdDLHVCQUF1QkMsbUJBQU9BLENBQUMsc0NBQWdCO0FBQzlELFNBQVNELHVCQUF1QkUsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRzs7Ozs7O0NBTUMsR0FDRCxJQUFJSixtQkFBbUJGLHdCQUF3QixHQUFHLENBQUMsR0FBR0csUUFBUSxDQUFDLFVBQVUsRUFBRSxTQUFVSyxNQUFNO0lBQ3pGLE9BQU87UUFDTEMsR0FBR0QsT0FBT0UsSUFBSTtRQUNkQyxHQUFHSCxPQUFPSSxHQUFHO1FBQ2JDLE9BQU9MLE9BQU9LLEtBQUs7UUFDbkJDLFFBQVFOLE9BQU9NLE1BQU07SUFDdkI7QUFDRixHQUFHLFNBQVVOLE1BQU07SUFDakIsT0FBTztRQUFDO1FBQUtBLE9BQU9FLElBQUk7UUFBRTtRQUFLRixPQUFPSSxHQUFHO1FBQUU7UUFBS0osT0FBT0ssS0FBSztRQUFFO1FBQUtMLE9BQU9NLE1BQU07S0FBQyxDQUFDQyxJQUFJLENBQUM7QUFDekYiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXHV0aWxcXGNhbGN1bGF0ZVZpZXdCb3guanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5jYWxjdWxhdGVWaWV3Qm94ID0gdm9pZCAwO1xyXG52YXIgX21lbW9pemUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvbWVtb2l6ZVwiKSk7XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG4vKipcclxuICogVGhpcyBpcyBtZW1vaXplZCBiZWNhdXNlIHRoZSB2aWV3Qm94IGlzIHVubGlrZWx5IHRvIGNoYW5nZSBvZnRlblxyXG4gKiAtIGJ1dCBiZWNhdXNlIGl0IGlzIGNvbXB1dGVkIGZyb20gb2Zmc2V0LCBhbnkgY2hhbmdlIHRvIGl0IHdvdWxkIHJlLXJlbmRlciBhbGwgY2hpbGRyZW4uXHJcbiAqXHJcbiAqIEFuZCBiZWNhdXNlIHdlIGhhdmUgbWFueSByZWFkZXJzIG9mIHRoZSB2aWV3Qm94LCBhbmQgdXBkYXRlIGl0IG9ubHkgcmFyZWx5LFxyXG4gKiB0aGVuIGxldCdzIG9wdGltaXplIHdpdGggbWVtb2l6YXRpb24uXHJcbiAqL1xyXG52YXIgY2FsY3VsYXRlVmlld0JveCA9IGV4cG9ydHMuY2FsY3VsYXRlVmlld0JveCA9ICgwLCBfbWVtb2l6ZVtcImRlZmF1bHRcIl0pKGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuICByZXR1cm4ge1xyXG4gICAgeDogb2Zmc2V0LmxlZnQsXHJcbiAgICB5OiBvZmZzZXQudG9wLFxyXG4gICAgd2lkdGg6IG9mZnNldC53aWR0aCxcclxuICAgIGhlaWdodDogb2Zmc2V0LmhlaWdodFxyXG4gIH07XHJcbn0sIGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuICByZXR1cm4gWydsJywgb2Zmc2V0LmxlZnQsICd0Jywgb2Zmc2V0LnRvcCwgJ3cnLCBvZmZzZXQud2lkdGgsICdoJywgb2Zmc2V0LmhlaWdodF0uam9pbignJyk7XHJcbn0pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNhbGN1bGF0ZVZpZXdCb3giLCJfbWVtb2l6ZSIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwib2JqIiwiX19lc01vZHVsZSIsIm9mZnNldCIsIngiLCJsZWZ0IiwieSIsInRvcCIsIndpZHRoIiwiaGVpZ2h0Iiwiam9pbiJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/calculateViewBox.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/cursor/getCursorPoints.js":
/*!******************************************************************!*\
  !*** ./node_modules/recharts/lib/util/cursor/getCursorPoints.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getCursorPoints = getCursorPoints;\nvar _PolarUtils = __webpack_require__(/*! ../PolarUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _getRadialCursorPoints = __webpack_require__(/*! ./getRadialCursorPoints */ \"(pages-dir-node)/./node_modules/recharts/lib/util/cursor/getRadialCursorPoints.js\");\nfunction getCursorPoints(layout, activeCoordinate, offset) {\n    var x1, y1, x2, y2;\n    if (layout === 'horizontal') {\n        x1 = activeCoordinate.x;\n        x2 = x1;\n        y1 = offset.top;\n        y2 = offset.top + offset.height;\n    } else if (layout === 'vertical') {\n        y1 = activeCoordinate.y;\n        y2 = y1;\n        x1 = offset.left;\n        x2 = offset.left + offset.width;\n    } else if (activeCoordinate.cx != null && activeCoordinate.cy != null) {\n        if (layout === 'centric') {\n            var cx = activeCoordinate.cx, cy = activeCoordinate.cy, innerRadius = activeCoordinate.innerRadius, outerRadius = activeCoordinate.outerRadius, angle = activeCoordinate.angle;\n            var innerPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, innerRadius, angle);\n            var outerPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, outerRadius, angle);\n            x1 = innerPoint.x;\n            y1 = innerPoint.y;\n            x2 = outerPoint.x;\n            y2 = outerPoint.y;\n        } else {\n            return (0, _getRadialCursorPoints.getRadialCursorPoints)(activeCoordinate);\n        }\n    }\n    return [\n        {\n            x: x1,\n            y: y1\n        },\n        {\n            x: x2,\n            y: y2\n        }\n    ];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9jdXJzb3IvZ2V0Q3Vyc29yUG9pbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCx1QkFBdUIsR0FBR0U7QUFDMUIsSUFBSUMsY0FBY0MsbUJBQU9BLENBQUMsc0ZBQWU7QUFDekMsSUFBSUMseUJBQXlCRCxtQkFBT0EsQ0FBQyxrSEFBeUI7QUFDOUQsU0FBU0YsZ0JBQWdCSSxNQUFNLEVBQUVDLGdCQUFnQixFQUFFQyxNQUFNO0lBQ3ZELElBQUlDLElBQUlDLElBQUlDLElBQUlDO0lBQ2hCLElBQUlOLFdBQVcsY0FBYztRQUMzQkcsS0FBS0YsaUJBQWlCTSxDQUFDO1FBQ3ZCRixLQUFLRjtRQUNMQyxLQUFLRixPQUFPTSxHQUFHO1FBQ2ZGLEtBQUtKLE9BQU9NLEdBQUcsR0FBR04sT0FBT08sTUFBTTtJQUNqQyxPQUFPLElBQUlULFdBQVcsWUFBWTtRQUNoQ0ksS0FBS0gsaUJBQWlCUyxDQUFDO1FBQ3ZCSixLQUFLRjtRQUNMRCxLQUFLRCxPQUFPUyxJQUFJO1FBQ2hCTixLQUFLSCxPQUFPUyxJQUFJLEdBQUdULE9BQU9VLEtBQUs7SUFDakMsT0FBTyxJQUFJWCxpQkFBaUJZLEVBQUUsSUFBSSxRQUFRWixpQkFBaUJhLEVBQUUsSUFBSSxNQUFNO1FBQ3JFLElBQUlkLFdBQVcsV0FBVztZQUN4QixJQUFJYSxLQUFLWixpQkFBaUJZLEVBQUUsRUFDMUJDLEtBQUtiLGlCQUFpQmEsRUFBRSxFQUN4QkMsY0FBY2QsaUJBQWlCYyxXQUFXLEVBQzFDQyxjQUFjZixpQkFBaUJlLFdBQVcsRUFDMUNDLFFBQVFoQixpQkFBaUJnQixLQUFLO1lBQ2hDLElBQUlDLGFBQWEsQ0FBQyxHQUFHckIsWUFBWXNCLGdCQUFnQixFQUFFTixJQUFJQyxJQUFJQyxhQUFhRTtZQUN4RSxJQUFJRyxhQUFhLENBQUMsR0FBR3ZCLFlBQVlzQixnQkFBZ0IsRUFBRU4sSUFBSUMsSUFBSUUsYUFBYUM7WUFDeEVkLEtBQUtlLFdBQVdYLENBQUM7WUFDakJILEtBQUtjLFdBQVdSLENBQUM7WUFDakJMLEtBQUtlLFdBQVdiLENBQUM7WUFDakJELEtBQUtjLFdBQVdWLENBQUM7UUFDbkIsT0FBTztZQUNMLE9BQU8sQ0FBQyxHQUFHWCx1QkFBdUJzQixxQkFBcUIsRUFBRXBCO1FBQzNEO0lBQ0Y7SUFDQSxPQUFPO1FBQUM7WUFDTk0sR0FBR0o7WUFDSE8sR0FBR047UUFDTDtRQUFHO1lBQ0RHLEdBQUdGO1lBQ0hLLEdBQUdKO1FBQ0w7S0FBRTtBQUNKIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFx1dGlsXFxjdXJzb3JcXGdldEN1cnNvclBvaW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmdldEN1cnNvclBvaW50cyA9IGdldEN1cnNvclBvaW50cztcclxudmFyIF9Qb2xhclV0aWxzID0gcmVxdWlyZShcIi4uL1BvbGFyVXRpbHNcIik7XHJcbnZhciBfZ2V0UmFkaWFsQ3Vyc29yUG9pbnRzID0gcmVxdWlyZShcIi4vZ2V0UmFkaWFsQ3Vyc29yUG9pbnRzXCIpO1xyXG5mdW5jdGlvbiBnZXRDdXJzb3JQb2ludHMobGF5b3V0LCBhY3RpdmVDb29yZGluYXRlLCBvZmZzZXQpIHtcclxuICB2YXIgeDEsIHkxLCB4MiwgeTI7XHJcbiAgaWYgKGxheW91dCA9PT0gJ2hvcml6b250YWwnKSB7XHJcbiAgICB4MSA9IGFjdGl2ZUNvb3JkaW5hdGUueDtcclxuICAgIHgyID0geDE7XHJcbiAgICB5MSA9IG9mZnNldC50b3A7XHJcbiAgICB5MiA9IG9mZnNldC50b3AgKyBvZmZzZXQuaGVpZ2h0O1xyXG4gIH0gZWxzZSBpZiAobGF5b3V0ID09PSAndmVydGljYWwnKSB7XHJcbiAgICB5MSA9IGFjdGl2ZUNvb3JkaW5hdGUueTtcclxuICAgIHkyID0geTE7XHJcbiAgICB4MSA9IG9mZnNldC5sZWZ0O1xyXG4gICAgeDIgPSBvZmZzZXQubGVmdCArIG9mZnNldC53aWR0aDtcclxuICB9IGVsc2UgaWYgKGFjdGl2ZUNvb3JkaW5hdGUuY3ggIT0gbnVsbCAmJiBhY3RpdmVDb29yZGluYXRlLmN5ICE9IG51bGwpIHtcclxuICAgIGlmIChsYXlvdXQgPT09ICdjZW50cmljJykge1xyXG4gICAgICB2YXIgY3ggPSBhY3RpdmVDb29yZGluYXRlLmN4LFxyXG4gICAgICAgIGN5ID0gYWN0aXZlQ29vcmRpbmF0ZS5jeSxcclxuICAgICAgICBpbm5lclJhZGl1cyA9IGFjdGl2ZUNvb3JkaW5hdGUuaW5uZXJSYWRpdXMsXHJcbiAgICAgICAgb3V0ZXJSYWRpdXMgPSBhY3RpdmVDb29yZGluYXRlLm91dGVyUmFkaXVzLFxyXG4gICAgICAgIGFuZ2xlID0gYWN0aXZlQ29vcmRpbmF0ZS5hbmdsZTtcclxuICAgICAgdmFyIGlubmVyUG9pbnQgPSAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikoY3gsIGN5LCBpbm5lclJhZGl1cywgYW5nbGUpO1xyXG4gICAgICB2YXIgb3V0ZXJQb2ludCA9ICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjeCwgY3ksIG91dGVyUmFkaXVzLCBhbmdsZSk7XHJcbiAgICAgIHgxID0gaW5uZXJQb2ludC54O1xyXG4gICAgICB5MSA9IGlubmVyUG9pbnQueTtcclxuICAgICAgeDIgPSBvdXRlclBvaW50Lng7XHJcbiAgICAgIHkyID0gb3V0ZXJQb2ludC55O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuICgwLCBfZ2V0UmFkaWFsQ3Vyc29yUG9pbnRzLmdldFJhZGlhbEN1cnNvclBvaW50cykoYWN0aXZlQ29vcmRpbmF0ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBbe1xyXG4gICAgeDogeDEsXHJcbiAgICB5OiB5MVxyXG4gIH0sIHtcclxuICAgIHg6IHgyLFxyXG4gICAgeTogeTJcclxuICB9XTtcclxufSJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldEN1cnNvclBvaW50cyIsIl9Qb2xhclV0aWxzIiwicmVxdWlyZSIsIl9nZXRSYWRpYWxDdXJzb3JQb2ludHMiLCJsYXlvdXQiLCJhY3RpdmVDb29yZGluYXRlIiwib2Zmc2V0IiwieDEiLCJ5MSIsIngyIiwieTIiLCJ4IiwidG9wIiwiaGVpZ2h0IiwieSIsImxlZnQiLCJ3aWR0aCIsImN4IiwiY3kiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIiwiYW5nbGUiLCJpbm5lclBvaW50IiwicG9sYXJUb0NhcnRlc2lhbiIsIm91dGVyUG9pbnQiLCJnZXRSYWRpYWxDdXJzb3JQb2ludHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/cursor/getCursorPoints.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/cursor/getCursorRectangle.js":
/*!*********************************************************************!*\
  !*** ./node_modules/recharts/lib/util/cursor/getCursorRectangle.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getCursorRectangle = getCursorRectangle;\nfunction getCursorRectangle(layout, activeCoordinate, offset, tooltipAxisBandSize) {\n    var halfSize = tooltipAxisBandSize / 2;\n    return {\n        stroke: 'none',\n        fill: '#ccc',\n        x: layout === 'horizontal' ? activeCoordinate.x - halfSize : offset.left + 0.5,\n        y: layout === 'horizontal' ? offset.top + 0.5 : activeCoordinate.y - halfSize,\n        width: layout === 'horizontal' ? tooltipAxisBandSize : offset.width - 1,\n        height: layout === 'horizontal' ? offset.height - 1 : tooltipAxisBandSize\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9jdXJzb3IvZ2V0Q3Vyc29yUmVjdGFuZ2xlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCwwQkFBMEIsR0FBR0U7QUFDN0IsU0FBU0EsbUJBQW1CQyxNQUFNLEVBQUVDLGdCQUFnQixFQUFFQyxNQUFNLEVBQUVDLG1CQUFtQjtJQUMvRSxJQUFJQyxXQUFXRCxzQkFBc0I7SUFDckMsT0FBTztRQUNMRSxRQUFRO1FBQ1JDLE1BQU07UUFDTkMsR0FBR1AsV0FBVyxlQUFlQyxpQkFBaUJNLENBQUMsR0FBR0gsV0FBV0YsT0FBT00sSUFBSSxHQUFHO1FBQzNFQyxHQUFHVCxXQUFXLGVBQWVFLE9BQU9RLEdBQUcsR0FBRyxNQUFNVCxpQkFBaUJRLENBQUMsR0FBR0w7UUFDckVPLE9BQU9YLFdBQVcsZUFBZUcsc0JBQXNCRCxPQUFPUyxLQUFLLEdBQUc7UUFDdEVDLFFBQVFaLFdBQVcsZUFBZUUsT0FBT1UsTUFBTSxHQUFHLElBQUlUO0lBQ3hEO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXHV0aWxcXGN1cnNvclxcZ2V0Q3Vyc29yUmVjdGFuZ2xlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZ2V0Q3Vyc29yUmVjdGFuZ2xlID0gZ2V0Q3Vyc29yUmVjdGFuZ2xlO1xyXG5mdW5jdGlvbiBnZXRDdXJzb3JSZWN0YW5nbGUobGF5b3V0LCBhY3RpdmVDb29yZGluYXRlLCBvZmZzZXQsIHRvb2x0aXBBeGlzQmFuZFNpemUpIHtcclxuICB2YXIgaGFsZlNpemUgPSB0b29sdGlwQXhpc0JhbmRTaXplIC8gMjtcclxuICByZXR1cm4ge1xyXG4gICAgc3Ryb2tlOiAnbm9uZScsXHJcbiAgICBmaWxsOiAnI2NjYycsXHJcbiAgICB4OiBsYXlvdXQgPT09ICdob3Jpem9udGFsJyA/IGFjdGl2ZUNvb3JkaW5hdGUueCAtIGhhbGZTaXplIDogb2Zmc2V0LmxlZnQgKyAwLjUsXHJcbiAgICB5OiBsYXlvdXQgPT09ICdob3Jpem9udGFsJyA/IG9mZnNldC50b3AgKyAwLjUgOiBhY3RpdmVDb29yZGluYXRlLnkgLSBoYWxmU2l6ZSxcclxuICAgIHdpZHRoOiBsYXlvdXQgPT09ICdob3Jpem9udGFsJyA/IHRvb2x0aXBBeGlzQmFuZFNpemUgOiBvZmZzZXQud2lkdGggLSAxLFxyXG4gICAgaGVpZ2h0OiBsYXlvdXQgPT09ICdob3Jpem9udGFsJyA/IG9mZnNldC5oZWlnaHQgLSAxIDogdG9vbHRpcEF4aXNCYW5kU2l6ZVxyXG4gIH07XHJcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRDdXJzb3JSZWN0YW5nbGUiLCJsYXlvdXQiLCJhY3RpdmVDb29yZGluYXRlIiwib2Zmc2V0IiwidG9vbHRpcEF4aXNCYW5kU2l6ZSIsImhhbGZTaXplIiwic3Ryb2tlIiwiZmlsbCIsIngiLCJsZWZ0IiwieSIsInRvcCIsIndpZHRoIiwiaGVpZ2h0Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/cursor/getCursorRectangle.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/cursor/getRadialCursorPoints.js":
/*!************************************************************************!*\
  !*** ./node_modules/recharts/lib/util/cursor/getRadialCursorPoints.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getRadialCursorPoints = getRadialCursorPoints;\nvar _PolarUtils = __webpack_require__(/*! ../PolarUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/PolarUtils.js\");\n/**\r\n * Only applicable for radial layouts\r\n * @param {Object} activeCoordinate ChartCoordinate\r\n * @returns {Object} RadialCursorPoints\r\n */ function getRadialCursorPoints(activeCoordinate) {\n    var cx = activeCoordinate.cx, cy = activeCoordinate.cy, radius = activeCoordinate.radius, startAngle = activeCoordinate.startAngle, endAngle = activeCoordinate.endAngle;\n    var startPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, radius, startAngle);\n    var endPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, radius, endAngle);\n    return {\n        points: [\n            startPoint,\n            endPoint\n        ],\n        cx: cx,\n        cy: cy,\n        radius: radius,\n        startAngle: startAngle,\n        endAngle: endAngle\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9jdXJzb3IvZ2V0UmFkaWFsQ3Vyc29yUG9pbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCw2QkFBNkIsR0FBR0U7QUFDaEMsSUFBSUMsY0FBY0MsbUJBQU9BLENBQUMsc0ZBQWU7QUFDekM7Ozs7Q0FJQyxHQUNELFNBQVNGLHNCQUFzQkcsZ0JBQWdCO0lBQzdDLElBQUlDLEtBQUtELGlCQUFpQkMsRUFBRSxFQUMxQkMsS0FBS0YsaUJBQWlCRSxFQUFFLEVBQ3hCQyxTQUFTSCxpQkFBaUJHLE1BQU0sRUFDaENDLGFBQWFKLGlCQUFpQkksVUFBVSxFQUN4Q0MsV0FBV0wsaUJBQWlCSyxRQUFRO0lBQ3RDLElBQUlDLGFBQWEsQ0FBQyxHQUFHUixZQUFZUyxnQkFBZ0IsRUFBRU4sSUFBSUMsSUFBSUMsUUFBUUM7SUFDbkUsSUFBSUksV0FBVyxDQUFDLEdBQUdWLFlBQVlTLGdCQUFnQixFQUFFTixJQUFJQyxJQUFJQyxRQUFRRTtJQUNqRSxPQUFPO1FBQ0xJLFFBQVE7WUFBQ0g7WUFBWUU7U0FBUztRQUM5QlAsSUFBSUE7UUFDSkMsSUFBSUE7UUFDSkMsUUFBUUE7UUFDUkMsWUFBWUE7UUFDWkMsVUFBVUE7SUFDWjtBQUNGIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFx1dGlsXFxjdXJzb3JcXGdldFJhZGlhbEN1cnNvclBvaW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmdldFJhZGlhbEN1cnNvclBvaW50cyA9IGdldFJhZGlhbEN1cnNvclBvaW50cztcclxudmFyIF9Qb2xhclV0aWxzID0gcmVxdWlyZShcIi4uL1BvbGFyVXRpbHNcIik7XHJcbi8qKlxyXG4gKiBPbmx5IGFwcGxpY2FibGUgZm9yIHJhZGlhbCBsYXlvdXRzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3RpdmVDb29yZGluYXRlIENoYXJ0Q29vcmRpbmF0ZVxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSYWRpYWxDdXJzb3JQb2ludHNcclxuICovXHJcbmZ1bmN0aW9uIGdldFJhZGlhbEN1cnNvclBvaW50cyhhY3RpdmVDb29yZGluYXRlKSB7XHJcbiAgdmFyIGN4ID0gYWN0aXZlQ29vcmRpbmF0ZS5jeCxcclxuICAgIGN5ID0gYWN0aXZlQ29vcmRpbmF0ZS5jeSxcclxuICAgIHJhZGl1cyA9IGFjdGl2ZUNvb3JkaW5hdGUucmFkaXVzLFxyXG4gICAgc3RhcnRBbmdsZSA9IGFjdGl2ZUNvb3JkaW5hdGUuc3RhcnRBbmdsZSxcclxuICAgIGVuZEFuZ2xlID0gYWN0aXZlQ29vcmRpbmF0ZS5lbmRBbmdsZTtcclxuICB2YXIgc3RhcnRQb2ludCA9ICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSk7XHJcbiAgdmFyIGVuZFBvaW50ID0gKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKGN4LCBjeSwgcmFkaXVzLCBlbmRBbmdsZSk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHBvaW50czogW3N0YXJ0UG9pbnQsIGVuZFBvaW50XSxcclxuICAgIGN4OiBjeCxcclxuICAgIGN5OiBjeSxcclxuICAgIHJhZGl1czogcmFkaXVzLFxyXG4gICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcclxuICAgIGVuZEFuZ2xlOiBlbmRBbmdsZVxyXG4gIH07XHJcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRSYWRpYWxDdXJzb3JQb2ludHMiLCJfUG9sYXJVdGlscyIsInJlcXVpcmUiLCJhY3RpdmVDb29yZGluYXRlIiwiY3giLCJjeSIsInJhZGl1cyIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsInN0YXJ0UG9pbnQiLCJwb2xhclRvQ2FydGVzaWFuIiwiZW5kUG9pbnQiLCJwb2ludHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/cursor/getRadialCursorPoints.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/getEveryNthWithCondition.js":
/*!********************************************************************!*\
  !*** ./node_modules/recharts/lib/util/getEveryNthWithCondition.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getEveryNthWithCondition = getEveryNthWithCondition;\n/**\r\n * Given an array and a number N, return a new array which contains every nTh\r\n * element of the input array. For n below 1, an empty array is returned.\r\n * If isValid is provided, all candidates must suffice the condition, else undefined is returned.\r\n * @param {T[]} array An input array.\r\n * @param {integer} n A number\r\n * @param {Function} isValid A function to evaluate a candidate form the array\r\n * @returns {T[]} The result array of the same type as the input array.\r\n */ function getEveryNthWithCondition(array, n, isValid) {\n    if (n < 1) {\n        return [];\n    }\n    if (n === 1 && isValid === undefined) {\n        return array;\n    }\n    var result = [];\n    for(var i = 0; i < array.length; i += n){\n        if (isValid === undefined || isValid(array[i]) === true) {\n            result.push(array[i]);\n        } else {\n            return undefined;\n        }\n    }\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9nZXRFdmVyeU50aFdpdGhDb25kaXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGdDQUFnQyxHQUFHRTtBQUNuQzs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNBLHlCQUF5QkMsS0FBSyxFQUFFQyxDQUFDLEVBQUVDLE9BQU87SUFDakQsSUFBSUQsSUFBSSxHQUFHO1FBQ1QsT0FBTyxFQUFFO0lBQ1g7SUFDQSxJQUFJQSxNQUFNLEtBQUtDLFlBQVlDLFdBQVc7UUFDcEMsT0FBT0g7SUFDVDtJQUNBLElBQUlJLFNBQVMsRUFBRTtJQUNmLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTCxNQUFNTSxNQUFNLEVBQUVELEtBQUtKLEVBQUc7UUFDeEMsSUFBSUMsWUFBWUMsYUFBYUQsUUFBUUYsS0FBSyxDQUFDSyxFQUFFLE1BQU0sTUFBTTtZQUN2REQsT0FBT0csSUFBSSxDQUFDUCxLQUFLLENBQUNLLEVBQUU7UUFDdEIsT0FBTztZQUNMLE9BQU9GO1FBQ1Q7SUFDRjtJQUNBLE9BQU9DO0FBQ1QiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXHV0aWxcXGdldEV2ZXJ5TnRoV2l0aENvbmRpdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmdldEV2ZXJ5TnRoV2l0aENvbmRpdGlvbiA9IGdldEV2ZXJ5TnRoV2l0aENvbmRpdGlvbjtcclxuLyoqXHJcbiAqIEdpdmVuIGFuIGFycmF5IGFuZCBhIG51bWJlciBOLCByZXR1cm4gYSBuZXcgYXJyYXkgd2hpY2ggY29udGFpbnMgZXZlcnkgblRoXHJcbiAqIGVsZW1lbnQgb2YgdGhlIGlucHV0IGFycmF5LiBGb3IgbiBiZWxvdyAxLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZC5cclxuICogSWYgaXNWYWxpZCBpcyBwcm92aWRlZCwgYWxsIGNhbmRpZGF0ZXMgbXVzdCBzdWZmaWNlIHRoZSBjb25kaXRpb24sIGVsc2UgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxyXG4gKiBAcGFyYW0ge1RbXX0gYXJyYXkgQW4gaW5wdXQgYXJyYXkuXHJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gbiBBIG51bWJlclxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpc1ZhbGlkIEEgZnVuY3Rpb24gdG8gZXZhbHVhdGUgYSBjYW5kaWRhdGUgZm9ybSB0aGUgYXJyYXlcclxuICogQHJldHVybnMge1RbXX0gVGhlIHJlc3VsdCBhcnJheSBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBpbnB1dCBhcnJheS5cclxuICovXHJcbmZ1bmN0aW9uIGdldEV2ZXJ5TnRoV2l0aENvbmRpdGlvbihhcnJheSwgbiwgaXNWYWxpZCkge1xyXG4gIGlmIChuIDwgMSkge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuICBpZiAobiA9PT0gMSAmJiBpc1ZhbGlkID09PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiBhcnJheTtcclxuICB9XHJcbiAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IG4pIHtcclxuICAgIGlmIChpc1ZhbGlkID09PSB1bmRlZmluZWQgfHwgaXNWYWxpZChhcnJheVtpXSkgPT09IHRydWUpIHtcclxuICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufSJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldEV2ZXJ5TnRoV2l0aENvbmRpdGlvbiIsImFycmF5IiwibiIsImlzVmFsaWQiLCJ1bmRlZmluZWQiLCJyZXN1bHQiLCJpIiwibGVuZ3RoIiwicHVzaCJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/getEveryNthWithCondition.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/getLegendProps.js":
/*!**********************************************************!*\
  !*** ./node_modules/recharts/lib/util/getLegendProps.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getLegendProps = void 0;\nvar _Legend = __webpack_require__(/*! ../component/Legend */ \"(pages-dir-node)/./node_modules/recharts/lib/component/Legend.js\");\nvar _ChartUtils = __webpack_require__(/*! ./ChartUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ./ReactUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/ReactUtils.js\");\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar getLegendProps = exports.getLegendProps = function getLegendProps(_ref) {\n    var children = _ref.children, formattedGraphicalItems = _ref.formattedGraphicalItems, legendWidth = _ref.legendWidth, legendContent = _ref.legendContent;\n    var legendItem = (0, _ReactUtils.findChildByType)(children, _Legend.Legend);\n    if (!legendItem) {\n        return null;\n    }\n    var legendDefaultProps = _Legend.Legend.defaultProps;\n    var legendProps = legendDefaultProps !== undefined ? _objectSpread(_objectSpread({}, legendDefaultProps), legendItem.props) : {};\n    var legendData;\n    if (legendItem.props && legendItem.props.payload) {\n        legendData = legendItem.props && legendItem.props.payload;\n    } else if (legendContent === 'children') {\n        legendData = (formattedGraphicalItems || []).reduce(function(result, _ref2) {\n            var item = _ref2.item, props = _ref2.props;\n            var data = props.sectors || props.data || [];\n            return result.concat(data.map(function(entry) {\n                return {\n                    type: legendItem.props.iconType || item.props.legendType,\n                    value: entry.name,\n                    color: entry.fill,\n                    payload: entry\n                };\n            }));\n        }, []);\n    } else {\n        legendData = (formattedGraphicalItems || []).map(function(_ref3) {\n            var item = _ref3.item;\n            var itemDefaultProps = item.type.defaultProps;\n            var itemProps = itemDefaultProps !== undefined ? _objectSpread(_objectSpread({}, itemDefaultProps), item.props) : {};\n            var dataKey = itemProps.dataKey, name = itemProps.name, legendType = itemProps.legendType, hide = itemProps.hide;\n            return {\n                inactive: hide,\n                dataKey: dataKey,\n                type: legendProps.iconType || legendType || 'square',\n                color: (0, _ChartUtils.getMainColorOfGraphicItem)(item),\n                value: name || dataKey,\n                // @ts-expect-error property strokeDasharray is required in Payload but optional in props\n                payload: itemProps\n            };\n        });\n    }\n    return _objectSpread(_objectSpread(_objectSpread({}, legendProps), _Legend.Legend.getWithHeight(legendItem, legendWidth)), {}, {\n        payload: legendData,\n        item: legendItem\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9nZXRMZWdlbmRQcm9wcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsc0JBQXNCLEdBQUcsS0FBSztBQUM5QixJQUFJRyxVQUFVQyxtQkFBT0EsQ0FBQyw2RkFBcUI7QUFDM0MsSUFBSUMsY0FBY0QsbUJBQU9BLENBQUMscUZBQWM7QUFDeEMsSUFBSUUsY0FBY0YsbUJBQU9BLENBQUMscUZBQWM7QUFDeEMsU0FBU0csUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUUsV0FBVyxLQUFLQyxVQUFVRCxNQUFNQyxPQUFPRSxTQUFTLEdBQUcsV0FBVyxPQUFPSDtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1QsU0FBU0ksUUFBUUMsQ0FBQyxFQUFFQyxDQUFDO0lBQUksSUFBSUMsSUFBSWpCLE9BQU9rQixJQUFJLENBQUNIO0lBQUksSUFBSWYsT0FBT21CLHFCQUFxQixFQUFFO1FBQUUsSUFBSVQsSUFBSVYsT0FBT21CLHFCQUFxQixDQUFDSjtRQUFJQyxLQUFNTixDQUFBQSxJQUFJQSxFQUFFVSxNQUFNLENBQUMsU0FBVUosQ0FBQztZQUFJLE9BQU9oQixPQUFPcUIsd0JBQXdCLENBQUNOLEdBQUdDLEdBQUdNLFVBQVU7UUFBRSxFQUFDLEdBQUlMLEVBQUVNLElBQUksQ0FBQ0MsS0FBSyxDQUFDUCxHQUFHUDtJQUFJO0lBQUUsT0FBT087QUFBRztBQUM5UCxTQUFTUSxjQUFjVixDQUFDO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlVLFVBQVVDLE1BQU0s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bm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFx1dGlsXFxnZXRMZWdlbmRQcm9wcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmdldExlZ2VuZFByb3BzID0gdm9pZCAwO1xyXG52YXIgX0xlZ2VuZCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQvTGVnZW5kXCIpO1xyXG52YXIgX0NoYXJ0VXRpbHMgPSByZXF1aXJlKFwiLi9DaGFydFV0aWxzXCIpO1xyXG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi9SZWFjdFV0aWxzXCIpO1xyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxyXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cclxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cclxudmFyIGdldExlZ2VuZFByb3BzID0gZXhwb3J0cy5nZXRMZWdlbmRQcm9wcyA9IGZ1bmN0aW9uIGdldExlZ2VuZFByb3BzKF9yZWYpIHtcclxuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxyXG4gICAgZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXMgPSBfcmVmLmZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zLFxyXG4gICAgbGVnZW5kV2lkdGggPSBfcmVmLmxlZ2VuZFdpZHRoLFxyXG4gICAgbGVnZW5kQ29udGVudCA9IF9yZWYubGVnZW5kQ29udGVudDtcclxuICB2YXIgbGVnZW5kSXRlbSA9ICgwLCBfUmVhY3RVdGlscy5maW5kQ2hpbGRCeVR5cGUpKGNoaWxkcmVuLCBfTGVnZW5kLkxlZ2VuZCk7XHJcbiAgaWYgKCFsZWdlbmRJdGVtKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgdmFyIGxlZ2VuZERlZmF1bHRQcm9wcyA9IF9MZWdlbmQuTGVnZW5kLmRlZmF1bHRQcm9wcztcclxuICB2YXIgbGVnZW5kUHJvcHMgPSBsZWdlbmREZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbGVnZW5kRGVmYXVsdFByb3BzKSwgbGVnZW5kSXRlbS5wcm9wcykgOiB7fTtcclxuICB2YXIgbGVnZW5kRGF0YTtcclxuICBpZiAobGVnZW5kSXRlbS5wcm9wcyAmJiBsZWdlbmRJdGVtLnByb3BzLnBheWxvYWQpIHtcclxuICAgIGxlZ2VuZERhdGEgPSBsZWdlbmRJdGVtLnByb3BzICYmIGxlZ2VuZEl0ZW0ucHJvcHMucGF5bG9hZDtcclxuICB9IGVsc2UgaWYgKGxlZ2VuZENvbnRlbnQgPT09ICdjaGlsZHJlbicpIHtcclxuICAgIGxlZ2VuZERhdGEgPSAoZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXMgfHwgW10pLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBfcmVmMikge1xyXG4gICAgICB2YXIgaXRlbSA9IF9yZWYyLml0ZW0sXHJcbiAgICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcclxuICAgICAgdmFyIGRhdGEgPSBwcm9wcy5zZWN0b3JzIHx8IHByb3BzLmRhdGEgfHwgW107XHJcbiAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KGRhdGEubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB0eXBlOiBsZWdlbmRJdGVtLnByb3BzLmljb25UeXBlIHx8IGl0ZW0ucHJvcHMubGVnZW5kVHlwZSxcclxuICAgICAgICAgIHZhbHVlOiBlbnRyeS5uYW1lLFxyXG4gICAgICAgICAgY29sb3I6IGVudHJ5LmZpbGwsXHJcbiAgICAgICAgICBwYXlsb2FkOiBlbnRyeVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0pKTtcclxuICAgIH0sIFtdKTtcclxuICB9IGVsc2Uge1xyXG4gICAgbGVnZW5kRGF0YSA9IChmb3JtYXR0ZWRHcmFwaGljYWxJdGVtcyB8fCBbXSkubWFwKGZ1bmN0aW9uIChfcmVmMykge1xyXG4gICAgICB2YXIgaXRlbSA9IF9yZWYzLml0ZW07XHJcbiAgICAgIHZhciBpdGVtRGVmYXVsdFByb3BzID0gaXRlbS50eXBlLmRlZmF1bHRQcm9wcztcclxuICAgICAgdmFyIGl0ZW1Qcm9wcyA9IGl0ZW1EZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaXRlbURlZmF1bHRQcm9wcyksIGl0ZW0ucHJvcHMpIDoge307XHJcbiAgICAgIHZhciBkYXRhS2V5ID0gaXRlbVByb3BzLmRhdGFLZXksXHJcbiAgICAgICAgbmFtZSA9IGl0ZW1Qcm9wcy5uYW1lLFxyXG4gICAgICAgIGxlZ2VuZFR5cGUgPSBpdGVtUHJvcHMubGVnZW5kVHlwZSxcclxuICAgICAgICBoaWRlID0gaXRlbVByb3BzLmhpZGU7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaW5hY3RpdmU6IGhpZGUsXHJcbiAgICAgICAgZGF0YUtleTogZGF0YUtleSxcclxuICAgICAgICB0eXBlOiBsZWdlbmRQcm9wcy5pY29uVHlwZSB8fCBsZWdlbmRUeXBlIHx8ICdzcXVhcmUnLFxyXG4gICAgICAgIGNvbG9yOiAoMCwgX0NoYXJ0VXRpbHMuZ2V0TWFpbkNvbG9yT2ZHcmFwaGljSXRlbSkoaXRlbSksXHJcbiAgICAgICAgdmFsdWU6IG5hbWUgfHwgZGF0YUtleSxcclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHByb3BlcnR5IHN0cm9rZURhc2hhcnJheSBpcyByZXF1aXJlZCBpbiBQYXlsb2FkIGJ1dCBvcHRpb25hbCBpbiBwcm9wc1xyXG4gICAgICAgIHBheWxvYWQ6IGl0ZW1Qcm9wc1xyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbGVnZW5kUHJvcHMpLCBfTGVnZW5kLkxlZ2VuZC5nZXRXaXRoSGVpZ2h0KGxlZ2VuZEl0ZW0sIGxlZ2VuZFdpZHRoKSksIHt9LCB7XHJcbiAgICBwYXlsb2FkOiBsZWdlbmREYXRhLFxyXG4gICAgaXRlbTogbGVnZW5kSXRlbVxyXG4gIH0pO1xyXG59OyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldExlZ2VuZFByb3BzIiwiX0xlZ2VuZCIsInJlcXVpcmUiLCJfQ2hhcnRVdGlscyIsIl9SZWFjdFV0aWxzIiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsIm93bktleXMiLCJlIiwiciIsInQiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJvYmoiLCJrZXkiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiaSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiY2FsbCIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsIl9yZWYiLCJjaGlsZHJlbiIsImZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zIiwibGVnZW5kV2lkdGgiLCJsZWdlbmRDb250ZW50IiwibGVnZW5kSXRlbSIsImZpbmRDaGlsZEJ5VHlwZSIsIkxlZ2VuZCIsImxlZ2VuZERlZmF1bHRQcm9wcyIsImRlZmF1bHRQcm9wcyIsImxlZ2VuZFByb3BzIiwidW5kZWZpbmVkIiwicHJvcHMiLCJsZWdlbmREYXRhIiwicGF5bG9hZCIsInJlZHVjZSIsInJlc3VsdCIsIl9yZWYyIiwiaXRlbSIsImRhdGEiLCJzZWN0b3JzIiwiY29uY2F0IiwibWFwIiwiZW50cnkiLCJ0eXBlIiwiaWNvblR5cGUiLCJsZWdlbmRUeXBlIiwibmFtZSIsImNvbG9yIiwiZmlsbCIsIl9yZWYzIiwiaXRlbURlZmF1bHRQcm9wcyIsIml0ZW1Qcm9wcyIsImRhdGFLZXkiLCJoaWRlIiwiaW5hY3RpdmUiLCJnZXRNYWluQ29sb3JPZkdyYXBoaWNJdGVtIiwiZ2V0V2l0aEhlaWdodCJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/getLegendProps.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/isDomainSpecifiedByUser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/recharts/lib/util/isDomainSpecifiedByUser.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isDomainSpecifiedByUser = isDomainSpecifiedByUser;\nvar _DataUtils = __webpack_require__(/*! ./DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\n/**\r\n * Takes a domain and user props to determine whether he provided the domain via props or if we need to calculate it.\r\n * @param   {AxisDomain}  domain              The potential domain from props\r\n * @param   {Boolean}     allowDataOverflow   from props\r\n * @param   {String}      axisType            from props\r\n * @returns {Boolean}                         `true` if domain is specified by user\r\n */ function isDomainSpecifiedByUser(domain, allowDataOverflow, axisType) {\n    if (axisType === 'number' && allowDataOverflow === true && Array.isArray(domain)) {\n        var domainStart = domain === null || domain === void 0 ? void 0 : domain[0];\n        var domainEnd = domain === null || domain === void 0 ? void 0 : domain[1];\n        /*\r\n     * The `isNumber` check is needed because the user could also provide strings like \"dataMin\" via the domain props.\r\n     * In such case, we have to compute the domain from the data.\r\n     */ if (!!domainStart && !!domainEnd && (0, _DataUtils.isNumber)(domainStart) && (0, _DataUtils.isNumber)(domainEnd)) {\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9pc0RvbWFpblNwZWNpZmllZEJ5VXNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsK0JBQStCLEdBQUdFO0FBQ2xDLElBQUlDLGFBQWFDLG1CQUFPQSxDQUFDLG1GQUFhO0FBQ3RDOzs7Ozs7Q0FNQyxHQUNELFNBQVNGLHdCQUF3QkcsTUFBTSxFQUFFQyxpQkFBaUIsRUFBRUMsUUFBUTtJQUNsRSxJQUFJQSxhQUFhLFlBQVlELHNCQUFzQixRQUFRRSxNQUFNQyxPQUFPLENBQUNKLFNBQVM7UUFDaEYsSUFBSUssY0FBY0wsV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSSxLQUFLLElBQUlBLE1BQU0sQ0FBQyxFQUFFO1FBQzNFLElBQUlNLFlBQVlOLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxNQUFNLENBQUMsRUFBRTtRQUV6RTs7O0tBR0MsR0FDRCxJQUFJLENBQUMsQ0FBQ0ssZUFBZSxDQUFDLENBQUNDLGFBQWEsQ0FBQyxHQUFHUixXQUFXUyxRQUFRLEVBQUVGLGdCQUFnQixDQUFDLEdBQUdQLFdBQVdTLFFBQVEsRUFBRUQsWUFBWTtZQUNoSCxPQUFPO1FBQ1Q7SUFDRjtJQUNBLE9BQU87QUFDVCIsInNvdXJjZXMiOlsiRDpcXERvX2FuMlxcbGVuZGh1Yl92MlxcbGVuZGh1Yi1mcm9udGVuZC1uZXh0anNcXG5vZGVfbW9kdWxlc1xccmVjaGFydHNcXGxpYlxcdXRpbFxcaXNEb21haW5TcGVjaWZpZWRCeVVzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5pc0RvbWFpblNwZWNpZmllZEJ5VXNlciA9IGlzRG9tYWluU3BlY2lmaWVkQnlVc2VyO1xyXG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuL0RhdGFVdGlsc1wiKTtcclxuLyoqXHJcbiAqIFRha2VzIGEgZG9tYWluIGFuZCB1c2VyIHByb3BzIHRvIGRldGVybWluZSB3aGV0aGVyIGhlIHByb3ZpZGVkIHRoZSBkb21haW4gdmlhIHByb3BzIG9yIGlmIHdlIG5lZWQgdG8gY2FsY3VsYXRlIGl0LlxyXG4gKiBAcGFyYW0gICB7QXhpc0RvbWFpbn0gIGRvbWFpbiAgICAgICAgICAgICAgVGhlIHBvdGVudGlhbCBkb21haW4gZnJvbSBwcm9wc1xyXG4gKiBAcGFyYW0gICB7Qm9vbGVhbn0gICAgIGFsbG93RGF0YU92ZXJmbG93ICAgZnJvbSBwcm9wc1xyXG4gKiBAcGFyYW0gICB7U3RyaW5nfSAgICAgIGF4aXNUeXBlICAgICAgICAgICAgZnJvbSBwcm9wc1xyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgYHRydWVgIGlmIGRvbWFpbiBpcyBzcGVjaWZpZWQgYnkgdXNlclxyXG4gKi9cclxuZnVuY3Rpb24gaXNEb21haW5TcGVjaWZpZWRCeVVzZXIoZG9tYWluLCBhbGxvd0RhdGFPdmVyZmxvdywgYXhpc1R5cGUpIHtcclxuICBpZiAoYXhpc1R5cGUgPT09ICdudW1iZXInICYmIGFsbG93RGF0YU92ZXJmbG93ID09PSB0cnVlICYmIEFycmF5LmlzQXJyYXkoZG9tYWluKSkge1xyXG4gICAgdmFyIGRvbWFpblN0YXJ0ID0gZG9tYWluID09PSBudWxsIHx8IGRvbWFpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9tYWluWzBdO1xyXG4gICAgdmFyIGRvbWFpbkVuZCA9IGRvbWFpbiA9PT0gbnVsbCB8fCBkb21haW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvbWFpblsxXTtcclxuXHJcbiAgICAvKlxyXG4gICAgICogVGhlIGBpc051bWJlcmAgY2hlY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIHVzZXIgY291bGQgYWxzbyBwcm92aWRlIHN0cmluZ3MgbGlrZSBcImRhdGFNaW5cIiB2aWEgdGhlIGRvbWFpbiBwcm9wcy5cclxuICAgICAqIEluIHN1Y2ggY2FzZSwgd2UgaGF2ZSB0byBjb21wdXRlIHRoZSBkb21haW4gZnJvbSB0aGUgZGF0YS5cclxuICAgICAqL1xyXG4gICAgaWYgKCEhZG9tYWluU3RhcnQgJiYgISFkb21haW5FbmQgJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGRvbWFpblN0YXJ0KSAmJiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikoZG9tYWluRW5kKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaXNEb21haW5TcGVjaWZpZWRCeVVzZXIiLCJfRGF0YVV0aWxzIiwicmVxdWlyZSIsImRvbWFpbiIsImFsbG93RGF0YU92ZXJmbG93IiwiYXhpc1R5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJkb21haW5TdGFydCIsImRvbWFpbkVuZCIsImlzTnVtYmVyIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/isDomainSpecifiedByUser.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/payload/getUniqPayload.js":
/*!******************************************************************!*\
  !*** ./node_modules/recharts/lib/util/payload/getUniqPayload.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getUniqPayload = getUniqPayload;\nvar _uniqBy = _interopRequireDefault(__webpack_require__(/*! lodash/uniqBy */ \"lodash/uniqBy\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\n/**\r\n * This is configuration option that decides how to filter for unique values only:\r\n *\r\n * - `false` means \"no filter\"\r\n * - `true` means \"use recharts default filter\"\r\n * - function means \"use return of this function as the default key\"\r\n */ function getUniqPayload(payload, option, defaultUniqBy) {\n    if (option === true) {\n        return (0, _uniqBy[\"default\"])(payload, defaultUniqBy);\n    }\n    if ((0, _isFunction[\"default\"])(option)) {\n        return (0, _uniqBy[\"default\"])(payload, option);\n    }\n    return payload;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9wYXlsb2FkL2dldFVuaXFQYXlsb2FkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxzQkFBc0IsR0FBR0U7QUFDekIsSUFBSUMsVUFBVUMsdUJBQXVCQyxtQkFBT0EsQ0FBQyxvQ0FBZTtBQUM1RCxJQUFJQyxjQUFjRix1QkFBdUJDLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxTQUFTRCx1QkFBdUJHLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEc7Ozs7OztDQU1DLEdBRUQsU0FBU0wsZUFBZU8sT0FBTyxFQUFFQyxNQUFNLEVBQUVDLGFBQWE7SUFDcEQsSUFBSUQsV0FBVyxNQUFNO1FBQ25CLE9BQU8sQ0FBQyxHQUFHUCxPQUFPLENBQUMsVUFBVSxFQUFFTSxTQUFTRTtJQUMxQztJQUNBLElBQUksQ0FBQyxHQUFHTCxXQUFXLENBQUMsVUFBVSxFQUFFSSxTQUFTO1FBQ3ZDLE9BQU8sQ0FBQyxHQUFHUCxPQUFPLENBQUMsVUFBVSxFQUFFTSxTQUFTQztJQUMxQztJQUNBLE9BQU9EO0FBQ1QiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXHV0aWxcXHBheWxvYWRcXGdldFVuaXFQYXlsb2FkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZ2V0VW5pcVBheWxvYWQgPSBnZXRVbmlxUGF5bG9hZDtcclxudmFyIF91bmlxQnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvdW5pcUJ5XCIpKTtcclxudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuLyoqXHJcbiAqIFRoaXMgaXMgY29uZmlndXJhdGlvbiBvcHRpb24gdGhhdCBkZWNpZGVzIGhvdyB0byBmaWx0ZXIgZm9yIHVuaXF1ZSB2YWx1ZXMgb25seTpcclxuICpcclxuICogLSBgZmFsc2VgIG1lYW5zIFwibm8gZmlsdGVyXCJcclxuICogLSBgdHJ1ZWAgbWVhbnMgXCJ1c2UgcmVjaGFydHMgZGVmYXVsdCBmaWx0ZXJcIlxyXG4gKiAtIGZ1bmN0aW9uIG1lYW5zIFwidXNlIHJldHVybiBvZiB0aGlzIGZ1bmN0aW9uIGFzIHRoZSBkZWZhdWx0IGtleVwiXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gZ2V0VW5pcVBheWxvYWQocGF5bG9hZCwgb3B0aW9uLCBkZWZhdWx0VW5pcUJ5KSB7XHJcbiAgaWYgKG9wdGlvbiA9PT0gdHJ1ZSkge1xyXG4gICAgcmV0dXJuICgwLCBfdW5pcUJ5W1wiZGVmYXVsdFwiXSkocGF5bG9hZCwgZGVmYXVsdFVuaXFCeSk7XHJcbiAgfVxyXG4gIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvcHRpb24pKSB7XHJcbiAgICByZXR1cm4gKDAsIF91bmlxQnlbXCJkZWZhdWx0XCJdKShwYXlsb2FkLCBvcHRpb24pO1xyXG4gIH1cclxuICByZXR1cm4gcGF5bG9hZDtcclxufSJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldFVuaXFQYXlsb2FkIiwiX3VuaXFCeSIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2lzRnVuY3Rpb24iLCJvYmoiLCJfX2VzTW9kdWxlIiwicGF5bG9hZCIsIm9wdGlvbiIsImRlZmF1bHRVbmlxQnkiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/payload/getUniqPayload.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/tooltip/translate.js":
/*!*************************************************************!*\
  !*** ./node_modules/recharts/lib/util/tooltip/translate.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getTooltipCSSClassName = getTooltipCSSClassName;\nexports.getTooltipTranslate = getTooltipTranslate;\nexports.getTooltipTranslateXY = getTooltipTranslateXY;\nexports.getTransformStyle = getTransformStyle;\nvar _clsx2 = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx?ce27\"));\nvar _DataUtils = __webpack_require__(/*! ../DataUtils */ \"(pages-dir-node)/./node_modules/recharts/lib/util/DataUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar CSS_CLASS_PREFIX = 'recharts-tooltip-wrapper';\nvar TOOLTIP_HIDDEN = {\n    visibility: 'hidden'\n};\nfunction getTooltipCSSClassName(_ref) {\n    var coordinate = _ref.coordinate, translateX = _ref.translateX, translateY = _ref.translateY;\n    return (0, _clsx2[\"default\"])(CSS_CLASS_PREFIX, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, \"\".concat(CSS_CLASS_PREFIX, \"-right\"), (0, _DataUtils.isNumber)(translateX) && coordinate && (0, _DataUtils.isNumber)(coordinate.x) && translateX >= coordinate.x), \"\".concat(CSS_CLASS_PREFIX, \"-left\"), (0, _DataUtils.isNumber)(translateX) && coordinate && (0, _DataUtils.isNumber)(coordinate.x) && translateX < coordinate.x), \"\".concat(CSS_CLASS_PREFIX, \"-bottom\"), (0, _DataUtils.isNumber)(translateY) && coordinate && (0, _DataUtils.isNumber)(coordinate.y) && translateY >= coordinate.y), \"\".concat(CSS_CLASS_PREFIX, \"-top\"), (0, _DataUtils.isNumber)(translateY) && coordinate && (0, _DataUtils.isNumber)(coordinate.y) && translateY < coordinate.y));\n}\nfunction getTooltipTranslateXY(_ref2) {\n    var allowEscapeViewBox = _ref2.allowEscapeViewBox, coordinate = _ref2.coordinate, key = _ref2.key, offsetTopLeft = _ref2.offsetTopLeft, position = _ref2.position, reverseDirection = _ref2.reverseDirection, tooltipDimension = _ref2.tooltipDimension, viewBox = _ref2.viewBox, viewBoxDimension = _ref2.viewBoxDimension;\n    if (position && (0, _DataUtils.isNumber)(position[key])) {\n        return position[key];\n    }\n    var negative = coordinate[key] - tooltipDimension - offsetTopLeft;\n    var positive = coordinate[key] + offsetTopLeft;\n    if (allowEscapeViewBox[key]) {\n        return reverseDirection[key] ? negative : positive;\n    }\n    if (reverseDirection[key]) {\n        var _tooltipBoundary = negative;\n        var _viewBoxBoundary = viewBox[key];\n        if (_tooltipBoundary < _viewBoxBoundary) {\n            return Math.max(positive, viewBox[key]);\n        }\n        return Math.max(negative, viewBox[key]);\n    }\n    var tooltipBoundary = positive + tooltipDimension;\n    var viewBoxBoundary = viewBox[key] + viewBoxDimension;\n    if (tooltipBoundary > viewBoxBoundary) {\n        return Math.max(negative, viewBox[key]);\n    }\n    return Math.max(positive, viewBox[key]);\n}\nfunction getTransformStyle(_ref3) {\n    var translateX = _ref3.translateX, translateY = _ref3.translateY, useTranslate3d = _ref3.useTranslate3d;\n    return {\n        transform: useTranslate3d ? \"translate3d(\".concat(translateX, \"px, \").concat(translateY, \"px, 0)\") : \"translate(\".concat(translateX, \"px, \").concat(translateY, \"px)\")\n    };\n}\nfunction getTooltipTranslate(_ref4) {\n    var allowEscapeViewBox = _ref4.allowEscapeViewBox, coordinate = _ref4.coordinate, offsetTopLeft = _ref4.offsetTopLeft, position = _ref4.position, reverseDirection = _ref4.reverseDirection, tooltipBox = _ref4.tooltipBox, useTranslate3d = _ref4.useTranslate3d, viewBox = _ref4.viewBox;\n    var cssProperties, translateX, translateY;\n    if (tooltipBox.height > 0 && tooltipBox.width > 0 && coordinate) {\n        translateX = getTooltipTranslateXY({\n            allowEscapeViewBox: allowEscapeViewBox,\n            coordinate: coordinate,\n            key: 'x',\n            offsetTopLeft: offsetTopLeft,\n            position: position,\n            reverseDirection: reverseDirection,\n            tooltipDimension: tooltipBox.width,\n            viewBox: viewBox,\n            viewBoxDimension: viewBox.width\n        });\n        translateY = getTooltipTranslateXY({\n            allowEscapeViewBox: allowEscapeViewBox,\n            coordinate: coordinate,\n            key: 'y',\n            offsetTopLeft: offsetTopLeft,\n            position: position,\n            reverseDirection: reverseDirection,\n            tooltipDimension: tooltipBox.height,\n            viewBox: viewBox,\n            viewBoxDimension: viewBox.height\n        });\n        cssProperties = getTransformStyle({\n            translateX: translateX,\n            translateY: translateY,\n            useTranslate3d: useTranslate3d\n        });\n    } else {\n        cssProperties = TOOLTIP_HIDDEN;\n    }\n    return {\n        cssProperties: cssProperties,\n        cssClasses: getTooltipCSSClassName({\n            translateX: translateX,\n            translateY: translateY,\n            coordinate: coordinate\n        })\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC90b29sdGlwL3RyYW5zbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsOEJBQThCLEdBQUdFO0FBQ2pDRiwyQkFBMkIsR0FBR0c7QUFDOUJILDZCQUE2QixHQUFHSTtBQUNoQ0oseUJBQXlCLEdBQUdLO0FBQzVCLElBQUlDLFNBQVNDLHVCQUF1QkMsbUJBQU9BLENBQUMsdUJBQU07QUFDbEQsSUFBSUMsYUFBYUQsbUJBQU9BLENBQUMsb0ZBQWM7QUFDdkMsU0FBU0QsdUJBQXVCRyxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFLFdBQVcsS0FBS0MsVUFBVUQsTUFBTUMsT0FBT0UsU0FBUyxHQUFHLFdBQVcsT0FBT0g7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNJLGdCQUFnQlAsR0FBRyxFQUFFUSxHQUFHLEVBQUVqQixLQUFLO0lBQUlpQixNQUFNQyxlQUFlRDtJQUFNLElBQUlBLE9BQU9SLEtBQUs7UUFBRVosT0FBT0MsY0FBYyxDQUFDVyxLQUFLUSxLQUFLO1lBQUVqQixPQUFPQTtZQUFPbUIsWUFBWTtZQUFNQyxjQUFjO1lBQU1DLFVBQVU7UUFBSztJQUFJLE9BQU87UUFBRVosR0FBRyxDQUFDUSxJQUFJLEdBQUdqQjtJQUFPO0lBQUUsT0FBT1M7QUFBSztBQUMzTyxTQUFTUyxlQUFlSSxDQUFDO0lB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QztJQUMvQixJQUFJeUIsV0FBV0UsTUFBTSxHQUFHLEtBQUtGLFdBQVdHLEtBQUssR0FBRyxLQUFLOUIsWUFBWTtRQUMvREMsYUFBYWxDLHNCQUFzQjtZQUNqQ3lDLG9CQUFvQkE7WUFDcEJSLFlBQVlBO1lBQ1puQixLQUFLO1lBQ0w0QixlQUFlQTtZQUNmQyxVQUFVQTtZQUNWQyxrQkFBa0JBO1lBQ2xCQyxrQkFBa0JlLFdBQVdHLEtBQUs7WUFDbENqQixTQUFTQTtZQUNUQyxrQkFBa0JELFFBQVFpQixLQUFLO1FBQ2pDO1FBQ0E1QixhQUFhbkMsc0JBQXNCO1lBQ2pDeUMsb0JBQW9CQTtZQUNwQlIsWUFBWUE7WUFDWm5CLEtBQUs7WUFDTDRCLGVBQWVBO1lBQ2ZDLFVBQVVBO1lBQ1ZDLGtCQUFrQkE7WUFDbEJDLGtCQUFrQmUsV0FBV0UsTUFBTTtZQUNuQ2hCLFNBQVNBO1lBQ1RDLGtCQUFrQkQsUUFBUWdCLE1BQU07UUFDbEM7UUFDQUQsZ0JBQWdCNUQsa0JBQWtCO1lBQ2hDaUMsWUFBWUE7WUFDWkMsWUFBWUE7WUFDWnNCLGdCQUFnQkE7UUFDbEI7SUFDRixPQUFPO1FBQ0xJLGdCQUFnQi9CO0lBQ2xCO0lBQ0EsT0FBTztRQUNMK0IsZUFBZUE7UUFDZkcsWUFBWWxFLHVCQUF1QjtZQUNqQ29DLFlBQVlBO1lBQ1pDLFlBQVlBO1lBQ1pGLFlBQVlBO1FBQ2Q7SUFDRjtBQUNGIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbGliXFx1dGlsXFx0b29sdGlwXFx0cmFuc2xhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5nZXRUb29sdGlwQ1NTQ2xhc3NOYW1lID0gZ2V0VG9vbHRpcENTU0NsYXNzTmFtZTtcclxuZXhwb3J0cy5nZXRUb29sdGlwVHJhbnNsYXRlID0gZ2V0VG9vbHRpcFRyYW5zbGF0ZTtcclxuZXhwb3J0cy5nZXRUb29sdGlwVHJhbnNsYXRlWFkgPSBnZXRUb29sdGlwVHJhbnNsYXRlWFk7XHJcbmV4cG9ydHMuZ2V0VHJhbnNmb3JtU3R5bGUgPSBnZXRUcmFuc2Zvcm1TdHlsZTtcclxudmFyIF9jbHN4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xyXG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuLi9EYXRhVXRpbHNcIik7XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cclxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cclxudmFyIENTU19DTEFTU19QUkVGSVggPSAncmVjaGFydHMtdG9vbHRpcC13cmFwcGVyJztcclxudmFyIFRPT0xUSVBfSElEREVOID0ge1xyXG4gIHZpc2liaWxpdHk6ICdoaWRkZW4nXHJcbn07XHJcbmZ1bmN0aW9uIGdldFRvb2x0aXBDU1NDbGFzc05hbWUoX3JlZikge1xyXG4gIHZhciBjb29yZGluYXRlID0gX3JlZi5jb29yZGluYXRlLFxyXG4gICAgdHJhbnNsYXRlWCA9IF9yZWYudHJhbnNsYXRlWCxcclxuICAgIHRyYW5zbGF0ZVkgPSBfcmVmLnRyYW5zbGF0ZVk7XHJcbiAgcmV0dXJuICgwLCBfY2xzeDJbXCJkZWZhdWx0XCJdKShDU1NfQ0xBU1NfUFJFRklYLCBfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoe30sIFwiXCIuY29uY2F0KENTU19DTEFTU19QUkVGSVgsIFwiLXJpZ2h0XCIpLCAoMCwgX0RhdGFVdGlscy5pc051bWJlcikodHJhbnNsYXRlWCkgJiYgY29vcmRpbmF0ZSAmJiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikoY29vcmRpbmF0ZS54KSAmJiB0cmFuc2xhdGVYID49IGNvb3JkaW5hdGUueCksIFwiXCIuY29uY2F0KENTU19DTEFTU19QUkVGSVgsIFwiLWxlZnRcIiksICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKSh0cmFuc2xhdGVYKSAmJiBjb29yZGluYXRlICYmICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShjb29yZGluYXRlLngpICYmIHRyYW5zbGF0ZVggPCBjb29yZGluYXRlLngpLCBcIlwiLmNvbmNhdChDU1NfQ0xBU1NfUFJFRklYLCBcIi1ib3R0b21cIiksICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKSh0cmFuc2xhdGVZKSAmJiBjb29yZGluYXRlICYmICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShjb29yZGluYXRlLnkpICYmIHRyYW5zbGF0ZVkgPj0gY29vcmRpbmF0ZS55KSwgXCJcIi5jb25jYXQoQ1NTX0NMQVNTX1BSRUZJWCwgXCItdG9wXCIpLCAoMCwgX0RhdGFVdGlscy5pc051bWJlcikodHJhbnNsYXRlWSkgJiYgY29vcmRpbmF0ZSAmJiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikoY29vcmRpbmF0ZS55KSAmJiB0cmFuc2xhdGVZIDwgY29vcmRpbmF0ZS55KSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VG9vbHRpcFRyYW5zbGF0ZVhZKF9yZWYyKSB7XHJcbiAgdmFyIGFsbG93RXNjYXBlVmlld0JveCA9IF9yZWYyLmFsbG93RXNjYXBlVmlld0JveCxcclxuICAgIGNvb3JkaW5hdGUgPSBfcmVmMi5jb29yZGluYXRlLFxyXG4gICAga2V5ID0gX3JlZjIua2V5LFxyXG4gICAgb2Zmc2V0VG9wTGVmdCA9IF9yZWYyLm9mZnNldFRvcExlZnQsXHJcbiAgICBwb3NpdGlvbiA9IF9yZWYyLnBvc2l0aW9uLFxyXG4gICAgcmV2ZXJzZURpcmVjdGlvbiA9IF9yZWYyLnJldmVyc2VEaXJlY3Rpb24sXHJcbiAgICB0b29sdGlwRGltZW5zaW9uID0gX3JlZjIudG9vbHRpcERpbWVuc2lvbixcclxuICAgIHZpZXdCb3ggPSBfcmVmMi52aWV3Qm94LFxyXG4gICAgdmlld0JveERpbWVuc2lvbiA9IF9yZWYyLnZpZXdCb3hEaW1lbnNpb247XHJcbiAgaWYgKHBvc2l0aW9uICYmICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShwb3NpdGlvbltrZXldKSkge1xyXG4gICAgcmV0dXJuIHBvc2l0aW9uW2tleV07XHJcbiAgfVxyXG4gIHZhciBuZWdhdGl2ZSA9IGNvb3JkaW5hdGVba2V5XSAtIHRvb2x0aXBEaW1lbnNpb24gLSBvZmZzZXRUb3BMZWZ0O1xyXG4gIHZhciBwb3NpdGl2ZSA9IGNvb3JkaW5hdGVba2V5XSArIG9mZnNldFRvcExlZnQ7XHJcbiAgaWYgKGFsbG93RXNjYXBlVmlld0JveFtrZXldKSB7XHJcbiAgICByZXR1cm4gcmV2ZXJzZURpcmVjdGlvbltrZXldID8gbmVnYXRpdmUgOiBwb3NpdGl2ZTtcclxuICB9XHJcbiAgaWYgKHJldmVyc2VEaXJlY3Rpb25ba2V5XSkge1xyXG4gICAgdmFyIF90b29sdGlwQm91bmRhcnkgPSBuZWdhdGl2ZTtcclxuICAgIHZhciBfdmlld0JveEJvdW5kYXJ5ID0gdmlld0JveFtrZXldO1xyXG4gICAgaWYgKF90b29sdGlwQm91bmRhcnkgPCBfdmlld0JveEJvdW5kYXJ5KSB7XHJcbiAgICAgIHJldHVybiBNYXRoLm1heChwb3NpdGl2ZSwgdmlld0JveFtrZXldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBNYXRoLm1heChuZWdhdGl2ZSwgdmlld0JveFtrZXldKTtcclxuICB9XHJcbiAgdmFyIHRvb2x0aXBCb3VuZGFyeSA9IHBvc2l0aXZlICsgdG9vbHRpcERpbWVuc2lvbjtcclxuICB2YXIgdmlld0JveEJvdW5kYXJ5ID0gdmlld0JveFtrZXldICsgdmlld0JveERpbWVuc2lvbjtcclxuICBpZiAodG9vbHRpcEJvdW5kYXJ5ID4gdmlld0JveEJvdW5kYXJ5KSB7XHJcbiAgICByZXR1cm4gTWF0aC5tYXgobmVnYXRpdmUsIHZpZXdCb3hba2V5XSk7XHJcbiAgfVxyXG4gIHJldHVybiBNYXRoLm1heChwb3NpdGl2ZSwgdmlld0JveFtrZXldKTtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1TdHlsZShfcmVmMykge1xyXG4gIHZhciB0cmFuc2xhdGVYID0gX3JlZjMudHJhbnNsYXRlWCxcclxuICAgIHRyYW5zbGF0ZVkgPSBfcmVmMy50cmFuc2xhdGVZLFxyXG4gICAgdXNlVHJhbnNsYXRlM2QgPSBfcmVmMy51c2VUcmFuc2xhdGUzZDtcclxuICByZXR1cm4ge1xyXG4gICAgdHJhbnNmb3JtOiB1c2VUcmFuc2xhdGUzZCA/IFwidHJhbnNsYXRlM2QoXCIuY29uY2F0KHRyYW5zbGF0ZVgsIFwicHgsIFwiKS5jb25jYXQodHJhbnNsYXRlWSwgXCJweCwgMClcIikgOiBcInRyYW5zbGF0ZShcIi5jb25jYXQodHJhbnNsYXRlWCwgXCJweCwgXCIpLmNvbmNhdCh0cmFuc2xhdGVZLCBcInB4KVwiKVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0VG9vbHRpcFRyYW5zbGF0ZShfcmVmNCkge1xyXG4gIHZhciBhbGxvd0VzY2FwZVZpZXdCb3ggPSBfcmVmNC5hbGxvd0VzY2FwZVZpZXdCb3gsXHJcbiAgICBjb29yZGluYXRlID0gX3JlZjQuY29vcmRpbmF0ZSxcclxuICAgIG9mZnNldFRvcExlZnQgPSBfcmVmNC5vZmZzZXRUb3BMZWZ0LFxyXG4gICAgcG9zaXRpb24gPSBfcmVmNC5wb3NpdGlvbixcclxuICAgIHJldmVyc2VEaXJlY3Rpb24gPSBfcmVmNC5yZXZlcnNlRGlyZWN0aW9uLFxyXG4gICAgdG9vbHRpcEJveCA9IF9yZWY0LnRvb2x0aXBCb3gsXHJcbiAgICB1c2VUcmFuc2xhdGUzZCA9IF9yZWY0LnVzZVRyYW5zbGF0ZTNkLFxyXG4gICAgdmlld0JveCA9IF9yZWY0LnZpZXdCb3g7XHJcbiAgdmFyIGNzc1Byb3BlcnRpZXMsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVk7XHJcbiAgaWYgKHRvb2x0aXBCb3guaGVpZ2h0ID4gMCAmJiB0b29sdGlwQm94LndpZHRoID4gMCAmJiBjb29yZGluYXRlKSB7XHJcbiAgICB0cmFuc2xhdGVYID0gZ2V0VG9vbHRpcFRyYW5zbGF0ZVhZKHtcclxuICAgICAgYWxsb3dFc2NhcGVWaWV3Qm94OiBhbGxvd0VzY2FwZVZpZXdCb3gsXHJcbiAgICAgIGNvb3JkaW5hdGU6IGNvb3JkaW5hdGUsXHJcbiAgICAgIGtleTogJ3gnLFxyXG4gICAgICBvZmZzZXRUb3BMZWZ0OiBvZmZzZXRUb3BMZWZ0LFxyXG4gICAgICBwb3NpdGlvbjogcG9zaXRpb24sXHJcbiAgICAgIHJldmVyc2VEaXJlY3Rpb246IHJldmVyc2VEaXJlY3Rpb24sXHJcbiAgICAgIHRvb2x0aXBEaW1lbnNpb246IHRvb2x0aXBCb3gud2lkdGgsXHJcbiAgICAgIHZpZXdCb3g6IHZpZXdCb3gsXHJcbiAgICAgIHZpZXdCb3hEaW1lbnNpb246IHZpZXdCb3gud2lkdGhcclxuICAgIH0pO1xyXG4gICAgdHJhbnNsYXRlWSA9IGdldFRvb2x0aXBUcmFuc2xhdGVYWSh7XHJcbiAgICAgIGFsbG93RXNjYXBlVmlld0JveDogYWxsb3dFc2NhcGVWaWV3Qm94LFxyXG4gICAgICBjb29yZGluYXRlOiBjb29yZGluYXRlLFxyXG4gICAgICBrZXk6ICd5JyxcclxuICAgICAgb2Zmc2V0VG9wTGVmdDogb2Zmc2V0VG9wTGVmdCxcclxuICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxyXG4gICAgICByZXZlcnNlRGlyZWN0aW9uOiByZXZlcnNlRGlyZWN0aW9uLFxyXG4gICAgICB0b29sdGlwRGltZW5zaW9uOiB0b29sdGlwQm94LmhlaWdodCxcclxuICAgICAgdmlld0JveDogdmlld0JveCxcclxuICAgICAgdmlld0JveERpbWVuc2lvbjogdmlld0JveC5oZWlnaHRcclxuICAgIH0pO1xyXG4gICAgY3NzUHJvcGVydGllcyA9IGdldFRyYW5zZm9ybVN0eWxlKHtcclxuICAgICAgdHJhbnNsYXRlWDogdHJhbnNsYXRlWCxcclxuICAgICAgdHJhbnNsYXRlWTogdHJhbnNsYXRlWSxcclxuICAgICAgdXNlVHJhbnNsYXRlM2Q6IHVzZVRyYW5zbGF0ZTNkXHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgY3NzUHJvcGVydGllcyA9IFRPT0xUSVBfSElEREVOO1xyXG4gIH1cclxuICByZXR1cm4ge1xyXG4gICAgY3NzUHJvcGVydGllczogY3NzUHJvcGVydGllcyxcclxuICAgIGNzc0NsYXNzZXM6IGdldFRvb2x0aXBDU1NDbGFzc05hbWUoe1xyXG4gICAgICB0cmFuc2xhdGVYOiB0cmFuc2xhdGVYLFxyXG4gICAgICB0cmFuc2xhdGVZOiB0cmFuc2xhdGVZLFxyXG4gICAgICBjb29yZGluYXRlOiBjb29yZGluYXRlXHJcbiAgICB9KVxyXG4gIH07XHJcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRUb29sdGlwQ1NTQ2xhc3NOYW1lIiwiZ2V0VG9vbHRpcFRyYW5zbGF0ZSIsImdldFRvb2x0aXBUcmFuc2xhdGVYWSIsImdldFRyYW5zZm9ybVN0eWxlIiwiX2Nsc3gyIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfRGF0YVV0aWxzIiwib2JqIiwiX19lc01vZHVsZSIsIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJfZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfdG9Qcm9wZXJ0eUtleSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInQiLCJpIiwiX3RvUHJpbWl0aXZlIiwiciIsImUiLCJ0b1ByaW1pdGl2ZSIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJDU1NfQ0xBU1NfUFJFRklYIiwiVE9PTFRJUF9ISURERU4iLCJ2aXNpYmlsaXR5IiwiX3JlZiIsImNvb3JkaW5hdGUiLCJ0cmFuc2xhdGVYIiwidHJhbnNsYXRlWSIsImNvbmNhdCIsImlzTnVtYmVyIiwieCIsInkiLCJfcmVmMiIsImFsbG93RXNjYXBlVmlld0JveCIsIm9mZnNldFRvcExlZnQiLCJwb3NpdGlvbiIsInJldmVyc2VEaXJlY3Rpb24iLCJ0b29sdGlwRGltZW5zaW9uIiwidmlld0JveCIsInZpZXdCb3hEaW1lbnNpb24iLCJuZWdhdGl2ZSIsInBvc2l0aXZlIiwiX3Rvb2x0aXBCb3VuZGFyeSIsIl92aWV3Qm94Qm91bmRhcnkiLCJNYXRoIiwibWF4IiwidG9vbHRpcEJvdW5kYXJ5Iiwidmlld0JveEJvdW5kYXJ5IiwiX3JlZjMiLCJ1c2VUcmFuc2xhdGUzZCIsInRyYW5zZm9ybSIsIl9yZWY0IiwidG9vbHRpcEJveCIsImNzc1Byb3BlcnRpZXMiLCJoZWlnaHQiLCJ3aWR0aCIsImNzc0NsYXNzZXMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/tooltip/translate.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/lib/util/types.js":
/*!*************************************************!*\
  !*** ./node_modules/recharts/lib/util/types.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.adaptEventsOfChild = exports.adaptEventHandlers = exports.SVGElementPropKeys = exports.FilteredElementKeyMap = exports.EventKeys = void 0;\nvar _react = __webpack_require__(/*! react */ \"react\");\nvar _isObject = _interopRequireDefault(__webpack_require__(/*! lodash/isObject */ \"lodash/isObject\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\n/**\r\n * Determines how values are stacked:\r\n *\r\n * - `none` is the default, it adds values on top of each other. No smarts. Negative values will overlap.\r\n * - `expand` make it so that the values always add up to 1 - so the chart will look like a rectangle.\r\n * - `wiggle` and `silhouette` tries to keep the chart centered.\r\n * - `sign` stacks positive values above zero and negative values below zero. Similar to `none` but handles negatives.\r\n * - `positive` ignores all negative values, and then behaves like \\`none\\`.\r\n *\r\n * Also see https://d3js.org/d3-shape/stack#stack-offsets\r\n * (note that the `diverging` offset in d3 is named `sign` in recharts)\r\n */ //\n// Event Handler Types -- Copied from @types/react/index.d.ts and adapted for Props.\n//\nvar SVGContainerPropKeys = [\n    'viewBox',\n    'children'\n];\nvar SVGElementPropKeys = exports.SVGElementPropKeys = [\n    'aria-activedescendant',\n    'aria-atomic',\n    'aria-autocomplete',\n    'aria-busy',\n    'aria-checked',\n    'aria-colcount',\n    'aria-colindex',\n    'aria-colspan',\n    'aria-controls',\n    'aria-current',\n    'aria-describedby',\n    'aria-details',\n    'aria-disabled',\n    'aria-errormessage',\n    'aria-expanded',\n    'aria-flowto',\n    'aria-haspopup',\n    'aria-hidden',\n    'aria-invalid',\n    'aria-keyshortcuts',\n    'aria-label',\n    'aria-labelledby',\n    'aria-level',\n    'aria-live',\n    'aria-modal',\n    'aria-multiline',\n    'aria-multiselectable',\n    'aria-orientation',\n    'aria-owns',\n    'aria-placeholder',\n    'aria-posinset',\n    'aria-pressed',\n    'aria-readonly',\n    'aria-relevant',\n    'aria-required',\n    'aria-roledescription',\n    'aria-rowcount',\n    'aria-rowindex',\n    'aria-rowspan',\n    'aria-selected',\n    'aria-setsize',\n    'aria-sort',\n    'aria-valuemax',\n    'aria-valuemin',\n    'aria-valuenow',\n    'aria-valuetext',\n    'className',\n    'color',\n    'height',\n    'id',\n    'lang',\n    'max',\n    'media',\n    'method',\n    'min',\n    'name',\n    'style',\n    /*\r\n * removed 'type' SVGElementPropKey because we do not currently use any SVG elements\r\n * that can use it and it conflicts with the recharts prop 'type'\r\n * https://github.com/recharts/recharts/pull/3327\r\n * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/type\r\n */ // 'type',\n    'target',\n    'width',\n    'role',\n    'tabIndex',\n    'accentHeight',\n    'accumulate',\n    'additive',\n    'alignmentBaseline',\n    'allowReorder',\n    'alphabetic',\n    'amplitude',\n    'arabicForm',\n    'ascent',\n    'attributeName',\n    'attributeType',\n    'autoReverse',\n    'azimuth',\n    'baseFrequency',\n    'baselineShift',\n    'baseProfile',\n    'bbox',\n    'begin',\n    'bias',\n    'by',\n    'calcMode',\n    'capHeight',\n    'clip',\n    'clipPath',\n    'clipPathUnits',\n    'clipRule',\n    'colorInterpolation',\n    'colorInterpolationFilters',\n    'colorProfile',\n    'colorRendering',\n    'contentScriptType',\n    'contentStyleType',\n    'cursor',\n    'cx',\n    'cy',\n    'd',\n    'decelerate',\n    'descent',\n    'diffuseConstant',\n    'direction',\n    'display',\n    'divisor',\n    'dominantBaseline',\n    'dur',\n    'dx',\n    'dy',\n    'edgeMode',\n    'elevation',\n    'enableBackground',\n    'end',\n    'exponent',\n    'externalResourcesRequired',\n    'fill',\n    'fillOpacity',\n    'fillRule',\n    'filter',\n    'filterRes',\n    'filterUnits',\n    'floodColor',\n    'floodOpacity',\n    'focusable',\n    'fontFamily',\n    'fontSize',\n    'fontSizeAdjust',\n    'fontStretch',\n    'fontStyle',\n    'fontVariant',\n    'fontWeight',\n    'format',\n    'from',\n    'fx',\n    'fy',\n    'g1',\n    'g2',\n    'glyphName',\n    'glyphOrientationHorizontal',\n    'glyphOrientationVertical',\n    'glyphRef',\n    'gradientTransform',\n    'gradientUnits',\n    'hanging',\n    'horizAdvX',\n    'horizOriginX',\n    'href',\n    'ideographic',\n    'imageRendering',\n    'in2',\n    'in',\n    'intercept',\n    'k1',\n    'k2',\n    'k3',\n    'k4',\n    'k',\n    'kernelMatrix',\n    'kernelUnitLength',\n    'kerning',\n    'keyPoints',\n    'keySplines',\n    'keyTimes',\n    'lengthAdjust',\n    'letterSpacing',\n    'lightingColor',\n    'limitingConeAngle',\n    'local',\n    'markerEnd',\n    'markerHeight',\n    'markerMid',\n    'markerStart',\n    'markerUnits',\n    'markerWidth',\n    'mask',\n    'maskContentUnits',\n    'maskUnits',\n    'mathematical',\n    'mode',\n    'numOctaves',\n    'offset',\n    'opacity',\n    'operator',\n    'order',\n    'orient',\n    'orientation',\n    'origin',\n    'overflow',\n    'overlinePosition',\n    'overlineThickness',\n    'paintOrder',\n    'panose1',\n    'pathLength',\n    'patternContentUnits',\n    'patternTransform',\n    'patternUnits',\n    'pointerEvents',\n    'pointsAtX',\n    'pointsAtY',\n    'pointsAtZ',\n    'preserveAlpha',\n    'preserveAspectRatio',\n    'primitiveUnits',\n    'r',\n    'radius',\n    'refX',\n    'refY',\n    'renderingIntent',\n    'repeatCount',\n    'repeatDur',\n    'requiredExtensions',\n    'requiredFeatures',\n    'restart',\n    'result',\n    'rotate',\n    'rx',\n    'ry',\n    'seed',\n    'shapeRendering',\n    'slope',\n    'spacing',\n    'specularConstant',\n    'specularExponent',\n    'speed',\n    'spreadMethod',\n    'startOffset',\n    'stdDeviation',\n    'stemh',\n    'stemv',\n    'stitchTiles',\n    'stopColor',\n    'stopOpacity',\n    'strikethroughPosition',\n    'strikethroughThickness',\n    'string',\n    'stroke',\n    'strokeDasharray',\n    'strokeDashoffset',\n    'strokeLinecap',\n    'strokeLinejoin',\n    'strokeMiterlimit',\n    'strokeOpacity',\n    'strokeWidth',\n    'surfaceScale',\n    'systemLanguage',\n    'tableValues',\n    'targetX',\n    'targetY',\n    'textAnchor',\n    'textDecoration',\n    'textLength',\n    'textRendering',\n    'to',\n    'transform',\n    'u1',\n    'u2',\n    'underlinePosition',\n    'underlineThickness',\n    'unicode',\n    'unicodeBidi',\n    'unicodeRange',\n    'unitsPerEm',\n    'vAlphabetic',\n    'values',\n    'vectorEffect',\n    'version',\n    'vertAdvY',\n    'vertOriginX',\n    'vertOriginY',\n    'vHanging',\n    'vIdeographic',\n    'viewTarget',\n    'visibility',\n    'vMathematical',\n    'widths',\n    'wordSpacing',\n    'writingMode',\n    'x1',\n    'x2',\n    'x',\n    'xChannelSelector',\n    'xHeight',\n    'xlinkActuate',\n    'xlinkArcrole',\n    'xlinkHref',\n    'xlinkRole',\n    'xlinkShow',\n    'xlinkTitle',\n    'xlinkType',\n    'xmlBase',\n    'xmlLang',\n    'xmlns',\n    'xmlnsXlink',\n    'xmlSpace',\n    'y1',\n    'y2',\n    'y',\n    'yChannelSelector',\n    'z',\n    'zoomAndPan',\n    'ref',\n    'key',\n    'angle'\n];\nvar PolyElementKeys = [\n    'points',\n    'pathLength'\n];\n/** svg element types that have specific attribute filtration requirements */ /** map of svg element types to unique svg attributes that belong to that element */ var FilteredElementKeyMap = exports.FilteredElementKeyMap = {\n    svg: SVGContainerPropKeys,\n    polygon: PolyElementKeys,\n    polyline: PolyElementKeys\n};\nvar EventKeys = exports.EventKeys = [\n    'dangerouslySetInnerHTML',\n    'onCopy',\n    'onCopyCapture',\n    'onCut',\n    'onCutCapture',\n    'onPaste',\n    'onPasteCapture',\n    'onCompositionEnd',\n    'onCompositionEndCapture',\n    'onCompositionStart',\n    'onCompositionStartCapture',\n    'onCompositionUpdate',\n    'onCompositionUpdateCapture',\n    'onFocus',\n    'onFocusCapture',\n    'onBlur',\n    'onBlurCapture',\n    'onChange',\n    'onChangeCapture',\n    'onBeforeInput',\n    'onBeforeInputCapture',\n    'onInput',\n    'onInputCapture',\n    'onReset',\n    'onResetCapture',\n    'onSubmit',\n    'onSubmitCapture',\n    'onInvalid',\n    'onInvalidCapture',\n    'onLoad',\n    'onLoadCapture',\n    'onError',\n    'onErrorCapture',\n    'onKeyDown',\n    'onKeyDownCapture',\n    'onKeyPress',\n    'onKeyPressCapture',\n    'onKeyUp',\n    'onKeyUpCapture',\n    'onAbort',\n    'onAbortCapture',\n    'onCanPlay',\n    'onCanPlayCapture',\n    'onCanPlayThrough',\n    'onCanPlayThroughCapture',\n    'onDurationChange',\n    'onDurationChangeCapture',\n    'onEmptied',\n    'onEmptiedCapture',\n    'onEncrypted',\n    'onEncryptedCapture',\n    'onEnded',\n    'onEndedCapture',\n    'onLoadedData',\n    'onLoadedDataCapture',\n    'onLoadedMetadata',\n    'onLoadedMetadataCapture',\n    'onLoadStart',\n    'onLoadStartCapture',\n    'onPause',\n    'onPauseCapture',\n    'onPlay',\n    'onPlayCapture',\n    'onPlaying',\n    'onPlayingCapture',\n    'onProgress',\n    'onProgressCapture',\n    'onRateChange',\n    'onRateChangeCapture',\n    'onSeeked',\n    'onSeekedCapture',\n    'onSeeking',\n    'onSeekingCapture',\n    'onStalled',\n    'onStalledCapture',\n    'onSuspend',\n    'onSuspendCapture',\n    'onTimeUpdate',\n    'onTimeUpdateCapture',\n    'onVolumeChange',\n    'onVolumeChangeCapture',\n    'onWaiting',\n    'onWaitingCapture',\n    'onAuxClick',\n    'onAuxClickCapture',\n    'onClick',\n    'onClickCapture',\n    'onContextMenu',\n    'onContextMenuCapture',\n    'onDoubleClick',\n    'onDoubleClickCapture',\n    'onDrag',\n    'onDragCapture',\n    'onDragEnd',\n    'onDragEndCapture',\n    'onDragEnter',\n    'onDragEnterCapture',\n    'onDragExit',\n    'onDragExitCapture',\n    'onDragLeave',\n    'onDragLeaveCapture',\n    'onDragOver',\n    'onDragOverCapture',\n    'onDragStart',\n    'onDragStartCapture',\n    'onDrop',\n    'onDropCapture',\n    'onMouseDown',\n    'onMouseDownCapture',\n    'onMouseEnter',\n    'onMouseLeave',\n    'onMouseMove',\n    'onMouseMoveCapture',\n    'onMouseOut',\n    'onMouseOutCapture',\n    'onMouseOver',\n    'onMouseOverCapture',\n    'onMouseUp',\n    'onMouseUpCapture',\n    'onSelect',\n    'onSelectCapture',\n    'onTouchCancel',\n    'onTouchCancelCapture',\n    'onTouchEnd',\n    'onTouchEndCapture',\n    'onTouchMove',\n    'onTouchMoveCapture',\n    'onTouchStart',\n    'onTouchStartCapture',\n    'onPointerDown',\n    'onPointerDownCapture',\n    'onPointerMove',\n    'onPointerMoveCapture',\n    'onPointerUp',\n    'onPointerUpCapture',\n    'onPointerCancel',\n    'onPointerCancelCapture',\n    'onPointerEnter',\n    'onPointerEnterCapture',\n    'onPointerLeave',\n    'onPointerLeaveCapture',\n    'onPointerOver',\n    'onPointerOverCapture',\n    'onPointerOut',\n    'onPointerOutCapture',\n    'onGotPointerCapture',\n    'onGotPointerCaptureCapture',\n    'onLostPointerCapture',\n    'onLostPointerCaptureCapture',\n    'onScroll',\n    'onScrollCapture',\n    'onWheel',\n    'onWheelCapture',\n    'onAnimationStart',\n    'onAnimationStartCapture',\n    'onAnimationEnd',\n    'onAnimationEndCapture',\n    'onAnimationIteration',\n    'onAnimationIterationCapture',\n    'onTransitionEnd',\n    'onTransitionEndCapture'\n];\n/** The type of easing function to use for animations */ /** Specifies the duration of animation, the unit of this option is ms. */ /** the offset of a chart, which define the blank space all around */ /**\r\n * The domain of axis.\r\n * This is the definition\r\n *\r\n * Numeric domain is always defined by an array of exactly two values, for the min and the max of the axis.\r\n * Categorical domain is defined as array of all possible values.\r\n *\r\n * Can be specified in many ways:\r\n * - array of numbers\r\n * - with special strings like 'dataMin' and 'dataMax'\r\n * - with special string math like 'dataMin - 100'\r\n * - with keyword 'auto'\r\n * - or a function\r\n * - array of functions\r\n * - or a combination of the above\r\n */ /**\r\n * NumberDomain is an evaluated {@link AxisDomain}.\r\n * Unlike {@link AxisDomain}, it has no variety - it's a tuple of two number.\r\n * This is after all the keywords and functions were evaluated and what is left is [min, max].\r\n *\r\n * Know that the min, max values are not guaranteed to be nice numbers - values like -Infinity or NaN are possible.\r\n *\r\n * There are also `category` axes that have different things than numbers in their domain.\r\n */ /** The props definition of base axis */ /** Defines how ticks are placed and whether / how tick collisions are handled.\r\n * 'preserveStart' keeps the left tick on collision and ensures that the first tick is always shown.\r\n * 'preserveEnd' keeps the right tick on collision and ensures that the last tick is always shown.\r\n * 'preserveStartEnd' keeps the left tick on collision and ensures that the first and last ticks are always shown.\r\n * 'equidistantPreserveStart' selects a number N such that every nTh tick will be shown without collision.\r\n */ var adaptEventHandlers = exports.adaptEventHandlers = function adaptEventHandlers(props, newHandler) {\n    if (!props || typeof props === 'function' || typeof props === 'boolean') {\n        return null;\n    }\n    var inputProps = props;\n    if (/*#__PURE__*/ (0, _react.isValidElement)(props)) {\n        inputProps = props.props;\n    }\n    if (!(0, _isObject[\"default\"])(inputProps)) {\n        return null;\n    }\n    var out = {};\n    Object.keys(inputProps).forEach(function(key) {\n        if (EventKeys.includes(key)) {\n            out[key] = newHandler || function(e) {\n                return inputProps[key](inputProps, e);\n            };\n        }\n    });\n    return out;\n};\nvar getEventHandlerOfChild = function getEventHandlerOfChild(originalHandler, data, index) {\n    return function(e) {\n        originalHandler(data, index, e);\n        return null;\n    };\n};\nvar adaptEventsOfChild = exports.adaptEventsOfChild = function adaptEventsOfChild(props, data, index) {\n    if (!(0, _isObject[\"default\"])(props) || _typeof(props) !== 'object') {\n        return null;\n    }\n    var out = null;\n    Object.keys(props).forEach(function(key) {\n        var item = props[key];\n        if (EventKeys.includes(key) && typeof item === 'function') {\n            if (!out) out = {};\n            out[key] = getEventHandlerOfChild(item, data, index);\n        }\n    });\n    return out;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsMEJBQTBCLEdBQUdBLDBCQUEwQixHQUFHQSwwQkFBMEIsR0FBR0EsNkJBQTZCLEdBQUdBLGlCQUFpQixHQUFHLEtBQUs7QUFDaEosSUFBSU8sU0FBU0MsbUJBQU9BLENBQUMsb0JBQU87QUFDNUIsSUFBSUMsWUFBWUMsdUJBQXVCRixtQkFBT0EsQ0FBQyx3Q0FBaUI7QUFDaEUsU0FBU0UsdUJBQXVCQyxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFLFdBQVcsS0FBS0MsVUFBVUQsTUFBTUMsT0FBT0UsU0FBUyxHQUFHLFdBQVcsT0FBT0g7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdUOzs7Ozs7Ozs7OztDQVdDLEdBRUQsRUFBRTtBQUNGLG9GQUFvRjtBQUNwRixFQUFFO0FBRUYsSUFBSUksdUJBQXVCO0lBQUM7SUFBVztDQUFXO0FBQ2xELElBQUlkLHFCQUFxQkosMEJBQTBCLEdBQUc7SUFBQztJQUF5QjtJQUFlO0lBQXFCO0lBQWE7SUFBZ0I7SUFBaUI7SUFBaUI7SUFBZ0I7SUFBaUI7SUFBZ0I7SUFBb0I7SUFBZ0I7SUFBaUI7SUFBcUI7SUFBaUI7SUFBZTtJQUFpQjtJQUFlO0lBQWdCO0lBQXFCO0lBQWM7SUFBbUI7SUFBYztJQUFhO0lBQWM7SUFBa0I7SUFB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QUFJO1FBQ3JCLElBQUl4QixVQUFVeUIsUUFBUSxDQUFDRCxRQUFRLE9BQU9PLFNBQVMsWUFBWTtZQUN6RCxJQUFJLENBQUNWLEtBQUtBLE1BQU0sQ0FBQztZQUNqQkEsR0FBRyxDQUFDRyxJQUFJLEdBQUdHLHVCQUF1QkksTUFBTUYsTUFBTUM7UUFDaEQ7SUFDRjtJQUNBLE9BQU9UO0FBQ1QiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxsaWJcXHV0aWxcXHR5cGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuYWRhcHRFdmVudHNPZkNoaWxkID0gZXhwb3J0cy5hZGFwdEV2ZW50SGFuZGxlcnMgPSBleHBvcnRzLlNWR0VsZW1lbnRQcm9wS2V5cyA9IGV4cG9ydHMuRmlsdGVyZWRFbGVtZW50S2V5TWFwID0gZXhwb3J0cy5FdmVudEtleXMgPSB2b2lkIDA7XHJcbnZhciBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XHJcbnZhciBfaXNPYmplY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNPYmplY3RcIikpO1xyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxyXG4vKipcclxuICogRGV0ZXJtaW5lcyBob3cgdmFsdWVzIGFyZSBzdGFja2VkOlxyXG4gKlxyXG4gKiAtIGBub25lYCBpcyB0aGUgZGVmYXVsdCwgaXQgYWRkcyB2YWx1ZXMgb24gdG9wIG9mIGVhY2ggb3RoZXIuIE5vIHNtYXJ0cy4gTmVnYXRpdmUgdmFsdWVzIHdpbGwgb3ZlcmxhcC5cclxuICogLSBgZXhwYW5kYCBtYWtlIGl0IHNvIHRoYXQgdGhlIHZhbHVlcyBhbHdheXMgYWRkIHVwIHRvIDEgLSBzbyB0aGUgY2hhcnQgd2lsbCBsb29rIGxpa2UgYSByZWN0YW5nbGUuXHJcbiAqIC0gYHdpZ2dsZWAgYW5kIGBzaWxob3VldHRlYCB0cmllcyB0byBrZWVwIHRoZSBjaGFydCBjZW50ZXJlZC5cclxuICogLSBgc2lnbmAgc3RhY2tzIHBvc2l0aXZlIHZhbHVlcyBhYm92ZSB6ZXJvIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgYmVsb3cgemVyby4gU2ltaWxhciB0byBgbm9uZWAgYnV0IGhhbmRsZXMgbmVnYXRpdmVzLlxyXG4gKiAtIGBwb3NpdGl2ZWAgaWdub3JlcyBhbGwgbmVnYXRpdmUgdmFsdWVzLCBhbmQgdGhlbiBiZWhhdmVzIGxpa2UgXFxgbm9uZVxcYC5cclxuICpcclxuICogQWxzbyBzZWUgaHR0cHM6Ly9kM2pzLm9yZy9kMy1zaGFwZS9zdGFjayNzdGFjay1vZmZzZXRzXHJcbiAqIChub3RlIHRoYXQgdGhlIGBkaXZlcmdpbmdgIG9mZnNldCBpbiBkMyBpcyBuYW1lZCBgc2lnbmAgaW4gcmVjaGFydHMpXHJcbiAqL1xyXG5cclxuLy9cclxuLy8gRXZlbnQgSGFuZGxlciBUeXBlcyAtLSBDb3BpZWQgZnJvbSBAdHlwZXMvcmVhY3QvaW5kZXguZC50cyBhbmQgYWRhcHRlZCBmb3IgUHJvcHMuXHJcbi8vXHJcblxyXG52YXIgU1ZHQ29udGFpbmVyUHJvcEtleXMgPSBbJ3ZpZXdCb3gnLCAnY2hpbGRyZW4nXTtcclxudmFyIFNWR0VsZW1lbnRQcm9wS2V5cyA9IGV4cG9ydHMuU1ZHRWxlbWVudFByb3BLZXlzID0gWydhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLCAnYXJpYS1hdG9taWMnLCAnYXJpYS1hdXRvY29tcGxldGUnLCAnYXJpYS1idXN5JywgJ2FyaWEtY2hlY2tlZCcsICdhcmlhLWNvbGNvdW50JywgJ2FyaWEtY29saW5kZXgnLCAnYXJpYS1jb2xzcGFuJywgJ2FyaWEtY29udHJvbHMnLCAnYXJpYS1jdXJyZW50JywgJ2FyaWEtZGVzY3JpYmVkYnknLCAnYXJpYS1kZXRhaWxzJywgJ2FyaWEtZGlzYWJsZWQnLCAnYXJpYS1lcnJvcm1lc3NhZ2UnLCAnYXJpYS1leHBhbmRlZCcsICdhcmlhLWZsb3d0bycsICdhcmlhLWhhc3BvcHVwJywgJ2FyaWEtaGlkZGVuJywgJ2FyaWEtaW52YWxpZCcsICdhcmlhLWtleXNob3J0Y3V0cycsICdhcmlhLWxhYmVsJywgJ2FyaWEtbGFiZWxsZWRieScsICdhcmlhLWxldmVsJywgJ2FyaWEtbGl2ZScsICdhcmlhLW1vZGFsJywgJ2FyaWEtbXVsdGlsaW5lJywgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJywgJ2FyaWEtb3JpZW50YXRpb24nLCAnYXJpYS1vd25zJywgJ2FyaWEtcGxhY2Vob2xkZXInLCAnYXJpYS1wb3NpbnNldCcsICdhcmlhLXByZXNzZWQnLCAnYXJpYS1yZWFkb25seScsICdhcmlhLXJlbGV2YW50JywgJ2FyaWEtcmVxdWlyZWQnLCAnYXJpYS1yb2xlZGVzY3JpcHRpb24nLCAnYXJpYS1yb3djb3VudCcsICdhcmlhLXJvd2luZGV4JywgJ2FyaWEtcm93c3BhbicsICdhcmlhLXNlbGVjdGVkJywgJ2FyaWEtc2V0c2l6ZScsICdhcmlhLXNvcnQnLCAnYXJpYS12YWx1ZW1heCcsICdhcmlhLXZhbHVlbWluJywgJ2FyaWEtdmFsdWVub3cnLCAnYXJpYS12YWx1ZXRleHQnLCAnY2xhc3NOYW1lJywgJ2NvbG9yJywgJ2hlaWdodCcsICdpZCcsICdsYW5nJywgJ21heCcsICdtZWRpYScsICdtZXRob2QnLCAnbWluJywgJ25hbWUnLCAnc3R5bGUnLFxyXG4vKlxyXG4gKiByZW1vdmVkICd0eXBlJyBTVkdFbGVtZW50UHJvcEtleSBiZWNhdXNlIHdlIGRvIG5vdCBjdXJyZW50bHkgdXNlIGFueSBTVkcgZWxlbWVudHNcclxuICogdGhhdCBjYW4gdXNlIGl0IGFuZCBpdCBjb25mbGljdHMgd2l0aCB0aGUgcmVjaGFydHMgcHJvcCAndHlwZSdcclxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlY2hhcnRzL3JlY2hhcnRzL3B1bGwvMzMyN1xyXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3R5cGVcclxuICovXHJcbi8vICd0eXBlJyxcclxuJ3RhcmdldCcsICd3aWR0aCcsICdyb2xlJywgJ3RhYkluZGV4JywgJ2FjY2VudEhlaWdodCcsICdhY2N1bXVsYXRlJywgJ2FkZGl0aXZlJywgJ2FsaWdubWVudEJhc2VsaW5lJywgJ2FsbG93UmVvcmRlcicsICdhbHBoYWJldGljJywgJ2FtcGxpdHVkZScsICdhcmFiaWNGb3JtJywgJ2FzY2VudCcsICdhdHRyaWJ1dGVOYW1lJywgJ2F0dHJpYnV0ZVR5cGUnLCAnYXV0b1JldmVyc2UnLCAnYXppbXV0aCcsICdiYXNlRnJlcXVlbmN5JywgJ2Jhc2VsaW5lU2hpZnQnLCAnYmFzZVByb2ZpbGUnLCAnYmJveCcsICdiZWdpbicsICdiaWFzJywgJ2J5JywgJ2NhbGNNb2RlJywgJ2NhcEhlaWdodCcsICdjbGlwJywgJ2NsaXBQYXRoJywgJ2NsaXBQYXRoVW5pdHMnLCAnY2xpcFJ1bGUnLCAnY29sb3JJbnRlcnBvbGF0aW9uJywgJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLCAnY29sb3JQcm9maWxlJywgJ2NvbG9yUmVuZGVyaW5nJywgJ2NvbnRlbnRTY3JpcHRUeXBlJywgJ2NvbnRlbnRTdHlsZVR5cGUnLCAnY3Vyc29yJywgJ2N4JywgJ2N5JywgJ2QnLCAnZGVjZWxlcmF0ZScsICdkZXNjZW50JywgJ2RpZmZ1c2VDb25zdGFudCcsICdkaXJlY3Rpb24nLCAnZGlzcGxheScsICdkaXZpc29yJywgJ2RvbWluYW50QmFzZWxpbmUnLCAnZHVyJywgJ2R4JywgJ2R5JywgJ2VkZ2VNb2RlJywgJ2VsZXZhdGlvbicsICdlbmFibGVCYWNrZ3JvdW5kJywgJ2VuZCcsICdleHBvbmVudCcsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2ZpbGwnLCAnZmlsbE9wYWNpdHknLCAnZmlsbFJ1bGUnLCAnZmlsdGVyJywgJ2ZpbHRlclJlcycsICdmaWx0ZXJVbml0cycsICdmbG9vZENvbG9yJywgJ2Zsb29kT3BhY2l0eScsICdmb2N1c2FibGUnLCAnZm9udEZhbWlseScsICdmb250U2l6ZScsICdmb250U2l6ZUFkanVzdCcsICdmb250U3RyZXRjaCcsICdmb250U3R5bGUnLCAnZm9udFZhcmlhbnQnLCAnZm9udFdlaWdodCcsICdmb3JtYXQnLCAnZnJvbScsICdmeCcsICdmeScsICdnMScsICdnMicsICdnbHlwaE5hbWUnLCAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLCAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJywgJ2dseXBoUmVmJywgJ2dyYWRpZW50VHJhbnNmb3JtJywgJ2dyYWRpZW50VW5pdHMnLCAnaGFuZ2luZycsICdob3JpekFkdlgnLCAnaG9yaXpPcmlnaW5YJywgJ2hyZWYnLCAnaWRlb2dyYXBoaWMnLCAnaW1hZ2VSZW5kZXJpbmcnLCAnaW4yJywgJ2luJywgJ2ludGVyY2VwdCcsICdrMScsICdrMicsICdrMycsICdrNCcsICdrJywgJ2tlcm5lbE1hdHJpeCcsICdrZXJuZWxVbml0TGVuZ3RoJywgJ2tlcm5pbmcnLCAna2V5UG9pbnRzJywgJ2tleVNwbGluZXMnLCAna2V5VGltZXMnLCAnbGVuZ3RoQWRqdXN0JywgJ2xldHRlclNwYWNpbmcnLCAnbGlnaHRpbmdDb2xvcicsICdsaW1pdGluZ0NvbmVBbmdsZScsICdsb2NhbCcsICdtYXJrZXJFbmQnLCAnbWFya2VySGVpZ2h0JywgJ21hcmtlck1pZCcsICdtYXJrZXJTdGFydCcsICdtYXJrZXJVbml0cycsICdtYXJrZXJXaWR0aCcsICdtYXNrJywgJ21hc2tDb250ZW50VW5pdHMnLCAnbWFza1VuaXRzJywgJ21hdGhlbWF0aWNhbCcsICdtb2RlJywgJ251bU9jdGF2ZXMnLCAnb2Zmc2V0JywgJ29wYWNpdHknLCAnb3BlcmF0b3InLCAnb3JkZXInLCAnb3JpZW50JywgJ29yaWVudGF0aW9uJywgJ29yaWdpbicsICdvdmVyZmxvdycsICdvdmVybGluZVBvc2l0aW9uJywgJ292ZXJsaW5lVGhpY2tuZXNzJywgJ3BhaW50T3JkZXInLCAncGFub3NlMScsICdwYXRoTGVuZ3RoJywgJ3BhdHRlcm5Db250ZW50VW5pdHMnLCAncGF0dGVyblRyYW5zZm9ybScsICdwYXR0ZXJuVW5pdHMnLCAncG9pbnRlckV2ZW50cycsICdwb2ludHNBdFgnLCAncG9pbnRzQXRZJywgJ3BvaW50c0F0WicsICdwcmVzZXJ2ZUFscGhhJywgJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCAncHJpbWl0aXZlVW5pdHMnLCAncicsICdyYWRpdXMnLCAncmVmWCcsICdyZWZZJywgJ3JlbmRlcmluZ0ludGVudCcsICdyZXBlYXRDb3VudCcsICdyZXBlYXREdXInLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAncmVzdGFydCcsICdyZXN1bHQnLCAncm90YXRlJywgJ3J4JywgJ3J5JywgJ3NlZWQnLCAnc2hhcGVSZW5kZXJpbmcnLCAnc2xvcGUnLCAnc3BhY2luZycsICdzcGVjdWxhckNvbnN0YW50JywgJ3NwZWN1bGFyRXhwb25lbnQnLCAnc3BlZWQnLCAnc3ByZWFkTWV0aG9kJywgJ3N0YXJ0T2Zmc2V0JywgJ3N0ZERldmlhdGlvbicsICdzdGVtaCcsICdzdGVtdicsICdzdGl0Y2hUaWxlcycsICdzdG9wQ29sb3InLCAnc3RvcE9wYWNpdHknLCAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLCAnc3RyaW5nJywgJ3N0cm9rZScsICdzdHJva2VEYXNoYXJyYXknLCAnc3Ryb2tlRGFzaG9mZnNldCcsICdzdHJva2VMaW5lY2FwJywgJ3N0cm9rZUxpbmVqb2luJywgJ3N0cm9rZU1pdGVybGltaXQnLCAnc3Ryb2tlT3BhY2l0eScsICdzdHJva2VXaWR0aCcsICdzdXJmYWNlU2NhbGUnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndGFibGVWYWx1ZXMnLCAndGFyZ2V0WCcsICd0YXJnZXRZJywgJ3RleHRBbmNob3InLCAndGV4dERlY29yYXRpb24nLCAndGV4dExlbmd0aCcsICd0ZXh0UmVuZGVyaW5nJywgJ3RvJywgJ3RyYW5zZm9ybScsICd1MScsICd1MicsICd1bmRlcmxpbmVQb3NpdGlvbicsICd1bmRlcmxpbmVUaGlja25lc3MnLCAndW5pY29kZScsICd1bmljb2RlQmlkaScsICd1bmljb2RlUmFuZ2UnLCAndW5pdHNQZXJFbScsICd2QWxwaGFiZXRpYycsICd2YWx1ZXMnLCAndmVjdG9yRWZmZWN0JywgJ3ZlcnNpb24nLCAndmVydEFkdlknLCAndmVydE9yaWdpblgnLCAndmVydE9yaWdpblknLCAndkhhbmdpbmcnLCAndklkZW9ncmFwaGljJywgJ3ZpZXdUYXJnZXQnLCAndmlzaWJpbGl0eScsICd2TWF0aGVtYXRpY2FsJywgJ3dpZHRocycsICd3b3JkU3BhY2luZycsICd3cml0aW5nTW9kZScsICd4MScsICd4MicsICd4JywgJ3hDaGFubmVsU2VsZWN0b3InLCAneEhlaWdodCcsICd4bGlua0FjdHVhdGUnLCAneGxpbmtBcmNyb2xlJywgJ3hsaW5rSHJlZicsICd4bGlua1JvbGUnLCAneGxpbmtTaG93JywgJ3hsaW5rVGl0bGUnLCAneGxpbmtUeXBlJywgJ3htbEJhc2UnLCAneG1sTGFuZycsICd4bWxucycsICd4bWxuc1hsaW5rJywgJ3htbFNwYWNlJywgJ3kxJywgJ3kyJywgJ3knLCAneUNoYW5uZWxTZWxlY3RvcicsICd6JywgJ3pvb21BbmRQYW4nLCAncmVmJywgJ2tleScsICdhbmdsZSddO1xyXG52YXIgUG9seUVsZW1lbnRLZXlzID0gWydwb2ludHMnLCAncGF0aExlbmd0aCddO1xyXG5cclxuLyoqIHN2ZyBlbGVtZW50IHR5cGVzIHRoYXQgaGF2ZSBzcGVjaWZpYyBhdHRyaWJ1dGUgZmlsdHJhdGlvbiByZXF1aXJlbWVudHMgKi9cclxuXHJcbi8qKiBtYXAgb2Ygc3ZnIGVsZW1lbnQgdHlwZXMgdG8gdW5pcXVlIHN2ZyBhdHRyaWJ1dGVzIHRoYXQgYmVsb25nIHRvIHRoYXQgZWxlbWVudCAqL1xyXG52YXIgRmlsdGVyZWRFbGVtZW50S2V5TWFwID0gZXhwb3J0cy5GaWx0ZXJlZEVsZW1lbnRLZXlNYXAgPSB7XHJcbiAgc3ZnOiBTVkdDb250YWluZXJQcm9wS2V5cyxcclxuICBwb2x5Z29uOiBQb2x5RWxlbWVudEtleXMsXHJcbiAgcG9seWxpbmU6IFBvbHlFbGVtZW50S2V5c1xyXG59O1xyXG52YXIgRXZlbnRLZXlzID0gZXhwb3J0cy5FdmVudEtleXMgPSBbJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJywgJ29uQ29weScsICdvbkNvcHlDYXB0dXJlJywgJ29uQ3V0JywgJ29uQ3V0Q2FwdHVyZScsICdvblBhc3RlJywgJ29uUGFzdGVDYXB0dXJlJywgJ29uQ29tcG9zaXRpb25FbmQnLCAnb25Db21wb3NpdGlvbkVuZENhcHR1cmUnLCAnb25Db21wb3NpdGlvblN0YXJ0JywgJ29uQ29tcG9zaXRpb25TdGFydENhcHR1cmUnLCAnb25Db21wb3NpdGlvblVwZGF0ZScsICdvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZScsICdvbkZvY3VzJywgJ29uRm9jdXNDYXB0dXJlJywgJ29uQmx1cicsICdvbkJsdXJDYXB0dXJlJywgJ29uQ2hhbmdlJywgJ29uQ2hhbmdlQ2FwdHVyZScsICdvbkJlZm9yZUlucHV0JywgJ29uQmVmb3JlSW5wdXRDYXB0dXJlJywgJ29uSW5wdXQnLCAnb25JbnB1dENhcHR1cmUnLCAnb25SZXNldCcsICdvblJlc2V0Q2FwdHVyZScsICdvblN1Ym1pdCcsICdvblN1Ym1pdENhcHR1cmUnLCAnb25JbnZhbGlkJywgJ29uSW52YWxpZENhcHR1cmUnLCAnb25Mb2FkJywgJ29uTG9hZENhcHR1cmUnLCAnb25FcnJvcicsICdvbkVycm9yQ2FwdHVyZScsICdvbktleURvd24nLCAnb25LZXlEb3duQ2FwdHVyZScsICdvbktleVByZXNzJywgJ29uS2V5UHJlc3NDYXB0dXJlJywgJ29uS2V5VXAnLCAnb25LZXlVcENhcHR1cmUnLCAnb25BYm9ydCcsICdvbkFib3J0Q2FwdHVyZScsICdvbkNhblBsYXknLCAnb25DYW5QbGF5Q2FwdHVyZScsICdvbkNhblBsYXlUaHJvdWdoJywgJ29uQ2FuUGxheVRocm91Z2hDYXB0dXJlJywgJ29uRHVyYXRpb25DaGFuZ2UnLCAnb25EdXJhdGlvbkNoYW5nZUNhcHR1cmUnLCAnb25FbXB0aWVkJywgJ29uRW1wdGllZENhcHR1cmUnLCAnb25FbmNyeXB0ZWQnLCAnb25FbmNyeXB0ZWRDYXB0dXJlJywgJ29uRW5kZWQnLCAnb25FbmRlZENhcHR1cmUnLCAnb25Mb2FkZWREYXRhJywgJ29uTG9hZGVkRGF0YUNhcHR1cmUnLCAnb25Mb2FkZWRNZXRhZGF0YScsICdvbkxvYWRlZE1ldGFkYXRhQ2FwdHVyZScsICdvbkxvYWRTdGFydCcsICdvbkxvYWRTdGFydENhcHR1cmUnLCAnb25QYXVzZScsICdvblBhdXNlQ2FwdHVyZScsICdvblBsYXknLCAnb25QbGF5Q2FwdHVyZScsICdvblBsYXlpbmcnLCAnb25QbGF5aW5nQ2FwdHVyZScsICdvblByb2dyZXNzJywgJ29uUHJvZ3Jlc3NDYXB0dXJlJywgJ29uUmF0ZUNoYW5nZScsICdvblJhdGVDaGFuZ2VDYXB0dXJlJywgJ29uU2Vla2VkJywgJ29uU2Vla2VkQ2FwdHVyZScsICdvblNlZWtpbmcnLCAnb25TZWVraW5nQ2FwdHVyZScsICdvblN0YWxsZWQnLCAnb25TdGFsbGVkQ2FwdHVyZScsICdvblN1c3BlbmQnLCAnb25TdXNwZW5kQ2FwdHVyZScsICdvblRpbWVVcGRhdGUnLCAnb25UaW1lVXBkYXRlQ2FwdHVyZScsICdvblZvbHVtZUNoYW5nZScsICdvblZvbHVtZUNoYW5nZUNhcHR1cmUnLCAnb25XYWl0aW5nJywgJ29uV2FpdGluZ0NhcHR1cmUnLCAnb25BdXhDbGljaycsICdvbkF1eENsaWNrQ2FwdHVyZScsICdvbkNsaWNrJywgJ29uQ2xpY2tDYXB0dXJlJywgJ29uQ29udGV4dE1lbnUnLCAnb25Db250ZXh0TWVudUNhcHR1cmUnLCAnb25Eb3VibGVDbGljaycsICdvbkRvdWJsZUNsaWNrQ2FwdHVyZScsICdvbkRyYWcnLCAnb25EcmFnQ2FwdHVyZScsICdvbkRyYWdFbmQnLCAnb25EcmFnRW5kQ2FwdHVyZScsICdvbkRyYWdFbnRlcicsICdvbkRyYWdFbnRlckNhcHR1cmUnLCAnb25EcmFnRXhpdCcsICdvbkRyYWdFeGl0Q2FwdHVyZScsICdvbkRyYWdMZWF2ZScsICdvbkRyYWdMZWF2ZUNhcHR1cmUnLCAnb25EcmFnT3ZlcicsICdvbkRyYWdPdmVyQ2FwdHVyZScsICdvbkRyYWdTdGFydCcsICdvbkRyYWdTdGFydENhcHR1cmUnLCAnb25Ecm9wJywgJ29uRHJvcENhcHR1cmUnLCAnb25Nb3VzZURvd24nLCAnb25Nb3VzZURvd25DYXB0dXJlJywgJ29uTW91c2VFbnRlcicsICdvbk1vdXNlTGVhdmUnLCAnb25Nb3VzZU1vdmUnLCAnb25Nb3VzZU1vdmVDYXB0dXJlJywgJ29uTW91c2VPdXQnLCAnb25Nb3VzZU91dENhcHR1cmUnLCAnb25Nb3VzZU92ZXInLCAnb25Nb3VzZU92ZXJDYXB0dXJlJywgJ29uTW91c2VVcCcsICdvbk1vdXNlVXBDYXB0dXJlJywgJ29uU2VsZWN0JywgJ29uU2VsZWN0Q2FwdHVyZScsICdvblRvdWNoQ2FuY2VsJywgJ29uVG91Y2hDYW5jZWxDYXB0dXJlJywgJ29uVG91Y2hFbmQnLCAnb25Ub3VjaEVuZENhcHR1cmUnLCAnb25Ub3VjaE1vdmUnLCAnb25Ub3VjaE1vdmVDYXB0dXJlJywgJ29uVG91Y2hTdGFydCcsICdvblRvdWNoU3RhcnRDYXB0dXJlJywgJ29uUG9pbnRlckRvd24nLCAnb25Qb2ludGVyRG93bkNhcHR1cmUnLCAnb25Qb2ludGVyTW92ZScsICdvblBvaW50ZXJNb3ZlQ2FwdHVyZScsICdvblBvaW50ZXJVcCcsICdvblBvaW50ZXJVcENhcHR1cmUnLCAnb25Qb2ludGVyQ2FuY2VsJywgJ29uUG9pbnRlckNhbmNlbENhcHR1cmUnLCAnb25Qb2ludGVyRW50ZXInLCAnb25Qb2ludGVyRW50ZXJDYXB0dXJlJywgJ29uUG9pbnRlckxlYXZlJywgJ29uUG9pbnRlckxlYXZlQ2FwdHVyZScsICdvblBvaW50ZXJPdmVyJywgJ29uUG9pbnRlck92ZXJDYXB0dXJlJywgJ29uUG9pbnRlck91dCcsICdvblBvaW50ZXJPdXRDYXB0dXJlJywgJ29uR290UG9pbnRlckNhcHR1cmUnLCAnb25Hb3RQb2ludGVyQ2FwdHVyZUNhcHR1cmUnLCAnb25Mb3N0UG9pbnRlckNhcHR1cmUnLCAnb25Mb3N0UG9pbnRlckNhcHR1cmVDYXB0dXJlJywgJ29uU2Nyb2xsJywgJ29uU2Nyb2xsQ2FwdHVyZScsICdvbldoZWVsJywgJ29uV2hlZWxDYXB0dXJlJywgJ29uQW5pbWF0aW9uU3RhcnQnLCAnb25BbmltYXRpb25TdGFydENhcHR1cmUnLCAnb25BbmltYXRpb25FbmQnLCAnb25BbmltYXRpb25FbmRDYXB0dXJlJywgJ29uQW5pbWF0aW9uSXRlcmF0aW9uJywgJ29uQW5pbWF0aW9uSXRlcmF0aW9uQ2FwdHVyZScsICdvblRyYW5zaXRpb25FbmQnLCAnb25UcmFuc2l0aW9uRW5kQ2FwdHVyZSddO1xyXG5cclxuLyoqIFRoZSB0eXBlIG9mIGVhc2luZyBmdW5jdGlvbiB0byB1c2UgZm9yIGFuaW1hdGlvbnMgKi9cclxuXHJcbi8qKiBTcGVjaWZpZXMgdGhlIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiwgdGhlIHVuaXQgb2YgdGhpcyBvcHRpb24gaXMgbXMuICovXHJcblxyXG4vKiogdGhlIG9mZnNldCBvZiBhIGNoYXJ0LCB3aGljaCBkZWZpbmUgdGhlIGJsYW5rIHNwYWNlIGFsbCBhcm91bmQgKi9cclxuXHJcbi8qKlxyXG4gKiBUaGUgZG9tYWluIG9mIGF4aXMuXHJcbiAqIFRoaXMgaXMgdGhlIGRlZmluaXRpb25cclxuICpcclxuICogTnVtZXJpYyBkb21haW4gaXMgYWx3YXlzIGRlZmluZWQgYnkgYW4gYXJyYXkgb2YgZXhhY3RseSB0d28gdmFsdWVzLCBmb3IgdGhlIG1pbiBhbmQgdGhlIG1heCBvZiB0aGUgYXhpcy5cclxuICogQ2F0ZWdvcmljYWwgZG9tYWluIGlzIGRlZmluZWQgYXMgYXJyYXkgb2YgYWxsIHBvc3NpYmxlIHZhbHVlcy5cclxuICpcclxuICogQ2FuIGJlIHNwZWNpZmllZCBpbiBtYW55IHdheXM6XHJcbiAqIC0gYXJyYXkgb2YgbnVtYmVyc1xyXG4gKiAtIHdpdGggc3BlY2lhbCBzdHJpbmdzIGxpa2UgJ2RhdGFNaW4nIGFuZCAnZGF0YU1heCdcclxuICogLSB3aXRoIHNwZWNpYWwgc3RyaW5nIG1hdGggbGlrZSAnZGF0YU1pbiAtIDEwMCdcclxuICogLSB3aXRoIGtleXdvcmQgJ2F1dG8nXHJcbiAqIC0gb3IgYSBmdW5jdGlvblxyXG4gKiAtIGFycmF5IG9mIGZ1bmN0aW9uc1xyXG4gKiAtIG9yIGEgY29tYmluYXRpb24gb2YgdGhlIGFib3ZlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE51bWJlckRvbWFpbiBpcyBhbiBldmFsdWF0ZWQge0BsaW5rIEF4aXNEb21haW59LlxyXG4gKiBVbmxpa2Uge0BsaW5rIEF4aXNEb21haW59LCBpdCBoYXMgbm8gdmFyaWV0eSAtIGl0J3MgYSB0dXBsZSBvZiB0d28gbnVtYmVyLlxyXG4gKiBUaGlzIGlzIGFmdGVyIGFsbCB0aGUga2V5d29yZHMgYW5kIGZ1bmN0aW9ucyB3ZXJlIGV2YWx1YXRlZCBhbmQgd2hhdCBpcyBsZWZ0IGlzIFttaW4sIG1heF0uXHJcbiAqXHJcbiAqIEtub3cgdGhhdCB0aGUgbWluLCBtYXggdmFsdWVzIGFyZSBub3QgZ3VhcmFudGVlZCB0byBiZSBuaWNlIG51bWJlcnMgLSB2YWx1ZXMgbGlrZSAtSW5maW5pdHkgb3IgTmFOIGFyZSBwb3NzaWJsZS5cclxuICpcclxuICogVGhlcmUgYXJlIGFsc28gYGNhdGVnb3J5YCBheGVzIHRoYXQgaGF2ZSBkaWZmZXJlbnQgdGhpbmdzIHRoYW4gbnVtYmVycyBpbiB0aGVpciBkb21haW4uXHJcbiAqL1xyXG5cclxuLyoqIFRoZSBwcm9wcyBkZWZpbml0aW9uIG9mIGJhc2UgYXhpcyAqL1xyXG5cclxuLyoqIERlZmluZXMgaG93IHRpY2tzIGFyZSBwbGFjZWQgYW5kIHdoZXRoZXIgLyBob3cgdGljayBjb2xsaXNpb25zIGFyZSBoYW5kbGVkLlxyXG4gKiAncHJlc2VydmVTdGFydCcga2VlcHMgdGhlIGxlZnQgdGljayBvbiBjb2xsaXNpb24gYW5kIGVuc3VyZXMgdGhhdCB0aGUgZmlyc3QgdGljayBpcyBhbHdheXMgc2hvd24uXHJcbiAqICdwcmVzZXJ2ZUVuZCcga2VlcHMgdGhlIHJpZ2h0IHRpY2sgb24gY29sbGlzaW9uIGFuZCBlbnN1cmVzIHRoYXQgdGhlIGxhc3QgdGljayBpcyBhbHdheXMgc2hvd24uXHJcbiAqICdwcmVzZXJ2ZVN0YXJ0RW5kJyBrZWVwcyB0aGUgbGVmdCB0aWNrIG9uIGNvbGxpc2lvbiBhbmQgZW5zdXJlcyB0aGF0IHRoZSBmaXJzdCBhbmQgbGFzdCB0aWNrcyBhcmUgYWx3YXlzIHNob3duLlxyXG4gKiAnZXF1aWRpc3RhbnRQcmVzZXJ2ZVN0YXJ0JyBzZWxlY3RzIGEgbnVtYmVyIE4gc3VjaCB0aGF0IGV2ZXJ5IG5UaCB0aWNrIHdpbGwgYmUgc2hvd24gd2l0aG91dCBjb2xsaXNpb24uXHJcbiAqL1xyXG5cclxudmFyIGFkYXB0RXZlbnRIYW5kbGVycyA9IGV4cG9ydHMuYWRhcHRFdmVudEhhbmRsZXJzID0gZnVuY3Rpb24gYWRhcHRFdmVudEhhbmRsZXJzKHByb3BzLCBuZXdIYW5kbGVyKSB7XHJcbiAgaWYgKCFwcm9wcyB8fCB0eXBlb2YgcHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHByb3BzID09PSAnYm9vbGVhbicpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICB2YXIgaW5wdXRQcm9wcyA9IHByb3BzO1xyXG4gIGlmICggLyojX19QVVJFX18qLygwLCBfcmVhY3QuaXNWYWxpZEVsZW1lbnQpKHByb3BzKSkge1xyXG4gICAgaW5wdXRQcm9wcyA9IHByb3BzLnByb3BzO1xyXG4gIH1cclxuICBpZiAoISgwLCBfaXNPYmplY3RbXCJkZWZhdWx0XCJdKShpbnB1dFByb3BzKSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHZhciBvdXQgPSB7fTtcclxuICBPYmplY3Qua2V5cyhpbnB1dFByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIGlmIChFdmVudEtleXMuaW5jbHVkZXMoa2V5KSkge1xyXG4gICAgICBvdXRba2V5XSA9IG5ld0hhbmRsZXIgfHwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICByZXR1cm4gaW5wdXRQcm9wc1trZXldKGlucHV0UHJvcHMsIGUpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBvdXQ7XHJcbn07XHJcbnZhciBnZXRFdmVudEhhbmRsZXJPZkNoaWxkID0gZnVuY3Rpb24gZ2V0RXZlbnRIYW5kbGVyT2ZDaGlsZChvcmlnaW5hbEhhbmRsZXIsIGRhdGEsIGluZGV4KSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XHJcbiAgICBvcmlnaW5hbEhhbmRsZXIoZGF0YSwgaW5kZXgsIGUpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfTtcclxufTtcclxudmFyIGFkYXB0RXZlbnRzT2ZDaGlsZCA9IGV4cG9ydHMuYWRhcHRFdmVudHNPZkNoaWxkID0gZnVuY3Rpb24gYWRhcHRFdmVudHNPZkNoaWxkKHByb3BzLCBkYXRhLCBpbmRleCkge1xyXG4gIGlmICghKDAsIF9pc09iamVjdFtcImRlZmF1bHRcIl0pKHByb3BzKSB8fCBfdHlwZW9mKHByb3BzKSAhPT0gJ29iamVjdCcpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICB2YXIgb3V0ID0gbnVsbDtcclxuICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICB2YXIgaXRlbSA9IHByb3BzW2tleV07XHJcbiAgICBpZiAoRXZlbnRLZXlzLmluY2x1ZGVzKGtleSkgJiYgdHlwZW9mIGl0ZW0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgaWYgKCFvdXQpIG91dCA9IHt9O1xyXG4gICAgICBvdXRba2V5XSA9IGdldEV2ZW50SGFuZGxlck9mQ2hpbGQoaXRlbSwgZGF0YSwgaW5kZXgpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBvdXQ7XHJcbn07Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYWRhcHRFdmVudHNPZkNoaWxkIiwiYWRhcHRFdmVudEhhbmRsZXJzIiwiU1ZHRWxlbWVudFByb3BLZXlzIiwiRmlsdGVyZWRFbGVtZW50S2V5TWFwIiwiRXZlbnRLZXlzIiwiX3JlYWN0IiwicmVxdWlyZSIsIl9pc09iamVjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsIlNWR0NvbnRhaW5lclByb3BLZXlzIiwiUG9seUVsZW1lbnRLZXlzIiwic3ZnIiwicG9seWdvbiIsInBvbHlsaW5lIiwicHJvcHMiLCJuZXdIYW5kbGVyIiwiaW5wdXRQcm9wcyIsImlzVmFsaWRFbGVtZW50Iiwib3V0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJpbmNsdWRlcyIsImUiLCJnZXRFdmVudEhhbmRsZXJPZkNoaWxkIiwib3JpZ2luYWxIYW5kbGVyIiwiZGF0YSIsImluZGV4IiwiaXRlbSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/lib/util/types.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/node_modules/react-is/cjs/react-is.development.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/recharts/node_modules/react-is/cjs/react-is.development.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\r\n * @license React\r\n * react-is.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */ \nif (true) {\n    (function() {\n        'use strict';\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for('react.element');\n        var REACT_PORTAL_TYPE = Symbol.for('react.portal');\n        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\n        var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\n        var REACT_PROFILER_TYPE = Symbol.for('react.profiler');\n        var REACT_PROVIDER_TYPE = Symbol.for('react.provider');\n        var REACT_CONTEXT_TYPE = Symbol.for('react.context');\n        var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\n        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\n        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\n        var REACT_MEMO_TYPE = Symbol.for('react.memo');\n        var REACT_LAZY_TYPE = Symbol.for('react.lazy');\n        var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n        var REACT_MODULE_REFERENCE;\n        {\n            REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n        }\n        function isValidElementType(type) {\n            if (typeof type === 'string' || typeof type === 'function') {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === 'object' && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function typeOf(object) {\n            if (typeof object === 'object' && object !== null) {\n                var $$typeof = object.$$typeof;\n                switch($$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        var type = object.type;\n                        switch(type){\n                            case REACT_FRAGMENT_TYPE:\n                            case REACT_PROFILER_TYPE:\n                            case REACT_STRICT_MODE_TYPE:\n                            case REACT_SUSPENSE_TYPE:\n                            case REACT_SUSPENSE_LIST_TYPE:\n                                return type;\n                            default:\n                                var $$typeofType = type && type.$$typeof;\n                                switch($$typeofType){\n                                    case REACT_SERVER_CONTEXT_TYPE:\n                                    case REACT_CONTEXT_TYPE:\n                                    case REACT_FORWARD_REF_TYPE:\n                                    case REACT_LAZY_TYPE:\n                                    case REACT_MEMO_TYPE:\n                                    case REACT_PROVIDER_TYPE:\n                                        return $$typeofType;\n                                    default:\n                                        return $$typeof;\n                                }\n                        }\n                    case REACT_PORTAL_TYPE:\n                        return $$typeof;\n                }\n            }\n            return undefined;\n        }\n        var ContextConsumer = REACT_CONTEXT_TYPE;\n        var ContextProvider = REACT_PROVIDER_TYPE;\n        var Element = REACT_ELEMENT_TYPE;\n        var ForwardRef = REACT_FORWARD_REF_TYPE;\n        var Fragment = REACT_FRAGMENT_TYPE;\n        var Lazy = REACT_LAZY_TYPE;\n        var Memo = REACT_MEMO_TYPE;\n        var Portal = REACT_PORTAL_TYPE;\n        var Profiler = REACT_PROFILER_TYPE;\n        var StrictMode = REACT_STRICT_MODE_TYPE;\n        var Suspense = REACT_SUSPENSE_TYPE;\n        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;\n        var hasWarnedAboutDeprecatedIsAsyncMode = false;\n        var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated\n        function isAsyncMode(object) {\n            {\n                if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n                    hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n                    console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');\n                }\n            }\n            return false;\n        }\n        function isConcurrentMode(object) {\n            {\n                if (!hasWarnedAboutDeprecatedIsConcurrentMode) {\n                    hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint\n                    console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');\n                }\n            }\n            return false;\n        }\n        function isContextConsumer(object) {\n            return typeOf(object) === REACT_CONTEXT_TYPE;\n        }\n        function isContextProvider(object) {\n            return typeOf(object) === REACT_PROVIDER_TYPE;\n        }\n        function isElement(object) {\n            return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n        }\n        function isForwardRef(object) {\n            return typeOf(object) === REACT_FORWARD_REF_TYPE;\n        }\n        function isFragment(object) {\n            return typeOf(object) === REACT_FRAGMENT_TYPE;\n        }\n        function isLazy(object) {\n            return typeOf(object) === REACT_LAZY_TYPE;\n        }\n        function isMemo(object) {\n            return typeOf(object) === REACT_MEMO_TYPE;\n        }\n        function isPortal(object) {\n            return typeOf(object) === REACT_PORTAL_TYPE;\n        }\n        function isProfiler(object) {\n            return typeOf(object) === REACT_PROFILER_TYPE;\n        }\n        function isStrictMode(object) {\n            return typeOf(object) === REACT_STRICT_MODE_TYPE;\n        }\n        function isSuspense(object) {\n            return typeOf(object) === REACT_SUSPENSE_TYPE;\n        }\n        function isSuspenseList(object) {\n            return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\n        }\n        exports.ContextConsumer = ContextConsumer;\n        exports.ContextProvider = ContextProvider;\n        exports.Element = Element;\n        exports.ForwardRef = ForwardRef;\n        exports.Fragment = Fragment;\n        exports.Lazy = Lazy;\n        exports.Memo = Memo;\n        exports.Portal = Portal;\n        exports.Profiler = Profiler;\n        exports.StrictMode = StrictMode;\n        exports.Suspense = Suspense;\n        exports.SuspenseList = SuspenseList;\n        exports.isAsyncMode = isAsyncMode;\n        exports.isConcurrentMode = isConcurrentMode;\n        exports.isContextConsumer = isContextConsumer;\n        exports.isContextProvider = isContextProvider;\n        exports.isElement = isElement;\n        exports.isForwardRef = isForwardRef;\n        exports.isFragment = isFragment;\n        exports.isLazy = isLazy;\n        exports.isMemo = isMemo;\n        exports.isPortal = isPortal;\n        exports.isProfiler = isProfiler;\n        exports.isStrictMode = isStrictMode;\n        exports.isSuspense = isSuspense;\n        exports.isSuspenseList = isSuspenseList;\n        exports.isValidElementType = isValidElementType;\n        exports.typeOf = typeOf;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDLEdBRVk7QUFFYixJQUFJQSxJQUFxQyxFQUFFO0lBQ3hDO1FBQ0g7UUFFQSxZQUFZO1FBQ1osd0NBQXdDO1FBQ3hDLGtGQUFrRjtRQUNsRixzREFBc0Q7UUFDdEQsSUFBSUMscUJBQXFCQyxPQUFPQyxHQUFHLENBQUM7UUFDcEMsSUFBSUMsb0JBQW9CRixPQUFPQyxHQUFHLENBQUM7UUFDbkMsSUFBSUUsc0JBQXNCSCxPQUFPQyxHQUFHLENBQUM7UUFDckMsSUFBSUcseUJBQXlCSixPQUFPQyxHQUFHLENBQUM7UUFDeEMsSUFBSUksc0JBQXNCTCxPQUFPQyxHQUFHLENBQUM7UUFDckMsSUFBSUssc0JBQXNCTixPQUFPQyxHQUFHLENBQUM7UUFDckMsSUFBSU0scUJBQXFCUCxPQUFPQyxHQUFHLENBQUM7UUFDcEMsSUFBSU8sNEJBQTRCUixPQUFPQyxHQUFHLENBQUM7UUFDM0MsSUFBSVEseUJBQXlCVCxPQUFPQyxHQUFHLENBQUM7UUFDeEMsSUFBSVMsc0JBQXNCVixPQUFPQyxHQUFHLENBQUM7UUFDckMsSUFBSVUsMkJBQTJCWCxPQUFPQyxHQUFHLENBQUM7UUFDMUMsSUFBSVcsa0JBQWtCWixPQUFPQyxHQUFHLENBQUM7UUFDakMsSUFBSVksa0JBQWtCYixPQUFPQyxHQUFHLENBQUM7UUFDakMsSUFBSWEsdUJBQXVCZCxPQUFPQyxHQUFHLENBQUM7UUFFdEMsZ0ZBQWdGO1FBRWhGLElBQUljLGlCQUFpQixPQUFPLHdDQUF3QztRQUNwRSxJQUFJQyxxQkFBcUI7UUFDekIsSUFBSUMsMEJBQTBCLE9BQU8sK0NBQStDO1FBRXBGLElBQUlDLHFCQUFxQixPQUFPLHNEQUFzRDtRQUN0RiwrRUFBK0U7UUFDL0Usd0JBQXdCO1FBRXhCLElBQUlDLHFCQUFx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aUJBQWlCLEdBQUdWO1FBQ3BCVSxvQkFBb0IsR0FBR1Q7UUFDdkJTLGtCQUFrQixHQUFHUjtRQUNyQlEsY0FBYyxHQUFHUDtRQUNqQk8sY0FBYyxHQUFHTjtRQUNqQk0sZ0JBQWdCLEdBQUdMO1FBQ25CSyxrQkFBa0IsR0FBR0o7UUFDckJJLG9CQUFvQixHQUFHSDtRQUN2Qkcsa0JBQWtCLEdBQUdGO1FBQ3JCRSxzQkFBc0IsR0FBR0Q7UUFDekJDLDBCQUEwQixHQUFHckM7UUFDN0JxQyxjQUFjLEdBQUdoQztJQUNmO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxEb19hbjJcXGxlbmRodWJfdjJcXGxlbmRodWItZnJvbnRlbmQtbmV4dGpzXFxub2RlX21vZHVsZXNcXHJlY2hhcnRzXFxub2RlX21vZHVsZXNcXHJlYWN0LWlzXFxjanNcXHJlYWN0LWlzLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbGljZW5zZSBSZWFjdFxyXG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgKGZ1bmN0aW9uKCkge1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vLyBBVFRFTlRJT05cclxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxyXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXHJcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxyXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xyXG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcclxudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xyXG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XHJcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcclxudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xyXG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xyXG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNlcnZlcl9jb250ZXh0Jyk7XHJcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcclxudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xyXG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xyXG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xyXG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xyXG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxyXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XHJcbnZhciBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyA9IGZhbHNlOyAvLyBObyBrbm93biBidWdzLCBidXQgbmVlZHMgcGVyZm9ybWFuY2UgdGVzdGluZ1xyXG5cclxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcclxuLy8gc3R1ZmYuIEludGVuZGVkIHRvIGVuYWJsZSBSZWFjdCBjb3JlIG1lbWJlcnMgdG8gbW9yZSBlYXNpbHkgZGVidWcgc2NoZWR1bGluZ1xyXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cclxuXHJcbnZhciBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTsgLy8gVHJhY2sgd2hpY2ggRmliZXIocykgc2NoZWR1bGUgcmVuZGVyIHdvcmsuXHJcblxyXG52YXIgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRTtcclxuXHJcbntcclxuICBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QubW9kdWxlLnJlZmVyZW5jZScpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xyXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cclxuXHJcblxyXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xyXG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XHJcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXHJcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcclxuICAgIC8vIHdpdGguXHJcbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xyXG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcclxuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcclxuXHJcbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XHJcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxyXG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XHJcblxyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxyXG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxyXG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxyXG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxyXG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xyXG5cclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHZhciAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xyXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRTpcclxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcclxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XHJcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XHJcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XHJcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcclxuXHJcbiAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxyXG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxudmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcclxudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XHJcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xyXG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XHJcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XHJcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xyXG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcclxudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xyXG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xyXG52YXIgU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XHJcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XHJcbnZhciBTdXNwZW5zZUxpc3QgPSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU7XHJcbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlO1xyXG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNDb25jdXJyZW50TW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcclxuXHJcbmZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xyXG4gIHtcclxuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcclxuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxyXG5cclxuICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxOCsuJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcclxuICB7XHJcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQ29uY3VycmVudE1vZGUpIHtcclxuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNDb25jdXJyZW50TW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XHJcblxyXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTgrLicpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcclxufVxyXG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcclxufVxyXG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XHJcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xyXG59XHJcbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XHJcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xyXG59XHJcbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcclxuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcclxufVxyXG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XHJcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XHJcbn1cclxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XHJcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcclxufVxyXG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcclxufVxyXG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XHJcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xyXG59XHJcbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XHJcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xyXG59XHJcbmZ1bmN0aW9uIGlzU3VzcGVuc2VMaXN0KG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFO1xyXG59XHJcblxyXG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcclxuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XHJcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XHJcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XHJcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcclxuZXhwb3J0cy5MYXp5ID0gTGF6eTtcclxuZXhwb3J0cy5NZW1vID0gTWVtbztcclxuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XHJcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcclxuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcclxuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xyXG5leHBvcnRzLlN1c3BlbnNlTGlzdCA9IFN1c3BlbnNlTGlzdDtcclxuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xyXG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xyXG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XHJcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcclxuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XHJcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xyXG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xyXG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcclxuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XHJcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcclxuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcclxuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XHJcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XHJcbmV4cG9ydHMuaXNTdXNwZW5zZUxpc3QgPSBpc1N1c3BlbnNlTGlzdDtcclxuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XHJcbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xyXG4gIH0pKCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9PRkZTQ1JFRU5fVFlQRSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwidHlwZSIsIiQkdHlwZW9mIiwiZ2V0TW9kdWxlSWQiLCJ1bmRlZmluZWQiLCJ0eXBlT2YiLCJvYmplY3QiLCIkJHR5cGVvZlR5cGUiLCJDb250ZXh0Q29uc3VtZXIiLCJDb250ZXh0UHJvdmlkZXIiLCJFbGVtZW50IiwiRm9yd2FyZFJlZiIsIkZyYWdtZW50IiwiTGF6eSIsIk1lbW8iLCJQb3J0YWwiLCJQcm9maWxlciIsIlN0cmljdE1vZGUiLCJTdXNwZW5zZSIsIlN1c3BlbnNlTGlzdCIsImhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlIiwiaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNDb25jdXJyZW50TW9kZSIsImlzQXN5bmNNb2RlIiwiY29uc29sZSIsImlzQ29uY3VycmVudE1vZGUiLCJpc0NvbnRleHRDb25zdW1lciIsImlzQ29udGV4dFByb3ZpZGVyIiwiaXNFbGVtZW50IiwiaXNGb3J3YXJkUmVmIiwiaXNGcmFnbWVudCIsImlzTGF6eSIsImlzTWVtbyIsImlzUG9ydGFsIiwiaXNQcm9maWxlciIsImlzU3RyaWN0TW9kZSIsImlzU3VzcGVuc2UiLCJpc1N1c3BlbnNlTGlzdCIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/node_modules/react-is/cjs/react-is.development.js\n");

/***/ }),

/***/ "(pages-dir-node)/./node_modules/recharts/node_modules/react-is/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/recharts/node_modules/react-is/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"(pages-dir-node)/./node_modules/recharts/node_modules/react-is/cjs/react-is.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxLQUFxQyxFQUFFLEVBRTFDLE1BQU07SUFDTEMsdUtBQXlEO0FBQzNEIiwic291cmNlcyI6WyJEOlxcRG9fYW4yXFxsZW5kaHViX3YyXFxsZW5kaHViLWZyb250ZW5kLW5leHRqc1xcbm9kZV9tb2R1bGVzXFxyZWNoYXJ0c1xcbm9kZV9tb2R1bGVzXFxyZWFjdC1pc1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzJyk7XHJcbn0gZWxzZSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./node_modules/recharts/node_modules/react-is/index.js\n");

/***/ })

};
;